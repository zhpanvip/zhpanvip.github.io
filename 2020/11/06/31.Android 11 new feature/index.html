

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="zhangpan">
  <meta name="keywords" content="">
  <title>Android 11新特性汇总 - zhangpan&#39;s blog</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.5.3/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.1.2/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->

  
<link rel="stylesheet" href="//at.alicdn.com/t/font_2048617_el7rbx5279a.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","version":"1.8.7","typing":{"enable":true,"typeSpeed":50,"cursorChar":"|","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":200}},"copy_btn":true,"image_zoom":{"enable":true},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"onlypost":false},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.1.1"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>我赌一包辣条</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友链
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('https://raw.githubusercontent.com/zhpanvip/images/master/blog/article.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="Android 11新特性汇总">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2020-11-06 16:15" pubdate>
        2020年11月6日 下午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      7.1k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      41
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Android 11新特性汇总</h1>
            
            <div class="markdown-body">
              <p>本文内容来自公司项目适配Android-11的调研，内容未加整理。</p>
<h1 id="以-Android-11-为目标平台的应用"><a href="#以-Android-11-为目标平台的应用" class="headerlink" title="以 Android 11 为目标平台的应用"></a>以 Android 11 为目标平台的应用</h1><p>只有指定了targetVersion=30时需要适配一下内容.</p>
<h3 id="1-存储与访问机制变更"><a href="#1-存储与访问机制变更" class="headerlink" title="1.存储与访问机制变更"></a>1.存储与访问机制变更</h3><p>Android 中存储可以分为两大类：私有存储和共享存储</p>
<ul>
<li>私有存储 (Private Storage) : 每个应用在都拥有自己的私有目录，其它应用看不到，彼此也无法访问到该目录：<ul>
<li>内部存储私有目录<code> (/data/data/packageName)</code> ；</li>
<li>外部存储私有目录 <code>(/sdcard/Android/data/packageName)</code>，</li>
</ul>
</li>
<li>共享存储 (Shared Storage) : 存储其他应用可访问文件， 包含媒体文件、文档文件以及其他文件，对应设备DCIM、Pictures、Alarms、Music、Notifications、Podcasts、Ringtones、Movies、Download等目录。</li>
</ul>
<h4 id="1-分区存储强制执行"><a href="#1-分区存储强制执行" class="headerlink" title="(1) 分区存储强制执行"></a>(1) 分区存储强制执行</h4><blockquote>
<p>安卓10中设置requestLegacyExternalStorage为true来修改外部存储空间视图模型（true为 Legacy View，false 为 Filtered View）但是<strong>当您将应用更新为以 Android 11 为目标平台后，将无法使用 <code>requestLegacyExternalStorage</code> 来停用分区存储。</strong></p>
</blockquote>
<p>分区存储是指应用对于文件的读写只能在沙盒环境中进行，对于读取媒体文件可以通过MediaStore进行访问。分区存储在Android10中已经开始推行。但在Android10中并没有强制分区存储，在targetSdkVersion = 29的情况下可以通过 ：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">android:requestLegacyExternalStorage=&quot;true&quot;<br></code></pre></td></tr></table></figure>

<p>设置不强制启动分区存储。从Android11开始，分区存储变为强制执行，当设置了targetSdkVersion = 30，则会强制开启分区存储。但是为了安全，Google提供了以下配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">android:preserveLegacyExternalStorage=&quot;true&quot;<br></code></pre></td></tr></table></figure>

<p>在覆盖安装的时候可以暂时关闭分区存储。</p>
<p><strong>1)访问专属目录</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><br><span class="hljs-comment">//分区存储空间</span><br><span class="hljs-keyword">val</span> file = File(context.filesDir, filename)<br><br><span class="hljs-comment">//应用专属外部存储空间</span><br><span class="hljs-keyword">val</span> appSpecificExternalDir = File(context.getExternalFilesDir(), filename)<br><br></code></pre></td></tr></table></figure>

<p><strong>2)访问公共媒体目录</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><br><span class="hljs-keyword">val</span> cursor = contentResolver.query(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">&quot;<span class="hljs-subst">$&#123;MediaStore.MediaColumns.DATE_ADDED&#125;</span> desc&quot;</span>)<br><span class="hljs-keyword">if</span> (cursor != <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">while</span> (cursor.moveToNext()) &#123;<br>        <span class="hljs-keyword">val</span> id = cursor.getLong(cursor.getColumnIndexOrThrow(MediaStore.MediaColumns._ID))<br>        <span class="hljs-keyword">val</span> uri = ContentUris.withAppendedId(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, id)<br>        println(<span class="hljs-string">&quot;image uri is <span class="hljs-variable">$uri</span>&quot;</span>)<br>    &#125;<br>    cursor.close()<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>Environment.getExternalStoragePublicDirectory(“”)方法在Android11中已被弃用，使用该方法会导致程序报错。</p>
<h4 id="2-SAF访问框架（Storage-Access-Framework"><a href="#2-SAF访问框架（Storage-Access-Framework" class="headerlink" title="(2) SAF访问框架（Storage Access Framework)"></a>(2) SAF访问框架（Storage Access Framework)</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> intent = Intent(Intent.ACTION_OPEN_DOCUMENT)<br>  intent.addCategory(Intent.CATEGORY_OPENABLE)<br>  intent.type = <span class="hljs-string">&quot;image/*&quot;</span><br>  startActivityForResult(intent, <span class="hljs-number">100</span>)<br><br>  <span class="hljs-meta">@RequiresApi(Build.VERSION_CODES.KITKAT)</span><br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onActivityResult</span><span class="hljs-params">(requestCode: <span class="hljs-type">Int</span>, resultCode: <span class="hljs-type">Int</span>, <span class="hljs-keyword">data</span>: <span class="hljs-type">Intent</span>?)</span></span> &#123;<br>      <span class="hljs-keyword">super</span>.onActivityResult(requestCode, resultCode, <span class="hljs-keyword">data</span>)<br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">data</span> == <span class="hljs-literal">null</span> || resultCode != Activity.RESULT_OK) <span class="hljs-keyword">return</span><br>      <span class="hljs-keyword">if</span> (requestCode == <span class="hljs-number">100</span>) &#123;<br>          <span class="hljs-keyword">val</span> uri = <span class="hljs-keyword">data</span>.<span class="hljs-keyword">data</span><br>          println(<span class="hljs-string">&quot;image uri is <span class="hljs-variable">$uri</span>&quot;</span>)<br>      &#125;<br>  &#125;<br></code></pre></td></tr></table></figure>

<p>同时，Android11中还提供了两个Intent入口：</p>
<ul>
<li><p>调用<code>ACTION_MANAGE_STORAGE intent</code> 操作检查可用空间。</p>
</li>
<li><p>调用<code>ACTION_CLEAR_APP_CACHE intent</code> 操作清除所有缓存。</p>
</li>
</ul>
<p>对于像手机管理器的APP可以通过这两个Intent管理APP的缓存。</p>
<h4 id="3-所有文件访问权限"><a href="#3-所有文件访问权限" class="headerlink" title="(3) 所有文件访问权限"></a>(3) 所有文件访问权限</h4><blockquote>
<p>针对文件管理器以及一些备份类的应用，它们需要获得共享存储的更广泛的访问权限。Android 11 里将会引入一个特别的权限叫做 <strong>MANAGE_EXTERNAL_STORAGE</strong>，该权限将授权读写所有共享存储内容，这也将同时包含非媒体类型的文件。但是获得这个权限的应用还是<strong>无法访问</strong>其他应用的应用专属目录 (app-specific directory)，无论是外部存储还是内部存储。</p>
</blockquote>
<p>使用MANAGE_EXTERNAL_STORAGE权限：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.MANAGE_EXTERNAL_STORAGE&quot;</span> /&gt;</span>     <br></code></pre></td></tr></table></figure>



<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><br><span class="hljs-keyword">val</span> intent = Intent()    <br><br>intent.action= Settings.ACTION_MANAGE_ALL_FILES_ACCESS_PERMISSION    <br><br>startActivity(intent)     <span class="hljs-comment">//判断是否获取MANAGE_EXTERNAL_STORAGE权限：    </span><br><br><span class="hljs-keyword">val</span> isHasStoragePermission= Environment.isExternalStorageManager()<br><br></code></pre></td></tr></table></figure>

<h4 id="4-媒体文件访问权限"><a href="#4-媒体文件访问权限" class="headerlink" title="(4) 媒体文件访问权限"></a>(4) 媒体文件访问权限</h4><blockquote>
<p>Android 10 中要求所有应用都使用 MediaStore API 来访问照片、视频和音乐文件，我们也将继续秉承这个原则。但是我们也知道，很多深度依赖基于原始文件路径 API 的应用和第三方库是很难切换到使用文件描述符 (File Descriptor) 的。因此在 Android 11 里，依赖原始文件路径的 API 和库<a href="https://link.zhihu.com/?target=https://developer.android.google.cn/preview/privacy/storage%23media-files-raw-paths">可以再次使用</a>了。您需要在应用的 Manifest 文件里添加 requestLegacyExternalStorage 属性，以保证 Android 10 的用户也可以使用该特性。</p>
<p>在实际的运行中，依赖原始文件路径的 I/O 请求会被重定向到使用 MediaStore API，当使用这种方式访问本应用存储空间之外的文件时，这次重定向会造成性能影响。而且直接使用原始文件路径，并不会比使用 MediaStore API 有更多优势，因此我们强烈建议直接使用 MediaStore API。</p>
<p>在 Android 10 中，应用在对每一个文件请求编辑或删除时都必须得到用户的确认。而在 Android 11 中，应用可以一次请求<a href="https://link.zhihu.com/?target=https://developer.android.com/preview/privacy/storage%23media-file-access">修改或者删除多个媒体文件</a>。系统的默认图库应用 (Gallery) 将不再展示这些对话框。我们希望这项改进能够使用户体验更加顺畅。</p>
</blockquote>
<p><strong>1) 执行批量操作</strong></p>
<p>Android 11 向 <code>MediaStore API</code> 中添加了多种方法，用于简化特定媒体文件更改流程（例如在原位置编辑照片），分别是：</p>
<ul>
<li><p><code> createWriteRequest()</code> 用户向应用授予对指定媒体文件组的写入访问权限的请求。</p>
</li>
<li><p><code>createFavoriteRequest()</code>用户将设备上指定的媒体文件标记为“收藏”的请求。对该文件具有读取访问权限的任何应用都可以看到用户已将该文件标记为“收藏”。</p>
</li>
<li><p>createTrashRequest()用户将指定的媒体文件放入设备垃圾箱的请求。垃圾箱中的内容会在系统定义的时间段后被永久删除。</p>
</li>
<li><p>createDeleteRequest()用户立即永久删除指定的媒体文件（而不是先将其放入垃圾箱）的请求。</p>
</li>
</ul>
<p>例如：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> urisToModify = listOf(uri,uri,...)<br><span class="hljs-keyword">val</span> editPendingIntent = MediaStore.createWriteRequest(contentResolver,<br>        urisToModify)<br><br><span class="hljs-comment">// Launch a system prompt requesting user permission for the operation.</span><br>startIntentSenderForResult(editPendingIntent.intentSender, EDIT_REQUEST_CODE,<br>    <span class="hljs-literal">null</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<br><br><br><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onActivityResult</span><span class="hljs-params">(requestCode: <span class="hljs-type">Int</span>, resultCode: <span class="hljs-type">Int</span>,</span></span><br><span class="hljs-function"><span class="hljs-params">                 <span class="hljs-keyword">data</span>: <span class="hljs-type">Intent</span>?)</span></span> &#123;<br>    <span class="hljs-keyword">when</span> (requestCode) &#123;<br>        EDIT_REQUEST_CODE -&gt;<br>            <span class="hljs-keyword">if</span> (resultCode == Activity.RESULT_OK) &#123;<br>                <span class="hljs-comment">/* Edit request granted; proceed. */</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">/* Edit request not granted; explain to the user. */</span><br>            &#125;<br>    &#125;<br>&#125;    <br><br></code></pre></td></tr></table></figure>

<p><strong>2）直接文件路径和原生库访问文件</strong></p>
<p>Android11又恢复了使用<code>直接文件路径</code>访问访问媒体文件！也就是除了 <code>MediaStore API</code>之外还有两种方式可以访问媒体文件：</p>
<ul>
<li>File API。</li>
<li>原生库，例如 fopen()。</li>
</ul>
<h4 id="5-文档访问权限"><a href="#5-文档访问权限" class="headerlink" title="(5) 文档访问权限"></a>(5) 文档访问权限</h4><p>在分区存储权限中说过可以使用SAF来访问公共目录，但Android11中部分目录不能访问，如下：</p>
<p>无法再使用 <code>ACTION_OPEN_DOCUMENT_TREE intent</code> 操作请求访问以下目录：</p>
<ul>
<li>内部存储卷的根目录。</li>
<li>设备制造商认为可靠的各个 SD 卡卷的根目录，无论该卡是模拟卡还是可移除的卡。可靠的卷是指应用在大多数情况下可以成功访问的卷。</li>
<li>Download 目录。</li>
</ul>
<p>无法再使用 <code>ACTION_OPEN_DOCUMENT_TREE</code> 或 <code>ACTION_OPEN_DOCUMENT intent</code> 操作请求用户从以下目录中选择单独的文件：</p>
<ul>
<li>Android/data/ 目录及其所有子目录。</li>
<li>Android/obb/ 目录及其所有子目录。</li>
</ul>
<h3 id="2-位置权限更新"><a href="#2-位置权限更新" class="headerlink" title="2.位置权限更新"></a>2.位置权限更新</h3><h4 id="1-单次访问权限"><a href="#1-单次访问权限" class="headerlink" title="(1)单次访问权限"></a>(1)单次访问权限</h4><blockquote>
<p>在 Android 11 及更高版本中，每当应用请求在前台访问位置信息时，系统权限对话框都包含一个名为<strong>仅限这一次</strong>的选项。通过这一选项，用户可以更好地控制应用何时有权访问位置信息。</p>
</blockquote>
<p>####(2) 在后台访问位置信息的权限</p>
<blockquote>
<p>Android 11 更改了应用中的功能获取后台位置信息访问权限的方式。</p>
</blockquote>
<p>（1）从Android10系统开始，需要申请后台位置权限（ACCESS_BACKGROUND_LOCATION），并且只有用户点了始终允许之后才能获得后台位置权限。Android11设备上对于后台位置权限再次收紧，表现在系统对话框上不在提示始终允许字样，而是提供了位置权限设置入口，需要用户到设置页面允许后才能获得后台位置权限。</p>
<p>（2）在targetVersion小于30时候，可以前台位置权限与后台位置权限一起申请，并且对话框提供了文字说明，表示需要随时获取用户位置信息。，进入设置选择始终允许即可。但targetVersion设置为30时，必须单独申请后台位置权限，而且必须在获取前台位置权限之后，并且无任何提示，需要开发者自行设置提示样式。</p>
<h3 id="3-电话号码相关权限"><a href="#3-电话号码相关权限" class="headerlink" title="3.电话号码相关权限"></a>3.电话号码相关权限</h3><blockquote>
<p>Android11更改了读取电话号码时与电话相关的权限。如果您的应用以 Android 11 为目标平台，并且需要访问以下列表中显示的电话号码 API，则必须请求 <code>READ_PHONE_NUMBERS</code>权限，而不是 <code>READ_PHONE_STATE</code> 权限。</p>
</blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://developer.android.com/reference/kotlin/android/telephony/TelephonyManager?hl=zh-cn#getline1number"><code>TelephonyManager</code></a> 类和 <a target="_blank" rel="noopener" href="https://developer.android.com/reference/kotlin/android/telecom/TelecomManager?hl=zh-cn#getline1number"><code>TelecomManager</code></a> <code>getLine1Number()</code> 方法</li>
<li><a target="_blank" rel="noopener" href="https://developer.android.com/reference/kotlin/android/telephony/TelephonyManager?hl=zh-cn"><code>TelephonyManager</code></a> 类中的 <code>getMsisdn()</code> 方法</li>
</ul>
<p>也就是当用到这两个API的时候，原来的<code>READ_PHONE_STATE</code>权限不管用了，需要<code>READ_PHONE_NUMBERS</code>权限才行。</p>
<p>需要做的改动：</p>
<ol>
<li>更改 <code>READ_PHONE_STATE</code> 的声明，以使您的应用仅在 Android 10（API 级别 29）及更低版本中使用该权限。</li>
<li>添加 <code>READ_PHONE_NUMBERS</code> 权限。</li>
</ol>
<p>清单文件配置如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><br><span class="hljs-tag">&lt;<span class="hljs-name">manifest</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- Grants the READ_PHONE_STATE permission only on devices that run</span><br><span class="hljs-comment">         Android 10 (API level 29) and lower. --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;READ_PHONE_STATE&quot;</span></span><br><span class="hljs-tag">                     <span class="hljs-attr">android:maxSdkVersion</span>=<span class="hljs-string">&quot;29&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;READ_PHONE_NUMBERS&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">manifest</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h3 id="4-自动重置权限"><a href="#4-自动重置权限" class="headerlink" title="4.自动重置权限"></a>4.自动重置权限</h3><p>如果用户几个月未与应用互动，系统会自动重置应用的敏感权限。</p>
<blockquote>
<p>如果应用以 Android 11 为目标平台并且数月未使用，系统会通过自动重置用户已授予应用的运行时敏感权限来保护用户数据。此操作与用户在系统设置中查看权限并将应用的访问权限级别更改为拒绝的做法效果一样。如果应用已遵循有关在运行时请求权限的最佳做法，那么您不必对应用进行任何更改。这是因为，当用户与应用中的功能互动时，您应该会验证相关功能是否具有所需权限。</p>
</blockquote>
<p><strong>请求用户停用自动重置功能</strong></p>
<p>如果需要，您可以要求用户阻止系统重置应用的权限。如果用户希望应用主要在后台运行，即使用户不与应用互动，应用也能正常工作，那么此做法就非常有用。</p>
<h3 id="5-应用打包与安装"><a href="#5-应用打包与安装" class="headerlink" title="5.应用打包与安装"></a>5.应用打包与安装</h3><h4 id="1-压缩的资源文件"><a href="#1-压缩的资源文件" class="headerlink" title="(1) 压缩的资源文件"></a>(1) 压缩的资源文件</h4><blockquote>
<p>如果以 Android 11（API 级别 30）或更高版本为目标平台的应用包含压缩的 <code>resources.arsc</code> 文件或者如果此文件未按 4 字节边界对齐，应用将无法安装。如果存在其中任意一种情况，系统将无法对此文件进行内存映射。无法进行内存映射的资源表必须读入 RAM 中的缓冲区，从而给系统造成不必要的内存压力，并大大增加设备的 RAM 使用量。</p>
</blockquote>
<h4 id="2-需要使用V2签名"><a href="#2-需要使用V2签名" class="headerlink" title="(2) 需要使用V2签名"></a>(2) 需要使用V2签名</h4><p>对于以 Android 11（API 级别 30）为目标平台，且目前仅使用 APK 签名方案 v1 签名的应用，现在还必须使用 APK 签名方案 v2或更高版本进行签名。用户无法在搭载 Android 11 的设备上安装或更新仅通过 APK 签名方案 v1 签名的应用。</p>
<h3 id="6-软件包可见性"><a href="#6-软件包可见性" class="headerlink" title="6.软件包可见性"></a>6.软件包可见性</h3><p>当应用查询设备上已安装应用的列表时，系统会过滤返回的列表。</p>
<blockquote>
<p>Android 11 更改了应用查询用户已在设备上安装的其他应用以及与之交互的方式。使用新的  元素，应用可以定义一组自身可访问的其他应用。通过告知系统应向您的应用显示哪些其他应用，此元素有助于鼓励最小权限原则。此外，此元素还可帮助 Google Play 等应用商店评估应用为用户提供的隐私权和安全性。</p>
</blockquote>
<p>也就是说，<code>Android11中</code>，如果你想去获取其他应用的信息，比如包名，名称等等，不能直接获取了，必须在清单文件中添加<code>&lt;queries&gt;</code>元素，告知系统你要获取哪些应用信息或者哪一类应用。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><br><span class="hljs-keyword">val</span> pm = <span class="hljs-keyword">this</span>.packageManager<br>   <span class="hljs-keyword">val</span> listAppcations: List&lt;ApplicationInfo&gt; = pm<br>           .getInstalledApplications(PackageManager.GET_META_DATA)<br>   <span class="hljs-keyword">for</span> (app <span class="hljs-keyword">in</span> listAppcations) &#123;<br>       Log.e(<span class="hljs-string">&quot;lz&quot;</span>,app.packageName)<br>   &#125;<br><br></code></pre></td></tr></table></figure>

<p>上述代码在Android11上只能获取到自己APP的信息，查询不到其他应用信息。如果需要查询其他APP，需要添加<queries>元素，有两种方式：</p>
<p>（1）元素中加入具体包名</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><br><span class="hljs-tag">&lt;<span class="hljs-name">manifest</span> <span class="hljs-attr">package</span>=<span class="hljs-string">&quot;com.example.game&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">queries</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">package</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;com.example.store&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">package</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;com.example.services&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">queries</span>&gt;</span><br>    ...<br><span class="hljs-tag">&lt;/<span class="hljs-name">manifest</span>&gt;</span><br><br></code></pre></td></tr></table></figure>

<p>（2）元素中加入固定过滤的<code>intent</code></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">manifest</span> <span class="hljs-attr">package</span>=<span class="hljs-string">&quot;com.example.game&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">queries</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">intent</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">action</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.intent.action.SEND&quot;</span> /&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">data</span> <span class="hljs-attr">android:mimeType</span>=<span class="hljs-string">&quot;image/jpeg&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">intent</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">queries</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">manifest</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>同时，Google还添加了QUERY_ALL_PACKAGES的权限，需要在清单文件中加入该权限后可以获取到APP的所有应用列表。</p>
<h3 id="7-5G功能支持"><a href="#7-5G功能支持" class="headerlink" title="7. 5G功能支持"></a>7. 5G功能支持</h3><h4 id="1-针对-5G-的模拟器支持"><a href="#1-针对-5G-的模拟器支持" class="headerlink" title="(1) 针对 5G 的模拟器支持"></a>(1) 针对 5G 的模拟器支持</h4><blockquote>
<p>Android 11 添加了 <a target="_blank" rel="noopener" href="https://developer.android.com/about/versions/11/features/5g">5G API</a>，使您的应用能够添加各种先进的功能。如需在添加这些功能时对其进行测试，您可以使用 <a target="_blank" rel="noopener" href="https://developer.android.com/studio/run/emulator">Android SDK 模拟器</a>的新功能。这项新功能是在模拟器版本 30.0.22 中添加的。选择 5G 网络设置可将 <a target="_blank" rel="noopener" href="https://developer.android.com/reference/android/telephony/TelephonyDisplayInfo"><code>TelephonyDisplayInfo</code></a> 设为 <a target="_blank" rel="noopener" href="https://developer.android.com/reference/android/telephony/TelephonyDisplayInfo#OVERRIDE_NETWORK_TYPE_NR_NSA"><code>OVERRIDE_NETWORK_TYPE_NR_NSA</code></a>，修改带宽估算值，还允许您设置按流量计费性，以验证您的应用是否会对 <a target="_blank" rel="noopener" href="https://developer.android.com/reference/android/net/NetworkCapabilities#NET_CAPABILITY_TEMPORARILY_NOT_METERED"><code>NET_CAPABILITY_TEMPORARILY_NOT_METERED</code></a> 状态的变化做出适当的响应。</p>
</blockquote>
<h4 id="2-5G功能"><a href="#2-5G功能" class="headerlink" title="(2) 5G功能"></a>(2) 5G功能</h4><p>Android 11 引入了以下功能变更和增强功能</p>
<ul>
<li>按流量计费性</li>
<li>5G检测</li>
<li>带宽估算</li>
</ul>
<p><strong>检查按流量计费性</strong></p>
<p><a target="_blank" rel="noopener" href="https://developer.android.com/reference/android/net/NetworkCapabilities#NET_CAPABILITY_TEMPORARILY_NOT_METERED"><code>NET_CAPABILITY_TEMPORARILY_NOT_METERED</code></a> 是 Android 11 中添加的一项功能，可根据移动网络运营商提供的信息，告知您正在使用的网络是否不按流量计费。</p>
<p>该新标记与 <a target="_blank" rel="noopener" href="https://developer.android.com/reference/android/net/NetworkCapabilities#NET_CAPABILITY_NOT_METERED"><code>NET_CAPABILITY_NOT_METERED</code></a> 一起使用。该现有标记指示网络是否始终不按流量计费，并且同时适用于 WLAN 和移动网络连接。</p>
<p>这两个标记之间的区别在于，在网络类型不变的情况下，<code>NET_CAPABILITY_TEMPORARILY_NOT_METERED</code> 可能会发生变化。以 Android 11 为目标平台的应用可以使用 <code>NET_CAPABILITY_TEMPORARILY_NOT_METERED</code> 标记。在搭载 Android 9 及更低版本的设备上，操作系统不会报告该标记。对于在 Android 10 上运行的应用，此标记可能可用，具体取决于运行应用的设备。</p>
<p>一旦确定当前网络暂时或永久不按流量计费，您便可以显示分辨率更高的内容（如 4k 视频）、上传日志、备份文件，以及主动下载内容。</p>
<p>使用在网络回调中收到的 <code>NetworkCapabilites</code> 对象来检查以下代码的输出：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> manager = getSystemService(CONNECTIVITY_SERVICE) <span class="hljs-keyword">as</span> ConnectivityManager<br>     manager.registerDefaultNetworkCallback(<span class="hljs-keyword">object</span> : ConnectivityManager.NetworkCallback() &#123;<br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCapabilitiesChanged</span><span class="hljs-params">(network: <span class="hljs-type">Network</span>, networkCapabilities: <span class="hljs-type">NetworkCapabilities</span>)</span></span> &#123;<br>          <span class="hljs-keyword">super</span>.onCapabilitiesChanged(network, networkCapabilities)<br>            <span class="hljs-comment">//true 代表连接不按流量计费</span><br>            <span class="hljs-keyword">val</span> isNotFlowPay=networkCapabilities.hasCapability(NetworkCapabilities.NET_CAPABILITY_NOT_METERED) ||<br>                            networkCapabilities.hasCapability(NetworkCapabilities.NET_CAPABILITY_TEMPORARILY_NOT_METERED)<br>          &#125;<br>    &#125;)<br><br></code></pre></td></tr></table></figure>

<p>如果值为 true，则可以将网络视为不按流量计费。</p>
<p>注册网络回调</p>
<p>使用 <a target="_blank" rel="noopener" href="https://developer.android.com/reference/android/net/ConnectivityManager#registerDefaultNetworkCallback(android.net.ConnectivityManager.NetworkCallback)"><code>ConnectivityManager.registerDefaultNetworkCallback()</code></a> 注册一个网络回调，以监听 <code>NetworkCapabilities</code> 何时发生更改。您可以通过替换 <code>NetworkCallback</code> 中的 [<code>onCapabilitiesChanged()</code>](<a target="_blank" rel="noopener" href="https://developer.android.com/reference/android/net/ConnectivityManager.NetworkCallback#onCapabilitiesChanged">https://developer.android.com/reference/android/net/ConnectivityManager.NetworkCallback#onCapabilitiesChanged</a>(android.net.Network, android.net.NetworkCapabilities)) 方法来检测 <code>NetworkCapabilities</code> 的更改。</p>
<p><code>registerDefaultNetworkCallback()</code> 会使注册的回调在注册后立即触发，从而为应用提供有关当前状态的信息。将来的回调对于应用在状态从不按流量计费更改为按流量计费或者从按流量计费更改为不按流量计费时采取适当的措施至关重要。</p>
<p><strong>5G检测</strong></p>
<p>从 Android 11 开始，可以使用基于回调的 API 调用来检测设备是否连接到了 5G 网络。可以检查连接的是 5G NR（独立）网络，还是 NSA（非独立）网络。</p>
<p>通过<code>TelephonyManager</code>的监听方法并传入 <a target="_blank" rel="noopener" href="https://developer.android.com/reference/android/telephony/PhoneStateListener#LISTEN_DISPLAY_INFO_CHANGED"><code>LISTEN_DISPLAY_INFO_CHANGED</code></a>，以确定用户是否连接到了 5G 网络。替换 <a target="_blank" rel="noopener" href="https://developer.android.com/reference/android/telephony/PhoneStateListener#onDisplayInfoChanged(android.telephony.TelephonyDisplayInfo)"><code>onDisplayInfoChanged()</code></a> 方法，以确定应用连接到的网络类型：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><br><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getNetworkType</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">val</span> tManager = getSystemService(Context.TELEPHONY_SERVICE) <span class="hljs-keyword">as</span> TelephonyManager<br>        tManager.listen(<span class="hljs-keyword">object</span> : PhoneStateListener() &#123;<br><br>            <span class="hljs-meta">@RequiresApi(Build.VERSION_CODES.R)</span><br>            <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onDisplayInfoChanged</span><span class="hljs-params">(telephonyDisplayInfo: <span class="hljs-type">TelephonyDisplayInfo</span>)</span></span> &#123;<br>                <span class="hljs-keyword">if</span> (ActivityCompat.checkSelfPermission(<span class="hljs-keyword">this</span><span class="hljs-symbol">@Android11Test2Activity</span>, android.Manifest.permission.READ_PHONE_STATE) != android.content.pm.PackageManager.PERMISSION_GRANTED) &#123;<br>                    <span class="hljs-keyword">return</span><br>                &#125;<br>                <span class="hljs-keyword">super</span>.onDisplayInfoChanged(telephonyDisplayInfo)<br><br>                <span class="hljs-keyword">when</span>(telephonyDisplayInfo.networkType) &#123;<br>                    TelephonyDisplayInfo.OVERRIDE_NETWORK_TYPE_LTE_ADVANCED_PRO -&gt; showToast(<span class="hljs-string">&quot;高级专业版 LTE (5Ge)&quot;</span>)<br>                    TelephonyDisplayInfo.OVERRIDE_NETWORK_TYPE_NR_NSA -&gt; showToast(<span class="hljs-string">&quot;NR (5G) - 5G Sub-6 网络&quot;</span>)<br>                    TelephonyDisplayInfo.OVERRIDE_NETWORK_TYPE_NR_NSA_MMWAVE -&gt; showToast(<span class="hljs-string">&quot;5G+/5G UW - 5G mmWave 网络&quot;</span>)<br>                    <span class="hljs-keyword">else</span> -&gt; showToast(<span class="hljs-string">&quot;other&quot;</span>)<br>                &#125;<br>            &#125;<br><br>        &#125;, PhoneStateListener.LISTEN_DISPLAY_INFO_CHANGED)<br>    &#125;<br><br></code></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left"><strong>返回类型</strong></th>
<th align="left"><strong>网络</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a target="_blank" rel="noopener" href="https://developer.android.com/reference/android/telephony/TelephonyDisplayInfo#OVERRIDE_NETWORK_TYPE_LTE_ADVANCED_PRO"><code>OVERRIDE_NETWORK_TYPE_LTE_ADVANCED_PRO</code></a></td>
<td align="left">高级专业版 LTE (5Ge)</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://developer.android.com/reference/android/telephony/TelephonyDisplayInfo#OVERRIDE_NETWORK_TYPE_NR_NSA"><code>OVERRIDE_NETWORK_TYPE_NR_NSA</code></a></td>
<td align="left">NR (5G) - 5G Sub-6 网络</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://developer.android.com/reference/android/telephony/TelephonyDisplayInfo#OVERRIDE_NETWORK_TYPE_NR_NSA_MMWAVE"><code>OVERRIDE_NETWORK_TYPE_NR_NSA_MMWAVE</code></a></td>
<td align="left">5G+/5G UW - 5G mmWave 网络</td>
</tr>
</tbody></table>
<p><strong>带宽估测</strong></p>
<p>带宽估测使用您在确定按流量计费性时使用的 <code>NetworkCapabilities</code> 对象。您可以使用该对象获取带宽估测值。</p>
<p>带宽估测方法 <a target="_blank" rel="noopener" href="https://developer.android.com/reference/android/net/NetworkCapabilities#getLinkDownstreamBandwidthKbps()"><code>getLinkDownstreamBandwidthKbps()</code></a> 和 <a target="_blank" rel="noopener" href="https://developer.android.com/reference/android/net/NetworkCapabilities#getLinkUpstreamBandwidthKbps()"><code>getLinkUpstreamBandwidthKbps()</code></a> 的可靠性和准确性在 Android 11 中得到了改进，这是因为，为了适应 5G 而进行了框架支持的升级和平台/调制解调器问题修复。</p>
<p>带宽默认值仅提供关于应用启动的指导。这应该可以帮助您处理“空闲时启动”的情况。您的应用应衡量用户开始与其互动后的性能，并动态地调整其流式传输行为。例如，您可以根据启动时的带宽估测来选择要提供的视频分辨率。随着用户使用应用，继续检查估测值；随着其连接类型和强度的变化，相应地调整应用的行为。</p>
<h3 id="8-媒体Intent打开相机"><a href="#8-媒体Intent打开相机" class="headerlink" title="8.媒体Intent打开相机"></a>8.媒体Intent打开相机</h3><blockquote>
<p>从Android11开始，只有预装的系统相机可以相应以下Intent事件：</p>
</blockquote>
<ul>
<li>android.media.action.VIDEO_CAPTURE</li>
<li>android.media.action.IMAGE_CAPTURE</li>
<li>android.media.action.IMAGE_CAPTURE_SECURE</li>
</ul>
<p>也就是使用Intent将无法唤起第三方相机，如果需要打开第三方相机官方给的建议是可以通过为<code>intent</code>设置软件包名称或组件来使这些intent变得明确。</p>
<h3 id="9-前台服务类型"><a href="#9-前台服务类型" class="headerlink" title="9.前台服务类型"></a>9.前台服务类型</h3><blockquote>
<p>从 Android 9 开始，应用仅限于在前台访问摄像头和麦克风。为了进一步保护用户，Android 11 更改了前台服务访问摄像头和麦克风相关数据的方式。如果您的应用以 Android 11 为目标平台并且在某项前台服务中访问这些类型的数据，您需要在该前台服务的声明的 foregroundServiceType 属性中添加新的 camera 和 microphone 类型。</p>
</blockquote>
<p>在Android10的时候，对于前台定位服务就必须加上<code>android:foregroundServiceType=&quot;location&quot;</code>，现在Android11上又增加了两个权限限制，一个是摄像头一个是麦克风。</p>
<p>所以总结下来就是，应用某项前台服务需要访问<code>位置信息、摄像头和麦克风</code>，那么就要在清单文件中这样添加：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><br><span class="hljs-tag">&lt;<span class="hljs-name">manifest</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">service</span> <span class="hljs-attr">...</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:foregroundServiceType</span>=<span class="hljs-string">&quot;location|camera|microphone&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">manifest</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>有的朋友可能测试发现，不加<code>foregroundServiceType</code>的前提下，让<code>Activity</code>启动了一个前台服务，并在服务里去获取定位，竟然可以获取到定位信息，难道官方说错了？</p>
<p>其实这是因为你并没有让前台服务单独运行，你可以试着在<code>Activity</code>启动Service后，进入Home界面，然后过几秒再请求位置，就请求不到了。但是不会崩溃，因为这个被系统设置的权限类别为<code>MODE_IGNORED</code>，也就是静默失败模式。</p>
<p>所以为了保险起见，只要前台服务涉及到了这三个功能，就在清单文件加上<code>android:foregroundServiceType</code></p>
<h3 id="10-Toast行为变更"><a href="#10-Toast行为变更" class="headerlink" title="10.Toast行为变更"></a>10.Toast行为变更</h3><h3 id="1-自定义Toast被屏蔽"><a href="#1-自定义Toast被屏蔽" class="headerlink" title="(1)自定义Toast被屏蔽"></a>(1)自定义Toast被屏蔽</h3><blockquote>
<p>出于安全方面的考虑，同时也为了保持良好的用户体验，如果包含自定义视图的消息框是以 Android 11 或更高版本为目标平台的应用从后台发送的，系统会屏蔽这些消息框。请注意，仍允许使用文本消息框；此类消息框是使用 <a target="_blank" rel="noopener" href="https://developer.android.com/reference/kotlin/android/widget/Toast#maketext"><code>Toast.makeText()</code></a> 创建的，并不调用 <a target="_blank" rel="noopener" href="https://developer.android.com/reference/kotlin/android/widget/Toast#setview"><code>setView()</code></a>。</p>
</blockquote>
<p>如果您的应用仍尝试从后台发布包含自定义视图的消息框，系统不会向用户显示相应的消息，而是会在 logcat 中记录以下消息：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><br>W/NotificationService: Blocking custom toast from <span class="hljs-keyword">package</span> \  &lt;<span class="hljs-keyword">package</span>&gt; due to <span class="hljs-keyword">package</span> <span class="hljs-keyword">not</span> in the foreground<br></code></pre></td></tr></table></figure>

<p>如果应用在后台时弹出自定义toast则会有相关警告，但不会crash。</p>
<h4 id="2-消息框回调"><a href="#2-消息框回调" class="headerlink" title="(2) 消息框回调"></a>(2) 消息框回调</h4><p>如果您希望在消息框（文本消息框或自定义消息框）出现或消失时收到通知，请使用 Android 11 中添加的 <a target="_blank" rel="noopener" href="https://developer.android.com/reference/android/widget/Toast#addCallback(android.widget.Toast.Callback)"><code>addCallback()</code></a> 方法。</p>
<h3 id="11-allowBackup"><a href="#11-allowBackup" class="headerlink" title="11.allowBackup"></a>11.allowBackup</h3><blockquote>
<p>如果您的应用以 Android 11 为目标平台，您将无法再使用 allowBackup 属性停用应用文件的设备到设备迁移。系统会自动启用此功能。不过，即使您的应用以 Android 11 为目标平台，您也可以通过将 allowBackup 属性设置为 false 来停用应用文件的云端备份和恢复。</p>
</blockquote>
<p><strong>android:allowBackup属性</strong></p>
<ul>
<li>代表是否允许应用参与备份和恢复基础架构。如果将此属性设为 false，则永远不会为该应用执行<code>备份或恢复</code>，即使是采用全系统备份方法也不例外（这种备份方法通常会通过 adb 保存所有应用数据）。此属性的默认值为 true。</li>
</ul>
<p>所以这里是不能停用文件的<code>设备到设备</code>迁移，但是可以停用<code>云端备份和恢复</code></p>
<h2 id="二、行为变更：所有应用"><a href="#二、行为变更：所有应用" class="headerlink" title="二、行为变更：所有应用"></a>二、行为变更：所有应用</h2><p>此模块的修改内容针对所有项目在<code>Android11</code>手机上存在的改动，与<code>targetSdkVersion</code>无关。</p>
<h3 id="1-数据访问审核"><a href="#1-数据访问审核" class="headerlink" title="1.数据访问审核"></a>1.数据访问审核</h3><blockquote>
<p>为了让应用及其依赖项访问用户私密数据的过程更加透明，Android 11 引入了数据访问审核功能。借助此流程得出的见解，您可以更好地识别和纠正可能出现的意外数据访问。</p>
</blockquote>
<p>哪些范畴属于用户私密数据呢？其实就是危险权限的调用，所以这个功能就是提供了可以监听危险权限调用的监听。主要涉及到的方法是<code>AppOpsManager.OnOpNotedCallback</code>。无论是应用本身，还是依赖库或者SDK中的代码，只要访问到私密数据（危险权限），都会回调给我们。</p>
<p>对于<strong>工程庞大或者使用较多SDK</strong>的工程比较适合用上这个功能，让自己应用的私有数据管理更加<code>透明规范</code>，否则对于私有数据的使用和管理并不全面和方便。而且还可以对权限使用<code>添加归因</code>，也就是一个tag，标志权限用到了什么地方。方便回调的时候知晓哪里使用了<code>私有数据</code>。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><br><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> &#123;<br>    <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)<br>    setContentView(R.layout.activity_test1)<br><br>    <span class="hljs-comment">//创建归因（attribute）  </span><br>    attributionContext = createAttributionContext(<span class="hljs-string">&quot;shareLocation&quot;</span>)<br><br>    <span class="hljs-comment">//监听事件</span><br>    <span class="hljs-keyword">val</span> appOpsCallback = <span class="hljs-keyword">object</span> : AppOpsManager.OnOpNotedCallback() &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">logPrivateDataAccess</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">                opCode: <span class="hljs-type">String</span>, attributionTag: <span class="hljs-type">String</span>, trace: <span class="hljs-type">String</span>)</span></span> &#123;<br>            Log.i(TAG, <span class="hljs-string">&quot;Private data accessed. &quot;</span> +<br>                    <span class="hljs-string">&quot;Operation: <span class="hljs-variable">$opCode</span>\n &quot;</span> +<br>                    <span class="hljs-string">&quot;Attribution Tag:<span class="hljs-variable">$attributionTag</span>\nStack Trace:\n<span class="hljs-variable">$trace</span>&quot;</span>)<br>        &#125;<br><br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onNoted</span><span class="hljs-params">(syncNotedAppOp: <span class="hljs-type">SyncNotedAppOp</span>)</span></span> &#123;<br>            syncNotedAppOp.attributionTag?.let &#123;<br>                logPrivateDataAccess(syncNotedAppOp.op,<br>                        it,<br>                        Throwable().stackTrace.toString())<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onSelfNoted</span><span class="hljs-params">(syncNotedAppOp: <span class="hljs-type">SyncNotedAppOp</span>)</span></span> &#123;<br>            syncNotedAppOp.attributionTag?.let &#123;<br>                logPrivateDataAccess(syncNotedAppOp.op,<br>                        it,<br>                        Throwable().stackTrace.toString())<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onAsyncNoted</span><span class="hljs-params">(asyncNotedAppOp: <span class="hljs-type">AsyncNotedAppOp</span>)</span></span> &#123;<br>            asyncNotedAppOp.attributionTag?.let &#123;<br>                logPrivateDataAccess(asyncNotedAppOp.op,<br>                        it,<br>                        asyncNotedAppOp.message)<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//开启私密数据监听</span><br>    <span class="hljs-keyword">val</span> appOpsManager =<br>            getSystemService(AppOpsManager::<span class="hljs-keyword">class</span>.java) <span class="hljs-keyword">as</span> AppOpsManager<br>    appOpsManager.setOnOpNotedCallback(mainExecutor, appOpsCallback)<br><br>    btn1.setOnClickListener &#123;<br>        getLocation()<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getLocation</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> locationManager = attributionContext.getSystemService(<br>            LocationManager::<span class="hljs-keyword">class</span>.java) <span class="hljs-keyword">as</span> LocationManager<br>    <span class="hljs-keyword">if</span> (!checkPermission()) &#123;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <span class="hljs-keyword">val</span> location: Location? = locationManager.getLastKnownLocation(LocationManager.NETWORK_PROVIDER)<br>    <span class="hljs-keyword">if</span> (location != <span class="hljs-literal">null</span>) &#123;<br>        showToast(<span class="hljs-string">&quot;<span class="hljs-subst">$&#123;location.latitude&#125;</span>&quot;</span>)<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>该例子主要展示了一个<code>获取位置信息</code>的功能，如果调用到<code>getLocation</code>方法，就会触发<code>onNoted</code>回调，回调信息包括危险权限code以及归因。</p>
<p>其中<strong>OnOpNotedCallback</strong> 一共三个回调方法：</p>
<ul>
<li><code>onNoted</code> 正常情况下都会回调到该方法</li>
<li><code>onAsyncNoted</code> 如果数据访问并非发生在应用调用API期间，就会调用onAsyncNoted()，比如一些监听器的回调。</li>
<li><code>onSelfNoted</code> 在极少数情况下，如果应用将自身的UID传递到 noteOp()，需要调用 onSelfNoted()。</li>
</ul>
<h3 id="2-单次授权"><a href="#2-单次授权" class="headerlink" title="2.单次授权"></a>2.单次授权</h3><blockquote>
<p>在 Android 11 中，每当应用请求与位置信息、麦克风或摄像头相关的权限时，面向用户的权限对话框会包含仅限这一次选项。如果用户在对话框中选择此选项，系统会向应用授予临时的单次授权。</p>
</blockquote>
<p>就是在申请与<code>位置信息、麦克风或摄像头</code>相关的权限时，系统会自动提供一个<code>单次授权</code>的选项，只供这一次权限获取。然后用户下次打开app的时候，系统会再次提示用户授予权限。这个影响应该不大，只要我们每次使用的时候都去判断权限，没有就去申请即可。</p>
<h3 id="3-权限对话框的可见性"><a href="#3-权限对话框的可见性" class="headerlink" title="3.权限对话框的可见性"></a>3.权限对话框的可见性</h3><blockquote>
<p>Android 11 建议不要请求用户已选择拒绝的权限。在应用安装到设备上后，如果用户在使用过程中屡次针对某项特定的权限点按拒绝，此操作表示其希望“不再询问”。</p>
</blockquote>
<p>这个都算不上改动，只是官方的一个<code>良好建议</code>。建议在用户多次拒绝之后，不要再展示权限申请。</p>
<h3 id="4-数据访问审核"><a href="#4-数据访问审核" class="headerlink" title="4.数据访问审核"></a>4.数据访问审核</h3><p>为了让应用及其依赖项访问用户私密数据的过程更加透明，Android 11 引入了数据访问审核功能。借助此流程得出的见解，您可以更好地识别可能出现的意外数据访问。您的应用可以注册 <code>AppOpsManager.OnOpNotedCallback</code> 实例，该实例可在每次发生以下任一事件时执行相应操作：</p>
<ul>
<li>应用的代码访问私密数据。为了帮助您确定应用的哪个逻辑部分调用了事件，您可以按归因标记审核数据访问。</li>
<li>依赖库或 SDK 中的代码访问私密数据。</li>
</ul>
<h3 id="5-永久SIM卡标识符"><a href="#5-永久SIM卡标识符" class="headerlink" title="5.永久SIM卡标识符"></a>5.永久SIM卡标识符</h3><blockquote>
<p>在 Android 11 及更高版本中，使用 <a target="_blank" rel="noopener" href="https://developer.android.google.cn/reference/android/telephony/SubscriptionInfo#getIccId()"><code>getIccId()</code></a> 方法访问不可重置的 ICCID 受到限制。该方法会返回一个非 null 的空字符串。如需唯一标识设备上安装的 SIM 卡，请改用 <a target="_blank" rel="noopener" href="https://developer.android.google.cn/reference/android/telephony/SubscriptionInfo#getSubscriptionId()"><code>getSubscriptionId()</code></a> 方法。订阅 ID 会提供一个索引值（从 1 开始），用于唯一识别已安装的 SIM 卡（包括实体 SIM 卡和电子 SIM 卡）。除非设备恢复出厂设置，否则此标识符的值对于给定 SIM 卡是保持不变的。</p>
</blockquote>
<h3 id="6-非-SDK-接口限制"><a href="#6-非-SDK-接口限制" class="headerlink" title="6.非 SDK 接口限制"></a>6.非 SDK 接口限制</h3><blockquote>
<p>Android 11 包含更新后的受限制非 SDK 接口列表（基于与 Android 开发者之间的协作以及最新的内部测试）。在限制使用非 SDK 接口之前，我们会尽可能确保有可用的公开替代方案。</p>
</blockquote>
<p>如果您的应用并非以 Android 11 为目标平台，那么其中一些变更可能不会立即对您产生影响。不过，虽然您目前可以使用一些非 SDK 接口（具体取决于应用的目标 API 级别），但只要您使用任何非 SDK 方法或字段，应用无法运行的风险终归较高。</p>
<p>如果您不确定自己的应用是否使用了非 SDK 接口，则可以测试该应用，进行确认。如果您的应用依赖于非 SDK 接口，您应该开始计划迁移到 SDK 替代方案。然而，我们知道某些应用具有使用非 SDK 接口的有效用例。如果您无法为应用中的某项功能找到使用非 SDK 接口的替代方案，则应<a target="_blank" rel="noopener" href="https://developer.android.google.cn/distribute/best-practices/develop/restrictions-non-sdk-interfaces#feature-request">请求新的公共 API</a>。</p>
<p>如需详细了解此 Android 版本中的变更，请参阅 <a target="_blank" rel="noopener" href="https://developer.android.google.cn/about/versions/11/non-sdk-11">Android 11 中有关限制非 SDK 接口的更新</a>。如需全面了解有关非 SDK 接口的详细信息，请参阅<a target="_blank" rel="noopener" href="https://developer.android.google.cn/distribute/best-practices/develop/restrictions-non-sdk-interfaces">对非 SDK 接口的限制</a>。</p>
<h3 id="4-Scudo-Hardened-Allocator"><a href="#4-Scudo-Hardened-Allocator" class="headerlink" title="4.Scudo Hardened Allocator"></a>4.Scudo Hardened Allocator</h3><blockquote>
<p>Android 11 在内部使用 Scudo Hardened Allocator 为堆分配提供服务。Scudo 能够检测并减轻某些类型的内存安全违规行为。如果您在原生代码崩溃报告中发现与 Scudo 相关的崩溃（例如 Scudo ERROR:），请参阅 Scudo 问题排查文档。</p>
</blockquote>
<p><code>Scudo</code>是一种动态的用户模式内存分配器，旨在抵御与堆相关的漏洞，同时保持良好的性能。它是一个开源的项目。 Android 11中，将采用这个新的<code>heap分配器</code>，性能更好，更安全。</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/Android/">Android</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Android-11/">Android-11</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！ <div class="text-center"> <div class="about-info"> <div class="about-icons" style="margin-top:20px;"> <a target="_blank" rel="noopener" href="https://github.com/zhpanvip" class="hint--bottom hint--rounded" aria-label=GitHub> <i class="iconfont icon-github-fill" aria-hidden="true"></i> </a> <a target="_blank" rel="noopener" href="https://juejin.im/user/2735240659359448/posts" class="hint--bottom hint--rounded" aria-label=掘金> <i class="iconfont icon-juejin" aria-hidden="true"></i> </a> <a href="mailto:zhpanvip@outlook.com" class="hint--bottom hint--rounded" aria-label=邮箱> <i class="iconfont icon-mail" aria-hidden="true"></i> </a> <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_20521573" class="qr-trigger"> <i class="iconfont icon-wechat-fill" aria-hidden="true"></i> <img class="qr-img" src="https://raw.githubusercontent.com/zhpanvip/images/master/project/group/wechat_gzh.jpg" srcset="/img/loading.gif" alt="qrcode" /> </a> </div> </div></p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2020/11/29/32.Bye%20ButterKnife/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">ButterKnife被弃用，ViewBinding才是findView的未来？</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2020/09/25/30.Know%20about%20HashTable/">
                        <span class="hidden-mobile">面试官：哈希表都不知道，你是怎么看懂HashMap的？</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments">
                
                
  <script type="text/javascript">
    Fluid.utils.waitElementVisible('comments', function() {
      var light = 'github-light';
      var dark = 'github-dark';
      var schema = document.documentElement.getAttribute('data-user-color-scheme');
      if (schema === 'dark') {
        schema = dark;
      } else {
        schema = light;
      }
      window.UtterancesThemeLight = light;
      window.UtterancesThemeDark = dark;
      var s = document.createElement('script');
      s.setAttribute('src', 'https://utteranc.es/client.js');
      s.setAttribute('repo', 'zhpanvip/utterances-comment');
      s.setAttribute('issue-term', 'title');
      
      s.setAttribute('label', 'utterances');
      
      s.setAttribute('theme', schema);
      s.setAttribute('crossorigin', 'anonymous');
      document.getElementById('comments').appendChild(s);
    })
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->

  <div class="col-lg-7 mx-auto nopadding-x-md">
    <div class="container custom post-custom mx-auto">
      <img src="https://raw.githubusercontent.com/zhpanvip/images/master/project/group/wechat_gzh.jpg" srcset="/img/loading.gif" class="rounded mx-auto d-block mt-5" style="width:150px; height:150px;">
    </div>
  </div>


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <span rel="nofollow noopener">Copyright © 2016-<span id="current_year"><a target="_blank" href="https://github.com/zhpanvip" rel="nofollow noopener noopener"></span> ZhangPan</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a>
<script type="text/javascript"> function setCurrentYear() { var date = new Date(); var currentYear = date.getFullYear(); document.getElementById("current_year").innerHTML = currentYear; }
window.onload=function(){ setCurrentYear(); } </script>

  </div>
  

  

  
</footer>

<!-- SCRIPTS -->

  <script  src="https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":200})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.staticfile.org/jquery/3.5.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.5.3/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script  src="https://cdn.staticfile.org/tocbot/4.12.0/tocbot.min.js" ></script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>






  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      var inputArea = document.querySelector("#local-search-input");
      inputArea.onclick = function () {
        searchFunc(path, 'local-search-input', 'local-search-result');
        this.onclick = null
      }
    })()
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>



</body>
</html>
