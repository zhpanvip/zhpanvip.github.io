{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"themes/fluid/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/avatar.png","path":"img/avatar.png","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/bg_about.jpg","path":"img/bg_about.jpg","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/bg_article.jpg","path":"img/bg_article.jpg","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/bg_default.png","path":"img/bg_default.png","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/default.png","path":"img/default.png","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/favicon.png","path":"img/favicon.png","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/loading.gif","path":"img/loading.gif","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/police_beian.png","path":"img/police_beian.png","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/clipboard-use.js","path":"js/clipboard-use.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/color-schema.js","path":"js/color-schema.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/debouncer.js","path":"js/debouncer.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/lazyload.js","path":"js/lazyload.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/local-search.js","path":"js/local-search.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/xml/local-search.xml","path":"xml/local-search.xml","modified":0,"renderable":1},{"_id":"themes/fluid/source/lib/hint/hint.min.css","path":"lib/hint/hint.min.css","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/bg_label.jpg","path":"img/bg_label.jpg","modified":0,"renderable":1}],"Cache":[{"_id":"source/CNAME","hash":"afbbd2bef5ea8be919208c6d396994af8618bc81","modified":1598672329306},{"_id":"source/_data/fluid_config.yml","hash":"3c08cf0a81a16a8c01ceb697ddda19877d231ca7","modified":1598797003345},{"_id":"source/_posts/1.浅析Java设计模式（一）.md","hash":"5e2fe42fdaa6ac3c3e1d4c0d481b5701489c7a55","modified":1598724174615},{"_id":"source/_posts/10.Android夜间模式实现方案.md","hash":"3c0ceb9f725c29de7e83f6d9979db476374dcc43","modified":1598724785332},{"_id":"source/_posts/12.关于Https的那些事儿.md","hash":"ae7b4ea29b5c93e9057dec94fc475867d444b9c4","modified":1598724117275},{"_id":"source/_posts/13.Android-Widget开发详解.md","hash":"7e1c1b83e5c77e50ef00a966be8ec302cab710b5","modified":1598724111473},{"_id":"source/_posts/16.Java自定义注解在Android中的实例应用.md","hash":"ccaaa066ad75c6c2fae49acb03f4e90e6a245feb","modified":1598724097236},{"_id":"source/_posts/11.追根溯源-探究Handler的实现原理.md","hash":"634a901500fa873e9de04460e843fc56a1a4977e","modified":1598664648332},{"_id":"source/_posts/18.手撕黄油刀-探究ButterKnife的实现原理.md","hash":"a770cb6f86d263ca6c5891a073fd2898b3656e3f","modified":1598665905168},{"_id":"source/_posts/14.自定义View之弹性滑动的LockView.md","hash":"9f167362fe659eccad066ef425a913f0d30ea889","modified":1598724105364},{"_id":"source/_posts/2.浅析Java设计模式（二）.md","hash":"352763cc48ca42e30c814f8c743caccc434073dd","modified":1598724169074},{"_id":"source/_posts/19.打造一个丝滑般自动轮播无限循环Android库(一).md","hash":"fe49c4364cecab6d3b512ca513ba6f1e09f93a36","modified":1598665915935},{"_id":"source/_posts/20.BannerViewPager源码剖析(二).md","hash":"d9f1297029d5ee2237168247c011454a6b362d25","modified":1598665927048},{"_id":"source/_posts/15.基于Arouter的路由实现方案.md","hash":"2433dc964b3ba7e5cffeec89bc22d7d6c76182ca","modified":1598665866939},{"_id":"source/_posts/23.学不动也要学！深入了解ViewPager2.md","hash":"9b107bed6a53a447e1112b94e5d6334cc10ccd1a","modified":1598666251038},{"_id":"source/_posts/21.静态代理这么用？-聊一聊ViewPagerIndicator重构的一些经验.md","hash":"daf77de6d6257a609e921361d09654254f3eeb1a","modified":1598665935392},{"_id":"source/_posts/24.学不动也要学！探究Fragment延迟加载的前世今生.md","hash":"e0dda218ee89ae726905193c7f9325d4612ffac8","modified":1598724067010},{"_id":"source/_posts/4.RecyclerView-ListView嵌套CheckBox选中状态错乱解决方案.md","hash":"282310ee201c1d9108824530b8469c5ad7f5737f","modified":1598724159276},{"_id":"source/_posts/22.干货满满，整理给程序员的15款开发利器.md","hash":"372e618ef9b73cd8ade5afbe90eae92547faf794","modified":1598724060296},{"_id":"source/_posts/6.自定义View之颜色渐变折线图.md","hash":"43a79d1f7464960bbeb390bb85e6a87fd62b182f","modified":1598724148536},{"_id":"source/_posts/7.BaseActivity中封装通用的Toolbar.md","hash":"e98aeec6719903cf4cae7ecb0d3616fcb138f548","modified":1598722807347},{"_id":"source/_posts/8,RxJava-Retrofit完美封装（一）.md","hash":"7591a6d603bca5b8e0d1ba49f432d1cacf91a6d3","modified":1598724141507},{"_id":"source/_posts/9.RxJava-Retrofit之token自动刷新（二）.md","hash":"d7f0adf764381f301abd52e41578a513f36c3c2d","modified":1598724132728},{"_id":"source/about/index.md","hash":"ad2e86c13c66d7c970fa25f782685a3986b6ddaa","modified":1598761824973},{"_id":"source/_posts/5.Android搜索关键字高亮显示及开发中遇到的坑.md","hash":"bdb3a53c300804ac6f777fe74d5138abc2ecd7c6","modified":1598724154466},{"_id":"source/_posts/3.浅析Java设计模式（三）.md","hash":"5e11026fa30d40198ab778500d03f0bde716c0d1","modified":1598724164212},{"_id":"source/_posts/17.Java编译时注解处理器.md","hash":"66c20484598167a3e03855b90ba2dd7e31f53c0c","modified":1598724086715},{"_id":"themes/fluid/source/css/_pages/_category/category.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1597159344000},{"_id":"themes/fluid/source/css/_pages/_tag/tag.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1597159344000},{"_id":"themes/fluid/.editorconfig","hash":"33218fbd623feb43edf5f99f15965392cecc44a6","modified":1597159344000},{"_id":"themes/fluid/.gitattributes","hash":"a54f902957d49356376b59287b894b1a3d7a003f","modified":1597159344000},{"_id":"themes/fluid/.gitignore","hash":"bd095eee271360a38772ee1a42d4f000fb722e5f","modified":1597159344000},{"_id":"themes/fluid/.eslintrc","hash":"4bc2b19ce2b8c4d242f97d4ccf2d741e68ab0097","modified":1597159344000},{"_id":"themes/fluid/_config.yml","hash":"b88a684787204aad0e4445cbbafa3f061e3c2e43","modified":1598762452931},{"_id":"themes/fluid/_static_prefix.yml","hash":"dd94756c6967838bf656735a46047bb7b0031ca1","modified":1597159344000},{"_id":"themes/fluid/README.md","hash":"0ff14201b4a4799d5e3b1387da8e06ead1681970","modified":1597159344000},{"_id":"themes/fluid/package.json","hash":"167c67c82a91dbc59a2feb88af1bf211b61256a0","modified":1597159344000},{"_id":"themes/fluid/languages/en.yml","hash":"a85dcc5cc21f9cab50df31e5001b8818ee62d1e2","modified":1597159344000},{"_id":"themes/fluid/languages/ja.yml","hash":"91020031a847c0361a6fd7ab990c7be4bf17529b","modified":1597159344000},{"_id":"themes/fluid/languages/zh-CN.yml","hash":"21307b4137c3d9b04bb58243747e75af0abc5a71","modified":1597159344000},{"_id":"themes/fluid/layout/404.ejs","hash":"689d9f4efd2a7f5edfd9b24561a7ade69d46617c","modified":1597159344000},{"_id":"themes/fluid/layout/about.ejs","hash":"e967e102bab2b35b9083165c2b8e037db8e0a32d","modified":1597159344000},{"_id":"themes/fluid/layout/archive.ejs","hash":"094357be1c2c6b477269a3f4b725d3c5dd24ef8c","modified":1597159344000},{"_id":"themes/fluid/layout/categories.ejs","hash":"3b8589675338c7b3e1849104b7bb15ac477fce4e","modified":1597159344000},{"_id":"themes/fluid/layout/category.ejs","hash":"1cfe94f46f1492a411d431b02a8d09c99cab77d5","modified":1597159344000},{"_id":"themes/fluid/layout/index.ejs","hash":"9534043275df504d70232c07fec7e10503b85d32","modified":1597159344000},{"_id":"themes/fluid/layout/layout.ejs","hash":"7eef318f19597fb51b33078a9d9a14a103c1d3f0","modified":1597159344000},{"_id":"themes/fluid/layout/links.ejs","hash":"6abd180ff4dd1d5d22e4c70328e3c7f83d174d9c","modified":1597159344000},{"_id":"themes/fluid/layout/page.ejs","hash":"8cab50ead4cdb992d35710147a9a5308fb5df290","modified":1597159344000},{"_id":"themes/fluid/layout/post.ejs","hash":"59551ef5d9c0dee8c162ac39a18a96dafe5e1358","modified":1597159344000},{"_id":"themes/fluid/layout/tag.ejs","hash":"fd72ec9e6629facf63ce8122f0fa8d492669fa6a","modified":1597159344000},{"_id":"themes/fluid/layout/tags.ejs","hash":"1d06af34b6cf1d8a20d2eb565e309326ceba309f","modified":1597159344000},{"_id":"themes/fluid/LICENSE","hash":"5b919c12e4f5f5cdebb7c17ded4f10f1ebe64811","modified":1597159344000},{"_id":"themes/fluid/gulpfile.js","hash":"dc82b6be72c786721a2f5e2acc10a2a94995c540","modified":1597159344000},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/bug_report.md","hash":"867ed2bb90863934b72b7586ec7c31abf9863182","modified":1597159344000},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/feature_request_zh.md","hash":"a413dc14e4737dbcaa8fb797d37f85121ede6551","modified":1597159344000},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/question.md","hash":"93cf5e1f1e0362adee0f63f4edcc7738cd4fc842","modified":1597159344000},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/question_zh.md","hash":"e24b470f7aa8044499a4f5e39634e5dc43899011","modified":1597159344000},{"_id":"themes/fluid/.github/workflows/limit.yaml","hash":"f8bd2edeb4424ee7a055b31583445d5d5dff91a4","modified":1597159344000},{"_id":"themes/fluid/.github/workflows/lint.yaml","hash":"628f8d7655fdba149f5a9b0232df5c3225eda9da","modified":1597159344000},{"_id":"themes/fluid/layout/_partial/beian.ejs","hash":"4f3acc8dc822c85d0d778552a15875f71c0cd80a","modified":1597159344000},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/feature_request.md","hash":"d3a3204d9bb2b43a69c9cb0be59bada8cb91e412","modified":1597159344000},{"_id":"themes/fluid/layout/_partial/css.ejs","hash":"21964c2e5c68ee3806ef80465ef5de92174cdc3a","modified":1597159344000},{"_id":"themes/fluid/layout/_partial/footer.ejs","hash":"03defcd4409dce27447aa8dfe7ce41a2d47e373b","modified":1597159344000},{"_id":"themes/fluid/layout/_partial/head.ejs","hash":"4359f8598a21b133d392f71772c3f9adb5de96a0","modified":1597159344000},{"_id":"themes/fluid/layout/_partial/nav.ejs","hash":"70490c67b7313ae305d39331238232fe62f094f1","modified":1597159344000},{"_id":"themes/fluid/layout/_partial/paginator.ejs","hash":"783eee847562ce14db8f723b4ae742fb69aaf620","modified":1597159344000},{"_id":"themes/fluid/layout/_partial/post-meta.ejs","hash":"afa8b2d53452609a5ee7cf32ad5f00d5a80de72e","modified":1597159344000},{"_id":"themes/fluid/layout/_partial/scripts.ejs","hash":"0d818a43079d9a2da12d9c974426d675cc0b66ea","modified":1597159344000},{"_id":"themes/fluid/layout/_partial/search.ejs","hash":"cdd7919fa01f6ef7ccc09938d662ff3d77f5d999","modified":1597159344000},{"_id":"themes/fluid/layout/_partial/statistics.ejs","hash":"920bc618d357d48d2b96f8758f6ae8f9488fc4d8","modified":1597159344000},{"_id":"themes/fluid/layout/_partial/toc.ejs","hash":"3cf1d9b9032919d6b936e1f2410911df3b325670","modified":1597159344000},{"_id":"themes/fluid/scripts/events/index.js","hash":"36b137b75c76ff08523016dc8eac702f397d771b","modified":1597159344000},{"_id":"themes/fluid/scripts/filters/post-filter.js","hash":"6665f19fa30cbbe0853d8140a0832f8638538f89","modified":1597159344000},{"_id":"themes/fluid/scripts/generators/local-search.js","hash":"fc2c50405b771b06b7f6cfc4e9de97b992691555","modified":1597159344000},{"_id":"themes/fluid/scripts/generators/pages.js","hash":"01439b3d7abdeb5e51f810d784181c1d420be55d","modified":1597159344000},{"_id":"themes/fluid/scripts/helpers/page.js","hash":"d45dce23532c17367c7eb86b94afa8c9e40d16c6","modified":1597159344000},{"_id":"themes/fluid/scripts/helpers/url.js","hash":"99ab4551dc9c035abcc3bf4da5def2f63449d7ec","modified":1597159344000},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/bug_report_zh.md","hash":"5c5a5565bb13928bc92332d9b99b968673ea7dfb","modified":1597159344000},{"_id":"themes/fluid/scripts/helpers/utils.js","hash":"9045f47c7a71aab39f16cffb3e3847b752c2e0f1","modified":1597159344000},{"_id":"themes/fluid/scripts/helpers/wordcount.js","hash":"e58d422eddb44c1be893f65f79f4c7feecfe6d5f","modified":1597159344000},{"_id":"themes/fluid/scripts/tags/button.js","hash":"48e1b46b4c34b79a128dda7a0592b43be47cf955","modified":1597159344000},{"_id":"themes/fluid/scripts/tags/checkbox.js","hash":"c131fb22805cec89d647e643299508487fc72576","modified":1597159344000},{"_id":"themes/fluid/scripts/tags/group-image.js","hash":"4aeebb797026f1df25646a5d69f7fde79b1bcd26","modified":1597159344000},{"_id":"themes/fluid/scripts/utils/join-path.js","hash":"629e7deb3955f750c1cfa6fc773f412e020fcef4","modified":1597159344000},{"_id":"themes/fluid/scripts/tags/label.js","hash":"d50f5aeb1a95adbc88cea9cca4a07165d6725408","modified":1597159344000},{"_id":"themes/fluid/scripts/tags/note.js","hash":"0886cfe3f8589671a1d289495e359c20a9908080","modified":1597159344000},{"_id":"themes/fluid/scripts/utils/object.js","hash":"61e9555f99edcb23d55361c7154e23af33153ecb","modified":1597159344000},{"_id":"themes/fluid/source/css/main.styl","hash":"d5a8a59c8d1fd17d699a951e59c4ce9ae44c419d","modified":1597159344000},{"_id":"themes/fluid/source/img/favicon.png","hash":"8e732451c22fede8518efc9afd7acd0920ad00eb","modified":1598692181821},{"_id":"themes/fluid/source/img/loading.gif","hash":"2d2fc0f947940f98c21afafef39ecf226a2e8d55","modified":1597159344000},{"_id":"themes/fluid/README_en.md","hash":"99412f14c91c3bc188953eb5b347481a618facd3","modified":1597159344000},{"_id":"themes/fluid/source/js/clipboard-use.js","hash":"f0ffe3df1deeb3cc36adfee2ab839368fb28d1c9","modified":1597159344000},{"_id":"themes/fluid/source/js/color-schema.js","hash":"8728594f7dbbd18467aed378a4696b2805686903","modified":1597159344000},{"_id":"themes/fluid/source/js/debouncer.js","hash":"045f324777bdfb99d4c17b1806169f029f897a65","modified":1597159344000},{"_id":"themes/fluid/source/js/lazyload.js","hash":"792deca48c12512d3e612f0de092ffcff3ca3e34","modified":1597159344000},{"_id":"themes/fluid/source/js/local-search.js","hash":"13d5ef2fe68c49bd6096781034dbb26c190b5176","modified":1597159344000},{"_id":"themes/fluid/source/js/main.js","hash":"a6def6368d288892088f78fd401e7170e3e81a13","modified":1597159344000},{"_id":"themes/fluid/source/js/utils.js","hash":"9b06e2e2a2bb92e27d15a700f28f880317c25cfa","modified":1597159344000},{"_id":"themes/fluid/source/xml/local-search.xml","hash":"8c96ba6a064705602ce28d096fd7dd9069630a55","modified":1597159344000},{"_id":"themes/fluid/layout/_partial/comments/changyan.ejs","hash":"13c0b62854668fd83287dff3792997baeeb3a2c7","modified":1597159344000},{"_id":"themes/fluid/layout/_partial/comments/disqus.ejs","hash":"f6b7af1cd9f5a9971a5c769075d001e2161da367","modified":1597159344000},{"_id":"themes/fluid/layout/_partial/comments/gitalk.ejs","hash":"096fef408349db4ebbec84cf20a373dd46c8f4ff","modified":1597159344000},{"_id":"themes/fluid/layout/_partial/comments/livere.ejs","hash":"f1e5d89cc98e2f6e067e5cd3db728127ccff0105","modified":1597159344000},{"_id":"themes/fluid/layout/_partial/comments/utterances.ejs","hash":"f151bc3453a67213cfdcb944c23764fb3a780722","modified":1597159344000},{"_id":"themes/fluid/layout/_partial/comments/valine.ejs","hash":"37941b3c6f66f1f22aeff734802373657dfdfb99","modified":1597159344000},{"_id":"themes/fluid/layout/_partial/plugins/analytics.ejs","hash":"0977e642c65e34d2ca2980a77b16d9ad2d3936fc","modified":1597159344000},{"_id":"themes/fluid/layout/_partial/plugins/anchor.ejs","hash":"3738c2ef427b4b400225b92e638a17b7ab2125ed","modified":1597159344000},{"_id":"themes/fluid/layout/_partial/plugins/aplayer.ejs","hash":"e843cdbe64af3dee9385eb1d763539d3ac10ed72","modified":1597159344000},{"_id":"themes/fluid/layout/_partial/plugins/daovoice.ejs","hash":"cfc684ba48608abd25afd155ee373d9936bbe84e","modified":1597159344000},{"_id":"themes/fluid/layout/_partial/plugins/fancybox.ejs","hash":"c447e35c93c61a70c1c2dfc34948615832989660","modified":1597159344000},{"_id":"themes/fluid/layout/_partial/plugins/leancloud.ejs","hash":"7807e58722dcf992fba11bc879b0fac0e904dc76","modified":1597159344000},{"_id":"themes/fluid/layout/_partial/plugins/local-search.ejs","hash":"03b024c7bab51b64e5187c9dbfac039d020f1e97","modified":1597159344000},{"_id":"themes/fluid/layout/_partial/plugins/math.ejs","hash":"76c4e0608ae362a265ac5e9c0fc49f75c1bc568e","modified":1597159344000},{"_id":"themes/fluid/layout/_partial/plugins/mermaid.ejs","hash":"10ed1f9a611449d37736e17c4e251127b38b3772","modified":1597159344000},{"_id":"themes/fluid/layout/_partial/plugins/mouse-click.ejs","hash":"eb19991199c201ceb103a6ef025e4dfd1e7dbfb7","modified":1597159344000},{"_id":"themes/fluid/layout/_partial/plugins/tocjs.ejs","hash":"2d35295dba2bb912d6ce2ec7747af06bfdc82edb","modified":1597159344000},{"_id":"themes/fluid/layout/_partial/plugins/typed.ejs","hash":"38334350425008d1f64323de221457ee0948af0e","modified":1597159344000},{"_id":"themes/fluid/scripts/events/lib/footnote.js","hash":"3b2abc5f5e3b681874637e98e047dc4969eb1983","modified":1597159344000},{"_id":"themes/fluid/scripts/events/lib/hello.js","hash":"da4c281a8b2d2ed813da1236950c9dff87334adc","modified":1597159344000},{"_id":"themes/fluid/scripts/events/lib/highlight.js","hash":"4adf895fa1157aaf5a194f8b760332b6215656ef","modified":1597159344000},{"_id":"themes/fluid/scripts/events/lib/lazyload.js","hash":"ee7dfef805af96195c11223cca53983deace8bda","modified":1597159344000},{"_id":"themes/fluid/scripts/events/lib/merge-configs.js","hash":"a191fbf01f0266ac47f0198159f68f4b8ebb81be","modified":1597159344000},{"_id":"themes/fluid/scripts/events/lib/version.js","hash":"ea5f0baa30d6f768febde5f2fb4cf17d280a2adc","modified":1597159344000},{"_id":"themes/fluid/source/css/_functions/base.styl","hash":"2e46f3f4e2c9fe34c1ff1c598738fc7349ae8188","modified":1597159344000},{"_id":"themes/fluid/source/css/_mixins/base.styl","hash":"542e306ee9494e8a78e44d6d7d409605d94caeb3","modified":1597159344000},{"_id":"themes/fluid/source/css/_pages/pages.styl","hash":"b8e887bc7fb3b765a1f8ec9448eff8603a41984f","modified":1597159344000},{"_id":"themes/fluid/source/css/_variables/base.styl","hash":"1678c5bbb1aa2e17681f8e88776ecb802bc85b69","modified":1597159344000},{"_id":"themes/fluid/source/lib/hint/hint.min.css","hash":"b38df228460ebfb4c0b6085336ee2878fe85aafe","modified":1597159344000},{"_id":"themes/fluid/source/css/_pages/_archive/archive.styl","hash":"6e6f22b664199772370b59ce1678b0c148b5849f","modified":1597159344000},{"_id":"themes/fluid/source/css/_pages/_about/about.styl","hash":"15d2786d00418e61022475194ad76445d68e27ea","modified":1597159344000},{"_id":"themes/fluid/source/css/_pages/_base/base.styl","hash":"aa2528e71c290dc43b69dfbdcf4d8d6c258015a4","modified":1597159344000},{"_id":"themes/fluid/source/css/_pages/_base/color-schema.styl","hash":"7231920523d634670344a452908f933b29a452be","modified":1597159344000},{"_id":"themes/fluid/source/css/_pages/_base/inline.styl","hash":"fab8441a0b8d8f9db6c8370013659c035345ae79","modified":1597159344000},{"_id":"themes/fluid/source/css/_pages/_base/keyframes.styl","hash":"94065ea50f5bef7566d184f2422f6ac20866ba22","modified":1597159344000},{"_id":"themes/fluid/source/css/_pages/_base/rewrite.styl","hash":"439fce1b41bc1134399e7f2ce6ffe5aa64568acd","modified":1597159344000},{"_id":"themes/fluid/source/css/_pages/_category/categories.styl","hash":"1ab7db37c2f7dc7ccdb994dcb41c16a4c8920397","modified":1597159344000},{"_id":"themes/fluid/source/css/_pages/_index/index.styl","hash":"c443551deb389102e65cbb2441f60e8c20712ee8","modified":1597159344000},{"_id":"themes/fluid/source/css/_pages/_links/links.styl","hash":"cd4ebb1426abed9fda93b797b02c6d5dd71dc2a1","modified":1597159344000},{"_id":"themes/fluid/source/css/_pages/_post/post.styl","hash":"f8f5503443f26354dacd139606e245f19aceb4a0","modified":1597159344000},{"_id":"themes/fluid/source/css/_pages/_post/tag_plugin.styl","hash":"cbb49a17fcc030029f0c2fbe1e056613109d1ecc","modified":1597159344000},{"_id":"themes/fluid/source/css/_pages/_tag/tags.styl","hash":"65bfc01c76abc927fa1a23bf2422892b0d566c3f","modified":1597159344000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/banner.styl","hash":"5f8738c43539c27ad2ce7635a53b2cac522f1c13","modified":1597159344000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/board.styl","hash":"32d90bcc8bf2fd5d8d78e86a567973d4b69bcfa1","modified":1597159344000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/copy-btn.styl","hash":"2c9e05a354d4be820646a1c99f814740f299ed37","modified":1597159344000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/footer.styl","hash":"6b8340a41afc6b6e5f30dc9e912a0e0265446963","modified":1597159344000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/footnote.styl","hash":"ae9289cc89649af2042907f8a003303b987f3404","modified":1597159344000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/header.styl","hash":"7c8170d0e2de47570fe8ed523f10ee1c33138a9f","modified":1597159344000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/qrcode.styl","hash":"fe74d031acef4403e1510d4cce5bc7accd641780","modified":1597159344000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/scroll-btn.styl","hash":"f1cd98a5b8d98535d707a99dba6a00f1f3978c81","modified":1597159344000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/search.styl","hash":"10f7e91a91e681fb9fe46f9df7707b9ef78707c8","modified":1597159344000},{"_id":"themes/fluid/source/img/police_beian.png","hash":"90efded6baa2dde599a9d6b1387973e8e64923ea","modified":1597159344000},{"_id":"themes/fluid/source/img/bg_about.jpg","hash":"29e373adb946d7ea0521cc18165397c9325466a9","modified":1598720029260},{"_id":"themes/fluid/source/img/bg_default.png","hash":"1b5f63481b4ec2bbece9a5397c6223ffa5b236cf","modified":1598796326591},{"_id":"themes/fluid/source/img/avatar.png","hash":"fe739a158cc128f70f780eb5fa96f388b81d478f","modified":1597159344000},{"_id":"themes/fluid/source/img/bg_article.jpg","hash":"c4c21a1702dd4e65499b8018756e973ca7a3ae24","modified":1598796373580},{"_id":"themes/fluid/source/img/default.png","hash":"2b4c0b48afa1f0ad02ca85e2e41ca886603e7d19","modified":1598796406102},{"_id":"public/local-search.xml","hash":"8c380d14b6d983515574665184da6fb86e2f7fc2","modified":1598762908200},{"_id":"public/about/index.html","hash":"f939a4474963b39b0d595849ba63183274af8661","modified":1598762908200},{"_id":"public/archives/index.html","hash":"218dd7108cfb508b11da831e1bcd1d62e8518470","modified":1598762908200},{"_id":"public/archives/page/3/index.html","hash":"55134e07f98c1c99d2cf3df935f541e79b3306d4","modified":1598762908200},{"_id":"public/archives/page/2/index.html","hash":"9f52727483dbce8069e6669fe202fa44c237c504","modified":1598762908200},{"_id":"public/archives/2016/index.html","hash":"61da3f07a430cef52dcf62d11cc09a903e6d1c71","modified":1598762908200},{"_id":"public/archives/2016/07/index.html","hash":"8b0c73d063362c6d899cf166c9f5f2b5d9612f5f","modified":1598762908200},{"_id":"public/archives/2016/09/index.html","hash":"6a194cd47c58af11e968ae94ffc37cf7e616ba3b","modified":1598762908200},{"_id":"public/archives/2016/12/index.html","hash":"d789d7ab0b9305865baf57d030b118174ffe506a","modified":1598762908200},{"_id":"public/archives/2017/index.html","hash":"30f3142ba4e9285c4c9b846dc1fa080031db8c8c","modified":1598762908200},{"_id":"public/archives/2017/03/index.html","hash":"debb176dd9df25ce39aa8cfa96e5d38c8fe2340e","modified":1598762908200},{"_id":"public/archives/2017/04/index.html","hash":"465cfffc92af6c9e8d91c612da4e7b9d5ea2df1c","modified":1598762908200},{"_id":"public/archives/2017/07/index.html","hash":"13fe5b2477cbab30b6409db9a1faa34bb694167d","modified":1598762908200},{"_id":"public/archives/2017/09/index.html","hash":"0e09b32dd7cbd2798ff28bab84816623ec3535ea","modified":1598762908200},{"_id":"public/archives/2018/index.html","hash":"cdd1151a1aee238ee6122a621759b0833d60b7c0","modified":1598762908200},{"_id":"public/archives/2018/02/index.html","hash":"f8c7ceb51654a91dc63111a4827704f129d2ab0d","modified":1598762908200},{"_id":"public/archives/2018/06/index.html","hash":"5f936c891a228a34124b3afa5ea471b93b276cae","modified":1598762908200},{"_id":"public/archives/2018/07/index.html","hash":"8bade5f041dab7028d62fd947623721310f188cb","modified":1598762908200},{"_id":"public/archives/2018/08/index.html","hash":"de7cdf5c966c50034e25e9c661ecd4b0b93f4ea8","modified":1598762908200},{"_id":"public/archives/2018/09/index.html","hash":"c11603c716850e54be55a463a2ebc820b9165bb1","modified":1598762908200},{"_id":"public/archives/2019/index.html","hash":"5ec2d5c422e729ea4defe7d1cd453277078d0ed6","modified":1598762908200},{"_id":"public/archives/2019/08/index.html","hash":"26f3fe5f9eb9a9b241c5e3fbb10e5d59806e778f","modified":1598762908200},{"_id":"public/archives/2019/09/index.html","hash":"e82df9ee1bb5fbb128e3c725954d1f11bb42e57c","modified":1598762908200},{"_id":"public/archives/2019/11/index.html","hash":"107ea866483c2ce2ce34a8ac236dad0f50aa2765","modified":1598762908200},{"_id":"public/archives/2019/12/index.html","hash":"a54347d4d71a8697e9239f17591fe0b7574e8639","modified":1598762908200},{"_id":"public/archives/2020/index.html","hash":"ce15526a3bad33bd3ecceaae791ae22bf87ccdb0","modified":1598762908200},{"_id":"public/archives/2020/01/index.html","hash":"ce15526a3bad33bd3ecceaae791ae22bf87ccdb0","modified":1598762908200},{"_id":"public/tags/设计模式/index.html","hash":"f30e0d271cf1a75dbb0008cee3575dd2a9bafe35","modified":1598762908200},{"_id":"public/tags/Annotation/index.html","hash":"e24b2df6c1fa3873feda63abd32d89aa7682cb1b","modified":1598762908200},{"_id":"public/tags/源码分析/index.html","hash":"004975a33e4a9512dea207a02f776759a8d42778","modified":1598762908200},{"_id":"public/tags/APT/index.html","hash":"ce6b30ad201b92209624cbc8172369cd4ef9c773","modified":1598762908200},{"_id":"public/tags/indicator/index.html","hash":"ea787bd9dccfda35d1289c60ca35afd034b00254","modified":1598762908200},{"_id":"public/tags/ViewPager2/index.html","hash":"9358b28a1fbf362ec99698dff78dd6bdd0b228b0","modified":1598762908200},{"_id":"public/tags/开发工具/index.html","hash":"683043b6e4156c7c40f9b821a359735ee6fcb173","modified":1598762908200},{"_id":"public/tags/自定义View/index.html","hash":"5f821b3f01d748185370464f46f663139d763393","modified":1598762908200},{"_id":"public/tags/RxJava/index.html","hash":"e02ff08f7c2731c3f16f607c41ffd657698cc653","modified":1598762908200},{"_id":"public/tags/token/index.html","hash":"8a7d8dafef31bb0e29a85ea7e80d85a15081c32c","modified":1598762908200},{"_id":"public/tags/https/index.html","hash":"a0dae51310f5dd1150d178ae508aadf801ad212d","modified":1598762908200},{"_id":"public/tags/Widget/index.html","hash":"0ba52e61ce4070601656816dfdef7d9e6e3a42d9","modified":1598762908200},{"_id":"public/tags/Arouter/index.html","hash":"0ceb8b4f3652ef5207ed19c8bd49af62c418193e","modified":1598762908200},{"_id":"public/tags/Banner/index.html","hash":"8fd32ae4bf7824521b50be3689a1ce35cbac56eb","modified":1598762908200},{"_id":"public/tags/Fragment/index.html","hash":"0873362cebb365634da1684ff2955a882a8ce920","modified":1598762908200},{"_id":"public/tags/懒加载/index.html","hash":"4a8866c88866939b5baf496e5f717e6b88f77188","modified":1598762908200},{"_id":"public/page/3/index.html","hash":"4ff936a1ee534a77d400cc0e4c6e1bd7958e9ef9","modified":1598762908200},{"_id":"public/404.html","hash":"c708a68dd92ae45c60a525b67ea419675f9ad469","modified":1598762908200},{"_id":"public/tags/index.html","hash":"a9c6c067eac95626ebbeb32251a5509a7313e05a","modified":1598762908200},{"_id":"public/categories/index.html","hash":"b6afacd1c7316c0b53d2597e4db7479720209f08","modified":1598797015553},{"_id":"public/links/index.html","hash":"867fdf5d35eba9130846177007c953fa12fedbe0","modified":1598762908200},{"_id":"public/2020/01/02/24.学不动也要学！探究Fragment延迟加载的前世今生/index.html","hash":"c7fb83b95c0943cbe8ef728b32b3b70474177b23","modified":1598762908200},{"_id":"public/2019/12/14/23.学不动也要学！深入了解ViewPager2/index.html","hash":"8dd103d8867101f75c56ecdb6eb5188382f31ad2","modified":1598762908200},{"_id":"public/2019/12/05/22.干货满满，整理给程序员的15款开发利器/index.html","hash":"3d8f9f41fdcfca1ab90bb87ef8cc7e76d50c6d65","modified":1598762908200},{"_id":"public/2019/11/24/21.静态代理这么用？-聊一聊ViewPagerIndicator重构的一些经验/index.html","hash":"b5fd416f026c56e959e6eac50c85cb93080b428d","modified":1598762908200},{"_id":"public/2019/09/08/20.BannerViewPager源码剖析(二)/index.html","hash":"b27581ca1eba8b272a77f195ae11375487b82d9f","modified":1598762908200},{"_id":"public/2019/09/01/19.打造一个丝滑般自动轮播无限循环Android库(一)/index.html","hash":"9811b8902231527cb5fcf92003800aafd9ff55d5","modified":1598762908200},{"_id":"public/2019/08/26/18.手撕黄油刀-探究ButterKnife的实现原理/index.html","hash":"137e3c1de965dcb6e47552d8b09a71fed7d5521f","modified":1598762908200},{"_id":"public/2018/09/10/17.Java编译时注解处理器/index.html","hash":"cabda535191954d4cefadf2fed8c4a26c7d0c487","modified":1598762908200},{"_id":"public/2018/08/25/16.Java自定义注解在Android中的实例应用/index.html","hash":"b1ec65c694aaa633439731aa3c29d0edb2892ca8","modified":1598762908200},{"_id":"public/2018/07/26/15.基于Arouter的路由实现方案/index.html","hash":"047c41cfd1218ca49bfb4c72ef819ab5fdd4f1cd","modified":1598762908200},{"_id":"public/2018/07/14/14.自定义View之弹性滑动的LockView/index.html","hash":"66af79f6d6d838c8e6aecc909528a8953de8c4b9","modified":1598762908200},{"_id":"public/2018/06/21/13.Android-Widget开发详解/index.html","hash":"9ec0a3b9fd1f150b37904ac49e5d7e7a371c820a","modified":1598762908200},{"_id":"public/2018/02/12/12.关于Https的那些事儿/index.html","hash":"5aa56f18bdd0d95f01eec5604449d17f306b54f7","modified":1598762908200},{"_id":"public/2017/09/10/11.追根溯源-探究Handler的实现原理/index.html","hash":"8d2210ec8f14a9cd00e94fe114e475088eb783d0","modified":1598762908200},{"_id":"public/2017/07/27/10.Android夜间模式实现方案/index.html","hash":"ce57d011d87a7f3509a7afa6356ce80ba756c7c3","modified":1598762908200},{"_id":"public/2017/07/27/9.RxJava-Retrofit之token自动刷新（二）/index.html","hash":"38d23980a5a5d0d03ca926f749b67ae689700588","modified":1598762908200},{"_id":"public/2017/04/30/8,RxJava-Retrofit完美封装（一）/index.html","hash":"f7b434617f88e6b7e8dd4ed29cbf977dd2782fd7","modified":1598762908200},{"_id":"public/2017/04/28/7.BaseActivity中封装通用的Toolbar/index.html","hash":"90abcdf7bfd34619229c216a301bad36143cc9d8","modified":1598762908200},{"_id":"public/2017/03/16/6.自定义View之颜色渐变折线图/index.html","hash":"2a28f08f83b928b0e8c0fe918210fe4f2616d82a","modified":1598762908200},{"_id":"public/2016/12/15/5.Android搜索关键字高亮显示及开发中遇到的坑/index.html","hash":"515ed1ce58fdb8d58975f128849c246afbf1493c","modified":1598762908200},{"_id":"public/2016/09/25/4.RecyclerView-ListView嵌套CheckBox选中状态错乱解决方案/index.html","hash":"3c6a59427db097bb1c8d52c16f8db10ef990aa3b","modified":1598762908200},{"_id":"public/2016/07/26/3.浅析Java设计模式（三）/index.html","hash":"0ea20b9408a42d11e18ac520c80abb998b793a1a","modified":1598762908200},{"_id":"public/2016/07/25/2.浅析Java设计模式（二）/index.html","hash":"833a27971b8dee2321df306a6fbbb1ba0fbba20a","modified":1598762908200},{"_id":"public/2016/07/24/1.浅析Java设计模式（一）/index.html","hash":"b1aa4b533b86a0293c09670b0b0228688fe12318","modified":1598762908200},{"_id":"public/index.html","hash":"bf1ee0c6cac041b560555890b01b5f755df2dea6","modified":1598762908200},{"_id":"public/page/2/index.html","hash":"4022b974cb07b35edb3351a7c6a55997f69ed408","modified":1598762908200},{"_id":"public/CNAME","hash":"afbbd2bef5ea8be919208c6d396994af8618bc81","modified":1598762908200},{"_id":"public/img/avatar.png","hash":"fe739a158cc128f70f780eb5fa96f388b81d478f","modified":1598762908200},{"_id":"public/img/bg_about.jpg","hash":"29e373adb946d7ea0521cc18165397c9325466a9","modified":1598762908200},{"_id":"public/img/favicon.png","hash":"8e732451c22fede8518efc9afd7acd0920ad00eb","modified":1598762908200},{"_id":"public/img/loading.gif","hash":"2d2fc0f947940f98c21afafef39ecf226a2e8d55","modified":1598762908200},{"_id":"public/img/police_beian.png","hash":"90efded6baa2dde599a9d6b1387973e8e64923ea","modified":1598762908200},{"_id":"public/xml/local-search.xml","hash":"8c96ba6a064705602ce28d096fd7dd9069630a55","modified":1598762908200},{"_id":"public/img/bg_default.png","hash":"1b5f63481b4ec2bbece9a5397c6223ffa5b236cf","modified":1598796529782},{"_id":"public/js/clipboard-use.js","hash":"f0ffe3df1deeb3cc36adfee2ab839368fb28d1c9","modified":1598762908200},{"_id":"public/js/color-schema.js","hash":"8728594f7dbbd18467aed378a4696b2805686903","modified":1598762908200},{"_id":"public/js/debouncer.js","hash":"045f324777bdfb99d4c17b1806169f029f897a65","modified":1598762908200},{"_id":"public/js/local-search.js","hash":"13d5ef2fe68c49bd6096781034dbb26c190b5176","modified":1598762908200},{"_id":"public/js/lazyload.js","hash":"792deca48c12512d3e612f0de092ffcff3ca3e34","modified":1598762908200},{"_id":"public/js/main.js","hash":"a6def6368d288892088f78fd401e7170e3e81a13","modified":1598762908200},{"_id":"public/js/utils.js","hash":"9b06e2e2a2bb92e27d15a700f28f880317c25cfa","modified":1598762908200},{"_id":"public/lib/hint/hint.min.css","hash":"b38df228460ebfb4c0b6085336ee2878fe85aafe","modified":1598762908200},{"_id":"public/css/main.css","hash":"986c13d4282a28fe7b9006c7c5c7b5438e157646","modified":1598762908200},{"_id":"public/img/bg_article.jpg","hash":"c4c21a1702dd4e65499b8018756e973ca7a3ae24","modified":1598796529782},{"_id":"public/img/default.png","hash":"2b4c0b48afa1f0ad02ca85e2e41ca886603e7d19","modified":1598796529782},{"_id":"themes/fluid/source/img/bg_label.jpg","hash":"7ea1ebac36321f13bba6d715a7c4949f28b0e60a","modified":1598796341648},{"_id":"public/img/bg_label.jpg","hash":"7ea1ebac36321f13bba6d715a7c4949f28b0e60a","modified":1598796529782}],"Category":[],"Data":[{"_id":"fluid_config","data":{"favicon":"/img/favicon.png","apple_touch_icon":"/img/favicon.png","title_join_string":" - ","force_https":false,"highlight":{"enable":true,"style":"Github Gist","bg_color":false,"copy_btn":true},"fun_features":{"typing":{"enable":true,"typeSpeed":70,"cursorChar":"|","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"mouse_click":{"enable":false,"style":"values"}},"dark_mode":{"enable":true,"default":"auto"},"color":{"body_bg_color":"#eee","body_bg_color_dark":"#181c27","navbar_bg_color":"#2f4154","navbar_bg_color_dark":"#1f3144","navbar_text_color":"#fff","navbar_text_color_dark":"#d0d0d0","text_color":"#3c4858","text_color_dark":"#c4c6c9","sec_text_color":"#718096","sec_text_color_dark":"#a7a9ad","post_text_color":"#2c3e50","post_text_color_dark":"#c4c6c9","post_heading_color":"#1a202c","post_heading_color_dark":"#c4c6c9","post_link_color":"#0366d6","post_link_color_dark":"#1589e9","link_hover_color":"#30a9de","link_hover_color_dark":"#30a9de","link_hover_bg_color":"#f8f9fa","link_hover_bg_color_dark":"#364151","board_color":"#fff","board_color_dark":"#252d38"},"font":{"font_size":"16px","font_family":null,"code_font_size":"85%"},"custom_js":null,"custom_css":null,"custom_html":"","web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"tajs":null,"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}},"lazyload":{"enable":true,"onlypost":false},"daovoice":{"enable":false,"appid":""},"aplayer":{"enable":false,"autoplay":false,"loop":"all","order":"random","theme":"#b7daff","songs":[{"name":"name","artist":"artist","url":"/songs/test.mp3","cover":"/img/cover.jpg"},{"name":"name","artist":"artist","url":"https://...url.mp3","cover":"https://...cover.jpg"}]},"version":{"check":false},"navbar":{"blog_title":"zhangpan","ground_glass":{"enable":false,"px":3,"alpha":0.7},"menu":[{"key":"home","link":"/","icon":"iconfont icon-home-fill"},{"key":"archive","link":"/archives/","icon":"iconfont icon-archive-fill"},{"key":"category","link":"/categories/","icon":"iconfont icon-category-fill"},{"key":"tag","link":"/tags/","icon":"iconfont icon-tags-fill"},{"key":"about","link":"/about/","icon":"iconfont icon-user-fill"}]},"search":{"enable":true,"path":"/local-search.xml","generate_path":"/local-search.xml","field":"post","content":true},"scroll_down_arrow":{"enable":true,"banner_height_limit":90,"scroll_after_turning_page":true},"banner_parallax":true,"footer":{"statistics":{"enable":false,"source":"busuanzi","pv_format":"总访问量 {} 次","uv_format":"总访客数 {} 人"},"beian":{"enable":false,"icp_text":"京ICP证123456号","police_text":"京公网安备12345678号","police_code":12345678,"police_icon":"/img/police_beian.png"}},"scroll_top_arrow":{"enable":true},"index":{"banner_img":"/img/default.png","banner_img_height":100,"banner_mask_alpha":0.3,"post_default_img":"","slogan":{"enable":true,"text":"Talk is cheap, show me the code."},"auto_excerpt":{"enable":true},"post_url_target":"_self","post_meta":{"date":true,"category":true,"tag":true}},"page":{"banner_img":"/img/default.png","banner_img_height":60,"banner_mask_alpha":0.3},"post":{"banner_img":"/img/default.png","banner_img_height":70,"banner_mask_alpha":0.3,"meta":{"date":{"enable":true,"format":"LL a"},"wordcount":{"enable":true,"format":"{} 字"},"min2read":{"enable":true,"format":"{} 分钟","words":100},"views":{"enable":false,"source":"busuanzi","format":"{} 次"}},"updated":{"enable":false,"content":"本文最后更新于：","relative":false},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"copyright":{"enable":true,"content":"本博客所有文章除特别声明外，均采用 <a href=\"https://creativecommons.org/licenses/by-sa/4.0/deed.zh\" rel=\"nofollow noopener\">CC BY-SA 4.0 协议</a> ，转载请注明出处！ <h5>开源库推荐</h5> <a href=\"https://github.com/zhpanvip/BannerViewPager\">1.BannerViewPager</a> <p> 一个基于ViewPager2实现的具有强大功能的无限轮播库。支持多种页面切换效果和指示器样式。 </p>\n<a href=\"https://github.com/zhpanvip/viewpagerindicator\">2.ViewPagerIndicator</a> <p> 一个适用于ViewPager和ViewPager2的指示器，支持多种滑块样式及滑动模式 </p>"},"prev_next":{"enable":true},"custom":{"enable":false,"content":"<img src=\"https://octodex.github.com/images/jetpacktocat.png\" class=\"rounded mx-auto d-block mt-5\" style=\"width:150px; height:150px;\">"},"image_zoom":{"enable":true},"footnote":{"enable":true,"header":""},"math":{"enable":false,"specific":false,"engine":"mathjax"},"mermaid":{"enable":false,"specific":false,"options":{"theme":"default"}},"comments":{"enable":true,"type":"utterances"}},"utterances":{"repo":"zhpanvip/utterances-comment","issue_term":"pathname","label":"utterances","theme":"github-light","crossorigin":"anonymous"},"disqus":{"shortname":null,"disqusjs":false,"apikey":null},"gitalk":{"clientID":null,"clientSecret":null,"repo":null,"owner":null,"admin":["name"],"id":"location.pathname","language":"zh-CN","labels":["Gitalk"],"perPage":10,"pagerDirection":"last","distractionFreeMode":false,"createIssueManually":true},"valine":{"appid":"hXIROaIM5y9qnieojJRWP5hS","appkey":"y0f3w3aqd1MF7JL9ma4WECTy","placeholder":"说点什么","path":"window.location.pathname","avatar":"retro","meta":["nick","mail","link"],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"https://zhangpan.site"},"changyan":{"appid":"","appkey":""},"livere":{"uid":""},"archive":{"banner_img":"/img/bg_article.jpg","banner_img_height":60,"banner_mask_alpha":0.3,"subtitle":null},"category":{"banner_img":"/img/bg_default.png","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null,"post_limit":10,"order_by":"-length"},"tag":{"banner_img":"/img/bg_label.jpg","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null,"tagcloud":{"min_font":15,"max_font":30,"unit":"px","start_color":"#BBBBEE","end_color":"#337ab7"}},"about":{"banner_img":"/img/bg_about.png","banner_img_height":60,"banner_mask_alpha":0.3,"subtitle":null,"avatar":"/img/avatar.png","name":"myname","introduce":"一句简短的介绍","icons":[{"class":"iconfont icon-github-fill","link":"https://github.com","tip":"GitHub"},{"class":"iconfont icon-douban-fill","link":"https://douban.com","tip":"豆瓣"},{"class":"iconfont icon-wechat-fill","qrcode":"/img/favicon.png"}]},"page404":{"banner_img":"/img/default.png","banner_img_height":85,"banner_mask_alpha":0.3,"subtitle":"Page not found"},"links":{"banner_img":"/img/default.png","banner_img_height":60,"banner_mask_alpha":0.3,"subtitle":null,"items":[{"title":"Fluid Docs","intro":"主题使用指南","link":"https://hexo.fluid-dev.com/docs/","image":"/img/favicon.png"},{"title":"Fluid Repo","intro":"主题 GitHub 仓库","link":"https://github.com/fluid-dev/hexo-theme-fluid","image":"/img/favicon.png"},{"title":"Fluid Example","intro":"主题操作示例","link":"https://hexo.fluid-dev.com/docs/example/","image":"/img/favicon.png"}]}}}],"Page":[{"title":"about","date":"2020-08-28T06:34:13.000Z","_content":"\n#  关于我\n\n电子邮箱：zhpanvip@outlook.com\n\nGithub： https://github.com/zhpanvip\n\n掘金：https://juejin.im/user/2735240659359448/posts\n\nCSDN：https://blog.csdn.net/qq_20521573\n\n#  关于博客\n\n## 1.博客托管地址\n\n[github连接:https://github.com/zhpanvip/zhpanvip.github.io](https://github.com/zhpanvip/zhpanvip.github.io)\n\n## 2.Hexo\n\n博客使用Hexo搭建，Hexo是一个简单、快速、强大的基于 Github Pages 的博客发布工具，支持Markdown格式，有众多优秀插件和主题。\n\n### hexo常用命令\n\n```\n\thexo new \"postName\" #新建文章\n\thexo new page \"pageName\" #新建页面\n\thexo generate #生成静态页面至public目录\n\thexo server #开启预览访问端口（默认端口4000，'ctrl + c'关闭server）\n\thexo deploy #部署到GitHub\n\thexo help  # 查看帮助\n\thexo version  #查看Hexo的版本\n```\n缩写\n\n```\nhexo n == hexo new\nhexo g == hexo generate\nhexo s == hexo server\nhexo d == hexo deploy \n```\n## 3.Fluid主题\n\n博客采用Material-Designd的一款<a color=\"red\" href=\"https://github.com/fluid-dev/hexo-theme-fluid\">Fluid</a>主题","source":"about/index.md","raw":"---\ntitle: about\ndate: 2020-08-28 14:34:13\n---\n\n#  关于我\n\n电子邮箱：zhpanvip@outlook.com\n\nGithub： https://github.com/zhpanvip\n\n掘金：https://juejin.im/user/2735240659359448/posts\n\nCSDN：https://blog.csdn.net/qq_20521573\n\n#  关于博客\n\n## 1.博客托管地址\n\n[github连接:https://github.com/zhpanvip/zhpanvip.github.io](https://github.com/zhpanvip/zhpanvip.github.io)\n\n## 2.Hexo\n\n博客使用Hexo搭建，Hexo是一个简单、快速、强大的基于 Github Pages 的博客发布工具，支持Markdown格式，有众多优秀插件和主题。\n\n### hexo常用命令\n\n```\n\thexo new \"postName\" #新建文章\n\thexo new page \"pageName\" #新建页面\n\thexo generate #生成静态页面至public目录\n\thexo server #开启预览访问端口（默认端口4000，'ctrl + c'关闭server）\n\thexo deploy #部署到GitHub\n\thexo help  # 查看帮助\n\thexo version  #查看Hexo的版本\n```\n缩写\n\n```\nhexo n == hexo new\nhexo g == hexo generate\nhexo s == hexo server\nhexo d == hexo deploy \n```\n## 3.Fluid主题\n\n博客采用Material-Designd的一款<a color=\"red\" href=\"https://github.com/fluid-dev/hexo-theme-fluid\">Fluid</a>主题","updated":"2020-08-30T04:30:24.973Z","path":"about/index.html","comments":1,"layout":"page","_id":"ckegm5nrb0000dwozaxpu53hu","content":"<h1 id=\"关于我\"><a href=\"#关于我\" class=\"headerlink\" title=\"关于我\"></a>关于我</h1><p>电子邮箱：<a href=\"mailto:&#x7a;&#104;&#112;&#x61;&#x6e;&#x76;&#x69;&#x70;&#x40;&#x6f;&#x75;&#116;&#x6c;&#111;&#111;&#x6b;&#46;&#99;&#111;&#x6d;\">&#x7a;&#104;&#112;&#x61;&#x6e;&#x76;&#x69;&#x70;&#x40;&#x6f;&#x75;&#116;&#x6c;&#111;&#111;&#x6b;&#46;&#99;&#111;&#x6d;</a></p>\n<p>Github： <a href=\"https://github.com/zhpanvip\">https://github.com/zhpanvip</a></p>\n<p>掘金：<a href=\"https://juejin.im/user/2735240659359448/posts\">https://juejin.im/user/2735240659359448/posts</a></p>\n<p>CSDN：<a href=\"https://blog.csdn.net/qq_20521573\">https://blog.csdn.net/qq_20521573</a></p>\n<h1 id=\"关于博客\"><a href=\"#关于博客\" class=\"headerlink\" title=\"关于博客\"></a>关于博客</h1><h2 id=\"1-博客托管地址\"><a href=\"#1-博客托管地址\" class=\"headerlink\" title=\"1.博客托管地址\"></a>1.博客托管地址</h2><p><a href=\"https://github.com/zhpanvip/zhpanvip.github.io\">github连接:https://github.com/zhpanvip/zhpanvip.github.io</a></p>\n<h2 id=\"2-Hexo\"><a href=\"#2-Hexo\" class=\"headerlink\" title=\"2.Hexo\"></a>2.Hexo</h2><p>博客使用Hexo搭建，Hexo是一个简单、快速、强大的基于 Github Pages 的博客发布工具，支持Markdown格式，有众多优秀插件和主题。</p>\n<h3 id=\"hexo常用命令\"><a href=\"#hexo常用命令\" class=\"headerlink\" title=\"hexo常用命令\"></a>hexo常用命令</h3><pre><code class=\"hljs routeros\">hexo new <span class=\"hljs-string\">&quot;postName&quot;</span> #新建文章\nhexo new<span class=\"hljs-built_in\"> page </span><span class=\"hljs-string\">&quot;pageName&quot;</span> #新建页面\nhexo generate #生成静态页面至public目录\nhexo<span class=\"hljs-built_in\"> server </span>#开启预览访问端口（默认端口4000，<span class=\"hljs-string\">&#x27;ctrl + c&#x27;</span>关闭server）\nhexo deploy #部署到GitHub\nhexo help  # 查看帮助\nhexo version  #查看Hexo的版本</code></pre>\n<p>缩写</p>\n<pre><code class=\"hljs routeros\">hexo n == hexo new\nhexo g == hexo generate\nhexo s == hexo server\nhexo d == hexo deploy</code></pre>\n<h2 id=\"3-Fluid主题\"><a href=\"#3-Fluid主题\" class=\"headerlink\" title=\"3.Fluid主题\"></a>3.Fluid主题</h2><p>博客采用Material-Designd的一款<a color=\"red\" href=\"https://github.com/fluid-dev/hexo-theme-fluid\">Fluid</a>主题</p>\n","site":{"data":{"fluid_config":{"favicon":"/img/favicon.png","apple_touch_icon":"/img/favicon.png","title_join_string":" - ","force_https":false,"highlight":{"enable":true,"style":"Github Gist","bg_color":false,"copy_btn":true},"fun_features":{"typing":{"enable":true,"typeSpeed":70,"cursorChar":"|","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"mouse_click":{"enable":false,"style":"values"}},"dark_mode":{"enable":true,"default":"auto"},"color":{"body_bg_color":"#eee","body_bg_color_dark":"#181c27","navbar_bg_color":"#2f4154","navbar_bg_color_dark":"#1f3144","navbar_text_color":"#fff","navbar_text_color_dark":"#d0d0d0","text_color":"#3c4858","text_color_dark":"#c4c6c9","sec_text_color":"#718096","sec_text_color_dark":"#a7a9ad","post_text_color":"#2c3e50","post_text_color_dark":"#c4c6c9","post_heading_color":"#1a202c","post_heading_color_dark":"#c4c6c9","post_link_color":"#0366d6","post_link_color_dark":"#1589e9","link_hover_color":"#30a9de","link_hover_color_dark":"#30a9de","link_hover_bg_color":"#f8f9fa","link_hover_bg_color_dark":"#364151","board_color":"#fff","board_color_dark":"#252d38"},"font":{"font_size":"16px","font_family":null,"code_font_size":"85%"},"custom_js":null,"custom_css":null,"custom_html":"","web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"tajs":null,"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}},"lazyload":{"enable":true,"onlypost":false},"daovoice":{"enable":false,"appid":""},"aplayer":{"enable":false,"autoplay":false,"loop":"all","order":"random","theme":"#b7daff","songs":[{"name":"name","artist":"artist","url":"/songs/test.mp3","cover":"/img/cover.jpg"},{"name":"name","artist":"artist","url":"https://...url.mp3","cover":"https://...cover.jpg"}]},"version":{"check":false},"navbar":{"blog_title":"zhangpan","ground_glass":{"enable":false,"px":3,"alpha":0.7},"menu":[{"key":"home","link":"/","icon":"iconfont icon-home-fill"},{"key":"archive","link":"/archives/","icon":"iconfont icon-archive-fill"},{"key":"category","link":"/categories/","icon":"iconfont icon-category-fill"},{"key":"tag","link":"/tags/","icon":"iconfont icon-tags-fill"},{"key":"about","link":"/about/","icon":"iconfont icon-user-fill"}]},"search":{"enable":true,"path":"/local-search.xml","generate_path":"/local-search.xml","field":"post","content":true},"scroll_down_arrow":{"enable":true,"banner_height_limit":90,"scroll_after_turning_page":true},"banner_parallax":true,"footer":{"statistics":{"enable":false,"source":"busuanzi","pv_format":"总访问量 {} 次","uv_format":"总访客数 {} 人"},"beian":{"enable":false,"icp_text":"京ICP证123456号","police_text":"京公网安备12345678号","police_code":12345678,"police_icon":"/img/police_beian.png"}},"scroll_top_arrow":{"enable":true},"index":{"banner_img":"/img/default.png","banner_img_height":100,"banner_mask_alpha":0.3,"post_default_img":"","slogan":{"enable":true,"text":"Talk is cheap, show me the code."},"auto_excerpt":{"enable":true},"post_url_target":"_self","post_meta":{"date":true,"category":true,"tag":true}},"page":{"banner_img":"/img/default.png","banner_img_height":60,"banner_mask_alpha":0.3},"post":{"banner_img":"/img/default.png","banner_img_height":70,"banner_mask_alpha":0.3,"meta":{"date":{"enable":true,"format":"LL a"},"wordcount":{"enable":true,"format":"{} 字"},"min2read":{"enable":true,"format":"{} 分钟","words":100},"views":{"enable":false,"source":"busuanzi","format":"{} 次"}},"updated":{"enable":false,"content":"本文最后更新于：","relative":false},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"copyright":{"enable":true,"content":"本博客所有文章除特别声明外，均采用 <a href=\"https://creativecommons.org/licenses/by-sa/4.0/deed.zh\" rel=\"nofollow noopener\">CC BY-SA 4.0 协议</a> ，转载请注明出处！ <h5>开源库推荐</h5> <a href=\"https://github.com/zhpanvip/BannerViewPager\">1.BannerViewPager</a> <p> 一个基于ViewPager2实现的具有强大功能的无限轮播库。支持多种页面切换效果和指示器样式。 </p>\n<a href=\"https://github.com/zhpanvip/viewpagerindicator\">2.ViewPagerIndicator</a> <p> 一个适用于ViewPager和ViewPager2的指示器，支持多种滑块样式及滑动模式 </p>"},"prev_next":{"enable":true},"custom":{"enable":false,"content":"<img src=\"https://octodex.github.com/images/jetpacktocat.png\" class=\"rounded mx-auto d-block mt-5\" style=\"width:150px; height:150px;\">"},"image_zoom":{"enable":true},"footnote":{"enable":true,"header":""},"math":{"enable":false,"specific":false,"engine":"mathjax"},"mermaid":{"enable":false,"specific":false,"options":{"theme":"default"}},"comments":{"enable":true,"type":"utterances"}},"utterances":{"repo":"zhpanvip/utterances-comment","issue_term":"pathname","label":"utterances","theme":"github-light","crossorigin":"anonymous"},"disqus":{"shortname":null,"disqusjs":false,"apikey":null},"gitalk":{"clientID":null,"clientSecret":null,"repo":null,"owner":null,"admin":["name"],"id":"location.pathname","language":"zh-CN","labels":["Gitalk"],"perPage":10,"pagerDirection":"last","distractionFreeMode":false,"createIssueManually":true},"valine":{"appid":"hXIROaIM5y9qnieojJRWP5hS","appkey":"y0f3w3aqd1MF7JL9ma4WECTy","placeholder":"说点什么","path":"window.location.pathname","avatar":"retro","meta":["nick","mail","link"],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"https://zhangpan.site"},"changyan":{"appid":"","appkey":""},"livere":{"uid":""},"archive":{"banner_img":"/img/bg_article.jpg","banner_img_height":60,"banner_mask_alpha":0.3,"subtitle":null},"category":{"banner_img":"/img/bg_default.png","banner_img_height":60,"banner_mask_alpha":0.3,"subtitle":null,"post_limit":10,"order_by":"-length"},"tag":{"banner_img":"/img/bg_label.jpg","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null,"tagcloud":{"min_font":15,"max_font":30,"unit":"px","start_color":"#BBBBEE","end_color":"#337ab7"}},"about":{"banner_img":"/img/bg_default.png","banner_img_height":60,"banner_mask_alpha":0.3,"subtitle":null,"avatar":"/img/avatar.png","name":"myname","introduce":"一句简短的介绍","icons":[{"class":"iconfont icon-github-fill","link":"https://github.com","tip":"GitHub"},{"class":"iconfont icon-douban-fill","link":"https://douban.com","tip":"豆瓣"},{"class":"iconfont icon-wechat-fill","qrcode":"/img/favicon.png"}]},"page404":{"banner_img":"/img/default.png","banner_img_height":85,"banner_mask_alpha":0.3,"subtitle":"Page not found"},"links":{"banner_img":"/img/default.png","banner_img_height":60,"banner_mask_alpha":0.3,"subtitle":null,"items":[{"title":"Fluid Docs","intro":"主题使用指南","link":"https://hexo.fluid-dev.com/docs/","image":"/img/favicon.png"},{"title":"Fluid Repo","intro":"主题 GitHub 仓库","link":"https://github.com/fluid-dev/hexo-theme-fluid","image":"/img/favicon.png"},{"title":"Fluid Example","intro":"主题操作示例","link":"https://hexo.fluid-dev.com/docs/example/","image":"/img/favicon.png"}]}}}},"excerpt":"","more":"<h1 id=\"关于我\"><a href=\"#关于我\" class=\"headerlink\" title=\"关于我\"></a>关于我</h1><p>电子邮箱：<a href=\"mailto:&#x7a;&#104;&#112;&#x61;&#x6e;&#x76;&#x69;&#x70;&#x40;&#x6f;&#x75;&#116;&#x6c;&#111;&#111;&#x6b;&#46;&#99;&#111;&#x6d;\">&#x7a;&#104;&#112;&#x61;&#x6e;&#x76;&#x69;&#x70;&#x40;&#x6f;&#x75;&#116;&#x6c;&#111;&#111;&#x6b;&#46;&#99;&#111;&#x6d;</a></p>\n<p>Github： <a href=\"https://github.com/zhpanvip\">https://github.com/zhpanvip</a></p>\n<p>掘金：<a href=\"https://juejin.im/user/2735240659359448/posts\">https://juejin.im/user/2735240659359448/posts</a></p>\n<p>CSDN：<a href=\"https://blog.csdn.net/qq_20521573\">https://blog.csdn.net/qq_20521573</a></p>\n<h1 id=\"关于博客\"><a href=\"#关于博客\" class=\"headerlink\" title=\"关于博客\"></a>关于博客</h1><h2 id=\"1-博客托管地址\"><a href=\"#1-博客托管地址\" class=\"headerlink\" title=\"1.博客托管地址\"></a>1.博客托管地址</h2><p><a href=\"https://github.com/zhpanvip/zhpanvip.github.io\">github连接:https://github.com/zhpanvip/zhpanvip.github.io</a></p>\n<h2 id=\"2-Hexo\"><a href=\"#2-Hexo\" class=\"headerlink\" title=\"2.Hexo\"></a>2.Hexo</h2><p>博客使用Hexo搭建，Hexo是一个简单、快速、强大的基于 Github Pages 的博客发布工具，支持Markdown格式，有众多优秀插件和主题。</p>\n<h3 id=\"hexo常用命令\"><a href=\"#hexo常用命令\" class=\"headerlink\" title=\"hexo常用命令\"></a>hexo常用命令</h3><pre><code class=\"hljs routeros\">hexo new <span class=\"hljs-string\">&quot;postName&quot;</span> #新建文章\nhexo new<span class=\"hljs-built_in\"> page </span><span class=\"hljs-string\">&quot;pageName&quot;</span> #新建页面\nhexo generate #生成静态页面至public目录\nhexo<span class=\"hljs-built_in\"> server </span>#开启预览访问端口（默认端口4000，<span class=\"hljs-string\">&#x27;ctrl + c&#x27;</span>关闭server）\nhexo deploy #部署到GitHub\nhexo help  # 查看帮助\nhexo version  #查看Hexo的版本</code></pre>\n<p>缩写</p>\n<pre><code class=\"hljs routeros\">hexo n == hexo new\nhexo g == hexo generate\nhexo s == hexo server\nhexo d == hexo deploy</code></pre>\n<h2 id=\"3-Fluid主题\"><a href=\"#3-Fluid主题\" class=\"headerlink\" title=\"3.Fluid主题\"></a>3.Fluid主题</h2><p>博客采用Material-Designd的一款<a color=\"red\" href=\"https://github.com/fluid-dev/hexo-theme-fluid\">Fluid</a>主题</p>\n"}],"Post":[{"title":"浅析Java设计模式（一）","date":"2016-07-24T08:58:29.000Z","_content":"\n设计模式可以分为三大类\n**1.创建型模式** 这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。该类设计模式有五种:\n\n - 简单工厂模式（Factory Pattern） \n - 建造者模式（Builder Pattern）\n - 单例模式（SingletonPattern）    \n - 原型模式（Prototype Pattern）\n - 抽象工厂模式（Abstract Factory Pattern） \n\n**2.结构型模式** 这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。该类模式有五种：\n\n -  代理模式（Proxy Pattern）\n -  装饰器模式（Decorator Pattern）  \n - 适配器模式（Adapter Pattern）\n -  组合模式（Composite Pattern）   \n - 桥接模式（Bridge Pattern）  \n -  外观模式（FacadePattern）   \n -  过滤器模式（Filter、CriteriaPattern）  \n\n**3.行为型模式**  这些设计模式特别关注对象之间的通信。\n - 观察者模式（Observer Pattern）\n - 中介者模式（Mediator Pattern）\n - 策略模式（Strategy Pattern）\n - 责任链模式（Chain of Responsibility Pattern）\n - 命令模式（Command Pattern）\n - 解释器模式（Interpreter Pattern）\n - 迭代器模式（Iterator Pattern）\n - 备忘录模式（Memento Pattern）\n - 状态模式（State Pattern）\n - 空对象模式（Null Object Pattern）\n - 模板模式（Template Pattern）\n - 访问者模式（Visitor Pattern）\n《浅析Java设计模式》将分为三篇分别对三类设计模式中比较常用且典型的几种模式做讲解。本篇文章是第一篇将从创建型模式中挑选简单工厂模式、单例模式以及建造者模式来解析。\n\n一、简单工厂模式\n------\n简单工厂模式就是建立一个工厂类，对实现了同一接口的一些类进行实例的创建。简单工厂模式的实质是由一个工厂类根据传入的参数，动态决定应该创建哪一个产品类（这些产品类继承自一个父类或接口）的实例。\n简单工厂模式UML\n我们以画矩形、三角形以及圆为例，对于三种图形，可以抽象出来一个Shape，它们有共同的draw方法。并且让三种图形均实现Shape接口。简单工厂模式UML图如下所示：\n![简单工厂模式](https://raw.githubusercontent.com/zhpanvip/Resource/master/image/0101.jfif)\n\n1.首先定义Shape接口，接口中有三种图形共有的draw方法：\n```\npublic interface Shape {\n\tvoid draw();\n}\n```\n2.创建三种形状并实现Shape接口：\n矩形类：\n```\npublic class Rectangle implements Shape {\n\t@Override\n\tpublic void draw() {\n\t\tSystem.out.println(\"Draw a Rectangle\");\n\t}\n}\n```\n三角形：\n```\npublic class Triangle implements Shape {\n\t@Override\n\tpublic void draw() {\n\t\tSystem.out.println(\"Draw a Triangle\");\n\t}\n}\n```\n圆形：\n```\npublic class Circle implements Shape {\n\t@Override\n\tpublic void draw() {\n\t\tSystem.out.println(\"Draw a circle\");\n\t}\n}\n```\n3.创建工厂类，并根据参数信息画出对应的图形：\n\n```\npublic class ShapFactory {\n\t //使用 getShape 方法获取形状类型的对象\n\t   public Shape getShape(String shapeType){\n\t      if(shapeType == null){\n\t         return null;\n\t      }        \n\t      if(shapeType.equals(\"Circle\")){\n\t         return new Circle();\n\t      } else if(shapeType.equals(\"Rectangle\")){\n\t         return new Rectangle();\n\t      } else if(shapeType.equals(\"Triangle\")){\n\t         return new Triangle();\n\t      }\n\t      return null;\n\t   }\n}\n```\n4.接下来，我们创建一个测试类：\n\n```\npublic class FactoryTest {\n\n\tpublic static void main(String[] args) {\n\t\tShapFactory shapFactory = new ShapFactory();\n\n\t\tShape shapeCircle = shapFactory.getShape(\"Circle\");\n\t\tshapeCircle.draw();\n\n\t\tShape shapeRectangle = shapFactory.getShape(\"Rectangle\");\n\t\tshapeRectangle.draw();\n\n\t\tShape shapeTriangle = shapFactory.getShape(\"Triangle\");\n\t\tshapeTriangle.draw();\n\n\t\tShape shapeSquare = shapFactory.getShape(\"Square\");\n\t\tif (shapeSquare == null) {\n\t\t\tSystem.out.println(\"shapeSquare is null!\");\n\t\t} else {\n\t\t\tshapeSquare.draw();\n\t\t}\n\t}\n}\n```\n\n 输出结果： \n> Draw a circle   \n> Draw a Rectangle  \n>  Draw a Triangle \n> shapeSquare isnull!\n\n二、单例模式\n------\n单例模式（Singleton Pattern），保证一个类仅有一个实例，并提供一个访问它的全局访问方法。单例模式需要我们把显示定义的构造方法私有化，不允许外部对它实例化。单例模式的结构图如下所示。\n\n![单例模式](https://raw.githubusercontent.com/zhpanvip/Resource/master/image/0102.png)\n\n**1.一个简单的单例模式实现。**\n\n```\npublic class Singleton {\n\tprivate static Singleton instance;\n\n\tprivate Singleton() {\n\t}\n\n\tpublic static Singleton getInstance() {\n\t\tif(instance==null) {\n\t\t\tinstance = new Singleton();\n\t\t}\n\t\treturn instance;\n\t}\n\t\n\tpublic void openWindow() {\n\t\tSystem.out.println(\"Open a Window\");\n\t}\n}\n```\n上面就是一个最简单的单例模式，我们来写一个测试类：\n\n```\npublic class SingleTest {\n\tpublic static void main(String[] args) {\n\t\tSingleton single1=Singleton.getInstance();\n\t\tSingleton single2=Singleton.getInstance();\n\t\tSystem.out.println(\"single1.equals(single2)---\"+single1.equals(single2));\n\t}\n}\n```\n输出结果：\n\n> single1.equals(single2)---true\n\n从输出结果可以看出两次调用getInstance得到的是同一个Singleton 实例。\n\n上面仅仅是实现单例的一种方式，在调用时实例化对象我们称之为懒汉式，上面的代码有一个弊端，就是不支持多线程调用，在多线程调用的情况下可能会被实例化出多个实例，因此，严格来讲它并不是真正的单例模式！接下来我们继续来看几种单例模式的实现方法，并且来保证它的线程安全。\n**2.线程安全的懒汉式单例模式**\n\n```\npublic class Singleton {\n\tprivate static Singleton instance;\n\n\tprivate Singleton() {}\n\n\tpublic static synchronized  Singleton getInstance() {\n\t\tif(instance==null) {\n\t\t\tinstance = new Singleton();\n\t\t}\n\t\treturn instance;\n\t}\n\t\n\tpublic void openWindow() {\n\t\tSystem.out.println(\"Open a Window\");\n\t}\n}\n```\n如上代码，我们仅仅在getInstance方法上加了一个synchronized 锁，从而保证了线程的安全。但是我们又不得不考虑一个问题，即每次调用getInstance的时候都会加锁，这种做法势必影响了程序的性能，所以还有待改良。\n**3.双重锁定的单例模式**\n\n```\npublic class Singleton {\n\tprivate static Singleton instance;\n\n\tprivate Singleton() {\n\t}\n\n\t//\t双重校验锁 线程安全  不用让线程每次都加锁，只有在未实例化时加锁，提高性能。\n\tpublic static Singleton2 getInstance3() {\n\t\tif (instance == null) {//先判断实例是否存在，不存在再加锁处理\n\t\t\tsynchronized (Singleton2.class) {\n\t\t\t\tif(instance==null) {\n\t\t\t\t\tinstance=new Singleton2();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn instance;\n\t}\n\t\n\tpublic void openWindow() {\n\t\tSystem.out.println(\"Open a Window\");\n\t}\n}\n\n```\n上述代码中为什么两次判断instance是否为null？假如instance为null并且同时又两个线程调用getInstance()方法，它们将同时通过第一重instance==null的判断。然后由于锁机制，这两个线程只能有一个进入，另一个在外排队等候。等到第一个执行完后另一个线程才能进入。而此时如果没有第二重instance是否为空的判断，则第一个线程创建了实例，而第二个线程还是可以继续创建实例。这样没有达到单例的目的。\n**4.饿汉式实现单例模式**\n前三种我们讲解了懒汉式实现单例。那么还有一种在类加载时就创建对象的单例模式的实现方法我们称之为饿汉式。代码如下：\n\n```\npublic class Singleton {\n\tprivate static Singleton instance=new Singleton();\n\n\tprivate Singleton() {\n\t}\n\n\tpublic static Singleton getInstance() {\n\t\treturn instance;\n\t}\n\t\n\tpublic void openWindow() {\n\t\tSystem.out.println(\"Open a Window\");\n\t}\n}\n```\n这种单例模式基于 classloader 机制避免了多线程的同步问题。但因为instance在类加载时就被实例化了，因此存在内存浪费的可能性。\n\n三、建造者模式\n-------\n建造者模式是将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。\n我们以画卡通人物为例，画一个卡通人物需要完成头、身体、手、腿的绘制。那么，我们就可以抽象出一个IDrawPerson的接口\n\n```\npublic interface IDrawPerson {\n\t\n\t void drawHead();\n\t \n\t void drawBody();\n\t \n\t void drawHand();\n\t \n\t void drawLeg();\n\t \n\t Person buildPerson();\n}\n```\n接下来，我想画一个比较瘦的卡通人物，那么定义PersonThinBuilder并实现IDrawPerson类\n\n```\npublic class Person {\n\tprivate String head;\n\t\n\tprivate String body;\n\t\n\tprivate String hand;\n\t\n\tprivate String leg;\n\t\n\t...  //省去get、set方法\n}\n\n\npublic class PersonThinBuilder implements IDrawPerson {\n\tprivate Person mPerson;\n\t\n\tpublic PersonThinBuilder() {\n\t\tsuper();\n\t\tmPerson=new Person();\n\t}\n\n\t@Override\n\tpublic void drawHead() {\n\t\tmPerson.setHead(\"draw head\");\n\t\t\n\t}\n\n\t@Override\n\tpublic void drawBody() {\n\t\tmPerson.setBody(\"draw thin body\");\n\t}\n\n\t@Override\n\tpublic void drawHand() {\n\t\tmPerson.setHand(\"draa hand\");\n\t}\n\n\t@Override\n\tpublic void drawLeg() {\n\t\tmPerson.setLeg(\"draw leg\");\n\t}\n\n\t@Override\n\tpublic Person buildPerson() {\n\t\treturn mPerson;\n\t}\n}\n```\n\n同样，如果我想再画一个胖人或者高个子都用类似代码实现这个类就可以了。\n\n接下来看建造者模式中很重要的一个类，指挥者类，用这个类来控制建造过程或者隔离用户与建造过程的关联。\n\n```\npublic class PersonDirector {\n\tpublic Person CreatePerson(IDrawPerson buildPerson) {\n\t\tbuildPerson.drawHead();\n\t\tbuildPerson.drawBody();\n\t\tbuildPerson.drawHand();\n\t\tbuildPerson.drawLeg();\n\t\treturn buildPerson.buildPerson();\n\t}\n}\n```\n最后来看创建一个建造者模式的测试类：\n\n```\npublic class BuildTest {\n\tpublic static void main(String[] args) {\n\t\tPersonDirector personDirector=new PersonDirector();\n\t\tPerson thinPerson=personDirector.CreatePerson(new PersonThinBuilder());\n\t\tSystem.out.println(thinPerson.getBody());\n\t}\n}\n```\n\n输出结果：\n\n> draw thin body\n\n","source":"_posts/1.浅析Java设计模式（一）.md","raw":"---\ntitle: 浅析Java设计模式（一）\ndate: 2016-07-24 16:58:29\ntags:\n- 设计模式\n---\n\n设计模式可以分为三大类\n**1.创建型模式** 这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。该类设计模式有五种:\n\n - 简单工厂模式（Factory Pattern） \n - 建造者模式（Builder Pattern）\n - 单例模式（SingletonPattern）    \n - 原型模式（Prototype Pattern）\n - 抽象工厂模式（Abstract Factory Pattern） \n\n**2.结构型模式** 这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。该类模式有五种：\n\n -  代理模式（Proxy Pattern）\n -  装饰器模式（Decorator Pattern）  \n - 适配器模式（Adapter Pattern）\n -  组合模式（Composite Pattern）   \n - 桥接模式（Bridge Pattern）  \n -  外观模式（FacadePattern）   \n -  过滤器模式（Filter、CriteriaPattern）  \n\n**3.行为型模式**  这些设计模式特别关注对象之间的通信。\n - 观察者模式（Observer Pattern）\n - 中介者模式（Mediator Pattern）\n - 策略模式（Strategy Pattern）\n - 责任链模式（Chain of Responsibility Pattern）\n - 命令模式（Command Pattern）\n - 解释器模式（Interpreter Pattern）\n - 迭代器模式（Iterator Pattern）\n - 备忘录模式（Memento Pattern）\n - 状态模式（State Pattern）\n - 空对象模式（Null Object Pattern）\n - 模板模式（Template Pattern）\n - 访问者模式（Visitor Pattern）\n《浅析Java设计模式》将分为三篇分别对三类设计模式中比较常用且典型的几种模式做讲解。本篇文章是第一篇将从创建型模式中挑选简单工厂模式、单例模式以及建造者模式来解析。\n\n一、简单工厂模式\n------\n简单工厂模式就是建立一个工厂类，对实现了同一接口的一些类进行实例的创建。简单工厂模式的实质是由一个工厂类根据传入的参数，动态决定应该创建哪一个产品类（这些产品类继承自一个父类或接口）的实例。\n简单工厂模式UML\n我们以画矩形、三角形以及圆为例，对于三种图形，可以抽象出来一个Shape，它们有共同的draw方法。并且让三种图形均实现Shape接口。简单工厂模式UML图如下所示：\n![简单工厂模式](https://raw.githubusercontent.com/zhpanvip/Resource/master/image/0101.jfif)\n\n1.首先定义Shape接口，接口中有三种图形共有的draw方法：\n```\npublic interface Shape {\n\tvoid draw();\n}\n```\n2.创建三种形状并实现Shape接口：\n矩形类：\n```\npublic class Rectangle implements Shape {\n\t@Override\n\tpublic void draw() {\n\t\tSystem.out.println(\"Draw a Rectangle\");\n\t}\n}\n```\n三角形：\n```\npublic class Triangle implements Shape {\n\t@Override\n\tpublic void draw() {\n\t\tSystem.out.println(\"Draw a Triangle\");\n\t}\n}\n```\n圆形：\n```\npublic class Circle implements Shape {\n\t@Override\n\tpublic void draw() {\n\t\tSystem.out.println(\"Draw a circle\");\n\t}\n}\n```\n3.创建工厂类，并根据参数信息画出对应的图形：\n\n```\npublic class ShapFactory {\n\t //使用 getShape 方法获取形状类型的对象\n\t   public Shape getShape(String shapeType){\n\t      if(shapeType == null){\n\t         return null;\n\t      }        \n\t      if(shapeType.equals(\"Circle\")){\n\t         return new Circle();\n\t      } else if(shapeType.equals(\"Rectangle\")){\n\t         return new Rectangle();\n\t      } else if(shapeType.equals(\"Triangle\")){\n\t         return new Triangle();\n\t      }\n\t      return null;\n\t   }\n}\n```\n4.接下来，我们创建一个测试类：\n\n```\npublic class FactoryTest {\n\n\tpublic static void main(String[] args) {\n\t\tShapFactory shapFactory = new ShapFactory();\n\n\t\tShape shapeCircle = shapFactory.getShape(\"Circle\");\n\t\tshapeCircle.draw();\n\n\t\tShape shapeRectangle = shapFactory.getShape(\"Rectangle\");\n\t\tshapeRectangle.draw();\n\n\t\tShape shapeTriangle = shapFactory.getShape(\"Triangle\");\n\t\tshapeTriangle.draw();\n\n\t\tShape shapeSquare = shapFactory.getShape(\"Square\");\n\t\tif (shapeSquare == null) {\n\t\t\tSystem.out.println(\"shapeSquare is null!\");\n\t\t} else {\n\t\t\tshapeSquare.draw();\n\t\t}\n\t}\n}\n```\n\n 输出结果： \n> Draw a circle   \n> Draw a Rectangle  \n>  Draw a Triangle \n> shapeSquare isnull!\n\n二、单例模式\n------\n单例模式（Singleton Pattern），保证一个类仅有一个实例，并提供一个访问它的全局访问方法。单例模式需要我们把显示定义的构造方法私有化，不允许外部对它实例化。单例模式的结构图如下所示。\n\n![单例模式](https://raw.githubusercontent.com/zhpanvip/Resource/master/image/0102.png)\n\n**1.一个简单的单例模式实现。**\n\n```\npublic class Singleton {\n\tprivate static Singleton instance;\n\n\tprivate Singleton() {\n\t}\n\n\tpublic static Singleton getInstance() {\n\t\tif(instance==null) {\n\t\t\tinstance = new Singleton();\n\t\t}\n\t\treturn instance;\n\t}\n\t\n\tpublic void openWindow() {\n\t\tSystem.out.println(\"Open a Window\");\n\t}\n}\n```\n上面就是一个最简单的单例模式，我们来写一个测试类：\n\n```\npublic class SingleTest {\n\tpublic static void main(String[] args) {\n\t\tSingleton single1=Singleton.getInstance();\n\t\tSingleton single2=Singleton.getInstance();\n\t\tSystem.out.println(\"single1.equals(single2)---\"+single1.equals(single2));\n\t}\n}\n```\n输出结果：\n\n> single1.equals(single2)---true\n\n从输出结果可以看出两次调用getInstance得到的是同一个Singleton 实例。\n\n上面仅仅是实现单例的一种方式，在调用时实例化对象我们称之为懒汉式，上面的代码有一个弊端，就是不支持多线程调用，在多线程调用的情况下可能会被实例化出多个实例，因此，严格来讲它并不是真正的单例模式！接下来我们继续来看几种单例模式的实现方法，并且来保证它的线程安全。\n**2.线程安全的懒汉式单例模式**\n\n```\npublic class Singleton {\n\tprivate static Singleton instance;\n\n\tprivate Singleton() {}\n\n\tpublic static synchronized  Singleton getInstance() {\n\t\tif(instance==null) {\n\t\t\tinstance = new Singleton();\n\t\t}\n\t\treturn instance;\n\t}\n\t\n\tpublic void openWindow() {\n\t\tSystem.out.println(\"Open a Window\");\n\t}\n}\n```\n如上代码，我们仅仅在getInstance方法上加了一个synchronized 锁，从而保证了线程的安全。但是我们又不得不考虑一个问题，即每次调用getInstance的时候都会加锁，这种做法势必影响了程序的性能，所以还有待改良。\n**3.双重锁定的单例模式**\n\n```\npublic class Singleton {\n\tprivate static Singleton instance;\n\n\tprivate Singleton() {\n\t}\n\n\t//\t双重校验锁 线程安全  不用让线程每次都加锁，只有在未实例化时加锁，提高性能。\n\tpublic static Singleton2 getInstance3() {\n\t\tif (instance == null) {//先判断实例是否存在，不存在再加锁处理\n\t\t\tsynchronized (Singleton2.class) {\n\t\t\t\tif(instance==null) {\n\t\t\t\t\tinstance=new Singleton2();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn instance;\n\t}\n\t\n\tpublic void openWindow() {\n\t\tSystem.out.println(\"Open a Window\");\n\t}\n}\n\n```\n上述代码中为什么两次判断instance是否为null？假如instance为null并且同时又两个线程调用getInstance()方法，它们将同时通过第一重instance==null的判断。然后由于锁机制，这两个线程只能有一个进入，另一个在外排队等候。等到第一个执行完后另一个线程才能进入。而此时如果没有第二重instance是否为空的判断，则第一个线程创建了实例，而第二个线程还是可以继续创建实例。这样没有达到单例的目的。\n**4.饿汉式实现单例模式**\n前三种我们讲解了懒汉式实现单例。那么还有一种在类加载时就创建对象的单例模式的实现方法我们称之为饿汉式。代码如下：\n\n```\npublic class Singleton {\n\tprivate static Singleton instance=new Singleton();\n\n\tprivate Singleton() {\n\t}\n\n\tpublic static Singleton getInstance() {\n\t\treturn instance;\n\t}\n\t\n\tpublic void openWindow() {\n\t\tSystem.out.println(\"Open a Window\");\n\t}\n}\n```\n这种单例模式基于 classloader 机制避免了多线程的同步问题。但因为instance在类加载时就被实例化了，因此存在内存浪费的可能性。\n\n三、建造者模式\n-------\n建造者模式是将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。\n我们以画卡通人物为例，画一个卡通人物需要完成头、身体、手、腿的绘制。那么，我们就可以抽象出一个IDrawPerson的接口\n\n```\npublic interface IDrawPerson {\n\t\n\t void drawHead();\n\t \n\t void drawBody();\n\t \n\t void drawHand();\n\t \n\t void drawLeg();\n\t \n\t Person buildPerson();\n}\n```\n接下来，我想画一个比较瘦的卡通人物，那么定义PersonThinBuilder并实现IDrawPerson类\n\n```\npublic class Person {\n\tprivate String head;\n\t\n\tprivate String body;\n\t\n\tprivate String hand;\n\t\n\tprivate String leg;\n\t\n\t...  //省去get、set方法\n}\n\n\npublic class PersonThinBuilder implements IDrawPerson {\n\tprivate Person mPerson;\n\t\n\tpublic PersonThinBuilder() {\n\t\tsuper();\n\t\tmPerson=new Person();\n\t}\n\n\t@Override\n\tpublic void drawHead() {\n\t\tmPerson.setHead(\"draw head\");\n\t\t\n\t}\n\n\t@Override\n\tpublic void drawBody() {\n\t\tmPerson.setBody(\"draw thin body\");\n\t}\n\n\t@Override\n\tpublic void drawHand() {\n\t\tmPerson.setHand(\"draa hand\");\n\t}\n\n\t@Override\n\tpublic void drawLeg() {\n\t\tmPerson.setLeg(\"draw leg\");\n\t}\n\n\t@Override\n\tpublic Person buildPerson() {\n\t\treturn mPerson;\n\t}\n}\n```\n\n同样，如果我想再画一个胖人或者高个子都用类似代码实现这个类就可以了。\n\n接下来看建造者模式中很重要的一个类，指挥者类，用这个类来控制建造过程或者隔离用户与建造过程的关联。\n\n```\npublic class PersonDirector {\n\tpublic Person CreatePerson(IDrawPerson buildPerson) {\n\t\tbuildPerson.drawHead();\n\t\tbuildPerson.drawBody();\n\t\tbuildPerson.drawHand();\n\t\tbuildPerson.drawLeg();\n\t\treturn buildPerson.buildPerson();\n\t}\n}\n```\n最后来看创建一个建造者模式的测试类：\n\n```\npublic class BuildTest {\n\tpublic static void main(String[] args) {\n\t\tPersonDirector personDirector=new PersonDirector();\n\t\tPerson thinPerson=personDirector.CreatePerson(new PersonThinBuilder());\n\t\tSystem.out.println(thinPerson.getBody());\n\t}\n}\n```\n\n输出结果：\n\n> draw thin body\n\n","slug":"1.浅析Java设计模式（一）","published":1,"updated":"2020-08-29T18:02:54.615Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckegm5nrm0001dwoz6qr9gbhu","content":"<p>设计模式可以分为三大类<br><strong>1.创建型模式</strong> 这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。该类设计模式有五种:</p>\n<ul>\n<li>简单工厂模式（Factory Pattern） </li>\n<li>建造者模式（Builder Pattern）</li>\n<li>单例模式（SingletonPattern）    </li>\n<li>原型模式（Prototype Pattern）</li>\n<li>抽象工厂模式（Abstract Factory Pattern） </li>\n</ul>\n<p><strong>2.结构型模式</strong> 这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。该类模式有五种：</p>\n<ul>\n<li>代理模式（Proxy Pattern）</li>\n<li>装饰器模式（Decorator Pattern）  </li>\n<li>适配器模式（Adapter Pattern）</li>\n<li>组合模式（Composite Pattern）   </li>\n<li>桥接模式（Bridge Pattern）  </li>\n<li>外观模式（FacadePattern）   </li>\n<li>过滤器模式（Filter、CriteriaPattern）  </li>\n</ul>\n<p><strong>3.行为型模式</strong>  这些设计模式特别关注对象之间的通信。</p>\n<ul>\n<li>观察者模式（Observer Pattern）</li>\n<li>中介者模式（Mediator Pattern）</li>\n<li>策略模式（Strategy Pattern）</li>\n<li>责任链模式（Chain of Responsibility Pattern）</li>\n<li>命令模式（Command Pattern）</li>\n<li>解释器模式（Interpreter Pattern）</li>\n<li>迭代器模式（Iterator Pattern）</li>\n<li>备忘录模式（Memento Pattern）</li>\n<li>状态模式（State Pattern）</li>\n<li>空对象模式（Null Object Pattern）</li>\n<li>模板模式（Template Pattern）</li>\n<li>访问者模式（Visitor Pattern）<br>《浅析Java设计模式》将分为三篇分别对三类设计模式中比较常用且典型的几种模式做讲解。本篇文章是第一篇将从创建型模式中挑选简单工厂模式、单例模式以及建造者模式来解析。</li>\n</ul>\n<h2 id=\"一、简单工厂模式\"><a href=\"#一、简单工厂模式\" class=\"headerlink\" title=\"一、简单工厂模式\"></a>一、简单工厂模式</h2><p>简单工厂模式就是建立一个工厂类，对实现了同一接口的一些类进行实例的创建。简单工厂模式的实质是由一个工厂类根据传入的参数，动态决定应该创建哪一个产品类（这些产品类继承自一个父类或接口）的实例。<br>简单工厂模式UML<br>我们以画矩形、三角形以及圆为例，对于三种图形，可以抽象出来一个Shape，它们有共同的draw方法。并且让三种图形均实现Shape接口。简单工厂模式UML图如下所示：<br><img src=\"https://raw.githubusercontent.com/zhpanvip/Resource/master/image/0101.jfif\" alt=\"简单工厂模式\"></p>\n<p>1.首先定义Shape接口，接口中有三种图形共有的draw方法：</p>\n<pre><code class=\"hljs routeros\">public<span class=\"hljs-built_in\"> interface </span>Shape &#123;\n\tvoid draw();\n&#125;</code></pre>\n<p>2.创建三种形状并实现Shape接口：<br>矩形类：</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Rectangle</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">Shape</span> </span>&#123;\n\t<span class=\"hljs-meta\">@Override</span>\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">draw</span><span class=\"hljs-params\">()</span> </span>&#123;\n\t\tSystem.out.println(<span class=\"hljs-string\">&quot;Draw a Rectangle&quot;</span>);\n\t&#125;\n&#125;</code></pre>\n<p>三角形：</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Triangle</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">Shape</span> </span>&#123;\n\t<span class=\"hljs-meta\">@Override</span>\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">draw</span><span class=\"hljs-params\">()</span> </span>&#123;\n\t\tSystem.out.println(<span class=\"hljs-string\">&quot;Draw a Triangle&quot;</span>);\n\t&#125;\n&#125;</code></pre>\n<p>圆形：</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Circle</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">Shape</span> </span>&#123;\n\t<span class=\"hljs-meta\">@Override</span>\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">draw</span><span class=\"hljs-params\">()</span> </span>&#123;\n\t\tSystem.out.println(<span class=\"hljs-string\">&quot;Draw a circle&quot;</span>);\n\t&#125;\n&#125;</code></pre>\n<p>3.创建工厂类，并根据参数信息画出对应的图形：</p>\n<pre><code class=\"hljs csharp\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ShapFactory</span> &#123;\n\t <span class=\"hljs-comment\">//使用 getShape 方法获取形状类型的对象</span>\n\t   <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> Shape <span class=\"hljs-title\">getShape</span>(<span class=\"hljs-params\">String shapeType</span>)</span>&#123;\n\t      <span class=\"hljs-keyword\">if</span>(shapeType == <span class=\"hljs-literal\">null</span>)&#123;\n\t         <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">null</span>;\n\t      &#125;        \n\t      <span class=\"hljs-keyword\">if</span>(shapeType.<span class=\"hljs-keyword\">equals</span>(<span class=\"hljs-string\">&quot;Circle&quot;</span>))&#123;\n\t         <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> Circle();\n\t      &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(shapeType.<span class=\"hljs-keyword\">equals</span>(<span class=\"hljs-string\">&quot;Rectangle&quot;</span>))&#123;\n\t         <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> Rectangle();\n\t      &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(shapeType.<span class=\"hljs-keyword\">equals</span>(<span class=\"hljs-string\">&quot;Triangle&quot;</span>))&#123;\n\t         <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> Triangle();\n\t      &#125;\n\t      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">null</span>;\n\t   &#125;\n&#125;</code></pre>\n<p>4.接下来，我们创建一个测试类：</p>\n<pre><code class=\"hljs mipsasm\">public class FactoryTest &#123;\n\n\tpublic static void main(String[] args) &#123;\n\t\t<span class=\"hljs-keyword\">ShapFactory </span><span class=\"hljs-keyword\">shapFactory </span>= new <span class=\"hljs-keyword\">ShapFactory();</span>\n<span class=\"hljs-keyword\"></span>\n<span class=\"hljs-keyword\">\t</span>\t<span class=\"hljs-keyword\">Shape </span><span class=\"hljs-keyword\">shapeCircle </span>= <span class=\"hljs-keyword\">shapFactory.getShape(&quot;Circle&quot;);</span>\n<span class=\"hljs-keyword\">\t</span>\t<span class=\"hljs-keyword\">shapeCircle.draw();</span>\n<span class=\"hljs-keyword\"></span>\n<span class=\"hljs-keyword\">\t</span>\t<span class=\"hljs-keyword\">Shape </span><span class=\"hljs-keyword\">shapeRectangle </span>= <span class=\"hljs-keyword\">shapFactory.getShape(&quot;Rectangle&quot;);</span>\n<span class=\"hljs-keyword\">\t</span>\t<span class=\"hljs-keyword\">shapeRectangle.draw();</span>\n<span class=\"hljs-keyword\"></span>\n<span class=\"hljs-keyword\">\t</span>\t<span class=\"hljs-keyword\">Shape </span><span class=\"hljs-keyword\">shapeTriangle </span>= <span class=\"hljs-keyword\">shapFactory.getShape(&quot;Triangle&quot;);</span>\n<span class=\"hljs-keyword\">\t</span>\t<span class=\"hljs-keyword\">shapeTriangle.draw();</span>\n<span class=\"hljs-keyword\"></span>\n<span class=\"hljs-keyword\">\t</span>\t<span class=\"hljs-keyword\">Shape </span><span class=\"hljs-keyword\">shapeSquare </span>= <span class=\"hljs-keyword\">shapFactory.getShape(&quot;Square&quot;);</span>\n<span class=\"hljs-keyword\">\t</span>\tif (<span class=\"hljs-keyword\">shapeSquare </span>== null) &#123;\n\t\t\tSystem.out.println(<span class=\"hljs-string\">&quot;shapeSquare is null!&quot;</span>);\n\t\t&#125; else &#123;\n\t\t\t<span class=\"hljs-keyword\">shapeSquare.draw();</span>\n<span class=\"hljs-keyword\">\t</span>\t&#125;\n\t&#125;\n&#125;</code></pre>\n\n<p> 输出结果： </p>\n<blockquote>\n<p>Draw a circle<br>Draw a Rectangle<br> Draw a Triangle<br>shapeSquare isnull!</p>\n</blockquote>\n<h2 id=\"二、单例模式\"><a href=\"#二、单例模式\" class=\"headerlink\" title=\"二、单例模式\"></a>二、单例模式</h2><p>单例模式（Singleton Pattern），保证一个类仅有一个实例，并提供一个访问它的全局访问方法。单例模式需要我们把显示定义的构造方法私有化，不允许外部对它实例化。单例模式的结构图如下所示。</p>\n<p><img src=\"https://raw.githubusercontent.com/zhpanvip/Resource/master/image/0102.png\" alt=\"单例模式\"></p>\n<p><strong>1.一个简单的单例模式实现。</strong></p>\n<pre><code class=\"hljs routeros\">public class Singleton &#123;\n\tprivate static Singleton instance;\n\n\tprivate Singleton() &#123;\n\t&#125;\n\n\tpublic static Singleton getInstance() &#123;\n\t\t<span class=\"hljs-keyword\">if</span>(<span class=\"hljs-attribute\">instance</span>==null) &#123;\n\t\t<span class=\"hljs-built_in\">\tinstance </span>= new Singleton();\n\t\t&#125;\n\t\treturn instance;\n\t&#125;\n\t\n\tpublic void openWindow() &#123;\n\t\tSystem.out.println(<span class=\"hljs-string\">&quot;Open a Window&quot;</span>);\n\t&#125;\n&#125;</code></pre>\n<p>上面就是一个最简单的单例模式，我们来写一个测试类：</p>\n<pre><code class=\"hljs arduino\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">SingleTest</span> &#123;</span>\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">String</span>[] args)</span> </span>&#123;\n\t\tSingleton single1=Singleton.getInstance();\n\t\tSingleton single2=Singleton.getInstance();\n\t\tSystem.out.<span class=\"hljs-built_in\">println</span>(<span class=\"hljs-string\">&quot;single1.equals(single2)---&quot;</span>+single1.equals(single2));\n\t&#125;\n&#125;</code></pre>\n<p>输出结果：</p>\n<blockquote>\n<p>single1.equals(single2)—true</p>\n</blockquote>\n<p>从输出结果可以看出两次调用getInstance得到的是同一个Singleton 实例。</p>\n<p>上面仅仅是实现单例的一种方式，在调用时实例化对象我们称之为懒汉式，上面的代码有一个弊端，就是不支持多线程调用，在多线程调用的情况下可能会被实例化出多个实例，因此，严格来讲它并不是真正的单例模式！接下来我们继续来看几种单例模式的实现方法，并且来保证它的线程安全。<br><strong>2.线程安全的懒汉式单例模式</strong></p>\n<pre><code class=\"hljs routeros\">public class Singleton &#123;\n\tprivate static Singleton instance;\n\n\tprivate Singleton() &#123;&#125;\n\n\tpublic static synchronized  Singleton getInstance() &#123;\n\t\t<span class=\"hljs-keyword\">if</span>(<span class=\"hljs-attribute\">instance</span>==null) &#123;\n\t\t<span class=\"hljs-built_in\">\tinstance </span>= new Singleton();\n\t\t&#125;\n\t\treturn instance;\n\t&#125;\n\t\n\tpublic void openWindow() &#123;\n\t\tSystem.out.println(<span class=\"hljs-string\">&quot;Open a Window&quot;</span>);\n\t&#125;\n&#125;</code></pre>\n<p>如上代码，我们仅仅在getInstance方法上加了一个synchronized 锁，从而保证了线程的安全。但是我们又不得不考虑一个问题，即每次调用getInstance的时候都会加锁，这种做法势必影响了程序的性能，所以还有待改良。<br><strong>3.双重锁定的单例模式</strong></p>\n<pre><code class=\"hljs csharp\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Singleton</span> &#123;\n\t<span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> Singleton instance;\n\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-title\">Singleton</span>(<span class=\"hljs-params\"></span>)</span> &#123;\n\t&#125;\n\n\t<span class=\"hljs-comment\">//\t双重校验锁 线程安全  不用让线程每次都加锁，只有在未实例化时加锁，提高性能。</span>\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> Singleton2 <span class=\"hljs-title\">getInstance3</span>(<span class=\"hljs-params\"></span>)</span> &#123;\n\t\t<span class=\"hljs-keyword\">if</span> (instance == <span class=\"hljs-literal\">null</span>) &#123;<span class=\"hljs-comment\">//先判断实例是否存在，不存在再加锁处理</span>\n\t\t\tsynchronized (Singleton2.class) &#123;\n\t\t\t\t<span class=\"hljs-keyword\">if</span>(instance==<span class=\"hljs-literal\">null</span>) &#123;\n\t\t\t\t\tinstance=<span class=\"hljs-keyword\">new</span> Singleton2();\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&#125;\n\t\t<span class=\"hljs-keyword\">return</span> instance;\n\t&#125;\n\t\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">openWindow</span>(<span class=\"hljs-params\"></span>)</span> &#123;\n\t\tSystem.<span class=\"hljs-keyword\">out</span>.println(<span class=\"hljs-string\">&quot;Open a Window&quot;</span>);\n\t&#125;\n&#125;\n</code></pre>\n<p>上述代码中为什么两次判断instance是否为null？假如instance为null并且同时又两个线程调用getInstance()方法，它们将同时通过第一重instance==null的判断。然后由于锁机制，这两个线程只能有一个进入，另一个在外排队等候。等到第一个执行完后另一个线程才能进入。而此时如果没有第二重instance是否为空的判断，则第一个线程创建了实例，而第二个线程还是可以继续创建实例。这样没有达到单例的目的。<br><strong>4.饿汉式实现单例模式</strong><br>前三种我们讲解了懒汉式实现单例。那么还有一种在类加载时就创建对象的单例模式的实现方法我们称之为饿汉式。代码如下：</p>\n<pre><code class=\"hljs arduino\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Singleton</span> &#123;</span>\n\t<span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> Singleton instance=<span class=\"hljs-keyword\">new</span> Singleton();\n\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-title\">Singleton</span><span class=\"hljs-params\">()</span> </span>&#123;\n\t&#125;\n\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> Singleton <span class=\"hljs-title\">getInstance</span><span class=\"hljs-params\">()</span> </span>&#123;\n\t\t<span class=\"hljs-keyword\">return</span> instance;\n\t&#125;\n\t\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">openWindow</span><span class=\"hljs-params\">()</span> </span>&#123;\n\t\tSystem.out.<span class=\"hljs-built_in\">println</span>(<span class=\"hljs-string\">&quot;Open a Window&quot;</span>);\n\t&#125;\n&#125;</code></pre>\n<p>这种单例模式基于 classloader 机制避免了多线程的同步问题。但因为instance在类加载时就被实例化了，因此存在内存浪费的可能性。</p>\n<h2 id=\"三、建造者模式\"><a href=\"#三、建造者模式\" class=\"headerlink\" title=\"三、建造者模式\"></a>三、建造者模式</h2><p>建造者模式是将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。<br>我们以画卡通人物为例，画一个卡通人物需要完成头、身体、手、腿的绘制。那么，我们就可以抽象出一个IDrawPerson的接口</p>\n<pre><code class=\"hljs csharp\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">IDrawPerson</span> &#123;\n\t\n\t <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">drawHead</span>(<span class=\"hljs-params\"></span>)</span>;\n\t \n\t <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">drawBody</span>(<span class=\"hljs-params\"></span>)</span>;\n\t \n\t <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">drawHand</span>(<span class=\"hljs-params\"></span>)</span>;\n\t \n\t <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">drawLeg</span>(<span class=\"hljs-params\"></span>)</span>;\n\t \n\t <span class=\"hljs-function\">Person <span class=\"hljs-title\">buildPerson</span>(<span class=\"hljs-params\"></span>)</span>;\n&#125;</code></pre>\n<p>接下来，我想画一个比较瘦的卡通人物，那么定义PersonThinBuilder并实现IDrawPerson类</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Person</span> </span>&#123;\n\t<span class=\"hljs-keyword\">private</span> String head;\n\t\n\t<span class=\"hljs-keyword\">private</span> String body;\n\t\n\t<span class=\"hljs-keyword\">private</span> String hand;\n\t\n\t<span class=\"hljs-keyword\">private</span> String leg;\n\t\n\t...  <span class=\"hljs-comment\">//省去get、set方法</span>\n&#125;\n\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">PersonThinBuilder</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">IDrawPerson</span> </span>&#123;\n\t<span class=\"hljs-keyword\">private</span> Person mPerson;\n\t\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">PersonThinBuilder</span><span class=\"hljs-params\">()</span> </span>&#123;\n\t\t<span class=\"hljs-keyword\">super</span>();\n\t\tmPerson=<span class=\"hljs-keyword\">new</span> Person();\n\t&#125;\n\n\t<span class=\"hljs-meta\">@Override</span>\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">drawHead</span><span class=\"hljs-params\">()</span> </span>&#123;\n\t\tmPerson.setHead(<span class=\"hljs-string\">&quot;draw head&quot;</span>);\n\t\t\n\t&#125;\n\n\t<span class=\"hljs-meta\">@Override</span>\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">drawBody</span><span class=\"hljs-params\">()</span> </span>&#123;\n\t\tmPerson.setBody(<span class=\"hljs-string\">&quot;draw thin body&quot;</span>);\n\t&#125;\n\n\t<span class=\"hljs-meta\">@Override</span>\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">drawHand</span><span class=\"hljs-params\">()</span> </span>&#123;\n\t\tmPerson.setHand(<span class=\"hljs-string\">&quot;draa hand&quot;</span>);\n\t&#125;\n\n\t<span class=\"hljs-meta\">@Override</span>\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">drawLeg</span><span class=\"hljs-params\">()</span> </span>&#123;\n\t\tmPerson.setLeg(<span class=\"hljs-string\">&quot;draw leg&quot;</span>);\n\t&#125;\n\n\t<span class=\"hljs-meta\">@Override</span>\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> Person <span class=\"hljs-title\">buildPerson</span><span class=\"hljs-params\">()</span> </span>&#123;\n\t\t<span class=\"hljs-keyword\">return</span> mPerson;\n\t&#125;\n&#125;</code></pre>\n\n<p>同样，如果我想再画一个胖人或者高个子都用类似代码实现这个类就可以了。</p>\n<p>接下来看建造者模式中很重要的一个类，指挥者类，用这个类来控制建造过程或者隔离用户与建造过程的关联。</p>\n<pre><code class=\"hljs reasonml\">public <span class=\"hljs-keyword\">class</span> PersonDirector &#123;\n\tpublic Person <span class=\"hljs-constructor\">CreatePerson(IDrawPerson <span class=\"hljs-params\">buildPerson</span>)</span> &#123;\n\t\tbuildPerson.draw<span class=\"hljs-constructor\">Head()</span>;\n\t\tbuildPerson.draw<span class=\"hljs-constructor\">Body()</span>;\n\t\tbuildPerson.draw<span class=\"hljs-constructor\">Hand()</span>;\n\t\tbuildPerson.draw<span class=\"hljs-constructor\">Leg()</span>;\n\t\treturn buildPerson.build<span class=\"hljs-constructor\">Person()</span>;\n\t&#125;\n&#125;</code></pre>\n<p>最后来看创建一个建造者模式的测试类：</p>\n<pre><code class=\"hljs arduino\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">BuildTest</span> &#123;</span>\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">String</span>[] args)</span> </span>&#123;\n\t\tPersonDirector personDirector=<span class=\"hljs-keyword\">new</span> PersonDirector();\n\t\tPerson thinPerson=personDirector.CreatePerson(<span class=\"hljs-keyword\">new</span> PersonThinBuilder());\n\t\tSystem.out.<span class=\"hljs-built_in\">println</span>(thinPerson.getBody());\n\t&#125;\n&#125;</code></pre>\n\n<p>输出结果：</p>\n<blockquote>\n<p>draw thin body</p>\n</blockquote>\n","site":{"data":{"fluid_config":{"favicon":"/img/favicon.png","apple_touch_icon":"/img/favicon.png","title_join_string":" - ","force_https":false,"highlight":{"enable":true,"style":"Github Gist","bg_color":false,"copy_btn":true},"fun_features":{"typing":{"enable":true,"typeSpeed":70,"cursorChar":"|","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"mouse_click":{"enable":false,"style":"values"}},"dark_mode":{"enable":true,"default":"auto"},"color":{"body_bg_color":"#eee","body_bg_color_dark":"#181c27","navbar_bg_color":"#2f4154","navbar_bg_color_dark":"#1f3144","navbar_text_color":"#fff","navbar_text_color_dark":"#d0d0d0","text_color":"#3c4858","text_color_dark":"#c4c6c9","sec_text_color":"#718096","sec_text_color_dark":"#a7a9ad","post_text_color":"#2c3e50","post_text_color_dark":"#c4c6c9","post_heading_color":"#1a202c","post_heading_color_dark":"#c4c6c9","post_link_color":"#0366d6","post_link_color_dark":"#1589e9","link_hover_color":"#30a9de","link_hover_color_dark":"#30a9de","link_hover_bg_color":"#f8f9fa","link_hover_bg_color_dark":"#364151","board_color":"#fff","board_color_dark":"#252d38"},"font":{"font_size":"16px","font_family":null,"code_font_size":"85%"},"custom_js":null,"custom_css":null,"custom_html":"","web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"tajs":null,"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}},"lazyload":{"enable":true,"onlypost":false},"daovoice":{"enable":false,"appid":""},"aplayer":{"enable":false,"autoplay":false,"loop":"all","order":"random","theme":"#b7daff","songs":[{"name":"name","artist":"artist","url":"/songs/test.mp3","cover":"/img/cover.jpg"},{"name":"name","artist":"artist","url":"https://...url.mp3","cover":"https://...cover.jpg"}]},"version":{"check":false},"navbar":{"blog_title":"zhangpan","ground_glass":{"enable":false,"px":3,"alpha":0.7},"menu":[{"key":"home","link":"/","icon":"iconfont icon-home-fill"},{"key":"archive","link":"/archives/","icon":"iconfont icon-archive-fill"},{"key":"category","link":"/categories/","icon":"iconfont icon-category-fill"},{"key":"tag","link":"/tags/","icon":"iconfont icon-tags-fill"},{"key":"about","link":"/about/","icon":"iconfont icon-user-fill"}]},"search":{"enable":true,"path":"/local-search.xml","generate_path":"/local-search.xml","field":"post","content":true},"scroll_down_arrow":{"enable":true,"banner_height_limit":90,"scroll_after_turning_page":true},"banner_parallax":true,"footer":{"statistics":{"enable":false,"source":"busuanzi","pv_format":"总访问量 {} 次","uv_format":"总访客数 {} 人"},"beian":{"enable":false,"icp_text":"京ICP证123456号","police_text":"京公网安备12345678号","police_code":12345678,"police_icon":"/img/police_beian.png"}},"scroll_top_arrow":{"enable":true},"index":{"banner_img":"/img/default.png","banner_img_height":100,"banner_mask_alpha":0.3,"post_default_img":"","slogan":{"enable":true,"text":"Talk is cheap, show me the code."},"auto_excerpt":{"enable":true},"post_url_target":"_self","post_meta":{"date":true,"category":true,"tag":true}},"page":{"banner_img":"/img/default.png","banner_img_height":60,"banner_mask_alpha":0.3},"post":{"banner_img":"/img/default.png","banner_img_height":70,"banner_mask_alpha":0.3,"meta":{"date":{"enable":true,"format":"LL a"},"wordcount":{"enable":true,"format":"{} 字"},"min2read":{"enable":true,"format":"{} 分钟","words":100},"views":{"enable":false,"source":"busuanzi","format":"{} 次"}},"updated":{"enable":false,"content":"本文最后更新于：","relative":false},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"copyright":{"enable":true,"content":"本博客所有文章除特别声明外，均采用 <a href=\"https://creativecommons.org/licenses/by-sa/4.0/deed.zh\" rel=\"nofollow noopener\">CC BY-SA 4.0 协议</a> ，转载请注明出处！ <h5>开源库推荐</h5> <a href=\"https://github.com/zhpanvip/BannerViewPager\">1.BannerViewPager</a> <p> 一个基于ViewPager2实现的具有强大功能的无限轮播库。支持多种页面切换效果和指示器样式。 </p>\n<a href=\"https://github.com/zhpanvip/viewpagerindicator\">2.ViewPagerIndicator</a> <p> 一个适用于ViewPager和ViewPager2的指示器，支持多种滑块样式及滑动模式 </p>"},"prev_next":{"enable":true},"custom":{"enable":false,"content":"<img src=\"https://octodex.github.com/images/jetpacktocat.png\" class=\"rounded mx-auto d-block mt-5\" style=\"width:150px; height:150px;\">"},"image_zoom":{"enable":true},"footnote":{"enable":true,"header":""},"math":{"enable":false,"specific":false,"engine":"mathjax"},"mermaid":{"enable":false,"specific":false,"options":{"theme":"default"}},"comments":{"enable":true,"type":"utterances"}},"utterances":{"repo":"zhpanvip/utterances-comment","issue_term":"pathname","label":"utterances","theme":"github-light","crossorigin":"anonymous"},"disqus":{"shortname":null,"disqusjs":false,"apikey":null},"gitalk":{"clientID":null,"clientSecret":null,"repo":null,"owner":null,"admin":["name"],"id":"location.pathname","language":"zh-CN","labels":["Gitalk"],"perPage":10,"pagerDirection":"last","distractionFreeMode":false,"createIssueManually":true},"valine":{"appid":"hXIROaIM5y9qnieojJRWP5hS","appkey":"y0f3w3aqd1MF7JL9ma4WECTy","placeholder":"说点什么","path":"window.location.pathname","avatar":"retro","meta":["nick","mail","link"],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"https://zhangpan.site"},"changyan":{"appid":"","appkey":""},"livere":{"uid":""},"archive":{"banner_img":"/img/bg_article.jpg","banner_img_height":60,"banner_mask_alpha":0.3,"subtitle":null},"category":{"banner_img":"/img/bg_default.png","banner_img_height":60,"banner_mask_alpha":0.3,"subtitle":null,"post_limit":10,"order_by":"-length"},"tag":{"banner_img":"/img/bg_label.jpg","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null,"tagcloud":{"min_font":15,"max_font":30,"unit":"px","start_color":"#BBBBEE","end_color":"#337ab7"}},"about":{"banner_img":"/img/bg_default.png","banner_img_height":60,"banner_mask_alpha":0.3,"subtitle":null,"avatar":"/img/avatar.png","name":"myname","introduce":"一句简短的介绍","icons":[{"class":"iconfont icon-github-fill","link":"https://github.com","tip":"GitHub"},{"class":"iconfont icon-douban-fill","link":"https://douban.com","tip":"豆瓣"},{"class":"iconfont icon-wechat-fill","qrcode":"/img/favicon.png"}]},"page404":{"banner_img":"/img/default.png","banner_img_height":85,"banner_mask_alpha":0.3,"subtitle":"Page not found"},"links":{"banner_img":"/img/default.png","banner_img_height":60,"banner_mask_alpha":0.3,"subtitle":null,"items":[{"title":"Fluid Docs","intro":"主题使用指南","link":"https://hexo.fluid-dev.com/docs/","image":"/img/favicon.png"},{"title":"Fluid Repo","intro":"主题 GitHub 仓库","link":"https://github.com/fluid-dev/hexo-theme-fluid","image":"/img/favicon.png"},{"title":"Fluid Example","intro":"主题操作示例","link":"https://hexo.fluid-dev.com/docs/example/","image":"/img/favicon.png"}]}}}},"excerpt":"","more":"<p>设计模式可以分为三大类<br><strong>1.创建型模式</strong> 这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。该类设计模式有五种:</p>\n<ul>\n<li>简单工厂模式（Factory Pattern） </li>\n<li>建造者模式（Builder Pattern）</li>\n<li>单例模式（SingletonPattern）    </li>\n<li>原型模式（Prototype Pattern）</li>\n<li>抽象工厂模式（Abstract Factory Pattern） </li>\n</ul>\n<p><strong>2.结构型模式</strong> 这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。该类模式有五种：</p>\n<ul>\n<li>代理模式（Proxy Pattern）</li>\n<li>装饰器模式（Decorator Pattern）  </li>\n<li>适配器模式（Adapter Pattern）</li>\n<li>组合模式（Composite Pattern）   </li>\n<li>桥接模式（Bridge Pattern）  </li>\n<li>外观模式（FacadePattern）   </li>\n<li>过滤器模式（Filter、CriteriaPattern）  </li>\n</ul>\n<p><strong>3.行为型模式</strong>  这些设计模式特别关注对象之间的通信。</p>\n<ul>\n<li>观察者模式（Observer Pattern）</li>\n<li>中介者模式（Mediator Pattern）</li>\n<li>策略模式（Strategy Pattern）</li>\n<li>责任链模式（Chain of Responsibility Pattern）</li>\n<li>命令模式（Command Pattern）</li>\n<li>解释器模式（Interpreter Pattern）</li>\n<li>迭代器模式（Iterator Pattern）</li>\n<li>备忘录模式（Memento Pattern）</li>\n<li>状态模式（State Pattern）</li>\n<li>空对象模式（Null Object Pattern）</li>\n<li>模板模式（Template Pattern）</li>\n<li>访问者模式（Visitor Pattern）<br>《浅析Java设计模式》将分为三篇分别对三类设计模式中比较常用且典型的几种模式做讲解。本篇文章是第一篇将从创建型模式中挑选简单工厂模式、单例模式以及建造者模式来解析。</li>\n</ul>\n<h2 id=\"一、简单工厂模式\"><a href=\"#一、简单工厂模式\" class=\"headerlink\" title=\"一、简单工厂模式\"></a>一、简单工厂模式</h2><p>简单工厂模式就是建立一个工厂类，对实现了同一接口的一些类进行实例的创建。简单工厂模式的实质是由一个工厂类根据传入的参数，动态决定应该创建哪一个产品类（这些产品类继承自一个父类或接口）的实例。<br>简单工厂模式UML<br>我们以画矩形、三角形以及圆为例，对于三种图形，可以抽象出来一个Shape，它们有共同的draw方法。并且让三种图形均实现Shape接口。简单工厂模式UML图如下所示：<br><img src=\"https://raw.githubusercontent.com/zhpanvip/Resource/master/image/0101.jfif\" alt=\"简单工厂模式\"></p>\n<p>1.首先定义Shape接口，接口中有三种图形共有的draw方法：</p>\n<pre><code class=\"hljs routeros\">public<span class=\"hljs-built_in\"> interface </span>Shape &#123;\n\tvoid draw();\n&#125;</code></pre>\n<p>2.创建三种形状并实现Shape接口：<br>矩形类：</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Rectangle</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">Shape</span> </span>&#123;\n\t<span class=\"hljs-meta\">@Override</span>\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">draw</span><span class=\"hljs-params\">()</span> </span>&#123;\n\t\tSystem.out.println(<span class=\"hljs-string\">&quot;Draw a Rectangle&quot;</span>);\n\t&#125;\n&#125;</code></pre>\n<p>三角形：</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Triangle</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">Shape</span> </span>&#123;\n\t<span class=\"hljs-meta\">@Override</span>\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">draw</span><span class=\"hljs-params\">()</span> </span>&#123;\n\t\tSystem.out.println(<span class=\"hljs-string\">&quot;Draw a Triangle&quot;</span>);\n\t&#125;\n&#125;</code></pre>\n<p>圆形：</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Circle</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">Shape</span> </span>&#123;\n\t<span class=\"hljs-meta\">@Override</span>\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">draw</span><span class=\"hljs-params\">()</span> </span>&#123;\n\t\tSystem.out.println(<span class=\"hljs-string\">&quot;Draw a circle&quot;</span>);\n\t&#125;\n&#125;</code></pre>\n<p>3.创建工厂类，并根据参数信息画出对应的图形：</p>\n<pre><code class=\"hljs csharp\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ShapFactory</span> &#123;\n\t <span class=\"hljs-comment\">//使用 getShape 方法获取形状类型的对象</span>\n\t   <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> Shape <span class=\"hljs-title\">getShape</span>(<span class=\"hljs-params\">String shapeType</span>)</span>&#123;\n\t      <span class=\"hljs-keyword\">if</span>(shapeType == <span class=\"hljs-literal\">null</span>)&#123;\n\t         <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">null</span>;\n\t      &#125;        \n\t      <span class=\"hljs-keyword\">if</span>(shapeType.<span class=\"hljs-keyword\">equals</span>(<span class=\"hljs-string\">&quot;Circle&quot;</span>))&#123;\n\t         <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> Circle();\n\t      &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(shapeType.<span class=\"hljs-keyword\">equals</span>(<span class=\"hljs-string\">&quot;Rectangle&quot;</span>))&#123;\n\t         <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> Rectangle();\n\t      &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(shapeType.<span class=\"hljs-keyword\">equals</span>(<span class=\"hljs-string\">&quot;Triangle&quot;</span>))&#123;\n\t         <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> Triangle();\n\t      &#125;\n\t      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">null</span>;\n\t   &#125;\n&#125;</code></pre>\n<p>4.接下来，我们创建一个测试类：</p>\n<pre><code class=\"hljs mipsasm\">public class FactoryTest &#123;\n\n\tpublic static void main(String[] args) &#123;\n\t\t<span class=\"hljs-keyword\">ShapFactory </span><span class=\"hljs-keyword\">shapFactory </span>= new <span class=\"hljs-keyword\">ShapFactory();</span>\n<span class=\"hljs-keyword\"></span>\n<span class=\"hljs-keyword\">\t</span>\t<span class=\"hljs-keyword\">Shape </span><span class=\"hljs-keyword\">shapeCircle </span>= <span class=\"hljs-keyword\">shapFactory.getShape(&quot;Circle&quot;);</span>\n<span class=\"hljs-keyword\">\t</span>\t<span class=\"hljs-keyword\">shapeCircle.draw();</span>\n<span class=\"hljs-keyword\"></span>\n<span class=\"hljs-keyword\">\t</span>\t<span class=\"hljs-keyword\">Shape </span><span class=\"hljs-keyword\">shapeRectangle </span>= <span class=\"hljs-keyword\">shapFactory.getShape(&quot;Rectangle&quot;);</span>\n<span class=\"hljs-keyword\">\t</span>\t<span class=\"hljs-keyword\">shapeRectangle.draw();</span>\n<span class=\"hljs-keyword\"></span>\n<span class=\"hljs-keyword\">\t</span>\t<span class=\"hljs-keyword\">Shape </span><span class=\"hljs-keyword\">shapeTriangle </span>= <span class=\"hljs-keyword\">shapFactory.getShape(&quot;Triangle&quot;);</span>\n<span class=\"hljs-keyword\">\t</span>\t<span class=\"hljs-keyword\">shapeTriangle.draw();</span>\n<span class=\"hljs-keyword\"></span>\n<span class=\"hljs-keyword\">\t</span>\t<span class=\"hljs-keyword\">Shape </span><span class=\"hljs-keyword\">shapeSquare </span>= <span class=\"hljs-keyword\">shapFactory.getShape(&quot;Square&quot;);</span>\n<span class=\"hljs-keyword\">\t</span>\tif (<span class=\"hljs-keyword\">shapeSquare </span>== null) &#123;\n\t\t\tSystem.out.println(<span class=\"hljs-string\">&quot;shapeSquare is null!&quot;</span>);\n\t\t&#125; else &#123;\n\t\t\t<span class=\"hljs-keyword\">shapeSquare.draw();</span>\n<span class=\"hljs-keyword\">\t</span>\t&#125;\n\t&#125;\n&#125;</code></pre>\n\n<p> 输出结果： </p>\n<blockquote>\n<p>Draw a circle<br>Draw a Rectangle<br> Draw a Triangle<br>shapeSquare isnull!</p>\n</blockquote>\n<h2 id=\"二、单例模式\"><a href=\"#二、单例模式\" class=\"headerlink\" title=\"二、单例模式\"></a>二、单例模式</h2><p>单例模式（Singleton Pattern），保证一个类仅有一个实例，并提供一个访问它的全局访问方法。单例模式需要我们把显示定义的构造方法私有化，不允许外部对它实例化。单例模式的结构图如下所示。</p>\n<p><img src=\"https://raw.githubusercontent.com/zhpanvip/Resource/master/image/0102.png\" alt=\"单例模式\"></p>\n<p><strong>1.一个简单的单例模式实现。</strong></p>\n<pre><code class=\"hljs routeros\">public class Singleton &#123;\n\tprivate static Singleton instance;\n\n\tprivate Singleton() &#123;\n\t&#125;\n\n\tpublic static Singleton getInstance() &#123;\n\t\t<span class=\"hljs-keyword\">if</span>(<span class=\"hljs-attribute\">instance</span>==null) &#123;\n\t\t<span class=\"hljs-built_in\">\tinstance </span>= new Singleton();\n\t\t&#125;\n\t\treturn instance;\n\t&#125;\n\t\n\tpublic void openWindow() &#123;\n\t\tSystem.out.println(<span class=\"hljs-string\">&quot;Open a Window&quot;</span>);\n\t&#125;\n&#125;</code></pre>\n<p>上面就是一个最简单的单例模式，我们来写一个测试类：</p>\n<pre><code class=\"hljs arduino\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">SingleTest</span> &#123;</span>\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">String</span>[] args)</span> </span>&#123;\n\t\tSingleton single1=Singleton.getInstance();\n\t\tSingleton single2=Singleton.getInstance();\n\t\tSystem.out.<span class=\"hljs-built_in\">println</span>(<span class=\"hljs-string\">&quot;single1.equals(single2)---&quot;</span>+single1.equals(single2));\n\t&#125;\n&#125;</code></pre>\n<p>输出结果：</p>\n<blockquote>\n<p>single1.equals(single2)—true</p>\n</blockquote>\n<p>从输出结果可以看出两次调用getInstance得到的是同一个Singleton 实例。</p>\n<p>上面仅仅是实现单例的一种方式，在调用时实例化对象我们称之为懒汉式，上面的代码有一个弊端，就是不支持多线程调用，在多线程调用的情况下可能会被实例化出多个实例，因此，严格来讲它并不是真正的单例模式！接下来我们继续来看几种单例模式的实现方法，并且来保证它的线程安全。<br><strong>2.线程安全的懒汉式单例模式</strong></p>\n<pre><code class=\"hljs routeros\">public class Singleton &#123;\n\tprivate static Singleton instance;\n\n\tprivate Singleton() &#123;&#125;\n\n\tpublic static synchronized  Singleton getInstance() &#123;\n\t\t<span class=\"hljs-keyword\">if</span>(<span class=\"hljs-attribute\">instance</span>==null) &#123;\n\t\t<span class=\"hljs-built_in\">\tinstance </span>= new Singleton();\n\t\t&#125;\n\t\treturn instance;\n\t&#125;\n\t\n\tpublic void openWindow() &#123;\n\t\tSystem.out.println(<span class=\"hljs-string\">&quot;Open a Window&quot;</span>);\n\t&#125;\n&#125;</code></pre>\n<p>如上代码，我们仅仅在getInstance方法上加了一个synchronized 锁，从而保证了线程的安全。但是我们又不得不考虑一个问题，即每次调用getInstance的时候都会加锁，这种做法势必影响了程序的性能，所以还有待改良。<br><strong>3.双重锁定的单例模式</strong></p>\n<pre><code class=\"hljs csharp\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Singleton</span> &#123;\n\t<span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> Singleton instance;\n\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-title\">Singleton</span>(<span class=\"hljs-params\"></span>)</span> &#123;\n\t&#125;\n\n\t<span class=\"hljs-comment\">//\t双重校验锁 线程安全  不用让线程每次都加锁，只有在未实例化时加锁，提高性能。</span>\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> Singleton2 <span class=\"hljs-title\">getInstance3</span>(<span class=\"hljs-params\"></span>)</span> &#123;\n\t\t<span class=\"hljs-keyword\">if</span> (instance == <span class=\"hljs-literal\">null</span>) &#123;<span class=\"hljs-comment\">//先判断实例是否存在，不存在再加锁处理</span>\n\t\t\tsynchronized (Singleton2.class) &#123;\n\t\t\t\t<span class=\"hljs-keyword\">if</span>(instance==<span class=\"hljs-literal\">null</span>) &#123;\n\t\t\t\t\tinstance=<span class=\"hljs-keyword\">new</span> Singleton2();\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&#125;\n\t\t<span class=\"hljs-keyword\">return</span> instance;\n\t&#125;\n\t\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">openWindow</span>(<span class=\"hljs-params\"></span>)</span> &#123;\n\t\tSystem.<span class=\"hljs-keyword\">out</span>.println(<span class=\"hljs-string\">&quot;Open a Window&quot;</span>);\n\t&#125;\n&#125;\n</code></pre>\n<p>上述代码中为什么两次判断instance是否为null？假如instance为null并且同时又两个线程调用getInstance()方法，它们将同时通过第一重instance==null的判断。然后由于锁机制，这两个线程只能有一个进入，另一个在外排队等候。等到第一个执行完后另一个线程才能进入。而此时如果没有第二重instance是否为空的判断，则第一个线程创建了实例，而第二个线程还是可以继续创建实例。这样没有达到单例的目的。<br><strong>4.饿汉式实现单例模式</strong><br>前三种我们讲解了懒汉式实现单例。那么还有一种在类加载时就创建对象的单例模式的实现方法我们称之为饿汉式。代码如下：</p>\n<pre><code class=\"hljs arduino\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Singleton</span> &#123;</span>\n\t<span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> Singleton instance=<span class=\"hljs-keyword\">new</span> Singleton();\n\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-title\">Singleton</span><span class=\"hljs-params\">()</span> </span>&#123;\n\t&#125;\n\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> Singleton <span class=\"hljs-title\">getInstance</span><span class=\"hljs-params\">()</span> </span>&#123;\n\t\t<span class=\"hljs-keyword\">return</span> instance;\n\t&#125;\n\t\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">openWindow</span><span class=\"hljs-params\">()</span> </span>&#123;\n\t\tSystem.out.<span class=\"hljs-built_in\">println</span>(<span class=\"hljs-string\">&quot;Open a Window&quot;</span>);\n\t&#125;\n&#125;</code></pre>\n<p>这种单例模式基于 classloader 机制避免了多线程的同步问题。但因为instance在类加载时就被实例化了，因此存在内存浪费的可能性。</p>\n<h2 id=\"三、建造者模式\"><a href=\"#三、建造者模式\" class=\"headerlink\" title=\"三、建造者模式\"></a>三、建造者模式</h2><p>建造者模式是将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。<br>我们以画卡通人物为例，画一个卡通人物需要完成头、身体、手、腿的绘制。那么，我们就可以抽象出一个IDrawPerson的接口</p>\n<pre><code class=\"hljs csharp\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">IDrawPerson</span> &#123;\n\t\n\t <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">drawHead</span>(<span class=\"hljs-params\"></span>)</span>;\n\t \n\t <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">drawBody</span>(<span class=\"hljs-params\"></span>)</span>;\n\t \n\t <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">drawHand</span>(<span class=\"hljs-params\"></span>)</span>;\n\t \n\t <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">drawLeg</span>(<span class=\"hljs-params\"></span>)</span>;\n\t \n\t <span class=\"hljs-function\">Person <span class=\"hljs-title\">buildPerson</span>(<span class=\"hljs-params\"></span>)</span>;\n&#125;</code></pre>\n<p>接下来，我想画一个比较瘦的卡通人物，那么定义PersonThinBuilder并实现IDrawPerson类</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Person</span> </span>&#123;\n\t<span class=\"hljs-keyword\">private</span> String head;\n\t\n\t<span class=\"hljs-keyword\">private</span> String body;\n\t\n\t<span class=\"hljs-keyword\">private</span> String hand;\n\t\n\t<span class=\"hljs-keyword\">private</span> String leg;\n\t\n\t...  <span class=\"hljs-comment\">//省去get、set方法</span>\n&#125;\n\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">PersonThinBuilder</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">IDrawPerson</span> </span>&#123;\n\t<span class=\"hljs-keyword\">private</span> Person mPerson;\n\t\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">PersonThinBuilder</span><span class=\"hljs-params\">()</span> </span>&#123;\n\t\t<span class=\"hljs-keyword\">super</span>();\n\t\tmPerson=<span class=\"hljs-keyword\">new</span> Person();\n\t&#125;\n\n\t<span class=\"hljs-meta\">@Override</span>\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">drawHead</span><span class=\"hljs-params\">()</span> </span>&#123;\n\t\tmPerson.setHead(<span class=\"hljs-string\">&quot;draw head&quot;</span>);\n\t\t\n\t&#125;\n\n\t<span class=\"hljs-meta\">@Override</span>\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">drawBody</span><span class=\"hljs-params\">()</span> </span>&#123;\n\t\tmPerson.setBody(<span class=\"hljs-string\">&quot;draw thin body&quot;</span>);\n\t&#125;\n\n\t<span class=\"hljs-meta\">@Override</span>\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">drawHand</span><span class=\"hljs-params\">()</span> </span>&#123;\n\t\tmPerson.setHand(<span class=\"hljs-string\">&quot;draa hand&quot;</span>);\n\t&#125;\n\n\t<span class=\"hljs-meta\">@Override</span>\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">drawLeg</span><span class=\"hljs-params\">()</span> </span>&#123;\n\t\tmPerson.setLeg(<span class=\"hljs-string\">&quot;draw leg&quot;</span>);\n\t&#125;\n\n\t<span class=\"hljs-meta\">@Override</span>\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> Person <span class=\"hljs-title\">buildPerson</span><span class=\"hljs-params\">()</span> </span>&#123;\n\t\t<span class=\"hljs-keyword\">return</span> mPerson;\n\t&#125;\n&#125;</code></pre>\n\n<p>同样，如果我想再画一个胖人或者高个子都用类似代码实现这个类就可以了。</p>\n<p>接下来看建造者模式中很重要的一个类，指挥者类，用这个类来控制建造过程或者隔离用户与建造过程的关联。</p>\n<pre><code class=\"hljs reasonml\">public <span class=\"hljs-keyword\">class</span> PersonDirector &#123;\n\tpublic Person <span class=\"hljs-constructor\">CreatePerson(IDrawPerson <span class=\"hljs-params\">buildPerson</span>)</span> &#123;\n\t\tbuildPerson.draw<span class=\"hljs-constructor\">Head()</span>;\n\t\tbuildPerson.draw<span class=\"hljs-constructor\">Body()</span>;\n\t\tbuildPerson.draw<span class=\"hljs-constructor\">Hand()</span>;\n\t\tbuildPerson.draw<span class=\"hljs-constructor\">Leg()</span>;\n\t\treturn buildPerson.build<span class=\"hljs-constructor\">Person()</span>;\n\t&#125;\n&#125;</code></pre>\n<p>最后来看创建一个建造者模式的测试类：</p>\n<pre><code class=\"hljs arduino\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">BuildTest</span> &#123;</span>\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">String</span>[] args)</span> </span>&#123;\n\t\tPersonDirector personDirector=<span class=\"hljs-keyword\">new</span> PersonDirector();\n\t\tPerson thinPerson=personDirector.CreatePerson(<span class=\"hljs-keyword\">new</span> PersonThinBuilder());\n\t\tSystem.out.<span class=\"hljs-built_in\">println</span>(thinPerson.getBody());\n\t&#125;\n&#125;</code></pre>\n\n<p>输出结果：</p>\n<blockquote>\n<p>draw thin body</p>\n</blockquote>\n"},{"title":"Android夜间模式实现方案","date":"2017-07-27T15:45:44.000Z","_content":"\n\n对于一款阅读类的软件，夜间模式是不可缺少的。最初看到这个需求时候觉得无从下手，没有一点头绪。后来通过查阅资料发现Android官方在Support Library 23.2.0中已经加入了夜间主题。也就是只需要通过更换主题便可实现日间模式和夜间模式的切换。下面截取项目实现的夜间模式效果图：\n![](https://raw.githubusercontent.com/zhpanvip/Resource/master/image/1001.jfif)\n\n效果看起来还比较nice，没有闪屏，过度也比较平滑。那么项目中的这个日间、夜间模式切换效果是如何实现的呢？下面将从以下几个方面来讲解：\n\n - 一 实现夜间模式需要的配置\n - 二 实现白天和夜间模式的切换\n - 三 实现夜间模式时遇到的问题及解决方案\n\n一、实现夜间模式需要的配置\n1.首先在gradel中引入以下依赖\n```\ncompile 'com.android.support:appcompat-v7:25.3.1'\n```\n2.让我们项目的主题继承夜间模式主题，在style中设置如下主题：\n\n```\n <style name=\"AppTheme\" parent=\"Theme.AppCompat.DayNight\">\n        <!-- Customize your theme here. -->\n        <item name=\"colorPrimary\">@color/colorPrimary</item>\n        <item name=\"colorPrimaryDark\">@color/colorPrimaryDark</item>\n        <item name=\"colorAccent\">@color/colorAccent</item>\n    </style>\n```\n3.新建drawable-night和values-night的资源目录。如果要适配不同分辨率的屏幕则可新建drawable-night-hdip、drawable-night-xhdpi等目录来存放不同分辨率的图片资源。values-night目录下存放与夜间模式相关的value文件。本篇文章讲解仅以夜间模式和日间模式的颜色为例，在values-night目录下新建color.xml文件。\n\n（1）新建values-night目录，如下：\n\n![](https://raw.githubusercontent.com/zhpanvip/Resource/master/image/1002.jfif)\n\n\n![](https://raw.githubusercontent.com/zhpanvip/Resource/master/image/1003.jfif)\n\n\n（2）在values-night目录下新建colors文件，如下：\n![](https://raw.githubusercontent.com/zhpanvip/Resource/master/image/1004.jfif)\n\n\n\n![](https://raw.githubusercontent.com/zhpanvip/Resource/master/image/1005.jfif)\n\n接下来只需要在对应的colors文件下写不同的颜色值(夜间颜色值和白天颜色值)即可。至此关于实现夜间模式的配置已经基本完成。\n\n二、实现白天和夜间模式的切换\n1.启动App时检测是否处于夜间模式，如果是则切换至夜间主题。这个需要在自己项目的Application中实现。可在自己项目的Application中添加以下代码：\n\n```\n /**\n   * 初始化夜间模式\n   */\n    private void setNightMode() {\n        boolean nightMode = UserInfoTools.isNightMode(this);\n        AppCompatDelegate.setDefaultNightMode(nightMode ?\n                AppCompatDelegate.MODE_NIGHT_YES : AppCompatDelegate.MODE_NIGHT_NO);\n    }\n```\n这里需要介绍一下有关夜间模式的几个常量值。AppCompatDelegate.setDefaultNightMode(mode),其中mode有一下四个值：\n\n - MODE_NIGHT_NO： 亮色(light)主题，不使用夜间模式\n - MODE_NIGHT_YES：暗色(dark)主题，使用夜间模式\n - MODE_NIGHT_AUTO：根据当前时间自动切换 亮色(light)/暗色(dark)主题（22：00-07：00时间段内自动切换为夜间模式）\n - MODE_NIGHT_FOLLOW_SYSTEM(默认选项)：设置为跟随系统，通常为MODE_NIGHT_NO\n2.接下来需要我们在设置页面点击ToggleButton时切换白天/夜间模式。\n具体实现如下：\n```\nprivate void setNightMode() {\n         //  获取当前模式\n        int currentNightMode = getResources().getConfiguration().uiMode & Configuration.UI_MODE_NIGHT_MASK;\n        //  将是否为夜间模式保存到SharedPreferences\n        UserInfoTools.setNightMode(this, currentNightMode == Configuration.UI_MODE_NIGHT_NO);\n        //  切换模式\n        getDelegate().setDefaultNightMode(currentNightMode == Configuration.UI_MODE_NIGHT_NO ?\n                AppCompatDelegate.MODE_NIGHT_YES : AppCompatDelegate.MODE_NIGHT_NO);\n        UserInfoTools.setChangeNightMode(this,true);\n        //  重启Activity\n        recreate();\n    }\n\nprivate void setListener() {\n        mToggleButton.setOnClickListener((View v) -> {\n            setNightMode();\n        });\n    }\n```\n注意，上面代码中设置白天/夜间模式的代码的最后调用了recreate()方法重启了当前Activity。但这样写切换模式时会有闪屏问题，体验比较差。具体优化将在下一节中实现。\n\n三 、实现夜间模式时遇到的问题及解决方案\n利用谷歌官方提供的这个方案实现夜间模式的过程中遇到了不少的问题。且网上资料较少，大多文章讲解仅仅以一个简单的demo为例。但在用到实际项目中时会遇到很多的麻烦。这里主要总结了笔者曾经遇到过的难以解决的几个问题。\n1.白天/夜间模式切换时闪屏问题\n上一节中已经提到了在调用recreate()方法时会有闪屏问题。其实闪屏问题的解决比较简单。我们大可以不掉用recreate()方法，而是自己重启当前activity并为activity设置启动和退出动画即可！实现代码如下：\n```\n private void setNightMode() {\n        //  获取当前模式\n        int currentNightMode = getResources().getConfiguration().uiMode & Configuration.UI_MODE_NIGHT_MASK;\n        //  将是否为夜间模式保存到SharedPreferences\n        UserInfoTools.setNightMode(this, currentNightMode == Configuration.UI_MODE_NIGHT_NO);\n        //  切换模式\n        getDelegate().setDefaultNightMode(currentNightMode == Configuration.UI_MODE_NIGHT_NO ?\n                AppCompatDelegate.MODE_NIGHT_YES : AppCompatDelegate.MODE_NIGHT_NO);\n        UserInfoTools.setChangeNightMode(this,true);\n        \n        //recreate();\n\n        startActivity(new Intent(this,SettingActivity.class));\n        overridePendingTransition(R.anim.animo_alph_close, R.anim.animo_alph_close);\n        finish();\n    }\n```\n如上代码，我们自行调用startActivity启动了设置页面并为其添加了一个透明渐变的启动动画。最后调用finish结束掉旧的设置页面。这样闪屏问题便迎刃而解。模式切换也变得流畅自然。\n 2.切换夜间模式后返回MainActivity,MainActivity页面没有更新。解决这个问题可以在切换模式后从设置页面发送一个广播，然后在MainActivity中接收到这个广播后重启MainActivity即可。根据官方的推荐更换夜间模式后需要调用recreate()方法刷新页面。但是recreate()方法巨坑无比，调用recreate()方法引起了诸多问题。详见问题3、4、5。因此解决这个问题笔者并没有在MainActivity调用中调用recreate()方法。而是在SettingActivity中定义了一个boolean值来标记是否切换了夜间模式。然后重写了onKeyDown()方法。如果切换了夜间模式则在返回时发出一个广播结束掉MainActivity,然后调用startActivity()重启了MainActivity并添加了启动动画，让用户感觉是只是返回了主页面。其实思想跟解决问题1有些类似。还是结合代码来看吧。\n \nSettingActivity中的代码\n```\n @Override\n    public boolean onKeyDown(int keyCode, KeyEvent event) {\n        if (keyCode == KeyEvent.KEYCODE_BACK && event.getAction() == KeyEvent.ACTION_DOWN) {\n            goBack();\n            return true;\n        }\n        return super.onKeyDown(keyCode, event);\n    }\n\n    private void goBack() {\n        if (isChangeNightMode) {  //  如果改变了夜间模式，则重启MainActivity\n            EventBus.getDefault().post(new NightModeEvent());\n            Intent intent = new Intent(this, MainActivity.class);\n            intent.putExtra(\"nightMode\", true);\n            startActivity(intent);\n            overridePendingTransition(R.anim.animo_alph_close, R.anim.activity_close);\n        }\n        finish();\n    }\n```\nMainActivity中的代码：\n\n```\n\t @Override\n    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        \n        reStartActivity()\n    }\n\n //  改变夜间模式后返回时重启Activity\n    private void reStartActivity() {\n        Intent intent = getIntent();\n        boolean nightMode = intent.getBooleanExtra(\"nightMode\", false);\n        if(nightMode&&UserInfoTools.getIsLogin(this)){\n            //  自动切换到“我的”页面\n            mRbMe.performClick();\n        }\n    }\n\n\t/**\n     * 接收到夜间模式改变的事件后结束当前Activity\n     * @param event\n     */\n\t @Subscribe\n    public void setNightMode(NightModeEvent event) {\n        finish();\n    }\n```\n最后还有点问题需要说明，由问题1我们可以知道，改变模式后，我们重启了SettingActivity。因此在该类中定义的一个标记是否切换了夜间模式的boolean值并不能起到作用。解决办法是将这个值保存到SharedPreference中。然后重启SettingActivity后再取出该值。可以看代码，这点真心有点绕啊。。。\n注意问题1中的setNightMode()方法中有一句代码 UserInfoTools.setChangeNightMode(this,true);将改变了夜间模式设置为了true并保存到了SharedPreferences中，然后在onCreate()中有以下代码来初始化isChangeNightMode的值。\n```\n @Override\n    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n                 isChangeNightMode=UserInfoTools.isChangeNightMode(this);\n        UserInfoTools.setChangeNightMode(this,false);\n    }\n\n```\n3.设置白天/夜间模式后出现无故闪退问题\n这个问题说来比较奇怪，原因是切换了夜间模式后在MainActivity中调用了recreate()方法。具体原因笔者也没有弄清楚，调试了好一阵子也没有找出个所以然来。后来果断放弃了在MainActivity中调用recreate()方法，而是换成了startActivity()重新启动了MainActivity。之后这个问题便不复存在了。\n\n4.点击ToggleButton切换模式后应用黑屏，随后挂掉。这个问题的最终原因还是因为recreate()方法引起的。如果你用了ToggleButton切换白天/夜间模式，并且为ToggleButton设置了setOnCheckChangedListener()方法，那么你将有很大概率碰到这个问题。引起这个问题的原因是因为调用了recreate()方法后Activity重新启动，但是新启动的Activity保存了之前Activity的状态。因此在重启时候重新设置了TouggleButton，继而调用了又setOnCheckChangedListener()方法，结果悲剧了。。。一个死循环产生了，程序不黑屏才怪。因此最简单的办法是放弃recreate()方法，改用问题1中的方法！（其实细心的小伙伴应该已经发现了，我的代码中仅仅是为ToggleButton设置了setOnClickListener()....机智如我啊）如果你有强迫症必须要使用setOnCheckChangedListener和recreate()方法那么也不是没有解决方案。可以定义一个boolean成员变量，然后在onCreate()方法中判断savedInstanceState是否为null，然后给这个boolean成员变量赋值，并在setOnCheckChangedListener()方法中根据这个boolean成员变量的值去调用设置夜间模式的方法即可。\n\n5.设置夜间模式后MainActivity调用recreate()方法，MainActivity中的”发现“页面没有加载出来。发现页面如下面图片所示，也就是一个Fragment中嵌套了一个ViewPager。调用recreate()后整个ViewPager消失了。。。没有加载出来！！！\n![](https://raw.githubusercontent.com/zhpanvip/Resource/master/image/1006.jfif)\n\n解决方案，放弃使用recreate()，改用问题1中的方法！\n\n万恶的recreate()方法！难道是我使用的姿势不对？\n\n","source":"_posts/10.Android夜间模式实现方案.md","raw":"---\ntitle: Android夜间模式实现方案\ndate: 2017-07-27 23:45:44\ntags: \n---\n\n\n对于一款阅读类的软件，夜间模式是不可缺少的。最初看到这个需求时候觉得无从下手，没有一点头绪。后来通过查阅资料发现Android官方在Support Library 23.2.0中已经加入了夜间主题。也就是只需要通过更换主题便可实现日间模式和夜间模式的切换。下面截取项目实现的夜间模式效果图：\n![](https://raw.githubusercontent.com/zhpanvip/Resource/master/image/1001.jfif)\n\n效果看起来还比较nice，没有闪屏，过度也比较平滑。那么项目中的这个日间、夜间模式切换效果是如何实现的呢？下面将从以下几个方面来讲解：\n\n - 一 实现夜间模式需要的配置\n - 二 实现白天和夜间模式的切换\n - 三 实现夜间模式时遇到的问题及解决方案\n\n一、实现夜间模式需要的配置\n1.首先在gradel中引入以下依赖\n```\ncompile 'com.android.support:appcompat-v7:25.3.1'\n```\n2.让我们项目的主题继承夜间模式主题，在style中设置如下主题：\n\n```\n <style name=\"AppTheme\" parent=\"Theme.AppCompat.DayNight\">\n        <!-- Customize your theme here. -->\n        <item name=\"colorPrimary\">@color/colorPrimary</item>\n        <item name=\"colorPrimaryDark\">@color/colorPrimaryDark</item>\n        <item name=\"colorAccent\">@color/colorAccent</item>\n    </style>\n```\n3.新建drawable-night和values-night的资源目录。如果要适配不同分辨率的屏幕则可新建drawable-night-hdip、drawable-night-xhdpi等目录来存放不同分辨率的图片资源。values-night目录下存放与夜间模式相关的value文件。本篇文章讲解仅以夜间模式和日间模式的颜色为例，在values-night目录下新建color.xml文件。\n\n（1）新建values-night目录，如下：\n\n![](https://raw.githubusercontent.com/zhpanvip/Resource/master/image/1002.jfif)\n\n\n![](https://raw.githubusercontent.com/zhpanvip/Resource/master/image/1003.jfif)\n\n\n（2）在values-night目录下新建colors文件，如下：\n![](https://raw.githubusercontent.com/zhpanvip/Resource/master/image/1004.jfif)\n\n\n\n![](https://raw.githubusercontent.com/zhpanvip/Resource/master/image/1005.jfif)\n\n接下来只需要在对应的colors文件下写不同的颜色值(夜间颜色值和白天颜色值)即可。至此关于实现夜间模式的配置已经基本完成。\n\n二、实现白天和夜间模式的切换\n1.启动App时检测是否处于夜间模式，如果是则切换至夜间主题。这个需要在自己项目的Application中实现。可在自己项目的Application中添加以下代码：\n\n```\n /**\n   * 初始化夜间模式\n   */\n    private void setNightMode() {\n        boolean nightMode = UserInfoTools.isNightMode(this);\n        AppCompatDelegate.setDefaultNightMode(nightMode ?\n                AppCompatDelegate.MODE_NIGHT_YES : AppCompatDelegate.MODE_NIGHT_NO);\n    }\n```\n这里需要介绍一下有关夜间模式的几个常量值。AppCompatDelegate.setDefaultNightMode(mode),其中mode有一下四个值：\n\n - MODE_NIGHT_NO： 亮色(light)主题，不使用夜间模式\n - MODE_NIGHT_YES：暗色(dark)主题，使用夜间模式\n - MODE_NIGHT_AUTO：根据当前时间自动切换 亮色(light)/暗色(dark)主题（22：00-07：00时间段内自动切换为夜间模式）\n - MODE_NIGHT_FOLLOW_SYSTEM(默认选项)：设置为跟随系统，通常为MODE_NIGHT_NO\n2.接下来需要我们在设置页面点击ToggleButton时切换白天/夜间模式。\n具体实现如下：\n```\nprivate void setNightMode() {\n         //  获取当前模式\n        int currentNightMode = getResources().getConfiguration().uiMode & Configuration.UI_MODE_NIGHT_MASK;\n        //  将是否为夜间模式保存到SharedPreferences\n        UserInfoTools.setNightMode(this, currentNightMode == Configuration.UI_MODE_NIGHT_NO);\n        //  切换模式\n        getDelegate().setDefaultNightMode(currentNightMode == Configuration.UI_MODE_NIGHT_NO ?\n                AppCompatDelegate.MODE_NIGHT_YES : AppCompatDelegate.MODE_NIGHT_NO);\n        UserInfoTools.setChangeNightMode(this,true);\n        //  重启Activity\n        recreate();\n    }\n\nprivate void setListener() {\n        mToggleButton.setOnClickListener((View v) -> {\n            setNightMode();\n        });\n    }\n```\n注意，上面代码中设置白天/夜间模式的代码的最后调用了recreate()方法重启了当前Activity。但这样写切换模式时会有闪屏问题，体验比较差。具体优化将在下一节中实现。\n\n三 、实现夜间模式时遇到的问题及解决方案\n利用谷歌官方提供的这个方案实现夜间模式的过程中遇到了不少的问题。且网上资料较少，大多文章讲解仅仅以一个简单的demo为例。但在用到实际项目中时会遇到很多的麻烦。这里主要总结了笔者曾经遇到过的难以解决的几个问题。\n1.白天/夜间模式切换时闪屏问题\n上一节中已经提到了在调用recreate()方法时会有闪屏问题。其实闪屏问题的解决比较简单。我们大可以不掉用recreate()方法，而是自己重启当前activity并为activity设置启动和退出动画即可！实现代码如下：\n```\n private void setNightMode() {\n        //  获取当前模式\n        int currentNightMode = getResources().getConfiguration().uiMode & Configuration.UI_MODE_NIGHT_MASK;\n        //  将是否为夜间模式保存到SharedPreferences\n        UserInfoTools.setNightMode(this, currentNightMode == Configuration.UI_MODE_NIGHT_NO);\n        //  切换模式\n        getDelegate().setDefaultNightMode(currentNightMode == Configuration.UI_MODE_NIGHT_NO ?\n                AppCompatDelegate.MODE_NIGHT_YES : AppCompatDelegate.MODE_NIGHT_NO);\n        UserInfoTools.setChangeNightMode(this,true);\n        \n        //recreate();\n\n        startActivity(new Intent(this,SettingActivity.class));\n        overridePendingTransition(R.anim.animo_alph_close, R.anim.animo_alph_close);\n        finish();\n    }\n```\n如上代码，我们自行调用startActivity启动了设置页面并为其添加了一个透明渐变的启动动画。最后调用finish结束掉旧的设置页面。这样闪屏问题便迎刃而解。模式切换也变得流畅自然。\n 2.切换夜间模式后返回MainActivity,MainActivity页面没有更新。解决这个问题可以在切换模式后从设置页面发送一个广播，然后在MainActivity中接收到这个广播后重启MainActivity即可。根据官方的推荐更换夜间模式后需要调用recreate()方法刷新页面。但是recreate()方法巨坑无比，调用recreate()方法引起了诸多问题。详见问题3、4、5。因此解决这个问题笔者并没有在MainActivity调用中调用recreate()方法。而是在SettingActivity中定义了一个boolean值来标记是否切换了夜间模式。然后重写了onKeyDown()方法。如果切换了夜间模式则在返回时发出一个广播结束掉MainActivity,然后调用startActivity()重启了MainActivity并添加了启动动画，让用户感觉是只是返回了主页面。其实思想跟解决问题1有些类似。还是结合代码来看吧。\n \nSettingActivity中的代码\n```\n @Override\n    public boolean onKeyDown(int keyCode, KeyEvent event) {\n        if (keyCode == KeyEvent.KEYCODE_BACK && event.getAction() == KeyEvent.ACTION_DOWN) {\n            goBack();\n            return true;\n        }\n        return super.onKeyDown(keyCode, event);\n    }\n\n    private void goBack() {\n        if (isChangeNightMode) {  //  如果改变了夜间模式，则重启MainActivity\n            EventBus.getDefault().post(new NightModeEvent());\n            Intent intent = new Intent(this, MainActivity.class);\n            intent.putExtra(\"nightMode\", true);\n            startActivity(intent);\n            overridePendingTransition(R.anim.animo_alph_close, R.anim.activity_close);\n        }\n        finish();\n    }\n```\nMainActivity中的代码：\n\n```\n\t @Override\n    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        \n        reStartActivity()\n    }\n\n //  改变夜间模式后返回时重启Activity\n    private void reStartActivity() {\n        Intent intent = getIntent();\n        boolean nightMode = intent.getBooleanExtra(\"nightMode\", false);\n        if(nightMode&&UserInfoTools.getIsLogin(this)){\n            //  自动切换到“我的”页面\n            mRbMe.performClick();\n        }\n    }\n\n\t/**\n     * 接收到夜间模式改变的事件后结束当前Activity\n     * @param event\n     */\n\t @Subscribe\n    public void setNightMode(NightModeEvent event) {\n        finish();\n    }\n```\n最后还有点问题需要说明，由问题1我们可以知道，改变模式后，我们重启了SettingActivity。因此在该类中定义的一个标记是否切换了夜间模式的boolean值并不能起到作用。解决办法是将这个值保存到SharedPreference中。然后重启SettingActivity后再取出该值。可以看代码，这点真心有点绕啊。。。\n注意问题1中的setNightMode()方法中有一句代码 UserInfoTools.setChangeNightMode(this,true);将改变了夜间模式设置为了true并保存到了SharedPreferences中，然后在onCreate()中有以下代码来初始化isChangeNightMode的值。\n```\n @Override\n    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n                 isChangeNightMode=UserInfoTools.isChangeNightMode(this);\n        UserInfoTools.setChangeNightMode(this,false);\n    }\n\n```\n3.设置白天/夜间模式后出现无故闪退问题\n这个问题说来比较奇怪，原因是切换了夜间模式后在MainActivity中调用了recreate()方法。具体原因笔者也没有弄清楚，调试了好一阵子也没有找出个所以然来。后来果断放弃了在MainActivity中调用recreate()方法，而是换成了startActivity()重新启动了MainActivity。之后这个问题便不复存在了。\n\n4.点击ToggleButton切换模式后应用黑屏，随后挂掉。这个问题的最终原因还是因为recreate()方法引起的。如果你用了ToggleButton切换白天/夜间模式，并且为ToggleButton设置了setOnCheckChangedListener()方法，那么你将有很大概率碰到这个问题。引起这个问题的原因是因为调用了recreate()方法后Activity重新启动，但是新启动的Activity保存了之前Activity的状态。因此在重启时候重新设置了TouggleButton，继而调用了又setOnCheckChangedListener()方法，结果悲剧了。。。一个死循环产生了，程序不黑屏才怪。因此最简单的办法是放弃recreate()方法，改用问题1中的方法！（其实细心的小伙伴应该已经发现了，我的代码中仅仅是为ToggleButton设置了setOnClickListener()....机智如我啊）如果你有强迫症必须要使用setOnCheckChangedListener和recreate()方法那么也不是没有解决方案。可以定义一个boolean成员变量，然后在onCreate()方法中判断savedInstanceState是否为null，然后给这个boolean成员变量赋值，并在setOnCheckChangedListener()方法中根据这个boolean成员变量的值去调用设置夜间模式的方法即可。\n\n5.设置夜间模式后MainActivity调用recreate()方法，MainActivity中的”发现“页面没有加载出来。发现页面如下面图片所示，也就是一个Fragment中嵌套了一个ViewPager。调用recreate()后整个ViewPager消失了。。。没有加载出来！！！\n![](https://raw.githubusercontent.com/zhpanvip/Resource/master/image/1006.jfif)\n\n解决方案，放弃使用recreate()，改用问题1中的方法！\n\n万恶的recreate()方法！难道是我使用的姿势不对？\n\n","slug":"10.Android夜间模式实现方案","published":1,"updated":"2020-08-29T18:13:05.332Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckegm5nro0002dwoz81c6cauo","content":"<p>对于一款阅读类的软件，夜间模式是不可缺少的。最初看到这个需求时候觉得无从下手，没有一点头绪。后来通过查阅资料发现Android官方在Support Library 23.2.0中已经加入了夜间主题。也就是只需要通过更换主题便可实现日间模式和夜间模式的切换。下面截取项目实现的夜间模式效果图：<br><img src=\"https://raw.githubusercontent.com/zhpanvip/Resource/master/image/1001.jfif\"></p>\n<p>效果看起来还比较nice，没有闪屏，过度也比较平滑。那么项目中的这个日间、夜间模式切换效果是如何实现的呢？下面将从以下几个方面来讲解：</p>\n<ul>\n<li>一 实现夜间模式需要的配置</li>\n<li>二 实现白天和夜间模式的切换</li>\n<li>三 实现夜间模式时遇到的问题及解决方案</li>\n</ul>\n<p>一、实现夜间模式需要的配置<br>1.首先在gradel中引入以下依赖</p>\n<pre><code class=\"hljs apache\"><span class=\"hljs-attribute\">compile</span> &#x27;com.android.support:appcompat-v<span class=\"hljs-number\">7</span>:<span class=\"hljs-number\">25</span>.<span class=\"hljs-number\">3</span>.<span class=\"hljs-number\">1</span>&#x27;</code></pre>\n<p>2.让我们项目的主题继承夜间模式主题，在style中设置如下主题：</p>\n<pre><code class=\"hljs xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">style</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;AppTheme&quot;</span> <span class=\"hljs-attr\">parent</span>=<span class=\"hljs-string\">&quot;Theme.AppCompat.DayNight&quot;</span>&gt;</span>\n<span class=\"xml\">       <span class=\"hljs-comment\">&lt;!-- Customize your theme here. --&gt;</span></span>\n<span class=\"xml\">       <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">item</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;colorPrimary&quot;</span>&gt;</span>@color/colorPrimary<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">item</span>&gt;</span></span>\n<span class=\"xml\">       <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">item</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;colorPrimaryDark&quot;</span>&gt;</span>@color/colorPrimaryDark<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">item</span>&gt;</span></span>\n<span class=\"xml\">       <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">item</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;colorAccent&quot;</span>&gt;</span>@color/colorAccent<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">item</span>&gt;</span></span>\n   <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">style</span>&gt;</span></code></pre>\n<p>3.新建drawable-night和values-night的资源目录。如果要适配不同分辨率的屏幕则可新建drawable-night-hdip、drawable-night-xhdpi等目录来存放不同分辨率的图片资源。values-night目录下存放与夜间模式相关的value文件。本篇文章讲解仅以夜间模式和日间模式的颜色为例，在values-night目录下新建color.xml文件。</p>\n<p>（1）新建values-night目录，如下：</p>\n<p><img src=\"https://raw.githubusercontent.com/zhpanvip/Resource/master/image/1002.jfif\"></p>\n<p><img src=\"https://raw.githubusercontent.com/zhpanvip/Resource/master/image/1003.jfif\"></p>\n<p>（2）在values-night目录下新建colors文件，如下：<br><img src=\"https://raw.githubusercontent.com/zhpanvip/Resource/master/image/1004.jfif\"></p>\n<p><img src=\"https://raw.githubusercontent.com/zhpanvip/Resource/master/image/1005.jfif\"></p>\n<p>接下来只需要在对应的colors文件下写不同的颜色值(夜间颜色值和白天颜色值)即可。至此关于实现夜间模式的配置已经基本完成。</p>\n<p>二、实现白天和夜间模式的切换<br>1.启动App时检测是否处于夜间模式，如果是则切换至夜间主题。这个需要在自己项目的Application中实现。可在自己项目的Application中添加以下代码：</p>\n<pre><code class=\"hljs arduino\"><span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">  * 初始化夜间模式</span>\n<span class=\"hljs-comment\">  */</span>\n   <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">setNightMode</span><span class=\"hljs-params\">()</span> </span>&#123;\n       <span class=\"hljs-keyword\">boolean</span> nightMode = UserInfoTools.isNightMode(<span class=\"hljs-keyword\">this</span>);\n       AppCompatDelegate.setDefaultNightMode(nightMode ?\n               AppCompatDelegate.MODE_NIGHT_YES : AppCompatDelegate.MODE_NIGHT_NO);\n   &#125;</code></pre>\n<p>这里需要介绍一下有关夜间模式的几个常量值。AppCompatDelegate.setDefaultNightMode(mode),其中mode有一下四个值：</p>\n<ul>\n<li>MODE_NIGHT_NO： 亮色(light)主题，不使用夜间模式</li>\n<li>MODE_NIGHT_YES：暗色(dark)主题，使用夜间模式</li>\n<li>MODE_NIGHT_AUTO：根据当前时间自动切换 亮色(light)/暗色(dark)主题（22：00-07：00时间段内自动切换为夜间模式）</li>\n<li>MODE_NIGHT_FOLLOW_SYSTEM(默认选项)：设置为跟随系统，通常为MODE_NIGHT_NO<br>2.接下来需要我们在设置页面点击ToggleButton时切换白天/夜间模式。<br>具体实现如下：<pre><code class=\"hljs jboss-cli\">private void <span class=\"hljs-keyword\">set</span>NightMode<span class=\"hljs-params\">()</span> &#123;\n         <span class=\"hljs-string\">//</span>  获取当前模式\n        int currentNightMode = getResources<span class=\"hljs-params\">()</span><span class=\"hljs-string\">.getConfiguration</span><span class=\"hljs-params\">()</span><span class=\"hljs-string\">.uiMode</span> &amp; Configuration.UI_MODE_NIGHT_MASK;\n        <span class=\"hljs-string\">//</span>  将是否为夜间模式保存到SharedPreferences\n        UserInfoTools.<span class=\"hljs-keyword\">set</span>NightMode<span class=\"hljs-params\">(this, <span class=\"hljs-attr\">currentNightMode</span> == Configuration.UI_MODE_NIGHT_NO)</span>;\n        <span class=\"hljs-string\">//</span>  切换模式\n        getDelegate<span class=\"hljs-params\">()</span><span class=\"hljs-string\">.setDefaultNightMode</span><span class=\"hljs-params\">(<span class=\"hljs-attr\">currentNightMode</span> == Configuration.UI_MODE_NIGHT_NO ?</span>\n<span class=\"hljs-params\">                AppCompatDelegate.MODE_NIGHT_YES : AppCompatDelegate.MODE_NIGHT_NO)</span>;\n        UserInfoTools.<span class=\"hljs-keyword\">set</span>ChangeNightMode<span class=\"hljs-params\">(this,true)</span>;\n        <span class=\"hljs-string\">//</span>  重启Activity\n        recreate<span class=\"hljs-params\">()</span>;\n    &#125;\n\nprivate void <span class=\"hljs-keyword\">set</span>Listener<span class=\"hljs-params\">()</span> &#123;\n        mToggleButton.<span class=\"hljs-keyword\">set</span>OnClickListener<span class=\"hljs-params\">((View v)</span> -&gt; &#123;\n            <span class=\"hljs-keyword\">set</span>NightMode<span class=\"hljs-params\">()</span>;\n        &#125;);\n    &#125;</code></pre>\n注意，上面代码中设置白天/夜间模式的代码的最后调用了recreate()方法重启了当前Activity。但这样写切换模式时会有闪屏问题，体验比较差。具体优化将在下一节中实现。</li>\n</ul>\n<p>三 、实现夜间模式时遇到的问题及解决方案<br>利用谷歌官方提供的这个方案实现夜间模式的过程中遇到了不少的问题。且网上资料较少，大多文章讲解仅仅以一个简单的demo为例。但在用到实际项目中时会遇到很多的麻烦。这里主要总结了笔者曾经遇到过的难以解决的几个问题。<br>1.白天/夜间模式切换时闪屏问题<br>上一节中已经提到了在调用recreate()方法时会有闪屏问题。其实闪屏问题的解决比较简单。我们大可以不掉用recreate()方法，而是自己重启当前activity并为activity设置启动和退出动画即可！实现代码如下：</p>\n<pre><code class=\"hljs groovy\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> setNightMode() &#123;\n       <span class=\"hljs-comment\">//  获取当前模式</span>\n       <span class=\"hljs-keyword\">int</span> currentNightMode = getResources().getConfiguration().uiMode &amp; Configuration.UI_MODE_NIGHT_MASK;\n       <span class=\"hljs-comment\">//  将是否为夜间模式保存到SharedPreferences</span>\n       UserInfoTools.setNightMode(<span class=\"hljs-built_in\">this</span>, currentNightMode == Configuration.UI_MODE_NIGHT_NO);\n       <span class=\"hljs-comment\">//  切换模式</span>\n       getDelegate().setDefaultNightMode(currentNightMode == Configuration.UI_MODE_NIGHT_NO ?\n               AppCompatDelegate.MODE_NIGHT_YES : AppCompatDelegate.MODE_NIGHT_NO);\n       UserInfoTools.setChangeNightMode(<span class=\"hljs-built_in\">this</span>,<span class=\"hljs-literal\">true</span>);\n       \n       <span class=\"hljs-comment\">//recreate();</span>\n\n       startActivity(<span class=\"hljs-keyword\">new</span> Intent(<span class=\"hljs-built_in\">this</span>,SettingActivity.<span class=\"hljs-keyword\">class</span>));\n       overridePendingTransition(R.anim.animo_alph_close, R.anim.animo_alph_close);\n       finish();\n   &#125;</code></pre>\n<p>如上代码，我们自行调用startActivity启动了设置页面并为其添加了一个透明渐变的启动动画。最后调用finish结束掉旧的设置页面。这样闪屏问题便迎刃而解。模式切换也变得流畅自然。<br> 2.切换夜间模式后返回MainActivity,MainActivity页面没有更新。解决这个问题可以在切换模式后从设置页面发送一个广播，然后在MainActivity中接收到这个广播后重启MainActivity即可。根据官方的推荐更换夜间模式后需要调用recreate()方法刷新页面。但是recreate()方法巨坑无比，调用recreate()方法引起了诸多问题。详见问题3、4、5。因此解决这个问题笔者并没有在MainActivity调用中调用recreate()方法。而是在SettingActivity中定义了一个boolean值来标记是否切换了夜间模式。然后重写了onKeyDown()方法。如果切换了夜间模式则在返回时发出一个广播结束掉MainActivity,然后调用startActivity()重启了MainActivity并添加了启动动画，让用户感觉是只是返回了主页面。其实思想跟解决问题1有些类似。还是结合代码来看吧。</p>\n<p>SettingActivity中的代码</p>\n<pre><code class=\"hljs reasonml\">@Override\n   public boolean on<span class=\"hljs-constructor\">KeyDown(<span class=\"hljs-params\">int</span> <span class=\"hljs-params\">keyCode</span>, KeyEvent <span class=\"hljs-params\">event</span>)</span> &#123;\n       <span class=\"hljs-keyword\">if</span> (keyCode<span class=\"hljs-operator\"> == </span>KeyEvent.KEYCODE_BACK<span class=\"hljs-operator\"> &amp;&amp; </span>event.get<span class=\"hljs-constructor\">Action()</span><span class=\"hljs-operator\"> == </span>KeyEvent.ACTION_DOWN) &#123;\n           go<span class=\"hljs-constructor\">Back()</span>;\n           return <span class=\"hljs-literal\">true</span>;\n       &#125;\n       return super.on<span class=\"hljs-constructor\">KeyDown(<span class=\"hljs-params\">keyCode</span>, <span class=\"hljs-params\">event</span>)</span>;\n   &#125;\n\n   <span class=\"hljs-keyword\">private</span> void go<span class=\"hljs-constructor\">Back()</span> &#123;\n       <span class=\"hljs-keyword\">if</span> (isChangeNightMode) &#123;  <span class=\"hljs-comment\">//  如果改变了夜间模式，则重启MainActivity</span>\n           <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">EventBus</span>.</span></span>get<span class=\"hljs-constructor\">Default()</span>.post(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-constructor\">NightModeEvent()</span>);\n           Intent intent = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-constructor\">Intent(<span class=\"hljs-params\">this</span>, MainActivity.<span class=\"hljs-params\">class</span>)</span>;\n           intent.put<span class=\"hljs-constructor\">Extra(<span class=\"hljs-string\">&quot;nightMode&quot;</span>, <span class=\"hljs-params\">true</span>)</span>;\n           start<span class=\"hljs-constructor\">Activity(<span class=\"hljs-params\">intent</span>)</span>;\n           override<span class=\"hljs-constructor\">PendingTransition(R.<span class=\"hljs-params\">anim</span>.<span class=\"hljs-params\">animo_alph_close</span>, R.<span class=\"hljs-params\">anim</span>.<span class=\"hljs-params\">activity_close</span>)</span>;\n       &#125;\n       finish<span class=\"hljs-literal\">()</span>;\n   &#125;</code></pre>\n<p>MainActivity中的代码：</p>\n<pre><code class=\"hljs reasonml\"> @Override\n   public void on<span class=\"hljs-constructor\">Create(Bundle <span class=\"hljs-params\">savedInstanceState</span>)</span> &#123;\n       super.on<span class=\"hljs-constructor\">Create(<span class=\"hljs-params\">savedInstanceState</span>)</span>;\n       set<span class=\"hljs-constructor\">ContentView(R.<span class=\"hljs-params\">layout</span>.<span class=\"hljs-params\">activity_main</span>)</span>;\n       \n       re<span class=\"hljs-constructor\">StartActivity()</span>\n   &#125;\n\n<span class=\"hljs-comment\">//  改变夜间模式后返回时重启Activity</span>\n   <span class=\"hljs-keyword\">private</span> void re<span class=\"hljs-constructor\">StartActivity()</span> &#123;\n       Intent intent = get<span class=\"hljs-constructor\">Intent()</span>;\n       boolean nightMode = intent.get<span class=\"hljs-constructor\">BooleanExtra(<span class=\"hljs-string\">&quot;nightMode&quot;</span>, <span class=\"hljs-params\">false</span>)</span>;\n       <span class=\"hljs-keyword\">if</span>(nightMode&amp;&amp;<span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">UserInfoTools</span>.</span></span>get<span class=\"hljs-constructor\">IsLogin(<span class=\"hljs-params\">this</span>)</span>)&#123;\n           <span class=\"hljs-comment\">//  自动切换到“我的”页面</span>\n           mRbMe.perform<span class=\"hljs-constructor\">Click()</span>;\n       &#125;\n   &#125;\n\n<span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">    * 接收到夜间模式改变的事件后结束当前Activity</span>\n<span class=\"hljs-comment\">    * @param event</span>\n<span class=\"hljs-comment\">    */</span>\n @Subscribe\n   public void set<span class=\"hljs-constructor\">NightMode(NightModeEvent <span class=\"hljs-params\">event</span>)</span> &#123;\n       finish<span class=\"hljs-literal\">()</span>;\n   &#125;</code></pre>\n<p>最后还有点问题需要说明，由问题1我们可以知道，改变模式后，我们重启了SettingActivity。因此在该类中定义的一个标记是否切换了夜间模式的boolean值并不能起到作用。解决办法是将这个值保存到SharedPreference中。然后重启SettingActivity后再取出该值。可以看代码，这点真心有点绕啊。。。<br>注意问题1中的setNightMode()方法中有一句代码 UserInfoTools.setChangeNightMode(this,true);将改变了夜间模式设置为了true并保存到了SharedPreferences中，然后在onCreate()中有以下代码来初始化isChangeNightMode的值。</p>\n<pre><code class=\"hljs reasonml\">@Override\n   public void on<span class=\"hljs-constructor\">Create(Bundle <span class=\"hljs-params\">savedInstanceState</span>)</span> &#123;\n       super.on<span class=\"hljs-constructor\">Create(<span class=\"hljs-params\">savedInstanceState</span>)</span>;\n       set<span class=\"hljs-constructor\">ContentView(R.<span class=\"hljs-params\">layout</span>.<span class=\"hljs-params\">activity_main</span>)</span>;\n                isChangeNightMode=<span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">UserInfoTools</span>.</span></span>is<span class=\"hljs-constructor\">ChangeNightMode(<span class=\"hljs-params\">this</span>)</span>;\n       <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">UserInfoTools</span>.</span></span>set<span class=\"hljs-constructor\">ChangeNightMode(<span class=\"hljs-params\">this</span>,<span class=\"hljs-params\">false</span>)</span>;\n   &#125;\n</code></pre>\n<p>3.设置白天/夜间模式后出现无故闪退问题<br>这个问题说来比较奇怪，原因是切换了夜间模式后在MainActivity中调用了recreate()方法。具体原因笔者也没有弄清楚，调试了好一阵子也没有找出个所以然来。后来果断放弃了在MainActivity中调用recreate()方法，而是换成了startActivity()重新启动了MainActivity。之后这个问题便不复存在了。</p>\n<p>4.点击ToggleButton切换模式后应用黑屏，随后挂掉。这个问题的最终原因还是因为recreate()方法引起的。如果你用了ToggleButton切换白天/夜间模式，并且为ToggleButton设置了setOnCheckChangedListener()方法，那么你将有很大概率碰到这个问题。引起这个问题的原因是因为调用了recreate()方法后Activity重新启动，但是新启动的Activity保存了之前Activity的状态。因此在重启时候重新设置了TouggleButton，继而调用了又setOnCheckChangedListener()方法，结果悲剧了。。。一个死循环产生了，程序不黑屏才怪。因此最简单的办法是放弃recreate()方法，改用问题1中的方法！（其实细心的小伙伴应该已经发现了，我的代码中仅仅是为ToggleButton设置了setOnClickListener()….机智如我啊）如果你有强迫症必须要使用setOnCheckChangedListener和recreate()方法那么也不是没有解决方案。可以定义一个boolean成员变量，然后在onCreate()方法中判断savedInstanceState是否为null，然后给这个boolean成员变量赋值，并在setOnCheckChangedListener()方法中根据这个boolean成员变量的值去调用设置夜间模式的方法即可。</p>\n<p>5.设置夜间模式后MainActivity调用recreate()方法，MainActivity中的”发现“页面没有加载出来。发现页面如下面图片所示，也就是一个Fragment中嵌套了一个ViewPager。调用recreate()后整个ViewPager消失了。。。没有加载出来！！！<br><img src=\"https://raw.githubusercontent.com/zhpanvip/Resource/master/image/1006.jfif\"></p>\n<p>解决方案，放弃使用recreate()，改用问题1中的方法！</p>\n<p>万恶的recreate()方法！难道是我使用的姿势不对？</p>\n","site":{"data":{"fluid_config":{"favicon":"/img/favicon.png","apple_touch_icon":"/img/favicon.png","title_join_string":" - ","force_https":false,"highlight":{"enable":true,"style":"Github Gist","bg_color":false,"copy_btn":true},"fun_features":{"typing":{"enable":true,"typeSpeed":70,"cursorChar":"|","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"mouse_click":{"enable":false,"style":"values"}},"dark_mode":{"enable":true,"default":"auto"},"color":{"body_bg_color":"#eee","body_bg_color_dark":"#181c27","navbar_bg_color":"#2f4154","navbar_bg_color_dark":"#1f3144","navbar_text_color":"#fff","navbar_text_color_dark":"#d0d0d0","text_color":"#3c4858","text_color_dark":"#c4c6c9","sec_text_color":"#718096","sec_text_color_dark":"#a7a9ad","post_text_color":"#2c3e50","post_text_color_dark":"#c4c6c9","post_heading_color":"#1a202c","post_heading_color_dark":"#c4c6c9","post_link_color":"#0366d6","post_link_color_dark":"#1589e9","link_hover_color":"#30a9de","link_hover_color_dark":"#30a9de","link_hover_bg_color":"#f8f9fa","link_hover_bg_color_dark":"#364151","board_color":"#fff","board_color_dark":"#252d38"},"font":{"font_size":"16px","font_family":null,"code_font_size":"85%"},"custom_js":null,"custom_css":null,"custom_html":"","web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"tajs":null,"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}},"lazyload":{"enable":true,"onlypost":false},"daovoice":{"enable":false,"appid":""},"aplayer":{"enable":false,"autoplay":false,"loop":"all","order":"random","theme":"#b7daff","songs":[{"name":"name","artist":"artist","url":"/songs/test.mp3","cover":"/img/cover.jpg"},{"name":"name","artist":"artist","url":"https://...url.mp3","cover":"https://...cover.jpg"}]},"version":{"check":false},"navbar":{"blog_title":"zhangpan","ground_glass":{"enable":false,"px":3,"alpha":0.7},"menu":[{"key":"home","link":"/","icon":"iconfont icon-home-fill"},{"key":"archive","link":"/archives/","icon":"iconfont icon-archive-fill"},{"key":"category","link":"/categories/","icon":"iconfont icon-category-fill"},{"key":"tag","link":"/tags/","icon":"iconfont icon-tags-fill"},{"key":"about","link":"/about/","icon":"iconfont icon-user-fill"}]},"search":{"enable":true,"path":"/local-search.xml","generate_path":"/local-search.xml","field":"post","content":true},"scroll_down_arrow":{"enable":true,"banner_height_limit":90,"scroll_after_turning_page":true},"banner_parallax":true,"footer":{"statistics":{"enable":false,"source":"busuanzi","pv_format":"总访问量 {} 次","uv_format":"总访客数 {} 人"},"beian":{"enable":false,"icp_text":"京ICP证123456号","police_text":"京公网安备12345678号","police_code":12345678,"police_icon":"/img/police_beian.png"}},"scroll_top_arrow":{"enable":true},"index":{"banner_img":"/img/default.png","banner_img_height":100,"banner_mask_alpha":0.3,"post_default_img":"","slogan":{"enable":true,"text":"Talk is cheap, show me the code."},"auto_excerpt":{"enable":true},"post_url_target":"_self","post_meta":{"date":true,"category":true,"tag":true}},"page":{"banner_img":"/img/default.png","banner_img_height":60,"banner_mask_alpha":0.3},"post":{"banner_img":"/img/default.png","banner_img_height":70,"banner_mask_alpha":0.3,"meta":{"date":{"enable":true,"format":"LL a"},"wordcount":{"enable":true,"format":"{} 字"},"min2read":{"enable":true,"format":"{} 分钟","words":100},"views":{"enable":false,"source":"busuanzi","format":"{} 次"}},"updated":{"enable":false,"content":"本文最后更新于：","relative":false},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"copyright":{"enable":true,"content":"本博客所有文章除特别声明外，均采用 <a href=\"https://creativecommons.org/licenses/by-sa/4.0/deed.zh\" rel=\"nofollow noopener\">CC BY-SA 4.0 协议</a> ，转载请注明出处！ <h5>开源库推荐</h5> <a href=\"https://github.com/zhpanvip/BannerViewPager\">1.BannerViewPager</a> <p> 一个基于ViewPager2实现的具有强大功能的无限轮播库。支持多种页面切换效果和指示器样式。 </p>\n<a href=\"https://github.com/zhpanvip/viewpagerindicator\">2.ViewPagerIndicator</a> <p> 一个适用于ViewPager和ViewPager2的指示器，支持多种滑块样式及滑动模式 </p>"},"prev_next":{"enable":true},"custom":{"enable":false,"content":"<img src=\"https://octodex.github.com/images/jetpacktocat.png\" class=\"rounded mx-auto d-block mt-5\" style=\"width:150px; height:150px;\">"},"image_zoom":{"enable":true},"footnote":{"enable":true,"header":""},"math":{"enable":false,"specific":false,"engine":"mathjax"},"mermaid":{"enable":false,"specific":false,"options":{"theme":"default"}},"comments":{"enable":true,"type":"utterances"}},"utterances":{"repo":"zhpanvip/utterances-comment","issue_term":"pathname","label":"utterances","theme":"github-light","crossorigin":"anonymous"},"disqus":{"shortname":null,"disqusjs":false,"apikey":null},"gitalk":{"clientID":null,"clientSecret":null,"repo":null,"owner":null,"admin":["name"],"id":"location.pathname","language":"zh-CN","labels":["Gitalk"],"perPage":10,"pagerDirection":"last","distractionFreeMode":false,"createIssueManually":true},"valine":{"appid":"hXIROaIM5y9qnieojJRWP5hS","appkey":"y0f3w3aqd1MF7JL9ma4WECTy","placeholder":"说点什么","path":"window.location.pathname","avatar":"retro","meta":["nick","mail","link"],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"https://zhangpan.site"},"changyan":{"appid":"","appkey":""},"livere":{"uid":""},"archive":{"banner_img":"/img/bg_article.jpg","banner_img_height":60,"banner_mask_alpha":0.3,"subtitle":null},"category":{"banner_img":"/img/bg_default.png","banner_img_height":60,"banner_mask_alpha":0.3,"subtitle":null,"post_limit":10,"order_by":"-length"},"tag":{"banner_img":"/img/bg_label.jpg","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null,"tagcloud":{"min_font":15,"max_font":30,"unit":"px","start_color":"#BBBBEE","end_color":"#337ab7"}},"about":{"banner_img":"/img/bg_default.png","banner_img_height":60,"banner_mask_alpha":0.3,"subtitle":null,"avatar":"/img/avatar.png","name":"myname","introduce":"一句简短的介绍","icons":[{"class":"iconfont icon-github-fill","link":"https://github.com","tip":"GitHub"},{"class":"iconfont icon-douban-fill","link":"https://douban.com","tip":"豆瓣"},{"class":"iconfont icon-wechat-fill","qrcode":"/img/favicon.png"}]},"page404":{"banner_img":"/img/default.png","banner_img_height":85,"banner_mask_alpha":0.3,"subtitle":"Page not found"},"links":{"banner_img":"/img/default.png","banner_img_height":60,"banner_mask_alpha":0.3,"subtitle":null,"items":[{"title":"Fluid Docs","intro":"主题使用指南","link":"https://hexo.fluid-dev.com/docs/","image":"/img/favicon.png"},{"title":"Fluid Repo","intro":"主题 GitHub 仓库","link":"https://github.com/fluid-dev/hexo-theme-fluid","image":"/img/favicon.png"},{"title":"Fluid Example","intro":"主题操作示例","link":"https://hexo.fluid-dev.com/docs/example/","image":"/img/favicon.png"}]}}}},"excerpt":"","more":"<p>对于一款阅读类的软件，夜间模式是不可缺少的。最初看到这个需求时候觉得无从下手，没有一点头绪。后来通过查阅资料发现Android官方在Support Library 23.2.0中已经加入了夜间主题。也就是只需要通过更换主题便可实现日间模式和夜间模式的切换。下面截取项目实现的夜间模式效果图：<br><img src=\"https://raw.githubusercontent.com/zhpanvip/Resource/master/image/1001.jfif\"></p>\n<p>效果看起来还比较nice，没有闪屏，过度也比较平滑。那么项目中的这个日间、夜间模式切换效果是如何实现的呢？下面将从以下几个方面来讲解：</p>\n<ul>\n<li>一 实现夜间模式需要的配置</li>\n<li>二 实现白天和夜间模式的切换</li>\n<li>三 实现夜间模式时遇到的问题及解决方案</li>\n</ul>\n<p>一、实现夜间模式需要的配置<br>1.首先在gradel中引入以下依赖</p>\n<pre><code class=\"hljs apache\"><span class=\"hljs-attribute\">compile</span> &#x27;com.android.support:appcompat-v<span class=\"hljs-number\">7</span>:<span class=\"hljs-number\">25</span>.<span class=\"hljs-number\">3</span>.<span class=\"hljs-number\">1</span>&#x27;</code></pre>\n<p>2.让我们项目的主题继承夜间模式主题，在style中设置如下主题：</p>\n<pre><code class=\"hljs xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">style</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;AppTheme&quot;</span> <span class=\"hljs-attr\">parent</span>=<span class=\"hljs-string\">&quot;Theme.AppCompat.DayNight&quot;</span>&gt;</span>\n<span class=\"xml\">       <span class=\"hljs-comment\">&lt;!-- Customize your theme here. --&gt;</span></span>\n<span class=\"xml\">       <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">item</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;colorPrimary&quot;</span>&gt;</span>@color/colorPrimary<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">item</span>&gt;</span></span>\n<span class=\"xml\">       <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">item</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;colorPrimaryDark&quot;</span>&gt;</span>@color/colorPrimaryDark<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">item</span>&gt;</span></span>\n<span class=\"xml\">       <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">item</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;colorAccent&quot;</span>&gt;</span>@color/colorAccent<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">item</span>&gt;</span></span>\n   <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">style</span>&gt;</span></code></pre>\n<p>3.新建drawable-night和values-night的资源目录。如果要适配不同分辨率的屏幕则可新建drawable-night-hdip、drawable-night-xhdpi等目录来存放不同分辨率的图片资源。values-night目录下存放与夜间模式相关的value文件。本篇文章讲解仅以夜间模式和日间模式的颜色为例，在values-night目录下新建color.xml文件。</p>\n<p>（1）新建values-night目录，如下：</p>\n<p><img src=\"https://raw.githubusercontent.com/zhpanvip/Resource/master/image/1002.jfif\"></p>\n<p><img src=\"https://raw.githubusercontent.com/zhpanvip/Resource/master/image/1003.jfif\"></p>\n<p>（2）在values-night目录下新建colors文件，如下：<br><img src=\"https://raw.githubusercontent.com/zhpanvip/Resource/master/image/1004.jfif\"></p>\n<p><img src=\"https://raw.githubusercontent.com/zhpanvip/Resource/master/image/1005.jfif\"></p>\n<p>接下来只需要在对应的colors文件下写不同的颜色值(夜间颜色值和白天颜色值)即可。至此关于实现夜间模式的配置已经基本完成。</p>\n<p>二、实现白天和夜间模式的切换<br>1.启动App时检测是否处于夜间模式，如果是则切换至夜间主题。这个需要在自己项目的Application中实现。可在自己项目的Application中添加以下代码：</p>\n<pre><code class=\"hljs arduino\"><span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">  * 初始化夜间模式</span>\n<span class=\"hljs-comment\">  */</span>\n   <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">setNightMode</span><span class=\"hljs-params\">()</span> </span>&#123;\n       <span class=\"hljs-keyword\">boolean</span> nightMode = UserInfoTools.isNightMode(<span class=\"hljs-keyword\">this</span>);\n       AppCompatDelegate.setDefaultNightMode(nightMode ?\n               AppCompatDelegate.MODE_NIGHT_YES : AppCompatDelegate.MODE_NIGHT_NO);\n   &#125;</code></pre>\n<p>这里需要介绍一下有关夜间模式的几个常量值。AppCompatDelegate.setDefaultNightMode(mode),其中mode有一下四个值：</p>\n<ul>\n<li>MODE_NIGHT_NO： 亮色(light)主题，不使用夜间模式</li>\n<li>MODE_NIGHT_YES：暗色(dark)主题，使用夜间模式</li>\n<li>MODE_NIGHT_AUTO：根据当前时间自动切换 亮色(light)/暗色(dark)主题（22：00-07：00时间段内自动切换为夜间模式）</li>\n<li>MODE_NIGHT_FOLLOW_SYSTEM(默认选项)：设置为跟随系统，通常为MODE_NIGHT_NO<br>2.接下来需要我们在设置页面点击ToggleButton时切换白天/夜间模式。<br>具体实现如下：<pre><code class=\"hljs jboss-cli\">private void <span class=\"hljs-keyword\">set</span>NightMode<span class=\"hljs-params\">()</span> &#123;\n         <span class=\"hljs-string\">//</span>  获取当前模式\n        int currentNightMode = getResources<span class=\"hljs-params\">()</span><span class=\"hljs-string\">.getConfiguration</span><span class=\"hljs-params\">()</span><span class=\"hljs-string\">.uiMode</span> &amp; Configuration.UI_MODE_NIGHT_MASK;\n        <span class=\"hljs-string\">//</span>  将是否为夜间模式保存到SharedPreferences\n        UserInfoTools.<span class=\"hljs-keyword\">set</span>NightMode<span class=\"hljs-params\">(this, <span class=\"hljs-attr\">currentNightMode</span> == Configuration.UI_MODE_NIGHT_NO)</span>;\n        <span class=\"hljs-string\">//</span>  切换模式\n        getDelegate<span class=\"hljs-params\">()</span><span class=\"hljs-string\">.setDefaultNightMode</span><span class=\"hljs-params\">(<span class=\"hljs-attr\">currentNightMode</span> == Configuration.UI_MODE_NIGHT_NO ?</span>\n<span class=\"hljs-params\">                AppCompatDelegate.MODE_NIGHT_YES : AppCompatDelegate.MODE_NIGHT_NO)</span>;\n        UserInfoTools.<span class=\"hljs-keyword\">set</span>ChangeNightMode<span class=\"hljs-params\">(this,true)</span>;\n        <span class=\"hljs-string\">//</span>  重启Activity\n        recreate<span class=\"hljs-params\">()</span>;\n    &#125;\n\nprivate void <span class=\"hljs-keyword\">set</span>Listener<span class=\"hljs-params\">()</span> &#123;\n        mToggleButton.<span class=\"hljs-keyword\">set</span>OnClickListener<span class=\"hljs-params\">((View v)</span> -&gt; &#123;\n            <span class=\"hljs-keyword\">set</span>NightMode<span class=\"hljs-params\">()</span>;\n        &#125;);\n    &#125;</code></pre>\n注意，上面代码中设置白天/夜间模式的代码的最后调用了recreate()方法重启了当前Activity。但这样写切换模式时会有闪屏问题，体验比较差。具体优化将在下一节中实现。</li>\n</ul>\n<p>三 、实现夜间模式时遇到的问题及解决方案<br>利用谷歌官方提供的这个方案实现夜间模式的过程中遇到了不少的问题。且网上资料较少，大多文章讲解仅仅以一个简单的demo为例。但在用到实际项目中时会遇到很多的麻烦。这里主要总结了笔者曾经遇到过的难以解决的几个问题。<br>1.白天/夜间模式切换时闪屏问题<br>上一节中已经提到了在调用recreate()方法时会有闪屏问题。其实闪屏问题的解决比较简单。我们大可以不掉用recreate()方法，而是自己重启当前activity并为activity设置启动和退出动画即可！实现代码如下：</p>\n<pre><code class=\"hljs groovy\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> setNightMode() &#123;\n       <span class=\"hljs-comment\">//  获取当前模式</span>\n       <span class=\"hljs-keyword\">int</span> currentNightMode = getResources().getConfiguration().uiMode &amp; Configuration.UI_MODE_NIGHT_MASK;\n       <span class=\"hljs-comment\">//  将是否为夜间模式保存到SharedPreferences</span>\n       UserInfoTools.setNightMode(<span class=\"hljs-built_in\">this</span>, currentNightMode == Configuration.UI_MODE_NIGHT_NO);\n       <span class=\"hljs-comment\">//  切换模式</span>\n       getDelegate().setDefaultNightMode(currentNightMode == Configuration.UI_MODE_NIGHT_NO ?\n               AppCompatDelegate.MODE_NIGHT_YES : AppCompatDelegate.MODE_NIGHT_NO);\n       UserInfoTools.setChangeNightMode(<span class=\"hljs-built_in\">this</span>,<span class=\"hljs-literal\">true</span>);\n       \n       <span class=\"hljs-comment\">//recreate();</span>\n\n       startActivity(<span class=\"hljs-keyword\">new</span> Intent(<span class=\"hljs-built_in\">this</span>,SettingActivity.<span class=\"hljs-keyword\">class</span>));\n       overridePendingTransition(R.anim.animo_alph_close, R.anim.animo_alph_close);\n       finish();\n   &#125;</code></pre>\n<p>如上代码，我们自行调用startActivity启动了设置页面并为其添加了一个透明渐变的启动动画。最后调用finish结束掉旧的设置页面。这样闪屏问题便迎刃而解。模式切换也变得流畅自然。<br> 2.切换夜间模式后返回MainActivity,MainActivity页面没有更新。解决这个问题可以在切换模式后从设置页面发送一个广播，然后在MainActivity中接收到这个广播后重启MainActivity即可。根据官方的推荐更换夜间模式后需要调用recreate()方法刷新页面。但是recreate()方法巨坑无比，调用recreate()方法引起了诸多问题。详见问题3、4、5。因此解决这个问题笔者并没有在MainActivity调用中调用recreate()方法。而是在SettingActivity中定义了一个boolean值来标记是否切换了夜间模式。然后重写了onKeyDown()方法。如果切换了夜间模式则在返回时发出一个广播结束掉MainActivity,然后调用startActivity()重启了MainActivity并添加了启动动画，让用户感觉是只是返回了主页面。其实思想跟解决问题1有些类似。还是结合代码来看吧。</p>\n<p>SettingActivity中的代码</p>\n<pre><code class=\"hljs reasonml\">@Override\n   public boolean on<span class=\"hljs-constructor\">KeyDown(<span class=\"hljs-params\">int</span> <span class=\"hljs-params\">keyCode</span>, KeyEvent <span class=\"hljs-params\">event</span>)</span> &#123;\n       <span class=\"hljs-keyword\">if</span> (keyCode<span class=\"hljs-operator\"> == </span>KeyEvent.KEYCODE_BACK<span class=\"hljs-operator\"> &amp;&amp; </span>event.get<span class=\"hljs-constructor\">Action()</span><span class=\"hljs-operator\"> == </span>KeyEvent.ACTION_DOWN) &#123;\n           go<span class=\"hljs-constructor\">Back()</span>;\n           return <span class=\"hljs-literal\">true</span>;\n       &#125;\n       return super.on<span class=\"hljs-constructor\">KeyDown(<span class=\"hljs-params\">keyCode</span>, <span class=\"hljs-params\">event</span>)</span>;\n   &#125;\n\n   <span class=\"hljs-keyword\">private</span> void go<span class=\"hljs-constructor\">Back()</span> &#123;\n       <span class=\"hljs-keyword\">if</span> (isChangeNightMode) &#123;  <span class=\"hljs-comment\">//  如果改变了夜间模式，则重启MainActivity</span>\n           <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">EventBus</span>.</span></span>get<span class=\"hljs-constructor\">Default()</span>.post(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-constructor\">NightModeEvent()</span>);\n           Intent intent = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-constructor\">Intent(<span class=\"hljs-params\">this</span>, MainActivity.<span class=\"hljs-params\">class</span>)</span>;\n           intent.put<span class=\"hljs-constructor\">Extra(<span class=\"hljs-string\">&quot;nightMode&quot;</span>, <span class=\"hljs-params\">true</span>)</span>;\n           start<span class=\"hljs-constructor\">Activity(<span class=\"hljs-params\">intent</span>)</span>;\n           override<span class=\"hljs-constructor\">PendingTransition(R.<span class=\"hljs-params\">anim</span>.<span class=\"hljs-params\">animo_alph_close</span>, R.<span class=\"hljs-params\">anim</span>.<span class=\"hljs-params\">activity_close</span>)</span>;\n       &#125;\n       finish<span class=\"hljs-literal\">()</span>;\n   &#125;</code></pre>\n<p>MainActivity中的代码：</p>\n<pre><code class=\"hljs reasonml\"> @Override\n   public void on<span class=\"hljs-constructor\">Create(Bundle <span class=\"hljs-params\">savedInstanceState</span>)</span> &#123;\n       super.on<span class=\"hljs-constructor\">Create(<span class=\"hljs-params\">savedInstanceState</span>)</span>;\n       set<span class=\"hljs-constructor\">ContentView(R.<span class=\"hljs-params\">layout</span>.<span class=\"hljs-params\">activity_main</span>)</span>;\n       \n       re<span class=\"hljs-constructor\">StartActivity()</span>\n   &#125;\n\n<span class=\"hljs-comment\">//  改变夜间模式后返回时重启Activity</span>\n   <span class=\"hljs-keyword\">private</span> void re<span class=\"hljs-constructor\">StartActivity()</span> &#123;\n       Intent intent = get<span class=\"hljs-constructor\">Intent()</span>;\n       boolean nightMode = intent.get<span class=\"hljs-constructor\">BooleanExtra(<span class=\"hljs-string\">&quot;nightMode&quot;</span>, <span class=\"hljs-params\">false</span>)</span>;\n       <span class=\"hljs-keyword\">if</span>(nightMode&amp;&amp;<span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">UserInfoTools</span>.</span></span>get<span class=\"hljs-constructor\">IsLogin(<span class=\"hljs-params\">this</span>)</span>)&#123;\n           <span class=\"hljs-comment\">//  自动切换到“我的”页面</span>\n           mRbMe.perform<span class=\"hljs-constructor\">Click()</span>;\n       &#125;\n   &#125;\n\n<span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">    * 接收到夜间模式改变的事件后结束当前Activity</span>\n<span class=\"hljs-comment\">    * @param event</span>\n<span class=\"hljs-comment\">    */</span>\n @Subscribe\n   public void set<span class=\"hljs-constructor\">NightMode(NightModeEvent <span class=\"hljs-params\">event</span>)</span> &#123;\n       finish<span class=\"hljs-literal\">()</span>;\n   &#125;</code></pre>\n<p>最后还有点问题需要说明，由问题1我们可以知道，改变模式后，我们重启了SettingActivity。因此在该类中定义的一个标记是否切换了夜间模式的boolean值并不能起到作用。解决办法是将这个值保存到SharedPreference中。然后重启SettingActivity后再取出该值。可以看代码，这点真心有点绕啊。。。<br>注意问题1中的setNightMode()方法中有一句代码 UserInfoTools.setChangeNightMode(this,true);将改变了夜间模式设置为了true并保存到了SharedPreferences中，然后在onCreate()中有以下代码来初始化isChangeNightMode的值。</p>\n<pre><code class=\"hljs reasonml\">@Override\n   public void on<span class=\"hljs-constructor\">Create(Bundle <span class=\"hljs-params\">savedInstanceState</span>)</span> &#123;\n       super.on<span class=\"hljs-constructor\">Create(<span class=\"hljs-params\">savedInstanceState</span>)</span>;\n       set<span class=\"hljs-constructor\">ContentView(R.<span class=\"hljs-params\">layout</span>.<span class=\"hljs-params\">activity_main</span>)</span>;\n                isChangeNightMode=<span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">UserInfoTools</span>.</span></span>is<span class=\"hljs-constructor\">ChangeNightMode(<span class=\"hljs-params\">this</span>)</span>;\n       <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">UserInfoTools</span>.</span></span>set<span class=\"hljs-constructor\">ChangeNightMode(<span class=\"hljs-params\">this</span>,<span class=\"hljs-params\">false</span>)</span>;\n   &#125;\n</code></pre>\n<p>3.设置白天/夜间模式后出现无故闪退问题<br>这个问题说来比较奇怪，原因是切换了夜间模式后在MainActivity中调用了recreate()方法。具体原因笔者也没有弄清楚，调试了好一阵子也没有找出个所以然来。后来果断放弃了在MainActivity中调用recreate()方法，而是换成了startActivity()重新启动了MainActivity。之后这个问题便不复存在了。</p>\n<p>4.点击ToggleButton切换模式后应用黑屏，随后挂掉。这个问题的最终原因还是因为recreate()方法引起的。如果你用了ToggleButton切换白天/夜间模式，并且为ToggleButton设置了setOnCheckChangedListener()方法，那么你将有很大概率碰到这个问题。引起这个问题的原因是因为调用了recreate()方法后Activity重新启动，但是新启动的Activity保存了之前Activity的状态。因此在重启时候重新设置了TouggleButton，继而调用了又setOnCheckChangedListener()方法，结果悲剧了。。。一个死循环产生了，程序不黑屏才怪。因此最简单的办法是放弃recreate()方法，改用问题1中的方法！（其实细心的小伙伴应该已经发现了，我的代码中仅仅是为ToggleButton设置了setOnClickListener()….机智如我啊）如果你有强迫症必须要使用setOnCheckChangedListener和recreate()方法那么也不是没有解决方案。可以定义一个boolean成员变量，然后在onCreate()方法中判断savedInstanceState是否为null，然后给这个boolean成员变量赋值，并在setOnCheckChangedListener()方法中根据这个boolean成员变量的值去调用设置夜间模式的方法即可。</p>\n<p>5.设置夜间模式后MainActivity调用recreate()方法，MainActivity中的”发现“页面没有加载出来。发现页面如下面图片所示，也就是一个Fragment中嵌套了一个ViewPager。调用recreate()后整个ViewPager消失了。。。没有加载出来！！！<br><img src=\"https://raw.githubusercontent.com/zhpanvip/Resource/master/image/1006.jfif\"></p>\n<p>解决方案，放弃使用recreate()，改用问题1中的方法！</p>\n<p>万恶的recreate()方法！难道是我使用的姿势不对？</p>\n"},{"title":"Java自定义注解在Android中的实例应用","date":"2018-08-25T10:34:47.000Z","_content":"\nJava注解在我们项目开发 中是非常常见的。比如经常用到的几种java内置的注解：\n\n>  @Override，表示当前的方法定义将覆盖超类中的方法。\n    @Deprecated，表示当前方法即将废弃，不推荐使用。\n    @SuppressWarnings，表示忽略编译器的警告信息。\n\n对于上面几个注解想必大家都不会陌生。除此之外，我们还经常在一些第三方框架中看到一些自定义注解。比如大名鼎鼎的ButterKnife和EventBus都是基于注解实现的。网上关于注解的文章数不胜数，但是，很多章都是贴下注解的定义，然后解释下几种元注解，扔出一个自定义注解的例子就不了了之了。刚接触注解的时候，看了半天注解相关的文章也没弄懂注解到底有什么用。其实注解往往是需要结合反射来用的，离了反射，注解也就失去了灵魂。因此，本篇文章我们会先来学习一些注解相关的一些基础知识，然后结合反射来实现一个与ButterKnife一样功能的实例。当然ButterKnife的实现并非是用反射而是使用注解处理器（AnnotationProcessor）来实现的，但是，本篇文章重点是自定义注解，因此，我们就用注解结合反射来模仿ButterKnife的效果。\n\n一、注解基础知识简介\n----------\n\n**1.注解(Annotation)的声明**\n\n同类(class)与接口(interface)一样，注解( @interface)也是一种定义类型，它是在JDK 5.0中引入的。我们可以通过@interface来声明一个注解：\n\n```\npublic @interface MAnnotation {\n}\n```\n**2.注解的成员变量**\n注解与类一样，都存在成员变量。与类的区别是注解中没有方法。因此，来看下如何在注解中声明成员变量。\n\n```\npublic @interface MAnnotation {\n    string name();\n    int age();\n}\n```\n上述示例中我们在MAnnotation中声明了一个String类型的name和一个int类型的age的成员变量。除此之外，我们还可以为成员变量制定默认值：\n\n```\npublic @interface MAnnotation {\n    string name() default \"Jack\";\n    int age() default 18;\n}\n```\n如果注解的成员变量被赋予了默认值，那么使用注解时可以不为成员变量赋值，而是用直接使用默认值。\n**3.注解的分类**\n根据注解是否包含成员变量，可以把Annotation分为如下两类：\n***(1)标记注解***       标记注解指的时没有包含成员变量的注解，例如java内置的注解@Override注解。\n***(2)元数据注解***   元数据注解指的是包含成员变量的注解，这类注解可以接受更多的元数据。例如，ButteerKnife的@BindView注解\n\n**4.元注解**\n元注解可以理解为注解的注解。用来提供对给其他的注解类型类型做说明。JDK中提供了如下4个元注解：\n\n> @Target\n> @Retention\n> @Documented\n> @Inherited\n\n针对以上四种注解，我们来分别解析\n\n***(1)@Target注解***\n指定Annotation用于修饰哪些程序元素。@Target也包含一个名为”value“的成员变量，该value成员变量类型为ElementType[ ]，ElementType为枚举类型，值有如下几个：\n\n> ElementType.TYPE：能修饰类、接口或枚举类型\n> ElementType.FIELD：能修饰成员变量\n> ElementType.METHOD：能修饰方法\n> ElementType.PARAMETER：能修饰参数\n> ElementType.CONSTRUCTOR：能修饰构造器\n> ElementType.LOCAL_VARIABLE：能修饰局部变量\n> ElementType.ANNOTATION_TYPE：能修饰注解\n> ElementType.PACKAGE：能修饰包\n\n举个栗子，用FIELD和METHOD来作为Target的value，那么MAnnotation 就只能用来修饰类的成员变量和方法\n```\n@Target(ElementType.FIELD,, ElementType.METHOD)\npublic @interface MAnnotation {\n    string name() default \"Jack\";\n    int age() default 18;\n}\n```\n**(2)@Retention**\n这个注解定义了该注解可以保留多长时间。某些注解仅出现在源代码中，而被编译器丢弃；而另一些却被编译在class文件中；编译在class文件中的Annotation可能会被虚拟机忽略，而另一些在class被装载时将被读取（请注意并不影响class的执行，因为Annotation与class在使用上是被分离的）。使用这个meta-Annotation可以对 Annotation的“生命周期”限制。\n@Retention同样包含一个名为“value”的成员变量，该value成员变量是RetentionPolicy枚举类型。使用@Retention时，必须为其value指定值。value成员变量的值只能是如下3个：\n\n> RetentionPolicy.SOURCE：Annotation只保留在源代码中，编译器编译时，直接丢弃这种Annotation。\n> RetentionPolicy.CLASS：编译器把Annotation记录在class文件中。当运行Java程序时，JVM中不再保留该Annotation。\n> RetentionPolicy.RUNTIME：编译器把Annotation记录在class文件中。当运行Java程序时，JVM会保留该Annotation，程序可以通过反射获取该Annotation的信息。\n\n\n@Retention举个栗子：\n```\n@Target(RetentionPolicy.RUNTIME)\n@Target(ElementType.FIELD)\npublic @interface MAnnotation {\n    string name() default \"Jack\";\n    int age() default 18;\n}\n```\n**(3)@Documented**\n@Documented是一个标记注解，如果定义注解MAnnotation ，使用了@Documented修饰定义，则在用javadoc命令生成API文档后，所有使用注解MAnnotation 修饰的程序元素，将会包含注解MAnnotation 的说明。举了这么久的栗子，也挺累，这个就不举了吧。。。\n**(4)@Inherited**\n@Inherited是一个标记注解，指定注解具有继承性。要注意的是它并不是说注解本身可以继承，而是说如果一个父类被 @Inherited 注解过的注解进行注解的话，那么如果它的子类没有被任何注解应用的话，那么这个子类就继承了父类的注解。这次我们还是需要举个栗子的：\n\n```\nInherited\n@Retention(RetentionPolicy.RUNTIME)\n@interface MAnnotation {}\n\n\n@MAnnotation \npublic class ClassA{}\n\n\npublic class ClassB extends ClassA {}\n```\n注解 @MAnnotation 被 @Inherited 修饰，ClassA 被 MAnnotation 注解，ClassB 继承 ClassA，那么此时ClassB也拥有@MAnnotation 注解。\n\n二、使用注解与反射实现ButterKnife的功能\n-------------------------\n\n说了这么久，关于注解的相关基础知识终于讲完了。但是，即使看到这里不知道小伙伴是否仍然会迷茫，注解到底有什么用？在文章开头我们就提到离开反射的注解是没有灵魂的，因此，正是因为反射才赋予了注解实质的用途。那么接下来，我们用注解和反射来模仿并实现ButterKnife的功能吧。\n首先，来分析一下要实现的功能。\n\n> 使用注解注入布局文件省去setContentView\n> 使用注解省去findViewById\n> 使用注解省去setOnClickListener\n\n\n**1.根据上述需求，我们可以定义三个注解。**如下:\n\n```\n//\t给Activity注入布局文件的注解\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface InjectLayout {\n    int value() default -1;\n}\n\n//\t查找控件ID的注解\n@Retention(RetentionPolicy.SOURCE)\n@Target({ElementType.FIELD})\npublic @interface BindView {\n    int value() default -1;\n}\n\n//\t给View设置监听事件的注解\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface OnClick {\n    int[] value();\n}\n\n```\n**2.声明BindProcessor类通过反射处理以上注解**\n\n```\n\t//  处理@InjectLayout \n\tprivate static void injectLayout(Activity activity) {\n        Class<?> activityClass = activity.getClass();\n        if (activityClass.isAnnotationPresent(InjectLayout.class)) {\n            InjectLayout mId = activityClass.getAnnotation(InjectLayout.class);\n            int id = mId.value();\n            try {\n                Method method = activityClass.getMethod(\"setContentView\", int.class);\n                method.setAccessible(true);\n                method.invoke(activity, id);\n            } catch (NoSuchMethodException | IllegalAccessException | InvocationTargetException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n\t//  处理@BindView\n    private static void bindView(Activity activity) {\n        Class<?> activityClass = activity.getClass();\n        Field[] declaredFields = activityClass.getDeclaredFields();\n        for (Field field : declaredFields) {\n            if (field.isAnnotationPresent(BindView.class)) {\n                BindView mId = field.getAnnotation(BindView.class);\n                int id = mId.value();\n                try {\n                    Method method = activityClass.getMethod(\"findViewById\", int.class);\n                    method.setAccessible(true);\n                    Object view = method.invoke(activity, id);\n                    field.setAccessible(true);\n                    field.set(activity, view);\n                } catch (NoSuchMethodException e) {\n                    e.printStackTrace();\n                } catch (IllegalAccessException e) {\n                    e.printStackTrace();\n                } catch (InvocationTargetException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n\t//  处理@OnClick\n    private static void bindOnClick(final Activity activity) {\n        Class<?> cls = activity.getClass();\n        Method[] methods = cls.getMethods();\n        for (int i = 0; i < methods.length; i++) {\n            final Method method = methods[i];\n            if (method.isAnnotationPresent(OnClick.class)) {\n                OnClick mOnclick = method.getAnnotation(OnClick.class);\n                int[] ids = mOnclick.value();\n                for (int j = 0; j < ids.length; j++) {\n                    final View view = activity.findViewById(ids[j]);\n                    if(view==null) continue;\n                    view.setOnClickListener(new View.OnClickListener() {\n                        @Override\n                        public void onClick(View v) {\n                            try {\n                                method.setAccessible(true);\n                                method.invoke(activity, view);\n                            } catch (IllegalAccessException e) {\n                                e.printStackTrace();\n                            } catch (InvocationTargetException e) {\n                                e.printStackTrace();\n                            }\n                        }\n                    });\n                }\n            }\n        }\n    }\n\n\n//\tbind方法对外开放\npublic static void bind(Activity activity) {\n        injectLayout(activity);\n        bindView(activity);\n        bindOnClick(activity);\n    }\n```\n以上代码并没有什么难度，只要是了解一点反射知识的相信都能看懂。那么我们只要在Activity中调用bind方法后便可以使用注解了。下面来看Activity中的代码：\n\n```\n@InjectLayout(R.layout.activity_main)\npublic class MainActivity extends AppCompatActivity {\n    @BindView(R.id.tv_test)\n    private Button mButton;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n//        setContentView(R.layout.activity_main);\n        BindProcessor.bind(this);\n        mButton.setText(\"通过注解设置的Text\");\n    }\n\n    @OnClick({R.id.tv_test, R.id.btn_reflect})\n    public void onClick(View view) {\n        switch (view.getId()) {\n            case R.id.tv_test:\n                Toast.makeText(this, \"通过注解点解了Text\", Toast.LENGTH_SHORT).show();\n                break;\n            case R.id.btn_reflect:\n                testReflect();\n                break;\n        }\n    }\n}\n```\n可以看到，我们并没有在onCreate方法中调用setContentView方法，也没有去为Button按钮findViewById，更没有为其设置监听事件，我们统统都是用上面自定义的注解实现的。那么效果如何呢？我们来看下运行及起来的效果：\n![](https://raw.githubusercontent.com/zhpanvip/Resource/master/image/1501.gif)\n\n\n效果貌似还不错，实现了与ButterKnife的部分功能，甚至我们还比ButterKnife多了一个注入布局的功能。但是，我们要知道的是ButterKnife并非是直接用反射实现的，因为反射是在运行时处理的，会影响到程序的效率。但对于神一般存在的Jake，怎么会做如此没有效率的事情。关于ButterKnife是如何实现注解，我们在下篇文章中在做探讨。\n\n[源码参考](https://github.com/zhpanvip/MAnnotation/blob/master/app/src/main/java/com/zhpan/mannotation/BindProcessor.java)\n\n\n","source":"_posts/16.Java自定义注解在Android中的实例应用.md","raw":"---\ntitle: Java自定义注解在Android中的实例应用\ndate: 2018-08-25 18:34:47\ntags: \n- Annotation\n---\n\nJava注解在我们项目开发 中是非常常见的。比如经常用到的几种java内置的注解：\n\n>  @Override，表示当前的方法定义将覆盖超类中的方法。\n    @Deprecated，表示当前方法即将废弃，不推荐使用。\n    @SuppressWarnings，表示忽略编译器的警告信息。\n\n对于上面几个注解想必大家都不会陌生。除此之外，我们还经常在一些第三方框架中看到一些自定义注解。比如大名鼎鼎的ButterKnife和EventBus都是基于注解实现的。网上关于注解的文章数不胜数，但是，很多章都是贴下注解的定义，然后解释下几种元注解，扔出一个自定义注解的例子就不了了之了。刚接触注解的时候，看了半天注解相关的文章也没弄懂注解到底有什么用。其实注解往往是需要结合反射来用的，离了反射，注解也就失去了灵魂。因此，本篇文章我们会先来学习一些注解相关的一些基础知识，然后结合反射来实现一个与ButterKnife一样功能的实例。当然ButterKnife的实现并非是用反射而是使用注解处理器（AnnotationProcessor）来实现的，但是，本篇文章重点是自定义注解，因此，我们就用注解结合反射来模仿ButterKnife的效果。\n\n一、注解基础知识简介\n----------\n\n**1.注解(Annotation)的声明**\n\n同类(class)与接口(interface)一样，注解( @interface)也是一种定义类型，它是在JDK 5.0中引入的。我们可以通过@interface来声明一个注解：\n\n```\npublic @interface MAnnotation {\n}\n```\n**2.注解的成员变量**\n注解与类一样，都存在成员变量。与类的区别是注解中没有方法。因此，来看下如何在注解中声明成员变量。\n\n```\npublic @interface MAnnotation {\n    string name();\n    int age();\n}\n```\n上述示例中我们在MAnnotation中声明了一个String类型的name和一个int类型的age的成员变量。除此之外，我们还可以为成员变量制定默认值：\n\n```\npublic @interface MAnnotation {\n    string name() default \"Jack\";\n    int age() default 18;\n}\n```\n如果注解的成员变量被赋予了默认值，那么使用注解时可以不为成员变量赋值，而是用直接使用默认值。\n**3.注解的分类**\n根据注解是否包含成员变量，可以把Annotation分为如下两类：\n***(1)标记注解***       标记注解指的时没有包含成员变量的注解，例如java内置的注解@Override注解。\n***(2)元数据注解***   元数据注解指的是包含成员变量的注解，这类注解可以接受更多的元数据。例如，ButteerKnife的@BindView注解\n\n**4.元注解**\n元注解可以理解为注解的注解。用来提供对给其他的注解类型类型做说明。JDK中提供了如下4个元注解：\n\n> @Target\n> @Retention\n> @Documented\n> @Inherited\n\n针对以上四种注解，我们来分别解析\n\n***(1)@Target注解***\n指定Annotation用于修饰哪些程序元素。@Target也包含一个名为”value“的成员变量，该value成员变量类型为ElementType[ ]，ElementType为枚举类型，值有如下几个：\n\n> ElementType.TYPE：能修饰类、接口或枚举类型\n> ElementType.FIELD：能修饰成员变量\n> ElementType.METHOD：能修饰方法\n> ElementType.PARAMETER：能修饰参数\n> ElementType.CONSTRUCTOR：能修饰构造器\n> ElementType.LOCAL_VARIABLE：能修饰局部变量\n> ElementType.ANNOTATION_TYPE：能修饰注解\n> ElementType.PACKAGE：能修饰包\n\n举个栗子，用FIELD和METHOD来作为Target的value，那么MAnnotation 就只能用来修饰类的成员变量和方法\n```\n@Target(ElementType.FIELD,, ElementType.METHOD)\npublic @interface MAnnotation {\n    string name() default \"Jack\";\n    int age() default 18;\n}\n```\n**(2)@Retention**\n这个注解定义了该注解可以保留多长时间。某些注解仅出现在源代码中，而被编译器丢弃；而另一些却被编译在class文件中；编译在class文件中的Annotation可能会被虚拟机忽略，而另一些在class被装载时将被读取（请注意并不影响class的执行，因为Annotation与class在使用上是被分离的）。使用这个meta-Annotation可以对 Annotation的“生命周期”限制。\n@Retention同样包含一个名为“value”的成员变量，该value成员变量是RetentionPolicy枚举类型。使用@Retention时，必须为其value指定值。value成员变量的值只能是如下3个：\n\n> RetentionPolicy.SOURCE：Annotation只保留在源代码中，编译器编译时，直接丢弃这种Annotation。\n> RetentionPolicy.CLASS：编译器把Annotation记录在class文件中。当运行Java程序时，JVM中不再保留该Annotation。\n> RetentionPolicy.RUNTIME：编译器把Annotation记录在class文件中。当运行Java程序时，JVM会保留该Annotation，程序可以通过反射获取该Annotation的信息。\n\n\n@Retention举个栗子：\n```\n@Target(RetentionPolicy.RUNTIME)\n@Target(ElementType.FIELD)\npublic @interface MAnnotation {\n    string name() default \"Jack\";\n    int age() default 18;\n}\n```\n**(3)@Documented**\n@Documented是一个标记注解，如果定义注解MAnnotation ，使用了@Documented修饰定义，则在用javadoc命令生成API文档后，所有使用注解MAnnotation 修饰的程序元素，将会包含注解MAnnotation 的说明。举了这么久的栗子，也挺累，这个就不举了吧。。。\n**(4)@Inherited**\n@Inherited是一个标记注解，指定注解具有继承性。要注意的是它并不是说注解本身可以继承，而是说如果一个父类被 @Inherited 注解过的注解进行注解的话，那么如果它的子类没有被任何注解应用的话，那么这个子类就继承了父类的注解。这次我们还是需要举个栗子的：\n\n```\nInherited\n@Retention(RetentionPolicy.RUNTIME)\n@interface MAnnotation {}\n\n\n@MAnnotation \npublic class ClassA{}\n\n\npublic class ClassB extends ClassA {}\n```\n注解 @MAnnotation 被 @Inherited 修饰，ClassA 被 MAnnotation 注解，ClassB 继承 ClassA，那么此时ClassB也拥有@MAnnotation 注解。\n\n二、使用注解与反射实现ButterKnife的功能\n-------------------------\n\n说了这么久，关于注解的相关基础知识终于讲完了。但是，即使看到这里不知道小伙伴是否仍然会迷茫，注解到底有什么用？在文章开头我们就提到离开反射的注解是没有灵魂的，因此，正是因为反射才赋予了注解实质的用途。那么接下来，我们用注解和反射来模仿并实现ButterKnife的功能吧。\n首先，来分析一下要实现的功能。\n\n> 使用注解注入布局文件省去setContentView\n> 使用注解省去findViewById\n> 使用注解省去setOnClickListener\n\n\n**1.根据上述需求，我们可以定义三个注解。**如下:\n\n```\n//\t给Activity注入布局文件的注解\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface InjectLayout {\n    int value() default -1;\n}\n\n//\t查找控件ID的注解\n@Retention(RetentionPolicy.SOURCE)\n@Target({ElementType.FIELD})\npublic @interface BindView {\n    int value() default -1;\n}\n\n//\t给View设置监听事件的注解\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface OnClick {\n    int[] value();\n}\n\n```\n**2.声明BindProcessor类通过反射处理以上注解**\n\n```\n\t//  处理@InjectLayout \n\tprivate static void injectLayout(Activity activity) {\n        Class<?> activityClass = activity.getClass();\n        if (activityClass.isAnnotationPresent(InjectLayout.class)) {\n            InjectLayout mId = activityClass.getAnnotation(InjectLayout.class);\n            int id = mId.value();\n            try {\n                Method method = activityClass.getMethod(\"setContentView\", int.class);\n                method.setAccessible(true);\n                method.invoke(activity, id);\n            } catch (NoSuchMethodException | IllegalAccessException | InvocationTargetException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n\t//  处理@BindView\n    private static void bindView(Activity activity) {\n        Class<?> activityClass = activity.getClass();\n        Field[] declaredFields = activityClass.getDeclaredFields();\n        for (Field field : declaredFields) {\n            if (field.isAnnotationPresent(BindView.class)) {\n                BindView mId = field.getAnnotation(BindView.class);\n                int id = mId.value();\n                try {\n                    Method method = activityClass.getMethod(\"findViewById\", int.class);\n                    method.setAccessible(true);\n                    Object view = method.invoke(activity, id);\n                    field.setAccessible(true);\n                    field.set(activity, view);\n                } catch (NoSuchMethodException e) {\n                    e.printStackTrace();\n                } catch (IllegalAccessException e) {\n                    e.printStackTrace();\n                } catch (InvocationTargetException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n\t//  处理@OnClick\n    private static void bindOnClick(final Activity activity) {\n        Class<?> cls = activity.getClass();\n        Method[] methods = cls.getMethods();\n        for (int i = 0; i < methods.length; i++) {\n            final Method method = methods[i];\n            if (method.isAnnotationPresent(OnClick.class)) {\n                OnClick mOnclick = method.getAnnotation(OnClick.class);\n                int[] ids = mOnclick.value();\n                for (int j = 0; j < ids.length; j++) {\n                    final View view = activity.findViewById(ids[j]);\n                    if(view==null) continue;\n                    view.setOnClickListener(new View.OnClickListener() {\n                        @Override\n                        public void onClick(View v) {\n                            try {\n                                method.setAccessible(true);\n                                method.invoke(activity, view);\n                            } catch (IllegalAccessException e) {\n                                e.printStackTrace();\n                            } catch (InvocationTargetException e) {\n                                e.printStackTrace();\n                            }\n                        }\n                    });\n                }\n            }\n        }\n    }\n\n\n//\tbind方法对外开放\npublic static void bind(Activity activity) {\n        injectLayout(activity);\n        bindView(activity);\n        bindOnClick(activity);\n    }\n```\n以上代码并没有什么难度，只要是了解一点反射知识的相信都能看懂。那么我们只要在Activity中调用bind方法后便可以使用注解了。下面来看Activity中的代码：\n\n```\n@InjectLayout(R.layout.activity_main)\npublic class MainActivity extends AppCompatActivity {\n    @BindView(R.id.tv_test)\n    private Button mButton;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n//        setContentView(R.layout.activity_main);\n        BindProcessor.bind(this);\n        mButton.setText(\"通过注解设置的Text\");\n    }\n\n    @OnClick({R.id.tv_test, R.id.btn_reflect})\n    public void onClick(View view) {\n        switch (view.getId()) {\n            case R.id.tv_test:\n                Toast.makeText(this, \"通过注解点解了Text\", Toast.LENGTH_SHORT).show();\n                break;\n            case R.id.btn_reflect:\n                testReflect();\n                break;\n        }\n    }\n}\n```\n可以看到，我们并没有在onCreate方法中调用setContentView方法，也没有去为Button按钮findViewById，更没有为其设置监听事件，我们统统都是用上面自定义的注解实现的。那么效果如何呢？我们来看下运行及起来的效果：\n![](https://raw.githubusercontent.com/zhpanvip/Resource/master/image/1501.gif)\n\n\n效果貌似还不错，实现了与ButterKnife的部分功能，甚至我们还比ButterKnife多了一个注入布局的功能。但是，我们要知道的是ButterKnife并非是直接用反射实现的，因为反射是在运行时处理的，会影响到程序的效率。但对于神一般存在的Jake，怎么会做如此没有效率的事情。关于ButterKnife是如何实现注解，我们在下篇文章中在做探讨。\n\n[源码参考](https://github.com/zhpanvip/MAnnotation/blob/master/app/src/main/java/com/zhpan/mannotation/BindProcessor.java)\n\n\n","slug":"16.Java自定义注解在Android中的实例应用","published":1,"updated":"2020-08-29T18:01:37.236Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckegm5nrr0004dwoz1maebn1u","content":"<p>Java注解在我们项目开发 中是非常常见的。比如经常用到的几种java内置的注解：</p>\n<blockquote>\n<p> @Override，表示当前的方法定义将覆盖超类中的方法。<br>    @Deprecated，表示当前方法即将废弃，不推荐使用。<br>    @SuppressWarnings，表示忽略编译器的警告信息。</p>\n</blockquote>\n<p>对于上面几个注解想必大家都不会陌生。除此之外，我们还经常在一些第三方框架中看到一些自定义注解。比如大名鼎鼎的ButterKnife和EventBus都是基于注解实现的。网上关于注解的文章数不胜数，但是，很多章都是贴下注解的定义，然后解释下几种元注解，扔出一个自定义注解的例子就不了了之了。刚接触注解的时候，看了半天注解相关的文章也没弄懂注解到底有什么用。其实注解往往是需要结合反射来用的，离了反射，注解也就失去了灵魂。因此，本篇文章我们会先来学习一些注解相关的一些基础知识，然后结合反射来实现一个与ButterKnife一样功能的实例。当然ButterKnife的实现并非是用反射而是使用注解处理器（AnnotationProcessor）来实现的，但是，本篇文章重点是自定义注解，因此，我们就用注解结合反射来模仿ButterKnife的效果。</p>\n<h2 id=\"一、注解基础知识简介\"><a href=\"#一、注解基础知识简介\" class=\"headerlink\" title=\"一、注解基础知识简介\"></a>一、注解基础知识简介</h2><p><strong>1.注解(Annotation)的声明</strong></p>\n<p>同类(class)与接口(interface)一样，注解( @interface)也是一种定义类型，它是在JDK 5.0中引入的。我们可以通过@interface来声明一个注解：</p>\n<pre><code class=\"hljs angelscript\"><span class=\"hljs-keyword\">public</span> @<span class=\"hljs-keyword\">interface</span> <span class=\"hljs-symbol\">MAnnotation</span> &#123;\n&#125;</code></pre>\n<p><strong>2.注解的成员变量</strong><br>注解与类一样，都存在成员变量。与类的区别是注解中没有方法。因此，来看下如何在注解中声明成员变量。</p>\n<pre><code class=\"hljs angelscript\"><span class=\"hljs-keyword\">public</span> @<span class=\"hljs-keyword\">interface</span> <span class=\"hljs-symbol\">MAnnotation</span> &#123;\n    <span class=\"hljs-built_in\">string</span> name();\n    <span class=\"hljs-built_in\">int</span> age();\n&#125;</code></pre>\n<p>上述示例中我们在MAnnotation中声明了一个String类型的name和一个int类型的age的成员变量。除此之外，我们还可以为成员变量制定默认值：</p>\n<pre><code class=\"hljs routeros\">public @interface MAnnotation &#123;\n    string name()<span class=\"hljs-built_in\"> default </span><span class=\"hljs-string\">&quot;Jack&quot;</span>;\n    int age()<span class=\"hljs-built_in\"> default </span>18;\n&#125;</code></pre>\n<p>如果注解的成员变量被赋予了默认值，那么使用注解时可以不为成员变量赋值，而是用直接使用默认值。<br><strong>3.注解的分类</strong><br>根据注解是否包含成员变量，可以把Annotation分为如下两类：<br>*<strong>(1)标记注解***       标记注解指的时没有包含成员变量的注解，例如java内置的注解@Override注解。<br>*</strong>(2)元数据注解***   元数据注解指的是包含成员变量的注解，这类注解可以接受更多的元数据。例如，ButteerKnife的@BindView注解</p>\n<p><strong>4.元注解</strong><br>元注解可以理解为注解的注解。用来提供对给其他的注解类型类型做说明。JDK中提供了如下4个元注解：</p>\n<blockquote>\n<p>@Target<br>@Retention<br>@Documented<br>@Inherited</p>\n</blockquote>\n<p>针对以上四种注解，我们来分别解析</p>\n<p><strong><em>(1)@Target注解</em></strong><br>指定Annotation用于修饰哪些程序元素。@Target也包含一个名为”value“的成员变量，该value成员变量类型为ElementType[ ]，ElementType为枚举类型，值有如下几个：</p>\n<blockquote>\n<p>ElementType.TYPE：能修饰类、接口或枚举类型<br>ElementType.FIELD：能修饰成员变量<br>ElementType.METHOD：能修饰方法<br>ElementType.PARAMETER：能修饰参数<br>ElementType.CONSTRUCTOR：能修饰构造器<br>ElementType.LOCAL_VARIABLE：能修饰局部变量<br>ElementType.ANNOTATION_TYPE：能修饰注解<br>ElementType.PACKAGE：能修饰包</p>\n</blockquote>\n<p>举个栗子，用FIELD和METHOD来作为Target的value，那么MAnnotation 就只能用来修饰类的成员变量和方法</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-meta\">@Target(ElementType.FIELD,, ElementType.METHOD)</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-meta\">@interface</span> MAnnotation &#123;\n    <span class=\"hljs-function\">string <span class=\"hljs-title\">name</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">default</span> &quot;Jack&quot;</span>;\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">age</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">default</span> 18</span>;\n&#125;</code></pre>\n<p><strong>(2)@Retention</strong><br>这个注解定义了该注解可以保留多长时间。某些注解仅出现在源代码中，而被编译器丢弃；而另一些却被编译在class文件中；编译在class文件中的Annotation可能会被虚拟机忽略，而另一些在class被装载时将被读取（请注意并不影响class的执行，因为Annotation与class在使用上是被分离的）。使用这个meta-Annotation可以对 Annotation的“生命周期”限制。<br>@Retention同样包含一个名为“value”的成员变量，该value成员变量是RetentionPolicy枚举类型。使用@Retention时，必须为其value指定值。value成员变量的值只能是如下3个：</p>\n<blockquote>\n<p>RetentionPolicy.SOURCE：Annotation只保留在源代码中，编译器编译时，直接丢弃这种Annotation。<br>RetentionPolicy.CLASS：编译器把Annotation记录在class文件中。当运行Java程序时，JVM中不再保留该Annotation。<br>RetentionPolicy.RUNTIME：编译器把Annotation记录在class文件中。当运行Java程序时，JVM会保留该Annotation，程序可以通过反射获取该Annotation的信息。</p>\n</blockquote>\n<p>@Retention举个栗子：</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-meta\">@Target(RetentionPolicy.RUNTIME)</span>\n<span class=\"hljs-meta\">@Target(ElementType.FIELD)</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-meta\">@interface</span> MAnnotation &#123;\n    <span class=\"hljs-function\">string <span class=\"hljs-title\">name</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">default</span> &quot;Jack&quot;</span>;\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">age</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">default</span> 18</span>;\n&#125;</code></pre>\n<p><strong>(3)@Documented</strong><br>@Documented是一个标记注解，如果定义注解MAnnotation ，使用了@Documented修饰定义，则在用javadoc命令生成API文档后，所有使用注解MAnnotation 修饰的程序元素，将会包含注解MAnnotation 的说明。举了这么久的栗子，也挺累，这个就不举了吧。。。<br>**(4)@Inherited**<br>@Inherited是一个标记注解，指定注解具有继承性。要注意的是它并不是说注解本身可以继承，而是说如果一个父类被 @Inherited 注解过的注解进行注解的话，那么如果它的子类没有被任何注解应用的话，那么这个子类就继承了父类的注解。这次我们还是需要举个栗子的：</p>\n<pre><code class=\"hljs scala\"><span class=\"hljs-type\">Inherited</span>\n<span class=\"hljs-meta\">@Retention</span>(<span class=\"hljs-type\">RetentionPolicy</span>.<span class=\"hljs-type\">RUNTIME</span>)\n<span class=\"hljs-meta\">@interface</span> <span class=\"hljs-type\">MAnnotation</span> &#123;&#125;\n\n\n<span class=\"hljs-meta\">@MAnnotation</span> \npublic <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ClassA</span></span>&#123;&#125;\n\n\npublic <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ClassB</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">ClassA</span> </span>&#123;&#125;</code></pre>\n<p>注解 @MAnnotation 被 @Inherited 修饰，ClassA 被 MAnnotation 注解，ClassB 继承 ClassA，那么此时ClassB也拥有@MAnnotation 注解。</p>\n<h2 id=\"二、使用注解与反射实现ButterKnife的功能\"><a href=\"#二、使用注解与反射实现ButterKnife的功能\" class=\"headerlink\" title=\"二、使用注解与反射实现ButterKnife的功能\"></a>二、使用注解与反射实现ButterKnife的功能</h2><p>说了这么久，关于注解的相关基础知识终于讲完了。但是，即使看到这里不知道小伙伴是否仍然会迷茫，注解到底有什么用？在文章开头我们就提到离开反射的注解是没有灵魂的，因此，正是因为反射才赋予了注解实质的用途。那么接下来，我们用注解和反射来模仿并实现ButterKnife的功能吧。<br>首先，来分析一下要实现的功能。</p>\n<blockquote>\n<p>使用注解注入布局文件省去setContentView<br>使用注解省去findViewById<br>使用注解省去setOnClickListener</p>\n</blockquote>\n<p><strong>1.根据上述需求，我们可以定义三个注解。</strong>如下:</p>\n<pre><code class=\"hljs less\"><span class=\"hljs-comment\">//\t给Activity注入布局文件的注解</span>\n<span class=\"hljs-variable\">@Target</span>(ElementType.TYPE)\n<span class=\"hljs-variable\">@Retention</span>(RetentionPolicy.RUNTIME)\npublic <span class=\"hljs-variable\">@interface</span> InjectLayout &#123;\n    <span class=\"hljs-selector-tag\">int</span> <span class=\"hljs-selector-tag\">value</span>() <span class=\"hljs-selector-tag\">default</span> <span class=\"hljs-selector-tag\">-1</span>;\n&#125;\n\n<span class=\"hljs-comment\">//\t查找控件ID的注解</span>\n@<span class=\"hljs-selector-tag\">Retention</span>(RetentionPolicy.SOURCE)\n@<span class=\"hljs-selector-tag\">Target</span>(&#123;<span class=\"hljs-selector-tag\">ElementType</span><span class=\"hljs-selector-class\">.FIELD</span>&#125;)\n<span class=\"hljs-selector-tag\">public</span> @<span class=\"hljs-selector-tag\">interface</span> <span class=\"hljs-selector-tag\">BindView</span> &#123;\n    <span class=\"hljs-selector-tag\">int</span> <span class=\"hljs-selector-tag\">value</span>() <span class=\"hljs-selector-tag\">default</span> <span class=\"hljs-selector-tag\">-1</span>;\n&#125;\n\n<span class=\"hljs-comment\">//\t给View设置监听事件的注解</span>\n@<span class=\"hljs-selector-tag\">Target</span>(ElementType.METHOD)\n@<span class=\"hljs-selector-tag\">Retention</span>(RetentionPolicy.RUNTIME)\n<span class=\"hljs-selector-tag\">public</span> @<span class=\"hljs-selector-tag\">interface</span> <span class=\"hljs-selector-tag\">OnClick</span> &#123;\n    <span class=\"hljs-selector-tag\">int</span><span class=\"hljs-selector-attr\">[]</span> <span class=\"hljs-selector-tag\">value</span>();\n&#125;\n</code></pre>\n<p><strong>2.声明BindProcessor类通过反射处理以上注解</strong></p>\n<pre><code class=\"hljs reasonml\">\t<span class=\"hljs-comment\">//  处理@InjectLayout </span>\n\t<span class=\"hljs-keyword\">private</span> static void inject<span class=\"hljs-constructor\">Layout(Activity <span class=\"hljs-params\">activity</span>)</span> &#123;\n        Class&lt;?&gt; activityClass = activity.get<span class=\"hljs-constructor\">Class()</span>;\n        <span class=\"hljs-keyword\">if</span> (activityClass.is<span class=\"hljs-constructor\">AnnotationPresent(InjectLayout.<span class=\"hljs-params\">class</span>)</span>) &#123;\n            InjectLayout mId = activityClass.get<span class=\"hljs-constructor\">Annotation(InjectLayout.<span class=\"hljs-params\">class</span>)</span>;\n            <span class=\"hljs-built_in\">int</span> id = mId.value<span class=\"hljs-literal\">()</span>;\n            <span class=\"hljs-keyword\">try</span> &#123;\n                Method <span class=\"hljs-keyword\">method</span> = activityClass.get<span class=\"hljs-constructor\">Method(<span class=\"hljs-string\">&quot;setContentView&quot;</span>, <span class=\"hljs-params\">int</span>.<span class=\"hljs-params\">class</span>)</span>;\n                <span class=\"hljs-keyword\">method</span>.set<span class=\"hljs-constructor\">Accessible(<span class=\"hljs-params\">true</span>)</span>;\n                <span class=\"hljs-keyword\">method</span>.invoke(activity, id);\n            &#125; catch (NoSuchMethodException <span class=\"hljs-pattern-match\">| <span class=\"hljs-constructor\">IllegalAccessException</span> | <span class=\"hljs-constructor\">InvocationTargetException</span> e) &#123;</span>\n<span class=\"hljs-pattern-match\">                e.print<span class=\"hljs-constructor\">StackTrace()</span>;</span>\n<span class=\"hljs-pattern-match\">            &#125;</span>\n<span class=\"hljs-pattern-match\">        &#125;</span>\n<span class=\"hljs-pattern-match\">    &#125;</span>\n<span class=\"hljs-pattern-match\"></span>\n<span class=\"hljs-pattern-match\">\t<span class=\"hljs-operator\">/</span><span class=\"hljs-operator\">/</span>  处理@<span class=\"hljs-constructor\">BindView</span></span>\n<span class=\"hljs-pattern-match\">    <span class=\"hljs-keyword\">private</span> static void bind<span class=\"hljs-constructor\">View(Activity <span class=\"hljs-params\">activity</span>)</span> &#123;</span>\n<span class=\"hljs-pattern-match\">        <span class=\"hljs-constructor\">Class</span>&lt;?&gt; activity<span class=\"hljs-constructor\">Class</span> = activity.get<span class=\"hljs-constructor\">Class()</span>;</span>\n<span class=\"hljs-pattern-match\">        <span class=\"hljs-constructor\">Field</span>[] declared<span class=\"hljs-constructor\">Fields</span> = activity<span class=\"hljs-constructor\">Class</span>.get<span class=\"hljs-constructor\">DeclaredFields()</span>;</span>\n<span class=\"hljs-pattern-match\">        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-constructor\">Field</span> field : declared<span class=\"hljs-constructor\">Fields</span>) &#123;</span>\n<span class=\"hljs-pattern-match\">            <span class=\"hljs-keyword\">if</span> (field.is<span class=\"hljs-constructor\">AnnotationPresent(BindView.<span class=\"hljs-params\">class</span>)</span>) &#123;</span>\n<span class=\"hljs-pattern-match\">                <span class=\"hljs-constructor\">BindView</span> m<span class=\"hljs-constructor\">Id</span> = field.get<span class=\"hljs-constructor\">Annotation(BindView.<span class=\"hljs-params\">class</span>)</span>;</span>\n<span class=\"hljs-pattern-match\">                <span class=\"hljs-built_in\">int</span> id = m<span class=\"hljs-constructor\">Id</span>.value();</span>\n<span class=\"hljs-pattern-match\">                <span class=\"hljs-keyword\">try</span> &#123;</span>\n<span class=\"hljs-pattern-match\">                    <span class=\"hljs-constructor\">Method</span> <span class=\"hljs-keyword\">method</span> = activity<span class=\"hljs-constructor\">Class</span>.get<span class=\"hljs-constructor\">Method(<span class=\"hljs-string\">&quot;findViewById&quot;</span>, <span class=\"hljs-params\">int</span>.<span class=\"hljs-params\">class</span>)</span>;</span>\n<span class=\"hljs-pattern-match\">                    <span class=\"hljs-keyword\">method</span>.set<span class=\"hljs-constructor\">Accessible(<span class=\"hljs-params\">true</span>)</span>;</span>\n<span class=\"hljs-pattern-match\">                    <span class=\"hljs-constructor\">Object</span> view = <span class=\"hljs-keyword\">method</span>.invoke(activity, id);</span>\n<span class=\"hljs-pattern-match\">                    field.set<span class=\"hljs-constructor\">Accessible(<span class=\"hljs-params\">true</span>)</span>;</span>\n<span class=\"hljs-pattern-match\">                    field.set(activity, view);</span>\n<span class=\"hljs-pattern-match\">                &#125; catch (<span class=\"hljs-constructor\">NoSuchMethodException</span> e) &#123;</span>\n<span class=\"hljs-pattern-match\">                    e.print<span class=\"hljs-constructor\">StackTrace()</span>;</span>\n<span class=\"hljs-pattern-match\">                &#125; catch (<span class=\"hljs-constructor\">IllegalAccessException</span> e) &#123;</span>\n<span class=\"hljs-pattern-match\">                    e.print<span class=\"hljs-constructor\">StackTrace()</span>;</span>\n<span class=\"hljs-pattern-match\">                &#125; catch (<span class=\"hljs-constructor\">InvocationTargetException</span> e) &#123;</span>\n<span class=\"hljs-pattern-match\">                    e.print<span class=\"hljs-constructor\">StackTrace()</span>;</span>\n<span class=\"hljs-pattern-match\">                &#125;</span>\n<span class=\"hljs-pattern-match\">            &#125;</span>\n<span class=\"hljs-pattern-match\">        &#125;</span>\n<span class=\"hljs-pattern-match\">    &#125;</span>\n<span class=\"hljs-pattern-match\">\t<span class=\"hljs-operator\">/</span><span class=\"hljs-operator\">/</span>  处理@<span class=\"hljs-constructor\">OnClick</span></span>\n<span class=\"hljs-pattern-match\">    <span class=\"hljs-keyword\">private</span> static void bind<span class=\"hljs-constructor\">OnClick(<span class=\"hljs-params\">final</span> Activity <span class=\"hljs-params\">activity</span>)</span> &#123;</span>\n<span class=\"hljs-pattern-match\">        <span class=\"hljs-constructor\">Class</span>&lt;?&gt; cls = activity.get<span class=\"hljs-constructor\">Class()</span>;</span>\n<span class=\"hljs-pattern-match\">        <span class=\"hljs-constructor\">Method</span>[] methods = cls.get<span class=\"hljs-constructor\">Methods()</span>;</span>\n<span class=\"hljs-pattern-match\">        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-built_in\">int</span> i = 0; i &lt; methods.length; i<span class=\"hljs-operator\">++</span>) &#123;</span>\n<span class=\"hljs-pattern-match\">            final <span class=\"hljs-constructor\">Method</span> <span class=\"hljs-keyword\">method</span> = methods[i];</span>\n<span class=\"hljs-pattern-match\">            <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">method</span>.is<span class=\"hljs-constructor\">AnnotationPresent(OnClick.<span class=\"hljs-params\">class</span>)</span>) &#123;</span>\n<span class=\"hljs-pattern-match\">                <span class=\"hljs-constructor\">OnClick</span> m<span class=\"hljs-constructor\">Onclick</span> = <span class=\"hljs-keyword\">method</span>.get<span class=\"hljs-constructor\">Annotation(OnClick.<span class=\"hljs-params\">class</span>)</span>;</span>\n<span class=\"hljs-pattern-match\">                <span class=\"hljs-built_in\">int</span>[] ids = m<span class=\"hljs-constructor\">Onclick</span>.value();</span>\n<span class=\"hljs-pattern-match\">                <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-built_in\">int</span> j = 0; j &lt; ids.length; j<span class=\"hljs-operator\">++</span>) &#123;</span>\n<span class=\"hljs-pattern-match\">                    final <span class=\"hljs-constructor\">View</span> view = activity.find<span class=\"hljs-constructor\">ViewById(<span class=\"hljs-params\">ids</span>[<span class=\"hljs-params\">j</span>])</span>;</span>\n<span class=\"hljs-pattern-match\">                    <span class=\"hljs-keyword\">if</span>(view<span class=\"hljs-operator\">==</span>null) continue;</span>\n<span class=\"hljs-pattern-match\">                    view.set<span class=\"hljs-constructor\">OnClickListener(<span class=\"hljs-params\">new</span> View.OnClickListener()</span> &#123;</span>\n<span class=\"hljs-pattern-match\">                        @<span class=\"hljs-constructor\">Override</span></span>\n<span class=\"hljs-pattern-match\">                        public void on<span class=\"hljs-constructor\">Click(View <span class=\"hljs-params\">v</span>)</span> &#123;</span>\n<span class=\"hljs-pattern-match\">                            <span class=\"hljs-keyword\">try</span> &#123;</span>\n<span class=\"hljs-pattern-match\">                                <span class=\"hljs-keyword\">method</span>.set<span class=\"hljs-constructor\">Accessible(<span class=\"hljs-params\">true</span>)</span>;</span>\n<span class=\"hljs-pattern-match\">                                <span class=\"hljs-keyword\">method</span>.invoke(activity, view);</span>\n<span class=\"hljs-pattern-match\">                            &#125; catch (<span class=\"hljs-constructor\">IllegalAccessException</span> e) &#123;</span>\n<span class=\"hljs-pattern-match\">                                e.print<span class=\"hljs-constructor\">StackTrace()</span>;</span>\n<span class=\"hljs-pattern-match\">                            &#125; catch (<span class=\"hljs-constructor\">InvocationTargetException</span> e) &#123;</span>\n<span class=\"hljs-pattern-match\">                                e.print<span class=\"hljs-constructor\">StackTrace()</span>;</span>\n<span class=\"hljs-pattern-match\">                            &#125;</span>\n<span class=\"hljs-pattern-match\">                        &#125;</span>\n<span class=\"hljs-pattern-match\">                    &#125;);</span>\n<span class=\"hljs-pattern-match\">                &#125;</span>\n<span class=\"hljs-pattern-match\">            &#125;</span>\n<span class=\"hljs-pattern-match\">        &#125;</span>\n<span class=\"hljs-pattern-match\">    &#125;</span>\n<span class=\"hljs-pattern-match\"></span>\n<span class=\"hljs-pattern-match\"></span>\n<span class=\"hljs-pattern-match\"><span class=\"hljs-operator\">/</span><span class=\"hljs-operator\">/</span>\tbind方法对外开放</span>\n<span class=\"hljs-pattern-match\">public static void bind(<span class=\"hljs-constructor\">Activity</span> activity) &#123;</span>\n<span class=\"hljs-pattern-match\">        inject<span class=\"hljs-constructor\">Layout(<span class=\"hljs-params\">activity</span>)</span>;</span>\n<span class=\"hljs-pattern-match\">        bind<span class=\"hljs-constructor\">View(<span class=\"hljs-params\">activity</span>)</span>;</span>\n<span class=\"hljs-pattern-match\">        bind<span class=\"hljs-constructor\">OnClick(<span class=\"hljs-params\">activity</span>)</span>;</span>\n<span class=\"hljs-pattern-match\">    &#125;</span></code></pre>\n<p>以上代码并没有什么难度，只要是了解一点反射知识的相信都能看懂。那么我们只要在Activity中调用bind方法后便可以使用注解了。下面来看Activity中的代码：</p>\n<pre><code class=\"hljs reasonml\">@<span class=\"hljs-constructor\">InjectLayout(R.<span class=\"hljs-params\">layout</span>.<span class=\"hljs-params\">activity_main</span>)</span>\npublic <span class=\"hljs-keyword\">class</span> MainActivity extends AppCompatActivity &#123;\n    @<span class=\"hljs-constructor\">BindView(R.<span class=\"hljs-params\">id</span>.<span class=\"hljs-params\">tv_test</span>)</span>\n    <span class=\"hljs-keyword\">private</span> Button mButton;\n\n    @Override\n    protected void on<span class=\"hljs-constructor\">Create(Bundle <span class=\"hljs-params\">savedInstanceState</span>)</span> &#123;\n        super.on<span class=\"hljs-constructor\">Create(<span class=\"hljs-params\">savedInstanceState</span>)</span>;\n<span class=\"hljs-comment\">//        setContentView(R.layout.activity_main);</span>\n        <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">BindProcessor</span>.</span></span>bind(this);\n        mButton.set<span class=\"hljs-constructor\">Text(<span class=\"hljs-string\">&quot;通过注解设置的Text&quot;</span>)</span>;\n    &#125;\n\n    @<span class=\"hljs-constructor\">OnClick(&#123;R.<span class=\"hljs-params\">id</span>.<span class=\"hljs-params\">tv_test</span>, R.<span class=\"hljs-params\">id</span>.<span class=\"hljs-params\">btn_reflect</span>&#125;)</span>\n    public void on<span class=\"hljs-constructor\">Click(View <span class=\"hljs-params\">view</span>)</span> &#123;\n        switch (view.get<span class=\"hljs-constructor\">Id()</span>) &#123;\n            case <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">R</span>.</span></span>id.tv_test:\n                <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">Toast</span>.</span></span>make<span class=\"hljs-constructor\">Text(<span class=\"hljs-params\">this</span>, <span class=\"hljs-string\">&quot;通过注解点解了Text&quot;</span>, Toast.LENGTH_SHORT)</span>.show<span class=\"hljs-literal\">()</span>;\n                break;\n            case <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">R</span>.</span></span>id.btn_reflect:\n                test<span class=\"hljs-constructor\">Reflect()</span>;\n                break;\n        &#125;\n    &#125;\n&#125;</code></pre>\n<p>可以看到，我们并没有在onCreate方法中调用setContentView方法，也没有去为Button按钮findViewById，更没有为其设置监听事件，我们统统都是用上面自定义的注解实现的。那么效果如何呢？我们来看下运行及起来的效果：<br><img src=\"https://raw.githubusercontent.com/zhpanvip/Resource/master/image/1501.gif\"></p>\n<p>效果貌似还不错，实现了与ButterKnife的部分功能，甚至我们还比ButterKnife多了一个注入布局的功能。但是，我们要知道的是ButterKnife并非是直接用反射实现的，因为反射是在运行时处理的，会影响到程序的效率。但对于神一般存在的Jake，怎么会做如此没有效率的事情。关于ButterKnife是如何实现注解，我们在下篇文章中在做探讨。</p>\n<p><a href=\"https://github.com/zhpanvip/MAnnotation/blob/master/app/src/main/java/com/zhpan/mannotation/BindProcessor.java\">源码参考</a></p>\n","site":{"data":{"fluid_config":{"favicon":"/img/favicon.png","apple_touch_icon":"/img/favicon.png","title_join_string":" - ","force_https":false,"highlight":{"enable":true,"style":"Github Gist","bg_color":false,"copy_btn":true},"fun_features":{"typing":{"enable":true,"typeSpeed":70,"cursorChar":"|","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"mouse_click":{"enable":false,"style":"values"}},"dark_mode":{"enable":true,"default":"auto"},"color":{"body_bg_color":"#eee","body_bg_color_dark":"#181c27","navbar_bg_color":"#2f4154","navbar_bg_color_dark":"#1f3144","navbar_text_color":"#fff","navbar_text_color_dark":"#d0d0d0","text_color":"#3c4858","text_color_dark":"#c4c6c9","sec_text_color":"#718096","sec_text_color_dark":"#a7a9ad","post_text_color":"#2c3e50","post_text_color_dark":"#c4c6c9","post_heading_color":"#1a202c","post_heading_color_dark":"#c4c6c9","post_link_color":"#0366d6","post_link_color_dark":"#1589e9","link_hover_color":"#30a9de","link_hover_color_dark":"#30a9de","link_hover_bg_color":"#f8f9fa","link_hover_bg_color_dark":"#364151","board_color":"#fff","board_color_dark":"#252d38"},"font":{"font_size":"16px","font_family":null,"code_font_size":"85%"},"custom_js":null,"custom_css":null,"custom_html":"","web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"tajs":null,"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}},"lazyload":{"enable":true,"onlypost":false},"daovoice":{"enable":false,"appid":""},"aplayer":{"enable":false,"autoplay":false,"loop":"all","order":"random","theme":"#b7daff","songs":[{"name":"name","artist":"artist","url":"/songs/test.mp3","cover":"/img/cover.jpg"},{"name":"name","artist":"artist","url":"https://...url.mp3","cover":"https://...cover.jpg"}]},"version":{"check":false},"navbar":{"blog_title":"zhangpan","ground_glass":{"enable":false,"px":3,"alpha":0.7},"menu":[{"key":"home","link":"/","icon":"iconfont icon-home-fill"},{"key":"archive","link":"/archives/","icon":"iconfont icon-archive-fill"},{"key":"category","link":"/categories/","icon":"iconfont icon-category-fill"},{"key":"tag","link":"/tags/","icon":"iconfont icon-tags-fill"},{"key":"about","link":"/about/","icon":"iconfont icon-user-fill"}]},"search":{"enable":true,"path":"/local-search.xml","generate_path":"/local-search.xml","field":"post","content":true},"scroll_down_arrow":{"enable":true,"banner_height_limit":90,"scroll_after_turning_page":true},"banner_parallax":true,"footer":{"statistics":{"enable":false,"source":"busuanzi","pv_format":"总访问量 {} 次","uv_format":"总访客数 {} 人"},"beian":{"enable":false,"icp_text":"京ICP证123456号","police_text":"京公网安备12345678号","police_code":12345678,"police_icon":"/img/police_beian.png"}},"scroll_top_arrow":{"enable":true},"index":{"banner_img":"/img/default.png","banner_img_height":100,"banner_mask_alpha":0.3,"post_default_img":"","slogan":{"enable":true,"text":"Talk is cheap, show me the code."},"auto_excerpt":{"enable":true},"post_url_target":"_self","post_meta":{"date":true,"category":true,"tag":true}},"page":{"banner_img":"/img/default.png","banner_img_height":60,"banner_mask_alpha":0.3},"post":{"banner_img":"/img/default.png","banner_img_height":70,"banner_mask_alpha":0.3,"meta":{"date":{"enable":true,"format":"LL a"},"wordcount":{"enable":true,"format":"{} 字"},"min2read":{"enable":true,"format":"{} 分钟","words":100},"views":{"enable":false,"source":"busuanzi","format":"{} 次"}},"updated":{"enable":false,"content":"本文最后更新于：","relative":false},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"copyright":{"enable":true,"content":"本博客所有文章除特别声明外，均采用 <a href=\"https://creativecommons.org/licenses/by-sa/4.0/deed.zh\" rel=\"nofollow noopener\">CC BY-SA 4.0 协议</a> ，转载请注明出处！ <h5>开源库推荐</h5> <a href=\"https://github.com/zhpanvip/BannerViewPager\">1.BannerViewPager</a> <p> 一个基于ViewPager2实现的具有强大功能的无限轮播库。支持多种页面切换效果和指示器样式。 </p>\n<a href=\"https://github.com/zhpanvip/viewpagerindicator\">2.ViewPagerIndicator</a> <p> 一个适用于ViewPager和ViewPager2的指示器，支持多种滑块样式及滑动模式 </p>"},"prev_next":{"enable":true},"custom":{"enable":false,"content":"<img src=\"https://octodex.github.com/images/jetpacktocat.png\" class=\"rounded mx-auto d-block mt-5\" style=\"width:150px; height:150px;\">"},"image_zoom":{"enable":true},"footnote":{"enable":true,"header":""},"math":{"enable":false,"specific":false,"engine":"mathjax"},"mermaid":{"enable":false,"specific":false,"options":{"theme":"default"}},"comments":{"enable":true,"type":"utterances"}},"utterances":{"repo":"zhpanvip/utterances-comment","issue_term":"pathname","label":"utterances","theme":"github-light","crossorigin":"anonymous"},"disqus":{"shortname":null,"disqusjs":false,"apikey":null},"gitalk":{"clientID":null,"clientSecret":null,"repo":null,"owner":null,"admin":["name"],"id":"location.pathname","language":"zh-CN","labels":["Gitalk"],"perPage":10,"pagerDirection":"last","distractionFreeMode":false,"createIssueManually":true},"valine":{"appid":"hXIROaIM5y9qnieojJRWP5hS","appkey":"y0f3w3aqd1MF7JL9ma4WECTy","placeholder":"说点什么","path":"window.location.pathname","avatar":"retro","meta":["nick","mail","link"],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"https://zhangpan.site"},"changyan":{"appid":"","appkey":""},"livere":{"uid":""},"archive":{"banner_img":"/img/bg_article.jpg","banner_img_height":60,"banner_mask_alpha":0.3,"subtitle":null},"category":{"banner_img":"/img/bg_default.png","banner_img_height":60,"banner_mask_alpha":0.3,"subtitle":null,"post_limit":10,"order_by":"-length"},"tag":{"banner_img":"/img/bg_label.jpg","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null,"tagcloud":{"min_font":15,"max_font":30,"unit":"px","start_color":"#BBBBEE","end_color":"#337ab7"}},"about":{"banner_img":"/img/bg_default.png","banner_img_height":60,"banner_mask_alpha":0.3,"subtitle":null,"avatar":"/img/avatar.png","name":"myname","introduce":"一句简短的介绍","icons":[{"class":"iconfont icon-github-fill","link":"https://github.com","tip":"GitHub"},{"class":"iconfont icon-douban-fill","link":"https://douban.com","tip":"豆瓣"},{"class":"iconfont icon-wechat-fill","qrcode":"/img/favicon.png"}]},"page404":{"banner_img":"/img/default.png","banner_img_height":85,"banner_mask_alpha":0.3,"subtitle":"Page not found"},"links":{"banner_img":"/img/default.png","banner_img_height":60,"banner_mask_alpha":0.3,"subtitle":null,"items":[{"title":"Fluid Docs","intro":"主题使用指南","link":"https://hexo.fluid-dev.com/docs/","image":"/img/favicon.png"},{"title":"Fluid Repo","intro":"主题 GitHub 仓库","link":"https://github.com/fluid-dev/hexo-theme-fluid","image":"/img/favicon.png"},{"title":"Fluid Example","intro":"主题操作示例","link":"https://hexo.fluid-dev.com/docs/example/","image":"/img/favicon.png"}]}}}},"excerpt":"","more":"<p>Java注解在我们项目开发 中是非常常见的。比如经常用到的几种java内置的注解：</p>\n<blockquote>\n<p> @Override，表示当前的方法定义将覆盖超类中的方法。<br>    @Deprecated，表示当前方法即将废弃，不推荐使用。<br>    @SuppressWarnings，表示忽略编译器的警告信息。</p>\n</blockquote>\n<p>对于上面几个注解想必大家都不会陌生。除此之外，我们还经常在一些第三方框架中看到一些自定义注解。比如大名鼎鼎的ButterKnife和EventBus都是基于注解实现的。网上关于注解的文章数不胜数，但是，很多章都是贴下注解的定义，然后解释下几种元注解，扔出一个自定义注解的例子就不了了之了。刚接触注解的时候，看了半天注解相关的文章也没弄懂注解到底有什么用。其实注解往往是需要结合反射来用的，离了反射，注解也就失去了灵魂。因此，本篇文章我们会先来学习一些注解相关的一些基础知识，然后结合反射来实现一个与ButterKnife一样功能的实例。当然ButterKnife的实现并非是用反射而是使用注解处理器（AnnotationProcessor）来实现的，但是，本篇文章重点是自定义注解，因此，我们就用注解结合反射来模仿ButterKnife的效果。</p>\n<h2 id=\"一、注解基础知识简介\"><a href=\"#一、注解基础知识简介\" class=\"headerlink\" title=\"一、注解基础知识简介\"></a>一、注解基础知识简介</h2><p><strong>1.注解(Annotation)的声明</strong></p>\n<p>同类(class)与接口(interface)一样，注解( @interface)也是一种定义类型，它是在JDK 5.0中引入的。我们可以通过@interface来声明一个注解：</p>\n<pre><code class=\"hljs angelscript\"><span class=\"hljs-keyword\">public</span> @<span class=\"hljs-keyword\">interface</span> <span class=\"hljs-symbol\">MAnnotation</span> &#123;\n&#125;</code></pre>\n<p><strong>2.注解的成员变量</strong><br>注解与类一样，都存在成员变量。与类的区别是注解中没有方法。因此，来看下如何在注解中声明成员变量。</p>\n<pre><code class=\"hljs angelscript\"><span class=\"hljs-keyword\">public</span> @<span class=\"hljs-keyword\">interface</span> <span class=\"hljs-symbol\">MAnnotation</span> &#123;\n    <span class=\"hljs-built_in\">string</span> name();\n    <span class=\"hljs-built_in\">int</span> age();\n&#125;</code></pre>\n<p>上述示例中我们在MAnnotation中声明了一个String类型的name和一个int类型的age的成员变量。除此之外，我们还可以为成员变量制定默认值：</p>\n<pre><code class=\"hljs routeros\">public @interface MAnnotation &#123;\n    string name()<span class=\"hljs-built_in\"> default </span><span class=\"hljs-string\">&quot;Jack&quot;</span>;\n    int age()<span class=\"hljs-built_in\"> default </span>18;\n&#125;</code></pre>\n<p>如果注解的成员变量被赋予了默认值，那么使用注解时可以不为成员变量赋值，而是用直接使用默认值。<br><strong>3.注解的分类</strong><br>根据注解是否包含成员变量，可以把Annotation分为如下两类：<br>*<strong>(1)标记注解***       标记注解指的时没有包含成员变量的注解，例如java内置的注解@Override注解。<br>*</strong>(2)元数据注解***   元数据注解指的是包含成员变量的注解，这类注解可以接受更多的元数据。例如，ButteerKnife的@BindView注解</p>\n<p><strong>4.元注解</strong><br>元注解可以理解为注解的注解。用来提供对给其他的注解类型类型做说明。JDK中提供了如下4个元注解：</p>\n<blockquote>\n<p>@Target<br>@Retention<br>@Documented<br>@Inherited</p>\n</blockquote>\n<p>针对以上四种注解，我们来分别解析</p>\n<p><strong><em>(1)@Target注解</em></strong><br>指定Annotation用于修饰哪些程序元素。@Target也包含一个名为”value“的成员变量，该value成员变量类型为ElementType[ ]，ElementType为枚举类型，值有如下几个：</p>\n<blockquote>\n<p>ElementType.TYPE：能修饰类、接口或枚举类型<br>ElementType.FIELD：能修饰成员变量<br>ElementType.METHOD：能修饰方法<br>ElementType.PARAMETER：能修饰参数<br>ElementType.CONSTRUCTOR：能修饰构造器<br>ElementType.LOCAL_VARIABLE：能修饰局部变量<br>ElementType.ANNOTATION_TYPE：能修饰注解<br>ElementType.PACKAGE：能修饰包</p>\n</blockquote>\n<p>举个栗子，用FIELD和METHOD来作为Target的value，那么MAnnotation 就只能用来修饰类的成员变量和方法</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-meta\">@Target(ElementType.FIELD,, ElementType.METHOD)</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-meta\">@interface</span> MAnnotation &#123;\n    <span class=\"hljs-function\">string <span class=\"hljs-title\">name</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">default</span> &quot;Jack&quot;</span>;\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">age</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">default</span> 18</span>;\n&#125;</code></pre>\n<p><strong>(2)@Retention</strong><br>这个注解定义了该注解可以保留多长时间。某些注解仅出现在源代码中，而被编译器丢弃；而另一些却被编译在class文件中；编译在class文件中的Annotation可能会被虚拟机忽略，而另一些在class被装载时将被读取（请注意并不影响class的执行，因为Annotation与class在使用上是被分离的）。使用这个meta-Annotation可以对 Annotation的“生命周期”限制。<br>@Retention同样包含一个名为“value”的成员变量，该value成员变量是RetentionPolicy枚举类型。使用@Retention时，必须为其value指定值。value成员变量的值只能是如下3个：</p>\n<blockquote>\n<p>RetentionPolicy.SOURCE：Annotation只保留在源代码中，编译器编译时，直接丢弃这种Annotation。<br>RetentionPolicy.CLASS：编译器把Annotation记录在class文件中。当运行Java程序时，JVM中不再保留该Annotation。<br>RetentionPolicy.RUNTIME：编译器把Annotation记录在class文件中。当运行Java程序时，JVM会保留该Annotation，程序可以通过反射获取该Annotation的信息。</p>\n</blockquote>\n<p>@Retention举个栗子：</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-meta\">@Target(RetentionPolicy.RUNTIME)</span>\n<span class=\"hljs-meta\">@Target(ElementType.FIELD)</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-meta\">@interface</span> MAnnotation &#123;\n    <span class=\"hljs-function\">string <span class=\"hljs-title\">name</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">default</span> &quot;Jack&quot;</span>;\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">age</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">default</span> 18</span>;\n&#125;</code></pre>\n<p><strong>(3)@Documented</strong><br>@Documented是一个标记注解，如果定义注解MAnnotation ，使用了@Documented修饰定义，则在用javadoc命令生成API文档后，所有使用注解MAnnotation 修饰的程序元素，将会包含注解MAnnotation 的说明。举了这么久的栗子，也挺累，这个就不举了吧。。。<br>**(4)@Inherited**<br>@Inherited是一个标记注解，指定注解具有继承性。要注意的是它并不是说注解本身可以继承，而是说如果一个父类被 @Inherited 注解过的注解进行注解的话，那么如果它的子类没有被任何注解应用的话，那么这个子类就继承了父类的注解。这次我们还是需要举个栗子的：</p>\n<pre><code class=\"hljs scala\"><span class=\"hljs-type\">Inherited</span>\n<span class=\"hljs-meta\">@Retention</span>(<span class=\"hljs-type\">RetentionPolicy</span>.<span class=\"hljs-type\">RUNTIME</span>)\n<span class=\"hljs-meta\">@interface</span> <span class=\"hljs-type\">MAnnotation</span> &#123;&#125;\n\n\n<span class=\"hljs-meta\">@MAnnotation</span> \npublic <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ClassA</span></span>&#123;&#125;\n\n\npublic <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ClassB</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">ClassA</span> </span>&#123;&#125;</code></pre>\n<p>注解 @MAnnotation 被 @Inherited 修饰，ClassA 被 MAnnotation 注解，ClassB 继承 ClassA，那么此时ClassB也拥有@MAnnotation 注解。</p>\n<h2 id=\"二、使用注解与反射实现ButterKnife的功能\"><a href=\"#二、使用注解与反射实现ButterKnife的功能\" class=\"headerlink\" title=\"二、使用注解与反射实现ButterKnife的功能\"></a>二、使用注解与反射实现ButterKnife的功能</h2><p>说了这么久，关于注解的相关基础知识终于讲完了。但是，即使看到这里不知道小伙伴是否仍然会迷茫，注解到底有什么用？在文章开头我们就提到离开反射的注解是没有灵魂的，因此，正是因为反射才赋予了注解实质的用途。那么接下来，我们用注解和反射来模仿并实现ButterKnife的功能吧。<br>首先，来分析一下要实现的功能。</p>\n<blockquote>\n<p>使用注解注入布局文件省去setContentView<br>使用注解省去findViewById<br>使用注解省去setOnClickListener</p>\n</blockquote>\n<p><strong>1.根据上述需求，我们可以定义三个注解。</strong>如下:</p>\n<pre><code class=\"hljs less\"><span class=\"hljs-comment\">//\t给Activity注入布局文件的注解</span>\n<span class=\"hljs-variable\">@Target</span>(ElementType.TYPE)\n<span class=\"hljs-variable\">@Retention</span>(RetentionPolicy.RUNTIME)\npublic <span class=\"hljs-variable\">@interface</span> InjectLayout &#123;\n    <span class=\"hljs-selector-tag\">int</span> <span class=\"hljs-selector-tag\">value</span>() <span class=\"hljs-selector-tag\">default</span> <span class=\"hljs-selector-tag\">-1</span>;\n&#125;\n\n<span class=\"hljs-comment\">//\t查找控件ID的注解</span>\n@<span class=\"hljs-selector-tag\">Retention</span>(RetentionPolicy.SOURCE)\n@<span class=\"hljs-selector-tag\">Target</span>(&#123;<span class=\"hljs-selector-tag\">ElementType</span><span class=\"hljs-selector-class\">.FIELD</span>&#125;)\n<span class=\"hljs-selector-tag\">public</span> @<span class=\"hljs-selector-tag\">interface</span> <span class=\"hljs-selector-tag\">BindView</span> &#123;\n    <span class=\"hljs-selector-tag\">int</span> <span class=\"hljs-selector-tag\">value</span>() <span class=\"hljs-selector-tag\">default</span> <span class=\"hljs-selector-tag\">-1</span>;\n&#125;\n\n<span class=\"hljs-comment\">//\t给View设置监听事件的注解</span>\n@<span class=\"hljs-selector-tag\">Target</span>(ElementType.METHOD)\n@<span class=\"hljs-selector-tag\">Retention</span>(RetentionPolicy.RUNTIME)\n<span class=\"hljs-selector-tag\">public</span> @<span class=\"hljs-selector-tag\">interface</span> <span class=\"hljs-selector-tag\">OnClick</span> &#123;\n    <span class=\"hljs-selector-tag\">int</span><span class=\"hljs-selector-attr\">[]</span> <span class=\"hljs-selector-tag\">value</span>();\n&#125;\n</code></pre>\n<p><strong>2.声明BindProcessor类通过反射处理以上注解</strong></p>\n<pre><code class=\"hljs reasonml\">\t<span class=\"hljs-comment\">//  处理@InjectLayout </span>\n\t<span class=\"hljs-keyword\">private</span> static void inject<span class=\"hljs-constructor\">Layout(Activity <span class=\"hljs-params\">activity</span>)</span> &#123;\n        Class&lt;?&gt; activityClass = activity.get<span class=\"hljs-constructor\">Class()</span>;\n        <span class=\"hljs-keyword\">if</span> (activityClass.is<span class=\"hljs-constructor\">AnnotationPresent(InjectLayout.<span class=\"hljs-params\">class</span>)</span>) &#123;\n            InjectLayout mId = activityClass.get<span class=\"hljs-constructor\">Annotation(InjectLayout.<span class=\"hljs-params\">class</span>)</span>;\n            <span class=\"hljs-built_in\">int</span> id = mId.value<span class=\"hljs-literal\">()</span>;\n            <span class=\"hljs-keyword\">try</span> &#123;\n                Method <span class=\"hljs-keyword\">method</span> = activityClass.get<span class=\"hljs-constructor\">Method(<span class=\"hljs-string\">&quot;setContentView&quot;</span>, <span class=\"hljs-params\">int</span>.<span class=\"hljs-params\">class</span>)</span>;\n                <span class=\"hljs-keyword\">method</span>.set<span class=\"hljs-constructor\">Accessible(<span class=\"hljs-params\">true</span>)</span>;\n                <span class=\"hljs-keyword\">method</span>.invoke(activity, id);\n            &#125; catch (NoSuchMethodException <span class=\"hljs-pattern-match\">| <span class=\"hljs-constructor\">IllegalAccessException</span> | <span class=\"hljs-constructor\">InvocationTargetException</span> e) &#123;</span>\n<span class=\"hljs-pattern-match\">                e.print<span class=\"hljs-constructor\">StackTrace()</span>;</span>\n<span class=\"hljs-pattern-match\">            &#125;</span>\n<span class=\"hljs-pattern-match\">        &#125;</span>\n<span class=\"hljs-pattern-match\">    &#125;</span>\n<span class=\"hljs-pattern-match\"></span>\n<span class=\"hljs-pattern-match\">\t<span class=\"hljs-operator\">/</span><span class=\"hljs-operator\">/</span>  处理@<span class=\"hljs-constructor\">BindView</span></span>\n<span class=\"hljs-pattern-match\">    <span class=\"hljs-keyword\">private</span> static void bind<span class=\"hljs-constructor\">View(Activity <span class=\"hljs-params\">activity</span>)</span> &#123;</span>\n<span class=\"hljs-pattern-match\">        <span class=\"hljs-constructor\">Class</span>&lt;?&gt; activity<span class=\"hljs-constructor\">Class</span> = activity.get<span class=\"hljs-constructor\">Class()</span>;</span>\n<span class=\"hljs-pattern-match\">        <span class=\"hljs-constructor\">Field</span>[] declared<span class=\"hljs-constructor\">Fields</span> = activity<span class=\"hljs-constructor\">Class</span>.get<span class=\"hljs-constructor\">DeclaredFields()</span>;</span>\n<span class=\"hljs-pattern-match\">        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-constructor\">Field</span> field : declared<span class=\"hljs-constructor\">Fields</span>) &#123;</span>\n<span class=\"hljs-pattern-match\">            <span class=\"hljs-keyword\">if</span> (field.is<span class=\"hljs-constructor\">AnnotationPresent(BindView.<span class=\"hljs-params\">class</span>)</span>) &#123;</span>\n<span class=\"hljs-pattern-match\">                <span class=\"hljs-constructor\">BindView</span> m<span class=\"hljs-constructor\">Id</span> = field.get<span class=\"hljs-constructor\">Annotation(BindView.<span class=\"hljs-params\">class</span>)</span>;</span>\n<span class=\"hljs-pattern-match\">                <span class=\"hljs-built_in\">int</span> id = m<span class=\"hljs-constructor\">Id</span>.value();</span>\n<span class=\"hljs-pattern-match\">                <span class=\"hljs-keyword\">try</span> &#123;</span>\n<span class=\"hljs-pattern-match\">                    <span class=\"hljs-constructor\">Method</span> <span class=\"hljs-keyword\">method</span> = activity<span class=\"hljs-constructor\">Class</span>.get<span class=\"hljs-constructor\">Method(<span class=\"hljs-string\">&quot;findViewById&quot;</span>, <span class=\"hljs-params\">int</span>.<span class=\"hljs-params\">class</span>)</span>;</span>\n<span class=\"hljs-pattern-match\">                    <span class=\"hljs-keyword\">method</span>.set<span class=\"hljs-constructor\">Accessible(<span class=\"hljs-params\">true</span>)</span>;</span>\n<span class=\"hljs-pattern-match\">                    <span class=\"hljs-constructor\">Object</span> view = <span class=\"hljs-keyword\">method</span>.invoke(activity, id);</span>\n<span class=\"hljs-pattern-match\">                    field.set<span class=\"hljs-constructor\">Accessible(<span class=\"hljs-params\">true</span>)</span>;</span>\n<span class=\"hljs-pattern-match\">                    field.set(activity, view);</span>\n<span class=\"hljs-pattern-match\">                &#125; catch (<span class=\"hljs-constructor\">NoSuchMethodException</span> e) &#123;</span>\n<span class=\"hljs-pattern-match\">                    e.print<span class=\"hljs-constructor\">StackTrace()</span>;</span>\n<span class=\"hljs-pattern-match\">                &#125; catch (<span class=\"hljs-constructor\">IllegalAccessException</span> e) &#123;</span>\n<span class=\"hljs-pattern-match\">                    e.print<span class=\"hljs-constructor\">StackTrace()</span>;</span>\n<span class=\"hljs-pattern-match\">                &#125; catch (<span class=\"hljs-constructor\">InvocationTargetException</span> e) &#123;</span>\n<span class=\"hljs-pattern-match\">                    e.print<span class=\"hljs-constructor\">StackTrace()</span>;</span>\n<span class=\"hljs-pattern-match\">                &#125;</span>\n<span class=\"hljs-pattern-match\">            &#125;</span>\n<span class=\"hljs-pattern-match\">        &#125;</span>\n<span class=\"hljs-pattern-match\">    &#125;</span>\n<span class=\"hljs-pattern-match\">\t<span class=\"hljs-operator\">/</span><span class=\"hljs-operator\">/</span>  处理@<span class=\"hljs-constructor\">OnClick</span></span>\n<span class=\"hljs-pattern-match\">    <span class=\"hljs-keyword\">private</span> static void bind<span class=\"hljs-constructor\">OnClick(<span class=\"hljs-params\">final</span> Activity <span class=\"hljs-params\">activity</span>)</span> &#123;</span>\n<span class=\"hljs-pattern-match\">        <span class=\"hljs-constructor\">Class</span>&lt;?&gt; cls = activity.get<span class=\"hljs-constructor\">Class()</span>;</span>\n<span class=\"hljs-pattern-match\">        <span class=\"hljs-constructor\">Method</span>[] methods = cls.get<span class=\"hljs-constructor\">Methods()</span>;</span>\n<span class=\"hljs-pattern-match\">        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-built_in\">int</span> i = 0; i &lt; methods.length; i<span class=\"hljs-operator\">++</span>) &#123;</span>\n<span class=\"hljs-pattern-match\">            final <span class=\"hljs-constructor\">Method</span> <span class=\"hljs-keyword\">method</span> = methods[i];</span>\n<span class=\"hljs-pattern-match\">            <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">method</span>.is<span class=\"hljs-constructor\">AnnotationPresent(OnClick.<span class=\"hljs-params\">class</span>)</span>) &#123;</span>\n<span class=\"hljs-pattern-match\">                <span class=\"hljs-constructor\">OnClick</span> m<span class=\"hljs-constructor\">Onclick</span> = <span class=\"hljs-keyword\">method</span>.get<span class=\"hljs-constructor\">Annotation(OnClick.<span class=\"hljs-params\">class</span>)</span>;</span>\n<span class=\"hljs-pattern-match\">                <span class=\"hljs-built_in\">int</span>[] ids = m<span class=\"hljs-constructor\">Onclick</span>.value();</span>\n<span class=\"hljs-pattern-match\">                <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-built_in\">int</span> j = 0; j &lt; ids.length; j<span class=\"hljs-operator\">++</span>) &#123;</span>\n<span class=\"hljs-pattern-match\">                    final <span class=\"hljs-constructor\">View</span> view = activity.find<span class=\"hljs-constructor\">ViewById(<span class=\"hljs-params\">ids</span>[<span class=\"hljs-params\">j</span>])</span>;</span>\n<span class=\"hljs-pattern-match\">                    <span class=\"hljs-keyword\">if</span>(view<span class=\"hljs-operator\">==</span>null) continue;</span>\n<span class=\"hljs-pattern-match\">                    view.set<span class=\"hljs-constructor\">OnClickListener(<span class=\"hljs-params\">new</span> View.OnClickListener()</span> &#123;</span>\n<span class=\"hljs-pattern-match\">                        @<span class=\"hljs-constructor\">Override</span></span>\n<span class=\"hljs-pattern-match\">                        public void on<span class=\"hljs-constructor\">Click(View <span class=\"hljs-params\">v</span>)</span> &#123;</span>\n<span class=\"hljs-pattern-match\">                            <span class=\"hljs-keyword\">try</span> &#123;</span>\n<span class=\"hljs-pattern-match\">                                <span class=\"hljs-keyword\">method</span>.set<span class=\"hljs-constructor\">Accessible(<span class=\"hljs-params\">true</span>)</span>;</span>\n<span class=\"hljs-pattern-match\">                                <span class=\"hljs-keyword\">method</span>.invoke(activity, view);</span>\n<span class=\"hljs-pattern-match\">                            &#125; catch (<span class=\"hljs-constructor\">IllegalAccessException</span> e) &#123;</span>\n<span class=\"hljs-pattern-match\">                                e.print<span class=\"hljs-constructor\">StackTrace()</span>;</span>\n<span class=\"hljs-pattern-match\">                            &#125; catch (<span class=\"hljs-constructor\">InvocationTargetException</span> e) &#123;</span>\n<span class=\"hljs-pattern-match\">                                e.print<span class=\"hljs-constructor\">StackTrace()</span>;</span>\n<span class=\"hljs-pattern-match\">                            &#125;</span>\n<span class=\"hljs-pattern-match\">                        &#125;</span>\n<span class=\"hljs-pattern-match\">                    &#125;);</span>\n<span class=\"hljs-pattern-match\">                &#125;</span>\n<span class=\"hljs-pattern-match\">            &#125;</span>\n<span class=\"hljs-pattern-match\">        &#125;</span>\n<span class=\"hljs-pattern-match\">    &#125;</span>\n<span class=\"hljs-pattern-match\"></span>\n<span class=\"hljs-pattern-match\"></span>\n<span class=\"hljs-pattern-match\"><span class=\"hljs-operator\">/</span><span class=\"hljs-operator\">/</span>\tbind方法对外开放</span>\n<span class=\"hljs-pattern-match\">public static void bind(<span class=\"hljs-constructor\">Activity</span> activity) &#123;</span>\n<span class=\"hljs-pattern-match\">        inject<span class=\"hljs-constructor\">Layout(<span class=\"hljs-params\">activity</span>)</span>;</span>\n<span class=\"hljs-pattern-match\">        bind<span class=\"hljs-constructor\">View(<span class=\"hljs-params\">activity</span>)</span>;</span>\n<span class=\"hljs-pattern-match\">        bind<span class=\"hljs-constructor\">OnClick(<span class=\"hljs-params\">activity</span>)</span>;</span>\n<span class=\"hljs-pattern-match\">    &#125;</span></code></pre>\n<p>以上代码并没有什么难度，只要是了解一点反射知识的相信都能看懂。那么我们只要在Activity中调用bind方法后便可以使用注解了。下面来看Activity中的代码：</p>\n<pre><code class=\"hljs reasonml\">@<span class=\"hljs-constructor\">InjectLayout(R.<span class=\"hljs-params\">layout</span>.<span class=\"hljs-params\">activity_main</span>)</span>\npublic <span class=\"hljs-keyword\">class</span> MainActivity extends AppCompatActivity &#123;\n    @<span class=\"hljs-constructor\">BindView(R.<span class=\"hljs-params\">id</span>.<span class=\"hljs-params\">tv_test</span>)</span>\n    <span class=\"hljs-keyword\">private</span> Button mButton;\n\n    @Override\n    protected void on<span class=\"hljs-constructor\">Create(Bundle <span class=\"hljs-params\">savedInstanceState</span>)</span> &#123;\n        super.on<span class=\"hljs-constructor\">Create(<span class=\"hljs-params\">savedInstanceState</span>)</span>;\n<span class=\"hljs-comment\">//        setContentView(R.layout.activity_main);</span>\n        <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">BindProcessor</span>.</span></span>bind(this);\n        mButton.set<span class=\"hljs-constructor\">Text(<span class=\"hljs-string\">&quot;通过注解设置的Text&quot;</span>)</span>;\n    &#125;\n\n    @<span class=\"hljs-constructor\">OnClick(&#123;R.<span class=\"hljs-params\">id</span>.<span class=\"hljs-params\">tv_test</span>, R.<span class=\"hljs-params\">id</span>.<span class=\"hljs-params\">btn_reflect</span>&#125;)</span>\n    public void on<span class=\"hljs-constructor\">Click(View <span class=\"hljs-params\">view</span>)</span> &#123;\n        switch (view.get<span class=\"hljs-constructor\">Id()</span>) &#123;\n            case <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">R</span>.</span></span>id.tv_test:\n                <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">Toast</span>.</span></span>make<span class=\"hljs-constructor\">Text(<span class=\"hljs-params\">this</span>, <span class=\"hljs-string\">&quot;通过注解点解了Text&quot;</span>, Toast.LENGTH_SHORT)</span>.show<span class=\"hljs-literal\">()</span>;\n                break;\n            case <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">R</span>.</span></span>id.btn_reflect:\n                test<span class=\"hljs-constructor\">Reflect()</span>;\n                break;\n        &#125;\n    &#125;\n&#125;</code></pre>\n<p>可以看到，我们并没有在onCreate方法中调用setContentView方法，也没有去为Button按钮findViewById，更没有为其设置监听事件，我们统统都是用上面自定义的注解实现的。那么效果如何呢？我们来看下运行及起来的效果：<br><img src=\"https://raw.githubusercontent.com/zhpanvip/Resource/master/image/1501.gif\"></p>\n<p>效果貌似还不错，实现了与ButterKnife的部分功能，甚至我们还比ButterKnife多了一个注入布局的功能。但是，我们要知道的是ButterKnife并非是直接用反射实现的，因为反射是在运行时处理的，会影响到程序的效率。但对于神一般存在的Jake，怎么会做如此没有效率的事情。关于ButterKnife是如何实现注解，我们在下篇文章中在做探讨。</p>\n<p><a href=\"https://github.com/zhpanvip/MAnnotation/blob/master/app/src/main/java/com/zhpan/mannotation/BindProcessor.java\">源码参考</a></p>\n"},{"title":"手撕黄油刀--探究ButterKnife的实现原理","date":"2019-08-26T02:02:12.000Z","_content":"上篇文章《Java编译时注解处理器（APT）详解》中学习了Java APT技术在Android中的使用，并且我们知道，当前Android开发中常用的许多框架都使用了APT技术，并且ButterKnife就是利用APT来实现的。那么本篇内容我们就来探究一下ButterKnife的实现原理。\n\n# 一、ButterKnife的bind过程\n\n当然，在探究源码，还是首先应该了解如何使用，我们以ButterKnife的BindView为例。首先在Activity的onCreate方法中通过ButterKnife.bind()方法绑定，然后为TextView添加BindView注解即可拿到TextView的实例。代码如下：\n\n```\npackage com.zhpan.app;\n\npublic class MainActivity extends AppCompatActivity {\n\t @BindView(R.id.text_view)\n\t TextView mTextView;\n\t\n\t    @Override\n\t    protected void onCreate(Bundle savedInstanceState) {\n\t        super.onCreate(savedInstanceState);\n\t        setContentView(R.layout.activity_main);\n\t        ButterKnife.bind(this);\n\t    }\n    }\n```\nButterKnife是怎么做到通过注解获取TextView的实例的呢？我们就从bind方法开始吧，点击ButterKnife的bind方法，其代码如下：\n\n```\n//\tButterKnife中有很多bind的重载方法，仅以此为例\n public static Unbinder bind(@NonNull Activity target) {\n    View sourceView = target.getWindow().getDecorView();\n    return createBinding(target, sourceView);\n  }\n```\n可以看到在bind方法中通过Activity拿到了DecorView（至于不懂DecorView是什么的同学可以自行Google）。然后调用了createBinding方法，并传入Activity对象和DecorView两个参数。我们追踪createBinding的代码如下：\n\n```\nprivate static Unbinder createBinding(@NonNull Object target, @NonNull View source) {\n    Class<?> targetClass = target.getClass();\n    //\t获取到了与target相关的类的构造方法\n    Constructor<? extends Unbinder> constructor = findBindingConstructorForClass(targetClass);\n\n    if (constructor == null) {\n      return Unbinder.EMPTY;\n    }\n\n    //noinspection TryWithIdenticalCatches Resolves to API 19+ only type.\n    try {\n    //\t通过构造方法反射实例化了这个类，这个类接收两个参数，分别是上边的Activity和DecorView\n      return constructor.newInstance(target, source);\n    } catch (IllegalAccessException e) {\n      throw new RuntimeException(\"Unable to invoke \" + constructor, e);\n    } catch (InstantiationException e) {\n      throw new RuntimeException(\"Unable to invoke \" + constructor, e);\n    } catch (InvocationTargetException e) {\n      Throwable cause = e.getCause();\n      if (cause instanceof RuntimeException) {\n        throw (RuntimeException) cause;\n      }\n      if (cause instanceof Error) {\n        throw (Error) cause;\n      }\n      throw new RuntimeException(\"Unable to create binding instance.\", cause);\n    }\n  }\n```\n上述代码中通过findBindingConstructorForClass()方法得到了某个类的构造方法，并在接下来的代码中通过反射 constructor.newInstance(target, source)实例化了这个类，我们点进findBindingConstructorForClass()方法看这里做了什么。\n\n```\nprivate static Constructor<? extends Unbinder> findBindingConstructorForClass(Class<?> cls) {\n\t//\t从BINDINGS中获取cls对应的Unbinder\n    Constructor<? extends Unbinder> bindingCtor = BINDINGS.get(cls);\n    if (bindingCtor != null) { 如果已存在直接return\n      if (debug) Log.d(TAG, \"HIT: Cached in binding map.\");\n      return bindingCtor;\n    }\n    //\t这里拿到的clsName应该为“com.zhpan.app.MainActivity”\n    String clsName = cls.getName();\n    if (clsName.startsWith(\"android.\") || clsName.startsWith(\"java.\")) {\n      if (debug) Log.d(TAG, \"MISS: Reached framework class. Abandoning search.\");\n      return null;\n    }\n    try {\n    //\t从类加载器中获取“com.zhpan.app.MainActivity_ViewBinding”\n      Class<?> bindingClass = cls.getClassLoader().loadClass(clsName + \"_ViewBinding\");\n      // 获取“com.zhpan.app.MainActivity_ViewBinding”类中的构造方法\n      bindingCtor = (Constructor<? extends Unbinder>) bindingClass.getConstructor(cls, View.class);\n    } catch (ClassNotFoundException e) {\n      if (debug) Log.d(TAG, \"Not found. Trying superclass \" + cls.getSuperclass().getName());\n      bindingCtor = findBindingConstructorForClass(cls.getSuperclass());\n    } catch (NoSuchMethodException e) {\n      throw new RuntimeException(\"Unable to find binding constructor for \" + clsName, e);\n    }\n    BINDINGS.put(cls, bindingCtor);\n    return bindingCtor;\n  }\n```\n直接看第7行，通过 cls.getName()得到了bind方法中参数的名字，由于我们是再MainActivity中调用的bind方法，因此，这里拿到的名字就是“com.zhpan.app.MainActivity\",接下来再第13行中通过ClassLoader拿到了一个名字是”clsName\"+\"_ViewBinding\"的类，也就是名字为MainActivity_ViewBinding的类。我们在项目里搜索一下，发现果真能找到这个类，其代码如下：\n\n```\npackage com.zhpan.app;\n\npublic class MainActivity_ViewBinding implements Unbinder {\n  private MainActivity target;\n\n  @UiThread\n  public MainActivity_ViewBinding(MainActivity target) {\n    this(target, target.getWindow().getDecorView());\n  }\n\n  @UiThread\n  public MainActivity_ViewBinding(MainActivity target, View source) {\n    this.target = target;\n\n    target.mTextView = Utils.findRequiredViewAsType(source, R.id.text_view, \"field 'mTextView'\", TextView.class);\n  }\n\n  @Override\n  @CallSuper\n  public void unbind() {\n    MainActivity target = this.target;\n    if (target == null) throw new IllegalStateException(\"Bindings already cleare![在这里插入图片描述](https://img-blog.csdnimg.cn/20190825162306549.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwNTIxNTcz,size_16,color_FFFFFF,t_70)d.\");\n    this.target = null;\n\n    target.mTextView = null;\n  }\n}\n```\n在这个类的构造方法中我们可以看到\n\n```\ntarget.mTextView = Utils.findRequiredViewAsType(source, R.id.text_view, \"field 'mTextView'\", TextView.class);\n```\n通过这句代码给Activity中的mTextView赋了值，到这里也就不奇怪为什通过一个BindView的注解就得到了mTextView的对象了。而MainActivity_ViewBinding这个类是从哪里来的呢？想必看过上篇文章同学应该都知道了，就是通过APT在代码编译期间自动生成的。其实后面的代码其实已经没有必要去看了，无非就是通过AbstractProcessor来处理注解，然后根据注解自动生成所需代码的。但是写文章要有始有终，也本着负责任的态度，还是深入ButtereKnife内部一探究竟。\n\n# 二、探究ButterKnife的注解处理器ButterKnifeProcessor\n\n现在我们来看一下ButterKnife的代码的模块结构：\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190825162330432.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwNTIxNTcz,size_16,color_FFFFFF,t_70)\n看到butterknife-annotations和butterknife-compiler很眼熟？和上篇文章我们自己写的代码结构是一样的，butterknife-annotations模块下存放的是butterknife的所有注解，butterknife-compiler是用来处理butterknife-annotations注解的。所以们直接看butterknife-compiler模块下的ButterKnifeProcessor类。\n\n## 1.ButterKnifeProcessor的getSupportedAnnotationTypes()方法\n\n我们知道ButterKnife除了BindView注解之外还有许多其它注解，比如常用的BindColor注解、OnClick注解等。这些注解的名字都会被添加到getSupportedAnnotationTypes方法中的Set集合里。来看getSupportedAnnotationTypes的源码：\n\n```\n@Override public Set<String> getSupportedAnnotationTypes() {\n    Set<String> types = new LinkedHashSet<>();\n    //\t遍历ButterKnife中的所有注解，并将注解名字添加到Set集合\n    for (Class<? extends Annotation> annotation : getSupportedAnnotations()) {\n      types.add(annotation.getCanonicalName());\n    }\n    return types;\n  }\n```\n\n## 2.ButterKnifeProcessor的process方法\n我们知道process方法是整个注解处理其的核心方法，对注解的处理以及代码的生成都是在这个方法里边实现的。那么接下来，就一步步看ButterKnife是怎么处理注解和生成代码的。\n**(1)解析RoundEnviroment**\n在process方法的第一行我们看到通过findAndParseTargets方法得到了一个 Map<TypeElement, BindingSet>集合，代码如下：\n\n```\npublic boolean process(Set<? extends TypeElement> elements, RoundEnvironment env) {\n    //\t通过findAndParseTargets处理注解得到BindingSet的集合\n    Map<TypeElement, BindingSet> bindingMap = findAndParseTargets(env);\n    \n     ...\n  \n    return false;\n  }\n```\n而在findAndParseTargets(env)是对一系列注解的处理，这里我们仅以处理BindView为例：\n\n```\nprivate Map<TypeElement, BindingSet> findAndParseTargets(RoundEnvironment env) {\n    Map<TypeElement, BindingSet.Builder> builderMap = new LinkedHashMap<>();\n    Set<TypeElement> erasedTargetNames = new LinkedHashSet<>();\n\n    for (Element element : env.getElementsAnnotatedWith(BindView.class)) {\n      try {\n        parseBindView(element, builderMap, erasedTargetNames);\n      } catch (Exception e) {\n        logParsingError(element, BindView.class, e);\n      }\n    }\n\n\t//\t省略处理其它注解的代码\n\t\t...\n\t\t\n\t\n```\n第9行在parseBindView方法中对BindView注解进行了一系列的校验，通过校验后解析BindView的数据，比如view的Id等信息封装到了BindingSet.Builder中,并最终将封装好的BindingSet.Builder放入builderMap 中。由于parseBindView方法的代码比较多，这里就不再贴出了，有兴趣的可以直接下载源码查看。\n接下来得到builderMap的集合之后，由于findAndParseTargets方法返回值是Map<TypeElement, BindingSet>，因此接下来又对builderMap集合进行了遍历并最终存储到了 Map<TypeElement, BindingSet>中。代码如下：\n\n```\nprivate Map<TypeElement, BindingSet> findAndParseTargets(RoundEnvironment env) {\n\t\t\n\t\t...\n\t\n\tDeque<Map.Entry<TypeElement, BindingSet.Builder>> entries =\n\t\t        new ArrayDeque<>(builderMap.entrySet());\n\t\t    Map<TypeElement, BindingSet> bindingMap = new LinkedHashMap<>();\n\t\t    while (!entries.isEmpty()) {\n\t\t      Map.Entry<TypeElement, BindingSet.Builder> entry = entries.removeFirst();\n\t\t\n\t\t      TypeElement type = entry.getKey();\n\t\t      BindingSet.Builder builder = entry.getValue();\n\t\t\n\t\t      TypeElement parentType = findParentType(type, erasedTargetNames);\n\t\t      if (parentType == null) {\n\t\t        bindingMap.put(type, builder.build());\n\t\t      } else {\n\t\t        BindingSet parentBinding = bindingMap.get(parentType);\n\t\t        if (parentBinding != null) {\n\t\t          builder.setParent(parentBinding);\n\t\t          bindingMap.put(type, builder.build());\n\t\t        } else {\n\t\t          // Has a superclass binding but we haven't built it yet. Re-enqueue for later.\n\t\t          entries.addLast(entry);\n\t\t        }\n\t\t      }\n\t\t    }\n\t\t}\n\t}\n```\n好了，接下来，继续到process方法中，在拿到bindingMap 之后遍历bindingMap ，并调用BindingSet的brewJava来生成Java文件，代码如下：\n\n```\npublic boolean process(Set<? extends TypeElement> elements, RoundEnvironment env) {\n    Map<TypeElement, BindingSet> bindingMap = findAndParseTargets(env);\n\n    for (Map.Entry<TypeElement, BindingSet> entry : bindingMap.entrySet()) {\n      TypeElement typeElement = entry.getKey();\n      BindingSet binding = entry.getValue();\n\n      JavaFile javaFile = binding.brewJava(sdk, debuggable, useAndroidX);\n      try {\n        javaFile.writeTo(filer);\n      } catch (IOException e) {\n        error(typeElement, \"Unable to write binding for type %s: %s\", typeElement, e.getMessage());\n      }\n    }\n\n    return false;\n  }\n```\n\n## 3.JavaPoet生成代码\nBindingSet 的brewJava方法中同样是使用了JavaPoet来生成代码的，无非就是拼接类，构造方法、方法，这些感觉真的没什么说的了。\n\n```\nJavaFile brewJava(int sdk, boolean debuggable, boolean useAndroidX) {\n    TypeSpec bindingConfiguration = createType(sdk, debuggable, useAndroidX);\n    return JavaFile.builder(bindingClassName.packageName(), bindingConfiguration)\n        .addFileComment(\"Generated code from Butter Knife. Do not modify!\")\n        .build();\n  }\n```\n\n```\nprivate TypeSpec createType(int sdk, boolean debuggable, boolean useAndroidX) {\n    TypeSpec.Builder result = TypeSpec.classBuilder(bindingClassName.simpleName())\n        .addModifiers(PUBLIC);\n    if (isFinal) {\n      result.addModifiers(FINAL);\n    }\n\n    if (parentBinding != null) {\n      result.superclass(parentBinding.bindingClassName);\n    } else {\n      result.addSuperinterface(UNBINDER);\n    }\n\n    if (hasTargetField()) {\n      result.addField(targetTypeName, \"target\", PRIVATE);\n    }\n\n    if (isView) {\n      result.addMethod(createBindingConstructorForView(useAndroidX));\n    } else if (isActivity) {\n      result.addMethod(createBindingConstructorForActivity(useAndroidX));\n    } else if (isDialog) {\n      result.addMethod(createBindingConstructorForDialog(useAndroidX));\n    }\n    if (!constructorNeedsView()) {\n      // Add a delegating constructor with a target type + view signature for reflective use.\n      result.addMethod(createBindingViewDelegateConstructor(useAndroidX));\n    }\n    result.addMethod(createBindingConstructor(sdk, debuggable, useAndroidX));\n\n    if (hasViewBindings() || parentBinding == null) {\n      result.addMethod(createBindingUnbindMethod(result, useAndroidX));\n    }\n\n    return result.build();\n  }\n```\n关于ButterKnife的源码就说这么多吧。总结一下，其实就是根据注解使用APT及JavaPoet在项目编译期间自动生成代码，并达到为注解元素赋值或者添加监听的目的。在阅读Butterknife时候不一定要把每一句代码都搞懂，能做到掌握其核心原理便可。","source":"_posts/18.手撕黄油刀-探究ButterKnife的实现原理.md","raw":"---\ntitle: 手撕黄油刀--探究ButterKnife的实现原理\ndate:  2019-08-26 10:02:12\ntags: \n- 源码分析\n- APT\n---\n上篇文章《Java编译时注解处理器（APT）详解》中学习了Java APT技术在Android中的使用，并且我们知道，当前Android开发中常用的许多框架都使用了APT技术，并且ButterKnife就是利用APT来实现的。那么本篇内容我们就来探究一下ButterKnife的实现原理。\n\n# 一、ButterKnife的bind过程\n\n当然，在探究源码，还是首先应该了解如何使用，我们以ButterKnife的BindView为例。首先在Activity的onCreate方法中通过ButterKnife.bind()方法绑定，然后为TextView添加BindView注解即可拿到TextView的实例。代码如下：\n\n```\npackage com.zhpan.app;\n\npublic class MainActivity extends AppCompatActivity {\n\t @BindView(R.id.text_view)\n\t TextView mTextView;\n\t\n\t    @Override\n\t    protected void onCreate(Bundle savedInstanceState) {\n\t        super.onCreate(savedInstanceState);\n\t        setContentView(R.layout.activity_main);\n\t        ButterKnife.bind(this);\n\t    }\n    }\n```\nButterKnife是怎么做到通过注解获取TextView的实例的呢？我们就从bind方法开始吧，点击ButterKnife的bind方法，其代码如下：\n\n```\n//\tButterKnife中有很多bind的重载方法，仅以此为例\n public static Unbinder bind(@NonNull Activity target) {\n    View sourceView = target.getWindow().getDecorView();\n    return createBinding(target, sourceView);\n  }\n```\n可以看到在bind方法中通过Activity拿到了DecorView（至于不懂DecorView是什么的同学可以自行Google）。然后调用了createBinding方法，并传入Activity对象和DecorView两个参数。我们追踪createBinding的代码如下：\n\n```\nprivate static Unbinder createBinding(@NonNull Object target, @NonNull View source) {\n    Class<?> targetClass = target.getClass();\n    //\t获取到了与target相关的类的构造方法\n    Constructor<? extends Unbinder> constructor = findBindingConstructorForClass(targetClass);\n\n    if (constructor == null) {\n      return Unbinder.EMPTY;\n    }\n\n    //noinspection TryWithIdenticalCatches Resolves to API 19+ only type.\n    try {\n    //\t通过构造方法反射实例化了这个类，这个类接收两个参数，分别是上边的Activity和DecorView\n      return constructor.newInstance(target, source);\n    } catch (IllegalAccessException e) {\n      throw new RuntimeException(\"Unable to invoke \" + constructor, e);\n    } catch (InstantiationException e) {\n      throw new RuntimeException(\"Unable to invoke \" + constructor, e);\n    } catch (InvocationTargetException e) {\n      Throwable cause = e.getCause();\n      if (cause instanceof RuntimeException) {\n        throw (RuntimeException) cause;\n      }\n      if (cause instanceof Error) {\n        throw (Error) cause;\n      }\n      throw new RuntimeException(\"Unable to create binding instance.\", cause);\n    }\n  }\n```\n上述代码中通过findBindingConstructorForClass()方法得到了某个类的构造方法，并在接下来的代码中通过反射 constructor.newInstance(target, source)实例化了这个类，我们点进findBindingConstructorForClass()方法看这里做了什么。\n\n```\nprivate static Constructor<? extends Unbinder> findBindingConstructorForClass(Class<?> cls) {\n\t//\t从BINDINGS中获取cls对应的Unbinder\n    Constructor<? extends Unbinder> bindingCtor = BINDINGS.get(cls);\n    if (bindingCtor != null) { 如果已存在直接return\n      if (debug) Log.d(TAG, \"HIT: Cached in binding map.\");\n      return bindingCtor;\n    }\n    //\t这里拿到的clsName应该为“com.zhpan.app.MainActivity”\n    String clsName = cls.getName();\n    if (clsName.startsWith(\"android.\") || clsName.startsWith(\"java.\")) {\n      if (debug) Log.d(TAG, \"MISS: Reached framework class. Abandoning search.\");\n      return null;\n    }\n    try {\n    //\t从类加载器中获取“com.zhpan.app.MainActivity_ViewBinding”\n      Class<?> bindingClass = cls.getClassLoader().loadClass(clsName + \"_ViewBinding\");\n      // 获取“com.zhpan.app.MainActivity_ViewBinding”类中的构造方法\n      bindingCtor = (Constructor<? extends Unbinder>) bindingClass.getConstructor(cls, View.class);\n    } catch (ClassNotFoundException e) {\n      if (debug) Log.d(TAG, \"Not found. Trying superclass \" + cls.getSuperclass().getName());\n      bindingCtor = findBindingConstructorForClass(cls.getSuperclass());\n    } catch (NoSuchMethodException e) {\n      throw new RuntimeException(\"Unable to find binding constructor for \" + clsName, e);\n    }\n    BINDINGS.put(cls, bindingCtor);\n    return bindingCtor;\n  }\n```\n直接看第7行，通过 cls.getName()得到了bind方法中参数的名字，由于我们是再MainActivity中调用的bind方法，因此，这里拿到的名字就是“com.zhpan.app.MainActivity\",接下来再第13行中通过ClassLoader拿到了一个名字是”clsName\"+\"_ViewBinding\"的类，也就是名字为MainActivity_ViewBinding的类。我们在项目里搜索一下，发现果真能找到这个类，其代码如下：\n\n```\npackage com.zhpan.app;\n\npublic class MainActivity_ViewBinding implements Unbinder {\n  private MainActivity target;\n\n  @UiThread\n  public MainActivity_ViewBinding(MainActivity target) {\n    this(target, target.getWindow().getDecorView());\n  }\n\n  @UiThread\n  public MainActivity_ViewBinding(MainActivity target, View source) {\n    this.target = target;\n\n    target.mTextView = Utils.findRequiredViewAsType(source, R.id.text_view, \"field 'mTextView'\", TextView.class);\n  }\n\n  @Override\n  @CallSuper\n  public void unbind() {\n    MainActivity target = this.target;\n    if (target == null) throw new IllegalStateException(\"Bindings already cleare![在这里插入图片描述](https://img-blog.csdnimg.cn/20190825162306549.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwNTIxNTcz,size_16,color_FFFFFF,t_70)d.\");\n    this.target = null;\n\n    target.mTextView = null;\n  }\n}\n```\n在这个类的构造方法中我们可以看到\n\n```\ntarget.mTextView = Utils.findRequiredViewAsType(source, R.id.text_view, \"field 'mTextView'\", TextView.class);\n```\n通过这句代码给Activity中的mTextView赋了值，到这里也就不奇怪为什通过一个BindView的注解就得到了mTextView的对象了。而MainActivity_ViewBinding这个类是从哪里来的呢？想必看过上篇文章同学应该都知道了，就是通过APT在代码编译期间自动生成的。其实后面的代码其实已经没有必要去看了，无非就是通过AbstractProcessor来处理注解，然后根据注解自动生成所需代码的。但是写文章要有始有终，也本着负责任的态度，还是深入ButtereKnife内部一探究竟。\n\n# 二、探究ButterKnife的注解处理器ButterKnifeProcessor\n\n现在我们来看一下ButterKnife的代码的模块结构：\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190825162330432.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwNTIxNTcz,size_16,color_FFFFFF,t_70)\n看到butterknife-annotations和butterknife-compiler很眼熟？和上篇文章我们自己写的代码结构是一样的，butterknife-annotations模块下存放的是butterknife的所有注解，butterknife-compiler是用来处理butterknife-annotations注解的。所以们直接看butterknife-compiler模块下的ButterKnifeProcessor类。\n\n## 1.ButterKnifeProcessor的getSupportedAnnotationTypes()方法\n\n我们知道ButterKnife除了BindView注解之外还有许多其它注解，比如常用的BindColor注解、OnClick注解等。这些注解的名字都会被添加到getSupportedAnnotationTypes方法中的Set集合里。来看getSupportedAnnotationTypes的源码：\n\n```\n@Override public Set<String> getSupportedAnnotationTypes() {\n    Set<String> types = new LinkedHashSet<>();\n    //\t遍历ButterKnife中的所有注解，并将注解名字添加到Set集合\n    for (Class<? extends Annotation> annotation : getSupportedAnnotations()) {\n      types.add(annotation.getCanonicalName());\n    }\n    return types;\n  }\n```\n\n## 2.ButterKnifeProcessor的process方法\n我们知道process方法是整个注解处理其的核心方法，对注解的处理以及代码的生成都是在这个方法里边实现的。那么接下来，就一步步看ButterKnife是怎么处理注解和生成代码的。\n**(1)解析RoundEnviroment**\n在process方法的第一行我们看到通过findAndParseTargets方法得到了一个 Map<TypeElement, BindingSet>集合，代码如下：\n\n```\npublic boolean process(Set<? extends TypeElement> elements, RoundEnvironment env) {\n    //\t通过findAndParseTargets处理注解得到BindingSet的集合\n    Map<TypeElement, BindingSet> bindingMap = findAndParseTargets(env);\n    \n     ...\n  \n    return false;\n  }\n```\n而在findAndParseTargets(env)是对一系列注解的处理，这里我们仅以处理BindView为例：\n\n```\nprivate Map<TypeElement, BindingSet> findAndParseTargets(RoundEnvironment env) {\n    Map<TypeElement, BindingSet.Builder> builderMap = new LinkedHashMap<>();\n    Set<TypeElement> erasedTargetNames = new LinkedHashSet<>();\n\n    for (Element element : env.getElementsAnnotatedWith(BindView.class)) {\n      try {\n        parseBindView(element, builderMap, erasedTargetNames);\n      } catch (Exception e) {\n        logParsingError(element, BindView.class, e);\n      }\n    }\n\n\t//\t省略处理其它注解的代码\n\t\t...\n\t\t\n\t\n```\n第9行在parseBindView方法中对BindView注解进行了一系列的校验，通过校验后解析BindView的数据，比如view的Id等信息封装到了BindingSet.Builder中,并最终将封装好的BindingSet.Builder放入builderMap 中。由于parseBindView方法的代码比较多，这里就不再贴出了，有兴趣的可以直接下载源码查看。\n接下来得到builderMap的集合之后，由于findAndParseTargets方法返回值是Map<TypeElement, BindingSet>，因此接下来又对builderMap集合进行了遍历并最终存储到了 Map<TypeElement, BindingSet>中。代码如下：\n\n```\nprivate Map<TypeElement, BindingSet> findAndParseTargets(RoundEnvironment env) {\n\t\t\n\t\t...\n\t\n\tDeque<Map.Entry<TypeElement, BindingSet.Builder>> entries =\n\t\t        new ArrayDeque<>(builderMap.entrySet());\n\t\t    Map<TypeElement, BindingSet> bindingMap = new LinkedHashMap<>();\n\t\t    while (!entries.isEmpty()) {\n\t\t      Map.Entry<TypeElement, BindingSet.Builder> entry = entries.removeFirst();\n\t\t\n\t\t      TypeElement type = entry.getKey();\n\t\t      BindingSet.Builder builder = entry.getValue();\n\t\t\n\t\t      TypeElement parentType = findParentType(type, erasedTargetNames);\n\t\t      if (parentType == null) {\n\t\t        bindingMap.put(type, builder.build());\n\t\t      } else {\n\t\t        BindingSet parentBinding = bindingMap.get(parentType);\n\t\t        if (parentBinding != null) {\n\t\t          builder.setParent(parentBinding);\n\t\t          bindingMap.put(type, builder.build());\n\t\t        } else {\n\t\t          // Has a superclass binding but we haven't built it yet. Re-enqueue for later.\n\t\t          entries.addLast(entry);\n\t\t        }\n\t\t      }\n\t\t    }\n\t\t}\n\t}\n```\n好了，接下来，继续到process方法中，在拿到bindingMap 之后遍历bindingMap ，并调用BindingSet的brewJava来生成Java文件，代码如下：\n\n```\npublic boolean process(Set<? extends TypeElement> elements, RoundEnvironment env) {\n    Map<TypeElement, BindingSet> bindingMap = findAndParseTargets(env);\n\n    for (Map.Entry<TypeElement, BindingSet> entry : bindingMap.entrySet()) {\n      TypeElement typeElement = entry.getKey();\n      BindingSet binding = entry.getValue();\n\n      JavaFile javaFile = binding.brewJava(sdk, debuggable, useAndroidX);\n      try {\n        javaFile.writeTo(filer);\n      } catch (IOException e) {\n        error(typeElement, \"Unable to write binding for type %s: %s\", typeElement, e.getMessage());\n      }\n    }\n\n    return false;\n  }\n```\n\n## 3.JavaPoet生成代码\nBindingSet 的brewJava方法中同样是使用了JavaPoet来生成代码的，无非就是拼接类，构造方法、方法，这些感觉真的没什么说的了。\n\n```\nJavaFile brewJava(int sdk, boolean debuggable, boolean useAndroidX) {\n    TypeSpec bindingConfiguration = createType(sdk, debuggable, useAndroidX);\n    return JavaFile.builder(bindingClassName.packageName(), bindingConfiguration)\n        .addFileComment(\"Generated code from Butter Knife. Do not modify!\")\n        .build();\n  }\n```\n\n```\nprivate TypeSpec createType(int sdk, boolean debuggable, boolean useAndroidX) {\n    TypeSpec.Builder result = TypeSpec.classBuilder(bindingClassName.simpleName())\n        .addModifiers(PUBLIC);\n    if (isFinal) {\n      result.addModifiers(FINAL);\n    }\n\n    if (parentBinding != null) {\n      result.superclass(parentBinding.bindingClassName);\n    } else {\n      result.addSuperinterface(UNBINDER);\n    }\n\n    if (hasTargetField()) {\n      result.addField(targetTypeName, \"target\", PRIVATE);\n    }\n\n    if (isView) {\n      result.addMethod(createBindingConstructorForView(useAndroidX));\n    } else if (isActivity) {\n      result.addMethod(createBindingConstructorForActivity(useAndroidX));\n    } else if (isDialog) {\n      result.addMethod(createBindingConstructorForDialog(useAndroidX));\n    }\n    if (!constructorNeedsView()) {\n      // Add a delegating constructor with a target type + view signature for reflective use.\n      result.addMethod(createBindingViewDelegateConstructor(useAndroidX));\n    }\n    result.addMethod(createBindingConstructor(sdk, debuggable, useAndroidX));\n\n    if (hasViewBindings() || parentBinding == null) {\n      result.addMethod(createBindingUnbindMethod(result, useAndroidX));\n    }\n\n    return result.build();\n  }\n```\n关于ButterKnife的源码就说这么多吧。总结一下，其实就是根据注解使用APT及JavaPoet在项目编译期间自动生成代码，并达到为注解元素赋值或者添加监听的目的。在阅读Butterknife时候不一定要把每一句代码都搞懂，能做到掌握其核心原理便可。","slug":"18.手撕黄油刀-探究ButterKnife的实现原理","published":1,"updated":"2020-08-29T01:51:45.168Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckegm5nrs0005dwozaxqh2isq","content":"<p>上篇文章《Java编译时注解处理器（APT）详解》中学习了Java APT技术在Android中的使用，并且我们知道，当前Android开发中常用的许多框架都使用了APT技术，并且ButterKnife就是利用APT来实现的。那么本篇内容我们就来探究一下ButterKnife的实现原理。</p>\n<h1 id=\"一、ButterKnife的bind过程\"><a href=\"#一、ButterKnife的bind过程\" class=\"headerlink\" title=\"一、ButterKnife的bind过程\"></a>一、ButterKnife的bind过程</h1><p>当然，在探究源码，还是首先应该了解如何使用，我们以ButterKnife的BindView为例。首先在Activity的onCreate方法中通过ButterKnife.bind()方法绑定，然后为TextView添加BindView注解即可拿到TextView的实例。代码如下：</p>\n<pre><code class=\"hljs scala\"><span class=\"hljs-keyword\">package</span> com.zhpan.app;\n\npublic <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MainActivity</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">AppCompatActivity</span> </span>&#123;\n\t <span class=\"hljs-meta\">@BindView</span>(<span class=\"hljs-type\">R</span>.id.text_view)\n\t <span class=\"hljs-type\">TextView</span> mTextView;\n\t\n\t    <span class=\"hljs-meta\">@Override</span>\n\t    <span class=\"hljs-keyword\">protected</span> void onCreate(<span class=\"hljs-type\">Bundle</span> savedInstanceState) &#123;\n\t        <span class=\"hljs-keyword\">super</span>.onCreate(savedInstanceState);\n\t        setContentView(<span class=\"hljs-type\">R</span>.layout.activity_main);\n\t        <span class=\"hljs-type\">ButterKnife</span>.bind(<span class=\"hljs-keyword\">this</span>);\n\t    &#125;\n    &#125;</code></pre>\n<p>ButterKnife是怎么做到通过注解获取TextView的实例的呢？我们就从bind方法开始吧，点击ButterKnife的bind方法，其代码如下：</p>\n<pre><code class=\"hljs aspectj\"><span class=\"hljs-comment\">//\tButterKnife中有很多bind的重载方法，仅以此为例</span>\n <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-function\">Unbinder <span class=\"hljs-title\">bind</span><span class=\"hljs-params\">(@NonNull Activity <span class=\"hljs-keyword\">target</span>)</span> </span>&#123;\n    View sourceView = <span class=\"hljs-keyword\">target</span>.getWindow().getDecorView();\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">return</span> <span class=\"hljs-title\">createBinding</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">target</span>, sourceView)</span></span>;\n  &#125;</code></pre>\n<p>可以看到在bind方法中通过Activity拿到了DecorView（至于不懂DecorView是什么的同学可以自行Google）。然后调用了createBinding方法，并传入Activity对象和DecorView两个参数。我们追踪createBinding的代码如下：</p>\n<pre><code class=\"hljs typescript\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> Unbinder createBinding(<span class=\"hljs-meta\">@NonNull</span> <span class=\"hljs-built_in\">Object</span> target, <span class=\"hljs-meta\">@NonNull</span> View source) &#123;\n    Class&lt;?&gt; targetClass = target.getClass();\n    <span class=\"hljs-comment\">//\t获取到了与target相关的类的构造方法</span>\n    Constructor&lt;? <span class=\"hljs-keyword\">extends</span> Unbinder&gt; <span class=\"hljs-keyword\">constructor</span> = findBindingConstructorForClass(<span class=\"hljs-params\">targetClass</span>);\n\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">constructor</span> == null) &#123;\n      <span class=\"hljs-keyword\">return</span> Unbinder.EMPTY;\n    &#125;\n\n    <span class=\"hljs-comment\">//noinspection TryWithIdenticalCatches Resolves to API 19+ only type.</span>\n    <span class=\"hljs-keyword\">try</span> &#123;\n    <span class=\"hljs-comment\">//\t通过构造方法反射实例化了这个类，这个类接收两个参数，分别是上边的Activity和DecorView</span>\n      <span class=\"hljs-keyword\">return</span> constructor.newInstance(target, source);\n    &#125; <span class=\"hljs-keyword\">catch</span> (IllegalAccessException e) &#123;\n      <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> RuntimeException(<span class=\"hljs-string\">&quot;Unable to invoke &quot;</span> + <span class=\"hljs-keyword\">constructor</span>, e);\n    &#125; <span class=\"hljs-keyword\">catch</span> (InstantiationException e) &#123;\n      <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> RuntimeException(<span class=\"hljs-string\">&quot;Unable to invoke &quot;</span> + <span class=\"hljs-keyword\">constructor</span>, e);\n    &#125; <span class=\"hljs-keyword\">catch</span> (InvocationTargetException e) &#123;\n      Throwable cause = e.getCause();\n      <span class=\"hljs-keyword\">if</span> (cause <span class=\"hljs-keyword\">instanceof</span> RuntimeException) &#123;\n        <span class=\"hljs-keyword\">throw</span> (RuntimeException) cause;\n      &#125;\n      <span class=\"hljs-keyword\">if</span> (cause <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-built_in\">Error</span>) &#123;\n        <span class=\"hljs-keyword\">throw</span> (<span class=\"hljs-built_in\">Error</span>) cause;\n      &#125;\n      <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> RuntimeException(<span class=\"hljs-string\">&quot;Unable to create binding instance.&quot;</span>, cause);\n    &#125;\n  &#125;</code></pre>\n<p>上述代码中通过findBindingConstructorForClass()方法得到了某个类的构造方法，并在接下来的代码中通过反射 constructor.newInstance(target, source)实例化了这个类，我们点进findBindingConstructorForClass()方法看这里做了什么。</p>\n<pre><code class=\"hljs reasonml\"><span class=\"hljs-keyword\">private</span> static Constructor&lt;? extends Unbinder&gt; find<span class=\"hljs-constructor\">BindingConstructorForClass(Class&lt;?&gt; <span class=\"hljs-params\">cls</span>)</span> &#123;\n\t<span class=\"hljs-comment\">//\t从BINDINGS中获取cls对应的Unbinder</span>\n    Constructor&lt;? extends Unbinder&gt; bindingCtor = <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">BINDINGS</span>.</span></span>get(cls);\n    <span class=\"hljs-keyword\">if</span> (bindingCtor != null) &#123; 如果已存在直接return\n      <span class=\"hljs-keyword\">if</span> (debug) <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">Log</span>.</span></span>d(TAG, <span class=\"hljs-string\">&quot;HIT: Cached in binding map.&quot;</span>);\n      return bindingCtor;\n    &#125;\n    <span class=\"hljs-comment\">//\t这里拿到的clsName应该为“com.zhpan.app.MainActivity”</span>\n    String clsName = cls.get<span class=\"hljs-constructor\">Name()</span>;\n    <span class=\"hljs-keyword\">if</span> (clsName.starts<span class=\"hljs-constructor\">With(<span class=\"hljs-string\">&quot;android.&quot;</span>)</span><span class=\"hljs-operator\"> || </span>clsName.starts<span class=\"hljs-constructor\">With(<span class=\"hljs-string\">&quot;java.&quot;</span>)</span>) &#123;\n      <span class=\"hljs-keyword\">if</span> (debug) <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">Log</span>.</span></span>d(TAG, <span class=\"hljs-string\">&quot;MISS: Reached framework class. Abandoning search.&quot;</span>);\n      return null;\n    &#125;\n    <span class=\"hljs-keyword\">try</span> &#123;\n    <span class=\"hljs-comment\">//\t从类加载器中获取“com.zhpan.app.MainActivity_ViewBinding”</span>\n      Class&lt;?&gt; bindingClass = cls.get<span class=\"hljs-constructor\">ClassLoader()</span>.load<span class=\"hljs-constructor\">Class(<span class=\"hljs-params\">clsName</span> + <span class=\"hljs-string\">&quot;_ViewBinding&quot;</span>)</span>;\n      <span class=\"hljs-comment\">// 获取“com.zhpan.app.MainActivity_ViewBinding”类中的构造方法</span>\n      bindingCtor = (Constructor&lt;? extends Unbinder&gt;) bindingClass.get<span class=\"hljs-constructor\">Constructor(<span class=\"hljs-params\">cls</span>, View.<span class=\"hljs-params\">class</span>)</span>;\n    &#125; catch (ClassNotFoundException e) &#123;\n      <span class=\"hljs-keyword\">if</span> (debug) <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">Log</span>.</span></span>d(TAG, <span class=\"hljs-string\">&quot;Not found. Trying superclass &quot;</span> + cls.get<span class=\"hljs-constructor\">Superclass()</span>.get<span class=\"hljs-constructor\">Name()</span>);\n      bindingCtor = find<span class=\"hljs-constructor\">BindingConstructorForClass(<span class=\"hljs-params\">cls</span>.<span class=\"hljs-params\">getSuperclass</span>()</span>);\n    &#125; catch (NoSuchMethodException e) &#123;\n      throw <span class=\"hljs-keyword\">new</span> <span class=\"hljs-constructor\">RuntimeException(<span class=\"hljs-string\">&quot;Unable to find binding constructor for &quot;</span> + <span class=\"hljs-params\">clsName</span>, <span class=\"hljs-params\">e</span>)</span>;\n    &#125;\n    <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">BINDINGS</span>.</span></span>put(cls, bindingCtor);\n    return bindingCtor;\n  &#125;</code></pre>\n<p>直接看第7行，通过 cls.getName()得到了bind方法中参数的名字，由于我们是再MainActivity中调用的bind方法，因此，这里拿到的名字就是“com.zhpan.app.MainActivity”,接下来再第13行中通过ClassLoader拿到了一个名字是”clsName”+”_ViewBinding”的类，也就是名字为MainActivity_ViewBinding的类。我们在项目里搜索一下，发现果真能找到这个类，其代码如下：</p>\n<pre><code class=\"hljs aspectj\"><span class=\"hljs-keyword\">package</span> com.zhpan.app;\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MainActivity_ViewBinding</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">Unbinder</span> </span>&#123;\n  <span class=\"hljs-keyword\">private</span> MainActivity <span class=\"hljs-keyword\">target</span>;\n\n  <span class=\"hljs-meta\">@UiThread</span>\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">MainActivity_ViewBinding</span><span class=\"hljs-params\">(MainActivity <span class=\"hljs-keyword\">target</span>)</span> </span>&#123;\n    <span class=\"hljs-keyword\">this</span>(<span class=\"hljs-keyword\">target</span>, <span class=\"hljs-keyword\">target</span>.getWindow().getDecorView());\n  &#125;\n\n  <span class=\"hljs-meta\">@UiThread</span>\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">MainActivity_ViewBinding</span><span class=\"hljs-params\">(MainActivity <span class=\"hljs-keyword\">target</span>, View source)</span> </span>&#123;\n    <span class=\"hljs-keyword\">this</span>.<span class=\"hljs-keyword\">target</span> = <span class=\"hljs-keyword\">target</span>;\n\n    <span class=\"hljs-keyword\">target</span>.mTextView = Utils.findRequiredViewAsType(source, R.id.text_view, <span class=\"hljs-string\">&quot;field &#x27;mTextView&#x27;&quot;</span>, TextView.class);\n  &#125;\n\n  <span class=\"hljs-meta\">@Override</span>\n  <span class=\"hljs-meta\">@CallSuper</span>\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">unbind</span><span class=\"hljs-params\">()</span> </span>&#123;\n    MainActivity <span class=\"hljs-keyword\">target</span> = <span class=\"hljs-keyword\">this</span>.<span class=\"hljs-keyword\">target</span>;\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">target</span> == <span class=\"hljs-keyword\">null</span>) <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> IllegalStateException(<span class=\"hljs-string\">&quot;Bindings already cleare![在这里插入图片描述](https://img-blog.csdnimg.cn/20190825162306549.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwNTIxNTcz,size_16,color_FFFFFF,t_70)d.&quot;</span>);\n    <span class=\"hljs-keyword\">this</span>.<span class=\"hljs-keyword\">target</span> = <span class=\"hljs-keyword\">null</span>;\n\n    <span class=\"hljs-keyword\">target</span>.mTextView = <span class=\"hljs-keyword\">null</span>;\n  &#125;\n&#125;</code></pre>\n<p>在这个类的构造方法中我们可以看到</p>\n<pre><code class=\"hljs reasonml\">target.mTextView = <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">Utils</span>.</span></span>find<span class=\"hljs-constructor\">RequiredViewAsType(<span class=\"hljs-params\">source</span>, R.<span class=\"hljs-params\">id</span>.<span class=\"hljs-params\">text_view</span>, <span class=\"hljs-string\">&quot;field &#x27;mTextView&#x27;&quot;</span>, TextView.<span class=\"hljs-params\">class</span>)</span>;</code></pre>\n<p>通过这句代码给Activity中的mTextView赋了值，到这里也就不奇怪为什通过一个BindView的注解就得到了mTextView的对象了。而MainActivity_ViewBinding这个类是从哪里来的呢？想必看过上篇文章同学应该都知道了，就是通过APT在代码编译期间自动生成的。其实后面的代码其实已经没有必要去看了，无非就是通过AbstractProcessor来处理注解，然后根据注解自动生成所需代码的。但是写文章要有始有终，也本着负责任的态度，还是深入ButtereKnife内部一探究竟。</p>\n<h1 id=\"二、探究ButterKnife的注解处理器ButterKnifeProcessor\"><a href=\"#二、探究ButterKnife的注解处理器ButterKnifeProcessor\" class=\"headerlink\" title=\"二、探究ButterKnife的注解处理器ButterKnifeProcessor\"></a>二、探究ButterKnife的注解处理器ButterKnifeProcessor</h1><p>现在我们来看一下ButterKnife的代码的模块结构：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190825162330432.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwNTIxNTcz,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>看到butterknife-annotations和butterknife-compiler很眼熟？和上篇文章我们自己写的代码结构是一样的，butterknife-annotations模块下存放的是butterknife的所有注解，butterknife-compiler是用来处理butterknife-annotations注解的。所以们直接看butterknife-compiler模块下的ButterKnifeProcessor类。</p>\n<h2 id=\"1-ButterKnifeProcessor的getSupportedAnnotationTypes-方法\"><a href=\"#1-ButterKnifeProcessor的getSupportedAnnotationTypes-方法\" class=\"headerlink\" title=\"1.ButterKnifeProcessor的getSupportedAnnotationTypes()方法\"></a>1.ButterKnifeProcessor的getSupportedAnnotationTypes()方法</h2><p>我们知道ButterKnife除了BindView注解之外还有许多其它注解，比如常用的BindColor注解、OnClick注解等。这些注解的名字都会被添加到getSupportedAnnotationTypes方法中的Set集合里。来看getSupportedAnnotationTypes的源码：</p>\n<pre><code class=\"hljs crystal\">@Override public Set&lt;String&gt; getSupportedAnnotationTypes() &#123;\n    Set&lt;String&gt; types = new LinkedHashSet&lt;&gt;();\n    /<span class=\"hljs-regexp\">/\t遍历ButterKnife中的所有注解，并将注解名字添加到Set集合</span>\n<span class=\"hljs-regexp\">    for (Class&lt;? extends Annotation&gt; annotation : getSupportedAnnotations()) &#123;</span>\n<span class=\"hljs-regexp\">      types.add(annotation.getCanonicalName());</span>\n<span class=\"hljs-regexp\">    &#125;</span>\n<span class=\"hljs-regexp\">    return types;</span>\n<span class=\"hljs-regexp\">  &#125;</span></code></pre>\n\n<h2 id=\"2-ButterKnifeProcessor的process方法\"><a href=\"#2-ButterKnifeProcessor的process方法\" class=\"headerlink\" title=\"2.ButterKnifeProcessor的process方法\"></a>2.ButterKnifeProcessor的process方法</h2><p>我们知道process方法是整个注解处理其的核心方法，对注解的处理以及代码的生成都是在这个方法里边实现的。那么接下来，就一步步看ButterKnife是怎么处理注解和生成代码的。<br>**(1)解析RoundEnviroment**<br>在process方法的第一行我们看到通过findAndParseTargets方法得到了一个 Map&lt;TypeElement, BindingSet&gt;集合，代码如下：</p>\n<pre><code class=\"hljs lasso\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-built_in\">boolean</span> process(<span class=\"hljs-built_in\">Set</span>&lt;? extends TypeElement&gt; elements, RoundEnvironment env) &#123;\n    <span class=\"hljs-comment\">//\t通过findAndParseTargets处理注解得到BindingSet的集合</span>\n    <span class=\"hljs-built_in\">Map</span>&lt;TypeElement, BindingSet&gt; bindingMap = findAndParseTargets(env);\n    \n     <span class=\"hljs-params\">...</span>\n  \n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;\n  &#125;</code></pre>\n<p>而在findAndParseTargets(env)是对一系列注解的处理，这里我们仅以处理BindView为例：</p>\n<pre><code class=\"hljs reasonml\"><span class=\"hljs-keyword\">private</span> Map&lt;TypeElement, BindingSet&gt; find<span class=\"hljs-constructor\">AndParseTargets(RoundEnvironment <span class=\"hljs-params\">env</span>)</span> &#123;\n    Map&lt;TypeElement, BindingSet.Builder&gt; builderMap = <span class=\"hljs-keyword\">new</span> LinkedHashMap&lt;&gt;<span class=\"hljs-literal\">()</span>;\n    Set&lt;TypeElement&gt; erasedTargetNames = <span class=\"hljs-keyword\">new</span> LinkedHashSet&lt;&gt;<span class=\"hljs-literal\">()</span>;\n\n    <span class=\"hljs-keyword\">for</span> (Element element : env.get<span class=\"hljs-constructor\">ElementsAnnotatedWith(BindView.<span class=\"hljs-params\">class</span>)</span>) &#123;\n      <span class=\"hljs-keyword\">try</span> &#123;\n        parse<span class=\"hljs-constructor\">BindView(<span class=\"hljs-params\">element</span>, <span class=\"hljs-params\">builderMap</span>, <span class=\"hljs-params\">erasedTargetNames</span>)</span>;\n      &#125; catch (Exception e) &#123;\n        log<span class=\"hljs-constructor\">ParsingError(<span class=\"hljs-params\">element</span>, BindView.<span class=\"hljs-params\">class</span>, <span class=\"hljs-params\">e</span>)</span>;\n      &#125;\n    &#125;\n\n\t<span class=\"hljs-comment\">//\t省略处理其它注解的代码</span>\n\t\t...</code></pre>\n<p>第9行在parseBindView方法中对BindView注解进行了一系列的校验，通过校验后解析BindView的数据，比如view的Id等信息封装到了BindingSet.Builder中,并最终将封装好的BindingSet.Builder放入builderMap 中。由于parseBindView方法的代码比较多，这里就不再贴出了，有兴趣的可以直接下载源码查看。<br>接下来得到builderMap的集合之后，由于findAndParseTargets方法返回值是Map&lt;TypeElement, BindingSet&gt;，因此接下来又对builderMap集合进行了遍历并最终存储到了 Map&lt;TypeElement, BindingSet&gt;中。代码如下：</p>\n<pre><code class=\"hljs reasonml\"><span class=\"hljs-keyword\">private</span> Map&lt;TypeElement, BindingSet&gt; find<span class=\"hljs-constructor\">AndParseTargets(RoundEnvironment <span class=\"hljs-params\">env</span>)</span> &#123;\n\t\t\n\t\t...\n\t\n\tDeque&lt;Map.Entry&lt;TypeElement, BindingSet.Builder&gt;&gt; entries =\n\t\t        <span class=\"hljs-keyword\">new</span> ArrayDeque&lt;&gt;(builderMap.entry<span class=\"hljs-constructor\">Set()</span>);\n\t\t    Map&lt;TypeElement, BindingSet&gt; bindingMap = <span class=\"hljs-keyword\">new</span> LinkedHashMap&lt;&gt;<span class=\"hljs-literal\">()</span>;\n\t\t    <span class=\"hljs-keyword\">while</span> (!entries.is<span class=\"hljs-constructor\">Empty()</span>) &#123;\n\t\t      Map.Entry&lt;TypeElement, BindingSet.Builder&gt; entry = entries.remove<span class=\"hljs-constructor\">First()</span>;\n\t\t\n\t\t      TypeElement <span class=\"hljs-keyword\">type</span> = entry.get<span class=\"hljs-constructor\">Key()</span>;\n\t\t      BindingSet.Builder builder = entry.get<span class=\"hljs-constructor\">Value()</span>;\n\t\t\n\t\t      TypeElement parentType = find<span class=\"hljs-constructor\">ParentType(<span class=\"hljs-params\">type</span>, <span class=\"hljs-params\">erasedTargetNames</span>)</span>;\n\t\t      <span class=\"hljs-keyword\">if</span> (parentType<span class=\"hljs-operator\"> == </span>null) &#123;\n\t\t        bindingMap.put(<span class=\"hljs-keyword\">type</span>, builder.build<span class=\"hljs-literal\">()</span>);\n\t\t      &#125; <span class=\"hljs-keyword\">else</span> &#123;\n\t\t        BindingSet parentBinding = bindingMap.get(parentType);\n\t\t        <span class=\"hljs-keyword\">if</span> (parentBinding != null) &#123;\n\t\t          builder.set<span class=\"hljs-constructor\">Parent(<span class=\"hljs-params\">parentBinding</span>)</span>;\n\t\t          bindingMap.put(<span class=\"hljs-keyword\">type</span>, builder.build<span class=\"hljs-literal\">()</span>);\n\t\t        &#125; <span class=\"hljs-keyword\">else</span> &#123;\n\t\t          <span class=\"hljs-comment\">// Has a superclass binding but we haven&#x27;t built it yet. Re-enqueue for later.</span>\n\t\t          entries.add<span class=\"hljs-constructor\">Last(<span class=\"hljs-params\">entry</span>)</span>;\n\t\t        &#125;\n\t\t      &#125;\n\t\t    &#125;\n\t\t&#125;\n\t&#125;</code></pre>\n<p>好了，接下来，继续到process方法中，在拿到bindingMap 之后遍历bindingMap ，并调用BindingSet的brewJava来生成Java文件，代码如下：</p>\n<pre><code class=\"hljs reasonml\">public boolean process(Set&lt;? extends TypeElement&gt; elements, RoundEnvironment env) &#123;\n    Map&lt;TypeElement, BindingSet&gt; bindingMap = find<span class=\"hljs-constructor\">AndParseTargets(<span class=\"hljs-params\">env</span>)</span>;\n\n    <span class=\"hljs-keyword\">for</span> (Map.Entry&lt;TypeElement, BindingSet&gt; entry : bindingMap.entry<span class=\"hljs-constructor\">Set()</span>) &#123;\n      TypeElement typeElement = entry.get<span class=\"hljs-constructor\">Key()</span>;\n      BindingSet binding = entry.get<span class=\"hljs-constructor\">Value()</span>;\n\n      JavaFile javaFile = binding.brew<span class=\"hljs-constructor\">Java(<span class=\"hljs-params\">sdk</span>, <span class=\"hljs-params\">debuggable</span>, <span class=\"hljs-params\">useAndroidX</span>)</span>;\n      <span class=\"hljs-keyword\">try</span> &#123;\n        javaFile.write<span class=\"hljs-constructor\">To(<span class=\"hljs-params\">filer</span>)</span>;\n      &#125; catch (IOException e) &#123;\n        error(typeElement, <span class=\"hljs-string\">&quot;Unable to write binding for type %s: %s&quot;</span>, typeElement, e.get<span class=\"hljs-constructor\">Message()</span>);\n      &#125;\n    &#125;\n\n    return <span class=\"hljs-literal\">false</span>;\n  &#125;</code></pre>\n\n<h2 id=\"3-JavaPoet生成代码\"><a href=\"#3-JavaPoet生成代码\" class=\"headerlink\" title=\"3.JavaPoet生成代码\"></a>3.JavaPoet生成代码</h2><p>BindingSet 的brewJava方法中同样是使用了JavaPoet来生成代码的，无非就是拼接类，构造方法、方法，这些感觉真的没什么说的了。</p>\n<pre><code class=\"hljs reasonml\">JavaFile brew<span class=\"hljs-constructor\">Java(<span class=\"hljs-params\">int</span> <span class=\"hljs-params\">sdk</span>, <span class=\"hljs-params\">boolean</span> <span class=\"hljs-params\">debuggable</span>, <span class=\"hljs-params\">boolean</span> <span class=\"hljs-params\">useAndroidX</span>)</span> &#123;\n    TypeSpec bindingConfiguration = create<span class=\"hljs-constructor\">Type(<span class=\"hljs-params\">sdk</span>, <span class=\"hljs-params\">debuggable</span>, <span class=\"hljs-params\">useAndroidX</span>)</span>;\n    return <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">JavaFile</span>.</span></span>builder(bindingClassName.package<span class=\"hljs-constructor\">Name()</span>, bindingConfiguration)\n        .add<span class=\"hljs-constructor\">FileComment(<span class=\"hljs-string\">&quot;Generated code from Butter Knife. Do not modify!&quot;</span>)</span>\n        .build<span class=\"hljs-literal\">()</span>;\n  &#125;</code></pre>\n\n<pre><code class=\"hljs reasonml\"><span class=\"hljs-keyword\">private</span> TypeSpec create<span class=\"hljs-constructor\">Type(<span class=\"hljs-params\">int</span> <span class=\"hljs-params\">sdk</span>, <span class=\"hljs-params\">boolean</span> <span class=\"hljs-params\">debuggable</span>, <span class=\"hljs-params\">boolean</span> <span class=\"hljs-params\">useAndroidX</span>)</span> &#123;\n    TypeSpec.Builder result = <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">TypeSpec</span>.</span></span><span class=\"hljs-keyword\">class</span><span class=\"hljs-constructor\">Builder(<span class=\"hljs-params\">bindingClassName</span>.<span class=\"hljs-params\">simpleName</span>()</span>)\n        .add<span class=\"hljs-constructor\">Modifiers(PUBLIC)</span>;\n    <span class=\"hljs-keyword\">if</span> (isFinal) &#123;\n      result.add<span class=\"hljs-constructor\">Modifiers(FINAL)</span>;\n    &#125;\n\n    <span class=\"hljs-keyword\">if</span> (parentBinding != null) &#123;\n      result.superclass(parentBinding.bindingClassName);\n    &#125; <span class=\"hljs-keyword\">else</span> &#123;\n      result.add<span class=\"hljs-constructor\">Superinterface(UNBINDER)</span>;\n    &#125;\n\n    <span class=\"hljs-keyword\">if</span> (has<span class=\"hljs-constructor\">TargetField()</span>) &#123;\n      result.add<span class=\"hljs-constructor\">Field(<span class=\"hljs-params\">targetTypeName</span>, <span class=\"hljs-string\">&quot;target&quot;</span>, PRIVATE)</span>;\n    &#125;\n\n    <span class=\"hljs-keyword\">if</span> (isView) &#123;\n      result.add<span class=\"hljs-constructor\">Method(<span class=\"hljs-params\">createBindingConstructorForView</span>(<span class=\"hljs-params\">useAndroidX</span>)</span>);\n    &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (isActivity) &#123;\n      result.add<span class=\"hljs-constructor\">Method(<span class=\"hljs-params\">createBindingConstructorForActivity</span>(<span class=\"hljs-params\">useAndroidX</span>)</span>);\n    &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (isDialog) &#123;\n      result.add<span class=\"hljs-constructor\">Method(<span class=\"hljs-params\">createBindingConstructorForDialog</span>(<span class=\"hljs-params\">useAndroidX</span>)</span>);\n    &#125;\n    <span class=\"hljs-keyword\">if</span> (!constructor<span class=\"hljs-constructor\">NeedsView()</span>) &#123;\n      <span class=\"hljs-comment\">// Add a delegating constructor with a target type + view signature for reflective use.</span>\n      result.add<span class=\"hljs-constructor\">Method(<span class=\"hljs-params\">createBindingViewDelegateConstructor</span>(<span class=\"hljs-params\">useAndroidX</span>)</span>);\n    &#125;\n    result.add<span class=\"hljs-constructor\">Method(<span class=\"hljs-params\">createBindingConstructor</span>(<span class=\"hljs-params\">sdk</span>, <span class=\"hljs-params\">debuggable</span>, <span class=\"hljs-params\">useAndroidX</span>)</span>);\n\n    <span class=\"hljs-keyword\">if</span> (has<span class=\"hljs-constructor\">ViewBindings()</span><span class=\"hljs-operator\"> || </span>parentBinding<span class=\"hljs-operator\"> == </span>null) &#123;\n      result.add<span class=\"hljs-constructor\">Method(<span class=\"hljs-params\">createBindingUnbindMethod</span>(<span class=\"hljs-params\">result</span>, <span class=\"hljs-params\">useAndroidX</span>)</span>);\n    &#125;\n\n    return result.build<span class=\"hljs-literal\">()</span>;\n  &#125;</code></pre>\n<p>关于ButterKnife的源码就说这么多吧。总结一下，其实就是根据注解使用APT及JavaPoet在项目编译期间自动生成代码，并达到为注解元素赋值或者添加监听的目的。在阅读Butterknife时候不一定要把每一句代码都搞懂，能做到掌握其核心原理便可。</p>\n","site":{"data":{"fluid_config":{"favicon":"/img/favicon.png","apple_touch_icon":"/img/favicon.png","title_join_string":" - ","force_https":false,"highlight":{"enable":true,"style":"Github Gist","bg_color":false,"copy_btn":true},"fun_features":{"typing":{"enable":true,"typeSpeed":70,"cursorChar":"|","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"mouse_click":{"enable":false,"style":"values"}},"dark_mode":{"enable":true,"default":"auto"},"color":{"body_bg_color":"#eee","body_bg_color_dark":"#181c27","navbar_bg_color":"#2f4154","navbar_bg_color_dark":"#1f3144","navbar_text_color":"#fff","navbar_text_color_dark":"#d0d0d0","text_color":"#3c4858","text_color_dark":"#c4c6c9","sec_text_color":"#718096","sec_text_color_dark":"#a7a9ad","post_text_color":"#2c3e50","post_text_color_dark":"#c4c6c9","post_heading_color":"#1a202c","post_heading_color_dark":"#c4c6c9","post_link_color":"#0366d6","post_link_color_dark":"#1589e9","link_hover_color":"#30a9de","link_hover_color_dark":"#30a9de","link_hover_bg_color":"#f8f9fa","link_hover_bg_color_dark":"#364151","board_color":"#fff","board_color_dark":"#252d38"},"font":{"font_size":"16px","font_family":null,"code_font_size":"85%"},"custom_js":null,"custom_css":null,"custom_html":"","web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"tajs":null,"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}},"lazyload":{"enable":true,"onlypost":false},"daovoice":{"enable":false,"appid":""},"aplayer":{"enable":false,"autoplay":false,"loop":"all","order":"random","theme":"#b7daff","songs":[{"name":"name","artist":"artist","url":"/songs/test.mp3","cover":"/img/cover.jpg"},{"name":"name","artist":"artist","url":"https://...url.mp3","cover":"https://...cover.jpg"}]},"version":{"check":false},"navbar":{"blog_title":"zhangpan","ground_glass":{"enable":false,"px":3,"alpha":0.7},"menu":[{"key":"home","link":"/","icon":"iconfont icon-home-fill"},{"key":"archive","link":"/archives/","icon":"iconfont icon-archive-fill"},{"key":"category","link":"/categories/","icon":"iconfont icon-category-fill"},{"key":"tag","link":"/tags/","icon":"iconfont icon-tags-fill"},{"key":"about","link":"/about/","icon":"iconfont icon-user-fill"}]},"search":{"enable":true,"path":"/local-search.xml","generate_path":"/local-search.xml","field":"post","content":true},"scroll_down_arrow":{"enable":true,"banner_height_limit":90,"scroll_after_turning_page":true},"banner_parallax":true,"footer":{"statistics":{"enable":false,"source":"busuanzi","pv_format":"总访问量 {} 次","uv_format":"总访客数 {} 人"},"beian":{"enable":false,"icp_text":"京ICP证123456号","police_text":"京公网安备12345678号","police_code":12345678,"police_icon":"/img/police_beian.png"}},"scroll_top_arrow":{"enable":true},"index":{"banner_img":"/img/default.png","banner_img_height":100,"banner_mask_alpha":0.3,"post_default_img":"","slogan":{"enable":true,"text":"Talk is cheap, show me the code."},"auto_excerpt":{"enable":true},"post_url_target":"_self","post_meta":{"date":true,"category":true,"tag":true}},"page":{"banner_img":"/img/default.png","banner_img_height":60,"banner_mask_alpha":0.3},"post":{"banner_img":"/img/default.png","banner_img_height":70,"banner_mask_alpha":0.3,"meta":{"date":{"enable":true,"format":"LL a"},"wordcount":{"enable":true,"format":"{} 字"},"min2read":{"enable":true,"format":"{} 分钟","words":100},"views":{"enable":false,"source":"busuanzi","format":"{} 次"}},"updated":{"enable":false,"content":"本文最后更新于：","relative":false},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"copyright":{"enable":true,"content":"本博客所有文章除特别声明外，均采用 <a href=\"https://creativecommons.org/licenses/by-sa/4.0/deed.zh\" rel=\"nofollow noopener\">CC BY-SA 4.0 协议</a> ，转载请注明出处！ <h5>开源库推荐</h5> <a href=\"https://github.com/zhpanvip/BannerViewPager\">1.BannerViewPager</a> <p> 一个基于ViewPager2实现的具有强大功能的无限轮播库。支持多种页面切换效果和指示器样式。 </p>\n<a href=\"https://github.com/zhpanvip/viewpagerindicator\">2.ViewPagerIndicator</a> <p> 一个适用于ViewPager和ViewPager2的指示器，支持多种滑块样式及滑动模式 </p>"},"prev_next":{"enable":true},"custom":{"enable":false,"content":"<img src=\"https://octodex.github.com/images/jetpacktocat.png\" class=\"rounded mx-auto d-block mt-5\" style=\"width:150px; height:150px;\">"},"image_zoom":{"enable":true},"footnote":{"enable":true,"header":""},"math":{"enable":false,"specific":false,"engine":"mathjax"},"mermaid":{"enable":false,"specific":false,"options":{"theme":"default"}},"comments":{"enable":true,"type":"utterances"}},"utterances":{"repo":"zhpanvip/utterances-comment","issue_term":"pathname","label":"utterances","theme":"github-light","crossorigin":"anonymous"},"disqus":{"shortname":null,"disqusjs":false,"apikey":null},"gitalk":{"clientID":null,"clientSecret":null,"repo":null,"owner":null,"admin":["name"],"id":"location.pathname","language":"zh-CN","labels":["Gitalk"],"perPage":10,"pagerDirection":"last","distractionFreeMode":false,"createIssueManually":true},"valine":{"appid":"hXIROaIM5y9qnieojJRWP5hS","appkey":"y0f3w3aqd1MF7JL9ma4WECTy","placeholder":"说点什么","path":"window.location.pathname","avatar":"retro","meta":["nick","mail","link"],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"https://zhangpan.site"},"changyan":{"appid":"","appkey":""},"livere":{"uid":""},"archive":{"banner_img":"/img/bg_article.jpg","banner_img_height":60,"banner_mask_alpha":0.3,"subtitle":null},"category":{"banner_img":"/img/bg_default.png","banner_img_height":60,"banner_mask_alpha":0.3,"subtitle":null,"post_limit":10,"order_by":"-length"},"tag":{"banner_img":"/img/bg_label.jpg","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null,"tagcloud":{"min_font":15,"max_font":30,"unit":"px","start_color":"#BBBBEE","end_color":"#337ab7"}},"about":{"banner_img":"/img/bg_default.png","banner_img_height":60,"banner_mask_alpha":0.3,"subtitle":null,"avatar":"/img/avatar.png","name":"myname","introduce":"一句简短的介绍","icons":[{"class":"iconfont icon-github-fill","link":"https://github.com","tip":"GitHub"},{"class":"iconfont icon-douban-fill","link":"https://douban.com","tip":"豆瓣"},{"class":"iconfont icon-wechat-fill","qrcode":"/img/favicon.png"}]},"page404":{"banner_img":"/img/default.png","banner_img_height":85,"banner_mask_alpha":0.3,"subtitle":"Page not found"},"links":{"banner_img":"/img/default.png","banner_img_height":60,"banner_mask_alpha":0.3,"subtitle":null,"items":[{"title":"Fluid Docs","intro":"主题使用指南","link":"https://hexo.fluid-dev.com/docs/","image":"/img/favicon.png"},{"title":"Fluid Repo","intro":"主题 GitHub 仓库","link":"https://github.com/fluid-dev/hexo-theme-fluid","image":"/img/favicon.png"},{"title":"Fluid Example","intro":"主题操作示例","link":"https://hexo.fluid-dev.com/docs/example/","image":"/img/favicon.png"}]}}}},"excerpt":"","more":"<p>上篇文章《Java编译时注解处理器（APT）详解》中学习了Java APT技术在Android中的使用，并且我们知道，当前Android开发中常用的许多框架都使用了APT技术，并且ButterKnife就是利用APT来实现的。那么本篇内容我们就来探究一下ButterKnife的实现原理。</p>\n<h1 id=\"一、ButterKnife的bind过程\"><a href=\"#一、ButterKnife的bind过程\" class=\"headerlink\" title=\"一、ButterKnife的bind过程\"></a>一、ButterKnife的bind过程</h1><p>当然，在探究源码，还是首先应该了解如何使用，我们以ButterKnife的BindView为例。首先在Activity的onCreate方法中通过ButterKnife.bind()方法绑定，然后为TextView添加BindView注解即可拿到TextView的实例。代码如下：</p>\n<pre><code class=\"hljs scala\"><span class=\"hljs-keyword\">package</span> com.zhpan.app;\n\npublic <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MainActivity</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">AppCompatActivity</span> </span>&#123;\n\t <span class=\"hljs-meta\">@BindView</span>(<span class=\"hljs-type\">R</span>.id.text_view)\n\t <span class=\"hljs-type\">TextView</span> mTextView;\n\t\n\t    <span class=\"hljs-meta\">@Override</span>\n\t    <span class=\"hljs-keyword\">protected</span> void onCreate(<span class=\"hljs-type\">Bundle</span> savedInstanceState) &#123;\n\t        <span class=\"hljs-keyword\">super</span>.onCreate(savedInstanceState);\n\t        setContentView(<span class=\"hljs-type\">R</span>.layout.activity_main);\n\t        <span class=\"hljs-type\">ButterKnife</span>.bind(<span class=\"hljs-keyword\">this</span>);\n\t    &#125;\n    &#125;</code></pre>\n<p>ButterKnife是怎么做到通过注解获取TextView的实例的呢？我们就从bind方法开始吧，点击ButterKnife的bind方法，其代码如下：</p>\n<pre><code class=\"hljs aspectj\"><span class=\"hljs-comment\">//\tButterKnife中有很多bind的重载方法，仅以此为例</span>\n <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-function\">Unbinder <span class=\"hljs-title\">bind</span><span class=\"hljs-params\">(@NonNull Activity <span class=\"hljs-keyword\">target</span>)</span> </span>&#123;\n    View sourceView = <span class=\"hljs-keyword\">target</span>.getWindow().getDecorView();\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">return</span> <span class=\"hljs-title\">createBinding</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">target</span>, sourceView)</span></span>;\n  &#125;</code></pre>\n<p>可以看到在bind方法中通过Activity拿到了DecorView（至于不懂DecorView是什么的同学可以自行Google）。然后调用了createBinding方法，并传入Activity对象和DecorView两个参数。我们追踪createBinding的代码如下：</p>\n<pre><code class=\"hljs typescript\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> Unbinder createBinding(<span class=\"hljs-meta\">@NonNull</span> <span class=\"hljs-built_in\">Object</span> target, <span class=\"hljs-meta\">@NonNull</span> View source) &#123;\n    Class&lt;?&gt; targetClass = target.getClass();\n    <span class=\"hljs-comment\">//\t获取到了与target相关的类的构造方法</span>\n    Constructor&lt;? <span class=\"hljs-keyword\">extends</span> Unbinder&gt; <span class=\"hljs-keyword\">constructor</span> = findBindingConstructorForClass(<span class=\"hljs-params\">targetClass</span>);\n\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">constructor</span> == null) &#123;\n      <span class=\"hljs-keyword\">return</span> Unbinder.EMPTY;\n    &#125;\n\n    <span class=\"hljs-comment\">//noinspection TryWithIdenticalCatches Resolves to API 19+ only type.</span>\n    <span class=\"hljs-keyword\">try</span> &#123;\n    <span class=\"hljs-comment\">//\t通过构造方法反射实例化了这个类，这个类接收两个参数，分别是上边的Activity和DecorView</span>\n      <span class=\"hljs-keyword\">return</span> constructor.newInstance(target, source);\n    &#125; <span class=\"hljs-keyword\">catch</span> (IllegalAccessException e) &#123;\n      <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> RuntimeException(<span class=\"hljs-string\">&quot;Unable to invoke &quot;</span> + <span class=\"hljs-keyword\">constructor</span>, e);\n    &#125; <span class=\"hljs-keyword\">catch</span> (InstantiationException e) &#123;\n      <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> RuntimeException(<span class=\"hljs-string\">&quot;Unable to invoke &quot;</span> + <span class=\"hljs-keyword\">constructor</span>, e);\n    &#125; <span class=\"hljs-keyword\">catch</span> (InvocationTargetException e) &#123;\n      Throwable cause = e.getCause();\n      <span class=\"hljs-keyword\">if</span> (cause <span class=\"hljs-keyword\">instanceof</span> RuntimeException) &#123;\n        <span class=\"hljs-keyword\">throw</span> (RuntimeException) cause;\n      &#125;\n      <span class=\"hljs-keyword\">if</span> (cause <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-built_in\">Error</span>) &#123;\n        <span class=\"hljs-keyword\">throw</span> (<span class=\"hljs-built_in\">Error</span>) cause;\n      &#125;\n      <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> RuntimeException(<span class=\"hljs-string\">&quot;Unable to create binding instance.&quot;</span>, cause);\n    &#125;\n  &#125;</code></pre>\n<p>上述代码中通过findBindingConstructorForClass()方法得到了某个类的构造方法，并在接下来的代码中通过反射 constructor.newInstance(target, source)实例化了这个类，我们点进findBindingConstructorForClass()方法看这里做了什么。</p>\n<pre><code class=\"hljs reasonml\"><span class=\"hljs-keyword\">private</span> static Constructor&lt;? extends Unbinder&gt; find<span class=\"hljs-constructor\">BindingConstructorForClass(Class&lt;?&gt; <span class=\"hljs-params\">cls</span>)</span> &#123;\n\t<span class=\"hljs-comment\">//\t从BINDINGS中获取cls对应的Unbinder</span>\n    Constructor&lt;? extends Unbinder&gt; bindingCtor = <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">BINDINGS</span>.</span></span>get(cls);\n    <span class=\"hljs-keyword\">if</span> (bindingCtor != null) &#123; 如果已存在直接return\n      <span class=\"hljs-keyword\">if</span> (debug) <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">Log</span>.</span></span>d(TAG, <span class=\"hljs-string\">&quot;HIT: Cached in binding map.&quot;</span>);\n      return bindingCtor;\n    &#125;\n    <span class=\"hljs-comment\">//\t这里拿到的clsName应该为“com.zhpan.app.MainActivity”</span>\n    String clsName = cls.get<span class=\"hljs-constructor\">Name()</span>;\n    <span class=\"hljs-keyword\">if</span> (clsName.starts<span class=\"hljs-constructor\">With(<span class=\"hljs-string\">&quot;android.&quot;</span>)</span><span class=\"hljs-operator\"> || </span>clsName.starts<span class=\"hljs-constructor\">With(<span class=\"hljs-string\">&quot;java.&quot;</span>)</span>) &#123;\n      <span class=\"hljs-keyword\">if</span> (debug) <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">Log</span>.</span></span>d(TAG, <span class=\"hljs-string\">&quot;MISS: Reached framework class. Abandoning search.&quot;</span>);\n      return null;\n    &#125;\n    <span class=\"hljs-keyword\">try</span> &#123;\n    <span class=\"hljs-comment\">//\t从类加载器中获取“com.zhpan.app.MainActivity_ViewBinding”</span>\n      Class&lt;?&gt; bindingClass = cls.get<span class=\"hljs-constructor\">ClassLoader()</span>.load<span class=\"hljs-constructor\">Class(<span class=\"hljs-params\">clsName</span> + <span class=\"hljs-string\">&quot;_ViewBinding&quot;</span>)</span>;\n      <span class=\"hljs-comment\">// 获取“com.zhpan.app.MainActivity_ViewBinding”类中的构造方法</span>\n      bindingCtor = (Constructor&lt;? extends Unbinder&gt;) bindingClass.get<span class=\"hljs-constructor\">Constructor(<span class=\"hljs-params\">cls</span>, View.<span class=\"hljs-params\">class</span>)</span>;\n    &#125; catch (ClassNotFoundException e) &#123;\n      <span class=\"hljs-keyword\">if</span> (debug) <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">Log</span>.</span></span>d(TAG, <span class=\"hljs-string\">&quot;Not found. Trying superclass &quot;</span> + cls.get<span class=\"hljs-constructor\">Superclass()</span>.get<span class=\"hljs-constructor\">Name()</span>);\n      bindingCtor = find<span class=\"hljs-constructor\">BindingConstructorForClass(<span class=\"hljs-params\">cls</span>.<span class=\"hljs-params\">getSuperclass</span>()</span>);\n    &#125; catch (NoSuchMethodException e) &#123;\n      throw <span class=\"hljs-keyword\">new</span> <span class=\"hljs-constructor\">RuntimeException(<span class=\"hljs-string\">&quot;Unable to find binding constructor for &quot;</span> + <span class=\"hljs-params\">clsName</span>, <span class=\"hljs-params\">e</span>)</span>;\n    &#125;\n    <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">BINDINGS</span>.</span></span>put(cls, bindingCtor);\n    return bindingCtor;\n  &#125;</code></pre>\n<p>直接看第7行，通过 cls.getName()得到了bind方法中参数的名字，由于我们是再MainActivity中调用的bind方法，因此，这里拿到的名字就是“com.zhpan.app.MainActivity”,接下来再第13行中通过ClassLoader拿到了一个名字是”clsName”+”_ViewBinding”的类，也就是名字为MainActivity_ViewBinding的类。我们在项目里搜索一下，发现果真能找到这个类，其代码如下：</p>\n<pre><code class=\"hljs aspectj\"><span class=\"hljs-keyword\">package</span> com.zhpan.app;\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MainActivity_ViewBinding</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">Unbinder</span> </span>&#123;\n  <span class=\"hljs-keyword\">private</span> MainActivity <span class=\"hljs-keyword\">target</span>;\n\n  <span class=\"hljs-meta\">@UiThread</span>\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">MainActivity_ViewBinding</span><span class=\"hljs-params\">(MainActivity <span class=\"hljs-keyword\">target</span>)</span> </span>&#123;\n    <span class=\"hljs-keyword\">this</span>(<span class=\"hljs-keyword\">target</span>, <span class=\"hljs-keyword\">target</span>.getWindow().getDecorView());\n  &#125;\n\n  <span class=\"hljs-meta\">@UiThread</span>\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">MainActivity_ViewBinding</span><span class=\"hljs-params\">(MainActivity <span class=\"hljs-keyword\">target</span>, View source)</span> </span>&#123;\n    <span class=\"hljs-keyword\">this</span>.<span class=\"hljs-keyword\">target</span> = <span class=\"hljs-keyword\">target</span>;\n\n    <span class=\"hljs-keyword\">target</span>.mTextView = Utils.findRequiredViewAsType(source, R.id.text_view, <span class=\"hljs-string\">&quot;field &#x27;mTextView&#x27;&quot;</span>, TextView.class);\n  &#125;\n\n  <span class=\"hljs-meta\">@Override</span>\n  <span class=\"hljs-meta\">@CallSuper</span>\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">unbind</span><span class=\"hljs-params\">()</span> </span>&#123;\n    MainActivity <span class=\"hljs-keyword\">target</span> = <span class=\"hljs-keyword\">this</span>.<span class=\"hljs-keyword\">target</span>;\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">target</span> == <span class=\"hljs-keyword\">null</span>) <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> IllegalStateException(<span class=\"hljs-string\">&quot;Bindings already cleare![在这里插入图片描述](https://img-blog.csdnimg.cn/20190825162306549.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwNTIxNTcz,size_16,color_FFFFFF,t_70)d.&quot;</span>);\n    <span class=\"hljs-keyword\">this</span>.<span class=\"hljs-keyword\">target</span> = <span class=\"hljs-keyword\">null</span>;\n\n    <span class=\"hljs-keyword\">target</span>.mTextView = <span class=\"hljs-keyword\">null</span>;\n  &#125;\n&#125;</code></pre>\n<p>在这个类的构造方法中我们可以看到</p>\n<pre><code class=\"hljs reasonml\">target.mTextView = <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">Utils</span>.</span></span>find<span class=\"hljs-constructor\">RequiredViewAsType(<span class=\"hljs-params\">source</span>, R.<span class=\"hljs-params\">id</span>.<span class=\"hljs-params\">text_view</span>, <span class=\"hljs-string\">&quot;field &#x27;mTextView&#x27;&quot;</span>, TextView.<span class=\"hljs-params\">class</span>)</span>;</code></pre>\n<p>通过这句代码给Activity中的mTextView赋了值，到这里也就不奇怪为什通过一个BindView的注解就得到了mTextView的对象了。而MainActivity_ViewBinding这个类是从哪里来的呢？想必看过上篇文章同学应该都知道了，就是通过APT在代码编译期间自动生成的。其实后面的代码其实已经没有必要去看了，无非就是通过AbstractProcessor来处理注解，然后根据注解自动生成所需代码的。但是写文章要有始有终，也本着负责任的态度，还是深入ButtereKnife内部一探究竟。</p>\n<h1 id=\"二、探究ButterKnife的注解处理器ButterKnifeProcessor\"><a href=\"#二、探究ButterKnife的注解处理器ButterKnifeProcessor\" class=\"headerlink\" title=\"二、探究ButterKnife的注解处理器ButterKnifeProcessor\"></a>二、探究ButterKnife的注解处理器ButterKnifeProcessor</h1><p>现在我们来看一下ButterKnife的代码的模块结构：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190825162330432.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwNTIxNTcz,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>看到butterknife-annotations和butterknife-compiler很眼熟？和上篇文章我们自己写的代码结构是一样的，butterknife-annotations模块下存放的是butterknife的所有注解，butterknife-compiler是用来处理butterknife-annotations注解的。所以们直接看butterknife-compiler模块下的ButterKnifeProcessor类。</p>\n<h2 id=\"1-ButterKnifeProcessor的getSupportedAnnotationTypes-方法\"><a href=\"#1-ButterKnifeProcessor的getSupportedAnnotationTypes-方法\" class=\"headerlink\" title=\"1.ButterKnifeProcessor的getSupportedAnnotationTypes()方法\"></a>1.ButterKnifeProcessor的getSupportedAnnotationTypes()方法</h2><p>我们知道ButterKnife除了BindView注解之外还有许多其它注解，比如常用的BindColor注解、OnClick注解等。这些注解的名字都会被添加到getSupportedAnnotationTypes方法中的Set集合里。来看getSupportedAnnotationTypes的源码：</p>\n<pre><code class=\"hljs crystal\">@Override public Set&lt;String&gt; getSupportedAnnotationTypes() &#123;\n    Set&lt;String&gt; types = new LinkedHashSet&lt;&gt;();\n    /<span class=\"hljs-regexp\">/\t遍历ButterKnife中的所有注解，并将注解名字添加到Set集合</span>\n<span class=\"hljs-regexp\">    for (Class&lt;? extends Annotation&gt; annotation : getSupportedAnnotations()) &#123;</span>\n<span class=\"hljs-regexp\">      types.add(annotation.getCanonicalName());</span>\n<span class=\"hljs-regexp\">    &#125;</span>\n<span class=\"hljs-regexp\">    return types;</span>\n<span class=\"hljs-regexp\">  &#125;</span></code></pre>\n\n<h2 id=\"2-ButterKnifeProcessor的process方法\"><a href=\"#2-ButterKnifeProcessor的process方法\" class=\"headerlink\" title=\"2.ButterKnifeProcessor的process方法\"></a>2.ButterKnifeProcessor的process方法</h2><p>我们知道process方法是整个注解处理其的核心方法，对注解的处理以及代码的生成都是在这个方法里边实现的。那么接下来，就一步步看ButterKnife是怎么处理注解和生成代码的。<br>**(1)解析RoundEnviroment**<br>在process方法的第一行我们看到通过findAndParseTargets方法得到了一个 Map&lt;TypeElement, BindingSet&gt;集合，代码如下：</p>\n<pre><code class=\"hljs lasso\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-built_in\">boolean</span> process(<span class=\"hljs-built_in\">Set</span>&lt;? extends TypeElement&gt; elements, RoundEnvironment env) &#123;\n    <span class=\"hljs-comment\">//\t通过findAndParseTargets处理注解得到BindingSet的集合</span>\n    <span class=\"hljs-built_in\">Map</span>&lt;TypeElement, BindingSet&gt; bindingMap = findAndParseTargets(env);\n    \n     <span class=\"hljs-params\">...</span>\n  \n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;\n  &#125;</code></pre>\n<p>而在findAndParseTargets(env)是对一系列注解的处理，这里我们仅以处理BindView为例：</p>\n<pre><code class=\"hljs reasonml\"><span class=\"hljs-keyword\">private</span> Map&lt;TypeElement, BindingSet&gt; find<span class=\"hljs-constructor\">AndParseTargets(RoundEnvironment <span class=\"hljs-params\">env</span>)</span> &#123;\n    Map&lt;TypeElement, BindingSet.Builder&gt; builderMap = <span class=\"hljs-keyword\">new</span> LinkedHashMap&lt;&gt;<span class=\"hljs-literal\">()</span>;\n    Set&lt;TypeElement&gt; erasedTargetNames = <span class=\"hljs-keyword\">new</span> LinkedHashSet&lt;&gt;<span class=\"hljs-literal\">()</span>;\n\n    <span class=\"hljs-keyword\">for</span> (Element element : env.get<span class=\"hljs-constructor\">ElementsAnnotatedWith(BindView.<span class=\"hljs-params\">class</span>)</span>) &#123;\n      <span class=\"hljs-keyword\">try</span> &#123;\n        parse<span class=\"hljs-constructor\">BindView(<span class=\"hljs-params\">element</span>, <span class=\"hljs-params\">builderMap</span>, <span class=\"hljs-params\">erasedTargetNames</span>)</span>;\n      &#125; catch (Exception e) &#123;\n        log<span class=\"hljs-constructor\">ParsingError(<span class=\"hljs-params\">element</span>, BindView.<span class=\"hljs-params\">class</span>, <span class=\"hljs-params\">e</span>)</span>;\n      &#125;\n    &#125;\n\n\t<span class=\"hljs-comment\">//\t省略处理其它注解的代码</span>\n\t\t...</code></pre>\n<p>第9行在parseBindView方法中对BindView注解进行了一系列的校验，通过校验后解析BindView的数据，比如view的Id等信息封装到了BindingSet.Builder中,并最终将封装好的BindingSet.Builder放入builderMap 中。由于parseBindView方法的代码比较多，这里就不再贴出了，有兴趣的可以直接下载源码查看。<br>接下来得到builderMap的集合之后，由于findAndParseTargets方法返回值是Map&lt;TypeElement, BindingSet&gt;，因此接下来又对builderMap集合进行了遍历并最终存储到了 Map&lt;TypeElement, BindingSet&gt;中。代码如下：</p>\n<pre><code class=\"hljs reasonml\"><span class=\"hljs-keyword\">private</span> Map&lt;TypeElement, BindingSet&gt; find<span class=\"hljs-constructor\">AndParseTargets(RoundEnvironment <span class=\"hljs-params\">env</span>)</span> &#123;\n\t\t\n\t\t...\n\t\n\tDeque&lt;Map.Entry&lt;TypeElement, BindingSet.Builder&gt;&gt; entries =\n\t\t        <span class=\"hljs-keyword\">new</span> ArrayDeque&lt;&gt;(builderMap.entry<span class=\"hljs-constructor\">Set()</span>);\n\t\t    Map&lt;TypeElement, BindingSet&gt; bindingMap = <span class=\"hljs-keyword\">new</span> LinkedHashMap&lt;&gt;<span class=\"hljs-literal\">()</span>;\n\t\t    <span class=\"hljs-keyword\">while</span> (!entries.is<span class=\"hljs-constructor\">Empty()</span>) &#123;\n\t\t      Map.Entry&lt;TypeElement, BindingSet.Builder&gt; entry = entries.remove<span class=\"hljs-constructor\">First()</span>;\n\t\t\n\t\t      TypeElement <span class=\"hljs-keyword\">type</span> = entry.get<span class=\"hljs-constructor\">Key()</span>;\n\t\t      BindingSet.Builder builder = entry.get<span class=\"hljs-constructor\">Value()</span>;\n\t\t\n\t\t      TypeElement parentType = find<span class=\"hljs-constructor\">ParentType(<span class=\"hljs-params\">type</span>, <span class=\"hljs-params\">erasedTargetNames</span>)</span>;\n\t\t      <span class=\"hljs-keyword\">if</span> (parentType<span class=\"hljs-operator\"> == </span>null) &#123;\n\t\t        bindingMap.put(<span class=\"hljs-keyword\">type</span>, builder.build<span class=\"hljs-literal\">()</span>);\n\t\t      &#125; <span class=\"hljs-keyword\">else</span> &#123;\n\t\t        BindingSet parentBinding = bindingMap.get(parentType);\n\t\t        <span class=\"hljs-keyword\">if</span> (parentBinding != null) &#123;\n\t\t          builder.set<span class=\"hljs-constructor\">Parent(<span class=\"hljs-params\">parentBinding</span>)</span>;\n\t\t          bindingMap.put(<span class=\"hljs-keyword\">type</span>, builder.build<span class=\"hljs-literal\">()</span>);\n\t\t        &#125; <span class=\"hljs-keyword\">else</span> &#123;\n\t\t          <span class=\"hljs-comment\">// Has a superclass binding but we haven&#x27;t built it yet. Re-enqueue for later.</span>\n\t\t          entries.add<span class=\"hljs-constructor\">Last(<span class=\"hljs-params\">entry</span>)</span>;\n\t\t        &#125;\n\t\t      &#125;\n\t\t    &#125;\n\t\t&#125;\n\t&#125;</code></pre>\n<p>好了，接下来，继续到process方法中，在拿到bindingMap 之后遍历bindingMap ，并调用BindingSet的brewJava来生成Java文件，代码如下：</p>\n<pre><code class=\"hljs reasonml\">public boolean process(Set&lt;? extends TypeElement&gt; elements, RoundEnvironment env) &#123;\n    Map&lt;TypeElement, BindingSet&gt; bindingMap = find<span class=\"hljs-constructor\">AndParseTargets(<span class=\"hljs-params\">env</span>)</span>;\n\n    <span class=\"hljs-keyword\">for</span> (Map.Entry&lt;TypeElement, BindingSet&gt; entry : bindingMap.entry<span class=\"hljs-constructor\">Set()</span>) &#123;\n      TypeElement typeElement = entry.get<span class=\"hljs-constructor\">Key()</span>;\n      BindingSet binding = entry.get<span class=\"hljs-constructor\">Value()</span>;\n\n      JavaFile javaFile = binding.brew<span class=\"hljs-constructor\">Java(<span class=\"hljs-params\">sdk</span>, <span class=\"hljs-params\">debuggable</span>, <span class=\"hljs-params\">useAndroidX</span>)</span>;\n      <span class=\"hljs-keyword\">try</span> &#123;\n        javaFile.write<span class=\"hljs-constructor\">To(<span class=\"hljs-params\">filer</span>)</span>;\n      &#125; catch (IOException e) &#123;\n        error(typeElement, <span class=\"hljs-string\">&quot;Unable to write binding for type %s: %s&quot;</span>, typeElement, e.get<span class=\"hljs-constructor\">Message()</span>);\n      &#125;\n    &#125;\n\n    return <span class=\"hljs-literal\">false</span>;\n  &#125;</code></pre>\n\n<h2 id=\"3-JavaPoet生成代码\"><a href=\"#3-JavaPoet生成代码\" class=\"headerlink\" title=\"3.JavaPoet生成代码\"></a>3.JavaPoet生成代码</h2><p>BindingSet 的brewJava方法中同样是使用了JavaPoet来生成代码的，无非就是拼接类，构造方法、方法，这些感觉真的没什么说的了。</p>\n<pre><code class=\"hljs reasonml\">JavaFile brew<span class=\"hljs-constructor\">Java(<span class=\"hljs-params\">int</span> <span class=\"hljs-params\">sdk</span>, <span class=\"hljs-params\">boolean</span> <span class=\"hljs-params\">debuggable</span>, <span class=\"hljs-params\">boolean</span> <span class=\"hljs-params\">useAndroidX</span>)</span> &#123;\n    TypeSpec bindingConfiguration = create<span class=\"hljs-constructor\">Type(<span class=\"hljs-params\">sdk</span>, <span class=\"hljs-params\">debuggable</span>, <span class=\"hljs-params\">useAndroidX</span>)</span>;\n    return <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">JavaFile</span>.</span></span>builder(bindingClassName.package<span class=\"hljs-constructor\">Name()</span>, bindingConfiguration)\n        .add<span class=\"hljs-constructor\">FileComment(<span class=\"hljs-string\">&quot;Generated code from Butter Knife. Do not modify!&quot;</span>)</span>\n        .build<span class=\"hljs-literal\">()</span>;\n  &#125;</code></pre>\n\n<pre><code class=\"hljs reasonml\"><span class=\"hljs-keyword\">private</span> TypeSpec create<span class=\"hljs-constructor\">Type(<span class=\"hljs-params\">int</span> <span class=\"hljs-params\">sdk</span>, <span class=\"hljs-params\">boolean</span> <span class=\"hljs-params\">debuggable</span>, <span class=\"hljs-params\">boolean</span> <span class=\"hljs-params\">useAndroidX</span>)</span> &#123;\n    TypeSpec.Builder result = <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">TypeSpec</span>.</span></span><span class=\"hljs-keyword\">class</span><span class=\"hljs-constructor\">Builder(<span class=\"hljs-params\">bindingClassName</span>.<span class=\"hljs-params\">simpleName</span>()</span>)\n        .add<span class=\"hljs-constructor\">Modifiers(PUBLIC)</span>;\n    <span class=\"hljs-keyword\">if</span> (isFinal) &#123;\n      result.add<span class=\"hljs-constructor\">Modifiers(FINAL)</span>;\n    &#125;\n\n    <span class=\"hljs-keyword\">if</span> (parentBinding != null) &#123;\n      result.superclass(parentBinding.bindingClassName);\n    &#125; <span class=\"hljs-keyword\">else</span> &#123;\n      result.add<span class=\"hljs-constructor\">Superinterface(UNBINDER)</span>;\n    &#125;\n\n    <span class=\"hljs-keyword\">if</span> (has<span class=\"hljs-constructor\">TargetField()</span>) &#123;\n      result.add<span class=\"hljs-constructor\">Field(<span class=\"hljs-params\">targetTypeName</span>, <span class=\"hljs-string\">&quot;target&quot;</span>, PRIVATE)</span>;\n    &#125;\n\n    <span class=\"hljs-keyword\">if</span> (isView) &#123;\n      result.add<span class=\"hljs-constructor\">Method(<span class=\"hljs-params\">createBindingConstructorForView</span>(<span class=\"hljs-params\">useAndroidX</span>)</span>);\n    &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (isActivity) &#123;\n      result.add<span class=\"hljs-constructor\">Method(<span class=\"hljs-params\">createBindingConstructorForActivity</span>(<span class=\"hljs-params\">useAndroidX</span>)</span>);\n    &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (isDialog) &#123;\n      result.add<span class=\"hljs-constructor\">Method(<span class=\"hljs-params\">createBindingConstructorForDialog</span>(<span class=\"hljs-params\">useAndroidX</span>)</span>);\n    &#125;\n    <span class=\"hljs-keyword\">if</span> (!constructor<span class=\"hljs-constructor\">NeedsView()</span>) &#123;\n      <span class=\"hljs-comment\">// Add a delegating constructor with a target type + view signature for reflective use.</span>\n      result.add<span class=\"hljs-constructor\">Method(<span class=\"hljs-params\">createBindingViewDelegateConstructor</span>(<span class=\"hljs-params\">useAndroidX</span>)</span>);\n    &#125;\n    result.add<span class=\"hljs-constructor\">Method(<span class=\"hljs-params\">createBindingConstructor</span>(<span class=\"hljs-params\">sdk</span>, <span class=\"hljs-params\">debuggable</span>, <span class=\"hljs-params\">useAndroidX</span>)</span>);\n\n    <span class=\"hljs-keyword\">if</span> (has<span class=\"hljs-constructor\">ViewBindings()</span><span class=\"hljs-operator\"> || </span>parentBinding<span class=\"hljs-operator\"> == </span>null) &#123;\n      result.add<span class=\"hljs-constructor\">Method(<span class=\"hljs-params\">createBindingUnbindMethod</span>(<span class=\"hljs-params\">result</span>, <span class=\"hljs-params\">useAndroidX</span>)</span>);\n    &#125;\n\n    return result.build<span class=\"hljs-literal\">()</span>;\n  &#125;</code></pre>\n<p>关于ButterKnife的源码就说这么多吧。总结一下，其实就是根据注解使用APT及JavaPoet在项目编译期间自动生成代码，并达到为注解元素赋值或者添加监听的目的。在阅读Butterknife时候不一定要把每一句代码都搞懂，能做到掌握其核心原理便可。</p>\n"},{"title":"浅析Java设计模式（二）","date":"2016-07-25T02:21:45.000Z","_content":"\n上篇文章我们学习了几种创建型模式 的设计模式，那么本篇文章就继续来学习一下结构型模式的几个常用设计模式。\n\n一、代理模式（Proxy Pattern）\n------\n代理模式即为其它对象提供一种代理控制对这个对象的访问。在代理模式中，一个类代表另一个类的功能。这种类型的设计模式属于结构型模式。在代理模式中，我们创建具有现有对象的对象，以便向外界提供功能接口。代理模式的机构图如下：\n![静态代理](https://raw.githubusercontent.com/zhpanvip/Resource/master/image/0201.png)\n\nSubject类中定义一个抽象request()方法,RealSubject和Proxy共用接口，这样就在任何使用RealSubject的地方都可以使用Proxy。\n1.Subject类代码如下：\n\n```\npublic abstract class Subject {\n\tpublic abstract void request();\n}\n```\n2.RealSubject集成Subject类\n\n```\npublic class RealSubject extends Subject{\n\n\t@Override\n\tpublic void request() {\n\t\tSystem.out.println(\"Real Request\");\n\t}\n}\n```\n3.Proxy实现Subject类\n\n```\npublic class Proxy extends Subject {\n\tprivate RealSubject mRealSubject;\n\t\n\t@Override\n\tpublic void request() {\n\t\tif(mRealSubject==null) {\n\t\t\tmRealSubject=new RealSubject();\n\t\t}\n\t\tmRealSubject.request();\n\t}\n}\n```\n4.代理测试类\n\n```\npublic class ProxyTest {\n\n\tpublic static void main(String[] args) {\n\t\tProxy proxy=new Proxy();\n\t\tproxy.request();\n\t}\n}\n```\n输出结果：\n\n> Real Request\n\n二、装饰模式（Decorator Pattern）\n-------------------------\n装饰模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装。\n\n我们将创建一个 Shape 接口和实现了 Shape 接口的实体类。然后我们创建一个实现了 Shape 接口的抽象装饰类 ShapeDecorator，并把 Shape 对象作为它的实例变量。RedShapeDecorator 是实现了 ShapeDecorator 的实体类。DecoratorPatternDemo，我们的演示类使用 RedShapeDecorator 来装饰 Shape 对象。UML图如下：\n![装饰模式](https://raw.githubusercontent.com/zhpanvip/Resource/master/image/0202.jfif)\n\n1.创建Shape接口\n\n```\npublic interface Shape {\n\tvoid draw();\n}\n```\n2.创建Circle类和Rectangle类并实现Shape接口\n\n```\npublic class Circle implements Shape {\n\n\t@Override\n\tpublic void draw() {\n\t\tSystem.out.println(\"Draw Circle\");\n\t}\n\n}\n\n\npublic class Rectangle implements Shape {\n\n\t@Override\n\tpublic void draw() {\n\t\tSystem.out.println(\"Draw Rectangle\");\n\t}\n\n}\n```\n3.创建实现了 Shape 接口的抽象装饰类\n\n```\npublic abstract class ShapeDecorator implements Shape {\n\tprotected Shape decoratedShape;\n\t\n\tpublic ShapeDecorator(Shape decoratedShape) {\n\t\tthis.decoratedShape=decoratedShape;\n\t}\n\t\n\tpublic void draw() {\n\t\tdecoratedShape.draw();\n\t}\n}\n```\n4.创建RedShapeDecorator装饰类并继承ShapeDecorator\n\n```\npublic class RedShapeDecorator extends ShapeDecorator  {\n\n\tpublic RedShapeDecorator(Shape decoratedShape) {\n\t\tsuper(decoratedShape);\n\t}\n\t\n\t@Override\n\tpublic void draw() {\n\t\tdecoratedShape.draw();\n\t\tsetRedBorder(decoratedShape);\n\t}\n\t\n\tprivate void setRedBorder(Shape decoratedShape) {\n\t\tSystem.out.println(\"Red Border Corlor\");\n\t}\n\n}\n```\n5.装饰模式测试类\n\n```\npublic class DecoratorTest {\n\tpublic static void main(String[] args) {\n\t\tShape circle=new Circle();\n\t\tShape redCircle=new RedShapeDecorator(new Circle());\n\t\t\n\t\tShape redRectangle=new RedShapeDecorator(new Rectangle());\n\t\tSystem.out.println(\"Circle with normal border\");\n\t\tcircle.draw();\n\t\t\n\t\tSystem.out.println(\"Circle whit red border\");\n\t\tredCircle.draw();\n\t\t\n\t\tSystem.out.println(\"Rectangle with red border\");\n\t\tredRectangle.draw();\n\t\t\n\t}\n}\n```\n输出结果：\n\n> Circle with normal border\nDraw Circle\nCircle whit red border\nDraw Circle\nRed Border Corlor\nRectangle with red border\nDraw Rectangle\nRed Border Corlor\n\n三、适配器模式\n-------\n适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁。这种类型的设计模式属于结构型模式，它结合了两个独立接口的功能。通常来说，在软件开发中，系统的数据和行为都正确，但接口不符合时，我们应该考虑用适配器，目的是使控制范围之外的一个原有对象与某个接口匹配。\n\n现在假定在我们的应用中使用了两种地图，分别是Google地图和Baidu地图。这两个地图接口对我们而言是隐藏不可修改的，但是由于我们应用的特殊需求，可能会使用两个地图获取位置。那么此时我们就可以用适配器模式来实现。\n1.当前我们拥有百度地图和Google地图两个接口均可以获取地理位置。\n\n```\npublic class BaiduMap {\n\tpublic String getBaiduLocation() {\n\t\treturn \"this is baidu location\";\n\t}\n}\n\n\npublic class GoogleMap {\n\tpublic String getGoogleLocation() {\n\t\treturn \"this is Google location\";\n\t}\n}\n```\n\n2.创建一个Map接口\n\n```\npublic interface Map {\n\tString getLocation(String mapType);\n}\n```\n3.创建LocationAdapter实现Map接口\n\n```\npublic class LocationAdapter implements Map {\n\t@Override\n\tpublic String getLocation(String mapType) {\n\t\tString location=\"\";\n\t\tswitch(mapType) {\n\t\t\tcase \"Baidu\":\n\t\t\t\tlocation=new BaiduMap().getBaiduLocation();\n\t\t\t\tbreak;\n\t\t\tcase \"Google\":\n\t\t\t\tlocation=new GoogleMap().getGoogleLocation();\n\t\t\t\tbreak;\n\t\t}\n\t\treturn location;\n\t}\n}\n```\n3.测试适配器模式\n\n```\npublic class AdapterTest {\n\n\tpublic static void main(String[] args) {\n\t\tLocationAdapter adapter=new LocationAdapter();\n\t\tSystem.out.println(adapter.getLocation(\"Baidu\"));\n\t\tSystem.out.println(adapter.getLocation(\"Google\"));\n\t}\n\n}\n```\n输出结果：\n\n> this is baidu location\nthis is Google location\n\n","source":"_posts/2.浅析Java设计模式（二）.md","raw":"---\ntitle: 浅析Java设计模式（二）\ndate: 2016-07-25 10:21:45 \ntags:\n- 设计模式\n---\n\n上篇文章我们学习了几种创建型模式 的设计模式，那么本篇文章就继续来学习一下结构型模式的几个常用设计模式。\n\n一、代理模式（Proxy Pattern）\n------\n代理模式即为其它对象提供一种代理控制对这个对象的访问。在代理模式中，一个类代表另一个类的功能。这种类型的设计模式属于结构型模式。在代理模式中，我们创建具有现有对象的对象，以便向外界提供功能接口。代理模式的机构图如下：\n![静态代理](https://raw.githubusercontent.com/zhpanvip/Resource/master/image/0201.png)\n\nSubject类中定义一个抽象request()方法,RealSubject和Proxy共用接口，这样就在任何使用RealSubject的地方都可以使用Proxy。\n1.Subject类代码如下：\n\n```\npublic abstract class Subject {\n\tpublic abstract void request();\n}\n```\n2.RealSubject集成Subject类\n\n```\npublic class RealSubject extends Subject{\n\n\t@Override\n\tpublic void request() {\n\t\tSystem.out.println(\"Real Request\");\n\t}\n}\n```\n3.Proxy实现Subject类\n\n```\npublic class Proxy extends Subject {\n\tprivate RealSubject mRealSubject;\n\t\n\t@Override\n\tpublic void request() {\n\t\tif(mRealSubject==null) {\n\t\t\tmRealSubject=new RealSubject();\n\t\t}\n\t\tmRealSubject.request();\n\t}\n}\n```\n4.代理测试类\n\n```\npublic class ProxyTest {\n\n\tpublic static void main(String[] args) {\n\t\tProxy proxy=new Proxy();\n\t\tproxy.request();\n\t}\n}\n```\n输出结果：\n\n> Real Request\n\n二、装饰模式（Decorator Pattern）\n-------------------------\n装饰模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装。\n\n我们将创建一个 Shape 接口和实现了 Shape 接口的实体类。然后我们创建一个实现了 Shape 接口的抽象装饰类 ShapeDecorator，并把 Shape 对象作为它的实例变量。RedShapeDecorator 是实现了 ShapeDecorator 的实体类。DecoratorPatternDemo，我们的演示类使用 RedShapeDecorator 来装饰 Shape 对象。UML图如下：\n![装饰模式](https://raw.githubusercontent.com/zhpanvip/Resource/master/image/0202.jfif)\n\n1.创建Shape接口\n\n```\npublic interface Shape {\n\tvoid draw();\n}\n```\n2.创建Circle类和Rectangle类并实现Shape接口\n\n```\npublic class Circle implements Shape {\n\n\t@Override\n\tpublic void draw() {\n\t\tSystem.out.println(\"Draw Circle\");\n\t}\n\n}\n\n\npublic class Rectangle implements Shape {\n\n\t@Override\n\tpublic void draw() {\n\t\tSystem.out.println(\"Draw Rectangle\");\n\t}\n\n}\n```\n3.创建实现了 Shape 接口的抽象装饰类\n\n```\npublic abstract class ShapeDecorator implements Shape {\n\tprotected Shape decoratedShape;\n\t\n\tpublic ShapeDecorator(Shape decoratedShape) {\n\t\tthis.decoratedShape=decoratedShape;\n\t}\n\t\n\tpublic void draw() {\n\t\tdecoratedShape.draw();\n\t}\n}\n```\n4.创建RedShapeDecorator装饰类并继承ShapeDecorator\n\n```\npublic class RedShapeDecorator extends ShapeDecorator  {\n\n\tpublic RedShapeDecorator(Shape decoratedShape) {\n\t\tsuper(decoratedShape);\n\t}\n\t\n\t@Override\n\tpublic void draw() {\n\t\tdecoratedShape.draw();\n\t\tsetRedBorder(decoratedShape);\n\t}\n\t\n\tprivate void setRedBorder(Shape decoratedShape) {\n\t\tSystem.out.println(\"Red Border Corlor\");\n\t}\n\n}\n```\n5.装饰模式测试类\n\n```\npublic class DecoratorTest {\n\tpublic static void main(String[] args) {\n\t\tShape circle=new Circle();\n\t\tShape redCircle=new RedShapeDecorator(new Circle());\n\t\t\n\t\tShape redRectangle=new RedShapeDecorator(new Rectangle());\n\t\tSystem.out.println(\"Circle with normal border\");\n\t\tcircle.draw();\n\t\t\n\t\tSystem.out.println(\"Circle whit red border\");\n\t\tredCircle.draw();\n\t\t\n\t\tSystem.out.println(\"Rectangle with red border\");\n\t\tredRectangle.draw();\n\t\t\n\t}\n}\n```\n输出结果：\n\n> Circle with normal border\nDraw Circle\nCircle whit red border\nDraw Circle\nRed Border Corlor\nRectangle with red border\nDraw Rectangle\nRed Border Corlor\n\n三、适配器模式\n-------\n适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁。这种类型的设计模式属于结构型模式，它结合了两个独立接口的功能。通常来说，在软件开发中，系统的数据和行为都正确，但接口不符合时，我们应该考虑用适配器，目的是使控制范围之外的一个原有对象与某个接口匹配。\n\n现在假定在我们的应用中使用了两种地图，分别是Google地图和Baidu地图。这两个地图接口对我们而言是隐藏不可修改的，但是由于我们应用的特殊需求，可能会使用两个地图获取位置。那么此时我们就可以用适配器模式来实现。\n1.当前我们拥有百度地图和Google地图两个接口均可以获取地理位置。\n\n```\npublic class BaiduMap {\n\tpublic String getBaiduLocation() {\n\t\treturn \"this is baidu location\";\n\t}\n}\n\n\npublic class GoogleMap {\n\tpublic String getGoogleLocation() {\n\t\treturn \"this is Google location\";\n\t}\n}\n```\n\n2.创建一个Map接口\n\n```\npublic interface Map {\n\tString getLocation(String mapType);\n}\n```\n3.创建LocationAdapter实现Map接口\n\n```\npublic class LocationAdapter implements Map {\n\t@Override\n\tpublic String getLocation(String mapType) {\n\t\tString location=\"\";\n\t\tswitch(mapType) {\n\t\t\tcase \"Baidu\":\n\t\t\t\tlocation=new BaiduMap().getBaiduLocation();\n\t\t\t\tbreak;\n\t\t\tcase \"Google\":\n\t\t\t\tlocation=new GoogleMap().getGoogleLocation();\n\t\t\t\tbreak;\n\t\t}\n\t\treturn location;\n\t}\n}\n```\n3.测试适配器模式\n\n```\npublic class AdapterTest {\n\n\tpublic static void main(String[] args) {\n\t\tLocationAdapter adapter=new LocationAdapter();\n\t\tSystem.out.println(adapter.getLocation(\"Baidu\"));\n\t\tSystem.out.println(adapter.getLocation(\"Google\"));\n\t}\n\n}\n```\n输出结果：\n\n> this is baidu location\nthis is Google location\n\n","slug":"2.浅析Java设计模式（二）","published":1,"updated":"2020-08-29T18:02:49.074Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckegm5nrt0006dwozdcl1amnu","content":"<p>上篇文章我们学习了几种创建型模式 的设计模式，那么本篇文章就继续来学习一下结构型模式的几个常用设计模式。</p>\n<h2 id=\"一、代理模式（Proxy-Pattern）\"><a href=\"#一、代理模式（Proxy-Pattern）\" class=\"headerlink\" title=\"一、代理模式（Proxy Pattern）\"></a>一、代理模式（Proxy Pattern）</h2><p>代理模式即为其它对象提供一种代理控制对这个对象的访问。在代理模式中，一个类代表另一个类的功能。这种类型的设计模式属于结构型模式。在代理模式中，我们创建具有现有对象的对象，以便向外界提供功能接口。代理模式的机构图如下：<br><img src=\"https://raw.githubusercontent.com/zhpanvip/Resource/master/image/0201.png\" alt=\"静态代理\"></p>\n<p>Subject类中定义一个抽象request()方法,RealSubject和Proxy共用接口，这样就在任何使用RealSubject的地方都可以使用Proxy。<br>1.Subject类代码如下：</p>\n<pre><code class=\"hljs csharp\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Subject</span> &#123;\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">request</span>(<span class=\"hljs-params\"></span>)</span>;\n&#125;</code></pre>\n<p>2.RealSubject集成Subject类</p>\n<pre><code class=\"hljs scala\">public <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">RealSubject</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Subject</span></span>&#123;\n\n\t<span class=\"hljs-meta\">@Override</span>\n\tpublic void request() &#123;\n\t\t<span class=\"hljs-type\">System</span>.out.println(<span class=\"hljs-string\">&quot;Real Request&quot;</span>);\n\t&#125;\n&#125;</code></pre>\n<p>3.Proxy实现Subject类</p>\n<pre><code class=\"hljs scala\">public <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Proxy</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Subject</span> </span>&#123;\n\t<span class=\"hljs-keyword\">private</span> <span class=\"hljs-type\">RealSubject</span> mRealSubject;\n\t\n\t<span class=\"hljs-meta\">@Override</span>\n\tpublic void request() &#123;\n\t\t<span class=\"hljs-keyword\">if</span>(mRealSubject==<span class=\"hljs-literal\">null</span>) &#123;\n\t\t\tmRealSubject=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">RealSubject</span>();\n\t\t&#125;\n\t\tmRealSubject.request();\n\t&#125;\n&#125;</code></pre>\n<p>4.代理测试类</p>\n<pre><code class=\"hljs routeros\">public class ProxyTest &#123;\n\n\tpublic static void main(String[] args) &#123;\n\t<span class=\"hljs-built_in\">\tProxy </span><span class=\"hljs-attribute\">proxy</span>=new Proxy();\n\t\tproxy.request();\n\t&#125;\n&#125;</code></pre>\n<p>输出结果：</p>\n<blockquote>\n<p>Real Request</p>\n</blockquote>\n<h2 id=\"二、装饰模式（Decorator-Pattern）\"><a href=\"#二、装饰模式（Decorator-Pattern）\" class=\"headerlink\" title=\"二、装饰模式（Decorator Pattern）\"></a>二、装饰模式（Decorator Pattern）</h2><p>装饰模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装。</p>\n<p>我们将创建一个 Shape 接口和实现了 Shape 接口的实体类。然后我们创建一个实现了 Shape 接口的抽象装饰类 ShapeDecorator，并把 Shape 对象作为它的实例变量。RedShapeDecorator 是实现了 ShapeDecorator 的实体类。DecoratorPatternDemo，我们的演示类使用 RedShapeDecorator 来装饰 Shape 对象。UML图如下：<br><img src=\"https://raw.githubusercontent.com/zhpanvip/Resource/master/image/0202.jfif\" alt=\"装饰模式\"></p>\n<p>1.创建Shape接口</p>\n<pre><code class=\"hljs routeros\">public<span class=\"hljs-built_in\"> interface </span>Shape &#123;\n\tvoid draw();\n&#125;</code></pre>\n<p>2.创建Circle类和Rectangle类并实现Shape接口</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Circle</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">Shape</span> </span>&#123;\n\n\t<span class=\"hljs-meta\">@Override</span>\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">draw</span><span class=\"hljs-params\">()</span> </span>&#123;\n\t\tSystem.out.println(<span class=\"hljs-string\">&quot;Draw Circle&quot;</span>);\n\t&#125;\n\n&#125;\n\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Rectangle</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">Shape</span> </span>&#123;\n\n\t<span class=\"hljs-meta\">@Override</span>\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">draw</span><span class=\"hljs-params\">()</span> </span>&#123;\n\t\tSystem.out.println(<span class=\"hljs-string\">&quot;Draw Rectangle&quot;</span>);\n\t&#125;\n\n&#125;</code></pre>\n<p>3.创建实现了 Shape 接口的抽象装饰类</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ShapeDecorator</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">Shape</span> </span>&#123;\n\t<span class=\"hljs-keyword\">protected</span> Shape decoratedShape;\n\t\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">ShapeDecorator</span><span class=\"hljs-params\">(Shape decoratedShape)</span> </span>&#123;\n\t\t<span class=\"hljs-keyword\">this</span>.decoratedShape=decoratedShape;\n\t&#125;\n\t\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">draw</span><span class=\"hljs-params\">()</span> </span>&#123;\n\t\tdecoratedShape.draw();\n\t&#125;\n&#125;</code></pre>\n<p>4.创建RedShapeDecorator装饰类并继承ShapeDecorator</p>\n<pre><code class=\"hljs scala\">public <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">RedShapeDecorator</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">ShapeDecorator</span>  </span>&#123;\n\n\tpublic <span class=\"hljs-type\">RedShapeDecorator</span>(<span class=\"hljs-type\">Shape</span> decoratedShape) &#123;\n\t\t<span class=\"hljs-keyword\">super</span>(decoratedShape);\n\t&#125;\n\t\n\t<span class=\"hljs-meta\">@Override</span>\n\tpublic void draw() &#123;\n\t\tdecoratedShape.draw();\n\t\tsetRedBorder(decoratedShape);\n\t&#125;\n\t\n\t<span class=\"hljs-keyword\">private</span> void setRedBorder(<span class=\"hljs-type\">Shape</span> decoratedShape) &#123;\n\t\t<span class=\"hljs-type\">System</span>.out.println(<span class=\"hljs-string\">&quot;Red Border Corlor&quot;</span>);\n\t&#125;\n\n&#125;</code></pre>\n<p>5.装饰模式测试类</p>\n<pre><code class=\"hljs pgsql\"><span class=\"hljs-built_in\">public</span> <span class=\"hljs-keyword\">class</span> DecoratorTest &#123;\n\t<span class=\"hljs-built_in\">public</span> static <span class=\"hljs-type\">void</span> main(String[] args) &#123;\n\t\tShape <span class=\"hljs-type\">circle</span>=<span class=\"hljs-built_in\">new</span> Circle();\n\t\tShape redCircle=<span class=\"hljs-built_in\">new</span> RedShapeDecorator(<span class=\"hljs-built_in\">new</span> Circle());\n\t\t\n\t\tShape redRectangle=<span class=\"hljs-built_in\">new</span> RedShapeDecorator(<span class=\"hljs-built_in\">new</span> Rectangle());\n\t\t<span class=\"hljs-keyword\">System</span>.<span class=\"hljs-keyword\">out</span>.println(&quot;Circle with normal border&quot;);\n\t\t<span class=\"hljs-type\">circle</span>.draw();\n\t\t\n\t\t<span class=\"hljs-keyword\">System</span>.<span class=\"hljs-keyword\">out</span>.println(&quot;Circle whit red border&quot;);\n\t\tredCircle.draw();\n\t\t\n\t\t<span class=\"hljs-keyword\">System</span>.<span class=\"hljs-keyword\">out</span>.println(&quot;Rectangle with red border&quot;);\n\t\tredRectangle.draw();\n\t\t\n\t&#125;\n&#125;</code></pre>\n<p>输出结果：</p>\n<blockquote>\n<p>Circle with normal border<br>Draw Circle<br>Circle whit red border<br>Draw Circle<br>Red Border Corlor<br>Rectangle with red border<br>Draw Rectangle<br>Red Border Corlor</p>\n</blockquote>\n<h2 id=\"三、适配器模式\"><a href=\"#三、适配器模式\" class=\"headerlink\" title=\"三、适配器模式\"></a>三、适配器模式</h2><p>适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁。这种类型的设计模式属于结构型模式，它结合了两个独立接口的功能。通常来说，在软件开发中，系统的数据和行为都正确，但接口不符合时，我们应该考虑用适配器，目的是使控制范围之外的一个原有对象与某个接口匹配。</p>\n<p>现在假定在我们的应用中使用了两种地图，分别是Google地图和Baidu地图。这两个地图接口对我们而言是隐藏不可修改的，但是由于我们应用的特殊需求，可能会使用两个地图获取位置。那么此时我们就可以用适配器模式来实现。<br>1.当前我们拥有百度地图和Google地图两个接口均可以获取地理位置。</p>\n<pre><code class=\"hljs arduino\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">BaiduMap</span> &#123;</span>\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">String</span> <span class=\"hljs-title\">getBaiduLocation</span><span class=\"hljs-params\">()</span> </span>&#123;\n\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;this is baidu location&quot;</span>;\n\t&#125;\n&#125;\n\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">GoogleMap</span> &#123;</span>\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">String</span> <span class=\"hljs-title\">getGoogleLocation</span><span class=\"hljs-params\">()</span> </span>&#123;\n\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;this is Google location&quot;</span>;\n\t&#125;\n&#125;</code></pre>\n\n<p>2.创建一个Map接口</p>\n<pre><code class=\"hljs routeros\">public<span class=\"hljs-built_in\"> interface </span>Map &#123;\n\tString getLocation(String mapType);\n&#125;</code></pre>\n<p>3.创建LocationAdapter实现Map接口</p>\n<pre><code class=\"hljs haxe\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">LocationAdapter</span> <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">implements</span> <span class=\"hljs-type\">Map</span></span> </span>&#123;\n\t@Override\n\t<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">String</span> getLocation(<span class=\"hljs-keyword\">String</span> mapType) &#123;\n\t\t<span class=\"hljs-keyword\">String</span> location=<span class=\"hljs-string\">&quot;&quot;</span>;\n\t\t<span class=\"hljs-keyword\">switch</span>(mapType) &#123;\n\t\t\t<span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&quot;Baidu&quot;</span>:<span class=\"hljs-type\"></span>\n<span class=\"hljs-type\">\t\t\t\tlocation</span>=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">BaiduMap</span>().getBaiduLocation();\n\t\t\t\t<span class=\"hljs-keyword\">break</span>;\n\t\t\t<span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&quot;Google&quot;</span>:<span class=\"hljs-type\"></span>\n<span class=\"hljs-type\">\t\t\t\tlocation</span>=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">GoogleMap</span>().getGoogleLocation();\n\t\t\t\t<span class=\"hljs-keyword\">break</span>;\n\t\t&#125;\n\t\t<span class=\"hljs-keyword\">return</span> location;\n\t&#125;\n&#125;</code></pre>\n<p>3.测试适配器模式</p>\n<pre><code class=\"hljs arduino\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">AdapterTest</span> &#123;</span>\n\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">String</span>[] args)</span> </span>&#123;\n\t\tLocationAdapter adapter=<span class=\"hljs-keyword\">new</span> LocationAdapter();\n\t\tSystem.out.<span class=\"hljs-built_in\">println</span>(adapter.getLocation(<span class=\"hljs-string\">&quot;Baidu&quot;</span>));\n\t\tSystem.out.<span class=\"hljs-built_in\">println</span>(adapter.getLocation(<span class=\"hljs-string\">&quot;Google&quot;</span>));\n\t&#125;\n\n&#125;</code></pre>\n<p>输出结果：</p>\n<blockquote>\n<p>this is baidu location<br>this is Google location</p>\n</blockquote>\n","site":{"data":{"fluid_config":{"favicon":"/img/favicon.png","apple_touch_icon":"/img/favicon.png","title_join_string":" - ","force_https":false,"highlight":{"enable":true,"style":"Github Gist","bg_color":false,"copy_btn":true},"fun_features":{"typing":{"enable":true,"typeSpeed":70,"cursorChar":"|","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"mouse_click":{"enable":false,"style":"values"}},"dark_mode":{"enable":true,"default":"auto"},"color":{"body_bg_color":"#eee","body_bg_color_dark":"#181c27","navbar_bg_color":"#2f4154","navbar_bg_color_dark":"#1f3144","navbar_text_color":"#fff","navbar_text_color_dark":"#d0d0d0","text_color":"#3c4858","text_color_dark":"#c4c6c9","sec_text_color":"#718096","sec_text_color_dark":"#a7a9ad","post_text_color":"#2c3e50","post_text_color_dark":"#c4c6c9","post_heading_color":"#1a202c","post_heading_color_dark":"#c4c6c9","post_link_color":"#0366d6","post_link_color_dark":"#1589e9","link_hover_color":"#30a9de","link_hover_color_dark":"#30a9de","link_hover_bg_color":"#f8f9fa","link_hover_bg_color_dark":"#364151","board_color":"#fff","board_color_dark":"#252d38"},"font":{"font_size":"16px","font_family":null,"code_font_size":"85%"},"custom_js":null,"custom_css":null,"custom_html":"","web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"tajs":null,"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}},"lazyload":{"enable":true,"onlypost":false},"daovoice":{"enable":false,"appid":""},"aplayer":{"enable":false,"autoplay":false,"loop":"all","order":"random","theme":"#b7daff","songs":[{"name":"name","artist":"artist","url":"/songs/test.mp3","cover":"/img/cover.jpg"},{"name":"name","artist":"artist","url":"https://...url.mp3","cover":"https://...cover.jpg"}]},"version":{"check":false},"navbar":{"blog_title":"zhangpan","ground_glass":{"enable":false,"px":3,"alpha":0.7},"menu":[{"key":"home","link":"/","icon":"iconfont icon-home-fill"},{"key":"archive","link":"/archives/","icon":"iconfont icon-archive-fill"},{"key":"category","link":"/categories/","icon":"iconfont icon-category-fill"},{"key":"tag","link":"/tags/","icon":"iconfont icon-tags-fill"},{"key":"about","link":"/about/","icon":"iconfont icon-user-fill"}]},"search":{"enable":true,"path":"/local-search.xml","generate_path":"/local-search.xml","field":"post","content":true},"scroll_down_arrow":{"enable":true,"banner_height_limit":90,"scroll_after_turning_page":true},"banner_parallax":true,"footer":{"statistics":{"enable":false,"source":"busuanzi","pv_format":"总访问量 {} 次","uv_format":"总访客数 {} 人"},"beian":{"enable":false,"icp_text":"京ICP证123456号","police_text":"京公网安备12345678号","police_code":12345678,"police_icon":"/img/police_beian.png"}},"scroll_top_arrow":{"enable":true},"index":{"banner_img":"/img/default.png","banner_img_height":100,"banner_mask_alpha":0.3,"post_default_img":"","slogan":{"enable":true,"text":"Talk is cheap, show me the code."},"auto_excerpt":{"enable":true},"post_url_target":"_self","post_meta":{"date":true,"category":true,"tag":true}},"page":{"banner_img":"/img/default.png","banner_img_height":60,"banner_mask_alpha":0.3},"post":{"banner_img":"/img/default.png","banner_img_height":70,"banner_mask_alpha":0.3,"meta":{"date":{"enable":true,"format":"LL a"},"wordcount":{"enable":true,"format":"{} 字"},"min2read":{"enable":true,"format":"{} 分钟","words":100},"views":{"enable":false,"source":"busuanzi","format":"{} 次"}},"updated":{"enable":false,"content":"本文最后更新于：","relative":false},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"copyright":{"enable":true,"content":"本博客所有文章除特别声明外，均采用 <a href=\"https://creativecommons.org/licenses/by-sa/4.0/deed.zh\" rel=\"nofollow noopener\">CC BY-SA 4.0 协议</a> ，转载请注明出处！ <h5>开源库推荐</h5> <a href=\"https://github.com/zhpanvip/BannerViewPager\">1.BannerViewPager</a> <p> 一个基于ViewPager2实现的具有强大功能的无限轮播库。支持多种页面切换效果和指示器样式。 </p>\n<a href=\"https://github.com/zhpanvip/viewpagerindicator\">2.ViewPagerIndicator</a> <p> 一个适用于ViewPager和ViewPager2的指示器，支持多种滑块样式及滑动模式 </p>"},"prev_next":{"enable":true},"custom":{"enable":false,"content":"<img src=\"https://octodex.github.com/images/jetpacktocat.png\" class=\"rounded mx-auto d-block mt-5\" style=\"width:150px; height:150px;\">"},"image_zoom":{"enable":true},"footnote":{"enable":true,"header":""},"math":{"enable":false,"specific":false,"engine":"mathjax"},"mermaid":{"enable":false,"specific":false,"options":{"theme":"default"}},"comments":{"enable":true,"type":"utterances"}},"utterances":{"repo":"zhpanvip/utterances-comment","issue_term":"pathname","label":"utterances","theme":"github-light","crossorigin":"anonymous"},"disqus":{"shortname":null,"disqusjs":false,"apikey":null},"gitalk":{"clientID":null,"clientSecret":null,"repo":null,"owner":null,"admin":["name"],"id":"location.pathname","language":"zh-CN","labels":["Gitalk"],"perPage":10,"pagerDirection":"last","distractionFreeMode":false,"createIssueManually":true},"valine":{"appid":"hXIROaIM5y9qnieojJRWP5hS","appkey":"y0f3w3aqd1MF7JL9ma4WECTy","placeholder":"说点什么","path":"window.location.pathname","avatar":"retro","meta":["nick","mail","link"],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"https://zhangpan.site"},"changyan":{"appid":"","appkey":""},"livere":{"uid":""},"archive":{"banner_img":"/img/bg_article.jpg","banner_img_height":60,"banner_mask_alpha":0.3,"subtitle":null},"category":{"banner_img":"/img/bg_default.png","banner_img_height":60,"banner_mask_alpha":0.3,"subtitle":null,"post_limit":10,"order_by":"-length"},"tag":{"banner_img":"/img/bg_label.jpg","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null,"tagcloud":{"min_font":15,"max_font":30,"unit":"px","start_color":"#BBBBEE","end_color":"#337ab7"}},"about":{"banner_img":"/img/bg_default.png","banner_img_height":60,"banner_mask_alpha":0.3,"subtitle":null,"avatar":"/img/avatar.png","name":"myname","introduce":"一句简短的介绍","icons":[{"class":"iconfont icon-github-fill","link":"https://github.com","tip":"GitHub"},{"class":"iconfont icon-douban-fill","link":"https://douban.com","tip":"豆瓣"},{"class":"iconfont icon-wechat-fill","qrcode":"/img/favicon.png"}]},"page404":{"banner_img":"/img/default.png","banner_img_height":85,"banner_mask_alpha":0.3,"subtitle":"Page not found"},"links":{"banner_img":"/img/default.png","banner_img_height":60,"banner_mask_alpha":0.3,"subtitle":null,"items":[{"title":"Fluid Docs","intro":"主题使用指南","link":"https://hexo.fluid-dev.com/docs/","image":"/img/favicon.png"},{"title":"Fluid Repo","intro":"主题 GitHub 仓库","link":"https://github.com/fluid-dev/hexo-theme-fluid","image":"/img/favicon.png"},{"title":"Fluid Example","intro":"主题操作示例","link":"https://hexo.fluid-dev.com/docs/example/","image":"/img/favicon.png"}]}}}},"excerpt":"","more":"<p>上篇文章我们学习了几种创建型模式 的设计模式，那么本篇文章就继续来学习一下结构型模式的几个常用设计模式。</p>\n<h2 id=\"一、代理模式（Proxy-Pattern）\"><a href=\"#一、代理模式（Proxy-Pattern）\" class=\"headerlink\" title=\"一、代理模式（Proxy Pattern）\"></a>一、代理模式（Proxy Pattern）</h2><p>代理模式即为其它对象提供一种代理控制对这个对象的访问。在代理模式中，一个类代表另一个类的功能。这种类型的设计模式属于结构型模式。在代理模式中，我们创建具有现有对象的对象，以便向外界提供功能接口。代理模式的机构图如下：<br><img src=\"https://raw.githubusercontent.com/zhpanvip/Resource/master/image/0201.png\" alt=\"静态代理\"></p>\n<p>Subject类中定义一个抽象request()方法,RealSubject和Proxy共用接口，这样就在任何使用RealSubject的地方都可以使用Proxy。<br>1.Subject类代码如下：</p>\n<pre><code class=\"hljs csharp\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Subject</span> &#123;\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">request</span>(<span class=\"hljs-params\"></span>)</span>;\n&#125;</code></pre>\n<p>2.RealSubject集成Subject类</p>\n<pre><code class=\"hljs scala\">public <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">RealSubject</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Subject</span></span>&#123;\n\n\t<span class=\"hljs-meta\">@Override</span>\n\tpublic void request() &#123;\n\t\t<span class=\"hljs-type\">System</span>.out.println(<span class=\"hljs-string\">&quot;Real Request&quot;</span>);\n\t&#125;\n&#125;</code></pre>\n<p>3.Proxy实现Subject类</p>\n<pre><code class=\"hljs scala\">public <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Proxy</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Subject</span> </span>&#123;\n\t<span class=\"hljs-keyword\">private</span> <span class=\"hljs-type\">RealSubject</span> mRealSubject;\n\t\n\t<span class=\"hljs-meta\">@Override</span>\n\tpublic void request() &#123;\n\t\t<span class=\"hljs-keyword\">if</span>(mRealSubject==<span class=\"hljs-literal\">null</span>) &#123;\n\t\t\tmRealSubject=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">RealSubject</span>();\n\t\t&#125;\n\t\tmRealSubject.request();\n\t&#125;\n&#125;</code></pre>\n<p>4.代理测试类</p>\n<pre><code class=\"hljs routeros\">public class ProxyTest &#123;\n\n\tpublic static void main(String[] args) &#123;\n\t<span class=\"hljs-built_in\">\tProxy </span><span class=\"hljs-attribute\">proxy</span>=new Proxy();\n\t\tproxy.request();\n\t&#125;\n&#125;</code></pre>\n<p>输出结果：</p>\n<blockquote>\n<p>Real Request</p>\n</blockquote>\n<h2 id=\"二、装饰模式（Decorator-Pattern）\"><a href=\"#二、装饰模式（Decorator-Pattern）\" class=\"headerlink\" title=\"二、装饰模式（Decorator Pattern）\"></a>二、装饰模式（Decorator Pattern）</h2><p>装饰模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装。</p>\n<p>我们将创建一个 Shape 接口和实现了 Shape 接口的实体类。然后我们创建一个实现了 Shape 接口的抽象装饰类 ShapeDecorator，并把 Shape 对象作为它的实例变量。RedShapeDecorator 是实现了 ShapeDecorator 的实体类。DecoratorPatternDemo，我们的演示类使用 RedShapeDecorator 来装饰 Shape 对象。UML图如下：<br><img src=\"https://raw.githubusercontent.com/zhpanvip/Resource/master/image/0202.jfif\" alt=\"装饰模式\"></p>\n<p>1.创建Shape接口</p>\n<pre><code class=\"hljs routeros\">public<span class=\"hljs-built_in\"> interface </span>Shape &#123;\n\tvoid draw();\n&#125;</code></pre>\n<p>2.创建Circle类和Rectangle类并实现Shape接口</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Circle</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">Shape</span> </span>&#123;\n\n\t<span class=\"hljs-meta\">@Override</span>\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">draw</span><span class=\"hljs-params\">()</span> </span>&#123;\n\t\tSystem.out.println(<span class=\"hljs-string\">&quot;Draw Circle&quot;</span>);\n\t&#125;\n\n&#125;\n\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Rectangle</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">Shape</span> </span>&#123;\n\n\t<span class=\"hljs-meta\">@Override</span>\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">draw</span><span class=\"hljs-params\">()</span> </span>&#123;\n\t\tSystem.out.println(<span class=\"hljs-string\">&quot;Draw Rectangle&quot;</span>);\n\t&#125;\n\n&#125;</code></pre>\n<p>3.创建实现了 Shape 接口的抽象装饰类</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ShapeDecorator</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">Shape</span> </span>&#123;\n\t<span class=\"hljs-keyword\">protected</span> Shape decoratedShape;\n\t\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">ShapeDecorator</span><span class=\"hljs-params\">(Shape decoratedShape)</span> </span>&#123;\n\t\t<span class=\"hljs-keyword\">this</span>.decoratedShape=decoratedShape;\n\t&#125;\n\t\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">draw</span><span class=\"hljs-params\">()</span> </span>&#123;\n\t\tdecoratedShape.draw();\n\t&#125;\n&#125;</code></pre>\n<p>4.创建RedShapeDecorator装饰类并继承ShapeDecorator</p>\n<pre><code class=\"hljs scala\">public <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">RedShapeDecorator</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">ShapeDecorator</span>  </span>&#123;\n\n\tpublic <span class=\"hljs-type\">RedShapeDecorator</span>(<span class=\"hljs-type\">Shape</span> decoratedShape) &#123;\n\t\t<span class=\"hljs-keyword\">super</span>(decoratedShape);\n\t&#125;\n\t\n\t<span class=\"hljs-meta\">@Override</span>\n\tpublic void draw() &#123;\n\t\tdecoratedShape.draw();\n\t\tsetRedBorder(decoratedShape);\n\t&#125;\n\t\n\t<span class=\"hljs-keyword\">private</span> void setRedBorder(<span class=\"hljs-type\">Shape</span> decoratedShape) &#123;\n\t\t<span class=\"hljs-type\">System</span>.out.println(<span class=\"hljs-string\">&quot;Red Border Corlor&quot;</span>);\n\t&#125;\n\n&#125;</code></pre>\n<p>5.装饰模式测试类</p>\n<pre><code class=\"hljs pgsql\"><span class=\"hljs-built_in\">public</span> <span class=\"hljs-keyword\">class</span> DecoratorTest &#123;\n\t<span class=\"hljs-built_in\">public</span> static <span class=\"hljs-type\">void</span> main(String[] args) &#123;\n\t\tShape <span class=\"hljs-type\">circle</span>=<span class=\"hljs-built_in\">new</span> Circle();\n\t\tShape redCircle=<span class=\"hljs-built_in\">new</span> RedShapeDecorator(<span class=\"hljs-built_in\">new</span> Circle());\n\t\t\n\t\tShape redRectangle=<span class=\"hljs-built_in\">new</span> RedShapeDecorator(<span class=\"hljs-built_in\">new</span> Rectangle());\n\t\t<span class=\"hljs-keyword\">System</span>.<span class=\"hljs-keyword\">out</span>.println(&quot;Circle with normal border&quot;);\n\t\t<span class=\"hljs-type\">circle</span>.draw();\n\t\t\n\t\t<span class=\"hljs-keyword\">System</span>.<span class=\"hljs-keyword\">out</span>.println(&quot;Circle whit red border&quot;);\n\t\tredCircle.draw();\n\t\t\n\t\t<span class=\"hljs-keyword\">System</span>.<span class=\"hljs-keyword\">out</span>.println(&quot;Rectangle with red border&quot;);\n\t\tredRectangle.draw();\n\t\t\n\t&#125;\n&#125;</code></pre>\n<p>输出结果：</p>\n<blockquote>\n<p>Circle with normal border<br>Draw Circle<br>Circle whit red border<br>Draw Circle<br>Red Border Corlor<br>Rectangle with red border<br>Draw Rectangle<br>Red Border Corlor</p>\n</blockquote>\n<h2 id=\"三、适配器模式\"><a href=\"#三、适配器模式\" class=\"headerlink\" title=\"三、适配器模式\"></a>三、适配器模式</h2><p>适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁。这种类型的设计模式属于结构型模式，它结合了两个独立接口的功能。通常来说，在软件开发中，系统的数据和行为都正确，但接口不符合时，我们应该考虑用适配器，目的是使控制范围之外的一个原有对象与某个接口匹配。</p>\n<p>现在假定在我们的应用中使用了两种地图，分别是Google地图和Baidu地图。这两个地图接口对我们而言是隐藏不可修改的，但是由于我们应用的特殊需求，可能会使用两个地图获取位置。那么此时我们就可以用适配器模式来实现。<br>1.当前我们拥有百度地图和Google地图两个接口均可以获取地理位置。</p>\n<pre><code class=\"hljs arduino\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">BaiduMap</span> &#123;</span>\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">String</span> <span class=\"hljs-title\">getBaiduLocation</span><span class=\"hljs-params\">()</span> </span>&#123;\n\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;this is baidu location&quot;</span>;\n\t&#125;\n&#125;\n\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">GoogleMap</span> &#123;</span>\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">String</span> <span class=\"hljs-title\">getGoogleLocation</span><span class=\"hljs-params\">()</span> </span>&#123;\n\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;this is Google location&quot;</span>;\n\t&#125;\n&#125;</code></pre>\n\n<p>2.创建一个Map接口</p>\n<pre><code class=\"hljs routeros\">public<span class=\"hljs-built_in\"> interface </span>Map &#123;\n\tString getLocation(String mapType);\n&#125;</code></pre>\n<p>3.创建LocationAdapter实现Map接口</p>\n<pre><code class=\"hljs haxe\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">LocationAdapter</span> <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">implements</span> <span class=\"hljs-type\">Map</span></span> </span>&#123;\n\t@Override\n\t<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">String</span> getLocation(<span class=\"hljs-keyword\">String</span> mapType) &#123;\n\t\t<span class=\"hljs-keyword\">String</span> location=<span class=\"hljs-string\">&quot;&quot;</span>;\n\t\t<span class=\"hljs-keyword\">switch</span>(mapType) &#123;\n\t\t\t<span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&quot;Baidu&quot;</span>:<span class=\"hljs-type\"></span>\n<span class=\"hljs-type\">\t\t\t\tlocation</span>=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">BaiduMap</span>().getBaiduLocation();\n\t\t\t\t<span class=\"hljs-keyword\">break</span>;\n\t\t\t<span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&quot;Google&quot;</span>:<span class=\"hljs-type\"></span>\n<span class=\"hljs-type\">\t\t\t\tlocation</span>=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">GoogleMap</span>().getGoogleLocation();\n\t\t\t\t<span class=\"hljs-keyword\">break</span>;\n\t\t&#125;\n\t\t<span class=\"hljs-keyword\">return</span> location;\n\t&#125;\n&#125;</code></pre>\n<p>3.测试适配器模式</p>\n<pre><code class=\"hljs arduino\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">AdapterTest</span> &#123;</span>\n\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">String</span>[] args)</span> </span>&#123;\n\t\tLocationAdapter adapter=<span class=\"hljs-keyword\">new</span> LocationAdapter();\n\t\tSystem.out.<span class=\"hljs-built_in\">println</span>(adapter.getLocation(<span class=\"hljs-string\">&quot;Baidu&quot;</span>));\n\t\tSystem.out.<span class=\"hljs-built_in\">println</span>(adapter.getLocation(<span class=\"hljs-string\">&quot;Google&quot;</span>));\n\t&#125;\n\n&#125;</code></pre>\n<p>输出结果：</p>\n<blockquote>\n<p>this is baidu location<br>this is Google location</p>\n</blockquote>\n"},{"title":"静态代理这么用？--聊一聊ViewPagerIndicator重构的一些经验","date":"2019-11-24T04:05:21.000Z","_content":"\n\n\nViewPagerIndicator的代码可谓一波三折，在不久前ViewPagerIndicator作为一个单独的库从[BannerViewPager](https://github.com/zhpanvip/BannerViewPager)中拆分了出来。拆分后的indicator已经不仅仅适用于BannerViewPager，还可以用于ViewPager和ViewPager2。现在，经历了几次代码重构后,总算可以拿得出手了。本篇文章就来写一写关于重构indicator的一些经验，了解下该库是如何通过静态代理模式来实现多种多样的indicator样式的。\n\n先贴上[ViewPagerIndicator](https://github.com/zhpanvip/viewpagerindicator)源码链接以及预览图，使用方式可以参考GitHub主页README,同时有兴趣的同学欢迎到GitHub star项目。\n\n| Attrs | CIRCLE | DASH | ROUND_RECT |\n|--|--|--|--|\n| NORMAL| ![CIRCLE_NORMAL](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC80LzI3LzE3MWJiZTZiYzFiZTVlNmI?x-oss-process=image/format,png) | ![DASH_NORMAL](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC80LzI3LzE3MWJiZTcxNGZlYTcwNzA?x-oss-process=image/format,png) | ![ROUND_RECT_NORMAL](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC80LzI3LzE3MWJiZTc2ZWQ4ZTc1OTY?x-oss-process=image/format,png) |\n| SMOOTH| ![CIRCLE_SMOOTH](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC80LzI3LzE3MWJiZTdmM2ViOGI2N2Y?x-oss-process=image/format,png)| ![DASH_SMOOTH](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC80LzI3LzE3MWJiZTg0ZDhlNzJjMDE?x-oss-process=image/format,png) | ![ROUND_RECT_SMOOTH](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC80LzI3LzE3MWJiZThkNDYxMGE4MTk?x-oss-process=image/format,png) |\n| WORM| ![CIRCLE_WORM](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC80LzI3LzE3MWJiZTk0YjgzNDMwMDI?x-oss-process=image/format,png)| ![DASH_WORM](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC80LzI3LzE3MWJiZTk5ZWZhNGJmNzA?x-oss-process=image/format,png) | ![ROUND_WORM](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC80LzI3LzE3MWJiZWEwZWU0MTY1NTY?x-oss-process=image/format,png)|\n| COLOR| ![CIRCLE_COLOR](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC80LzI3LzE3MWJiZWE1ZjBkYzE4Yjk?x-oss-process=image/format,png) | ![DASH_COLOR](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC80LzI3LzE3MWJiZWFiNzM0YjNkNjQ?x-oss-process=image/format,png) | ![ROUND_COLOR](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC80LzI3LzE3MWJiZWIzYjQ2OGFhNDY?x-oss-process=image/format,png) |\n| SCALE| ![CIRCLE_SCALE](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC80LzI3LzE3MWJiZWJhNTJmOTNkZWE?x-oss-process=image/format,png)| ![DASH_SCALE](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC80LzI3LzE3MWJiZWJmZWVjNjNkZDI?x-oss-process=image/format,png) | ![ROUND_SCALE](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC80LzI3LzE3MWJiZWM4MGYxMWI5NDc?x-oss-process=image/format,png) |\n\n## 一、为什么要重构\n\n在Indicator未拆分之前针对IndicatorView进行了两次较大的重构。第一次重构在上篇文章中也有提到。最初的Indicator是在BannerViewPager内部维护了一个指示器ImageView的List集合，在BannerViewPager内部会根据页面size动态添加指示器的Image。显然这种处理方式存在很大的弊端，即：不灵活、可扩展性低、性能相对较差等诸多问题。针对这一系列问题，在后续版本中对Indicator进行了第一次重构。这次重构将Indicator改为自定义View，并且抽象出了IIndicator接口，极大的增强了Indicator的可扩展性。因此，在后续若干个版本迭代中Indicator逐渐支持了多种样式（CIRCLE/DASH/ROUND_RECT）和多种滑动模式（SMOOTH/NORMAL）并且支持自定义Indicator。相比最初版本，不管在功能还是性能上都有了很大的提升。但是，在后续版本的迭代中却又暴露出许多问题。而这些问题很大程度上影响了开发和使用。列举其中一个最大问题如下：\n### 多个IndicatorView不利于维护和使用\n在BannerViewPager早期版本中indicator已经支持了CIRCLE和DASH两种样式，与之对应的是CircleIndicatorView和DashIndicatorView。在BannerViewPager内部用简单工厂模式根据IndicatorStyle来生成对应的IndicatorView。这么以来就出现了一个弊端，即每添加一种Indicator样式都需要一个与之对应的IndicatorView类，当Indicator 样式越来越多的时候维护成本和使用成本都会随之增加--使用该库的开发人员需要记住每种样式对应的IndicatorView名字，作为该库维护者也要面对越来越臃肿的代码结构，这是大家都不愿意看到的。因此，在这样的背景下IndicatorView的第二次重构就势在必行，不得不做了。针对这一问题，在第二次重构中使用了静态代理模式对代码结构进行了优化。\n\n## 二、回顾静态代理模式\n\n前文已经提到了，本次重构使用了静态代理模式。不知道现在大家对代理模式还记得多少，也不知道是否经常会在项目种用到代理模式。不管怎样，我们先来回顾以下静态代理模式吧：\n\n> 代理模式即为其它对象提供一种代理控制对这个对象的访问。在代理模式中，一个类代表另一个类的功能。这种类型的设计模式属于结构型模式。在代理模式中，我们创建具有现有对象的对象，以便向外界提供功能接口。\n\n代理模式的结构图如下：\n![这里写图片描述](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMS8yNC8xNmU5YmJjY2JhMjRhY2Q3?x-oss-process=image/format,png)\n注：图片来源《大话设计模式》\n\n看定义总是那么的晦涩难懂，我们还是来举一个代理模式的场景：\n\n> Ryan想在上海买一套房子，但是他又不懂得房地产的行情，于是委托了中介（Proxy）来帮助他买房子。\n> \n我们把这个场景通过Java代码来实现一下：\n\n### 1.抽象出接口\n首先我们把买房子的一类人抽象出来一个接口，接口中有一个buyHouse的方法：\n\n```java\npublic interface IPersonBuyHouse {\n\tvoid buyHouse();\n}\n```\n### 2.明确被代理的对象\nRyan想要买房子，于是他就需要实现这个IPersonBuyHouse接口:\n\n```java\npublic class Ryan implements IPersonBuyHouse{\n\n\t@Override\n\tpublic void buyHouse() {\n\t\tSystem.out.println(\"Ryan:I want buy a House...\");\n\t}\n}\n```\n### 3.寻找代理\n由于Ryan不了解房地产行情，于是将买房子的事情委托给了中介（Proxy），因此中介（Proxy）也需要实现IPersonBuyHouse的接口。但是中介不是给自己买房子的，而是买给其它有购房需求者的，所以他应该持有一个IPersonBuyHouse。而此处的购房需求者就是Ryan.于是Proxy代码如下：\n\n```java\npublic class Proxy implements IPersonBuyHouse{\n\t\n\tprivate IPersonBuyHouse mIPerson;\n\t\n\tpublic Proxy() {\n\t    mIPerson=new Ryan();\n\t}\n\t\n\t@Override\n\tpublic void buyHouse() {\n\t    System.out.println(\"Proxy:I can help you to buy house\");\n\t    mIPerson.buyHouse();\n\t}\n}\n```\n接下来我们在Main方法种测试一下Proxy类：\n\n```java\npublic class ProxyTest {\n\n\tpublic static void main(String[] args) {\n\t    new Proxy().buyHouse();\n\t}\n}\n```\n输出结果：\n\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMS8yNC8xNmU5YmJjY2JjNDk0M2Jk?x-oss-process=image/format,png)\n通过上面的例子可以看到静态代理是一个很简单的设计模式。那么接下来我们看下如何通过静态代理模式来完成对IndicatorView的重构吧。\n\n## 三、用静态代理模式重构Indicator\n在第一章节中我们就已经提到了当前Indicator的弊端：要维护多个IndicatorView，不利于开发也不利于使用。我们当前的目的就是要将IndicatorView统一成一个。而我们现在面临的困境是如何让一个IndicatorView承载多个Indicator Style？因为它既要绘制CIRCLE Style又要绘制DASH Style，以及以后可能还会增加更多的Style样式。在这种场景下我们就可以想到代理模式来解决问题。\n\n上一个章节中我们举了一个静态代理的例子是正向思维写下来的，那么本章中我们就采用逆向思维，看下是如何倒推出来静态代理模式的。\n\n### 1.初步设想\n\n首先，我们想要一个IndicatorView承接所有Style的绘制，那么正常来说我们就需要在IndicatorView中通过IndicatorStyle判断是哪种样式，然后在IndicatorView中进行绘制。其伪代码如下：\n\n```java\npublic class IndicatorView  {\n\n    public void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n    \tif(Style==CIRCLE) {\n    \t    setMeasuredDimension(measurCircleWidth(), measurCircleHeight());\n    \t} else {\n    \t\tsetMeasuredDimension(measurDashWidth(), measurDashHeight());\n\t    }\n    }\n\n    public void onDraw(Canvas canvas) {\n    \tif(Style==CIRCLE) {\n\t        drawCircleIndicator(canvas);\n\t    } else {\n\t        drawDashleIndicator(canvas);\n\t    }\n    }\n}\n```\n但是如果IndicatorStyle样式非常多的情况下，IndicatorView必然会变得非常庞大且臃肿。因此，我们自然而然的就会想到将View的measure和draw的逻辑抽出来单独给一个类来完成，那么这个类中呢至少应该有measure和draw两个方法。因此，我们将这个类的伪代码写出来大概应该是这样子的：\n\n```java\npublic class DrawerProxy  {\n\n    public BaseDrawer.MeasureResult onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n    \tif(Style==CIRCLE) {\n    \t\treturn measureCircleIndicator(int widthMeasureSpec, int heightMeasureSpec);\n    \t} else {\n    \t\treturn measureDashIndicator(int widthMeasureSpec, int heightMeasureSpec);\n\t    }\n    }\n\n    public void onDraw(Canvas canvas) {\n    \tif(Style==CIRCLE) {\n\t        drawCircleIndicator(canvas);\n\t    } else {\n\t        drawDashleIndicator(canvas);\n\t    }\n    }\n}\n```\n\n### 2.抽象接口\n\n通过上一小节的操作我们虽然将测量和绘制逻辑从IndicatorView中剥离了出来，但是DrawerProxy 这个类却承载了所有的测量和绘制逻辑。当Style样式多的时候同样会使DrawerProxy类变得臃肿不堪。因此，我们又很自然的想到了应该把不同Style的绘制逻辑单独抽出来，于是就有了CircleDrawer和DashDrawer两个类来分别处理各自的逻辑。但因为这两个类又要同时被放在DrawerProxy类中，且这两个类都又共同的方法。因此可以抽出一个CircleDrawer和DashDrawer的共同接口。于是就有了这样的一个IDrawer的接口：\n\n```java\npublic interface IDrawer {\n\n    BaseDrawer.MeasureResult onMeasure(int widthMeasureSpec, int heightMeasureSpec);\n\n    void onDraw(Canvas canvas);\n}\n```\n同时CircleDrawer和DashDrawer都应该实现该接口：\n\n```java\npublic class CircleDrawer implements IDrawer {\n\n    @Override\n    public MeasureResult onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n   \t\t// ... 省略measure逻辑\n        return mMeasureResult;\n    }\n\n    @Override\n    public void onDraw(Canvas canvas) {\n        drawIndicator(canvas);\n    }\n\n    private void drawIndicator(Canvas canvas) {\n       // ...\t省略draw逻辑\n    }\n}\n//\tDashDrawer与此类似，不再贴出\n```\n### 3.回眸一看，静态代理？\n到了这里我们在再来看DrawerProxy，发现这个类中同样需要onMeasure和onDraw，那他实现IDrawer接口顺理成章，同时它应该持有一个IDrawer类以便完成真实的测量和绘制任务。于是乎，完善之后的DrawerProxy类就成了这个样子：\n\n```java\npublic class DrawerProxy implements IDrawer {\n\n    private IDrawer mIDrawer;\n\n    public DrawerProxy(IndicatorOptions indicatorOptions) {\n        init(indicatorOptions);\n    }\n\n    private void init(IndicatorOptions indicatorOptions) {\n        mIDrawer = DrawerFactory.createDrawer(indicatorOptions);\n    }\n\n    public void setIndicatorOptions(IndicatorOptions indicatorOptions) {\n        init(indicatorOptions);\n    }\n\n    @Override\n    public BaseDrawer.MeasureResult onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n        return mIDrawer.onMeasure(widthMeasureSpec, heightMeasureSpec);\n    }\n\n    @Override\n    public void onDraw(Canvas canvas) {\n        mIDrawer.onDraw(canvas);\n    }\n}\n```\n到这里，我们回过神来看一下，这不就是一个非常标准的静态代理模式吗？当然，这里也结合了简单工厂模式来生成对应的Drawer。我们来看下重构后的IndicatorView\n\n```java\npublic class IndicatorView extends BaseIndicatorView {\n\n    private DrawerProxy mDrawerProxy;\n\n    public IndicatorView(Context context) {\n        this(context, null);\n    }\n\n    public IndicatorView(Context context, @Nullable AttributeSet attrs) {\n        this(context, attrs, 0);\n    }\n\n    public IndicatorView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) {\n        super(context, attrs, defStyleAttr);\n        mDrawerProxy = new DrawerProxy(getIndicatorOptions());\n    }\n\n    @Override\n    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n        super.onMeasure(widthMeasureSpec, heightMeasureSpec);\n        BaseDrawer.MeasureResult measureResult = mDrawerProxy.onMeasure(widthMeasureSpec, heightMeasureSpec);\n        setMeasuredDimension(measureResult.getMeasureWidth(), measureResult.getMeasureHeight());\n    }\n    \n    @Override\n    protected void onDraw(Canvas canvas) {\n        super.onDraw(canvas);\n        mDrawerProxy.onDraw(canvas);\n    }\n\n    @Override\n    public void setIndicatorOptions(IndicatorOptions indicatorOptions) {\n        super.setIndicatorOptions(indicatorOptions);\n        mDrawerProxy.setIndicatorOptions(indicatorOptions);\n    }\n}\n```\n\n可以看到通过静态代理模式简化完后的IndicatorView仅仅剩下了三十多行的代码，所有的测量和绘制逻辑都交给代理类DrawerProxy来处理，而DrawerProxy又将逻辑移交给对应的Drawer来完成。这样，所有的类都各司其职，代码简单明了！开发和维护起来也就变得更加得心应手了！\n\n最后，我们来看下如何使用Indicator：\n\n```java\n        indicatorView\n                    .setSlideMode(IndicatorSlideMode.WORM)\n                    .setIndicatorStyle(IndicatorStyle.CIRCLE)\n                    .setSliderColor(getResColor(R.color.red_normal_color), getResColor(R.color.red_checked_color))\n                    .setupWithViewPager(viewPager)\n```\n通过一个简单的链式调用传入不同的参数便实现了多种多样的指示器样式。\n\n## 四、总结\n本篇文章分享了对ViewPagerIndicator重构的一些经验。通过本篇文章相信大家对于静态代理模式也会有了更深的认识。重构后的代码在维护和使用上相比以前显然有了更明显的提升。但是并不等于现在的Indicator已经无懈可击了。相反，它还有很长的路要走。就目前而言，Indicator的SlideMode部分还是又相当大的优化空间的，那么我们就在后面的版本中拭目以吧。\n\n[ViewPagerIndicator源码戳此处](https://github.com/zhpanvip/viewpagerindicator)\n\n同时，欢迎关注用ViewPagerIndicator实现的[BannerViewPager](https://github.com/zhpanvip/BannerViewPager)库","source":"_posts/21.静态代理这么用？-聊一聊ViewPagerIndicator重构的一些经验.md","raw":"---\ntitle: 静态代理这么用？--聊一聊ViewPagerIndicator重构的一些经验\ndate: 2019-11-24 12:05:21\ntags:\n- indicator\n- ViewPager2\n---\n\n\n\nViewPagerIndicator的代码可谓一波三折，在不久前ViewPagerIndicator作为一个单独的库从[BannerViewPager](https://github.com/zhpanvip/BannerViewPager)中拆分了出来。拆分后的indicator已经不仅仅适用于BannerViewPager，还可以用于ViewPager和ViewPager2。现在，经历了几次代码重构后,总算可以拿得出手了。本篇文章就来写一写关于重构indicator的一些经验，了解下该库是如何通过静态代理模式来实现多种多样的indicator样式的。\n\n先贴上[ViewPagerIndicator](https://github.com/zhpanvip/viewpagerindicator)源码链接以及预览图，使用方式可以参考GitHub主页README,同时有兴趣的同学欢迎到GitHub star项目。\n\n| Attrs | CIRCLE | DASH | ROUND_RECT |\n|--|--|--|--|\n| NORMAL| ![CIRCLE_NORMAL](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC80LzI3LzE3MWJiZTZiYzFiZTVlNmI?x-oss-process=image/format,png) | ![DASH_NORMAL](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC80LzI3LzE3MWJiZTcxNGZlYTcwNzA?x-oss-process=image/format,png) | ![ROUND_RECT_NORMAL](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC80LzI3LzE3MWJiZTc2ZWQ4ZTc1OTY?x-oss-process=image/format,png) |\n| SMOOTH| ![CIRCLE_SMOOTH](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC80LzI3LzE3MWJiZTdmM2ViOGI2N2Y?x-oss-process=image/format,png)| ![DASH_SMOOTH](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC80LzI3LzE3MWJiZTg0ZDhlNzJjMDE?x-oss-process=image/format,png) | ![ROUND_RECT_SMOOTH](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC80LzI3LzE3MWJiZThkNDYxMGE4MTk?x-oss-process=image/format,png) |\n| WORM| ![CIRCLE_WORM](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC80LzI3LzE3MWJiZTk0YjgzNDMwMDI?x-oss-process=image/format,png)| ![DASH_WORM](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC80LzI3LzE3MWJiZTk5ZWZhNGJmNzA?x-oss-process=image/format,png) | ![ROUND_WORM](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC80LzI3LzE3MWJiZWEwZWU0MTY1NTY?x-oss-process=image/format,png)|\n| COLOR| ![CIRCLE_COLOR](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC80LzI3LzE3MWJiZWE1ZjBkYzE4Yjk?x-oss-process=image/format,png) | ![DASH_COLOR](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC80LzI3LzE3MWJiZWFiNzM0YjNkNjQ?x-oss-process=image/format,png) | ![ROUND_COLOR](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC80LzI3LzE3MWJiZWIzYjQ2OGFhNDY?x-oss-process=image/format,png) |\n| SCALE| ![CIRCLE_SCALE](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC80LzI3LzE3MWJiZWJhNTJmOTNkZWE?x-oss-process=image/format,png)| ![DASH_SCALE](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC80LzI3LzE3MWJiZWJmZWVjNjNkZDI?x-oss-process=image/format,png) | ![ROUND_SCALE](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC80LzI3LzE3MWJiZWM4MGYxMWI5NDc?x-oss-process=image/format,png) |\n\n## 一、为什么要重构\n\n在Indicator未拆分之前针对IndicatorView进行了两次较大的重构。第一次重构在上篇文章中也有提到。最初的Indicator是在BannerViewPager内部维护了一个指示器ImageView的List集合，在BannerViewPager内部会根据页面size动态添加指示器的Image。显然这种处理方式存在很大的弊端，即：不灵活、可扩展性低、性能相对较差等诸多问题。针对这一系列问题，在后续版本中对Indicator进行了第一次重构。这次重构将Indicator改为自定义View，并且抽象出了IIndicator接口，极大的增强了Indicator的可扩展性。因此，在后续若干个版本迭代中Indicator逐渐支持了多种样式（CIRCLE/DASH/ROUND_RECT）和多种滑动模式（SMOOTH/NORMAL）并且支持自定义Indicator。相比最初版本，不管在功能还是性能上都有了很大的提升。但是，在后续版本的迭代中却又暴露出许多问题。而这些问题很大程度上影响了开发和使用。列举其中一个最大问题如下：\n### 多个IndicatorView不利于维护和使用\n在BannerViewPager早期版本中indicator已经支持了CIRCLE和DASH两种样式，与之对应的是CircleIndicatorView和DashIndicatorView。在BannerViewPager内部用简单工厂模式根据IndicatorStyle来生成对应的IndicatorView。这么以来就出现了一个弊端，即每添加一种Indicator样式都需要一个与之对应的IndicatorView类，当Indicator 样式越来越多的时候维护成本和使用成本都会随之增加--使用该库的开发人员需要记住每种样式对应的IndicatorView名字，作为该库维护者也要面对越来越臃肿的代码结构，这是大家都不愿意看到的。因此，在这样的背景下IndicatorView的第二次重构就势在必行，不得不做了。针对这一问题，在第二次重构中使用了静态代理模式对代码结构进行了优化。\n\n## 二、回顾静态代理模式\n\n前文已经提到了，本次重构使用了静态代理模式。不知道现在大家对代理模式还记得多少，也不知道是否经常会在项目种用到代理模式。不管怎样，我们先来回顾以下静态代理模式吧：\n\n> 代理模式即为其它对象提供一种代理控制对这个对象的访问。在代理模式中，一个类代表另一个类的功能。这种类型的设计模式属于结构型模式。在代理模式中，我们创建具有现有对象的对象，以便向外界提供功能接口。\n\n代理模式的结构图如下：\n![这里写图片描述](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMS8yNC8xNmU5YmJjY2JhMjRhY2Q3?x-oss-process=image/format,png)\n注：图片来源《大话设计模式》\n\n看定义总是那么的晦涩难懂，我们还是来举一个代理模式的场景：\n\n> Ryan想在上海买一套房子，但是他又不懂得房地产的行情，于是委托了中介（Proxy）来帮助他买房子。\n> \n我们把这个场景通过Java代码来实现一下：\n\n### 1.抽象出接口\n首先我们把买房子的一类人抽象出来一个接口，接口中有一个buyHouse的方法：\n\n```java\npublic interface IPersonBuyHouse {\n\tvoid buyHouse();\n}\n```\n### 2.明确被代理的对象\nRyan想要买房子，于是他就需要实现这个IPersonBuyHouse接口:\n\n```java\npublic class Ryan implements IPersonBuyHouse{\n\n\t@Override\n\tpublic void buyHouse() {\n\t\tSystem.out.println(\"Ryan:I want buy a House...\");\n\t}\n}\n```\n### 3.寻找代理\n由于Ryan不了解房地产行情，于是将买房子的事情委托给了中介（Proxy），因此中介（Proxy）也需要实现IPersonBuyHouse的接口。但是中介不是给自己买房子的，而是买给其它有购房需求者的，所以他应该持有一个IPersonBuyHouse。而此处的购房需求者就是Ryan.于是Proxy代码如下：\n\n```java\npublic class Proxy implements IPersonBuyHouse{\n\t\n\tprivate IPersonBuyHouse mIPerson;\n\t\n\tpublic Proxy() {\n\t    mIPerson=new Ryan();\n\t}\n\t\n\t@Override\n\tpublic void buyHouse() {\n\t    System.out.println(\"Proxy:I can help you to buy house\");\n\t    mIPerson.buyHouse();\n\t}\n}\n```\n接下来我们在Main方法种测试一下Proxy类：\n\n```java\npublic class ProxyTest {\n\n\tpublic static void main(String[] args) {\n\t    new Proxy().buyHouse();\n\t}\n}\n```\n输出结果：\n\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMS8yNC8xNmU5YmJjY2JjNDk0M2Jk?x-oss-process=image/format,png)\n通过上面的例子可以看到静态代理是一个很简单的设计模式。那么接下来我们看下如何通过静态代理模式来完成对IndicatorView的重构吧。\n\n## 三、用静态代理模式重构Indicator\n在第一章节中我们就已经提到了当前Indicator的弊端：要维护多个IndicatorView，不利于开发也不利于使用。我们当前的目的就是要将IndicatorView统一成一个。而我们现在面临的困境是如何让一个IndicatorView承载多个Indicator Style？因为它既要绘制CIRCLE Style又要绘制DASH Style，以及以后可能还会增加更多的Style样式。在这种场景下我们就可以想到代理模式来解决问题。\n\n上一个章节中我们举了一个静态代理的例子是正向思维写下来的，那么本章中我们就采用逆向思维，看下是如何倒推出来静态代理模式的。\n\n### 1.初步设想\n\n首先，我们想要一个IndicatorView承接所有Style的绘制，那么正常来说我们就需要在IndicatorView中通过IndicatorStyle判断是哪种样式，然后在IndicatorView中进行绘制。其伪代码如下：\n\n```java\npublic class IndicatorView  {\n\n    public void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n    \tif(Style==CIRCLE) {\n    \t    setMeasuredDimension(measurCircleWidth(), measurCircleHeight());\n    \t} else {\n    \t\tsetMeasuredDimension(measurDashWidth(), measurDashHeight());\n\t    }\n    }\n\n    public void onDraw(Canvas canvas) {\n    \tif(Style==CIRCLE) {\n\t        drawCircleIndicator(canvas);\n\t    } else {\n\t        drawDashleIndicator(canvas);\n\t    }\n    }\n}\n```\n但是如果IndicatorStyle样式非常多的情况下，IndicatorView必然会变得非常庞大且臃肿。因此，我们自然而然的就会想到将View的measure和draw的逻辑抽出来单独给一个类来完成，那么这个类中呢至少应该有measure和draw两个方法。因此，我们将这个类的伪代码写出来大概应该是这样子的：\n\n```java\npublic class DrawerProxy  {\n\n    public BaseDrawer.MeasureResult onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n    \tif(Style==CIRCLE) {\n    \t\treturn measureCircleIndicator(int widthMeasureSpec, int heightMeasureSpec);\n    \t} else {\n    \t\treturn measureDashIndicator(int widthMeasureSpec, int heightMeasureSpec);\n\t    }\n    }\n\n    public void onDraw(Canvas canvas) {\n    \tif(Style==CIRCLE) {\n\t        drawCircleIndicator(canvas);\n\t    } else {\n\t        drawDashleIndicator(canvas);\n\t    }\n    }\n}\n```\n\n### 2.抽象接口\n\n通过上一小节的操作我们虽然将测量和绘制逻辑从IndicatorView中剥离了出来，但是DrawerProxy 这个类却承载了所有的测量和绘制逻辑。当Style样式多的时候同样会使DrawerProxy类变得臃肿不堪。因此，我们又很自然的想到了应该把不同Style的绘制逻辑单独抽出来，于是就有了CircleDrawer和DashDrawer两个类来分别处理各自的逻辑。但因为这两个类又要同时被放在DrawerProxy类中，且这两个类都又共同的方法。因此可以抽出一个CircleDrawer和DashDrawer的共同接口。于是就有了这样的一个IDrawer的接口：\n\n```java\npublic interface IDrawer {\n\n    BaseDrawer.MeasureResult onMeasure(int widthMeasureSpec, int heightMeasureSpec);\n\n    void onDraw(Canvas canvas);\n}\n```\n同时CircleDrawer和DashDrawer都应该实现该接口：\n\n```java\npublic class CircleDrawer implements IDrawer {\n\n    @Override\n    public MeasureResult onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n   \t\t// ... 省略measure逻辑\n        return mMeasureResult;\n    }\n\n    @Override\n    public void onDraw(Canvas canvas) {\n        drawIndicator(canvas);\n    }\n\n    private void drawIndicator(Canvas canvas) {\n       // ...\t省略draw逻辑\n    }\n}\n//\tDashDrawer与此类似，不再贴出\n```\n### 3.回眸一看，静态代理？\n到了这里我们在再来看DrawerProxy，发现这个类中同样需要onMeasure和onDraw，那他实现IDrawer接口顺理成章，同时它应该持有一个IDrawer类以便完成真实的测量和绘制任务。于是乎，完善之后的DrawerProxy类就成了这个样子：\n\n```java\npublic class DrawerProxy implements IDrawer {\n\n    private IDrawer mIDrawer;\n\n    public DrawerProxy(IndicatorOptions indicatorOptions) {\n        init(indicatorOptions);\n    }\n\n    private void init(IndicatorOptions indicatorOptions) {\n        mIDrawer = DrawerFactory.createDrawer(indicatorOptions);\n    }\n\n    public void setIndicatorOptions(IndicatorOptions indicatorOptions) {\n        init(indicatorOptions);\n    }\n\n    @Override\n    public BaseDrawer.MeasureResult onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n        return mIDrawer.onMeasure(widthMeasureSpec, heightMeasureSpec);\n    }\n\n    @Override\n    public void onDraw(Canvas canvas) {\n        mIDrawer.onDraw(canvas);\n    }\n}\n```\n到这里，我们回过神来看一下，这不就是一个非常标准的静态代理模式吗？当然，这里也结合了简单工厂模式来生成对应的Drawer。我们来看下重构后的IndicatorView\n\n```java\npublic class IndicatorView extends BaseIndicatorView {\n\n    private DrawerProxy mDrawerProxy;\n\n    public IndicatorView(Context context) {\n        this(context, null);\n    }\n\n    public IndicatorView(Context context, @Nullable AttributeSet attrs) {\n        this(context, attrs, 0);\n    }\n\n    public IndicatorView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) {\n        super(context, attrs, defStyleAttr);\n        mDrawerProxy = new DrawerProxy(getIndicatorOptions());\n    }\n\n    @Override\n    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n        super.onMeasure(widthMeasureSpec, heightMeasureSpec);\n        BaseDrawer.MeasureResult measureResult = mDrawerProxy.onMeasure(widthMeasureSpec, heightMeasureSpec);\n        setMeasuredDimension(measureResult.getMeasureWidth(), measureResult.getMeasureHeight());\n    }\n    \n    @Override\n    protected void onDraw(Canvas canvas) {\n        super.onDraw(canvas);\n        mDrawerProxy.onDraw(canvas);\n    }\n\n    @Override\n    public void setIndicatorOptions(IndicatorOptions indicatorOptions) {\n        super.setIndicatorOptions(indicatorOptions);\n        mDrawerProxy.setIndicatorOptions(indicatorOptions);\n    }\n}\n```\n\n可以看到通过静态代理模式简化完后的IndicatorView仅仅剩下了三十多行的代码，所有的测量和绘制逻辑都交给代理类DrawerProxy来处理，而DrawerProxy又将逻辑移交给对应的Drawer来完成。这样，所有的类都各司其职，代码简单明了！开发和维护起来也就变得更加得心应手了！\n\n最后，我们来看下如何使用Indicator：\n\n```java\n        indicatorView\n                    .setSlideMode(IndicatorSlideMode.WORM)\n                    .setIndicatorStyle(IndicatorStyle.CIRCLE)\n                    .setSliderColor(getResColor(R.color.red_normal_color), getResColor(R.color.red_checked_color))\n                    .setupWithViewPager(viewPager)\n```\n通过一个简单的链式调用传入不同的参数便实现了多种多样的指示器样式。\n\n## 四、总结\n本篇文章分享了对ViewPagerIndicator重构的一些经验。通过本篇文章相信大家对于静态代理模式也会有了更深的认识。重构后的代码在维护和使用上相比以前显然有了更明显的提升。但是并不等于现在的Indicator已经无懈可击了。相反，它还有很长的路要走。就目前而言，Indicator的SlideMode部分还是又相当大的优化空间的，那么我们就在后面的版本中拭目以吧。\n\n[ViewPagerIndicator源码戳此处](https://github.com/zhpanvip/viewpagerindicator)\n\n同时，欢迎关注用ViewPagerIndicator实现的[BannerViewPager](https://github.com/zhpanvip/BannerViewPager)库","slug":"21.静态代理这么用？-聊一聊ViewPagerIndicator重构的一些经验","published":1,"updated":"2020-08-29T01:52:15.392Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckegm5nrv0009dwozgxao5ubv","content":"<p>ViewPagerIndicator的代码可谓一波三折，在不久前ViewPagerIndicator作为一个单独的库从<a href=\"https://github.com/zhpanvip/BannerViewPager\">BannerViewPager</a>中拆分了出来。拆分后的indicator已经不仅仅适用于BannerViewPager，还可以用于ViewPager和ViewPager2。现在，经历了几次代码重构后,总算可以拿得出手了。本篇文章就来写一写关于重构indicator的一些经验，了解下该库是如何通过静态代理模式来实现多种多样的indicator样式的。</p>\n<p>先贴上<a href=\"https://github.com/zhpanvip/viewpagerindicator\">ViewPagerIndicator</a>源码链接以及预览图，使用方式可以参考GitHub主页README,同时有兴趣的同学欢迎到GitHub star项目。</p>\n<table>\n<thead>\n<tr>\n<th>Attrs</th>\n<th>CIRCLE</th>\n<th>DASH</th>\n<th>ROUND_RECT</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>NORMAL</td>\n<td><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC80LzI3LzE3MWJiZTZiYzFiZTVlNmI?x-oss-process=image/format,png\" alt=\"CIRCLE_NORMAL\"></td>\n<td><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC80LzI3LzE3MWJiZTcxNGZlYTcwNzA?x-oss-process=image/format,png\" alt=\"DASH_NORMAL\"></td>\n<td><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC80LzI3LzE3MWJiZTc2ZWQ4ZTc1OTY?x-oss-process=image/format,png\" alt=\"ROUND_RECT_NORMAL\"></td>\n</tr>\n<tr>\n<td>SMOOTH</td>\n<td><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC80LzI3LzE3MWJiZTdmM2ViOGI2N2Y?x-oss-process=image/format,png\" alt=\"CIRCLE_SMOOTH\"></td>\n<td><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC80LzI3LzE3MWJiZTg0ZDhlNzJjMDE?x-oss-process=image/format,png\" alt=\"DASH_SMOOTH\"></td>\n<td><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC80LzI3LzE3MWJiZThkNDYxMGE4MTk?x-oss-process=image/format,png\" alt=\"ROUND_RECT_SMOOTH\"></td>\n</tr>\n<tr>\n<td>WORM</td>\n<td><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC80LzI3LzE3MWJiZTk0YjgzNDMwMDI?x-oss-process=image/format,png\" alt=\"CIRCLE_WORM\"></td>\n<td><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC80LzI3LzE3MWJiZTk5ZWZhNGJmNzA?x-oss-process=image/format,png\" alt=\"DASH_WORM\"></td>\n<td><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC80LzI3LzE3MWJiZWEwZWU0MTY1NTY?x-oss-process=image/format,png\" alt=\"ROUND_WORM\"></td>\n</tr>\n<tr>\n<td>COLOR</td>\n<td><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC80LzI3LzE3MWJiZWE1ZjBkYzE4Yjk?x-oss-process=image/format,png\" alt=\"CIRCLE_COLOR\"></td>\n<td><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC80LzI3LzE3MWJiZWFiNzM0YjNkNjQ?x-oss-process=image/format,png\" alt=\"DASH_COLOR\"></td>\n<td><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC80LzI3LzE3MWJiZWIzYjQ2OGFhNDY?x-oss-process=image/format,png\" alt=\"ROUND_COLOR\"></td>\n</tr>\n<tr>\n<td>SCALE</td>\n<td><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC80LzI3LzE3MWJiZWJhNTJmOTNkZWE?x-oss-process=image/format,png\" alt=\"CIRCLE_SCALE\"></td>\n<td><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC80LzI3LzE3MWJiZWJmZWVjNjNkZDI?x-oss-process=image/format,png\" alt=\"DASH_SCALE\"></td>\n<td><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC80LzI3LzE3MWJiZWM4MGYxMWI5NDc?x-oss-process=image/format,png\" alt=\"ROUND_SCALE\"></td>\n</tr>\n</tbody></table>\n<h2 id=\"一、为什么要重构\"><a href=\"#一、为什么要重构\" class=\"headerlink\" title=\"一、为什么要重构\"></a>一、为什么要重构</h2><p>在Indicator未拆分之前针对IndicatorView进行了两次较大的重构。第一次重构在上篇文章中也有提到。最初的Indicator是在BannerViewPager内部维护了一个指示器ImageView的List集合，在BannerViewPager内部会根据页面size动态添加指示器的Image。显然这种处理方式存在很大的弊端，即：不灵活、可扩展性低、性能相对较差等诸多问题。针对这一系列问题，在后续版本中对Indicator进行了第一次重构。这次重构将Indicator改为自定义View，并且抽象出了IIndicator接口，极大的增强了Indicator的可扩展性。因此，在后续若干个版本迭代中Indicator逐渐支持了多种样式（CIRCLE/DASH/ROUND_RECT）和多种滑动模式（SMOOTH/NORMAL）并且支持自定义Indicator。相比最初版本，不管在功能还是性能上都有了很大的提升。但是，在后续版本的迭代中却又暴露出许多问题。而这些问题很大程度上影响了开发和使用。列举其中一个最大问题如下：</p>\n<h3 id=\"多个IndicatorView不利于维护和使用\"><a href=\"#多个IndicatorView不利于维护和使用\" class=\"headerlink\" title=\"多个IndicatorView不利于维护和使用\"></a>多个IndicatorView不利于维护和使用</h3><p>在BannerViewPager早期版本中indicator已经支持了CIRCLE和DASH两种样式，与之对应的是CircleIndicatorView和DashIndicatorView。在BannerViewPager内部用简单工厂模式根据IndicatorStyle来生成对应的IndicatorView。这么以来就出现了一个弊端，即每添加一种Indicator样式都需要一个与之对应的IndicatorView类，当Indicator 样式越来越多的时候维护成本和使用成本都会随之增加–使用该库的开发人员需要记住每种样式对应的IndicatorView名字，作为该库维护者也要面对越来越臃肿的代码结构，这是大家都不愿意看到的。因此，在这样的背景下IndicatorView的第二次重构就势在必行，不得不做了。针对这一问题，在第二次重构中使用了静态代理模式对代码结构进行了优化。</p>\n<h2 id=\"二、回顾静态代理模式\"><a href=\"#二、回顾静态代理模式\" class=\"headerlink\" title=\"二、回顾静态代理模式\"></a>二、回顾静态代理模式</h2><p>前文已经提到了，本次重构使用了静态代理模式。不知道现在大家对代理模式还记得多少，也不知道是否经常会在项目种用到代理模式。不管怎样，我们先来回顾以下静态代理模式吧：</p>\n<blockquote>\n<p>代理模式即为其它对象提供一种代理控制对这个对象的访问。在代理模式中，一个类代表另一个类的功能。这种类型的设计模式属于结构型模式。在代理模式中，我们创建具有现有对象的对象，以便向外界提供功能接口。</p>\n</blockquote>\n<p>代理模式的结构图如下：<br><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMS8yNC8xNmU5YmJjY2JhMjRhY2Q3?x-oss-process=image/format,png\" alt=\"这里写图片描述\"><br>注：图片来源《大话设计模式》</p>\n<p>看定义总是那么的晦涩难懂，我们还是来举一个代理模式的场景：</p>\n<blockquote>\n<p>Ryan想在上海买一套房子，但是他又不懂得房地产的行情，于是委托了中介（Proxy）来帮助他买房子。</p>\n</blockquote>\n<p>我们把这个场景通过Java代码来实现一下：</p>\n<h3 id=\"1-抽象出接口\"><a href=\"#1-抽象出接口\" class=\"headerlink\" title=\"1.抽象出接口\"></a>1.抽象出接口</h3><p>首先我们把买房子的一类人抽象出来一个接口，接口中有一个buyHouse的方法：</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">IPersonBuyHouse</span> </span>&#123;\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">buyHouse</span><span class=\"hljs-params\">()</span></span>;\n&#125;</code></pre>\n<h3 id=\"2-明确被代理的对象\"><a href=\"#2-明确被代理的对象\" class=\"headerlink\" title=\"2.明确被代理的对象\"></a>2.明确被代理的对象</h3><p>Ryan想要买房子，于是他就需要实现这个IPersonBuyHouse接口:</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Ryan</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">IPersonBuyHouse</span></span>&#123;\n\n\t<span class=\"hljs-meta\">@Override</span>\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">buyHouse</span><span class=\"hljs-params\">()</span> </span>&#123;\n\t\tSystem.out.println(<span class=\"hljs-string\">&quot;Ryan:I want buy a House...&quot;</span>);\n\t&#125;\n&#125;</code></pre>\n<h3 id=\"3-寻找代理\"><a href=\"#3-寻找代理\" class=\"headerlink\" title=\"3.寻找代理\"></a>3.寻找代理</h3><p>由于Ryan不了解房地产行情，于是将买房子的事情委托给了中介（Proxy），因此中介（Proxy）也需要实现IPersonBuyHouse的接口。但是中介不是给自己买房子的，而是买给其它有购房需求者的，所以他应该持有一个IPersonBuyHouse。而此处的购房需求者就是Ryan.于是Proxy代码如下：</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Proxy</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">IPersonBuyHouse</span></span>&#123;\n\t\n\t<span class=\"hljs-keyword\">private</span> IPersonBuyHouse mIPerson;\n\t\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">Proxy</span><span class=\"hljs-params\">()</span> </span>&#123;\n\t    mIPerson=<span class=\"hljs-keyword\">new</span> Ryan();\n\t&#125;\n\t\n\t<span class=\"hljs-meta\">@Override</span>\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">buyHouse</span><span class=\"hljs-params\">()</span> </span>&#123;\n\t    System.out.println(<span class=\"hljs-string\">&quot;Proxy:I can help you to buy house&quot;</span>);\n\t    mIPerson.buyHouse();\n\t&#125;\n&#125;</code></pre>\n<p>接下来我们在Main方法种测试一下Proxy类：</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ProxyTest</span> </span>&#123;\n\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>&#123;\n\t    <span class=\"hljs-keyword\">new</span> Proxy().buyHouse();\n\t&#125;\n&#125;</code></pre>\n<p>输出结果：</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMS8yNC8xNmU5YmJjY2JjNDk0M2Jk?x-oss-process=image/format,png\" alt=\"在这里插入图片描述\"><br>通过上面的例子可以看到静态代理是一个很简单的设计模式。那么接下来我们看下如何通过静态代理模式来完成对IndicatorView的重构吧。</p>\n<h2 id=\"三、用静态代理模式重构Indicator\"><a href=\"#三、用静态代理模式重构Indicator\" class=\"headerlink\" title=\"三、用静态代理模式重构Indicator\"></a>三、用静态代理模式重构Indicator</h2><p>在第一章节中我们就已经提到了当前Indicator的弊端：要维护多个IndicatorView，不利于开发也不利于使用。我们当前的目的就是要将IndicatorView统一成一个。而我们现在面临的困境是如何让一个IndicatorView承载多个Indicator Style？因为它既要绘制CIRCLE Style又要绘制DASH Style，以及以后可能还会增加更多的Style样式。在这种场景下我们就可以想到代理模式来解决问题。</p>\n<p>上一个章节中我们举了一个静态代理的例子是正向思维写下来的，那么本章中我们就采用逆向思维，看下是如何倒推出来静态代理模式的。</p>\n<h3 id=\"1-初步设想\"><a href=\"#1-初步设想\" class=\"headerlink\" title=\"1.初步设想\"></a>1.初步设想</h3><p>首先，我们想要一个IndicatorView承接所有Style的绘制，那么正常来说我们就需要在IndicatorView中通过IndicatorStyle判断是哪种样式，然后在IndicatorView中进行绘制。其伪代码如下：</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">IndicatorView</span>  </span>&#123;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onMeasure</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> widthMeasureSpec, <span class=\"hljs-keyword\">int</span> heightMeasureSpec)</span> </span>&#123;\n    \t<span class=\"hljs-keyword\">if</span>(Style==CIRCLE) &#123;\n    \t    setMeasuredDimension(measurCircleWidth(), measurCircleHeight());\n    \t&#125; <span class=\"hljs-keyword\">else</span> &#123;\n    \t\tsetMeasuredDimension(measurDashWidth(), measurDashHeight());\n\t    &#125;\n    &#125;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onDraw</span><span class=\"hljs-params\">(Canvas canvas)</span> </span>&#123;\n    \t<span class=\"hljs-keyword\">if</span>(Style==CIRCLE) &#123;\n\t        drawCircleIndicator(canvas);\n\t    &#125; <span class=\"hljs-keyword\">else</span> &#123;\n\t        drawDashleIndicator(canvas);\n\t    &#125;\n    &#125;\n&#125;</code></pre>\n<p>但是如果IndicatorStyle样式非常多的情况下，IndicatorView必然会变得非常庞大且臃肿。因此，我们自然而然的就会想到将View的measure和draw的逻辑抽出来单独给一个类来完成，那么这个类中呢至少应该有measure和draw两个方法。因此，我们将这个类的伪代码写出来大概应该是这样子的：</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">DrawerProxy</span>  </span>&#123;\n\n    <span class=\"hljs-keyword\">public</span> BaseDrawer.<span class=\"hljs-function\">MeasureResult <span class=\"hljs-title\">onMeasure</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> widthMeasureSpec, <span class=\"hljs-keyword\">int</span> heightMeasureSpec)</span> </span>&#123;\n    \t<span class=\"hljs-keyword\">if</span>(Style==CIRCLE) &#123;\n    \t\t<span class=\"hljs-keyword\">return</span> measureCircleIndicator(<span class=\"hljs-keyword\">int</span> widthMeasureSpec, <span class=\"hljs-keyword\">int</span> heightMeasureSpec);\n    \t&#125; <span class=\"hljs-keyword\">else</span> &#123;\n    \t\t<span class=\"hljs-keyword\">return</span> measureDashIndicator(<span class=\"hljs-keyword\">int</span> widthMeasureSpec, <span class=\"hljs-keyword\">int</span> heightMeasureSpec);\n\t    &#125;\n    &#125;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onDraw</span><span class=\"hljs-params\">(Canvas canvas)</span> </span>&#123;\n    \t<span class=\"hljs-keyword\">if</span>(Style==CIRCLE) &#123;\n\t        drawCircleIndicator(canvas);\n\t    &#125; <span class=\"hljs-keyword\">else</span> &#123;\n\t        drawDashleIndicator(canvas);\n\t    &#125;\n    &#125;\n&#125;</code></pre>\n\n<h3 id=\"2-抽象接口\"><a href=\"#2-抽象接口\" class=\"headerlink\" title=\"2.抽象接口\"></a>2.抽象接口</h3><p>通过上一小节的操作我们虽然将测量和绘制逻辑从IndicatorView中剥离了出来，但是DrawerProxy 这个类却承载了所有的测量和绘制逻辑。当Style样式多的时候同样会使DrawerProxy类变得臃肿不堪。因此，我们又很自然的想到了应该把不同Style的绘制逻辑单独抽出来，于是就有了CircleDrawer和DashDrawer两个类来分别处理各自的逻辑。但因为这两个类又要同时被放在DrawerProxy类中，且这两个类都又共同的方法。因此可以抽出一个CircleDrawer和DashDrawer的共同接口。于是就有了这样的一个IDrawer的接口：</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">IDrawer</span> </span>&#123;\n\n    BaseDrawer.<span class=\"hljs-function\">MeasureResult <span class=\"hljs-title\">onMeasure</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> widthMeasureSpec, <span class=\"hljs-keyword\">int</span> heightMeasureSpec)</span></span>;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onDraw</span><span class=\"hljs-params\">(Canvas canvas)</span></span>;\n&#125;</code></pre>\n<p>同时CircleDrawer和DashDrawer都应该实现该接口：</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">CircleDrawer</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">IDrawer</span> </span>&#123;\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> MeasureResult <span class=\"hljs-title\">onMeasure</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> widthMeasureSpec, <span class=\"hljs-keyword\">int</span> heightMeasureSpec)</span> </span>&#123;\n   \t\t<span class=\"hljs-comment\">// ... 省略measure逻辑</span>\n        <span class=\"hljs-keyword\">return</span> mMeasureResult;\n    &#125;\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onDraw</span><span class=\"hljs-params\">(Canvas canvas)</span> </span>&#123;\n        drawIndicator(canvas);\n    &#125;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">drawIndicator</span><span class=\"hljs-params\">(Canvas canvas)</span> </span>&#123;\n       <span class=\"hljs-comment\">// ...\t省略draw逻辑</span>\n    &#125;\n&#125;\n<span class=\"hljs-comment\">//\tDashDrawer与此类似，不再贴出</span></code></pre>\n<h3 id=\"3-回眸一看，静态代理？\"><a href=\"#3-回眸一看，静态代理？\" class=\"headerlink\" title=\"3.回眸一看，静态代理？\"></a>3.回眸一看，静态代理？</h3><p>到了这里我们在再来看DrawerProxy，发现这个类中同样需要onMeasure和onDraw，那他实现IDrawer接口顺理成章，同时它应该持有一个IDrawer类以便完成真实的测量和绘制任务。于是乎，完善之后的DrawerProxy类就成了这个样子：</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">DrawerProxy</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">IDrawer</span> </span>&#123;\n\n    <span class=\"hljs-keyword\">private</span> IDrawer mIDrawer;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">DrawerProxy</span><span class=\"hljs-params\">(IndicatorOptions indicatorOptions)</span> </span>&#123;\n        init(indicatorOptions);\n    &#125;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">init</span><span class=\"hljs-params\">(IndicatorOptions indicatorOptions)</span> </span>&#123;\n        mIDrawer = DrawerFactory.createDrawer(indicatorOptions);\n    &#125;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">setIndicatorOptions</span><span class=\"hljs-params\">(IndicatorOptions indicatorOptions)</span> </span>&#123;\n        init(indicatorOptions);\n    &#125;\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-keyword\">public</span> BaseDrawer.<span class=\"hljs-function\">MeasureResult <span class=\"hljs-title\">onMeasure</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> widthMeasureSpec, <span class=\"hljs-keyword\">int</span> heightMeasureSpec)</span> </span>&#123;\n        <span class=\"hljs-keyword\">return</span> mIDrawer.onMeasure(widthMeasureSpec, heightMeasureSpec);\n    &#125;\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onDraw</span><span class=\"hljs-params\">(Canvas canvas)</span> </span>&#123;\n        mIDrawer.onDraw(canvas);\n    &#125;\n&#125;</code></pre>\n<p>到这里，我们回过神来看一下，这不就是一个非常标准的静态代理模式吗？当然，这里也结合了简单工厂模式来生成对应的Drawer。我们来看下重构后的IndicatorView</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">IndicatorView</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">BaseIndicatorView</span> </span>&#123;\n\n    <span class=\"hljs-keyword\">private</span> DrawerProxy mDrawerProxy;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">IndicatorView</span><span class=\"hljs-params\">(Context context)</span> </span>&#123;\n        <span class=\"hljs-keyword\">this</span>(context, <span class=\"hljs-keyword\">null</span>);\n    &#125;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">IndicatorView</span><span class=\"hljs-params\">(Context context, <span class=\"hljs-meta\">@Nullable</span> AttributeSet attrs)</span> </span>&#123;\n        <span class=\"hljs-keyword\">this</span>(context, attrs, <span class=\"hljs-number\">0</span>);\n    &#125;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">IndicatorView</span><span class=\"hljs-params\">(Context context, <span class=\"hljs-meta\">@Nullable</span> AttributeSet attrs, <span class=\"hljs-keyword\">int</span> defStyleAttr)</span> </span>&#123;\n        <span class=\"hljs-keyword\">super</span>(context, attrs, defStyleAttr);\n        mDrawerProxy = <span class=\"hljs-keyword\">new</span> DrawerProxy(getIndicatorOptions());\n    &#125;\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onMeasure</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> widthMeasureSpec, <span class=\"hljs-keyword\">int</span> heightMeasureSpec)</span> </span>&#123;\n        <span class=\"hljs-keyword\">super</span>.onMeasure(widthMeasureSpec, heightMeasureSpec);\n        BaseDrawer.MeasureResult measureResult = mDrawerProxy.onMeasure(widthMeasureSpec, heightMeasureSpec);\n        setMeasuredDimension(measureResult.getMeasureWidth(), measureResult.getMeasureHeight());\n    &#125;\n    \n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onDraw</span><span class=\"hljs-params\">(Canvas canvas)</span> </span>&#123;\n        <span class=\"hljs-keyword\">super</span>.onDraw(canvas);\n        mDrawerProxy.onDraw(canvas);\n    &#125;\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">setIndicatorOptions</span><span class=\"hljs-params\">(IndicatorOptions indicatorOptions)</span> </span>&#123;\n        <span class=\"hljs-keyword\">super</span>.setIndicatorOptions(indicatorOptions);\n        mDrawerProxy.setIndicatorOptions(indicatorOptions);\n    &#125;\n&#125;</code></pre>\n\n<p>可以看到通过静态代理模式简化完后的IndicatorView仅仅剩下了三十多行的代码，所有的测量和绘制逻辑都交给代理类DrawerProxy来处理，而DrawerProxy又将逻辑移交给对应的Drawer来完成。这样，所有的类都各司其职，代码简单明了！开发和维护起来也就变得更加得心应手了！</p>\n<p>最后，我们来看下如何使用Indicator：</p>\n<pre><code class=\"hljs java\">indicatorView\n            .setSlideMode(IndicatorSlideMode.WORM)\n            .setIndicatorStyle(IndicatorStyle.CIRCLE)\n            .setSliderColor(getResColor(R.color.red_normal_color), getResColor(R.color.red_checked_color))\n            .setupWithViewPager(viewPager)</code></pre>\n<p>通过一个简单的链式调用传入不同的参数便实现了多种多样的指示器样式。</p>\n<h2 id=\"四、总结\"><a href=\"#四、总结\" class=\"headerlink\" title=\"四、总结\"></a>四、总结</h2><p>本篇文章分享了对ViewPagerIndicator重构的一些经验。通过本篇文章相信大家对于静态代理模式也会有了更深的认识。重构后的代码在维护和使用上相比以前显然有了更明显的提升。但是并不等于现在的Indicator已经无懈可击了。相反，它还有很长的路要走。就目前而言，Indicator的SlideMode部分还是又相当大的优化空间的，那么我们就在后面的版本中拭目以吧。</p>\n<p><a href=\"https://github.com/zhpanvip/viewpagerindicator\">ViewPagerIndicator源码戳此处</a></p>\n<p>同时，欢迎关注用ViewPagerIndicator实现的<a href=\"https://github.com/zhpanvip/BannerViewPager\">BannerViewPager</a>库</p>\n","site":{"data":{"fluid_config":{"favicon":"/img/favicon.png","apple_touch_icon":"/img/favicon.png","title_join_string":" - ","force_https":false,"highlight":{"enable":true,"style":"Github Gist","bg_color":false,"copy_btn":true},"fun_features":{"typing":{"enable":true,"typeSpeed":70,"cursorChar":"|","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"mouse_click":{"enable":false,"style":"values"}},"dark_mode":{"enable":true,"default":"auto"},"color":{"body_bg_color":"#eee","body_bg_color_dark":"#181c27","navbar_bg_color":"#2f4154","navbar_bg_color_dark":"#1f3144","navbar_text_color":"#fff","navbar_text_color_dark":"#d0d0d0","text_color":"#3c4858","text_color_dark":"#c4c6c9","sec_text_color":"#718096","sec_text_color_dark":"#a7a9ad","post_text_color":"#2c3e50","post_text_color_dark":"#c4c6c9","post_heading_color":"#1a202c","post_heading_color_dark":"#c4c6c9","post_link_color":"#0366d6","post_link_color_dark":"#1589e9","link_hover_color":"#30a9de","link_hover_color_dark":"#30a9de","link_hover_bg_color":"#f8f9fa","link_hover_bg_color_dark":"#364151","board_color":"#fff","board_color_dark":"#252d38"},"font":{"font_size":"16px","font_family":null,"code_font_size":"85%"},"custom_js":null,"custom_css":null,"custom_html":"","web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"tajs":null,"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}},"lazyload":{"enable":true,"onlypost":false},"daovoice":{"enable":false,"appid":""},"aplayer":{"enable":false,"autoplay":false,"loop":"all","order":"random","theme":"#b7daff","songs":[{"name":"name","artist":"artist","url":"/songs/test.mp3","cover":"/img/cover.jpg"},{"name":"name","artist":"artist","url":"https://...url.mp3","cover":"https://...cover.jpg"}]},"version":{"check":false},"navbar":{"blog_title":"zhangpan","ground_glass":{"enable":false,"px":3,"alpha":0.7},"menu":[{"key":"home","link":"/","icon":"iconfont icon-home-fill"},{"key":"archive","link":"/archives/","icon":"iconfont icon-archive-fill"},{"key":"category","link":"/categories/","icon":"iconfont icon-category-fill"},{"key":"tag","link":"/tags/","icon":"iconfont icon-tags-fill"},{"key":"about","link":"/about/","icon":"iconfont icon-user-fill"}]},"search":{"enable":true,"path":"/local-search.xml","generate_path":"/local-search.xml","field":"post","content":true},"scroll_down_arrow":{"enable":true,"banner_height_limit":90,"scroll_after_turning_page":true},"banner_parallax":true,"footer":{"statistics":{"enable":false,"source":"busuanzi","pv_format":"总访问量 {} 次","uv_format":"总访客数 {} 人"},"beian":{"enable":false,"icp_text":"京ICP证123456号","police_text":"京公网安备12345678号","police_code":12345678,"police_icon":"/img/police_beian.png"}},"scroll_top_arrow":{"enable":true},"index":{"banner_img":"/img/default.png","banner_img_height":100,"banner_mask_alpha":0.3,"post_default_img":"","slogan":{"enable":true,"text":"Talk is cheap, show me the code."},"auto_excerpt":{"enable":true},"post_url_target":"_self","post_meta":{"date":true,"category":true,"tag":true}},"page":{"banner_img":"/img/default.png","banner_img_height":60,"banner_mask_alpha":0.3},"post":{"banner_img":"/img/default.png","banner_img_height":70,"banner_mask_alpha":0.3,"meta":{"date":{"enable":true,"format":"LL a"},"wordcount":{"enable":true,"format":"{} 字"},"min2read":{"enable":true,"format":"{} 分钟","words":100},"views":{"enable":false,"source":"busuanzi","format":"{} 次"}},"updated":{"enable":false,"content":"本文最后更新于：","relative":false},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"copyright":{"enable":true,"content":"本博客所有文章除特别声明外，均采用 <a href=\"https://creativecommons.org/licenses/by-sa/4.0/deed.zh\" rel=\"nofollow noopener\">CC BY-SA 4.0 协议</a> ，转载请注明出处！ <h5>开源库推荐</h5> <a href=\"https://github.com/zhpanvip/BannerViewPager\">1.BannerViewPager</a> <p> 一个基于ViewPager2实现的具有强大功能的无限轮播库。支持多种页面切换效果和指示器样式。 </p>\n<a href=\"https://github.com/zhpanvip/viewpagerindicator\">2.ViewPagerIndicator</a> <p> 一个适用于ViewPager和ViewPager2的指示器，支持多种滑块样式及滑动模式 </p>"},"prev_next":{"enable":true},"custom":{"enable":false,"content":"<img src=\"https://octodex.github.com/images/jetpacktocat.png\" class=\"rounded mx-auto d-block mt-5\" style=\"width:150px; height:150px;\">"},"image_zoom":{"enable":true},"footnote":{"enable":true,"header":""},"math":{"enable":false,"specific":false,"engine":"mathjax"},"mermaid":{"enable":false,"specific":false,"options":{"theme":"default"}},"comments":{"enable":true,"type":"utterances"}},"utterances":{"repo":"zhpanvip/utterances-comment","issue_term":"pathname","label":"utterances","theme":"github-light","crossorigin":"anonymous"},"disqus":{"shortname":null,"disqusjs":false,"apikey":null},"gitalk":{"clientID":null,"clientSecret":null,"repo":null,"owner":null,"admin":["name"],"id":"location.pathname","language":"zh-CN","labels":["Gitalk"],"perPage":10,"pagerDirection":"last","distractionFreeMode":false,"createIssueManually":true},"valine":{"appid":"hXIROaIM5y9qnieojJRWP5hS","appkey":"y0f3w3aqd1MF7JL9ma4WECTy","placeholder":"说点什么","path":"window.location.pathname","avatar":"retro","meta":["nick","mail","link"],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"https://zhangpan.site"},"changyan":{"appid":"","appkey":""},"livere":{"uid":""},"archive":{"banner_img":"/img/bg_article.jpg","banner_img_height":60,"banner_mask_alpha":0.3,"subtitle":null},"category":{"banner_img":"/img/bg_default.png","banner_img_height":60,"banner_mask_alpha":0.3,"subtitle":null,"post_limit":10,"order_by":"-length"},"tag":{"banner_img":"/img/bg_label.jpg","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null,"tagcloud":{"min_font":15,"max_font":30,"unit":"px","start_color":"#BBBBEE","end_color":"#337ab7"}},"about":{"banner_img":"/img/bg_default.png","banner_img_height":60,"banner_mask_alpha":0.3,"subtitle":null,"avatar":"/img/avatar.png","name":"myname","introduce":"一句简短的介绍","icons":[{"class":"iconfont icon-github-fill","link":"https://github.com","tip":"GitHub"},{"class":"iconfont icon-douban-fill","link":"https://douban.com","tip":"豆瓣"},{"class":"iconfont icon-wechat-fill","qrcode":"/img/favicon.png"}]},"page404":{"banner_img":"/img/default.png","banner_img_height":85,"banner_mask_alpha":0.3,"subtitle":"Page not found"},"links":{"banner_img":"/img/default.png","banner_img_height":60,"banner_mask_alpha":0.3,"subtitle":null,"items":[{"title":"Fluid Docs","intro":"主题使用指南","link":"https://hexo.fluid-dev.com/docs/","image":"/img/favicon.png"},{"title":"Fluid Repo","intro":"主题 GitHub 仓库","link":"https://github.com/fluid-dev/hexo-theme-fluid","image":"/img/favicon.png"},{"title":"Fluid Example","intro":"主题操作示例","link":"https://hexo.fluid-dev.com/docs/example/","image":"/img/favicon.png"}]}}}},"excerpt":"","more":"<p>ViewPagerIndicator的代码可谓一波三折，在不久前ViewPagerIndicator作为一个单独的库从<a href=\"https://github.com/zhpanvip/BannerViewPager\">BannerViewPager</a>中拆分了出来。拆分后的indicator已经不仅仅适用于BannerViewPager，还可以用于ViewPager和ViewPager2。现在，经历了几次代码重构后,总算可以拿得出手了。本篇文章就来写一写关于重构indicator的一些经验，了解下该库是如何通过静态代理模式来实现多种多样的indicator样式的。</p>\n<p>先贴上<a href=\"https://github.com/zhpanvip/viewpagerindicator\">ViewPagerIndicator</a>源码链接以及预览图，使用方式可以参考GitHub主页README,同时有兴趣的同学欢迎到GitHub star项目。</p>\n<table>\n<thead>\n<tr>\n<th>Attrs</th>\n<th>CIRCLE</th>\n<th>DASH</th>\n<th>ROUND_RECT</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>NORMAL</td>\n<td><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC80LzI3LzE3MWJiZTZiYzFiZTVlNmI?x-oss-process=image/format,png\" alt=\"CIRCLE_NORMAL\"></td>\n<td><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC80LzI3LzE3MWJiZTcxNGZlYTcwNzA?x-oss-process=image/format,png\" alt=\"DASH_NORMAL\"></td>\n<td><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC80LzI3LzE3MWJiZTc2ZWQ4ZTc1OTY?x-oss-process=image/format,png\" alt=\"ROUND_RECT_NORMAL\"></td>\n</tr>\n<tr>\n<td>SMOOTH</td>\n<td><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC80LzI3LzE3MWJiZTdmM2ViOGI2N2Y?x-oss-process=image/format,png\" alt=\"CIRCLE_SMOOTH\"></td>\n<td><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC80LzI3LzE3MWJiZTg0ZDhlNzJjMDE?x-oss-process=image/format,png\" alt=\"DASH_SMOOTH\"></td>\n<td><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC80LzI3LzE3MWJiZThkNDYxMGE4MTk?x-oss-process=image/format,png\" alt=\"ROUND_RECT_SMOOTH\"></td>\n</tr>\n<tr>\n<td>WORM</td>\n<td><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC80LzI3LzE3MWJiZTk0YjgzNDMwMDI?x-oss-process=image/format,png\" alt=\"CIRCLE_WORM\"></td>\n<td><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC80LzI3LzE3MWJiZTk5ZWZhNGJmNzA?x-oss-process=image/format,png\" alt=\"DASH_WORM\"></td>\n<td><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC80LzI3LzE3MWJiZWEwZWU0MTY1NTY?x-oss-process=image/format,png\" alt=\"ROUND_WORM\"></td>\n</tr>\n<tr>\n<td>COLOR</td>\n<td><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC80LzI3LzE3MWJiZWE1ZjBkYzE4Yjk?x-oss-process=image/format,png\" alt=\"CIRCLE_COLOR\"></td>\n<td><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC80LzI3LzE3MWJiZWFiNzM0YjNkNjQ?x-oss-process=image/format,png\" alt=\"DASH_COLOR\"></td>\n<td><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC80LzI3LzE3MWJiZWIzYjQ2OGFhNDY?x-oss-process=image/format,png\" alt=\"ROUND_COLOR\"></td>\n</tr>\n<tr>\n<td>SCALE</td>\n<td><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC80LzI3LzE3MWJiZWJhNTJmOTNkZWE?x-oss-process=image/format,png\" alt=\"CIRCLE_SCALE\"></td>\n<td><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC80LzI3LzE3MWJiZWJmZWVjNjNkZDI?x-oss-process=image/format,png\" alt=\"DASH_SCALE\"></td>\n<td><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC80LzI3LzE3MWJiZWM4MGYxMWI5NDc?x-oss-process=image/format,png\" alt=\"ROUND_SCALE\"></td>\n</tr>\n</tbody></table>\n<h2 id=\"一、为什么要重构\"><a href=\"#一、为什么要重构\" class=\"headerlink\" title=\"一、为什么要重构\"></a>一、为什么要重构</h2><p>在Indicator未拆分之前针对IndicatorView进行了两次较大的重构。第一次重构在上篇文章中也有提到。最初的Indicator是在BannerViewPager内部维护了一个指示器ImageView的List集合，在BannerViewPager内部会根据页面size动态添加指示器的Image。显然这种处理方式存在很大的弊端，即：不灵活、可扩展性低、性能相对较差等诸多问题。针对这一系列问题，在后续版本中对Indicator进行了第一次重构。这次重构将Indicator改为自定义View，并且抽象出了IIndicator接口，极大的增强了Indicator的可扩展性。因此，在后续若干个版本迭代中Indicator逐渐支持了多种样式（CIRCLE/DASH/ROUND_RECT）和多种滑动模式（SMOOTH/NORMAL）并且支持自定义Indicator。相比最初版本，不管在功能还是性能上都有了很大的提升。但是，在后续版本的迭代中却又暴露出许多问题。而这些问题很大程度上影响了开发和使用。列举其中一个最大问题如下：</p>\n<h3 id=\"多个IndicatorView不利于维护和使用\"><a href=\"#多个IndicatorView不利于维护和使用\" class=\"headerlink\" title=\"多个IndicatorView不利于维护和使用\"></a>多个IndicatorView不利于维护和使用</h3><p>在BannerViewPager早期版本中indicator已经支持了CIRCLE和DASH两种样式，与之对应的是CircleIndicatorView和DashIndicatorView。在BannerViewPager内部用简单工厂模式根据IndicatorStyle来生成对应的IndicatorView。这么以来就出现了一个弊端，即每添加一种Indicator样式都需要一个与之对应的IndicatorView类，当Indicator 样式越来越多的时候维护成本和使用成本都会随之增加–使用该库的开发人员需要记住每种样式对应的IndicatorView名字，作为该库维护者也要面对越来越臃肿的代码结构，这是大家都不愿意看到的。因此，在这样的背景下IndicatorView的第二次重构就势在必行，不得不做了。针对这一问题，在第二次重构中使用了静态代理模式对代码结构进行了优化。</p>\n<h2 id=\"二、回顾静态代理模式\"><a href=\"#二、回顾静态代理模式\" class=\"headerlink\" title=\"二、回顾静态代理模式\"></a>二、回顾静态代理模式</h2><p>前文已经提到了，本次重构使用了静态代理模式。不知道现在大家对代理模式还记得多少，也不知道是否经常会在项目种用到代理模式。不管怎样，我们先来回顾以下静态代理模式吧：</p>\n<blockquote>\n<p>代理模式即为其它对象提供一种代理控制对这个对象的访问。在代理模式中，一个类代表另一个类的功能。这种类型的设计模式属于结构型模式。在代理模式中，我们创建具有现有对象的对象，以便向外界提供功能接口。</p>\n</blockquote>\n<p>代理模式的结构图如下：<br><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMS8yNC8xNmU5YmJjY2JhMjRhY2Q3?x-oss-process=image/format,png\" alt=\"这里写图片描述\"><br>注：图片来源《大话设计模式》</p>\n<p>看定义总是那么的晦涩难懂，我们还是来举一个代理模式的场景：</p>\n<blockquote>\n<p>Ryan想在上海买一套房子，但是他又不懂得房地产的行情，于是委托了中介（Proxy）来帮助他买房子。</p>\n</blockquote>\n<p>我们把这个场景通过Java代码来实现一下：</p>\n<h3 id=\"1-抽象出接口\"><a href=\"#1-抽象出接口\" class=\"headerlink\" title=\"1.抽象出接口\"></a>1.抽象出接口</h3><p>首先我们把买房子的一类人抽象出来一个接口，接口中有一个buyHouse的方法：</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">IPersonBuyHouse</span> </span>&#123;\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">buyHouse</span><span class=\"hljs-params\">()</span></span>;\n&#125;</code></pre>\n<h3 id=\"2-明确被代理的对象\"><a href=\"#2-明确被代理的对象\" class=\"headerlink\" title=\"2.明确被代理的对象\"></a>2.明确被代理的对象</h3><p>Ryan想要买房子，于是他就需要实现这个IPersonBuyHouse接口:</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Ryan</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">IPersonBuyHouse</span></span>&#123;\n\n\t<span class=\"hljs-meta\">@Override</span>\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">buyHouse</span><span class=\"hljs-params\">()</span> </span>&#123;\n\t\tSystem.out.println(<span class=\"hljs-string\">&quot;Ryan:I want buy a House...&quot;</span>);\n\t&#125;\n&#125;</code></pre>\n<h3 id=\"3-寻找代理\"><a href=\"#3-寻找代理\" class=\"headerlink\" title=\"3.寻找代理\"></a>3.寻找代理</h3><p>由于Ryan不了解房地产行情，于是将买房子的事情委托给了中介（Proxy），因此中介（Proxy）也需要实现IPersonBuyHouse的接口。但是中介不是给自己买房子的，而是买给其它有购房需求者的，所以他应该持有一个IPersonBuyHouse。而此处的购房需求者就是Ryan.于是Proxy代码如下：</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Proxy</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">IPersonBuyHouse</span></span>&#123;\n\t\n\t<span class=\"hljs-keyword\">private</span> IPersonBuyHouse mIPerson;\n\t\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">Proxy</span><span class=\"hljs-params\">()</span> </span>&#123;\n\t    mIPerson=<span class=\"hljs-keyword\">new</span> Ryan();\n\t&#125;\n\t\n\t<span class=\"hljs-meta\">@Override</span>\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">buyHouse</span><span class=\"hljs-params\">()</span> </span>&#123;\n\t    System.out.println(<span class=\"hljs-string\">&quot;Proxy:I can help you to buy house&quot;</span>);\n\t    mIPerson.buyHouse();\n\t&#125;\n&#125;</code></pre>\n<p>接下来我们在Main方法种测试一下Proxy类：</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ProxyTest</span> </span>&#123;\n\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>&#123;\n\t    <span class=\"hljs-keyword\">new</span> Proxy().buyHouse();\n\t&#125;\n&#125;</code></pre>\n<p>输出结果：</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMS8yNC8xNmU5YmJjY2JjNDk0M2Jk?x-oss-process=image/format,png\" alt=\"在这里插入图片描述\"><br>通过上面的例子可以看到静态代理是一个很简单的设计模式。那么接下来我们看下如何通过静态代理模式来完成对IndicatorView的重构吧。</p>\n<h2 id=\"三、用静态代理模式重构Indicator\"><a href=\"#三、用静态代理模式重构Indicator\" class=\"headerlink\" title=\"三、用静态代理模式重构Indicator\"></a>三、用静态代理模式重构Indicator</h2><p>在第一章节中我们就已经提到了当前Indicator的弊端：要维护多个IndicatorView，不利于开发也不利于使用。我们当前的目的就是要将IndicatorView统一成一个。而我们现在面临的困境是如何让一个IndicatorView承载多个Indicator Style？因为它既要绘制CIRCLE Style又要绘制DASH Style，以及以后可能还会增加更多的Style样式。在这种场景下我们就可以想到代理模式来解决问题。</p>\n<p>上一个章节中我们举了一个静态代理的例子是正向思维写下来的，那么本章中我们就采用逆向思维，看下是如何倒推出来静态代理模式的。</p>\n<h3 id=\"1-初步设想\"><a href=\"#1-初步设想\" class=\"headerlink\" title=\"1.初步设想\"></a>1.初步设想</h3><p>首先，我们想要一个IndicatorView承接所有Style的绘制，那么正常来说我们就需要在IndicatorView中通过IndicatorStyle判断是哪种样式，然后在IndicatorView中进行绘制。其伪代码如下：</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">IndicatorView</span>  </span>&#123;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onMeasure</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> widthMeasureSpec, <span class=\"hljs-keyword\">int</span> heightMeasureSpec)</span> </span>&#123;\n    \t<span class=\"hljs-keyword\">if</span>(Style==CIRCLE) &#123;\n    \t    setMeasuredDimension(measurCircleWidth(), measurCircleHeight());\n    \t&#125; <span class=\"hljs-keyword\">else</span> &#123;\n    \t\tsetMeasuredDimension(measurDashWidth(), measurDashHeight());\n\t    &#125;\n    &#125;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onDraw</span><span class=\"hljs-params\">(Canvas canvas)</span> </span>&#123;\n    \t<span class=\"hljs-keyword\">if</span>(Style==CIRCLE) &#123;\n\t        drawCircleIndicator(canvas);\n\t    &#125; <span class=\"hljs-keyword\">else</span> &#123;\n\t        drawDashleIndicator(canvas);\n\t    &#125;\n    &#125;\n&#125;</code></pre>\n<p>但是如果IndicatorStyle样式非常多的情况下，IndicatorView必然会变得非常庞大且臃肿。因此，我们自然而然的就会想到将View的measure和draw的逻辑抽出来单独给一个类来完成，那么这个类中呢至少应该有measure和draw两个方法。因此，我们将这个类的伪代码写出来大概应该是这样子的：</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">DrawerProxy</span>  </span>&#123;\n\n    <span class=\"hljs-keyword\">public</span> BaseDrawer.<span class=\"hljs-function\">MeasureResult <span class=\"hljs-title\">onMeasure</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> widthMeasureSpec, <span class=\"hljs-keyword\">int</span> heightMeasureSpec)</span> </span>&#123;\n    \t<span class=\"hljs-keyword\">if</span>(Style==CIRCLE) &#123;\n    \t\t<span class=\"hljs-keyword\">return</span> measureCircleIndicator(<span class=\"hljs-keyword\">int</span> widthMeasureSpec, <span class=\"hljs-keyword\">int</span> heightMeasureSpec);\n    \t&#125; <span class=\"hljs-keyword\">else</span> &#123;\n    \t\t<span class=\"hljs-keyword\">return</span> measureDashIndicator(<span class=\"hljs-keyword\">int</span> widthMeasureSpec, <span class=\"hljs-keyword\">int</span> heightMeasureSpec);\n\t    &#125;\n    &#125;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onDraw</span><span class=\"hljs-params\">(Canvas canvas)</span> </span>&#123;\n    \t<span class=\"hljs-keyword\">if</span>(Style==CIRCLE) &#123;\n\t        drawCircleIndicator(canvas);\n\t    &#125; <span class=\"hljs-keyword\">else</span> &#123;\n\t        drawDashleIndicator(canvas);\n\t    &#125;\n    &#125;\n&#125;</code></pre>\n\n<h3 id=\"2-抽象接口\"><a href=\"#2-抽象接口\" class=\"headerlink\" title=\"2.抽象接口\"></a>2.抽象接口</h3><p>通过上一小节的操作我们虽然将测量和绘制逻辑从IndicatorView中剥离了出来，但是DrawerProxy 这个类却承载了所有的测量和绘制逻辑。当Style样式多的时候同样会使DrawerProxy类变得臃肿不堪。因此，我们又很自然的想到了应该把不同Style的绘制逻辑单独抽出来，于是就有了CircleDrawer和DashDrawer两个类来分别处理各自的逻辑。但因为这两个类又要同时被放在DrawerProxy类中，且这两个类都又共同的方法。因此可以抽出一个CircleDrawer和DashDrawer的共同接口。于是就有了这样的一个IDrawer的接口：</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">IDrawer</span> </span>&#123;\n\n    BaseDrawer.<span class=\"hljs-function\">MeasureResult <span class=\"hljs-title\">onMeasure</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> widthMeasureSpec, <span class=\"hljs-keyword\">int</span> heightMeasureSpec)</span></span>;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onDraw</span><span class=\"hljs-params\">(Canvas canvas)</span></span>;\n&#125;</code></pre>\n<p>同时CircleDrawer和DashDrawer都应该实现该接口：</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">CircleDrawer</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">IDrawer</span> </span>&#123;\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> MeasureResult <span class=\"hljs-title\">onMeasure</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> widthMeasureSpec, <span class=\"hljs-keyword\">int</span> heightMeasureSpec)</span> </span>&#123;\n   \t\t<span class=\"hljs-comment\">// ... 省略measure逻辑</span>\n        <span class=\"hljs-keyword\">return</span> mMeasureResult;\n    &#125;\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onDraw</span><span class=\"hljs-params\">(Canvas canvas)</span> </span>&#123;\n        drawIndicator(canvas);\n    &#125;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">drawIndicator</span><span class=\"hljs-params\">(Canvas canvas)</span> </span>&#123;\n       <span class=\"hljs-comment\">// ...\t省略draw逻辑</span>\n    &#125;\n&#125;\n<span class=\"hljs-comment\">//\tDashDrawer与此类似，不再贴出</span></code></pre>\n<h3 id=\"3-回眸一看，静态代理？\"><a href=\"#3-回眸一看，静态代理？\" class=\"headerlink\" title=\"3.回眸一看，静态代理？\"></a>3.回眸一看，静态代理？</h3><p>到了这里我们在再来看DrawerProxy，发现这个类中同样需要onMeasure和onDraw，那他实现IDrawer接口顺理成章，同时它应该持有一个IDrawer类以便完成真实的测量和绘制任务。于是乎，完善之后的DrawerProxy类就成了这个样子：</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">DrawerProxy</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">IDrawer</span> </span>&#123;\n\n    <span class=\"hljs-keyword\">private</span> IDrawer mIDrawer;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">DrawerProxy</span><span class=\"hljs-params\">(IndicatorOptions indicatorOptions)</span> </span>&#123;\n        init(indicatorOptions);\n    &#125;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">init</span><span class=\"hljs-params\">(IndicatorOptions indicatorOptions)</span> </span>&#123;\n        mIDrawer = DrawerFactory.createDrawer(indicatorOptions);\n    &#125;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">setIndicatorOptions</span><span class=\"hljs-params\">(IndicatorOptions indicatorOptions)</span> </span>&#123;\n        init(indicatorOptions);\n    &#125;\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-keyword\">public</span> BaseDrawer.<span class=\"hljs-function\">MeasureResult <span class=\"hljs-title\">onMeasure</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> widthMeasureSpec, <span class=\"hljs-keyword\">int</span> heightMeasureSpec)</span> </span>&#123;\n        <span class=\"hljs-keyword\">return</span> mIDrawer.onMeasure(widthMeasureSpec, heightMeasureSpec);\n    &#125;\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onDraw</span><span class=\"hljs-params\">(Canvas canvas)</span> </span>&#123;\n        mIDrawer.onDraw(canvas);\n    &#125;\n&#125;</code></pre>\n<p>到这里，我们回过神来看一下，这不就是一个非常标准的静态代理模式吗？当然，这里也结合了简单工厂模式来生成对应的Drawer。我们来看下重构后的IndicatorView</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">IndicatorView</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">BaseIndicatorView</span> </span>&#123;\n\n    <span class=\"hljs-keyword\">private</span> DrawerProxy mDrawerProxy;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">IndicatorView</span><span class=\"hljs-params\">(Context context)</span> </span>&#123;\n        <span class=\"hljs-keyword\">this</span>(context, <span class=\"hljs-keyword\">null</span>);\n    &#125;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">IndicatorView</span><span class=\"hljs-params\">(Context context, <span class=\"hljs-meta\">@Nullable</span> AttributeSet attrs)</span> </span>&#123;\n        <span class=\"hljs-keyword\">this</span>(context, attrs, <span class=\"hljs-number\">0</span>);\n    &#125;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">IndicatorView</span><span class=\"hljs-params\">(Context context, <span class=\"hljs-meta\">@Nullable</span> AttributeSet attrs, <span class=\"hljs-keyword\">int</span> defStyleAttr)</span> </span>&#123;\n        <span class=\"hljs-keyword\">super</span>(context, attrs, defStyleAttr);\n        mDrawerProxy = <span class=\"hljs-keyword\">new</span> DrawerProxy(getIndicatorOptions());\n    &#125;\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onMeasure</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> widthMeasureSpec, <span class=\"hljs-keyword\">int</span> heightMeasureSpec)</span> </span>&#123;\n        <span class=\"hljs-keyword\">super</span>.onMeasure(widthMeasureSpec, heightMeasureSpec);\n        BaseDrawer.MeasureResult measureResult = mDrawerProxy.onMeasure(widthMeasureSpec, heightMeasureSpec);\n        setMeasuredDimension(measureResult.getMeasureWidth(), measureResult.getMeasureHeight());\n    &#125;\n    \n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onDraw</span><span class=\"hljs-params\">(Canvas canvas)</span> </span>&#123;\n        <span class=\"hljs-keyword\">super</span>.onDraw(canvas);\n        mDrawerProxy.onDraw(canvas);\n    &#125;\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">setIndicatorOptions</span><span class=\"hljs-params\">(IndicatorOptions indicatorOptions)</span> </span>&#123;\n        <span class=\"hljs-keyword\">super</span>.setIndicatorOptions(indicatorOptions);\n        mDrawerProxy.setIndicatorOptions(indicatorOptions);\n    &#125;\n&#125;</code></pre>\n\n<p>可以看到通过静态代理模式简化完后的IndicatorView仅仅剩下了三十多行的代码，所有的测量和绘制逻辑都交给代理类DrawerProxy来处理，而DrawerProxy又将逻辑移交给对应的Drawer来完成。这样，所有的类都各司其职，代码简单明了！开发和维护起来也就变得更加得心应手了！</p>\n<p>最后，我们来看下如何使用Indicator：</p>\n<pre><code class=\"hljs java\">indicatorView\n            .setSlideMode(IndicatorSlideMode.WORM)\n            .setIndicatorStyle(IndicatorStyle.CIRCLE)\n            .setSliderColor(getResColor(R.color.red_normal_color), getResColor(R.color.red_checked_color))\n            .setupWithViewPager(viewPager)</code></pre>\n<p>通过一个简单的链式调用传入不同的参数便实现了多种多样的指示器样式。</p>\n<h2 id=\"四、总结\"><a href=\"#四、总结\" class=\"headerlink\" title=\"四、总结\"></a>四、总结</h2><p>本篇文章分享了对ViewPagerIndicator重构的一些经验。通过本篇文章相信大家对于静态代理模式也会有了更深的认识。重构后的代码在维护和使用上相比以前显然有了更明显的提升。但是并不等于现在的Indicator已经无懈可击了。相反，它还有很长的路要走。就目前而言，Indicator的SlideMode部分还是又相当大的优化空间的，那么我们就在后面的版本中拭目以吧。</p>\n<p><a href=\"https://github.com/zhpanvip/viewpagerindicator\">ViewPagerIndicator源码戳此处</a></p>\n<p>同时，欢迎关注用ViewPagerIndicator实现的<a href=\"https://github.com/zhpanvip/BannerViewPager\">BannerViewPager</a>库</p>\n"},{"title":"干货满满，整理给程序员的15款开发利器","date":"2019-12-04T16:27:23.000Z","_content":"\n\n今天给大家分享一些开发者必备的神器，这些都是笔者在几年的工作中收集到的，对于开发者非常有用的小工具。我将这些工具分为了四个部分来介绍，分别时---图片篇、文档篇、开发篇和插件篇。文章会对于各个小工具的功能及用途做一个简单介绍，并会给出星级评分，当然评分只能作为参考，因为不同工具对于不同的人有不同的重要性，这些评分是站在笔者角度来分析的。\n\n## 一、图片篇\n### [1.GIF神器--ezgif](https://ezgif.com/video-to-gif)\n星级评分：<font color=orange >★★★★★</font>\n![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi80LzE2ZWQxNGQxMzcxNzQ1NTE?x-oss-process=image/format,png)\n这是一个国外站点，从名字上就可以看出这是一个Gif相关的网站。这个网站绝对称得上是一个神器，它不仅可以将视频转换为GIF，还支持GIF图片的编辑、制作、裁剪，修改尺寸、美化甚至还可以GIF转视频、倒放等等众多功能。最重要的一点是完全免费！！！所以这个工具的评分直怼到五分毫不为过。想要了解更多还是大家亲自体验！\n\n### [2.图片压缩神器--TinyPNG](https://tinypng.com/)\n星级评分：<font color=orange >★★★★★</font>\n![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi80LzE2ZWQxNGRhYTY0YTFlNTU?x-oss-process=image/format,png)\n这是一个图片无损压缩的小工具，同样来自国外。通常在App开发过程中我们都会格外注意App包的内存，拿Android的一个30M的Apk来说可能有一半以上的内存都是图片。而TinyPNG提供了批量压缩打包下载的强大功能。同时，这个网站还提供了MAC和Windows的桌面程序（桌面端限每月500张）。下图是一张Mac桌面端的截图：\n\n![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi80LzE2ZWQxNGUwZjU2MjNkZmI?x-oss-process=image/format,png)\n可以看到我们从UI拿到的图片，经过TinyPng压缩后体积减少了78.2%-91.1%。但压缩前和压缩后图片的质量肉眼几乎看不出任何差别！这对前端开发同学来说堪称神器。五星毫无悬念！\n\n### [3.在线作图--ProcessOn](https://www.processon.com/;jsessionid=64008D63D312671F43AE9D007BB51386.jvm1)\n星级评分：<font color=orange >★★★★☆</font>\n\n![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi80LzE2ZWQxNGU1YmYwMTEyMTk?x-oss-process=image/format,png)\n这是一款免费的在线作图工具，支持流程图、思维导图、原型图、UML、网络拓扑图等。这个网站可以说应用广泛，各行各业都可能会用得到。贴一张使用ProcessOn制作的思维导图仅供参考：\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi80LzE2ZWQxNGI5YmQ3MWI4MjU?x-oss-process=image/format,png)\n注：图片来源ProcessOn\n虽然这个网站声称是免费作图，但免费是由一定限制的，每个账号做多可以免费保存十个文件。这也是和前两个网站相比唯一的缺点，毕竟公司也要生存，有盈利才能生存嘛，收费不为过！星级评分四颗星！\n\n### [4.Android .9阴影图生成器--Android Shadow Generator](https://inloop.github.io/shadow4android/)\n星级评分：<font color=orange >★★★☆☆</font>\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi80LzE2ZWQxNGI5YmZmZmY3MjU?x-oss-process=image/format,png)\nAndroid开发的同学都应该比较熟悉.9图，它是一种可以拉伸的图片。同时，做Android开发的同学也应该知道做阴影效果的痛苦。而Android Shadow Generator这个网站就提供了一个可以生成带阴影的.9图。通过这个工具不仅可以定义阴影的大小还可以顶指圆角、颜色等等。但是这个工具使用的局限性比较大，对于Android开发者来说是个不错的福利。三颗星拿走！\n\n### [5.业界大佬--PhotoShop](https://www.adobe.com/cn/products/photoshop/free-trial-download.html)\n星级评分：<font color=orange >★★★★★</font>\n\n![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi80LzE2ZWQxNGU5M2JkNjNlYTg?x-oss-process=image/format,png)\n这个软件应该不用我去做过多解释了吧，毕竟它的名气可以说无人不知无人不晓。作为一款专业的图像处理软件，想要掌握它并不是一件容易的事，但是作为一个开发人员并不需要掌握太高深的技能，了解一些简单技巧就足以应对常见问题了。没有五颗星说不过去吧？\n\n## 二、文档篇\n### [1.PDF神器--Easy PDF](https://easypdf.com/cn)\n星级评分：<font color=orange >★★★★★</font>\n![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi80LzE2ZWQxNGVkYWMwZTVmZGU?x-oss-process=image/format,png)\nEasyPDF--又一款神器横空出世，它提供了强大的PDF转换功能，可以PDF转Word、PDF转PPT、Word转PDF...各种PDF转换功能应有尽有。最重要的一点是免费！！！五星还有什么说的么？\n\n### [2.在线文档编辑器--腾讯文档](https://docs.qq.com/desktop)\n星级评分：<font color=orange >★★★★☆</font>\n\n![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi80LzE2ZWQxNTQ5YWI0NTZkM2E?x-oss-process=image/format,png)\n这是一个免费的在线文档编辑器,提供了在线编辑Word、Excel、PPT等文档，同时可以将文档分享给好友还可以授权好友共同编辑文档。是一个很不错的文档编辑工具。四颗星物有所值。\n\n### [4.Markdown编辑器--MarkdownPad](http://markdownpad.com/)\n星级评分：<font color=orange >★★★☆☆</font>\n\n![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi80LzE2ZWQxNjFiNjM5MWUzNDU?x-oss-process=image/format,png)\n\nMarkdownPad是一款桌面端的Markdown编辑器，对于经常使用Markdown写博客的开发者来说是一款很好用的工具。但是由于是国外的站点，下载比较慢，且安装好后在Windows上需要协同awesomium才能正常使用。由于使用局限性，且有很多在线的Markdown编辑器，譬如掘金、CSDN、简书(不推荐程序员使用简书，原因你懂的..)等，所以这个工具给三颗星吧。\n\n另外，放一个百度云的MarkdownPad下载链接，包含了awesomium。\n\n[MarkdownPad下载](https://pan.baidu.com/s/1fZm_d6ZfXesnx4_wnuMm6g)\n\n\n## 三、开发篇\n\n### [1.Postman](https://www.getpostman.com/)\n星级评分：<font color=orange >★★★★★</font>\n\n![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi80LzE2ZWQxNzQ5NzQzYTU1ZGY?x-oss-process=image/format,png)\n\n这是一个开发者的神器，不管是前端人员还是后端人员都要必备的一个软件。对于前端人员来说跟后台联调时可以通过postman来模拟请求，可以自定义添加params、authorization、headers、body等，实在是一个开发利器。星级评分五颗星！\n\n### [2.JSON处理工具--Bejson](https://www.bejson.com/)\n星级评分：<font color=orange >★★★★☆</font>\n\n![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi80LzE2ZWQxNzRkMmI4OTJkMDg?x-oss-process=image/format,png)\n\n这是一款Json格式化的工具，非常贴心好用。切换到Json->Json视图模式下查看json非常清晰，一目了然。也是四星值得推荐的工具。\n\n## 四、插件篇\n### 1.Octotree\n星级评分：<font color=orange >★★★★☆</font>\n\n如果你是github中毒用户，那么此款插件可谓是一个超级福利。在浏览github时要想打开某个类非常不方便，需要点击跳转好多次。而有了Octotree后就可以像在IDE中一样浏览github项目了。如下图：\n\n![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi80LzE2ZWQxN2NlOTc0YzA5NGY?x-oss-process=image/format,png)\n### 2.彩云小译\n星级评分：<font color=orange >★★★★☆</font>\n这是一款翻译工具，对于英语不好的同学来说简直就是救星，只要点一下插件就可以直接在原网页上翻译。支持英文翻译中文，同时也支持中文翻译英文。翻译效果如下图所示：\n\n![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi80LzE2ZWQxODQzNzI0ZDdiMDA?x-oss-process=image/format,png)\n\n### 4.[文件转换--Convertio](https://convertio.co/zh/)\n星级评分：<font color=orange >★★★★☆</font>\n\n![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi80LzE2ZWQxODdhMzhhOTBiZWM?x-oss-process=image/format,png)\n这是一个综合的文件转换平台不仅支持Web端更有Chrome插件。通过Convertio可以转换音频、视频、图像、文档等等。也是一个很不错的值得四颗星的工具。\n\n\n## 五、[BannerViewPager--Android开发者福利](https://github.com/zhpanvip/BannerViewPager)\n\n一个非常好用的可以实现任意样式的Banner轮播图--[BannerViewPager](https://github.com/zhpanvip/BannerViewPager)\n\n### 据说BannerViewPager可以实现任意Banner样式？\n\n> 腾讯视频、QQ音乐、酷狗音乐、支付宝、天猫、淘宝、优酷视频、喜马拉雅、网易云音乐、哔哩哔哩、全民K歌等App的Banner页面样式及指示器样式都可以通过[BannerViewPager](https://github.com/zhpanvip/BannerViewPager)实现哦！\n\n### 列举效果预览\n| PageStylel | IndicatorStyle |\n|--|--|\n| ![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi80LzE2ZWQxOWEyMzkxNmY2ZTY?x-oss-process=image/format,png) |![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi80LzE2ZWQxOWQ0YTMzZWJhZmM?x-oss-process=image/format,png)|\n\n详情可以查看以下文章：\n\n[《打造一个丝滑般自动轮播无限循环Android库》](https://juejin.im/post/5d6bce24f265da03db0790d1)\n\n[《BannerViewPager源码剖析》](https://juejin.im/post/5d74d3faf265da03b5747015)\n\n[《剖析BannerViewPager中Indicator的设计思想》](https://juejin.im/post/5dda0b6d518825731f569a8c)\n\n\n\n[点击此处查看源码](https://github.com/zhpanvip/BannerViewPager)\n\n","source":"_posts/22.干货满满，整理给程序员的15款开发利器.md","raw":"---\ntitle: 干货满满，整理给程序员的15款开发利器\ndate: 2019-12-05 00:27:23\ntags: \n- 开发工具\n---\n\n\n今天给大家分享一些开发者必备的神器，这些都是笔者在几年的工作中收集到的，对于开发者非常有用的小工具。我将这些工具分为了四个部分来介绍，分别时---图片篇、文档篇、开发篇和插件篇。文章会对于各个小工具的功能及用途做一个简单介绍，并会给出星级评分，当然评分只能作为参考，因为不同工具对于不同的人有不同的重要性，这些评分是站在笔者角度来分析的。\n\n## 一、图片篇\n### [1.GIF神器--ezgif](https://ezgif.com/video-to-gif)\n星级评分：<font color=orange >★★★★★</font>\n![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi80LzE2ZWQxNGQxMzcxNzQ1NTE?x-oss-process=image/format,png)\n这是一个国外站点，从名字上就可以看出这是一个Gif相关的网站。这个网站绝对称得上是一个神器，它不仅可以将视频转换为GIF，还支持GIF图片的编辑、制作、裁剪，修改尺寸、美化甚至还可以GIF转视频、倒放等等众多功能。最重要的一点是完全免费！！！所以这个工具的评分直怼到五分毫不为过。想要了解更多还是大家亲自体验！\n\n### [2.图片压缩神器--TinyPNG](https://tinypng.com/)\n星级评分：<font color=orange >★★★★★</font>\n![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi80LzE2ZWQxNGRhYTY0YTFlNTU?x-oss-process=image/format,png)\n这是一个图片无损压缩的小工具，同样来自国外。通常在App开发过程中我们都会格外注意App包的内存，拿Android的一个30M的Apk来说可能有一半以上的内存都是图片。而TinyPNG提供了批量压缩打包下载的强大功能。同时，这个网站还提供了MAC和Windows的桌面程序（桌面端限每月500张）。下图是一张Mac桌面端的截图：\n\n![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi80LzE2ZWQxNGUwZjU2MjNkZmI?x-oss-process=image/format,png)\n可以看到我们从UI拿到的图片，经过TinyPng压缩后体积减少了78.2%-91.1%。但压缩前和压缩后图片的质量肉眼几乎看不出任何差别！这对前端开发同学来说堪称神器。五星毫无悬念！\n\n### [3.在线作图--ProcessOn](https://www.processon.com/;jsessionid=64008D63D312671F43AE9D007BB51386.jvm1)\n星级评分：<font color=orange >★★★★☆</font>\n\n![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi80LzE2ZWQxNGU1YmYwMTEyMTk?x-oss-process=image/format,png)\n这是一款免费的在线作图工具，支持流程图、思维导图、原型图、UML、网络拓扑图等。这个网站可以说应用广泛，各行各业都可能会用得到。贴一张使用ProcessOn制作的思维导图仅供参考：\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi80LzE2ZWQxNGI5YmQ3MWI4MjU?x-oss-process=image/format,png)\n注：图片来源ProcessOn\n虽然这个网站声称是免费作图，但免费是由一定限制的，每个账号做多可以免费保存十个文件。这也是和前两个网站相比唯一的缺点，毕竟公司也要生存，有盈利才能生存嘛，收费不为过！星级评分四颗星！\n\n### [4.Android .9阴影图生成器--Android Shadow Generator](https://inloop.github.io/shadow4android/)\n星级评分：<font color=orange >★★★☆☆</font>\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi80LzE2ZWQxNGI5YmZmZmY3MjU?x-oss-process=image/format,png)\nAndroid开发的同学都应该比较熟悉.9图，它是一种可以拉伸的图片。同时，做Android开发的同学也应该知道做阴影效果的痛苦。而Android Shadow Generator这个网站就提供了一个可以生成带阴影的.9图。通过这个工具不仅可以定义阴影的大小还可以顶指圆角、颜色等等。但是这个工具使用的局限性比较大，对于Android开发者来说是个不错的福利。三颗星拿走！\n\n### [5.业界大佬--PhotoShop](https://www.adobe.com/cn/products/photoshop/free-trial-download.html)\n星级评分：<font color=orange >★★★★★</font>\n\n![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi80LzE2ZWQxNGU5M2JkNjNlYTg?x-oss-process=image/format,png)\n这个软件应该不用我去做过多解释了吧，毕竟它的名气可以说无人不知无人不晓。作为一款专业的图像处理软件，想要掌握它并不是一件容易的事，但是作为一个开发人员并不需要掌握太高深的技能，了解一些简单技巧就足以应对常见问题了。没有五颗星说不过去吧？\n\n## 二、文档篇\n### [1.PDF神器--Easy PDF](https://easypdf.com/cn)\n星级评分：<font color=orange >★★★★★</font>\n![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi80LzE2ZWQxNGVkYWMwZTVmZGU?x-oss-process=image/format,png)\nEasyPDF--又一款神器横空出世，它提供了强大的PDF转换功能，可以PDF转Word、PDF转PPT、Word转PDF...各种PDF转换功能应有尽有。最重要的一点是免费！！！五星还有什么说的么？\n\n### [2.在线文档编辑器--腾讯文档](https://docs.qq.com/desktop)\n星级评分：<font color=orange >★★★★☆</font>\n\n![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi80LzE2ZWQxNTQ5YWI0NTZkM2E?x-oss-process=image/format,png)\n这是一个免费的在线文档编辑器,提供了在线编辑Word、Excel、PPT等文档，同时可以将文档分享给好友还可以授权好友共同编辑文档。是一个很不错的文档编辑工具。四颗星物有所值。\n\n### [4.Markdown编辑器--MarkdownPad](http://markdownpad.com/)\n星级评分：<font color=orange >★★★☆☆</font>\n\n![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi80LzE2ZWQxNjFiNjM5MWUzNDU?x-oss-process=image/format,png)\n\nMarkdownPad是一款桌面端的Markdown编辑器，对于经常使用Markdown写博客的开发者来说是一款很好用的工具。但是由于是国外的站点，下载比较慢，且安装好后在Windows上需要协同awesomium才能正常使用。由于使用局限性，且有很多在线的Markdown编辑器，譬如掘金、CSDN、简书(不推荐程序员使用简书，原因你懂的..)等，所以这个工具给三颗星吧。\n\n另外，放一个百度云的MarkdownPad下载链接，包含了awesomium。\n\n[MarkdownPad下载](https://pan.baidu.com/s/1fZm_d6ZfXesnx4_wnuMm6g)\n\n\n## 三、开发篇\n\n### [1.Postman](https://www.getpostman.com/)\n星级评分：<font color=orange >★★★★★</font>\n\n![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi80LzE2ZWQxNzQ5NzQzYTU1ZGY?x-oss-process=image/format,png)\n\n这是一个开发者的神器，不管是前端人员还是后端人员都要必备的一个软件。对于前端人员来说跟后台联调时可以通过postman来模拟请求，可以自定义添加params、authorization、headers、body等，实在是一个开发利器。星级评分五颗星！\n\n### [2.JSON处理工具--Bejson](https://www.bejson.com/)\n星级评分：<font color=orange >★★★★☆</font>\n\n![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi80LzE2ZWQxNzRkMmI4OTJkMDg?x-oss-process=image/format,png)\n\n这是一款Json格式化的工具，非常贴心好用。切换到Json->Json视图模式下查看json非常清晰，一目了然。也是四星值得推荐的工具。\n\n## 四、插件篇\n### 1.Octotree\n星级评分：<font color=orange >★★★★☆</font>\n\n如果你是github中毒用户，那么此款插件可谓是一个超级福利。在浏览github时要想打开某个类非常不方便，需要点击跳转好多次。而有了Octotree后就可以像在IDE中一样浏览github项目了。如下图：\n\n![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi80LzE2ZWQxN2NlOTc0YzA5NGY?x-oss-process=image/format,png)\n### 2.彩云小译\n星级评分：<font color=orange >★★★★☆</font>\n这是一款翻译工具，对于英语不好的同学来说简直就是救星，只要点一下插件就可以直接在原网页上翻译。支持英文翻译中文，同时也支持中文翻译英文。翻译效果如下图所示：\n\n![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi80LzE2ZWQxODQzNzI0ZDdiMDA?x-oss-process=image/format,png)\n\n### 4.[文件转换--Convertio](https://convertio.co/zh/)\n星级评分：<font color=orange >★★★★☆</font>\n\n![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi80LzE2ZWQxODdhMzhhOTBiZWM?x-oss-process=image/format,png)\n这是一个综合的文件转换平台不仅支持Web端更有Chrome插件。通过Convertio可以转换音频、视频、图像、文档等等。也是一个很不错的值得四颗星的工具。\n\n\n## 五、[BannerViewPager--Android开发者福利](https://github.com/zhpanvip/BannerViewPager)\n\n一个非常好用的可以实现任意样式的Banner轮播图--[BannerViewPager](https://github.com/zhpanvip/BannerViewPager)\n\n### 据说BannerViewPager可以实现任意Banner样式？\n\n> 腾讯视频、QQ音乐、酷狗音乐、支付宝、天猫、淘宝、优酷视频、喜马拉雅、网易云音乐、哔哩哔哩、全民K歌等App的Banner页面样式及指示器样式都可以通过[BannerViewPager](https://github.com/zhpanvip/BannerViewPager)实现哦！\n\n### 列举效果预览\n| PageStylel | IndicatorStyle |\n|--|--|\n| ![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi80LzE2ZWQxOWEyMzkxNmY2ZTY?x-oss-process=image/format,png) |![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi80LzE2ZWQxOWQ0YTMzZWJhZmM?x-oss-process=image/format,png)|\n\n详情可以查看以下文章：\n\n[《打造一个丝滑般自动轮播无限循环Android库》](https://juejin.im/post/5d6bce24f265da03db0790d1)\n\n[《BannerViewPager源码剖析》](https://juejin.im/post/5d74d3faf265da03b5747015)\n\n[《剖析BannerViewPager中Indicator的设计思想》](https://juejin.im/post/5dda0b6d518825731f569a8c)\n\n\n\n[点击此处查看源码](https://github.com/zhpanvip/BannerViewPager)\n\n","slug":"22.干货满满，整理给程序员的15款开发利器","published":1,"updated":"2020-08-29T18:01:00.296Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckegm5nrw000bdwozd408gnus","content":"<p>今天给大家分享一些开发者必备的神器，这些都是笔者在几年的工作中收集到的，对于开发者非常有用的小工具。我将这些工具分为了四个部分来介绍，分别时—图片篇、文档篇、开发篇和插件篇。文章会对于各个小工具的功能及用途做一个简单介绍，并会给出星级评分，当然评分只能作为参考，因为不同工具对于不同的人有不同的重要性，这些评分是站在笔者角度来分析的。</p>\n<h2 id=\"一、图片篇\"><a href=\"#一、图片篇\" class=\"headerlink\" title=\"一、图片篇\"></a>一、图片篇</h2><h3 id=\"1-GIF神器–ezgif\"><a href=\"#1-GIF神器–ezgif\" class=\"headerlink\" title=\"1.GIF神器–ezgif\"></a><a href=\"https://ezgif.com/video-to-gif\">1.GIF神器–ezgif</a></h3><p>星级评分：<font color=orange >★★★★★</font><br><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi80LzE2ZWQxNGQxMzcxNzQ1NTE?x-oss-process=image/format,png\"><br>这是一个国外站点，从名字上就可以看出这是一个Gif相关的网站。这个网站绝对称得上是一个神器，它不仅可以将视频转换为GIF，还支持GIF图片的编辑、制作、裁剪，修改尺寸、美化甚至还可以GIF转视频、倒放等等众多功能。最重要的一点是完全免费！！！所以这个工具的评分直怼到五分毫不为过。想要了解更多还是大家亲自体验！</p>\n<h3 id=\"2-图片压缩神器–TinyPNG\"><a href=\"#2-图片压缩神器–TinyPNG\" class=\"headerlink\" title=\"2.图片压缩神器–TinyPNG\"></a><a href=\"https://tinypng.com/\">2.图片压缩神器–TinyPNG</a></h3><p>星级评分：<font color=orange >★★★★★</font><br><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi80LzE2ZWQxNGRhYTY0YTFlNTU?x-oss-process=image/format,png\"><br>这是一个图片无损压缩的小工具，同样来自国外。通常在App开发过程中我们都会格外注意App包的内存，拿Android的一个30M的Apk来说可能有一半以上的内存都是图片。而TinyPNG提供了批量压缩打包下载的强大功能。同时，这个网站还提供了MAC和Windows的桌面程序（桌面端限每月500张）。下图是一张Mac桌面端的截图：</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi80LzE2ZWQxNGUwZjU2MjNkZmI?x-oss-process=image/format,png\"><br>可以看到我们从UI拿到的图片，经过TinyPng压缩后体积减少了78.2%-91.1%。但压缩前和压缩后图片的质量肉眼几乎看不出任何差别！这对前端开发同学来说堪称神器。五星毫无悬念！</p>\n<h3 id=\"3-在线作图–ProcessOn\"><a href=\"#3-在线作图–ProcessOn\" class=\"headerlink\" title=\"3.在线作图–ProcessOn\"></a><a href=\"https://www.processon.com/;jsessionid=64008D63D312671F43AE9D007BB51386.jvm1\">3.在线作图–ProcessOn</a></h3><p>星级评分：<font color=orange >★★★★☆</font></p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi80LzE2ZWQxNGU1YmYwMTEyMTk?x-oss-process=image/format,png\"><br>这是一款免费的在线作图工具，支持流程图、思维导图、原型图、UML、网络拓扑图等。这个网站可以说应用广泛，各行各业都可能会用得到。贴一张使用ProcessOn制作的思维导图仅供参考：<br><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi80LzE2ZWQxNGI5YmQ3MWI4MjU?x-oss-process=image/format,png\" alt=\"在这里插入图片描述\"><br>注：图片来源ProcessOn<br>虽然这个网站声称是免费作图，但免费是由一定限制的，每个账号做多可以免费保存十个文件。这也是和前两个网站相比唯一的缺点，毕竟公司也要生存，有盈利才能生存嘛，收费不为过！星级评分四颗星！</p>\n<h3 id=\"4-Android-9阴影图生成器–Android-Shadow-Generator\"><a href=\"#4-Android-9阴影图生成器–Android-Shadow-Generator\" class=\"headerlink\" title=\"4.Android .9阴影图生成器–Android Shadow Generator\"></a><a href=\"https://inloop.github.io/shadow4android/\">4.Android .9阴影图生成器–Android Shadow Generator</a></h3><p>星级评分：<font color=orange >★★★☆☆</font><br><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi80LzE2ZWQxNGI5YmZmZmY3MjU?x-oss-process=image/format,png\" alt=\"在这里插入图片描述\"><br>Android开发的同学都应该比较熟悉.9图，它是一种可以拉伸的图片。同时，做Android开发的同学也应该知道做阴影效果的痛苦。而Android Shadow Generator这个网站就提供了一个可以生成带阴影的.9图。通过这个工具不仅可以定义阴影的大小还可以顶指圆角、颜色等等。但是这个工具使用的局限性比较大，对于Android开发者来说是个不错的福利。三颗星拿走！</p>\n<h3 id=\"5-业界大佬–PhotoShop\"><a href=\"#5-业界大佬–PhotoShop\" class=\"headerlink\" title=\"5.业界大佬–PhotoShop\"></a><a href=\"https://www.adobe.com/cn/products/photoshop/free-trial-download.html\">5.业界大佬–PhotoShop</a></h3><p>星级评分：<font color=orange >★★★★★</font></p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi80LzE2ZWQxNGU5M2JkNjNlYTg?x-oss-process=image/format,png\"><br>这个软件应该不用我去做过多解释了吧，毕竟它的名气可以说无人不知无人不晓。作为一款专业的图像处理软件，想要掌握它并不是一件容易的事，但是作为一个开发人员并不需要掌握太高深的技能，了解一些简单技巧就足以应对常见问题了。没有五颗星说不过去吧？</p>\n<h2 id=\"二、文档篇\"><a href=\"#二、文档篇\" class=\"headerlink\" title=\"二、文档篇\"></a>二、文档篇</h2><h3 id=\"1-PDF神器–Easy-PDF\"><a href=\"#1-PDF神器–Easy-PDF\" class=\"headerlink\" title=\"1.PDF神器–Easy PDF\"></a><a href=\"https://easypdf.com/cn\">1.PDF神器–Easy PDF</a></h3><p>星级评分：<font color=orange >★★★★★</font><br><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi80LzE2ZWQxNGVkYWMwZTVmZGU?x-oss-process=image/format,png\"><br>EasyPDF–又一款神器横空出世，它提供了强大的PDF转换功能，可以PDF转Word、PDF转PPT、Word转PDF…各种PDF转换功能应有尽有。最重要的一点是免费！！！五星还有什么说的么？</p>\n<h3 id=\"2-在线文档编辑器–腾讯文档\"><a href=\"#2-在线文档编辑器–腾讯文档\" class=\"headerlink\" title=\"2.在线文档编辑器–腾讯文档\"></a><a href=\"https://docs.qq.com/desktop\">2.在线文档编辑器–腾讯文档</a></h3><p>星级评分：<font color=orange >★★★★☆</font></p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi80LzE2ZWQxNTQ5YWI0NTZkM2E?x-oss-process=image/format,png\"><br>这是一个免费的在线文档编辑器,提供了在线编辑Word、Excel、PPT等文档，同时可以将文档分享给好友还可以授权好友共同编辑文档。是一个很不错的文档编辑工具。四颗星物有所值。</p>\n<h3 id=\"4-Markdown编辑器–MarkdownPad\"><a href=\"#4-Markdown编辑器–MarkdownPad\" class=\"headerlink\" title=\"4.Markdown编辑器–MarkdownPad\"></a><a href=\"http://markdownpad.com/\">4.Markdown编辑器–MarkdownPad</a></h3><p>星级评分：<font color=orange >★★★☆☆</font></p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi80LzE2ZWQxNjFiNjM5MWUzNDU?x-oss-process=image/format,png\"></p>\n<p>MarkdownPad是一款桌面端的Markdown编辑器，对于经常使用Markdown写博客的开发者来说是一款很好用的工具。但是由于是国外的站点，下载比较慢，且安装好后在Windows上需要协同awesomium才能正常使用。由于使用局限性，且有很多在线的Markdown编辑器，譬如掘金、CSDN、简书(不推荐程序员使用简书，原因你懂的..)等，所以这个工具给三颗星吧。</p>\n<p>另外，放一个百度云的MarkdownPad下载链接，包含了awesomium。</p>\n<p><a href=\"https://pan.baidu.com/s/1fZm_d6ZfXesnx4_wnuMm6g\">MarkdownPad下载</a></p>\n<h2 id=\"三、开发篇\"><a href=\"#三、开发篇\" class=\"headerlink\" title=\"三、开发篇\"></a>三、开发篇</h2><h3 id=\"1-Postman\"><a href=\"#1-Postman\" class=\"headerlink\" title=\"1.Postman\"></a><a href=\"https://www.getpostman.com/\">1.Postman</a></h3><p>星级评分：<font color=orange >★★★★★</font></p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi80LzE2ZWQxNzQ5NzQzYTU1ZGY?x-oss-process=image/format,png\"></p>\n<p>这是一个开发者的神器，不管是前端人员还是后端人员都要必备的一个软件。对于前端人员来说跟后台联调时可以通过postman来模拟请求，可以自定义添加params、authorization、headers、body等，实在是一个开发利器。星级评分五颗星！</p>\n<h3 id=\"2-JSON处理工具–Bejson\"><a href=\"#2-JSON处理工具–Bejson\" class=\"headerlink\" title=\"2.JSON处理工具–Bejson\"></a><a href=\"https://www.bejson.com/\">2.JSON处理工具–Bejson</a></h3><p>星级评分：<font color=orange >★★★★☆</font></p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi80LzE2ZWQxNzRkMmI4OTJkMDg?x-oss-process=image/format,png\"></p>\n<p>这是一款Json格式化的工具，非常贴心好用。切换到Json-&gt;Json视图模式下查看json非常清晰，一目了然。也是四星值得推荐的工具。</p>\n<h2 id=\"四、插件篇\"><a href=\"#四、插件篇\" class=\"headerlink\" title=\"四、插件篇\"></a>四、插件篇</h2><h3 id=\"1-Octotree\"><a href=\"#1-Octotree\" class=\"headerlink\" title=\"1.Octotree\"></a>1.Octotree</h3><p>星级评分：<font color=orange >★★★★☆</font></p>\n<p>如果你是github中毒用户，那么此款插件可谓是一个超级福利。在浏览github时要想打开某个类非常不方便，需要点击跳转好多次。而有了Octotree后就可以像在IDE中一样浏览github项目了。如下图：</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi80LzE2ZWQxN2NlOTc0YzA5NGY?x-oss-process=image/format,png\"></p>\n<h3 id=\"2-彩云小译\"><a href=\"#2-彩云小译\" class=\"headerlink\" title=\"2.彩云小译\"></a>2.彩云小译</h3><p>星级评分：<font color=orange >★★★★☆</font><br>这是一款翻译工具，对于英语不好的同学来说简直就是救星，只要点一下插件就可以直接在原网页上翻译。支持英文翻译中文，同时也支持中文翻译英文。翻译效果如下图所示：</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi80LzE2ZWQxODQzNzI0ZDdiMDA?x-oss-process=image/format,png\"></p>\n<h3 id=\"4-文件转换–Convertio\"><a href=\"#4-文件转换–Convertio\" class=\"headerlink\" title=\"4.文件转换–Convertio\"></a>4.<a href=\"https://convertio.co/zh/\">文件转换–Convertio</a></h3><p>星级评分：<font color=orange >★★★★☆</font></p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi80LzE2ZWQxODdhMzhhOTBiZWM?x-oss-process=image/format,png\"><br>这是一个综合的文件转换平台不仅支持Web端更有Chrome插件。通过Convertio可以转换音频、视频、图像、文档等等。也是一个很不错的值得四颗星的工具。</p>\n<h2 id=\"五、BannerViewPager–Android开发者福利\"><a href=\"#五、BannerViewPager–Android开发者福利\" class=\"headerlink\" title=\"五、BannerViewPager–Android开发者福利\"></a>五、<a href=\"https://github.com/zhpanvip/BannerViewPager\">BannerViewPager–Android开发者福利</a></h2><p>一个非常好用的可以实现任意样式的Banner轮播图–<a href=\"https://github.com/zhpanvip/BannerViewPager\">BannerViewPager</a></p>\n<h3 id=\"据说BannerViewPager可以实现任意Banner样式？\"><a href=\"#据说BannerViewPager可以实现任意Banner样式？\" class=\"headerlink\" title=\"据说BannerViewPager可以实现任意Banner样式？\"></a>据说BannerViewPager可以实现任意Banner样式？</h3><blockquote>\n<p>腾讯视频、QQ音乐、酷狗音乐、支付宝、天猫、淘宝、优酷视频、喜马拉雅、网易云音乐、哔哩哔哩、全民K歌等App的Banner页面样式及指示器样式都可以通过<a href=\"https://github.com/zhpanvip/BannerViewPager\">BannerViewPager</a>实现哦！</p>\n</blockquote>\n<h3 id=\"列举效果预览\"><a href=\"#列举效果预览\" class=\"headerlink\" title=\"列举效果预览\"></a>列举效果预览</h3><table>\n<thead>\n<tr>\n<th>PageStylel</th>\n<th>IndicatorStyle</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi80LzE2ZWQxOWEyMzkxNmY2ZTY?x-oss-process=image/format,png\"></td>\n<td><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi80LzE2ZWQxOWQ0YTMzZWJhZmM?x-oss-process=image/format,png\"></td>\n</tr>\n</tbody></table>\n<p>详情可以查看以下文章：</p>\n<p><a href=\"https://juejin.im/post/5d6bce24f265da03db0790d1\">《打造一个丝滑般自动轮播无限循环Android库》</a></p>\n<p><a href=\"https://juejin.im/post/5d74d3faf265da03b5747015\">《BannerViewPager源码剖析》</a></p>\n<p><a href=\"https://juejin.im/post/5dda0b6d518825731f569a8c\">《剖析BannerViewPager中Indicator的设计思想》</a></p>\n<p><a href=\"https://github.com/zhpanvip/BannerViewPager\">点击此处查看源码</a></p>\n","site":{"data":{"fluid_config":{"favicon":"/img/favicon.png","apple_touch_icon":"/img/favicon.png","title_join_string":" - ","force_https":false,"highlight":{"enable":true,"style":"Github Gist","bg_color":false,"copy_btn":true},"fun_features":{"typing":{"enable":true,"typeSpeed":70,"cursorChar":"|","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"mouse_click":{"enable":false,"style":"values"}},"dark_mode":{"enable":true,"default":"auto"},"color":{"body_bg_color":"#eee","body_bg_color_dark":"#181c27","navbar_bg_color":"#2f4154","navbar_bg_color_dark":"#1f3144","navbar_text_color":"#fff","navbar_text_color_dark":"#d0d0d0","text_color":"#3c4858","text_color_dark":"#c4c6c9","sec_text_color":"#718096","sec_text_color_dark":"#a7a9ad","post_text_color":"#2c3e50","post_text_color_dark":"#c4c6c9","post_heading_color":"#1a202c","post_heading_color_dark":"#c4c6c9","post_link_color":"#0366d6","post_link_color_dark":"#1589e9","link_hover_color":"#30a9de","link_hover_color_dark":"#30a9de","link_hover_bg_color":"#f8f9fa","link_hover_bg_color_dark":"#364151","board_color":"#fff","board_color_dark":"#252d38"},"font":{"font_size":"16px","font_family":null,"code_font_size":"85%"},"custom_js":null,"custom_css":null,"custom_html":"","web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"tajs":null,"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}},"lazyload":{"enable":true,"onlypost":false},"daovoice":{"enable":false,"appid":""},"aplayer":{"enable":false,"autoplay":false,"loop":"all","order":"random","theme":"#b7daff","songs":[{"name":"name","artist":"artist","url":"/songs/test.mp3","cover":"/img/cover.jpg"},{"name":"name","artist":"artist","url":"https://...url.mp3","cover":"https://...cover.jpg"}]},"version":{"check":false},"navbar":{"blog_title":"zhangpan","ground_glass":{"enable":false,"px":3,"alpha":0.7},"menu":[{"key":"home","link":"/","icon":"iconfont icon-home-fill"},{"key":"archive","link":"/archives/","icon":"iconfont icon-archive-fill"},{"key":"category","link":"/categories/","icon":"iconfont icon-category-fill"},{"key":"tag","link":"/tags/","icon":"iconfont icon-tags-fill"},{"key":"about","link":"/about/","icon":"iconfont icon-user-fill"}]},"search":{"enable":true,"path":"/local-search.xml","generate_path":"/local-search.xml","field":"post","content":true},"scroll_down_arrow":{"enable":true,"banner_height_limit":90,"scroll_after_turning_page":true},"banner_parallax":true,"footer":{"statistics":{"enable":false,"source":"busuanzi","pv_format":"总访问量 {} 次","uv_format":"总访客数 {} 人"},"beian":{"enable":false,"icp_text":"京ICP证123456号","police_text":"京公网安备12345678号","police_code":12345678,"police_icon":"/img/police_beian.png"}},"scroll_top_arrow":{"enable":true},"index":{"banner_img":"/img/default.png","banner_img_height":100,"banner_mask_alpha":0.3,"post_default_img":"","slogan":{"enable":true,"text":"Talk is cheap, show me the code."},"auto_excerpt":{"enable":true},"post_url_target":"_self","post_meta":{"date":true,"category":true,"tag":true}},"page":{"banner_img":"/img/default.png","banner_img_height":60,"banner_mask_alpha":0.3},"post":{"banner_img":"/img/default.png","banner_img_height":70,"banner_mask_alpha":0.3,"meta":{"date":{"enable":true,"format":"LL a"},"wordcount":{"enable":true,"format":"{} 字"},"min2read":{"enable":true,"format":"{} 分钟","words":100},"views":{"enable":false,"source":"busuanzi","format":"{} 次"}},"updated":{"enable":false,"content":"本文最后更新于：","relative":false},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"copyright":{"enable":true,"content":"本博客所有文章除特别声明外，均采用 <a href=\"https://creativecommons.org/licenses/by-sa/4.0/deed.zh\" rel=\"nofollow noopener\">CC BY-SA 4.0 协议</a> ，转载请注明出处！ <h5>开源库推荐</h5> <a href=\"https://github.com/zhpanvip/BannerViewPager\">1.BannerViewPager</a> <p> 一个基于ViewPager2实现的具有强大功能的无限轮播库。支持多种页面切换效果和指示器样式。 </p>\n<a href=\"https://github.com/zhpanvip/viewpagerindicator\">2.ViewPagerIndicator</a> <p> 一个适用于ViewPager和ViewPager2的指示器，支持多种滑块样式及滑动模式 </p>"},"prev_next":{"enable":true},"custom":{"enable":false,"content":"<img src=\"https://octodex.github.com/images/jetpacktocat.png\" class=\"rounded mx-auto d-block mt-5\" style=\"width:150px; height:150px;\">"},"image_zoom":{"enable":true},"footnote":{"enable":true,"header":""},"math":{"enable":false,"specific":false,"engine":"mathjax"},"mermaid":{"enable":false,"specific":false,"options":{"theme":"default"}},"comments":{"enable":true,"type":"utterances"}},"utterances":{"repo":"zhpanvip/utterances-comment","issue_term":"pathname","label":"utterances","theme":"github-light","crossorigin":"anonymous"},"disqus":{"shortname":null,"disqusjs":false,"apikey":null},"gitalk":{"clientID":null,"clientSecret":null,"repo":null,"owner":null,"admin":["name"],"id":"location.pathname","language":"zh-CN","labels":["Gitalk"],"perPage":10,"pagerDirection":"last","distractionFreeMode":false,"createIssueManually":true},"valine":{"appid":"hXIROaIM5y9qnieojJRWP5hS","appkey":"y0f3w3aqd1MF7JL9ma4WECTy","placeholder":"说点什么","path":"window.location.pathname","avatar":"retro","meta":["nick","mail","link"],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"https://zhangpan.site"},"changyan":{"appid":"","appkey":""},"livere":{"uid":""},"archive":{"banner_img":"/img/bg_article.jpg","banner_img_height":60,"banner_mask_alpha":0.3,"subtitle":null},"category":{"banner_img":"/img/bg_default.png","banner_img_height":60,"banner_mask_alpha":0.3,"subtitle":null,"post_limit":10,"order_by":"-length"},"tag":{"banner_img":"/img/bg_label.jpg","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null,"tagcloud":{"min_font":15,"max_font":30,"unit":"px","start_color":"#BBBBEE","end_color":"#337ab7"}},"about":{"banner_img":"/img/bg_default.png","banner_img_height":60,"banner_mask_alpha":0.3,"subtitle":null,"avatar":"/img/avatar.png","name":"myname","introduce":"一句简短的介绍","icons":[{"class":"iconfont icon-github-fill","link":"https://github.com","tip":"GitHub"},{"class":"iconfont icon-douban-fill","link":"https://douban.com","tip":"豆瓣"},{"class":"iconfont icon-wechat-fill","qrcode":"/img/favicon.png"}]},"page404":{"banner_img":"/img/default.png","banner_img_height":85,"banner_mask_alpha":0.3,"subtitle":"Page not found"},"links":{"banner_img":"/img/default.png","banner_img_height":60,"banner_mask_alpha":0.3,"subtitle":null,"items":[{"title":"Fluid Docs","intro":"主题使用指南","link":"https://hexo.fluid-dev.com/docs/","image":"/img/favicon.png"},{"title":"Fluid Repo","intro":"主题 GitHub 仓库","link":"https://github.com/fluid-dev/hexo-theme-fluid","image":"/img/favicon.png"},{"title":"Fluid Example","intro":"主题操作示例","link":"https://hexo.fluid-dev.com/docs/example/","image":"/img/favicon.png"}]}}}},"excerpt":"","more":"<p>今天给大家分享一些开发者必备的神器，这些都是笔者在几年的工作中收集到的，对于开发者非常有用的小工具。我将这些工具分为了四个部分来介绍，分别时—图片篇、文档篇、开发篇和插件篇。文章会对于各个小工具的功能及用途做一个简单介绍，并会给出星级评分，当然评分只能作为参考，因为不同工具对于不同的人有不同的重要性，这些评分是站在笔者角度来分析的。</p>\n<h2 id=\"一、图片篇\"><a href=\"#一、图片篇\" class=\"headerlink\" title=\"一、图片篇\"></a>一、图片篇</h2><h3 id=\"1-GIF神器–ezgif\"><a href=\"#1-GIF神器–ezgif\" class=\"headerlink\" title=\"1.GIF神器–ezgif\"></a><a href=\"https://ezgif.com/video-to-gif\">1.GIF神器–ezgif</a></h3><p>星级评分：<font color=orange >★★★★★</font><br><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi80LzE2ZWQxNGQxMzcxNzQ1NTE?x-oss-process=image/format,png\"><br>这是一个国外站点，从名字上就可以看出这是一个Gif相关的网站。这个网站绝对称得上是一个神器，它不仅可以将视频转换为GIF，还支持GIF图片的编辑、制作、裁剪，修改尺寸、美化甚至还可以GIF转视频、倒放等等众多功能。最重要的一点是完全免费！！！所以这个工具的评分直怼到五分毫不为过。想要了解更多还是大家亲自体验！</p>\n<h3 id=\"2-图片压缩神器–TinyPNG\"><a href=\"#2-图片压缩神器–TinyPNG\" class=\"headerlink\" title=\"2.图片压缩神器–TinyPNG\"></a><a href=\"https://tinypng.com/\">2.图片压缩神器–TinyPNG</a></h3><p>星级评分：<font color=orange >★★★★★</font><br><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi80LzE2ZWQxNGRhYTY0YTFlNTU?x-oss-process=image/format,png\"><br>这是一个图片无损压缩的小工具，同样来自国外。通常在App开发过程中我们都会格外注意App包的内存，拿Android的一个30M的Apk来说可能有一半以上的内存都是图片。而TinyPNG提供了批量压缩打包下载的强大功能。同时，这个网站还提供了MAC和Windows的桌面程序（桌面端限每月500张）。下图是一张Mac桌面端的截图：</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi80LzE2ZWQxNGUwZjU2MjNkZmI?x-oss-process=image/format,png\"><br>可以看到我们从UI拿到的图片，经过TinyPng压缩后体积减少了78.2%-91.1%。但压缩前和压缩后图片的质量肉眼几乎看不出任何差别！这对前端开发同学来说堪称神器。五星毫无悬念！</p>\n<h3 id=\"3-在线作图–ProcessOn\"><a href=\"#3-在线作图–ProcessOn\" class=\"headerlink\" title=\"3.在线作图–ProcessOn\"></a><a href=\"https://www.processon.com/;jsessionid=64008D63D312671F43AE9D007BB51386.jvm1\">3.在线作图–ProcessOn</a></h3><p>星级评分：<font color=orange >★★★★☆</font></p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi80LzE2ZWQxNGU1YmYwMTEyMTk?x-oss-process=image/format,png\"><br>这是一款免费的在线作图工具，支持流程图、思维导图、原型图、UML、网络拓扑图等。这个网站可以说应用广泛，各行各业都可能会用得到。贴一张使用ProcessOn制作的思维导图仅供参考：<br><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi80LzE2ZWQxNGI5YmQ3MWI4MjU?x-oss-process=image/format,png\" alt=\"在这里插入图片描述\"><br>注：图片来源ProcessOn<br>虽然这个网站声称是免费作图，但免费是由一定限制的，每个账号做多可以免费保存十个文件。这也是和前两个网站相比唯一的缺点，毕竟公司也要生存，有盈利才能生存嘛，收费不为过！星级评分四颗星！</p>\n<h3 id=\"4-Android-9阴影图生成器–Android-Shadow-Generator\"><a href=\"#4-Android-9阴影图生成器–Android-Shadow-Generator\" class=\"headerlink\" title=\"4.Android .9阴影图生成器–Android Shadow Generator\"></a><a href=\"https://inloop.github.io/shadow4android/\">4.Android .9阴影图生成器–Android Shadow Generator</a></h3><p>星级评分：<font color=orange >★★★☆☆</font><br><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi80LzE2ZWQxNGI5YmZmZmY3MjU?x-oss-process=image/format,png\" alt=\"在这里插入图片描述\"><br>Android开发的同学都应该比较熟悉.9图，它是一种可以拉伸的图片。同时，做Android开发的同学也应该知道做阴影效果的痛苦。而Android Shadow Generator这个网站就提供了一个可以生成带阴影的.9图。通过这个工具不仅可以定义阴影的大小还可以顶指圆角、颜色等等。但是这个工具使用的局限性比较大，对于Android开发者来说是个不错的福利。三颗星拿走！</p>\n<h3 id=\"5-业界大佬–PhotoShop\"><a href=\"#5-业界大佬–PhotoShop\" class=\"headerlink\" title=\"5.业界大佬–PhotoShop\"></a><a href=\"https://www.adobe.com/cn/products/photoshop/free-trial-download.html\">5.业界大佬–PhotoShop</a></h3><p>星级评分：<font color=orange >★★★★★</font></p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi80LzE2ZWQxNGU5M2JkNjNlYTg?x-oss-process=image/format,png\"><br>这个软件应该不用我去做过多解释了吧，毕竟它的名气可以说无人不知无人不晓。作为一款专业的图像处理软件，想要掌握它并不是一件容易的事，但是作为一个开发人员并不需要掌握太高深的技能，了解一些简单技巧就足以应对常见问题了。没有五颗星说不过去吧？</p>\n<h2 id=\"二、文档篇\"><a href=\"#二、文档篇\" class=\"headerlink\" title=\"二、文档篇\"></a>二、文档篇</h2><h3 id=\"1-PDF神器–Easy-PDF\"><a href=\"#1-PDF神器–Easy-PDF\" class=\"headerlink\" title=\"1.PDF神器–Easy PDF\"></a><a href=\"https://easypdf.com/cn\">1.PDF神器–Easy PDF</a></h3><p>星级评分：<font color=orange >★★★★★</font><br><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi80LzE2ZWQxNGVkYWMwZTVmZGU?x-oss-process=image/format,png\"><br>EasyPDF–又一款神器横空出世，它提供了强大的PDF转换功能，可以PDF转Word、PDF转PPT、Word转PDF…各种PDF转换功能应有尽有。最重要的一点是免费！！！五星还有什么说的么？</p>\n<h3 id=\"2-在线文档编辑器–腾讯文档\"><a href=\"#2-在线文档编辑器–腾讯文档\" class=\"headerlink\" title=\"2.在线文档编辑器–腾讯文档\"></a><a href=\"https://docs.qq.com/desktop\">2.在线文档编辑器–腾讯文档</a></h3><p>星级评分：<font color=orange >★★★★☆</font></p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi80LzE2ZWQxNTQ5YWI0NTZkM2E?x-oss-process=image/format,png\"><br>这是一个免费的在线文档编辑器,提供了在线编辑Word、Excel、PPT等文档，同时可以将文档分享给好友还可以授权好友共同编辑文档。是一个很不错的文档编辑工具。四颗星物有所值。</p>\n<h3 id=\"4-Markdown编辑器–MarkdownPad\"><a href=\"#4-Markdown编辑器–MarkdownPad\" class=\"headerlink\" title=\"4.Markdown编辑器–MarkdownPad\"></a><a href=\"http://markdownpad.com/\">4.Markdown编辑器–MarkdownPad</a></h3><p>星级评分：<font color=orange >★★★☆☆</font></p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi80LzE2ZWQxNjFiNjM5MWUzNDU?x-oss-process=image/format,png\"></p>\n<p>MarkdownPad是一款桌面端的Markdown编辑器，对于经常使用Markdown写博客的开发者来说是一款很好用的工具。但是由于是国外的站点，下载比较慢，且安装好后在Windows上需要协同awesomium才能正常使用。由于使用局限性，且有很多在线的Markdown编辑器，譬如掘金、CSDN、简书(不推荐程序员使用简书，原因你懂的..)等，所以这个工具给三颗星吧。</p>\n<p>另外，放一个百度云的MarkdownPad下载链接，包含了awesomium。</p>\n<p><a href=\"https://pan.baidu.com/s/1fZm_d6ZfXesnx4_wnuMm6g\">MarkdownPad下载</a></p>\n<h2 id=\"三、开发篇\"><a href=\"#三、开发篇\" class=\"headerlink\" title=\"三、开发篇\"></a>三、开发篇</h2><h3 id=\"1-Postman\"><a href=\"#1-Postman\" class=\"headerlink\" title=\"1.Postman\"></a><a href=\"https://www.getpostman.com/\">1.Postman</a></h3><p>星级评分：<font color=orange >★★★★★</font></p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi80LzE2ZWQxNzQ5NzQzYTU1ZGY?x-oss-process=image/format,png\"></p>\n<p>这是一个开发者的神器，不管是前端人员还是后端人员都要必备的一个软件。对于前端人员来说跟后台联调时可以通过postman来模拟请求，可以自定义添加params、authorization、headers、body等，实在是一个开发利器。星级评分五颗星！</p>\n<h3 id=\"2-JSON处理工具–Bejson\"><a href=\"#2-JSON处理工具–Bejson\" class=\"headerlink\" title=\"2.JSON处理工具–Bejson\"></a><a href=\"https://www.bejson.com/\">2.JSON处理工具–Bejson</a></h3><p>星级评分：<font color=orange >★★★★☆</font></p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi80LzE2ZWQxNzRkMmI4OTJkMDg?x-oss-process=image/format,png\"></p>\n<p>这是一款Json格式化的工具，非常贴心好用。切换到Json-&gt;Json视图模式下查看json非常清晰，一目了然。也是四星值得推荐的工具。</p>\n<h2 id=\"四、插件篇\"><a href=\"#四、插件篇\" class=\"headerlink\" title=\"四、插件篇\"></a>四、插件篇</h2><h3 id=\"1-Octotree\"><a href=\"#1-Octotree\" class=\"headerlink\" title=\"1.Octotree\"></a>1.Octotree</h3><p>星级评分：<font color=orange >★★★★☆</font></p>\n<p>如果你是github中毒用户，那么此款插件可谓是一个超级福利。在浏览github时要想打开某个类非常不方便，需要点击跳转好多次。而有了Octotree后就可以像在IDE中一样浏览github项目了。如下图：</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi80LzE2ZWQxN2NlOTc0YzA5NGY?x-oss-process=image/format,png\"></p>\n<h3 id=\"2-彩云小译\"><a href=\"#2-彩云小译\" class=\"headerlink\" title=\"2.彩云小译\"></a>2.彩云小译</h3><p>星级评分：<font color=orange >★★★★☆</font><br>这是一款翻译工具，对于英语不好的同学来说简直就是救星，只要点一下插件就可以直接在原网页上翻译。支持英文翻译中文，同时也支持中文翻译英文。翻译效果如下图所示：</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi80LzE2ZWQxODQzNzI0ZDdiMDA?x-oss-process=image/format,png\"></p>\n<h3 id=\"4-文件转换–Convertio\"><a href=\"#4-文件转换–Convertio\" class=\"headerlink\" title=\"4.文件转换–Convertio\"></a>4.<a href=\"https://convertio.co/zh/\">文件转换–Convertio</a></h3><p>星级评分：<font color=orange >★★★★☆</font></p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi80LzE2ZWQxODdhMzhhOTBiZWM?x-oss-process=image/format,png\"><br>这是一个综合的文件转换平台不仅支持Web端更有Chrome插件。通过Convertio可以转换音频、视频、图像、文档等等。也是一个很不错的值得四颗星的工具。</p>\n<h2 id=\"五、BannerViewPager–Android开发者福利\"><a href=\"#五、BannerViewPager–Android开发者福利\" class=\"headerlink\" title=\"五、BannerViewPager–Android开发者福利\"></a>五、<a href=\"https://github.com/zhpanvip/BannerViewPager\">BannerViewPager–Android开发者福利</a></h2><p>一个非常好用的可以实现任意样式的Banner轮播图–<a href=\"https://github.com/zhpanvip/BannerViewPager\">BannerViewPager</a></p>\n<h3 id=\"据说BannerViewPager可以实现任意Banner样式？\"><a href=\"#据说BannerViewPager可以实现任意Banner样式？\" class=\"headerlink\" title=\"据说BannerViewPager可以实现任意Banner样式？\"></a>据说BannerViewPager可以实现任意Banner样式？</h3><blockquote>\n<p>腾讯视频、QQ音乐、酷狗音乐、支付宝、天猫、淘宝、优酷视频、喜马拉雅、网易云音乐、哔哩哔哩、全民K歌等App的Banner页面样式及指示器样式都可以通过<a href=\"https://github.com/zhpanvip/BannerViewPager\">BannerViewPager</a>实现哦！</p>\n</blockquote>\n<h3 id=\"列举效果预览\"><a href=\"#列举效果预览\" class=\"headerlink\" title=\"列举效果预览\"></a>列举效果预览</h3><table>\n<thead>\n<tr>\n<th>PageStylel</th>\n<th>IndicatorStyle</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi80LzE2ZWQxOWEyMzkxNmY2ZTY?x-oss-process=image/format,png\"></td>\n<td><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi80LzE2ZWQxOWQ0YTMzZWJhZmM?x-oss-process=image/format,png\"></td>\n</tr>\n</tbody></table>\n<p>详情可以查看以下文章：</p>\n<p><a href=\"https://juejin.im/post/5d6bce24f265da03db0790d1\">《打造一个丝滑般自动轮播无限循环Android库》</a></p>\n<p><a href=\"https://juejin.im/post/5d74d3faf265da03b5747015\">《BannerViewPager源码剖析》</a></p>\n<p><a href=\"https://juejin.im/post/5dda0b6d518825731f569a8c\">《剖析BannerViewPager中Indicator的设计思想》</a></p>\n<p><a href=\"https://github.com/zhpanvip/BannerViewPager\">点击此处查看源码</a></p>\n"},{"title":"浅析Java设计模式（三）","date":"2016-07-26T02:26:41.000Z","_content":"\n本篇文章继续来学习Java的设计模式，这篇文章来解析行为型模式种的几种比较常用的设计模式。\n\n一、观察者模式\n观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态发生变化时，会通知所有的观察者对象，使它们能够自动更新自己。以微信推送腾讯新闻为例，用户在微信订阅了腾讯新闻后，用户会收到腾讯的新闻推送。如果用户取消了新闻订阅，那么就不会再收到推送。\n1.创建一个被观察者Observer 接口，接口中有update方法\n\n```\npublic interface Observer {\n\tvoid update(String news);\n}\n```\n\n2.创建观察者Observable接口，接口中有订阅、取消订阅、通知三个方法。\n\n```\npublic interface Observable {\n\tvoid subscribe(Observer observer);\n\tvoid unsubscribe(Observer observer);\n\tvoid notifyObserver();\n}\n\n```\n3.创建TencentNewsObservable并实现Observable接口\n\n```\n\npublic class TencentNewsObservable implements Observable {\n\tprivate List<Observer> observers=new ArrayList<Observer>();\n\tprivate String news;\n\t@Override\n\tpublic void subscribe(Observer observer) {\n\t\tobservers.add(observer);\n\t}\n\n\t@Override\n\tpublic void unsubscribe(Observer observer) {\n\t\tobservers.remove(observer);\n\t}\n\n\t@Override\n\tpublic void notifyObserver() {\n\t\tfor(Observer observer:observers) {\n\t\t\tobserver.update(news);\n\t\t}\n\t}\n\t\n\tpublic void sendNews(String news) {\n\t\tthis.news=news;\n\t\tnotifyObserver();\n\t}\n\n}\n```\n4.定义一个UserObserver并实现Observer接口\n\n```\npublic class UserObserver implements Observer{\n\tprivate String name;\n\t\n\tpublic UserObserver(String name) {\n\t\tthis.name=name;\n\t}\n\n\t@Override\n\tpublic void update(String news) {\n\t\tSystem.out.println(name+\"收到一条消息：\"+news);\n\t}\n}\n```\n5.编写测试类\n\n```\npublic class ObserverTest {\n\n\tpublic static void main(String[] args) {\n\t\tUserObserver mike=new UserObserver(\"Mike\");\n\t\tUserObserver lucy=new UserObserver(\"Lucy\");\n\t\tUserObserver kate=new UserObserver(\"Kate\");\n\t\tTencentNewsObservable observerable=new TencentNewsObservable();\n\t\t\n\t\tobserverable.subscribe(mike);\n\t\tobserverable.subscribe(lucy);\n\t\tobserverable.subscribe(kate);\n\t\tobserverable.sendNews(\"this is an ad\");\n\t}\n}\n```\n运行结果：\n\n> Mike收到一条消息：this is an advertisement\nLucy收到一条消息：this is an advertisement\nKate收到一条消息：this is an advertisement\n\n此时Mike收到推送打开后一看，竟然是一条广告，愤怒之下取消了订阅！\n\n```\n\t\tSystem.out.println(\"Mike unsubscribe news\");\n\t\tobserverable.unsubscribe(mike);\n\t\tobserverable.sendNews(\"this is a news\");\n```\n运行结果：\n\n> Mike收到一条消息：this is an advertisement\nLucy收到一条消息：this is an advertisement\nKate收到一条消息：this is an advertisement\nMike unsubscribe news\nLucy收到一条消息：this is a news\nKate收到一条消息：this is a news\n\n取消订阅后Mike再也没有收到新闻推送。\n\n二、策略模式\n策略模式定义了一系列的算法，并将每一个算法封装起来，而且使他们可以相互替换，让算法独立于使用它的客户而独立变化。策略模式设计三个角色，环境(Context)角色、抽象策略(Strategy)角色以及具体策略(ConcreteStrategy)角色。\n来看一个现实生活的例子，假设一个商场有三种会员（Strategy），分别为普通会员（StandardMemberStraegy）、白银会员（SilverMemberStrategy）以及黄金会员（GoldenMemberStrategy）。针对三种会员分别制定了不同的优方案。普通会员打九折、白银会员打八折、黄金会员打七折。来看如何用策略模式实现上述场景。\n1.创建抽象策略类\n\n```\npublic abstract class Strategy {\n\t\n\tprivate String strategy;\n\t\n\t\n\tpublic String getStrategy() {\n\t\treturn strategy;\n\t}\n\n\n\n\tpublic Strategy(String strategy) {\n\t\tsuper();\n\t\tthis.strategy = strategy;\n\t}\n\t\n\tabstract double getPrice(double normalPrice);\n}\n```\n2.创建环境类（Context）并持有抽象策略类\n\n```\npublic class Context {\n\tprivate Strategy mStrategy;\n\t\n\tpublic void setStrategy(Strategy strategy) {\n\t\tmStrategy=strategy;\n\t}\n\t\n\tpublic double executePrice(double normalPrice) {\n\t\tSystem.out.println(mStrategy.getStrategy()+\"Member，折后价：\"+mStrategy.getPrice(normalPrice));\n\t\treturn mStrategy.getPrice(normalPrice);\n\t}\n}\n```\n3.创建三种会员策略类\n\n```\npublic class StandardMemberStraegy extends Strategy {\n\t\n\tpublic StandardMemberStraegy(String strategy) {\n\t\tsuper(strategy);\n\t}\n\n\t@Override\n\tpublic double getPrice(double normalPrice) {\n\t\treturn 0.9*normalPrice;\n\t}\n}\n\npublic class SilverMemberStrategy extends Strategy{\n\n\tpublic SilverMemberStrategy(String strategy) {\n\t\tsuper(strategy);\n\t}\n\n\t@Override\n\tpublic double getPrice(double normalPrice) {\n\t\treturn 0.8*normalPrice;\n\t}\n\n}\n\npublic class GoldenMemberStrategy extends Strategy {\n\n\n\tpublic GoldenMemberStrategy(String strategy) {\n\t\tsuper(strategy);\n\t}\n\n\t@Override\n\tpublic double getPrice(double normalPrice) {\n\t\treturn 0.7*normalPrice;\n\t}\n\t\n}\n```\n4.创建策略模式测试类\n\n```\npublic class StrategyTest {\n\n\tpublic static void main(String[] args) {\n\t\tStandardMemberStraegy standar=new StandardMemberStraegy(\"Standar\");\n\t\tSilverMemberStrategy silver=new SilverMemberStrategy(\"Silver\");\n\t\tGoldenMemberStrategy golden=new GoldenMemberStrategy(\"Golden\");\n\t\tContext context=new Context();\n\t\t\n\t\tcontext.setStrategy(standar);\n\t\tcontext.executePrice(100);\n\t\t\n\t\tcontext.setStrategy(silver);\n\t\tcontext.executePrice(100);\n\t\t\n\t\tcontext.setStrategy(golden);\n\t\tcontext.executePrice(100);\n\t}\n\n}\n```\n运行结果：\n\n> StandarMember，折后价：90.0\nSilverMember，折后价：80.0\nGoldenMember，折后价：70.0\n\n","source":"_posts/3.浅析Java设计模式（三）.md","raw":"---\ntitle: 浅析Java设计模式（三）\ndate: 2016-07-26 10:26:41\ntags:\n- 设计模式\n---\n\n本篇文章继续来学习Java的设计模式，这篇文章来解析行为型模式种的几种比较常用的设计模式。\n\n一、观察者模式\n观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态发生变化时，会通知所有的观察者对象，使它们能够自动更新自己。以微信推送腾讯新闻为例，用户在微信订阅了腾讯新闻后，用户会收到腾讯的新闻推送。如果用户取消了新闻订阅，那么就不会再收到推送。\n1.创建一个被观察者Observer 接口，接口中有update方法\n\n```\npublic interface Observer {\n\tvoid update(String news);\n}\n```\n\n2.创建观察者Observable接口，接口中有订阅、取消订阅、通知三个方法。\n\n```\npublic interface Observable {\n\tvoid subscribe(Observer observer);\n\tvoid unsubscribe(Observer observer);\n\tvoid notifyObserver();\n}\n\n```\n3.创建TencentNewsObservable并实现Observable接口\n\n```\n\npublic class TencentNewsObservable implements Observable {\n\tprivate List<Observer> observers=new ArrayList<Observer>();\n\tprivate String news;\n\t@Override\n\tpublic void subscribe(Observer observer) {\n\t\tobservers.add(observer);\n\t}\n\n\t@Override\n\tpublic void unsubscribe(Observer observer) {\n\t\tobservers.remove(observer);\n\t}\n\n\t@Override\n\tpublic void notifyObserver() {\n\t\tfor(Observer observer:observers) {\n\t\t\tobserver.update(news);\n\t\t}\n\t}\n\t\n\tpublic void sendNews(String news) {\n\t\tthis.news=news;\n\t\tnotifyObserver();\n\t}\n\n}\n```\n4.定义一个UserObserver并实现Observer接口\n\n```\npublic class UserObserver implements Observer{\n\tprivate String name;\n\t\n\tpublic UserObserver(String name) {\n\t\tthis.name=name;\n\t}\n\n\t@Override\n\tpublic void update(String news) {\n\t\tSystem.out.println(name+\"收到一条消息：\"+news);\n\t}\n}\n```\n5.编写测试类\n\n```\npublic class ObserverTest {\n\n\tpublic static void main(String[] args) {\n\t\tUserObserver mike=new UserObserver(\"Mike\");\n\t\tUserObserver lucy=new UserObserver(\"Lucy\");\n\t\tUserObserver kate=new UserObserver(\"Kate\");\n\t\tTencentNewsObservable observerable=new TencentNewsObservable();\n\t\t\n\t\tobserverable.subscribe(mike);\n\t\tobserverable.subscribe(lucy);\n\t\tobserverable.subscribe(kate);\n\t\tobserverable.sendNews(\"this is an ad\");\n\t}\n}\n```\n运行结果：\n\n> Mike收到一条消息：this is an advertisement\nLucy收到一条消息：this is an advertisement\nKate收到一条消息：this is an advertisement\n\n此时Mike收到推送打开后一看，竟然是一条广告，愤怒之下取消了订阅！\n\n```\n\t\tSystem.out.println(\"Mike unsubscribe news\");\n\t\tobserverable.unsubscribe(mike);\n\t\tobserverable.sendNews(\"this is a news\");\n```\n运行结果：\n\n> Mike收到一条消息：this is an advertisement\nLucy收到一条消息：this is an advertisement\nKate收到一条消息：this is an advertisement\nMike unsubscribe news\nLucy收到一条消息：this is a news\nKate收到一条消息：this is a news\n\n取消订阅后Mike再也没有收到新闻推送。\n\n二、策略模式\n策略模式定义了一系列的算法，并将每一个算法封装起来，而且使他们可以相互替换，让算法独立于使用它的客户而独立变化。策略模式设计三个角色，环境(Context)角色、抽象策略(Strategy)角色以及具体策略(ConcreteStrategy)角色。\n来看一个现实生活的例子，假设一个商场有三种会员（Strategy），分别为普通会员（StandardMemberStraegy）、白银会员（SilverMemberStrategy）以及黄金会员（GoldenMemberStrategy）。针对三种会员分别制定了不同的优方案。普通会员打九折、白银会员打八折、黄金会员打七折。来看如何用策略模式实现上述场景。\n1.创建抽象策略类\n\n```\npublic abstract class Strategy {\n\t\n\tprivate String strategy;\n\t\n\t\n\tpublic String getStrategy() {\n\t\treturn strategy;\n\t}\n\n\n\n\tpublic Strategy(String strategy) {\n\t\tsuper();\n\t\tthis.strategy = strategy;\n\t}\n\t\n\tabstract double getPrice(double normalPrice);\n}\n```\n2.创建环境类（Context）并持有抽象策略类\n\n```\npublic class Context {\n\tprivate Strategy mStrategy;\n\t\n\tpublic void setStrategy(Strategy strategy) {\n\t\tmStrategy=strategy;\n\t}\n\t\n\tpublic double executePrice(double normalPrice) {\n\t\tSystem.out.println(mStrategy.getStrategy()+\"Member，折后价：\"+mStrategy.getPrice(normalPrice));\n\t\treturn mStrategy.getPrice(normalPrice);\n\t}\n}\n```\n3.创建三种会员策略类\n\n```\npublic class StandardMemberStraegy extends Strategy {\n\t\n\tpublic StandardMemberStraegy(String strategy) {\n\t\tsuper(strategy);\n\t}\n\n\t@Override\n\tpublic double getPrice(double normalPrice) {\n\t\treturn 0.9*normalPrice;\n\t}\n}\n\npublic class SilverMemberStrategy extends Strategy{\n\n\tpublic SilverMemberStrategy(String strategy) {\n\t\tsuper(strategy);\n\t}\n\n\t@Override\n\tpublic double getPrice(double normalPrice) {\n\t\treturn 0.8*normalPrice;\n\t}\n\n}\n\npublic class GoldenMemberStrategy extends Strategy {\n\n\n\tpublic GoldenMemberStrategy(String strategy) {\n\t\tsuper(strategy);\n\t}\n\n\t@Override\n\tpublic double getPrice(double normalPrice) {\n\t\treturn 0.7*normalPrice;\n\t}\n\t\n}\n```\n4.创建策略模式测试类\n\n```\npublic class StrategyTest {\n\n\tpublic static void main(String[] args) {\n\t\tStandardMemberStraegy standar=new StandardMemberStraegy(\"Standar\");\n\t\tSilverMemberStrategy silver=new SilverMemberStrategy(\"Silver\");\n\t\tGoldenMemberStrategy golden=new GoldenMemberStrategy(\"Golden\");\n\t\tContext context=new Context();\n\t\t\n\t\tcontext.setStrategy(standar);\n\t\tcontext.executePrice(100);\n\t\t\n\t\tcontext.setStrategy(silver);\n\t\tcontext.executePrice(100);\n\t\t\n\t\tcontext.setStrategy(golden);\n\t\tcontext.executePrice(100);\n\t}\n\n}\n```\n运行结果：\n\n> StandarMember，折后价：90.0\nSilverMember，折后价：80.0\nGoldenMember，折后价：70.0\n\n","slug":"3.浅析Java设计模式（三）","published":1,"updated":"2020-08-29T18:02:44.212Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckegm5nrx000ddwoz983q8l7l","content":"<p>本篇文章继续来学习Java的设计模式，这篇文章来解析行为型模式种的几种比较常用的设计模式。</p>\n<p>一、观察者模式<br>观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态发生变化时，会通知所有的观察者对象，使它们能够自动更新自己。以微信推送腾讯新闻为例，用户在微信订阅了腾讯新闻后，用户会收到腾讯的新闻推送。如果用户取消了新闻订阅，那么就不会再收到推送。<br>1.创建一个被观察者Observer 接口，接口中有update方法</p>\n<pre><code class=\"hljs routeros\">public<span class=\"hljs-built_in\"> interface </span>Observer &#123;\n\tvoid update(String news);\n&#125;</code></pre>\n\n<p>2.创建观察者Observable接口，接口中有订阅、取消订阅、通知三个方法。</p>\n<pre><code class=\"hljs routeros\">public<span class=\"hljs-built_in\"> interface </span>Observable &#123;\n\tvoid subscribe(Observer observer);\n\tvoid unsubscribe(Observer observer);\n\tvoid notifyObserver();\n&#125;\n</code></pre>\n<p>3.创建TencentNewsObservable并实现Observable接口</p>\n<pre><code class=\"hljs haxe\">\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">TencentNewsObservable</span> <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">implements</span> <span class=\"hljs-type\">Observable</span></span> </span>&#123;\n\t<span class=\"hljs-keyword\">private</span> List&lt;Observer&gt; observers=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">ArrayList</span>&lt;Observer&gt;();\n\t<span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">String</span> <span class=\"hljs-keyword\">new</span><span class=\"hljs-type\">s</span>;\n\t@Override\n\t<span class=\"hljs-keyword\">public</span> void subscribe(Observer observer) &#123;\n\t\tobservers.add(observer);\n\t&#125;\n\n\t@Override\n\t<span class=\"hljs-keyword\">public</span> void unsubscribe(Observer observer) &#123;\n\t\tobservers.remove(observer);\n\t&#125;\n\n\t@Override\n\t<span class=\"hljs-keyword\">public</span> void notifyObserver() &#123;\n\t\t<span class=\"hljs-keyword\">for</span>(Observer observer:<span class=\"hljs-type\">observers</span>) &#123;\n\t\t\tobserver.update(<span class=\"hljs-keyword\">new</span><span class=\"hljs-type\">s</span>);\n\t\t&#125;\n\t&#125;\n\t\n\t<span class=\"hljs-keyword\">public</span> void sendNews(<span class=\"hljs-keyword\">String</span> <span class=\"hljs-keyword\">new</span><span class=\"hljs-type\">s</span>) &#123;\n\t\t<span class=\"hljs-built_in\">this</span>.<span class=\"hljs-keyword\">new</span><span class=\"hljs-type\">s</span>=<span class=\"hljs-keyword\">new</span><span class=\"hljs-type\">s</span>;\n\t\tnotifyObserver();\n\t&#125;\n\n&#125;</code></pre>\n<p>4.定义一个UserObserver并实现Observer接口</p>\n<pre><code class=\"hljs haxe\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">UserObserver</span> <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">implements</span> <span class=\"hljs-type\">Observer</span></span></span>&#123;\n\t<span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">String</span> name;\n\t\n\t<span class=\"hljs-keyword\">public</span> UserObserver(<span class=\"hljs-keyword\">String</span> name) &#123;\n\t\t<span class=\"hljs-built_in\">this</span>.name=name;\n\t&#125;\n\n\t@Override\n\t<span class=\"hljs-keyword\">public</span> void update(<span class=\"hljs-keyword\">String</span> <span class=\"hljs-keyword\">new</span><span class=\"hljs-type\">s</span>) &#123;\n\t\tSystem.out.println(name+<span class=\"hljs-string\">&quot;收到一条消息：&quot;</span>+<span class=\"hljs-keyword\">new</span><span class=\"hljs-type\">s</span>);\n\t&#125;\n&#125;</code></pre>\n<p>5.编写测试类</p>\n<pre><code class=\"hljs haxe\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ObserverTest</span> </span>&#123;\n\n\t<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> void main(<span class=\"hljs-keyword\">String</span>[] args) &#123;\n\t\tUserObserver mike=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">UserObserver</span>(<span class=\"hljs-string\">&quot;Mike&quot;</span>);\n\t\tUserObserver lucy=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">UserObserver</span>(<span class=\"hljs-string\">&quot;Lucy&quot;</span>);\n\t\tUserObserver kate=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">UserObserver</span>(<span class=\"hljs-string\">&quot;Kate&quot;</span>);\n\t\tTencentNewsObservable observerable=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">TencentNewsObservable</span>();\n\t\t\n\t\tobserverable.subscribe(mike);\n\t\tobserverable.subscribe(lucy);\n\t\tobserverable.subscribe(kate);\n\t\tobserverable.sendNews(<span class=\"hljs-string\">&quot;this is an ad&quot;</span>);\n\t&#125;\n&#125;</code></pre>\n<p>运行结果：</p>\n<blockquote>\n<p>Mike收到一条消息：this is an advertisement<br>Lucy收到一条消息：this is an advertisement<br>Kate收到一条消息：this is an advertisement</p>\n</blockquote>\n<p>此时Mike收到推送打开后一看，竟然是一条广告，愤怒之下取消了订阅！</p>\n<pre><code class=\"hljs abnf\">System.out.println(<span class=\"hljs-string\">&quot;Mike unsubscribe news&quot;</span>)<span class=\"hljs-comment\">;</span>\nobserverable.unsubscribe(mike)<span class=\"hljs-comment\">;</span>\nobserverable.sendNews(<span class=\"hljs-string\">&quot;this is a news&quot;</span>)<span class=\"hljs-comment\">;</span></code></pre>\n<p>运行结果：</p>\n<blockquote>\n<p>Mike收到一条消息：this is an advertisement<br>Lucy收到一条消息：this is an advertisement<br>Kate收到一条消息：this is an advertisement<br>Mike unsubscribe news<br>Lucy收到一条消息：this is a news<br>Kate收到一条消息：this is a news</p>\n</blockquote>\n<p>取消订阅后Mike再也没有收到新闻推送。</p>\n<p>二、策略模式<br>策略模式定义了一系列的算法，并将每一个算法封装起来，而且使他们可以相互替换，让算法独立于使用它的客户而独立变化。策略模式设计三个角色，环境(Context)角色、抽象策略(Strategy)角色以及具体策略(ConcreteStrategy)角色。<br>来看一个现实生活的例子，假设一个商场有三种会员（Strategy），分别为普通会员（StandardMemberStraegy）、白银会员（SilverMemberStrategy）以及黄金会员（GoldenMemberStrategy）。针对三种会员分别制定了不同的优方案。普通会员打九折、白银会员打八折、黄金会员打七折。来看如何用策略模式实现上述场景。<br>1.创建抽象策略类</p>\n<pre><code class=\"hljs arduino\"><span class=\"hljs-keyword\">public</span> abstract <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Strategy</span> &#123;</span>\n\t\n\t<span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">String</span> strategy;\n\t\n\t\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">String</span> <span class=\"hljs-title\">getStrategy</span><span class=\"hljs-params\">()</span> </span>&#123;\n\t\t<span class=\"hljs-keyword\">return</span> strategy;\n\t&#125;\n\n\n\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">Strategy</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">String</span> strategy)</span> </span>&#123;\n\t\tsuper();\n\t\t<span class=\"hljs-keyword\">this</span>.strategy = strategy;\n\t&#125;\n\t\n\t<span class=\"hljs-function\">abstract <span class=\"hljs-keyword\">double</span> <span class=\"hljs-title\">getPrice</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">double</span> normalPrice)</span></span>;\n&#125;</code></pre>\n<p>2.创建环境类（Context）并持有抽象策略类</p>\n<pre><code class=\"hljs reasonml\">public <span class=\"hljs-keyword\">class</span> Context &#123;\n\t<span class=\"hljs-keyword\">private</span> Strategy mStrategy;\n\t\n\tpublic void set<span class=\"hljs-constructor\">Strategy(Strategy <span class=\"hljs-params\">strategy</span>)</span> &#123;\n\t\tmStrategy=strategy;\n\t&#125;\n\t\n\tpublic double execute<span class=\"hljs-constructor\">Price(<span class=\"hljs-params\">double</span> <span class=\"hljs-params\">normalPrice</span>)</span> &#123;\n\t\t<span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">System</span>.</span></span>out.println(mStrategy.get<span class=\"hljs-constructor\">Strategy()</span>+<span class=\"hljs-string\">&quot;Member，折后价：&quot;</span>+mStrategy.get<span class=\"hljs-constructor\">Price(<span class=\"hljs-params\">normalPrice</span>)</span>);\n\t\treturn mStrategy.get<span class=\"hljs-constructor\">Price(<span class=\"hljs-params\">normalPrice</span>)</span>;\n\t&#125;\n&#125;</code></pre>\n<p>3.创建三种会员策略类</p>\n<pre><code class=\"hljs scala\">public <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">StandardMemberStraegy</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Strategy</span> </span>&#123;\n\t\n\tpublic <span class=\"hljs-type\">StandardMemberStraegy</span>(<span class=\"hljs-type\">String</span> strategy) &#123;\n\t\t<span class=\"hljs-keyword\">super</span>(strategy);\n\t&#125;\n\n\t<span class=\"hljs-meta\">@Override</span>\n\tpublic double getPrice(double normalPrice) &#123;\n\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0.9</span>*normalPrice;\n\t&#125;\n&#125;\n\npublic <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">SilverMemberStrategy</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Strategy</span></span>&#123;\n\n\tpublic <span class=\"hljs-type\">SilverMemberStrategy</span>(<span class=\"hljs-type\">String</span> strategy) &#123;\n\t\t<span class=\"hljs-keyword\">super</span>(strategy);\n\t&#125;\n\n\t<span class=\"hljs-meta\">@Override</span>\n\tpublic double getPrice(double normalPrice) &#123;\n\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0.8</span>*normalPrice;\n\t&#125;\n\n&#125;\n\npublic <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">GoldenMemberStrategy</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Strategy</span> </span>&#123;\n\n\n\tpublic <span class=\"hljs-type\">GoldenMemberStrategy</span>(<span class=\"hljs-type\">String</span> strategy) &#123;\n\t\t<span class=\"hljs-keyword\">super</span>(strategy);\n\t&#125;\n\n\t<span class=\"hljs-meta\">@Override</span>\n\tpublic double getPrice(double normalPrice) &#123;\n\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0.7</span>*normalPrice;\n\t&#125;\n\t\n&#125;</code></pre>\n<p>4.创建策略模式测试类</p>\n<pre><code class=\"hljs reasonml\">public <span class=\"hljs-keyword\">class</span> StrategyTest &#123;\n\n\tpublic static void main(String<span class=\"hljs-literal\">[]</span> args) &#123;\n\t\tStandardMemberStraegy standar=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-constructor\">StandardMemberStraegy(<span class=\"hljs-string\">&quot;Standar&quot;</span>)</span>;\n\t\tSilverMemberStrategy silver=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-constructor\">SilverMemberStrategy(<span class=\"hljs-string\">&quot;Silver&quot;</span>)</span>;\n\t\tGoldenMemberStrategy golden=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-constructor\">GoldenMemberStrategy(<span class=\"hljs-string\">&quot;Golden&quot;</span>)</span>;\n\t\tContext context=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-constructor\">Context()</span>;\n\t\t\n\t\tcontext.set<span class=\"hljs-constructor\">Strategy(<span class=\"hljs-params\">standar</span>)</span>;\n\t\tcontext.execute<span class=\"hljs-constructor\">Price(100)</span>;\n\t\t\n\t\tcontext.set<span class=\"hljs-constructor\">Strategy(<span class=\"hljs-params\">silver</span>)</span>;\n\t\tcontext.execute<span class=\"hljs-constructor\">Price(100)</span>;\n\t\t\n\t\tcontext.set<span class=\"hljs-constructor\">Strategy(<span class=\"hljs-params\">golden</span>)</span>;\n\t\tcontext.execute<span class=\"hljs-constructor\">Price(100)</span>;\n\t&#125;\n\n&#125;</code></pre>\n<p>运行结果：</p>\n<blockquote>\n<p>StandarMember，折后价：90.0<br>SilverMember，折后价：80.0<br>GoldenMember，折后价：70.0</p>\n</blockquote>\n","site":{"data":{"fluid_config":{"favicon":"/img/favicon.png","apple_touch_icon":"/img/favicon.png","title_join_string":" - ","force_https":false,"highlight":{"enable":true,"style":"Github Gist","bg_color":false,"copy_btn":true},"fun_features":{"typing":{"enable":true,"typeSpeed":70,"cursorChar":"|","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"mouse_click":{"enable":false,"style":"values"}},"dark_mode":{"enable":true,"default":"auto"},"color":{"body_bg_color":"#eee","body_bg_color_dark":"#181c27","navbar_bg_color":"#2f4154","navbar_bg_color_dark":"#1f3144","navbar_text_color":"#fff","navbar_text_color_dark":"#d0d0d0","text_color":"#3c4858","text_color_dark":"#c4c6c9","sec_text_color":"#718096","sec_text_color_dark":"#a7a9ad","post_text_color":"#2c3e50","post_text_color_dark":"#c4c6c9","post_heading_color":"#1a202c","post_heading_color_dark":"#c4c6c9","post_link_color":"#0366d6","post_link_color_dark":"#1589e9","link_hover_color":"#30a9de","link_hover_color_dark":"#30a9de","link_hover_bg_color":"#f8f9fa","link_hover_bg_color_dark":"#364151","board_color":"#fff","board_color_dark":"#252d38"},"font":{"font_size":"16px","font_family":null,"code_font_size":"85%"},"custom_js":null,"custom_css":null,"custom_html":"","web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"tajs":null,"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}},"lazyload":{"enable":true,"onlypost":false},"daovoice":{"enable":false,"appid":""},"aplayer":{"enable":false,"autoplay":false,"loop":"all","order":"random","theme":"#b7daff","songs":[{"name":"name","artist":"artist","url":"/songs/test.mp3","cover":"/img/cover.jpg"},{"name":"name","artist":"artist","url":"https://...url.mp3","cover":"https://...cover.jpg"}]},"version":{"check":false},"navbar":{"blog_title":"zhangpan","ground_glass":{"enable":false,"px":3,"alpha":0.7},"menu":[{"key":"home","link":"/","icon":"iconfont icon-home-fill"},{"key":"archive","link":"/archives/","icon":"iconfont icon-archive-fill"},{"key":"category","link":"/categories/","icon":"iconfont icon-category-fill"},{"key":"tag","link":"/tags/","icon":"iconfont icon-tags-fill"},{"key":"about","link":"/about/","icon":"iconfont icon-user-fill"}]},"search":{"enable":true,"path":"/local-search.xml","generate_path":"/local-search.xml","field":"post","content":true},"scroll_down_arrow":{"enable":true,"banner_height_limit":90,"scroll_after_turning_page":true},"banner_parallax":true,"footer":{"statistics":{"enable":false,"source":"busuanzi","pv_format":"总访问量 {} 次","uv_format":"总访客数 {} 人"},"beian":{"enable":false,"icp_text":"京ICP证123456号","police_text":"京公网安备12345678号","police_code":12345678,"police_icon":"/img/police_beian.png"}},"scroll_top_arrow":{"enable":true},"index":{"banner_img":"/img/default.png","banner_img_height":100,"banner_mask_alpha":0.3,"post_default_img":"","slogan":{"enable":true,"text":"Talk is cheap, show me the code."},"auto_excerpt":{"enable":true},"post_url_target":"_self","post_meta":{"date":true,"category":true,"tag":true}},"page":{"banner_img":"/img/default.png","banner_img_height":60,"banner_mask_alpha":0.3},"post":{"banner_img":"/img/default.png","banner_img_height":70,"banner_mask_alpha":0.3,"meta":{"date":{"enable":true,"format":"LL a"},"wordcount":{"enable":true,"format":"{} 字"},"min2read":{"enable":true,"format":"{} 分钟","words":100},"views":{"enable":false,"source":"busuanzi","format":"{} 次"}},"updated":{"enable":false,"content":"本文最后更新于：","relative":false},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"copyright":{"enable":true,"content":"本博客所有文章除特别声明外，均采用 <a href=\"https://creativecommons.org/licenses/by-sa/4.0/deed.zh\" rel=\"nofollow noopener\">CC BY-SA 4.0 协议</a> ，转载请注明出处！ <h5>开源库推荐</h5> <a href=\"https://github.com/zhpanvip/BannerViewPager\">1.BannerViewPager</a> <p> 一个基于ViewPager2实现的具有强大功能的无限轮播库。支持多种页面切换效果和指示器样式。 </p>\n<a href=\"https://github.com/zhpanvip/viewpagerindicator\">2.ViewPagerIndicator</a> <p> 一个适用于ViewPager和ViewPager2的指示器，支持多种滑块样式及滑动模式 </p>"},"prev_next":{"enable":true},"custom":{"enable":false,"content":"<img src=\"https://octodex.github.com/images/jetpacktocat.png\" class=\"rounded mx-auto d-block mt-5\" style=\"width:150px; height:150px;\">"},"image_zoom":{"enable":true},"footnote":{"enable":true,"header":""},"math":{"enable":false,"specific":false,"engine":"mathjax"},"mermaid":{"enable":false,"specific":false,"options":{"theme":"default"}},"comments":{"enable":true,"type":"utterances"}},"utterances":{"repo":"zhpanvip/utterances-comment","issue_term":"pathname","label":"utterances","theme":"github-light","crossorigin":"anonymous"},"disqus":{"shortname":null,"disqusjs":false,"apikey":null},"gitalk":{"clientID":null,"clientSecret":null,"repo":null,"owner":null,"admin":["name"],"id":"location.pathname","language":"zh-CN","labels":["Gitalk"],"perPage":10,"pagerDirection":"last","distractionFreeMode":false,"createIssueManually":true},"valine":{"appid":"hXIROaIM5y9qnieojJRWP5hS","appkey":"y0f3w3aqd1MF7JL9ma4WECTy","placeholder":"说点什么","path":"window.location.pathname","avatar":"retro","meta":["nick","mail","link"],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"https://zhangpan.site"},"changyan":{"appid":"","appkey":""},"livere":{"uid":""},"archive":{"banner_img":"/img/bg_article.jpg","banner_img_height":60,"banner_mask_alpha":0.3,"subtitle":null},"category":{"banner_img":"/img/bg_default.png","banner_img_height":60,"banner_mask_alpha":0.3,"subtitle":null,"post_limit":10,"order_by":"-length"},"tag":{"banner_img":"/img/bg_label.jpg","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null,"tagcloud":{"min_font":15,"max_font":30,"unit":"px","start_color":"#BBBBEE","end_color":"#337ab7"}},"about":{"banner_img":"/img/bg_default.png","banner_img_height":60,"banner_mask_alpha":0.3,"subtitle":null,"avatar":"/img/avatar.png","name":"myname","introduce":"一句简短的介绍","icons":[{"class":"iconfont icon-github-fill","link":"https://github.com","tip":"GitHub"},{"class":"iconfont icon-douban-fill","link":"https://douban.com","tip":"豆瓣"},{"class":"iconfont icon-wechat-fill","qrcode":"/img/favicon.png"}]},"page404":{"banner_img":"/img/default.png","banner_img_height":85,"banner_mask_alpha":0.3,"subtitle":"Page not found"},"links":{"banner_img":"/img/default.png","banner_img_height":60,"banner_mask_alpha":0.3,"subtitle":null,"items":[{"title":"Fluid Docs","intro":"主题使用指南","link":"https://hexo.fluid-dev.com/docs/","image":"/img/favicon.png"},{"title":"Fluid Repo","intro":"主题 GitHub 仓库","link":"https://github.com/fluid-dev/hexo-theme-fluid","image":"/img/favicon.png"},{"title":"Fluid Example","intro":"主题操作示例","link":"https://hexo.fluid-dev.com/docs/example/","image":"/img/favicon.png"}]}}}},"excerpt":"","more":"<p>本篇文章继续来学习Java的设计模式，这篇文章来解析行为型模式种的几种比较常用的设计模式。</p>\n<p>一、观察者模式<br>观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态发生变化时，会通知所有的观察者对象，使它们能够自动更新自己。以微信推送腾讯新闻为例，用户在微信订阅了腾讯新闻后，用户会收到腾讯的新闻推送。如果用户取消了新闻订阅，那么就不会再收到推送。<br>1.创建一个被观察者Observer 接口，接口中有update方法</p>\n<pre><code class=\"hljs routeros\">public<span class=\"hljs-built_in\"> interface </span>Observer &#123;\n\tvoid update(String news);\n&#125;</code></pre>\n\n<p>2.创建观察者Observable接口，接口中有订阅、取消订阅、通知三个方法。</p>\n<pre><code class=\"hljs routeros\">public<span class=\"hljs-built_in\"> interface </span>Observable &#123;\n\tvoid subscribe(Observer observer);\n\tvoid unsubscribe(Observer observer);\n\tvoid notifyObserver();\n&#125;\n</code></pre>\n<p>3.创建TencentNewsObservable并实现Observable接口</p>\n<pre><code class=\"hljs haxe\">\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">TencentNewsObservable</span> <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">implements</span> <span class=\"hljs-type\">Observable</span></span> </span>&#123;\n\t<span class=\"hljs-keyword\">private</span> List&lt;Observer&gt; observers=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">ArrayList</span>&lt;Observer&gt;();\n\t<span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">String</span> <span class=\"hljs-keyword\">new</span><span class=\"hljs-type\">s</span>;\n\t@Override\n\t<span class=\"hljs-keyword\">public</span> void subscribe(Observer observer) &#123;\n\t\tobservers.add(observer);\n\t&#125;\n\n\t@Override\n\t<span class=\"hljs-keyword\">public</span> void unsubscribe(Observer observer) &#123;\n\t\tobservers.remove(observer);\n\t&#125;\n\n\t@Override\n\t<span class=\"hljs-keyword\">public</span> void notifyObserver() &#123;\n\t\t<span class=\"hljs-keyword\">for</span>(Observer observer:<span class=\"hljs-type\">observers</span>) &#123;\n\t\t\tobserver.update(<span class=\"hljs-keyword\">new</span><span class=\"hljs-type\">s</span>);\n\t\t&#125;\n\t&#125;\n\t\n\t<span class=\"hljs-keyword\">public</span> void sendNews(<span class=\"hljs-keyword\">String</span> <span class=\"hljs-keyword\">new</span><span class=\"hljs-type\">s</span>) &#123;\n\t\t<span class=\"hljs-built_in\">this</span>.<span class=\"hljs-keyword\">new</span><span class=\"hljs-type\">s</span>=<span class=\"hljs-keyword\">new</span><span class=\"hljs-type\">s</span>;\n\t\tnotifyObserver();\n\t&#125;\n\n&#125;</code></pre>\n<p>4.定义一个UserObserver并实现Observer接口</p>\n<pre><code class=\"hljs haxe\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">UserObserver</span> <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">implements</span> <span class=\"hljs-type\">Observer</span></span></span>&#123;\n\t<span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">String</span> name;\n\t\n\t<span class=\"hljs-keyword\">public</span> UserObserver(<span class=\"hljs-keyword\">String</span> name) &#123;\n\t\t<span class=\"hljs-built_in\">this</span>.name=name;\n\t&#125;\n\n\t@Override\n\t<span class=\"hljs-keyword\">public</span> void update(<span class=\"hljs-keyword\">String</span> <span class=\"hljs-keyword\">new</span><span class=\"hljs-type\">s</span>) &#123;\n\t\tSystem.out.println(name+<span class=\"hljs-string\">&quot;收到一条消息：&quot;</span>+<span class=\"hljs-keyword\">new</span><span class=\"hljs-type\">s</span>);\n\t&#125;\n&#125;</code></pre>\n<p>5.编写测试类</p>\n<pre><code class=\"hljs haxe\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ObserverTest</span> </span>&#123;\n\n\t<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> void main(<span class=\"hljs-keyword\">String</span>[] args) &#123;\n\t\tUserObserver mike=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">UserObserver</span>(<span class=\"hljs-string\">&quot;Mike&quot;</span>);\n\t\tUserObserver lucy=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">UserObserver</span>(<span class=\"hljs-string\">&quot;Lucy&quot;</span>);\n\t\tUserObserver kate=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">UserObserver</span>(<span class=\"hljs-string\">&quot;Kate&quot;</span>);\n\t\tTencentNewsObservable observerable=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">TencentNewsObservable</span>();\n\t\t\n\t\tobserverable.subscribe(mike);\n\t\tobserverable.subscribe(lucy);\n\t\tobserverable.subscribe(kate);\n\t\tobserverable.sendNews(<span class=\"hljs-string\">&quot;this is an ad&quot;</span>);\n\t&#125;\n&#125;</code></pre>\n<p>运行结果：</p>\n<blockquote>\n<p>Mike收到一条消息：this is an advertisement<br>Lucy收到一条消息：this is an advertisement<br>Kate收到一条消息：this is an advertisement</p>\n</blockquote>\n<p>此时Mike收到推送打开后一看，竟然是一条广告，愤怒之下取消了订阅！</p>\n<pre><code class=\"hljs abnf\">System.out.println(<span class=\"hljs-string\">&quot;Mike unsubscribe news&quot;</span>)<span class=\"hljs-comment\">;</span>\nobserverable.unsubscribe(mike)<span class=\"hljs-comment\">;</span>\nobserverable.sendNews(<span class=\"hljs-string\">&quot;this is a news&quot;</span>)<span class=\"hljs-comment\">;</span></code></pre>\n<p>运行结果：</p>\n<blockquote>\n<p>Mike收到一条消息：this is an advertisement<br>Lucy收到一条消息：this is an advertisement<br>Kate收到一条消息：this is an advertisement<br>Mike unsubscribe news<br>Lucy收到一条消息：this is a news<br>Kate收到一条消息：this is a news</p>\n</blockquote>\n<p>取消订阅后Mike再也没有收到新闻推送。</p>\n<p>二、策略模式<br>策略模式定义了一系列的算法，并将每一个算法封装起来，而且使他们可以相互替换，让算法独立于使用它的客户而独立变化。策略模式设计三个角色，环境(Context)角色、抽象策略(Strategy)角色以及具体策略(ConcreteStrategy)角色。<br>来看一个现实生活的例子，假设一个商场有三种会员（Strategy），分别为普通会员（StandardMemberStraegy）、白银会员（SilverMemberStrategy）以及黄金会员（GoldenMemberStrategy）。针对三种会员分别制定了不同的优方案。普通会员打九折、白银会员打八折、黄金会员打七折。来看如何用策略模式实现上述场景。<br>1.创建抽象策略类</p>\n<pre><code class=\"hljs arduino\"><span class=\"hljs-keyword\">public</span> abstract <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Strategy</span> &#123;</span>\n\t\n\t<span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">String</span> strategy;\n\t\n\t\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">String</span> <span class=\"hljs-title\">getStrategy</span><span class=\"hljs-params\">()</span> </span>&#123;\n\t\t<span class=\"hljs-keyword\">return</span> strategy;\n\t&#125;\n\n\n\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">Strategy</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">String</span> strategy)</span> </span>&#123;\n\t\tsuper();\n\t\t<span class=\"hljs-keyword\">this</span>.strategy = strategy;\n\t&#125;\n\t\n\t<span class=\"hljs-function\">abstract <span class=\"hljs-keyword\">double</span> <span class=\"hljs-title\">getPrice</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">double</span> normalPrice)</span></span>;\n&#125;</code></pre>\n<p>2.创建环境类（Context）并持有抽象策略类</p>\n<pre><code class=\"hljs reasonml\">public <span class=\"hljs-keyword\">class</span> Context &#123;\n\t<span class=\"hljs-keyword\">private</span> Strategy mStrategy;\n\t\n\tpublic void set<span class=\"hljs-constructor\">Strategy(Strategy <span class=\"hljs-params\">strategy</span>)</span> &#123;\n\t\tmStrategy=strategy;\n\t&#125;\n\t\n\tpublic double execute<span class=\"hljs-constructor\">Price(<span class=\"hljs-params\">double</span> <span class=\"hljs-params\">normalPrice</span>)</span> &#123;\n\t\t<span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">System</span>.</span></span>out.println(mStrategy.get<span class=\"hljs-constructor\">Strategy()</span>+<span class=\"hljs-string\">&quot;Member，折后价：&quot;</span>+mStrategy.get<span class=\"hljs-constructor\">Price(<span class=\"hljs-params\">normalPrice</span>)</span>);\n\t\treturn mStrategy.get<span class=\"hljs-constructor\">Price(<span class=\"hljs-params\">normalPrice</span>)</span>;\n\t&#125;\n&#125;</code></pre>\n<p>3.创建三种会员策略类</p>\n<pre><code class=\"hljs scala\">public <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">StandardMemberStraegy</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Strategy</span> </span>&#123;\n\t\n\tpublic <span class=\"hljs-type\">StandardMemberStraegy</span>(<span class=\"hljs-type\">String</span> strategy) &#123;\n\t\t<span class=\"hljs-keyword\">super</span>(strategy);\n\t&#125;\n\n\t<span class=\"hljs-meta\">@Override</span>\n\tpublic double getPrice(double normalPrice) &#123;\n\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0.9</span>*normalPrice;\n\t&#125;\n&#125;\n\npublic <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">SilverMemberStrategy</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Strategy</span></span>&#123;\n\n\tpublic <span class=\"hljs-type\">SilverMemberStrategy</span>(<span class=\"hljs-type\">String</span> strategy) &#123;\n\t\t<span class=\"hljs-keyword\">super</span>(strategy);\n\t&#125;\n\n\t<span class=\"hljs-meta\">@Override</span>\n\tpublic double getPrice(double normalPrice) &#123;\n\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0.8</span>*normalPrice;\n\t&#125;\n\n&#125;\n\npublic <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">GoldenMemberStrategy</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Strategy</span> </span>&#123;\n\n\n\tpublic <span class=\"hljs-type\">GoldenMemberStrategy</span>(<span class=\"hljs-type\">String</span> strategy) &#123;\n\t\t<span class=\"hljs-keyword\">super</span>(strategy);\n\t&#125;\n\n\t<span class=\"hljs-meta\">@Override</span>\n\tpublic double getPrice(double normalPrice) &#123;\n\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0.7</span>*normalPrice;\n\t&#125;\n\t\n&#125;</code></pre>\n<p>4.创建策略模式测试类</p>\n<pre><code class=\"hljs reasonml\">public <span class=\"hljs-keyword\">class</span> StrategyTest &#123;\n\n\tpublic static void main(String<span class=\"hljs-literal\">[]</span> args) &#123;\n\t\tStandardMemberStraegy standar=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-constructor\">StandardMemberStraegy(<span class=\"hljs-string\">&quot;Standar&quot;</span>)</span>;\n\t\tSilverMemberStrategy silver=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-constructor\">SilverMemberStrategy(<span class=\"hljs-string\">&quot;Silver&quot;</span>)</span>;\n\t\tGoldenMemberStrategy golden=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-constructor\">GoldenMemberStrategy(<span class=\"hljs-string\">&quot;Golden&quot;</span>)</span>;\n\t\tContext context=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-constructor\">Context()</span>;\n\t\t\n\t\tcontext.set<span class=\"hljs-constructor\">Strategy(<span class=\"hljs-params\">standar</span>)</span>;\n\t\tcontext.execute<span class=\"hljs-constructor\">Price(100)</span>;\n\t\t\n\t\tcontext.set<span class=\"hljs-constructor\">Strategy(<span class=\"hljs-params\">silver</span>)</span>;\n\t\tcontext.execute<span class=\"hljs-constructor\">Price(100)</span>;\n\t\t\n\t\tcontext.set<span class=\"hljs-constructor\">Strategy(<span class=\"hljs-params\">golden</span>)</span>;\n\t\tcontext.execute<span class=\"hljs-constructor\">Price(100)</span>;\n\t&#125;\n\n&#125;</code></pre>\n<p>运行结果：</p>\n<blockquote>\n<p>StandarMember，折后价：90.0<br>SilverMember，折后价：80.0<br>GoldenMember，折后价：70.0</p>\n</blockquote>\n"},{"title":"RecyclerView/ListView嵌套CheckBox选中状态错乱解决方案","date":"2016-09-25T14:58:04.000Z","_content":"\n在讨论这个问题之前应该先了解ListView的复用机制\nListView复用的原理：ListView中的每一个Item显示都需要Adapter调用一次getView的方法，这个方法会传入一个convertView的参数，返回的View就是这个Item显示的View。如果当Item的数量足够大，再为每一个Item都创建一个View对象，必将占用很多内存，创建View对象（mInflater.inflate(R.layout.lv_item, null);从xml中生成View，这是属于IO操作）也是耗时操作，所以必将影响性能。\nAndroid提供了一个叫做Recycler(反复循环器)的构件，就是当ListView的Item从上方滚出屏幕视角之外，对应Item的View会被缓存到Recycler中，相应的会从下方生成一个Item，而此时调用的getView中的convertView参数就是滚出屏幕的Item的View，所以说如果能重用这个convertView，就会大大改善性能。\n如果一个屏幕最多显示7个Item，当Item1滑出屏幕，此时Item1 的View被添加进Recycler中，相应的在下部要产生一个Item8，这时调用getView方法，convertView参数就是Item1 的View。 其原理图如下：\n![](https://raw.githubusercontent.com/zhpanvip/Resource/master/image/0401.jfif)\n\nListView的复用虽然大大提升了性能，但是却也带来很多问题。比如在加载图片时，由于下边的item复用了上边的item，造成下边item刚加载出来时显示的还是上边被复用的item的图片，等到这个新的item加载图片完毕时才会正常显示，这就是convert view复用造成listview图片加载错乱的问题。\n与上边问题相似，在listview的item中存在CheckBox时也会由于复用convert view导致CheckBox的选中状态错乱，本片内容将解决由于复用导致CheckBox选中状态错乱的问题。\n先看下存在问题的效果图\n![](https://raw.githubusercontent.com/zhpanvip/Resource/master/image/0402.jfif)\n\n\n上图中只选中了北京市和天津市，当下滑ListView时发现下边的河南省和山东省也被选中了，再往下滑四川省和台湾省也被选中。其实可以发现一个规律，每一屏都会有两个条目被选中，其实这两个被选中的条目就是因为复用了第一屏的两个被选中的条目所导致的。\n先看下ListView没有优化前的代码：\n\n```\npublic class MainActivity extends AppCompatActivity {\n    private ListView mListView;\n    private List<String> mStringList;\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        mStringList=new ArrayList<>();\n        mStringList.add(\"北京市\");mStringList.add(\"天津市\");mStringList.add(\"上海市\");mStringList.add(\"重庆市\");\n        mStringList.add(\"河北省\");mStringList.add(\"山西省\");mStringList.add(\"辽宁省\");mStringList.add(\"河南省\");\n        mStringList.add(\"山东省\");mStringList.add(\"湖北省\");mStringList.add(\"湖南省\");mStringList.add(\"江西省\");\n        mStringList.add(\"福建省\");mStringList.add(\"陕西省\");mStringList.add(\"四川省\");mStringList.add(\"台湾省\");\n        mListView= (ListView) findViewById(R.id.lv_main);\n        MyAdapter adapter=new MyAdapter(this,mStringList);\n        mListView.setAdapter(adapter);\n\n    }\n}\n```\nMainActivity中的代码为ListView适配数据和适配Adapter，不作过多解释。\n\n```\n/**\n * Created by zhpan on 2016/9/24.\n */\n\npublic class MyAdapter extends BaseAdapter {\n\n    List<String> mStringList;\n    Context mContext;\n\n    public MyAdapter(Context context, List<String> stringList) {\n        mStringList = stringList;\n        mContext=context;\n    }\n\n    @Override\n    public long getItemId(int position) {\n        return 0;\n    }\n\n    @Override\n    public View getView(final int position, View convertView, ViewGroup parent) {\n        MyViewHolder holder;\n        if(convertView==null){\n            convertView=View.inflate(mContext,R.layout.item,null);\n            holder=new MyViewHolder();\n            holder.mTextView= (TextView) convertView.findViewById(R.id.tv_item);\n            holder.mCheckBox= (CheckBox) convertView.findViewById(R.id.cb_item);\n            convertView.setTag(holder);\n        }else {\n            holder= (MyViewHolder) convertView.getTag();\n        }\n\n        holder.mTextView.setText(mStringList.get(position));\n\n        return convertView;\n    }\n\n    @Override\n    public int getCount() {\n        return mStringList.size();\n    }\n\n    @Override\n    public Object getItem(int position) {\n        return null;\n    }\n\n    public static class  MyViewHolder {\n        TextView mTextView;\n        CheckBox mCheckBox;\n    }\n}\n\n```\n\n在Adapter中只是复用了convertView,没有对CheckBox做任何处理，那么这样写的代码是存在上图中的CheckBox选中状态错乱问题的。为了解决这个问题我们需要对CheckBox的选中状态做下保存，可以在Adapter中声明一个Map集合用来保存被选中的CheckBox。修改后代码如下：\n\n```\n/**\n * Created by zhpan on 2016/9/24.\n */\n\npublic class MyAdapter extends BaseAdapter {\n\n    List<String> mStringList;\n    Context mContext;\n    private Map<Integer,Boolean> map=new HashMap<>();// 存放已被选中的CheckBox\n\n    public MyAdapter(Context context, List<String> stringList) {\n        mStringList = stringList;\n        mContext=context;\n    }\n\n    @Override\n    public long getItemId(int position) {\n        return 0;\n    }\n\n    @Override\n    public View getView(final int position, View convertView, ViewGroup parent) {\n        MyViewHolder holder;\n        if(convertView==null){\n            convertView=View.inflate(mContext,R.layout.item,null);\n            holder=new MyViewHolder();\n            holder.mTextView= (TextView) convertView.findViewById(R.id.tv_item);\n            holder.mCheckBox= (CheckBox) convertView.findViewById(R.id.cb_item);\n            convertView.setTag(holder);\n        }else {\n            holder= (MyViewHolder) convertView.getTag();\n        }\n\n        holder.mTextView.setText(mStringList.get(position));\n        holder.mCheckBox.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() {\n            @Override\n            public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {\n                if(isChecked==true){\n                    map.put(position,true);\n                }else {\n                    map.remove(position);\n                }\n            }\n        });\n\n        if(map!=null&&map.containsKey(position)){\n            holder.mCheckBox.setChecked(true);\n        }else {\n            holder.mCheckBox.setChecked(false);\n        }\n\n        return convertView;\n    }\n\n    @Override\n    public int getCount() {\n        return mStringList.size();\n    }\n\n    @Override\n    public Object getItem(int position) {\n        return null;\n    }\n\n    public static class  MyViewHolder {\n        TextView mTextView;\n        CheckBox mCheckBox;\n    }\n}\n\n```\n\n针对这个问题我们子Adapter中加入了一个Map集合，其中Map的key用来存储条被选中的checkbox的position，value用来存储checkbox被选中。代码中还添加了checkbox的监听事件，在监听事件中判断点击的checkbox是否被选中，如果被选中了则将position添加到集合，并设置状态未true，否则就将该checkbox从集合中移除。然后通过if语句判断集合中是否存在该checkbox，如果存在则证明是被选中的,遂将该checkbox设置为选中状态setChecked(true)，否则证明checkbox没有选中则设置setChecked(false)。这样就解决了checkbox选中状态错乱的问题。\n看下优化后的效果图\n![](https://raw.githubusercontent.com/zhpanvip/Resource/master/image/0403.jfif)\n\n\n可以看到优化后CheckBox的选中状态不会再出现错乱问题了。\n\n[源码下载](http://download.csdn.net/detail/qq_20521573/9639225)\n\n","source":"_posts/4.RecyclerView-ListView嵌套CheckBox选中状态错乱解决方案.md","raw":"---\ntitle: RecyclerView/ListView嵌套CheckBox选中状态错乱解决方案\ndate: 2016-09-25 22:58:04\ntags:\n---\n\n在讨论这个问题之前应该先了解ListView的复用机制\nListView复用的原理：ListView中的每一个Item显示都需要Adapter调用一次getView的方法，这个方法会传入一个convertView的参数，返回的View就是这个Item显示的View。如果当Item的数量足够大，再为每一个Item都创建一个View对象，必将占用很多内存，创建View对象（mInflater.inflate(R.layout.lv_item, null);从xml中生成View，这是属于IO操作）也是耗时操作，所以必将影响性能。\nAndroid提供了一个叫做Recycler(反复循环器)的构件，就是当ListView的Item从上方滚出屏幕视角之外，对应Item的View会被缓存到Recycler中，相应的会从下方生成一个Item，而此时调用的getView中的convertView参数就是滚出屏幕的Item的View，所以说如果能重用这个convertView，就会大大改善性能。\n如果一个屏幕最多显示7个Item，当Item1滑出屏幕，此时Item1 的View被添加进Recycler中，相应的在下部要产生一个Item8，这时调用getView方法，convertView参数就是Item1 的View。 其原理图如下：\n![](https://raw.githubusercontent.com/zhpanvip/Resource/master/image/0401.jfif)\n\nListView的复用虽然大大提升了性能，但是却也带来很多问题。比如在加载图片时，由于下边的item复用了上边的item，造成下边item刚加载出来时显示的还是上边被复用的item的图片，等到这个新的item加载图片完毕时才会正常显示，这就是convert view复用造成listview图片加载错乱的问题。\n与上边问题相似，在listview的item中存在CheckBox时也会由于复用convert view导致CheckBox的选中状态错乱，本片内容将解决由于复用导致CheckBox选中状态错乱的问题。\n先看下存在问题的效果图\n![](https://raw.githubusercontent.com/zhpanvip/Resource/master/image/0402.jfif)\n\n\n上图中只选中了北京市和天津市，当下滑ListView时发现下边的河南省和山东省也被选中了，再往下滑四川省和台湾省也被选中。其实可以发现一个规律，每一屏都会有两个条目被选中，其实这两个被选中的条目就是因为复用了第一屏的两个被选中的条目所导致的。\n先看下ListView没有优化前的代码：\n\n```\npublic class MainActivity extends AppCompatActivity {\n    private ListView mListView;\n    private List<String> mStringList;\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        mStringList=new ArrayList<>();\n        mStringList.add(\"北京市\");mStringList.add(\"天津市\");mStringList.add(\"上海市\");mStringList.add(\"重庆市\");\n        mStringList.add(\"河北省\");mStringList.add(\"山西省\");mStringList.add(\"辽宁省\");mStringList.add(\"河南省\");\n        mStringList.add(\"山东省\");mStringList.add(\"湖北省\");mStringList.add(\"湖南省\");mStringList.add(\"江西省\");\n        mStringList.add(\"福建省\");mStringList.add(\"陕西省\");mStringList.add(\"四川省\");mStringList.add(\"台湾省\");\n        mListView= (ListView) findViewById(R.id.lv_main);\n        MyAdapter adapter=new MyAdapter(this,mStringList);\n        mListView.setAdapter(adapter);\n\n    }\n}\n```\nMainActivity中的代码为ListView适配数据和适配Adapter，不作过多解释。\n\n```\n/**\n * Created by zhpan on 2016/9/24.\n */\n\npublic class MyAdapter extends BaseAdapter {\n\n    List<String> mStringList;\n    Context mContext;\n\n    public MyAdapter(Context context, List<String> stringList) {\n        mStringList = stringList;\n        mContext=context;\n    }\n\n    @Override\n    public long getItemId(int position) {\n        return 0;\n    }\n\n    @Override\n    public View getView(final int position, View convertView, ViewGroup parent) {\n        MyViewHolder holder;\n        if(convertView==null){\n            convertView=View.inflate(mContext,R.layout.item,null);\n            holder=new MyViewHolder();\n            holder.mTextView= (TextView) convertView.findViewById(R.id.tv_item);\n            holder.mCheckBox= (CheckBox) convertView.findViewById(R.id.cb_item);\n            convertView.setTag(holder);\n        }else {\n            holder= (MyViewHolder) convertView.getTag();\n        }\n\n        holder.mTextView.setText(mStringList.get(position));\n\n        return convertView;\n    }\n\n    @Override\n    public int getCount() {\n        return mStringList.size();\n    }\n\n    @Override\n    public Object getItem(int position) {\n        return null;\n    }\n\n    public static class  MyViewHolder {\n        TextView mTextView;\n        CheckBox mCheckBox;\n    }\n}\n\n```\n\n在Adapter中只是复用了convertView,没有对CheckBox做任何处理，那么这样写的代码是存在上图中的CheckBox选中状态错乱问题的。为了解决这个问题我们需要对CheckBox的选中状态做下保存，可以在Adapter中声明一个Map集合用来保存被选中的CheckBox。修改后代码如下：\n\n```\n/**\n * Created by zhpan on 2016/9/24.\n */\n\npublic class MyAdapter extends BaseAdapter {\n\n    List<String> mStringList;\n    Context mContext;\n    private Map<Integer,Boolean> map=new HashMap<>();// 存放已被选中的CheckBox\n\n    public MyAdapter(Context context, List<String> stringList) {\n        mStringList = stringList;\n        mContext=context;\n    }\n\n    @Override\n    public long getItemId(int position) {\n        return 0;\n    }\n\n    @Override\n    public View getView(final int position, View convertView, ViewGroup parent) {\n        MyViewHolder holder;\n        if(convertView==null){\n            convertView=View.inflate(mContext,R.layout.item,null);\n            holder=new MyViewHolder();\n            holder.mTextView= (TextView) convertView.findViewById(R.id.tv_item);\n            holder.mCheckBox= (CheckBox) convertView.findViewById(R.id.cb_item);\n            convertView.setTag(holder);\n        }else {\n            holder= (MyViewHolder) convertView.getTag();\n        }\n\n        holder.mTextView.setText(mStringList.get(position));\n        holder.mCheckBox.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() {\n            @Override\n            public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {\n                if(isChecked==true){\n                    map.put(position,true);\n                }else {\n                    map.remove(position);\n                }\n            }\n        });\n\n        if(map!=null&&map.containsKey(position)){\n            holder.mCheckBox.setChecked(true);\n        }else {\n            holder.mCheckBox.setChecked(false);\n        }\n\n        return convertView;\n    }\n\n    @Override\n    public int getCount() {\n        return mStringList.size();\n    }\n\n    @Override\n    public Object getItem(int position) {\n        return null;\n    }\n\n    public static class  MyViewHolder {\n        TextView mTextView;\n        CheckBox mCheckBox;\n    }\n}\n\n```\n\n针对这个问题我们子Adapter中加入了一个Map集合，其中Map的key用来存储条被选中的checkbox的position，value用来存储checkbox被选中。代码中还添加了checkbox的监听事件，在监听事件中判断点击的checkbox是否被选中，如果被选中了则将position添加到集合，并设置状态未true，否则就将该checkbox从集合中移除。然后通过if语句判断集合中是否存在该checkbox，如果存在则证明是被选中的,遂将该checkbox设置为选中状态setChecked(true)，否则证明checkbox没有选中则设置setChecked(false)。这样就解决了checkbox选中状态错乱的问题。\n看下优化后的效果图\n![](https://raw.githubusercontent.com/zhpanvip/Resource/master/image/0403.jfif)\n\n\n可以看到优化后CheckBox的选中状态不会再出现错乱问题了。\n\n[源码下载](http://download.csdn.net/detail/qq_20521573/9639225)\n\n","slug":"4.RecyclerView-ListView嵌套CheckBox选中状态错乱解决方案","published":1,"updated":"2020-08-29T18:02:39.276Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckegm5nry000fdwozceg83btd","content":"<p>在讨论这个问题之前应该先了解ListView的复用机制<br>ListView复用的原理：ListView中的每一个Item显示都需要Adapter调用一次getView的方法，这个方法会传入一个convertView的参数，返回的View就是这个Item显示的View。如果当Item的数量足够大，再为每一个Item都创建一个View对象，必将占用很多内存，创建View对象（mInflater.inflate(R.layout.lv_item, null);从xml中生成View，这是属于IO操作）也是耗时操作，所以必将影响性能。<br>Android提供了一个叫做Recycler(反复循环器)的构件，就是当ListView的Item从上方滚出屏幕视角之外，对应Item的View会被缓存到Recycler中，相应的会从下方生成一个Item，而此时调用的getView中的convertView参数就是滚出屏幕的Item的View，所以说如果能重用这个convertView，就会大大改善性能。<br>如果一个屏幕最多显示7个Item，当Item1滑出屏幕，此时Item1 的View被添加进Recycler中，相应的在下部要产生一个Item8，这时调用getView方法，convertView参数就是Item1 的View。 其原理图如下：<br><img src=\"https://raw.githubusercontent.com/zhpanvip/Resource/master/image/0401.jfif\"></p>\n<p>ListView的复用虽然大大提升了性能，但是却也带来很多问题。比如在加载图片时，由于下边的item复用了上边的item，造成下边item刚加载出来时显示的还是上边被复用的item的图片，等到这个新的item加载图片完毕时才会正常显示，这就是convert view复用造成listview图片加载错乱的问题。<br>与上边问题相似，在listview的item中存在CheckBox时也会由于复用convert view导致CheckBox的选中状态错乱，本片内容将解决由于复用导致CheckBox选中状态错乱的问题。<br>先看下存在问题的效果图<br><img src=\"https://raw.githubusercontent.com/zhpanvip/Resource/master/image/0402.jfif\"></p>\n<p>上图中只选中了北京市和天津市，当下滑ListView时发现下边的河南省和山东省也被选中了，再往下滑四川省和台湾省也被选中。其实可以发现一个规律，每一屏都会有两个条目被选中，其实这两个被选中的条目就是因为复用了第一屏的两个被选中的条目所导致的。<br>先看下ListView没有优化前的代码：</p>\n<pre><code class=\"hljs routeros\">public class MainActivity extends AppCompatActivity &#123;\n    private ListView mListView;\n    private List&lt;String&gt; mStringList;\n    @Override\n    protected void onCreate(Bundle savedInstanceState) &#123;\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        <span class=\"hljs-attribute\">mStringList</span>=new ArrayList&lt;&gt;();\n        mStringList.<span class=\"hljs-builtin-name\">add</span>(<span class=\"hljs-string\">&quot;北京市&quot;</span>);mStringList.<span class=\"hljs-builtin-name\">add</span>(<span class=\"hljs-string\">&quot;天津市&quot;</span>);mStringList.<span class=\"hljs-builtin-name\">add</span>(<span class=\"hljs-string\">&quot;上海市&quot;</span>);mStringList.<span class=\"hljs-builtin-name\">add</span>(<span class=\"hljs-string\">&quot;重庆市&quot;</span>);\n        mStringList.<span class=\"hljs-builtin-name\">add</span>(<span class=\"hljs-string\">&quot;河北省&quot;</span>);mStringList.<span class=\"hljs-builtin-name\">add</span>(<span class=\"hljs-string\">&quot;山西省&quot;</span>);mStringList.<span class=\"hljs-builtin-name\">add</span>(<span class=\"hljs-string\">&quot;辽宁省&quot;</span>);mStringList.<span class=\"hljs-builtin-name\">add</span>(<span class=\"hljs-string\">&quot;河南省&quot;</span>);\n        mStringList.<span class=\"hljs-builtin-name\">add</span>(<span class=\"hljs-string\">&quot;山东省&quot;</span>);mStringList.<span class=\"hljs-builtin-name\">add</span>(<span class=\"hljs-string\">&quot;湖北省&quot;</span>);mStringList.<span class=\"hljs-builtin-name\">add</span>(<span class=\"hljs-string\">&quot;湖南省&quot;</span>);mStringList.<span class=\"hljs-builtin-name\">add</span>(<span class=\"hljs-string\">&quot;江西省&quot;</span>);\n        mStringList.<span class=\"hljs-builtin-name\">add</span>(<span class=\"hljs-string\">&quot;福建省&quot;</span>);mStringList.<span class=\"hljs-builtin-name\">add</span>(<span class=\"hljs-string\">&quot;陕西省&quot;</span>);mStringList.<span class=\"hljs-builtin-name\">add</span>(<span class=\"hljs-string\">&quot;四川省&quot;</span>);mStringList.<span class=\"hljs-builtin-name\">add</span>(<span class=\"hljs-string\">&quot;台湾省&quot;</span>);\n        mListView= (ListView) findViewById(R.id.lv_main);\n        MyAdapter <span class=\"hljs-attribute\">adapter</span>=new MyAdapter(this,mStringList);\n        mListView.setAdapter(adapter);\n\n    &#125;\n&#125;</code></pre>\n<p>MainActivity中的代码为ListView适配数据和适配Adapter，不作过多解释。</p>\n<pre><code class=\"hljs reasonml\"><span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\"> * Created by zhpan on 2016/9/24.</span>\n<span class=\"hljs-comment\"> */</span>\n\npublic <span class=\"hljs-keyword\">class</span> MyAdapter extends BaseAdapter &#123;\n\n    List&lt;String&gt; mStringList;\n    Context mContext;\n\n    public <span class=\"hljs-constructor\">MyAdapter(Context <span class=\"hljs-params\">context</span>, List&lt;String&gt; <span class=\"hljs-params\">stringList</span>)</span> &#123;\n        mStringList = stringList;\n        mContext=context;\n    &#125;\n\n    @Override\n    public long get<span class=\"hljs-constructor\">ItemId(<span class=\"hljs-params\">int</span> <span class=\"hljs-params\">position</span>)</span> &#123;\n        return <span class=\"hljs-number\">0</span>;\n    &#125;\n\n    @Override\n    public View get<span class=\"hljs-constructor\">View(<span class=\"hljs-params\">final</span> <span class=\"hljs-params\">int</span> <span class=\"hljs-params\">position</span>, View <span class=\"hljs-params\">convertView</span>, ViewGroup <span class=\"hljs-params\">parent</span>)</span> &#123;\n        MyViewHolder holder;\n        <span class=\"hljs-keyword\">if</span>(convertView==null)&#123;\n            convertView=<span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">View</span>.</span></span>inflate(mContext,<span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">R</span>.</span></span>layout.item,null);\n            holder=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-constructor\">MyViewHolder()</span>;\n            holder.mTextView= (TextView) convertView.find<span class=\"hljs-constructor\">ViewById(R.<span class=\"hljs-params\">id</span>.<span class=\"hljs-params\">tv_item</span>)</span>;\n            holder.mCheckBox= (CheckBox) convertView.find<span class=\"hljs-constructor\">ViewById(R.<span class=\"hljs-params\">id</span>.<span class=\"hljs-params\">cb_item</span>)</span>;\n            convertView.set<span class=\"hljs-constructor\">Tag(<span class=\"hljs-params\">holder</span>)</span>;\n        &#125;<span class=\"hljs-keyword\">else</span> &#123;\n            holder= (MyViewHolder) convertView.get<span class=\"hljs-constructor\">Tag()</span>;\n        &#125;\n\n        holder.mTextView.set<span class=\"hljs-constructor\">Text(<span class=\"hljs-params\">mStringList</span>.<span class=\"hljs-params\">get</span>(<span class=\"hljs-params\">position</span>)</span>);\n\n        return convertView;\n    &#125;\n\n    @Override\n    public <span class=\"hljs-built_in\">int</span> get<span class=\"hljs-constructor\">Count()</span> &#123;\n        return mStringList.size<span class=\"hljs-literal\">()</span>;\n    &#125;\n\n    @Override\n    public Object get<span class=\"hljs-constructor\">Item(<span class=\"hljs-params\">int</span> <span class=\"hljs-params\">position</span>)</span> &#123;\n        return null;\n    &#125;\n\n    public static <span class=\"hljs-keyword\">class</span>  MyViewHolder &#123;\n        TextView mTextView;\n        CheckBox mCheckBox;\n    &#125;\n&#125;\n</code></pre>\n\n<p>在Adapter中只是复用了convertView,没有对CheckBox做任何处理，那么这样写的代码是存在上图中的CheckBox选中状态错乱问题的。为了解决这个问题我们需要对CheckBox的选中状态做下保存，可以在Adapter中声明一个Map集合用来保存被选中的CheckBox。修改后代码如下：</p>\n<pre><code class=\"hljs arduino\"><span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\"> * Created by zhpan on 2016/9/24.</span>\n<span class=\"hljs-comment\"> */</span>\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MyAdapter</span> <span class=\"hljs-title\">extends</span> <span class=\"hljs-title\">BaseAdapter</span> &#123;</span>\n\n    List&lt;<span class=\"hljs-keyword\">String</span>&gt; mStringList;\n    Context mContext;\n    <span class=\"hljs-keyword\">private</span> Map&lt;Integer,Boolean&gt; <span class=\"hljs-built_in\">map</span>=<span class=\"hljs-keyword\">new</span> HashMap&lt;&gt;();<span class=\"hljs-comment\">// 存放已被选中的CheckBox</span>\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">MyAdapter</span><span class=\"hljs-params\">(Context context, List&lt;<span class=\"hljs-keyword\">String</span>&gt; stringList)</span> </span>&#123;\n        mStringList = stringList;\n        mContext=context;\n    &#125;\n\n    @Override\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">long</span> <span class=\"hljs-title\">getItemId</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> <span class=\"hljs-built_in\">position</span>)</span> </span>&#123;\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n    &#125;\n\n    @Override\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> View <span class=\"hljs-title\">getView</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-built_in\">position</span>, View convertView, ViewGroup parent)</span> </span>&#123;\n        MyViewHolder holder;\n        <span class=\"hljs-keyword\">if</span>(convertView==null)&#123;\n            convertView=View.inflate(mContext,R.layout.item,null);\n            holder=<span class=\"hljs-keyword\">new</span> MyViewHolder();\n            holder.mTextView= (TextView) convertView.findViewById(R.id.tv_item);\n            holder.mCheckBox= (CheckBox) convertView.findViewById(R.id.cb_item);\n            convertView.setTag(holder);\n        &#125;<span class=\"hljs-keyword\">else</span> &#123;\n            holder= (MyViewHolder) convertView.getTag();\n        &#125;\n\n        holder.mTextView.setText(mStringList.<span class=\"hljs-built_in\">get</span>(<span class=\"hljs-built_in\">position</span>));\n        holder.mCheckBox.setOnCheckedChangeListener(<span class=\"hljs-keyword\">new</span> CompoundButton.OnCheckedChangeListener() &#123;\n            @Override\n            <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> onCheckedChanged(CompoundButton buttonView, <span class=\"hljs-keyword\">boolean</span> isChecked) &#123;\n                <span class=\"hljs-keyword\">if</span>(isChecked==<span class=\"hljs-literal\">true</span>)&#123;\n                    <span class=\"hljs-built_in\">map</span>.<span class=\"hljs-built_in\">put</span>(<span class=\"hljs-built_in\">position</span>,<span class=\"hljs-literal\">true</span>);\n                &#125;<span class=\"hljs-keyword\">else</span> &#123;\n                    <span class=\"hljs-built_in\">map</span>.<span class=\"hljs-built_in\">remove</span>(<span class=\"hljs-built_in\">position</span>);\n                &#125;\n            &#125;\n        &#125;);\n\n        <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-built_in\">map</span>!=null&amp;&amp;<span class=\"hljs-built_in\">map</span>.containsKey(<span class=\"hljs-built_in\">position</span>))&#123;\n            holder.mCheckBox.setChecked(<span class=\"hljs-literal\">true</span>);\n        &#125;<span class=\"hljs-keyword\">else</span> &#123;\n            holder.mCheckBox.setChecked(<span class=\"hljs-literal\">false</span>);\n        &#125;\n\n        <span class=\"hljs-keyword\">return</span> convertView;\n    &#125;\n\n    @Override\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">getCount</span><span class=\"hljs-params\">()</span> </span>&#123;\n        <span class=\"hljs-keyword\">return</span> mStringList.<span class=\"hljs-built_in\">size</span>();\n    &#125;\n\n    @Override\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> Object <span class=\"hljs-title\">getItem</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> <span class=\"hljs-built_in\">position</span>)</span> </span>&#123;\n        <span class=\"hljs-keyword\">return</span> null;\n    &#125;\n\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span>  <span class=\"hljs-title\">MyViewHolder</span> &#123;</span>\n        TextView mTextView;\n        CheckBox mCheckBox;\n    &#125;\n&#125;\n</code></pre>\n\n<p>针对这个问题我们子Adapter中加入了一个Map集合，其中Map的key用来存储条被选中的checkbox的position，value用来存储checkbox被选中。代码中还添加了checkbox的监听事件，在监听事件中判断点击的checkbox是否被选中，如果被选中了则将position添加到集合，并设置状态未true，否则就将该checkbox从集合中移除。然后通过if语句判断集合中是否存在该checkbox，如果存在则证明是被选中的,遂将该checkbox设置为选中状态setChecked(true)，否则证明checkbox没有选中则设置setChecked(false)。这样就解决了checkbox选中状态错乱的问题。<br>看下优化后的效果图<br><img src=\"https://raw.githubusercontent.com/zhpanvip/Resource/master/image/0403.jfif\"></p>\n<p>可以看到优化后CheckBox的选中状态不会再出现错乱问题了。</p>\n<p><a href=\"http://download.csdn.net/detail/qq_20521573/9639225\">源码下载</a></p>\n","site":{"data":{"fluid_config":{"favicon":"/img/favicon.png","apple_touch_icon":"/img/favicon.png","title_join_string":" - ","force_https":false,"highlight":{"enable":true,"style":"Github Gist","bg_color":false,"copy_btn":true},"fun_features":{"typing":{"enable":true,"typeSpeed":70,"cursorChar":"|","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"mouse_click":{"enable":false,"style":"values"}},"dark_mode":{"enable":true,"default":"auto"},"color":{"body_bg_color":"#eee","body_bg_color_dark":"#181c27","navbar_bg_color":"#2f4154","navbar_bg_color_dark":"#1f3144","navbar_text_color":"#fff","navbar_text_color_dark":"#d0d0d0","text_color":"#3c4858","text_color_dark":"#c4c6c9","sec_text_color":"#718096","sec_text_color_dark":"#a7a9ad","post_text_color":"#2c3e50","post_text_color_dark":"#c4c6c9","post_heading_color":"#1a202c","post_heading_color_dark":"#c4c6c9","post_link_color":"#0366d6","post_link_color_dark":"#1589e9","link_hover_color":"#30a9de","link_hover_color_dark":"#30a9de","link_hover_bg_color":"#f8f9fa","link_hover_bg_color_dark":"#364151","board_color":"#fff","board_color_dark":"#252d38"},"font":{"font_size":"16px","font_family":null,"code_font_size":"85%"},"custom_js":null,"custom_css":null,"custom_html":"","web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"tajs":null,"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}},"lazyload":{"enable":true,"onlypost":false},"daovoice":{"enable":false,"appid":""},"aplayer":{"enable":false,"autoplay":false,"loop":"all","order":"random","theme":"#b7daff","songs":[{"name":"name","artist":"artist","url":"/songs/test.mp3","cover":"/img/cover.jpg"},{"name":"name","artist":"artist","url":"https://...url.mp3","cover":"https://...cover.jpg"}]},"version":{"check":false},"navbar":{"blog_title":"zhangpan","ground_glass":{"enable":false,"px":3,"alpha":0.7},"menu":[{"key":"home","link":"/","icon":"iconfont icon-home-fill"},{"key":"archive","link":"/archives/","icon":"iconfont icon-archive-fill"},{"key":"category","link":"/categories/","icon":"iconfont icon-category-fill"},{"key":"tag","link":"/tags/","icon":"iconfont icon-tags-fill"},{"key":"about","link":"/about/","icon":"iconfont icon-user-fill"}]},"search":{"enable":true,"path":"/local-search.xml","generate_path":"/local-search.xml","field":"post","content":true},"scroll_down_arrow":{"enable":true,"banner_height_limit":90,"scroll_after_turning_page":true},"banner_parallax":true,"footer":{"statistics":{"enable":false,"source":"busuanzi","pv_format":"总访问量 {} 次","uv_format":"总访客数 {} 人"},"beian":{"enable":false,"icp_text":"京ICP证123456号","police_text":"京公网安备12345678号","police_code":12345678,"police_icon":"/img/police_beian.png"}},"scroll_top_arrow":{"enable":true},"index":{"banner_img":"/img/default.png","banner_img_height":100,"banner_mask_alpha":0.3,"post_default_img":"","slogan":{"enable":true,"text":"Talk is cheap, show me the code."},"auto_excerpt":{"enable":true},"post_url_target":"_self","post_meta":{"date":true,"category":true,"tag":true}},"page":{"banner_img":"/img/default.png","banner_img_height":60,"banner_mask_alpha":0.3},"post":{"banner_img":"/img/default.png","banner_img_height":70,"banner_mask_alpha":0.3,"meta":{"date":{"enable":true,"format":"LL a"},"wordcount":{"enable":true,"format":"{} 字"},"min2read":{"enable":true,"format":"{} 分钟","words":100},"views":{"enable":false,"source":"busuanzi","format":"{} 次"}},"updated":{"enable":false,"content":"本文最后更新于：","relative":false},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"copyright":{"enable":true,"content":"本博客所有文章除特别声明外，均采用 <a href=\"https://creativecommons.org/licenses/by-sa/4.0/deed.zh\" rel=\"nofollow noopener\">CC BY-SA 4.0 协议</a> ，转载请注明出处！ <h5>开源库推荐</h5> <a href=\"https://github.com/zhpanvip/BannerViewPager\">1.BannerViewPager</a> <p> 一个基于ViewPager2实现的具有强大功能的无限轮播库。支持多种页面切换效果和指示器样式。 </p>\n<a href=\"https://github.com/zhpanvip/viewpagerindicator\">2.ViewPagerIndicator</a> <p> 一个适用于ViewPager和ViewPager2的指示器，支持多种滑块样式及滑动模式 </p>"},"prev_next":{"enable":true},"custom":{"enable":false,"content":"<img src=\"https://octodex.github.com/images/jetpacktocat.png\" class=\"rounded mx-auto d-block mt-5\" style=\"width:150px; height:150px;\">"},"image_zoom":{"enable":true},"footnote":{"enable":true,"header":""},"math":{"enable":false,"specific":false,"engine":"mathjax"},"mermaid":{"enable":false,"specific":false,"options":{"theme":"default"}},"comments":{"enable":true,"type":"utterances"}},"utterances":{"repo":"zhpanvip/utterances-comment","issue_term":"pathname","label":"utterances","theme":"github-light","crossorigin":"anonymous"},"disqus":{"shortname":null,"disqusjs":false,"apikey":null},"gitalk":{"clientID":null,"clientSecret":null,"repo":null,"owner":null,"admin":["name"],"id":"location.pathname","language":"zh-CN","labels":["Gitalk"],"perPage":10,"pagerDirection":"last","distractionFreeMode":false,"createIssueManually":true},"valine":{"appid":"hXIROaIM5y9qnieojJRWP5hS","appkey":"y0f3w3aqd1MF7JL9ma4WECTy","placeholder":"说点什么","path":"window.location.pathname","avatar":"retro","meta":["nick","mail","link"],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"https://zhangpan.site"},"changyan":{"appid":"","appkey":""},"livere":{"uid":""},"archive":{"banner_img":"/img/bg_article.jpg","banner_img_height":60,"banner_mask_alpha":0.3,"subtitle":null},"category":{"banner_img":"/img/bg_default.png","banner_img_height":60,"banner_mask_alpha":0.3,"subtitle":null,"post_limit":10,"order_by":"-length"},"tag":{"banner_img":"/img/bg_label.jpg","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null,"tagcloud":{"min_font":15,"max_font":30,"unit":"px","start_color":"#BBBBEE","end_color":"#337ab7"}},"about":{"banner_img":"/img/bg_default.png","banner_img_height":60,"banner_mask_alpha":0.3,"subtitle":null,"avatar":"/img/avatar.png","name":"myname","introduce":"一句简短的介绍","icons":[{"class":"iconfont icon-github-fill","link":"https://github.com","tip":"GitHub"},{"class":"iconfont icon-douban-fill","link":"https://douban.com","tip":"豆瓣"},{"class":"iconfont icon-wechat-fill","qrcode":"/img/favicon.png"}]},"page404":{"banner_img":"/img/default.png","banner_img_height":85,"banner_mask_alpha":0.3,"subtitle":"Page not found"},"links":{"banner_img":"/img/default.png","banner_img_height":60,"banner_mask_alpha":0.3,"subtitle":null,"items":[{"title":"Fluid Docs","intro":"主题使用指南","link":"https://hexo.fluid-dev.com/docs/","image":"/img/favicon.png"},{"title":"Fluid Repo","intro":"主题 GitHub 仓库","link":"https://github.com/fluid-dev/hexo-theme-fluid","image":"/img/favicon.png"},{"title":"Fluid Example","intro":"主题操作示例","link":"https://hexo.fluid-dev.com/docs/example/","image":"/img/favicon.png"}]}}}},"excerpt":"","more":"<p>在讨论这个问题之前应该先了解ListView的复用机制<br>ListView复用的原理：ListView中的每一个Item显示都需要Adapter调用一次getView的方法，这个方法会传入一个convertView的参数，返回的View就是这个Item显示的View。如果当Item的数量足够大，再为每一个Item都创建一个View对象，必将占用很多内存，创建View对象（mInflater.inflate(R.layout.lv_item, null);从xml中生成View，这是属于IO操作）也是耗时操作，所以必将影响性能。<br>Android提供了一个叫做Recycler(反复循环器)的构件，就是当ListView的Item从上方滚出屏幕视角之外，对应Item的View会被缓存到Recycler中，相应的会从下方生成一个Item，而此时调用的getView中的convertView参数就是滚出屏幕的Item的View，所以说如果能重用这个convertView，就会大大改善性能。<br>如果一个屏幕最多显示7个Item，当Item1滑出屏幕，此时Item1 的View被添加进Recycler中，相应的在下部要产生一个Item8，这时调用getView方法，convertView参数就是Item1 的View。 其原理图如下：<br><img src=\"https://raw.githubusercontent.com/zhpanvip/Resource/master/image/0401.jfif\"></p>\n<p>ListView的复用虽然大大提升了性能，但是却也带来很多问题。比如在加载图片时，由于下边的item复用了上边的item，造成下边item刚加载出来时显示的还是上边被复用的item的图片，等到这个新的item加载图片完毕时才会正常显示，这就是convert view复用造成listview图片加载错乱的问题。<br>与上边问题相似，在listview的item中存在CheckBox时也会由于复用convert view导致CheckBox的选中状态错乱，本片内容将解决由于复用导致CheckBox选中状态错乱的问题。<br>先看下存在问题的效果图<br><img src=\"https://raw.githubusercontent.com/zhpanvip/Resource/master/image/0402.jfif\"></p>\n<p>上图中只选中了北京市和天津市，当下滑ListView时发现下边的河南省和山东省也被选中了，再往下滑四川省和台湾省也被选中。其实可以发现一个规律，每一屏都会有两个条目被选中，其实这两个被选中的条目就是因为复用了第一屏的两个被选中的条目所导致的。<br>先看下ListView没有优化前的代码：</p>\n<pre><code class=\"hljs routeros\">public class MainActivity extends AppCompatActivity &#123;\n    private ListView mListView;\n    private List&lt;String&gt; mStringList;\n    @Override\n    protected void onCreate(Bundle savedInstanceState) &#123;\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        <span class=\"hljs-attribute\">mStringList</span>=new ArrayList&lt;&gt;();\n        mStringList.<span class=\"hljs-builtin-name\">add</span>(<span class=\"hljs-string\">&quot;北京市&quot;</span>);mStringList.<span class=\"hljs-builtin-name\">add</span>(<span class=\"hljs-string\">&quot;天津市&quot;</span>);mStringList.<span class=\"hljs-builtin-name\">add</span>(<span class=\"hljs-string\">&quot;上海市&quot;</span>);mStringList.<span class=\"hljs-builtin-name\">add</span>(<span class=\"hljs-string\">&quot;重庆市&quot;</span>);\n        mStringList.<span class=\"hljs-builtin-name\">add</span>(<span class=\"hljs-string\">&quot;河北省&quot;</span>);mStringList.<span class=\"hljs-builtin-name\">add</span>(<span class=\"hljs-string\">&quot;山西省&quot;</span>);mStringList.<span class=\"hljs-builtin-name\">add</span>(<span class=\"hljs-string\">&quot;辽宁省&quot;</span>);mStringList.<span class=\"hljs-builtin-name\">add</span>(<span class=\"hljs-string\">&quot;河南省&quot;</span>);\n        mStringList.<span class=\"hljs-builtin-name\">add</span>(<span class=\"hljs-string\">&quot;山东省&quot;</span>);mStringList.<span class=\"hljs-builtin-name\">add</span>(<span class=\"hljs-string\">&quot;湖北省&quot;</span>);mStringList.<span class=\"hljs-builtin-name\">add</span>(<span class=\"hljs-string\">&quot;湖南省&quot;</span>);mStringList.<span class=\"hljs-builtin-name\">add</span>(<span class=\"hljs-string\">&quot;江西省&quot;</span>);\n        mStringList.<span class=\"hljs-builtin-name\">add</span>(<span class=\"hljs-string\">&quot;福建省&quot;</span>);mStringList.<span class=\"hljs-builtin-name\">add</span>(<span class=\"hljs-string\">&quot;陕西省&quot;</span>);mStringList.<span class=\"hljs-builtin-name\">add</span>(<span class=\"hljs-string\">&quot;四川省&quot;</span>);mStringList.<span class=\"hljs-builtin-name\">add</span>(<span class=\"hljs-string\">&quot;台湾省&quot;</span>);\n        mListView= (ListView) findViewById(R.id.lv_main);\n        MyAdapter <span class=\"hljs-attribute\">adapter</span>=new MyAdapter(this,mStringList);\n        mListView.setAdapter(adapter);\n\n    &#125;\n&#125;</code></pre>\n<p>MainActivity中的代码为ListView适配数据和适配Adapter，不作过多解释。</p>\n<pre><code class=\"hljs reasonml\"><span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\"> * Created by zhpan on 2016/9/24.</span>\n<span class=\"hljs-comment\"> */</span>\n\npublic <span class=\"hljs-keyword\">class</span> MyAdapter extends BaseAdapter &#123;\n\n    List&lt;String&gt; mStringList;\n    Context mContext;\n\n    public <span class=\"hljs-constructor\">MyAdapter(Context <span class=\"hljs-params\">context</span>, List&lt;String&gt; <span class=\"hljs-params\">stringList</span>)</span> &#123;\n        mStringList = stringList;\n        mContext=context;\n    &#125;\n\n    @Override\n    public long get<span class=\"hljs-constructor\">ItemId(<span class=\"hljs-params\">int</span> <span class=\"hljs-params\">position</span>)</span> &#123;\n        return <span class=\"hljs-number\">0</span>;\n    &#125;\n\n    @Override\n    public View get<span class=\"hljs-constructor\">View(<span class=\"hljs-params\">final</span> <span class=\"hljs-params\">int</span> <span class=\"hljs-params\">position</span>, View <span class=\"hljs-params\">convertView</span>, ViewGroup <span class=\"hljs-params\">parent</span>)</span> &#123;\n        MyViewHolder holder;\n        <span class=\"hljs-keyword\">if</span>(convertView==null)&#123;\n            convertView=<span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">View</span>.</span></span>inflate(mContext,<span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">R</span>.</span></span>layout.item,null);\n            holder=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-constructor\">MyViewHolder()</span>;\n            holder.mTextView= (TextView) convertView.find<span class=\"hljs-constructor\">ViewById(R.<span class=\"hljs-params\">id</span>.<span class=\"hljs-params\">tv_item</span>)</span>;\n            holder.mCheckBox= (CheckBox) convertView.find<span class=\"hljs-constructor\">ViewById(R.<span class=\"hljs-params\">id</span>.<span class=\"hljs-params\">cb_item</span>)</span>;\n            convertView.set<span class=\"hljs-constructor\">Tag(<span class=\"hljs-params\">holder</span>)</span>;\n        &#125;<span class=\"hljs-keyword\">else</span> &#123;\n            holder= (MyViewHolder) convertView.get<span class=\"hljs-constructor\">Tag()</span>;\n        &#125;\n\n        holder.mTextView.set<span class=\"hljs-constructor\">Text(<span class=\"hljs-params\">mStringList</span>.<span class=\"hljs-params\">get</span>(<span class=\"hljs-params\">position</span>)</span>);\n\n        return convertView;\n    &#125;\n\n    @Override\n    public <span class=\"hljs-built_in\">int</span> get<span class=\"hljs-constructor\">Count()</span> &#123;\n        return mStringList.size<span class=\"hljs-literal\">()</span>;\n    &#125;\n\n    @Override\n    public Object get<span class=\"hljs-constructor\">Item(<span class=\"hljs-params\">int</span> <span class=\"hljs-params\">position</span>)</span> &#123;\n        return null;\n    &#125;\n\n    public static <span class=\"hljs-keyword\">class</span>  MyViewHolder &#123;\n        TextView mTextView;\n        CheckBox mCheckBox;\n    &#125;\n&#125;\n</code></pre>\n\n<p>在Adapter中只是复用了convertView,没有对CheckBox做任何处理，那么这样写的代码是存在上图中的CheckBox选中状态错乱问题的。为了解决这个问题我们需要对CheckBox的选中状态做下保存，可以在Adapter中声明一个Map集合用来保存被选中的CheckBox。修改后代码如下：</p>\n<pre><code class=\"hljs arduino\"><span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\"> * Created by zhpan on 2016/9/24.</span>\n<span class=\"hljs-comment\"> */</span>\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MyAdapter</span> <span class=\"hljs-title\">extends</span> <span class=\"hljs-title\">BaseAdapter</span> &#123;</span>\n\n    List&lt;<span class=\"hljs-keyword\">String</span>&gt; mStringList;\n    Context mContext;\n    <span class=\"hljs-keyword\">private</span> Map&lt;Integer,Boolean&gt; <span class=\"hljs-built_in\">map</span>=<span class=\"hljs-keyword\">new</span> HashMap&lt;&gt;();<span class=\"hljs-comment\">// 存放已被选中的CheckBox</span>\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">MyAdapter</span><span class=\"hljs-params\">(Context context, List&lt;<span class=\"hljs-keyword\">String</span>&gt; stringList)</span> </span>&#123;\n        mStringList = stringList;\n        mContext=context;\n    &#125;\n\n    @Override\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">long</span> <span class=\"hljs-title\">getItemId</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> <span class=\"hljs-built_in\">position</span>)</span> </span>&#123;\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n    &#125;\n\n    @Override\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> View <span class=\"hljs-title\">getView</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-built_in\">position</span>, View convertView, ViewGroup parent)</span> </span>&#123;\n        MyViewHolder holder;\n        <span class=\"hljs-keyword\">if</span>(convertView==null)&#123;\n            convertView=View.inflate(mContext,R.layout.item,null);\n            holder=<span class=\"hljs-keyword\">new</span> MyViewHolder();\n            holder.mTextView= (TextView) convertView.findViewById(R.id.tv_item);\n            holder.mCheckBox= (CheckBox) convertView.findViewById(R.id.cb_item);\n            convertView.setTag(holder);\n        &#125;<span class=\"hljs-keyword\">else</span> &#123;\n            holder= (MyViewHolder) convertView.getTag();\n        &#125;\n\n        holder.mTextView.setText(mStringList.<span class=\"hljs-built_in\">get</span>(<span class=\"hljs-built_in\">position</span>));\n        holder.mCheckBox.setOnCheckedChangeListener(<span class=\"hljs-keyword\">new</span> CompoundButton.OnCheckedChangeListener() &#123;\n            @Override\n            <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> onCheckedChanged(CompoundButton buttonView, <span class=\"hljs-keyword\">boolean</span> isChecked) &#123;\n                <span class=\"hljs-keyword\">if</span>(isChecked==<span class=\"hljs-literal\">true</span>)&#123;\n                    <span class=\"hljs-built_in\">map</span>.<span class=\"hljs-built_in\">put</span>(<span class=\"hljs-built_in\">position</span>,<span class=\"hljs-literal\">true</span>);\n                &#125;<span class=\"hljs-keyword\">else</span> &#123;\n                    <span class=\"hljs-built_in\">map</span>.<span class=\"hljs-built_in\">remove</span>(<span class=\"hljs-built_in\">position</span>);\n                &#125;\n            &#125;\n        &#125;);\n\n        <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-built_in\">map</span>!=null&amp;&amp;<span class=\"hljs-built_in\">map</span>.containsKey(<span class=\"hljs-built_in\">position</span>))&#123;\n            holder.mCheckBox.setChecked(<span class=\"hljs-literal\">true</span>);\n        &#125;<span class=\"hljs-keyword\">else</span> &#123;\n            holder.mCheckBox.setChecked(<span class=\"hljs-literal\">false</span>);\n        &#125;\n\n        <span class=\"hljs-keyword\">return</span> convertView;\n    &#125;\n\n    @Override\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">getCount</span><span class=\"hljs-params\">()</span> </span>&#123;\n        <span class=\"hljs-keyword\">return</span> mStringList.<span class=\"hljs-built_in\">size</span>();\n    &#125;\n\n    @Override\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> Object <span class=\"hljs-title\">getItem</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> <span class=\"hljs-built_in\">position</span>)</span> </span>&#123;\n        <span class=\"hljs-keyword\">return</span> null;\n    &#125;\n\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span>  <span class=\"hljs-title\">MyViewHolder</span> &#123;</span>\n        TextView mTextView;\n        CheckBox mCheckBox;\n    &#125;\n&#125;\n</code></pre>\n\n<p>针对这个问题我们子Adapter中加入了一个Map集合，其中Map的key用来存储条被选中的checkbox的position，value用来存储checkbox被选中。代码中还添加了checkbox的监听事件，在监听事件中判断点击的checkbox是否被选中，如果被选中了则将position添加到集合，并设置状态未true，否则就将该checkbox从集合中移除。然后通过if语句判断集合中是否存在该checkbox，如果存在则证明是被选中的,遂将该checkbox设置为选中状态setChecked(true)，否则证明checkbox没有选中则设置setChecked(false)。这样就解决了checkbox选中状态错乱的问题。<br>看下优化后的效果图<br><img src=\"https://raw.githubusercontent.com/zhpanvip/Resource/master/image/0403.jfif\"></p>\n<p>可以看到优化后CheckBox的选中状态不会再出现错乱问题了。</p>\n<p><a href=\"http://download.csdn.net/detail/qq_20521573/9639225\">源码下载</a></p>\n"},{"title":"Android搜索关键字高亮显示及开发中遇到的坑","date":"2016-12-15T06:53:52.000Z","_content":"\n公司项目中有一个搜索功能，需求是要把搜索关键字高亮显示出来。本来觉得是一个很简单的问题，开发过程也比较顺利。但在测试阶段还是出了些Bug。而且有些问题还挺莫名其妙！\n最初的想法，定义一个工具类，然后封装一个处理高亮的方法，需要高亮显示的直接调用这个工具类就行了。工具类封装了一个matcherSearchContent()的静态方法，然后用SpannableStringBuilder去处理关键字高亮显示，处理完成后方法返回处理好的SpannableStringBuilder。然后就可以直接给TextView去set处理好的SpannableStringBuilder。具体代码如下：\n```\n\n\npublic class TextHighLight {\n\n    public static SpannableStringBuilder matcherSearchContent(String text,String[] keyword){\n        SpannableStringBuilder spannable=new SpannableStringBuilder(text);\n        CharacterStyle span=null;\n        for(int i=0;i<keyword.length;i++){\n            Pattern pattern=Pattern.compile(keyword[i]);\n            Matcher matcher=pattern.matcher(text);\n            while(m.find()){\n                span=new ForegroundColorSpan(Color.parseColor(\"#ff5656\"));\n                            spannable.setSpan(span,m.start(),matcher.end(), Spannable.SPAN_MARK_MARK);\n            }\n        }\n        return spannable;\n    }\n}\n```\n但是后来需求说字母是要忽略大小写的。这个该怎么实现啊，用逻辑实现还是很麻烦的。还好，可以用到正则表达式来完成加上一行代码 \"(?i)\" + keyword[i] 就可以了。修改后代码如下：\n\n```\npublic class TextHighLight {\n\n    public static SpannableStringBuilder matcherSearchContent(String text,String[] keyword){\n        SpannableStringBuilder spannable=new SpannableStringBuilder(text);\n        CharacterStyle span=null;\n        for(int i=0;i<keyword.length;i++){\n            wordReg = \"(?i)\" + keyword[i];   //忽略字母大小写\n            Pattern pattern = Pattern.compile(wordReg);\n            Matcher matcher=pattern.matcher(text);\n            while(m.find()){\n                span=new ForegroundColorSpan(Color.parseColor(\"#ff5656\"));\n                spannable.setSpan(span,m.start(),matcher.end(), Spannable.SPAN_MARK_MARK);\n            }\n        }\n        return spannable;\n    }\n}\n```\n嗯 这个解决的比较轻松。接下来测试阶段出现的问题。当输入特殊字符比如“\\*”时，程序出现异常闪退。调试发现原因是因为“\\*”号导致。在正则表达式中“\\*”是通配符，因此在匹配正则表达式时出现了异常。。解决办法也比较简单吗，就是判读如果包含“*”号的话就加上一个“\\\"转义一下就行了嘛！于是就有了下面的代码（因为测试的时候只有搜索“\\*\"、\"(\"、\")\"时出现闪退，因此只对这三个字符作了处理）\n\n```\npublic class TextHighLight {\n\n    /**\n     *   关键字高亮显示\n     *   \n     *   @param text 文字\n     *      \n     *   @param keyword1 文字中的关键字数组\n     *              \n     *   @return\n     *  \n     */\n    public static SpannableStringBuilder matcherSearchContent(String text, String[] keyword) {\n        SpannableStringBuilder spannable = new SpannableStringBuilder(text);\n\n        CharacterStyle span;\n        String wordReg;\n        for (int i = 0; i < keyword.length; i++) {\n            String key = \"\";\n            //  处理通配符问题\n            if (keyword[i].contains(\"*\") || keyword[i].contains(\"(\") || keyword[i].contains(\")\")) {\n                char[] chars = keyword[i].toCharArray();\n                for (int k = 0; k < chars.length; k++) {\n                    if (chars[k] == '*' || chars[k] == '(' || chars[k] == ')') {\n                        key = key + \"\\\\\" + String.valueOf(chars[k]);\n                    } else {\n                        key = key + String.valueOf(chars[k]);\n                    }\n                }\n                keyword[i] = key;\n            }\n\n            wordReg = \"(?i)\" + keyword[i];   //忽略字母大小写\n            Pattern pattern = Pattern.compile(wordReg);\n            Matcher matcher = pattern.matcher(text);\n            while (matcher.find()) {\n                span = new ForegroundColorSpan(Color.parseColor(\"#ff5656\"));\n                spannable.setSpan(span, matcher.start(), matcher.end(), Spannable.SPAN_MARK_MARK);\n            }\n        }\n\n        return spannable;\n    }\n}\n```\n上边代码先判断了字符串中是否包含“\\*”、\"（\"、\")\"号，如果包含的话就遍历字符串然后在“\\*、\"（\"、\")\"号前边加上“\\\"转义。嗯 这次一定没问题了。然后运行测试，跑起来看效果。嗯，果真正常了！以为这样就完了那就太天真了。当在一级搜索页面测试的时候一个很奇怪的问题出现了！！输入“\\*”搜索时发现“\\*”竟然没有高亮显示！效果图如下：\n\n| 一级搜索页面 | 二级搜索页面 |\n|--|--|\n|![](https://raw.githubusercontent.com/zhpanvip/Resource/master/image/0501.jfif)| ![](https://raw.githubusercontent.com/zhpanvip/Resource/master/image/0502.jfif)|\n\n\n很诡异，有木有！两个页面调用的同一个Adapter，调用的同一个处理高亮的方法，为什么一个显示了高亮效果而一个却不正常显示呢！接下来经过漫长的调试、打log、对比两个页面。看下面的log日志信息：\n\n![](https://raw.githubusercontent.com/zhpanvip/Resource/master/image/0503.jfif)\n\n嗯？要匹配的字符串怎么变成了“\\ \\ \\*”了？正常来说应该匹配“\\\\*“ 的这样在正则表达式中”\\\\*“正好被转义成“*”的，难怪出现没有匹配高亮显示，问题就出在了上边的for循环添加\"\\\"那段代码。看上边代码发现经过处理转义字符后将keyword[i]进行了一次重新赋值，而调用处理高亮的方法时传过来的参数关键字数组仅仅是一个引用，而实际的数组是在堆内存中存储的，因此重新赋值致使堆内存数据发生了改变！\n既然找到了问题所在就应该分析引起问题的原因，为什么转义字符会被添加了两次？\n调试的时候发现getView()方法确实是被重复执行了多次。这个原因就很奇怪了，按理说getView()方法的调用应该是跟ListView条目对应的。即有多少条数据，getView()就会被调用多少次。但是为什么在这个页面getView()会被重复执行，而在另一个页面getView()却只调用了一次？后来通过查阅资料发现是由于ListView的布局原因引起的。***当ListView的layout_height属性设置为wrap_content的时候，getView()就会出现被重复调用的问题！，而layout_height设置位match_parent的时候getView()的调用则是正常的***，现在再会过头来看两个页面的布局，上边第一张图片是出现问题的布局，因为该页面有多个ListView，因此单个ListView的layout_height都被定义成了wrap_content从而出现了上述getView()被重复调用问题。而第二张图片中只有一个ListView,layout_height属性设置的是match_parent,因此这个页面getView()只被调用了一次，所以高亮显示也就正常了！\n\n问题原因找到了，也就好解决了。解决的方案有两个，第一就是更改ListView()的layout_height属性，给其设置为定值。第二就是在matcherSearchContent（）的方法里复制出来关键字的数组，然后再去匹配。这里采用的是第二种方案。修改后代码如下：\n\n```\npublic class TextHighLight {\n\n    /**\n     *   关键字高亮显示\n     *   \n     *   @param text 文字\n     *      \n     *   @param keyword1 文字中的关键字数组\n     *              \n     *   @return\n     *  \n     */\n    public static SpannableStringBuilder matcherSearchContent(String text, String[] keyword1) {\n        String[] keyword = new String[keyword1.length];\n        System.arraycopy(keyword1, 0, keyword, 0, keyword1.length);\n        SpannableStringBuilder spannable = new SpannableStringBuilder(text);\n\n        CharacterStyle span;\n        String wordReg;\n        for (int i = 0; i < keyword.length; i++) {\n            String key = \"\";\n            //  处理通配符问题\n            if (keyword[i].contains(\"*\") || keyword[i].contains(\"(\") || keyword[i].contains(\")\")) {\n                char[] chars = keyword[i].toCharArray();\n                for (int k = 0; k < chars.length; k++) {\n                    if (chars[k] == '*' || chars[k] == '(' || chars[k] == ')') {\n                        key = key + \"\\\\\" + String.valueOf(chars[k]);\n                    } else {\n                        key = key + String.valueOf(chars[k]);\n                    }\n                }\n                keyword[i] = key;\n            }\n\n            wordReg = \"(?i)\" + keyword[i];   //忽略字母大小写\n            Pattern pattern = Pattern.compile(wordReg);\n            Matcher matcher = pattern.matcher(text);\n            while (matcher.find()) {\n                span = new ForegroundColorSpan(Color.parseColor(\"#ff5656\"));\n                spannable.setSpan(span, matcher.start(), matcher.end(), Spannable.SPAN_MARK_MARK);\n            }\n        }\n\n        return spannable;\n    }\n}\n```\n到这里关于关键字高亮的所有问题总算是解决了。\n\n","source":"_posts/5.Android搜索关键字高亮显示及开发中遇到的坑.md","raw":"---\ntitle: Android搜索关键字高亮显示及开发中遇到的坑\ndate: 2016-12-15 14:53:52\ntags:\n---\n\n公司项目中有一个搜索功能，需求是要把搜索关键字高亮显示出来。本来觉得是一个很简单的问题，开发过程也比较顺利。但在测试阶段还是出了些Bug。而且有些问题还挺莫名其妙！\n最初的想法，定义一个工具类，然后封装一个处理高亮的方法，需要高亮显示的直接调用这个工具类就行了。工具类封装了一个matcherSearchContent()的静态方法，然后用SpannableStringBuilder去处理关键字高亮显示，处理完成后方法返回处理好的SpannableStringBuilder。然后就可以直接给TextView去set处理好的SpannableStringBuilder。具体代码如下：\n```\n\n\npublic class TextHighLight {\n\n    public static SpannableStringBuilder matcherSearchContent(String text,String[] keyword){\n        SpannableStringBuilder spannable=new SpannableStringBuilder(text);\n        CharacterStyle span=null;\n        for(int i=0;i<keyword.length;i++){\n            Pattern pattern=Pattern.compile(keyword[i]);\n            Matcher matcher=pattern.matcher(text);\n            while(m.find()){\n                span=new ForegroundColorSpan(Color.parseColor(\"#ff5656\"));\n                            spannable.setSpan(span,m.start(),matcher.end(), Spannable.SPAN_MARK_MARK);\n            }\n        }\n        return spannable;\n    }\n}\n```\n但是后来需求说字母是要忽略大小写的。这个该怎么实现啊，用逻辑实现还是很麻烦的。还好，可以用到正则表达式来完成加上一行代码 \"(?i)\" + keyword[i] 就可以了。修改后代码如下：\n\n```\npublic class TextHighLight {\n\n    public static SpannableStringBuilder matcherSearchContent(String text,String[] keyword){\n        SpannableStringBuilder spannable=new SpannableStringBuilder(text);\n        CharacterStyle span=null;\n        for(int i=0;i<keyword.length;i++){\n            wordReg = \"(?i)\" + keyword[i];   //忽略字母大小写\n            Pattern pattern = Pattern.compile(wordReg);\n            Matcher matcher=pattern.matcher(text);\n            while(m.find()){\n                span=new ForegroundColorSpan(Color.parseColor(\"#ff5656\"));\n                spannable.setSpan(span,m.start(),matcher.end(), Spannable.SPAN_MARK_MARK);\n            }\n        }\n        return spannable;\n    }\n}\n```\n嗯 这个解决的比较轻松。接下来测试阶段出现的问题。当输入特殊字符比如“\\*”时，程序出现异常闪退。调试发现原因是因为“\\*”号导致。在正则表达式中“\\*”是通配符，因此在匹配正则表达式时出现了异常。。解决办法也比较简单吗，就是判读如果包含“*”号的话就加上一个“\\\"转义一下就行了嘛！于是就有了下面的代码（因为测试的时候只有搜索“\\*\"、\"(\"、\")\"时出现闪退，因此只对这三个字符作了处理）\n\n```\npublic class TextHighLight {\n\n    /**\n     *   关键字高亮显示\n     *   \n     *   @param text 文字\n     *      \n     *   @param keyword1 文字中的关键字数组\n     *              \n     *   @return\n     *  \n     */\n    public static SpannableStringBuilder matcherSearchContent(String text, String[] keyword) {\n        SpannableStringBuilder spannable = new SpannableStringBuilder(text);\n\n        CharacterStyle span;\n        String wordReg;\n        for (int i = 0; i < keyword.length; i++) {\n            String key = \"\";\n            //  处理通配符问题\n            if (keyword[i].contains(\"*\") || keyword[i].contains(\"(\") || keyword[i].contains(\")\")) {\n                char[] chars = keyword[i].toCharArray();\n                for (int k = 0; k < chars.length; k++) {\n                    if (chars[k] == '*' || chars[k] == '(' || chars[k] == ')') {\n                        key = key + \"\\\\\" + String.valueOf(chars[k]);\n                    } else {\n                        key = key + String.valueOf(chars[k]);\n                    }\n                }\n                keyword[i] = key;\n            }\n\n            wordReg = \"(?i)\" + keyword[i];   //忽略字母大小写\n            Pattern pattern = Pattern.compile(wordReg);\n            Matcher matcher = pattern.matcher(text);\n            while (matcher.find()) {\n                span = new ForegroundColorSpan(Color.parseColor(\"#ff5656\"));\n                spannable.setSpan(span, matcher.start(), matcher.end(), Spannable.SPAN_MARK_MARK);\n            }\n        }\n\n        return spannable;\n    }\n}\n```\n上边代码先判断了字符串中是否包含“\\*”、\"（\"、\")\"号，如果包含的话就遍历字符串然后在“\\*、\"（\"、\")\"号前边加上“\\\"转义。嗯 这次一定没问题了。然后运行测试，跑起来看效果。嗯，果真正常了！以为这样就完了那就太天真了。当在一级搜索页面测试的时候一个很奇怪的问题出现了！！输入“\\*”搜索时发现“\\*”竟然没有高亮显示！效果图如下：\n\n| 一级搜索页面 | 二级搜索页面 |\n|--|--|\n|![](https://raw.githubusercontent.com/zhpanvip/Resource/master/image/0501.jfif)| ![](https://raw.githubusercontent.com/zhpanvip/Resource/master/image/0502.jfif)|\n\n\n很诡异，有木有！两个页面调用的同一个Adapter，调用的同一个处理高亮的方法，为什么一个显示了高亮效果而一个却不正常显示呢！接下来经过漫长的调试、打log、对比两个页面。看下面的log日志信息：\n\n![](https://raw.githubusercontent.com/zhpanvip/Resource/master/image/0503.jfif)\n\n嗯？要匹配的字符串怎么变成了“\\ \\ \\*”了？正常来说应该匹配“\\\\*“ 的这样在正则表达式中”\\\\*“正好被转义成“*”的，难怪出现没有匹配高亮显示，问题就出在了上边的for循环添加\"\\\"那段代码。看上边代码发现经过处理转义字符后将keyword[i]进行了一次重新赋值，而调用处理高亮的方法时传过来的参数关键字数组仅仅是一个引用，而实际的数组是在堆内存中存储的，因此重新赋值致使堆内存数据发生了改变！\n既然找到了问题所在就应该分析引起问题的原因，为什么转义字符会被添加了两次？\n调试的时候发现getView()方法确实是被重复执行了多次。这个原因就很奇怪了，按理说getView()方法的调用应该是跟ListView条目对应的。即有多少条数据，getView()就会被调用多少次。但是为什么在这个页面getView()会被重复执行，而在另一个页面getView()却只调用了一次？后来通过查阅资料发现是由于ListView的布局原因引起的。***当ListView的layout_height属性设置为wrap_content的时候，getView()就会出现被重复调用的问题！，而layout_height设置位match_parent的时候getView()的调用则是正常的***，现在再会过头来看两个页面的布局，上边第一张图片是出现问题的布局，因为该页面有多个ListView，因此单个ListView的layout_height都被定义成了wrap_content从而出现了上述getView()被重复调用问题。而第二张图片中只有一个ListView,layout_height属性设置的是match_parent,因此这个页面getView()只被调用了一次，所以高亮显示也就正常了！\n\n问题原因找到了，也就好解决了。解决的方案有两个，第一就是更改ListView()的layout_height属性，给其设置为定值。第二就是在matcherSearchContent（）的方法里复制出来关键字的数组，然后再去匹配。这里采用的是第二种方案。修改后代码如下：\n\n```\npublic class TextHighLight {\n\n    /**\n     *   关键字高亮显示\n     *   \n     *   @param text 文字\n     *      \n     *   @param keyword1 文字中的关键字数组\n     *              \n     *   @return\n     *  \n     */\n    public static SpannableStringBuilder matcherSearchContent(String text, String[] keyword1) {\n        String[] keyword = new String[keyword1.length];\n        System.arraycopy(keyword1, 0, keyword, 0, keyword1.length);\n        SpannableStringBuilder spannable = new SpannableStringBuilder(text);\n\n        CharacterStyle span;\n        String wordReg;\n        for (int i = 0; i < keyword.length; i++) {\n            String key = \"\";\n            //  处理通配符问题\n            if (keyword[i].contains(\"*\") || keyword[i].contains(\"(\") || keyword[i].contains(\")\")) {\n                char[] chars = keyword[i].toCharArray();\n                for (int k = 0; k < chars.length; k++) {\n                    if (chars[k] == '*' || chars[k] == '(' || chars[k] == ')') {\n                        key = key + \"\\\\\" + String.valueOf(chars[k]);\n                    } else {\n                        key = key + String.valueOf(chars[k]);\n                    }\n                }\n                keyword[i] = key;\n            }\n\n            wordReg = \"(?i)\" + keyword[i];   //忽略字母大小写\n            Pattern pattern = Pattern.compile(wordReg);\n            Matcher matcher = pattern.matcher(text);\n            while (matcher.find()) {\n                span = new ForegroundColorSpan(Color.parseColor(\"#ff5656\"));\n                spannable.setSpan(span, matcher.start(), matcher.end(), Spannable.SPAN_MARK_MARK);\n            }\n        }\n\n        return spannable;\n    }\n}\n```\n到这里关于关键字高亮的所有问题总算是解决了。\n\n","slug":"5.Android搜索关键字高亮显示及开发中遇到的坑","published":1,"updated":"2020-08-29T18:02:34.466Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckegm5ns0000idwozhx083grc","content":"<p>公司项目中有一个搜索功能，需求是要把搜索关键字高亮显示出来。本来觉得是一个很简单的问题，开发过程也比较顺利。但在测试阶段还是出了些Bug。而且有些问题还挺莫名其妙！<br>最初的想法，定义一个工具类，然后封装一个处理高亮的方法，需要高亮显示的直接调用这个工具类就行了。工具类封装了一个matcherSearchContent()的静态方法，然后用SpannableStringBuilder去处理关键字高亮显示，处理完成后方法返回处理好的SpannableStringBuilder。然后就可以直接给TextView去set处理好的SpannableStringBuilder。具体代码如下：</p>\n<pre><code class=\"hljs\">\n\npublic class TextHighLight &#123;\n\n    public static SpannableStringBuilder matcherSearchContent(String text,String[] keyword)&#123;\n        SpannableStringBuilder spannable=new SpannableStringBuilder(text);\n        CharacterStyle span=null;\n        for(int i=0;i&lt;keyword.length;i++)&#123;\n            Pattern pattern=Pattern.compile(keyword[i]);\n            Matcher matcher=pattern.matcher(text);\n            while(m.find())&#123;\n                span=new ForegroundColorSpan(Color.parseColor(&quot;#ff5656&quot;));\n                            spannable.setSpan(span,m.start(),matcher.end(), Spannable.SPAN_MARK_MARK);\n            &#125;\n        &#125;\n        return spannable;\n    &#125;\n&#125;</code></pre>\n<p>但是后来需求说字母是要忽略大小写的。这个该怎么实现啊，用逻辑实现还是很麻烦的。还好，可以用到正则表达式来完成加上一行代码 “(?i)” + keyword[i] 就可以了。修改后代码如下：</p>\n<pre><code class=\"hljs reasonml\">public <span class=\"hljs-keyword\">class</span> TextHighLight &#123;\n\n    public static SpannableStringBuilder matcher<span class=\"hljs-constructor\">SearchContent(String <span class=\"hljs-params\">text</span>,String[] <span class=\"hljs-params\">keyword</span>)</span>&#123;\n        SpannableStringBuilder spannable=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-constructor\">SpannableStringBuilder(<span class=\"hljs-params\">text</span>)</span>;\n        CharacterStyle span=null;\n        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-built_in\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;keyword.length;i++)&#123;\n            wordReg = <span class=\"hljs-string\">&quot;(?i)&quot;</span> + keyword<span class=\"hljs-literal\">[<span class=\"hljs-identifier\">i</span>]</span>;   <span class=\"hljs-comment\">//忽略字母大小写</span>\n            Pattern pattern = <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">Pattern</span>.</span></span>compile(wordReg);\n            Matcher matcher=pattern.matcher(text);\n            <span class=\"hljs-keyword\">while</span>(m.find<span class=\"hljs-literal\">()</span>)&#123;\n                span=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-constructor\">ForegroundColorSpan(Color.<span class=\"hljs-params\">parseColor</span>(<span class=\"hljs-string\">&quot;#ff5656&quot;</span>)</span>);\n                spannable.set<span class=\"hljs-constructor\">Span(<span class=\"hljs-params\">span</span>,<span class=\"hljs-params\">m</span>.<span class=\"hljs-params\">start</span>()</span>,matcher.<span class=\"hljs-keyword\">end</span><span class=\"hljs-literal\">()</span>, Spannable.SPAN_MARK_MARK);\n            &#125;\n        &#125;\n        return spannable;\n    &#125;\n&#125;</code></pre>\n<p>嗯 这个解决的比较轻松。接下来测试阶段出现的问题。当输入特殊字符比如“*”时，程序出现异常闪退。调试发现原因是因为“*”号导致。在正则表达式中“*”是通配符，因此在匹配正则表达式时出现了异常。。解决办法也比较简单吗，就是判读如果包含“<em>”号的话就加上一个“&quot;转义一下就行了嘛！于是就有了下面的代码（因为测试的时候只有搜索“\\</em>“、”(“、”)”时出现闪退，因此只对这三个字符作了处理）</p>\n<pre><code class=\"hljs reasonml\">public <span class=\"hljs-keyword\">class</span> TextHighLight &#123;\n\n    <span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">     *   关键字高亮显示</span>\n<span class=\"hljs-comment\">     *   </span>\n<span class=\"hljs-comment\">     *   @param text 文字</span>\n<span class=\"hljs-comment\">     *      </span>\n<span class=\"hljs-comment\">     *   @param keyword1 文字中的关键字数组</span>\n<span class=\"hljs-comment\">     *              </span>\n<span class=\"hljs-comment\">     *   @return</span>\n<span class=\"hljs-comment\">     *  </span>\n<span class=\"hljs-comment\">     */</span>\n    public static SpannableStringBuilder matcher<span class=\"hljs-constructor\">SearchContent(String <span class=\"hljs-params\">text</span>, String[] <span class=\"hljs-params\">keyword</span>)</span> &#123;\n        SpannableStringBuilder spannable = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-constructor\">SpannableStringBuilder(<span class=\"hljs-params\">text</span>)</span>;\n\n        CharacterStyle span;\n        String wordReg;\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-built_in\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; keyword.length; i++) &#123;\n            String key = <span class=\"hljs-string\">&quot;&quot;</span>;\n            <span class=\"hljs-comment\">//  处理通配符问题</span>\n            <span class=\"hljs-keyword\">if</span> (keyword<span class=\"hljs-literal\">[<span class=\"hljs-identifier\">i</span>]</span>.contains(<span class=\"hljs-string\">&quot;*&quot;</span>)<span class=\"hljs-operator\"> || </span>keyword<span class=\"hljs-literal\">[<span class=\"hljs-identifier\">i</span>]</span>.contains(<span class=\"hljs-string\">&quot;(&quot;</span>)<span class=\"hljs-operator\"> || </span>keyword<span class=\"hljs-literal\">[<span class=\"hljs-identifier\">i</span>]</span>.contains(<span class=\"hljs-string\">&quot;)&quot;</span>)) &#123;\n                <span class=\"hljs-built_in\">char</span><span class=\"hljs-literal\">[]</span> chars = keyword<span class=\"hljs-literal\">[<span class=\"hljs-identifier\">i</span>]</span>.<span class=\"hljs-keyword\">to</span><span class=\"hljs-constructor\">CharArray()</span>;\n                <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-built_in\">int</span> k = <span class=\"hljs-number\">0</span>; k &lt; chars.length; k++) &#123;\n                    <span class=\"hljs-keyword\">if</span> (chars<span class=\"hljs-literal\">[<span class=\"hljs-identifier\">k</span>]</span><span class=\"hljs-operator\"> == </span><span class=\"hljs-character\">&#x27;*&#x27;</span><span class=\"hljs-operator\"> || </span>chars<span class=\"hljs-literal\">[<span class=\"hljs-identifier\">k</span>]</span><span class=\"hljs-operator\"> == </span><span class=\"hljs-character\">&#x27;(&#x27;</span><span class=\"hljs-operator\"> || </span>chars<span class=\"hljs-literal\">[<span class=\"hljs-identifier\">k</span>]</span><span class=\"hljs-operator\"> == </span><span class=\"hljs-character\">&#x27;)&#x27;</span>) &#123;\n                        key = key + <span class=\"hljs-string\">&quot;\\\\&quot;</span> + <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">String</span>.</span></span>value<span class=\"hljs-constructor\">Of(<span class=\"hljs-params\">chars</span>[<span class=\"hljs-params\">k</span>])</span>;\n                    &#125; <span class=\"hljs-keyword\">else</span> &#123;\n                        key = key + <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">String</span>.</span></span>value<span class=\"hljs-constructor\">Of(<span class=\"hljs-params\">chars</span>[<span class=\"hljs-params\">k</span>])</span>;\n                    &#125;\n                &#125;\n                keyword<span class=\"hljs-literal\">[<span class=\"hljs-identifier\">i</span>]</span> = key;\n            &#125;\n\n            wordReg = <span class=\"hljs-string\">&quot;(?i)&quot;</span> + keyword<span class=\"hljs-literal\">[<span class=\"hljs-identifier\">i</span>]</span>;   <span class=\"hljs-comment\">//忽略字母大小写</span>\n            Pattern pattern = <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">Pattern</span>.</span></span>compile(wordReg);\n            Matcher matcher = pattern.matcher(text);\n            <span class=\"hljs-keyword\">while</span> (matcher.find<span class=\"hljs-literal\">()</span>) &#123;\n                span = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-constructor\">ForegroundColorSpan(Color.<span class=\"hljs-params\">parseColor</span>(<span class=\"hljs-string\">&quot;#ff5656&quot;</span>)</span>);\n                spannable.set<span class=\"hljs-constructor\">Span(<span class=\"hljs-params\">span</span>, <span class=\"hljs-params\">matcher</span>.<span class=\"hljs-params\">start</span>()</span>, matcher.<span class=\"hljs-keyword\">end</span><span class=\"hljs-literal\">()</span>, Spannable.SPAN_MARK_MARK);\n            &#125;\n        &#125;\n\n        return spannable;\n    &#125;\n&#125;</code></pre>\n<p>上边代码先判断了字符串中是否包含“*”、”（”、”)”号，如果包含的话就遍历字符串然后在“*、”（”、”)”号前边加上“&quot;转义。嗯 这次一定没问题了。然后运行测试，跑起来看效果。嗯，果真正常了！以为这样就完了那就太天真了。当在一级搜索页面测试的时候一个很奇怪的问题出现了！！输入“*”搜索时发现“*”竟然没有高亮显示！效果图如下：</p>\n<table>\n<thead>\n<tr>\n<th>一级搜索页面</th>\n<th>二级搜索页面</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><img src=\"https://raw.githubusercontent.com/zhpanvip/Resource/master/image/0501.jfif\"></td>\n<td><img src=\"https://raw.githubusercontent.com/zhpanvip/Resource/master/image/0502.jfif\"></td>\n</tr>\n</tbody></table>\n<p>很诡异，有木有！两个页面调用的同一个Adapter，调用的同一个处理高亮的方法，为什么一个显示了高亮效果而一个却不正常显示呢！接下来经过漫长的调试、打log、对比两个页面。看下面的log日志信息：</p>\n<p><img src=\"https://raw.githubusercontent.com/zhpanvip/Resource/master/image/0503.jfif\"></p>\n<p>嗯？要匹配的字符串怎么变成了“\\ \\ *”了？正常来说应该匹配“\\<em>“ 的这样在正则表达式中”\\</em>“正好被转义成“<em>”的，难怪出现没有匹配高亮显示，问题就出在了上边的for循环添加”&quot;那段代码。看上边代码发现经过处理转义字符后将keyword[i]进行了一次重新赋值，而调用处理高亮的方法时传过来的参数关键字数组仅仅是一个引用，而实际的数组是在堆内存中存储的，因此重新赋值致使堆内存数据发生了改变！<br>既然找到了问题所在就应该分析引起问题的原因，为什么转义字符会被添加了两次？<br>调试的时候发现getView()方法确实是被重复执行了多次。这个原因就很奇怪了，按理说getView()方法的调用应该是跟ListView条目对应的。即有多少条数据，getView()就会被调用多少次。但是为什么在这个页面getView()会被重复执行，而在另一个页面getView()却只调用了一次？后来通过查阅资料发现是由于ListView的布局原因引起的。**</em>当ListView的layout_height属性设置为wrap_content的时候，getView()就会出现被重复调用的问题！，而layout_height设置位match_parent的时候getView()的调用则是正常的***，现在再会过头来看两个页面的布局，上边第一张图片是出现问题的布局，因为该页面有多个ListView，因此单个ListView的layout_height都被定义成了wrap_content从而出现了上述getView()被重复调用问题。而第二张图片中只有一个ListView,layout_height属性设置的是match_parent,因此这个页面getView()只被调用了一次，所以高亮显示也就正常了！</p>\n<p>问题原因找到了，也就好解决了。解决的方案有两个，第一就是更改ListView()的layout_height属性，给其设置为定值。第二就是在matcherSearchContent（）的方法里复制出来关键字的数组，然后再去匹配。这里采用的是第二种方案。修改后代码如下：</p>\n<pre><code class=\"hljs reasonml\">public <span class=\"hljs-keyword\">class</span> TextHighLight &#123;\n\n    <span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">     *   关键字高亮显示</span>\n<span class=\"hljs-comment\">     *   </span>\n<span class=\"hljs-comment\">     *   @param text 文字</span>\n<span class=\"hljs-comment\">     *      </span>\n<span class=\"hljs-comment\">     *   @param keyword1 文字中的关键字数组</span>\n<span class=\"hljs-comment\">     *              </span>\n<span class=\"hljs-comment\">     *   @return</span>\n<span class=\"hljs-comment\">     *  </span>\n<span class=\"hljs-comment\">     */</span>\n    public static SpannableStringBuilder matcher<span class=\"hljs-constructor\">SearchContent(String <span class=\"hljs-params\">text</span>, String[] <span class=\"hljs-params\">keyword1</span>)</span> &#123;\n        String<span class=\"hljs-literal\">[]</span> keyword = <span class=\"hljs-keyword\">new</span> String<span class=\"hljs-literal\">[<span class=\"hljs-identifier\">keyword1</span>.<span class=\"hljs-identifier\">length</span>]</span>;\n        <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">System</span>.</span></span>arraycopy(keyword1, <span class=\"hljs-number\">0</span>, keyword, <span class=\"hljs-number\">0</span>, keyword1.length);\n        SpannableStringBuilder spannable = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-constructor\">SpannableStringBuilder(<span class=\"hljs-params\">text</span>)</span>;\n\n        CharacterStyle span;\n        String wordReg;\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-built_in\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; keyword.length; i++) &#123;\n            String key = <span class=\"hljs-string\">&quot;&quot;</span>;\n            <span class=\"hljs-comment\">//  处理通配符问题</span>\n            <span class=\"hljs-keyword\">if</span> (keyword<span class=\"hljs-literal\">[<span class=\"hljs-identifier\">i</span>]</span>.contains(<span class=\"hljs-string\">&quot;*&quot;</span>)<span class=\"hljs-operator\"> || </span>keyword<span class=\"hljs-literal\">[<span class=\"hljs-identifier\">i</span>]</span>.contains(<span class=\"hljs-string\">&quot;(&quot;</span>)<span class=\"hljs-operator\"> || </span>keyword<span class=\"hljs-literal\">[<span class=\"hljs-identifier\">i</span>]</span>.contains(<span class=\"hljs-string\">&quot;)&quot;</span>)) &#123;\n                <span class=\"hljs-built_in\">char</span><span class=\"hljs-literal\">[]</span> chars = keyword<span class=\"hljs-literal\">[<span class=\"hljs-identifier\">i</span>]</span>.<span class=\"hljs-keyword\">to</span><span class=\"hljs-constructor\">CharArray()</span>;\n                <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-built_in\">int</span> k = <span class=\"hljs-number\">0</span>; k &lt; chars.length; k++) &#123;\n                    <span class=\"hljs-keyword\">if</span> (chars<span class=\"hljs-literal\">[<span class=\"hljs-identifier\">k</span>]</span><span class=\"hljs-operator\"> == </span><span class=\"hljs-character\">&#x27;*&#x27;</span><span class=\"hljs-operator\"> || </span>chars<span class=\"hljs-literal\">[<span class=\"hljs-identifier\">k</span>]</span><span class=\"hljs-operator\"> == </span><span class=\"hljs-character\">&#x27;(&#x27;</span><span class=\"hljs-operator\"> || </span>chars<span class=\"hljs-literal\">[<span class=\"hljs-identifier\">k</span>]</span><span class=\"hljs-operator\"> == </span><span class=\"hljs-character\">&#x27;)&#x27;</span>) &#123;\n                        key = key + <span class=\"hljs-string\">&quot;\\\\&quot;</span> + <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">String</span>.</span></span>value<span class=\"hljs-constructor\">Of(<span class=\"hljs-params\">chars</span>[<span class=\"hljs-params\">k</span>])</span>;\n                    &#125; <span class=\"hljs-keyword\">else</span> &#123;\n                        key = key + <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">String</span>.</span></span>value<span class=\"hljs-constructor\">Of(<span class=\"hljs-params\">chars</span>[<span class=\"hljs-params\">k</span>])</span>;\n                    &#125;\n                &#125;\n                keyword<span class=\"hljs-literal\">[<span class=\"hljs-identifier\">i</span>]</span> = key;\n            &#125;\n\n            wordReg = <span class=\"hljs-string\">&quot;(?i)&quot;</span> + keyword<span class=\"hljs-literal\">[<span class=\"hljs-identifier\">i</span>]</span>;   <span class=\"hljs-comment\">//忽略字母大小写</span>\n            Pattern pattern = <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">Pattern</span>.</span></span>compile(wordReg);\n            Matcher matcher = pattern.matcher(text);\n            <span class=\"hljs-keyword\">while</span> (matcher.find<span class=\"hljs-literal\">()</span>) &#123;\n                span = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-constructor\">ForegroundColorSpan(Color.<span class=\"hljs-params\">parseColor</span>(<span class=\"hljs-string\">&quot;#ff5656&quot;</span>)</span>);\n                spannable.set<span class=\"hljs-constructor\">Span(<span class=\"hljs-params\">span</span>, <span class=\"hljs-params\">matcher</span>.<span class=\"hljs-params\">start</span>()</span>, matcher.<span class=\"hljs-keyword\">end</span><span class=\"hljs-literal\">()</span>, Spannable.SPAN_MARK_MARK);\n            &#125;\n        &#125;\n\n        return spannable;\n    &#125;\n&#125;</code></pre>\n<p>到这里关于关键字高亮的所有问题总算是解决了。</p>\n","site":{"data":{"fluid_config":{"favicon":"/img/favicon.png","apple_touch_icon":"/img/favicon.png","title_join_string":" - ","force_https":false,"highlight":{"enable":true,"style":"Github Gist","bg_color":false,"copy_btn":true},"fun_features":{"typing":{"enable":true,"typeSpeed":70,"cursorChar":"|","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"mouse_click":{"enable":false,"style":"values"}},"dark_mode":{"enable":true,"default":"auto"},"color":{"body_bg_color":"#eee","body_bg_color_dark":"#181c27","navbar_bg_color":"#2f4154","navbar_bg_color_dark":"#1f3144","navbar_text_color":"#fff","navbar_text_color_dark":"#d0d0d0","text_color":"#3c4858","text_color_dark":"#c4c6c9","sec_text_color":"#718096","sec_text_color_dark":"#a7a9ad","post_text_color":"#2c3e50","post_text_color_dark":"#c4c6c9","post_heading_color":"#1a202c","post_heading_color_dark":"#c4c6c9","post_link_color":"#0366d6","post_link_color_dark":"#1589e9","link_hover_color":"#30a9de","link_hover_color_dark":"#30a9de","link_hover_bg_color":"#f8f9fa","link_hover_bg_color_dark":"#364151","board_color":"#fff","board_color_dark":"#252d38"},"font":{"font_size":"16px","font_family":null,"code_font_size":"85%"},"custom_js":null,"custom_css":null,"custom_html":"","web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"tajs":null,"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}},"lazyload":{"enable":true,"onlypost":false},"daovoice":{"enable":false,"appid":""},"aplayer":{"enable":false,"autoplay":false,"loop":"all","order":"random","theme":"#b7daff","songs":[{"name":"name","artist":"artist","url":"/songs/test.mp3","cover":"/img/cover.jpg"},{"name":"name","artist":"artist","url":"https://...url.mp3","cover":"https://...cover.jpg"}]},"version":{"check":false},"navbar":{"blog_title":"zhangpan","ground_glass":{"enable":false,"px":3,"alpha":0.7},"menu":[{"key":"home","link":"/","icon":"iconfont icon-home-fill"},{"key":"archive","link":"/archives/","icon":"iconfont icon-archive-fill"},{"key":"category","link":"/categories/","icon":"iconfont icon-category-fill"},{"key":"tag","link":"/tags/","icon":"iconfont icon-tags-fill"},{"key":"about","link":"/about/","icon":"iconfont icon-user-fill"}]},"search":{"enable":true,"path":"/local-search.xml","generate_path":"/local-search.xml","field":"post","content":true},"scroll_down_arrow":{"enable":true,"banner_height_limit":90,"scroll_after_turning_page":true},"banner_parallax":true,"footer":{"statistics":{"enable":false,"source":"busuanzi","pv_format":"总访问量 {} 次","uv_format":"总访客数 {} 人"},"beian":{"enable":false,"icp_text":"京ICP证123456号","police_text":"京公网安备12345678号","police_code":12345678,"police_icon":"/img/police_beian.png"}},"scroll_top_arrow":{"enable":true},"index":{"banner_img":"/img/default.png","banner_img_height":100,"banner_mask_alpha":0.3,"post_default_img":"","slogan":{"enable":true,"text":"Talk is cheap, show me the code."},"auto_excerpt":{"enable":true},"post_url_target":"_self","post_meta":{"date":true,"category":true,"tag":true}},"page":{"banner_img":"/img/default.png","banner_img_height":60,"banner_mask_alpha":0.3},"post":{"banner_img":"/img/default.png","banner_img_height":70,"banner_mask_alpha":0.3,"meta":{"date":{"enable":true,"format":"LL a"},"wordcount":{"enable":true,"format":"{} 字"},"min2read":{"enable":true,"format":"{} 分钟","words":100},"views":{"enable":false,"source":"busuanzi","format":"{} 次"}},"updated":{"enable":false,"content":"本文最后更新于：","relative":false},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"copyright":{"enable":true,"content":"本博客所有文章除特别声明外，均采用 <a href=\"https://creativecommons.org/licenses/by-sa/4.0/deed.zh\" rel=\"nofollow noopener\">CC BY-SA 4.0 协议</a> ，转载请注明出处！ <h5>开源库推荐</h5> <a href=\"https://github.com/zhpanvip/BannerViewPager\">1.BannerViewPager</a> <p> 一个基于ViewPager2实现的具有强大功能的无限轮播库。支持多种页面切换效果和指示器样式。 </p>\n<a href=\"https://github.com/zhpanvip/viewpagerindicator\">2.ViewPagerIndicator</a> <p> 一个适用于ViewPager和ViewPager2的指示器，支持多种滑块样式及滑动模式 </p>"},"prev_next":{"enable":true},"custom":{"enable":false,"content":"<img src=\"https://octodex.github.com/images/jetpacktocat.png\" class=\"rounded mx-auto d-block mt-5\" style=\"width:150px; height:150px;\">"},"image_zoom":{"enable":true},"footnote":{"enable":true,"header":""},"math":{"enable":false,"specific":false,"engine":"mathjax"},"mermaid":{"enable":false,"specific":false,"options":{"theme":"default"}},"comments":{"enable":true,"type":"utterances"}},"utterances":{"repo":"zhpanvip/utterances-comment","issue_term":"pathname","label":"utterances","theme":"github-light","crossorigin":"anonymous"},"disqus":{"shortname":null,"disqusjs":false,"apikey":null},"gitalk":{"clientID":null,"clientSecret":null,"repo":null,"owner":null,"admin":["name"],"id":"location.pathname","language":"zh-CN","labels":["Gitalk"],"perPage":10,"pagerDirection":"last","distractionFreeMode":false,"createIssueManually":true},"valine":{"appid":"hXIROaIM5y9qnieojJRWP5hS","appkey":"y0f3w3aqd1MF7JL9ma4WECTy","placeholder":"说点什么","path":"window.location.pathname","avatar":"retro","meta":["nick","mail","link"],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"https://zhangpan.site"},"changyan":{"appid":"","appkey":""},"livere":{"uid":""},"archive":{"banner_img":"/img/bg_article.jpg","banner_img_height":60,"banner_mask_alpha":0.3,"subtitle":null},"category":{"banner_img":"/img/bg_default.png","banner_img_height":60,"banner_mask_alpha":0.3,"subtitle":null,"post_limit":10,"order_by":"-length"},"tag":{"banner_img":"/img/bg_label.jpg","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null,"tagcloud":{"min_font":15,"max_font":30,"unit":"px","start_color":"#BBBBEE","end_color":"#337ab7"}},"about":{"banner_img":"/img/bg_default.png","banner_img_height":60,"banner_mask_alpha":0.3,"subtitle":null,"avatar":"/img/avatar.png","name":"myname","introduce":"一句简短的介绍","icons":[{"class":"iconfont icon-github-fill","link":"https://github.com","tip":"GitHub"},{"class":"iconfont icon-douban-fill","link":"https://douban.com","tip":"豆瓣"},{"class":"iconfont icon-wechat-fill","qrcode":"/img/favicon.png"}]},"page404":{"banner_img":"/img/default.png","banner_img_height":85,"banner_mask_alpha":0.3,"subtitle":"Page not found"},"links":{"banner_img":"/img/default.png","banner_img_height":60,"banner_mask_alpha":0.3,"subtitle":null,"items":[{"title":"Fluid Docs","intro":"主题使用指南","link":"https://hexo.fluid-dev.com/docs/","image":"/img/favicon.png"},{"title":"Fluid Repo","intro":"主题 GitHub 仓库","link":"https://github.com/fluid-dev/hexo-theme-fluid","image":"/img/favicon.png"},{"title":"Fluid Example","intro":"主题操作示例","link":"https://hexo.fluid-dev.com/docs/example/","image":"/img/favicon.png"}]}}}},"excerpt":"","more":"<p>公司项目中有一个搜索功能，需求是要把搜索关键字高亮显示出来。本来觉得是一个很简单的问题，开发过程也比较顺利。但在测试阶段还是出了些Bug。而且有些问题还挺莫名其妙！<br>最初的想法，定义一个工具类，然后封装一个处理高亮的方法，需要高亮显示的直接调用这个工具类就行了。工具类封装了一个matcherSearchContent()的静态方法，然后用SpannableStringBuilder去处理关键字高亮显示，处理完成后方法返回处理好的SpannableStringBuilder。然后就可以直接给TextView去set处理好的SpannableStringBuilder。具体代码如下：</p>\n<pre><code class=\"hljs\">\n\npublic class TextHighLight &#123;\n\n    public static SpannableStringBuilder matcherSearchContent(String text,String[] keyword)&#123;\n        SpannableStringBuilder spannable=new SpannableStringBuilder(text);\n        CharacterStyle span=null;\n        for(int i=0;i&lt;keyword.length;i++)&#123;\n            Pattern pattern=Pattern.compile(keyword[i]);\n            Matcher matcher=pattern.matcher(text);\n            while(m.find())&#123;\n                span=new ForegroundColorSpan(Color.parseColor(&quot;#ff5656&quot;));\n                            spannable.setSpan(span,m.start(),matcher.end(), Spannable.SPAN_MARK_MARK);\n            &#125;\n        &#125;\n        return spannable;\n    &#125;\n&#125;</code></pre>\n<p>但是后来需求说字母是要忽略大小写的。这个该怎么实现啊，用逻辑实现还是很麻烦的。还好，可以用到正则表达式来完成加上一行代码 “(?i)” + keyword[i] 就可以了。修改后代码如下：</p>\n<pre><code class=\"hljs reasonml\">public <span class=\"hljs-keyword\">class</span> TextHighLight &#123;\n\n    public static SpannableStringBuilder matcher<span class=\"hljs-constructor\">SearchContent(String <span class=\"hljs-params\">text</span>,String[] <span class=\"hljs-params\">keyword</span>)</span>&#123;\n        SpannableStringBuilder spannable=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-constructor\">SpannableStringBuilder(<span class=\"hljs-params\">text</span>)</span>;\n        CharacterStyle span=null;\n        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-built_in\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;keyword.length;i++)&#123;\n            wordReg = <span class=\"hljs-string\">&quot;(?i)&quot;</span> + keyword<span class=\"hljs-literal\">[<span class=\"hljs-identifier\">i</span>]</span>;   <span class=\"hljs-comment\">//忽略字母大小写</span>\n            Pattern pattern = <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">Pattern</span>.</span></span>compile(wordReg);\n            Matcher matcher=pattern.matcher(text);\n            <span class=\"hljs-keyword\">while</span>(m.find<span class=\"hljs-literal\">()</span>)&#123;\n                span=<span class=\"hljs-keyword\">new</span> <span class=\"hljs-constructor\">ForegroundColorSpan(Color.<span class=\"hljs-params\">parseColor</span>(<span class=\"hljs-string\">&quot;#ff5656&quot;</span>)</span>);\n                spannable.set<span class=\"hljs-constructor\">Span(<span class=\"hljs-params\">span</span>,<span class=\"hljs-params\">m</span>.<span class=\"hljs-params\">start</span>()</span>,matcher.<span class=\"hljs-keyword\">end</span><span class=\"hljs-literal\">()</span>, Spannable.SPAN_MARK_MARK);\n            &#125;\n        &#125;\n        return spannable;\n    &#125;\n&#125;</code></pre>\n<p>嗯 这个解决的比较轻松。接下来测试阶段出现的问题。当输入特殊字符比如“*”时，程序出现异常闪退。调试发现原因是因为“*”号导致。在正则表达式中“*”是通配符，因此在匹配正则表达式时出现了异常。。解决办法也比较简单吗，就是判读如果包含“<em>”号的话就加上一个“&quot;转义一下就行了嘛！于是就有了下面的代码（因为测试的时候只有搜索“\\</em>“、”(“、”)”时出现闪退，因此只对这三个字符作了处理）</p>\n<pre><code class=\"hljs reasonml\">public <span class=\"hljs-keyword\">class</span> TextHighLight &#123;\n\n    <span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">     *   关键字高亮显示</span>\n<span class=\"hljs-comment\">     *   </span>\n<span class=\"hljs-comment\">     *   @param text 文字</span>\n<span class=\"hljs-comment\">     *      </span>\n<span class=\"hljs-comment\">     *   @param keyword1 文字中的关键字数组</span>\n<span class=\"hljs-comment\">     *              </span>\n<span class=\"hljs-comment\">     *   @return</span>\n<span class=\"hljs-comment\">     *  </span>\n<span class=\"hljs-comment\">     */</span>\n    public static SpannableStringBuilder matcher<span class=\"hljs-constructor\">SearchContent(String <span class=\"hljs-params\">text</span>, String[] <span class=\"hljs-params\">keyword</span>)</span> &#123;\n        SpannableStringBuilder spannable = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-constructor\">SpannableStringBuilder(<span class=\"hljs-params\">text</span>)</span>;\n\n        CharacterStyle span;\n        String wordReg;\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-built_in\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; keyword.length; i++) &#123;\n            String key = <span class=\"hljs-string\">&quot;&quot;</span>;\n            <span class=\"hljs-comment\">//  处理通配符问题</span>\n            <span class=\"hljs-keyword\">if</span> (keyword<span class=\"hljs-literal\">[<span class=\"hljs-identifier\">i</span>]</span>.contains(<span class=\"hljs-string\">&quot;*&quot;</span>)<span class=\"hljs-operator\"> || </span>keyword<span class=\"hljs-literal\">[<span class=\"hljs-identifier\">i</span>]</span>.contains(<span class=\"hljs-string\">&quot;(&quot;</span>)<span class=\"hljs-operator\"> || </span>keyword<span class=\"hljs-literal\">[<span class=\"hljs-identifier\">i</span>]</span>.contains(<span class=\"hljs-string\">&quot;)&quot;</span>)) &#123;\n                <span class=\"hljs-built_in\">char</span><span class=\"hljs-literal\">[]</span> chars = keyword<span class=\"hljs-literal\">[<span class=\"hljs-identifier\">i</span>]</span>.<span class=\"hljs-keyword\">to</span><span class=\"hljs-constructor\">CharArray()</span>;\n                <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-built_in\">int</span> k = <span class=\"hljs-number\">0</span>; k &lt; chars.length; k++) &#123;\n                    <span class=\"hljs-keyword\">if</span> (chars<span class=\"hljs-literal\">[<span class=\"hljs-identifier\">k</span>]</span><span class=\"hljs-operator\"> == </span><span class=\"hljs-character\">&#x27;*&#x27;</span><span class=\"hljs-operator\"> || </span>chars<span class=\"hljs-literal\">[<span class=\"hljs-identifier\">k</span>]</span><span class=\"hljs-operator\"> == </span><span class=\"hljs-character\">&#x27;(&#x27;</span><span class=\"hljs-operator\"> || </span>chars<span class=\"hljs-literal\">[<span class=\"hljs-identifier\">k</span>]</span><span class=\"hljs-operator\"> == </span><span class=\"hljs-character\">&#x27;)&#x27;</span>) &#123;\n                        key = key + <span class=\"hljs-string\">&quot;\\\\&quot;</span> + <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">String</span>.</span></span>value<span class=\"hljs-constructor\">Of(<span class=\"hljs-params\">chars</span>[<span class=\"hljs-params\">k</span>])</span>;\n                    &#125; <span class=\"hljs-keyword\">else</span> &#123;\n                        key = key + <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">String</span>.</span></span>value<span class=\"hljs-constructor\">Of(<span class=\"hljs-params\">chars</span>[<span class=\"hljs-params\">k</span>])</span>;\n                    &#125;\n                &#125;\n                keyword<span class=\"hljs-literal\">[<span class=\"hljs-identifier\">i</span>]</span> = key;\n            &#125;\n\n            wordReg = <span class=\"hljs-string\">&quot;(?i)&quot;</span> + keyword<span class=\"hljs-literal\">[<span class=\"hljs-identifier\">i</span>]</span>;   <span class=\"hljs-comment\">//忽略字母大小写</span>\n            Pattern pattern = <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">Pattern</span>.</span></span>compile(wordReg);\n            Matcher matcher = pattern.matcher(text);\n            <span class=\"hljs-keyword\">while</span> (matcher.find<span class=\"hljs-literal\">()</span>) &#123;\n                span = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-constructor\">ForegroundColorSpan(Color.<span class=\"hljs-params\">parseColor</span>(<span class=\"hljs-string\">&quot;#ff5656&quot;</span>)</span>);\n                spannable.set<span class=\"hljs-constructor\">Span(<span class=\"hljs-params\">span</span>, <span class=\"hljs-params\">matcher</span>.<span class=\"hljs-params\">start</span>()</span>, matcher.<span class=\"hljs-keyword\">end</span><span class=\"hljs-literal\">()</span>, Spannable.SPAN_MARK_MARK);\n            &#125;\n        &#125;\n\n        return spannable;\n    &#125;\n&#125;</code></pre>\n<p>上边代码先判断了字符串中是否包含“*”、”（”、”)”号，如果包含的话就遍历字符串然后在“*、”（”、”)”号前边加上“&quot;转义。嗯 这次一定没问题了。然后运行测试，跑起来看效果。嗯，果真正常了！以为这样就完了那就太天真了。当在一级搜索页面测试的时候一个很奇怪的问题出现了！！输入“*”搜索时发现“*”竟然没有高亮显示！效果图如下：</p>\n<table>\n<thead>\n<tr>\n<th>一级搜索页面</th>\n<th>二级搜索页面</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><img src=\"https://raw.githubusercontent.com/zhpanvip/Resource/master/image/0501.jfif\"></td>\n<td><img src=\"https://raw.githubusercontent.com/zhpanvip/Resource/master/image/0502.jfif\"></td>\n</tr>\n</tbody></table>\n<p>很诡异，有木有！两个页面调用的同一个Adapter，调用的同一个处理高亮的方法，为什么一个显示了高亮效果而一个却不正常显示呢！接下来经过漫长的调试、打log、对比两个页面。看下面的log日志信息：</p>\n<p><img src=\"https://raw.githubusercontent.com/zhpanvip/Resource/master/image/0503.jfif\"></p>\n<p>嗯？要匹配的字符串怎么变成了“\\ \\ *”了？正常来说应该匹配“\\<em>“ 的这样在正则表达式中”\\</em>“正好被转义成“<em>”的，难怪出现没有匹配高亮显示，问题就出在了上边的for循环添加”&quot;那段代码。看上边代码发现经过处理转义字符后将keyword[i]进行了一次重新赋值，而调用处理高亮的方法时传过来的参数关键字数组仅仅是一个引用，而实际的数组是在堆内存中存储的，因此重新赋值致使堆内存数据发生了改变！<br>既然找到了问题所在就应该分析引起问题的原因，为什么转义字符会被添加了两次？<br>调试的时候发现getView()方法确实是被重复执行了多次。这个原因就很奇怪了，按理说getView()方法的调用应该是跟ListView条目对应的。即有多少条数据，getView()就会被调用多少次。但是为什么在这个页面getView()会被重复执行，而在另一个页面getView()却只调用了一次？后来通过查阅资料发现是由于ListView的布局原因引起的。**</em>当ListView的layout_height属性设置为wrap_content的时候，getView()就会出现被重复调用的问题！，而layout_height设置位match_parent的时候getView()的调用则是正常的***，现在再会过头来看两个页面的布局，上边第一张图片是出现问题的布局，因为该页面有多个ListView，因此单个ListView的layout_height都被定义成了wrap_content从而出现了上述getView()被重复调用问题。而第二张图片中只有一个ListView,layout_height属性设置的是match_parent,因此这个页面getView()只被调用了一次，所以高亮显示也就正常了！</p>\n<p>问题原因找到了，也就好解决了。解决的方案有两个，第一就是更改ListView()的layout_height属性，给其设置为定值。第二就是在matcherSearchContent（）的方法里复制出来关键字的数组，然后再去匹配。这里采用的是第二种方案。修改后代码如下：</p>\n<pre><code class=\"hljs reasonml\">public <span class=\"hljs-keyword\">class</span> TextHighLight &#123;\n\n    <span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">     *   关键字高亮显示</span>\n<span class=\"hljs-comment\">     *   </span>\n<span class=\"hljs-comment\">     *   @param text 文字</span>\n<span class=\"hljs-comment\">     *      </span>\n<span class=\"hljs-comment\">     *   @param keyword1 文字中的关键字数组</span>\n<span class=\"hljs-comment\">     *              </span>\n<span class=\"hljs-comment\">     *   @return</span>\n<span class=\"hljs-comment\">     *  </span>\n<span class=\"hljs-comment\">     */</span>\n    public static SpannableStringBuilder matcher<span class=\"hljs-constructor\">SearchContent(String <span class=\"hljs-params\">text</span>, String[] <span class=\"hljs-params\">keyword1</span>)</span> &#123;\n        String<span class=\"hljs-literal\">[]</span> keyword = <span class=\"hljs-keyword\">new</span> String<span class=\"hljs-literal\">[<span class=\"hljs-identifier\">keyword1</span>.<span class=\"hljs-identifier\">length</span>]</span>;\n        <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">System</span>.</span></span>arraycopy(keyword1, <span class=\"hljs-number\">0</span>, keyword, <span class=\"hljs-number\">0</span>, keyword1.length);\n        SpannableStringBuilder spannable = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-constructor\">SpannableStringBuilder(<span class=\"hljs-params\">text</span>)</span>;\n\n        CharacterStyle span;\n        String wordReg;\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-built_in\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; keyword.length; i++) &#123;\n            String key = <span class=\"hljs-string\">&quot;&quot;</span>;\n            <span class=\"hljs-comment\">//  处理通配符问题</span>\n            <span class=\"hljs-keyword\">if</span> (keyword<span class=\"hljs-literal\">[<span class=\"hljs-identifier\">i</span>]</span>.contains(<span class=\"hljs-string\">&quot;*&quot;</span>)<span class=\"hljs-operator\"> || </span>keyword<span class=\"hljs-literal\">[<span class=\"hljs-identifier\">i</span>]</span>.contains(<span class=\"hljs-string\">&quot;(&quot;</span>)<span class=\"hljs-operator\"> || </span>keyword<span class=\"hljs-literal\">[<span class=\"hljs-identifier\">i</span>]</span>.contains(<span class=\"hljs-string\">&quot;)&quot;</span>)) &#123;\n                <span class=\"hljs-built_in\">char</span><span class=\"hljs-literal\">[]</span> chars = keyword<span class=\"hljs-literal\">[<span class=\"hljs-identifier\">i</span>]</span>.<span class=\"hljs-keyword\">to</span><span class=\"hljs-constructor\">CharArray()</span>;\n                <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-built_in\">int</span> k = <span class=\"hljs-number\">0</span>; k &lt; chars.length; k++) &#123;\n                    <span class=\"hljs-keyword\">if</span> (chars<span class=\"hljs-literal\">[<span class=\"hljs-identifier\">k</span>]</span><span class=\"hljs-operator\"> == </span><span class=\"hljs-character\">&#x27;*&#x27;</span><span class=\"hljs-operator\"> || </span>chars<span class=\"hljs-literal\">[<span class=\"hljs-identifier\">k</span>]</span><span class=\"hljs-operator\"> == </span><span class=\"hljs-character\">&#x27;(&#x27;</span><span class=\"hljs-operator\"> || </span>chars<span class=\"hljs-literal\">[<span class=\"hljs-identifier\">k</span>]</span><span class=\"hljs-operator\"> == </span><span class=\"hljs-character\">&#x27;)&#x27;</span>) &#123;\n                        key = key + <span class=\"hljs-string\">&quot;\\\\&quot;</span> + <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">String</span>.</span></span>value<span class=\"hljs-constructor\">Of(<span class=\"hljs-params\">chars</span>[<span class=\"hljs-params\">k</span>])</span>;\n                    &#125; <span class=\"hljs-keyword\">else</span> &#123;\n                        key = key + <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">String</span>.</span></span>value<span class=\"hljs-constructor\">Of(<span class=\"hljs-params\">chars</span>[<span class=\"hljs-params\">k</span>])</span>;\n                    &#125;\n                &#125;\n                keyword<span class=\"hljs-literal\">[<span class=\"hljs-identifier\">i</span>]</span> = key;\n            &#125;\n\n            wordReg = <span class=\"hljs-string\">&quot;(?i)&quot;</span> + keyword<span class=\"hljs-literal\">[<span class=\"hljs-identifier\">i</span>]</span>;   <span class=\"hljs-comment\">//忽略字母大小写</span>\n            Pattern pattern = <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">Pattern</span>.</span></span>compile(wordReg);\n            Matcher matcher = pattern.matcher(text);\n            <span class=\"hljs-keyword\">while</span> (matcher.find<span class=\"hljs-literal\">()</span>) &#123;\n                span = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-constructor\">ForegroundColorSpan(Color.<span class=\"hljs-params\">parseColor</span>(<span class=\"hljs-string\">&quot;#ff5656&quot;</span>)</span>);\n                spannable.set<span class=\"hljs-constructor\">Span(<span class=\"hljs-params\">span</span>, <span class=\"hljs-params\">matcher</span>.<span class=\"hljs-params\">start</span>()</span>, matcher.<span class=\"hljs-keyword\">end</span><span class=\"hljs-literal\">()</span>, Spannable.SPAN_MARK_MARK);\n            &#125;\n        &#125;\n\n        return spannable;\n    &#125;\n&#125;</code></pre>\n<p>到这里关于关键字高亮的所有问题总算是解决了。</p>\n"},{"title":"自定义View之颜色渐变折线图","date":"2017-03-16T06:14:16.000Z","_content":"\n\n首先看下要实现的效果图。\n![](https://raw.githubusercontent.com/zhpanvip/Resource/master/image/0601.gif)\n\n折线图的绘制主要有一下几个步骤。\n一、定义LineChartView类并继承View。\n二、添加自定义属性。以在value目录下创建attrs.xml文件,文件中我们可以定义一些用到的属性，比如折线颜色、字体大小等属性。文件内容如下：\n\n```\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<resources>\n  <declare-styleable name=\"LineChartView\">\n    <attr name=\"axesColor\" format=\"color\"/> <!--坐标轴颜色-->\n    <attr name=\"axesWidth\" format=\"dimension\"/><!--坐标轴宽度-->\n    <attr name=\"textColor\" format=\"color\"/> <!--字体颜色-->\n    <attr name=\"textSize\" format=\"dimension\"/> <!--字体大小-->\n    <attr name=\"lineColor\" format=\"color\"/> <!--折线颜色-->\n  </declare-styleable>\n</resources>\n```\n接下来在LineChartView的构造方法中解析自定义属性的值并做相应的处理。在构造方法里还初始化了渐变颜色、折线数据的List集合以及初始化画笔等操作代码如下：\n\n```\n public LineChartView(Context context, AttributeSet attrs, int defStyleAttr) {\n        super(context, attrs, defStyleAttr);\n        TypedArray typedArray = context.obtainStyledAttributes(attrs, R.styleable.LineChartView);\n        mAxesColor = typedArray.getColor(R.styleable.LineChartView_axesColor, Color.parseColor(\"#CCCCCC\"));\n        mAxesWidth = typedArray.getDimension(R.styleable.LineChartView_axesWidth, 1);\n        mTextColor = typedArray.getColor(R.styleable.LineChartView_textColor, Color.parseColor(\"#ABABAB\"));\n        mTextSize = typedArray.getDimension(R.styleable.LineChartView_textSize, 32);\n        mLineColor = typedArray.getColor(R.styleable.LineChartView_lineColor, Color.RED);\n        typedArray.recycle();\n\n        //  初始化渐变色\n        shadeColors = new int[]{\n                Color.argb(100, 255, 86, 86), Color.argb(15, 255, 86, 86),\n                Color.argb(0, 255, 86, 86)};\n      //  初始化折线数据\n        mValues = new ArrayList<>();\n        mMargin10 = DensityUtils.dp2px(context, 10);\n        init();\n    }\n```\n\n\n三、初始化画笔和路径。代码如下：\n\n```\nprivate void init() {\n        //  初始化坐标轴画笔\n        mPaintAxes = new Paint();\n        mPaintAxes.setColor(mAxesColor);\n        mPaintAxes.setStrokeWidth(mAxesWidth);\n\n        //  初始化文字画笔\n        mPaintText = new Paint();\n        mPaintText.setStyle(Paint.Style.FILL);\n        mPaintText.setAntiAlias(true); //抗锯齿\n        mPaintText.setTextSize(mTextSize);\n        mPaintText.setColor(mTextColor);\n        mPaintText.setTextAlign(Paint.Align.LEFT);\n\n        //  初始化折线画笔\n        mPaintLine = new Paint();\n        mPaintLine.setStyle(Paint.Style.STROKE);\n        mPaintLine.setAntiAlias(true);\n        mPaintLine.setStrokeWidth(mAxesWidth / 2);\n        mPaintLine.setColor(mLineColor);\n\n        //  初始化折线路径\n        mPath = new Path();\n        mPathShader = new Path();\n\n        //  阴影画笔\n        mPaintShader = new Paint();\n        mPaintShader.setAntiAlias(true);\n        mPaintShader.setStrokeWidth(2f);\n    }\n```\n四、重写onLayout方法。在onLayout方法中获取控件的宽高、初始化原点坐标以及设置控件的背景。代码如下：\n\n```\n @Override\n    protected void onLayout(boolean changed, int left, int top, int right, int bottom) {\n        super.onLayout(changed, left, top, right, bottom);\n        if (changed) {\n\n            mWidth = getWidth();\n            mHeight = getHeight();\n            timeWidth = (int) mPaintText.measureText(startTime);\n            //  初始化原点坐标\n            xOrigin = 0 + mMargin10;\n            yOrigin = (mHeight - mTextSize - mMargin10); \n        }\n    }\n```\n五、重写onDraw方法。在onDraw方法中完成折线图的绘制。代码如下：\n\n```\n @Override\n    protected void onDraw(Canvas canvas) {\n        super.onDraw(canvas);\n        //  Y轴坐标间距\n        yInterval = (max - min) / (yOrigin - mMargin10);\n\t\t//  X轴坐标间距\n        xInterval = (mWidth - xOrigin) / (mItems.size() - 1);\n        //  画坐标轴\n        drawAxes(canvas);\n        //  画文字\n        drawText(canvas);\n        //  画折线\n        drawLine(canvas);\n\t\t//  绘制路径\n        drawPath(canvas);\n    }\n```\n折线图的绘制可以分三部分：1.绘制坐标轴。2.绘制View上的文字。3.绘制折线。\n\n1.坐标轴绘制的是第一象限，即左下角的点为原点。绘制坐标轴代码如下：\n\n```\n//  画坐标轴\n    private void drawAxes(Canvas canvas) {\n        //  绘制X轴\n        canvas.drawLine(xOrigin, yOrigin, mWidth - mMargin10, yOrigin, mPaintAxes);\n        //  绘制X中轴线\n        canvas.drawLine(xOrigin, yOrigin / 2, mWidth - mMargin10, yOrigin / 2, mPaintAxes);\n        //  绘制X上边线\n        canvas.drawLine(xOrigin, mMargin10, mWidth - mMargin10, mMargin10, mPaintAxes);\n        //  绘制画Y轴\n        canvas.drawLine(xOrigin, yOrigin, xOrigin, mMargin10, mPaintAxes);\n        //  绘制Y右边线\n        canvas.drawLine(mWidth - mMargin10, mMargin10, mWidth - mMargin10, yOrigin, mPaintAxes);\n    }\n```\n2.绘制文字，代码如下：\n\n```\nprivate void drawText(Canvas canvas) {\n        //  绘制最大值\n        canvas.drawText(String.format(\"%.2f\", max * 100 / 100.0) + \"%\", xOrigin + 6, 2 * mMargin10, mPaintText);\n        //  绘制最小值\n        canvas.drawText(String.format(\"%.2f\", min * 100 / 100.0) + \"%\", xOrigin + 6, yOrigin - 6, mPaintText);\n        //  绘制中间值\n        canvas.drawText((String.format(\"%.2f\", (min + max) * 100 / 200.0) + \"%\"), xOrigin + 6, (yOrigin + mMargin10) / 2, mPaintText);\n\n        //  绘制开始日期\n        canvas.drawText(startTime, xOrigin, mHeight - mMargin10, mPaintText);\n        //  绘制结束日期\n        canvas.drawText(endTime, mWidth - timeWidth - mMargin10, mHeight - mMargin10, mPaintText);\n    }\n```\n3.绘制折线及渐变填充\n\n```\nprivate void drawLine(Canvas canvas) {\n        //  画坐标点\n        for (int i = 0; i < mValues.size(); i++) {\n            float x = i * xInterval + xOrigin + mAxesWidth;\n            if (i == 0) {\n                mPathShader.moveTo(x, yOrigin - (mValues.get(i) - min) / yInterval);\n                mPath.moveTo(x, yOrigin - (mValues.get(i) - min) / yInterval);\n            } else {\n                mPath.lineTo(x - mMargin10 - mAxesWidth, yOrigin - (mValues.get(i) - min) / yInterval);\n                mPathShader.lineTo(x - mMargin10 - mAxesWidth, yOrigin - (mValues.get(i) - min) / yInterval);\n                if (i == mValues.size() - 1) {\n                    mPathShader.lineTo(x - mMargin10 - mAxesWidth, yOrigin);\n                    mPathShader.lineTo(xOrigin, yOrigin);\n                    mPathShader.close();\n                }\n            }\n        }\n        if (null == mShadeColors) {\n            mPaintShader.setColor(Color.argb(0, 0, 0, 0));\n        } else {\n            Shader mShader = new LinearGradient(0, 0, 0, getHeight(), mShadeColors, null, Shader.TileMode.CLAMP);\n            mPaintShader.setShader(mShader);\n        }\n        canvas.drawPath(mPathShader, mPaintShader);\n    }\n```\n六、折线图添加动画。\n\n1.折线图的动画使用属性动画，首先需要计算动画的进度，因此需要先添加setPercentage方法，当动画开始时，我们可以在该方法中拿到percentage的值\n\n```\n    /**\n     * Animate this property. It is the percentage of the path that is drawn.\n     *\n     * @param percentage float the percentage of the path.\n     */\n    public void setPercentage(float percentage) {\n        if (percentage < 0.0f || percentage > 1.0f) {\n            throw new IllegalArgumentException(\n                    \"setPercentage not between 0.0f and 1.0f\");\n        }\n        mProgress = percentage;\n        invalidate();\n    }\n```\n2.通过Path来绘制折线路径，代码如下：\n\n```\n private void drawPath(Canvas canvas) {\n\n        PathMeasure measure = new PathMeasure(mPath, false);\n        float pathLength = measure.getLength();\n        PathEffect effect = new DashPathEffect(new float[]{pathLength,\n                pathLength}, pathLength - pathLength * mProgress);\n        mPaintLine.setPathEffect(effect);\n        canvas.drawPath(mPath, mPaintLine);\n    }\n```\n3.通过ObjectAnimator 开启动画，注意ObjectAnimator.ofFloat(lineChartView, \"percentage\", 0.0f, 1.0f)中第二个参数必须为“percentage”，对应前那边的setPercentage方法，属性动画会根据“percentage”参数通过反射调用setPercentage：\n```\n  /**\n     * @param lineChartView\n     * @param duration      动画持续时间\n     */\n    public void startAnim(LineChartView lineChartView, long duration) {\n        ObjectAnimator anim = ObjectAnimator.ofFloat(lineChartView, \"percentage\", 0.0f, 1.0f);\n        anim.setDuration(duration);\n        anim.setInterpolator(new LinearInterpolator());\n        anim.start();\n    }\n```\n\n至此，折线图的绘制已经全部完成。最后还可以添加get() set()方法，暴露出属性接口，以供外部调用。代码就不再贴出来了。\n\n七、使用LineChartView\n1.在布局文件中添加LineChartView,可设置折线颜色、字体颜色、等属性，如下：\n\n```\n<com.example.zhpan.linechartview.LineChartView\n        android:id=\"@+id/lcv\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"200dp\"\n        android:layout_marginBottom=\"20dp\"\n        android:layout_marginLeft=\"15dp\"\n        android:layout_marginRight=\"15dp\"\n        android:layout_marginTop=\"15dp\"\n        app:lineColor=\"#FF0000\"\n        app:textColor=\"#ABABAB\"\n        app:textSize=\"12dp\"/>\n```\n\n2.在Activity中为LineChartView设置数据，也可以通过代码为其设置属性。\n\n```\nprivate void initData() {\n        //  初始化折线数据\n        List<Float> listValues = new ArrayList<>();\n        Random random = new Random();\n        float startValue = random.nextFloat() * 10;\n        listValues.add(startValue);\n        for (int i = 0; i < 30; i++) {\n            startValue += random.nextFloat() * 10 - 5;\n            listValues.add(startValue);\n        }\n        List<Integer> listShadeColors = new ArrayList<>();\n        listShadeColors.add(Color.argb(100, 255, 86, 86));\n        listShadeColors.add(Color.argb(15, 255, 86, 86));\n        listShadeColors.add(Color.argb(0, 255, 86, 86));\n        //  设置折线数据\n        mLineChartView.setValues(listValues);\n        //  设置渐变颜色\n        mLineChartView.setShadeColors(listShadeColors);\n        //  设置动画插值器\n        mLineChartView.setInterpolator(new DecelerateInterpolator());\n        mLineChartView.setAxisMinValue(-30);\n        mLineChartView.setAxisMaxValue(30);\n        mLineChartView.setStartTime(\"2017-03-15\");\n        mLineChartView.setEndTime(\"2017-04-14\");\n        //  开启动画\n        mLineChartView.startAnim(2500);\n    }\n```\n[源码下载](https://github.com/zhpanvip/CustomView)\n\n","source":"_posts/6.自定义View之颜色渐变折线图.md","raw":"---\ntitle: 自定义View之颜色渐变折线图\ndate: 2017-03-16 14:14:16\ntags: 自定义View\n---\n\n\n首先看下要实现的效果图。\n![](https://raw.githubusercontent.com/zhpanvip/Resource/master/image/0601.gif)\n\n折线图的绘制主要有一下几个步骤。\n一、定义LineChartView类并继承View。\n二、添加自定义属性。以在value目录下创建attrs.xml文件,文件中我们可以定义一些用到的属性，比如折线颜色、字体大小等属性。文件内容如下：\n\n```\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<resources>\n  <declare-styleable name=\"LineChartView\">\n    <attr name=\"axesColor\" format=\"color\"/> <!--坐标轴颜色-->\n    <attr name=\"axesWidth\" format=\"dimension\"/><!--坐标轴宽度-->\n    <attr name=\"textColor\" format=\"color\"/> <!--字体颜色-->\n    <attr name=\"textSize\" format=\"dimension\"/> <!--字体大小-->\n    <attr name=\"lineColor\" format=\"color\"/> <!--折线颜色-->\n  </declare-styleable>\n</resources>\n```\n接下来在LineChartView的构造方法中解析自定义属性的值并做相应的处理。在构造方法里还初始化了渐变颜色、折线数据的List集合以及初始化画笔等操作代码如下：\n\n```\n public LineChartView(Context context, AttributeSet attrs, int defStyleAttr) {\n        super(context, attrs, defStyleAttr);\n        TypedArray typedArray = context.obtainStyledAttributes(attrs, R.styleable.LineChartView);\n        mAxesColor = typedArray.getColor(R.styleable.LineChartView_axesColor, Color.parseColor(\"#CCCCCC\"));\n        mAxesWidth = typedArray.getDimension(R.styleable.LineChartView_axesWidth, 1);\n        mTextColor = typedArray.getColor(R.styleable.LineChartView_textColor, Color.parseColor(\"#ABABAB\"));\n        mTextSize = typedArray.getDimension(R.styleable.LineChartView_textSize, 32);\n        mLineColor = typedArray.getColor(R.styleable.LineChartView_lineColor, Color.RED);\n        typedArray.recycle();\n\n        //  初始化渐变色\n        shadeColors = new int[]{\n                Color.argb(100, 255, 86, 86), Color.argb(15, 255, 86, 86),\n                Color.argb(0, 255, 86, 86)};\n      //  初始化折线数据\n        mValues = new ArrayList<>();\n        mMargin10 = DensityUtils.dp2px(context, 10);\n        init();\n    }\n```\n\n\n三、初始化画笔和路径。代码如下：\n\n```\nprivate void init() {\n        //  初始化坐标轴画笔\n        mPaintAxes = new Paint();\n        mPaintAxes.setColor(mAxesColor);\n        mPaintAxes.setStrokeWidth(mAxesWidth);\n\n        //  初始化文字画笔\n        mPaintText = new Paint();\n        mPaintText.setStyle(Paint.Style.FILL);\n        mPaintText.setAntiAlias(true); //抗锯齿\n        mPaintText.setTextSize(mTextSize);\n        mPaintText.setColor(mTextColor);\n        mPaintText.setTextAlign(Paint.Align.LEFT);\n\n        //  初始化折线画笔\n        mPaintLine = new Paint();\n        mPaintLine.setStyle(Paint.Style.STROKE);\n        mPaintLine.setAntiAlias(true);\n        mPaintLine.setStrokeWidth(mAxesWidth / 2);\n        mPaintLine.setColor(mLineColor);\n\n        //  初始化折线路径\n        mPath = new Path();\n        mPathShader = new Path();\n\n        //  阴影画笔\n        mPaintShader = new Paint();\n        mPaintShader.setAntiAlias(true);\n        mPaintShader.setStrokeWidth(2f);\n    }\n```\n四、重写onLayout方法。在onLayout方法中获取控件的宽高、初始化原点坐标以及设置控件的背景。代码如下：\n\n```\n @Override\n    protected void onLayout(boolean changed, int left, int top, int right, int bottom) {\n        super.onLayout(changed, left, top, right, bottom);\n        if (changed) {\n\n            mWidth = getWidth();\n            mHeight = getHeight();\n            timeWidth = (int) mPaintText.measureText(startTime);\n            //  初始化原点坐标\n            xOrigin = 0 + mMargin10;\n            yOrigin = (mHeight - mTextSize - mMargin10); \n        }\n    }\n```\n五、重写onDraw方法。在onDraw方法中完成折线图的绘制。代码如下：\n\n```\n @Override\n    protected void onDraw(Canvas canvas) {\n        super.onDraw(canvas);\n        //  Y轴坐标间距\n        yInterval = (max - min) / (yOrigin - mMargin10);\n\t\t//  X轴坐标间距\n        xInterval = (mWidth - xOrigin) / (mItems.size() - 1);\n        //  画坐标轴\n        drawAxes(canvas);\n        //  画文字\n        drawText(canvas);\n        //  画折线\n        drawLine(canvas);\n\t\t//  绘制路径\n        drawPath(canvas);\n    }\n```\n折线图的绘制可以分三部分：1.绘制坐标轴。2.绘制View上的文字。3.绘制折线。\n\n1.坐标轴绘制的是第一象限，即左下角的点为原点。绘制坐标轴代码如下：\n\n```\n//  画坐标轴\n    private void drawAxes(Canvas canvas) {\n        //  绘制X轴\n        canvas.drawLine(xOrigin, yOrigin, mWidth - mMargin10, yOrigin, mPaintAxes);\n        //  绘制X中轴线\n        canvas.drawLine(xOrigin, yOrigin / 2, mWidth - mMargin10, yOrigin / 2, mPaintAxes);\n        //  绘制X上边线\n        canvas.drawLine(xOrigin, mMargin10, mWidth - mMargin10, mMargin10, mPaintAxes);\n        //  绘制画Y轴\n        canvas.drawLine(xOrigin, yOrigin, xOrigin, mMargin10, mPaintAxes);\n        //  绘制Y右边线\n        canvas.drawLine(mWidth - mMargin10, mMargin10, mWidth - mMargin10, yOrigin, mPaintAxes);\n    }\n```\n2.绘制文字，代码如下：\n\n```\nprivate void drawText(Canvas canvas) {\n        //  绘制最大值\n        canvas.drawText(String.format(\"%.2f\", max * 100 / 100.0) + \"%\", xOrigin + 6, 2 * mMargin10, mPaintText);\n        //  绘制最小值\n        canvas.drawText(String.format(\"%.2f\", min * 100 / 100.0) + \"%\", xOrigin + 6, yOrigin - 6, mPaintText);\n        //  绘制中间值\n        canvas.drawText((String.format(\"%.2f\", (min + max) * 100 / 200.0) + \"%\"), xOrigin + 6, (yOrigin + mMargin10) / 2, mPaintText);\n\n        //  绘制开始日期\n        canvas.drawText(startTime, xOrigin, mHeight - mMargin10, mPaintText);\n        //  绘制结束日期\n        canvas.drawText(endTime, mWidth - timeWidth - mMargin10, mHeight - mMargin10, mPaintText);\n    }\n```\n3.绘制折线及渐变填充\n\n```\nprivate void drawLine(Canvas canvas) {\n        //  画坐标点\n        for (int i = 0; i < mValues.size(); i++) {\n            float x = i * xInterval + xOrigin + mAxesWidth;\n            if (i == 0) {\n                mPathShader.moveTo(x, yOrigin - (mValues.get(i) - min) / yInterval);\n                mPath.moveTo(x, yOrigin - (mValues.get(i) - min) / yInterval);\n            } else {\n                mPath.lineTo(x - mMargin10 - mAxesWidth, yOrigin - (mValues.get(i) - min) / yInterval);\n                mPathShader.lineTo(x - mMargin10 - mAxesWidth, yOrigin - (mValues.get(i) - min) / yInterval);\n                if (i == mValues.size() - 1) {\n                    mPathShader.lineTo(x - mMargin10 - mAxesWidth, yOrigin);\n                    mPathShader.lineTo(xOrigin, yOrigin);\n                    mPathShader.close();\n                }\n            }\n        }\n        if (null == mShadeColors) {\n            mPaintShader.setColor(Color.argb(0, 0, 0, 0));\n        } else {\n            Shader mShader = new LinearGradient(0, 0, 0, getHeight(), mShadeColors, null, Shader.TileMode.CLAMP);\n            mPaintShader.setShader(mShader);\n        }\n        canvas.drawPath(mPathShader, mPaintShader);\n    }\n```\n六、折线图添加动画。\n\n1.折线图的动画使用属性动画，首先需要计算动画的进度，因此需要先添加setPercentage方法，当动画开始时，我们可以在该方法中拿到percentage的值\n\n```\n    /**\n     * Animate this property. It is the percentage of the path that is drawn.\n     *\n     * @param percentage float the percentage of the path.\n     */\n    public void setPercentage(float percentage) {\n        if (percentage < 0.0f || percentage > 1.0f) {\n            throw new IllegalArgumentException(\n                    \"setPercentage not between 0.0f and 1.0f\");\n        }\n        mProgress = percentage;\n        invalidate();\n    }\n```\n2.通过Path来绘制折线路径，代码如下：\n\n```\n private void drawPath(Canvas canvas) {\n\n        PathMeasure measure = new PathMeasure(mPath, false);\n        float pathLength = measure.getLength();\n        PathEffect effect = new DashPathEffect(new float[]{pathLength,\n                pathLength}, pathLength - pathLength * mProgress);\n        mPaintLine.setPathEffect(effect);\n        canvas.drawPath(mPath, mPaintLine);\n    }\n```\n3.通过ObjectAnimator 开启动画，注意ObjectAnimator.ofFloat(lineChartView, \"percentage\", 0.0f, 1.0f)中第二个参数必须为“percentage”，对应前那边的setPercentage方法，属性动画会根据“percentage”参数通过反射调用setPercentage：\n```\n  /**\n     * @param lineChartView\n     * @param duration      动画持续时间\n     */\n    public void startAnim(LineChartView lineChartView, long duration) {\n        ObjectAnimator anim = ObjectAnimator.ofFloat(lineChartView, \"percentage\", 0.0f, 1.0f);\n        anim.setDuration(duration);\n        anim.setInterpolator(new LinearInterpolator());\n        anim.start();\n    }\n```\n\n至此，折线图的绘制已经全部完成。最后还可以添加get() set()方法，暴露出属性接口，以供外部调用。代码就不再贴出来了。\n\n七、使用LineChartView\n1.在布局文件中添加LineChartView,可设置折线颜色、字体颜色、等属性，如下：\n\n```\n<com.example.zhpan.linechartview.LineChartView\n        android:id=\"@+id/lcv\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"200dp\"\n        android:layout_marginBottom=\"20dp\"\n        android:layout_marginLeft=\"15dp\"\n        android:layout_marginRight=\"15dp\"\n        android:layout_marginTop=\"15dp\"\n        app:lineColor=\"#FF0000\"\n        app:textColor=\"#ABABAB\"\n        app:textSize=\"12dp\"/>\n```\n\n2.在Activity中为LineChartView设置数据，也可以通过代码为其设置属性。\n\n```\nprivate void initData() {\n        //  初始化折线数据\n        List<Float> listValues = new ArrayList<>();\n        Random random = new Random();\n        float startValue = random.nextFloat() * 10;\n        listValues.add(startValue);\n        for (int i = 0; i < 30; i++) {\n            startValue += random.nextFloat() * 10 - 5;\n            listValues.add(startValue);\n        }\n        List<Integer> listShadeColors = new ArrayList<>();\n        listShadeColors.add(Color.argb(100, 255, 86, 86));\n        listShadeColors.add(Color.argb(15, 255, 86, 86));\n        listShadeColors.add(Color.argb(0, 255, 86, 86));\n        //  设置折线数据\n        mLineChartView.setValues(listValues);\n        //  设置渐变颜色\n        mLineChartView.setShadeColors(listShadeColors);\n        //  设置动画插值器\n        mLineChartView.setInterpolator(new DecelerateInterpolator());\n        mLineChartView.setAxisMinValue(-30);\n        mLineChartView.setAxisMaxValue(30);\n        mLineChartView.setStartTime(\"2017-03-15\");\n        mLineChartView.setEndTime(\"2017-04-14\");\n        //  开启动画\n        mLineChartView.startAnim(2500);\n    }\n```\n[源码下载](https://github.com/zhpanvip/CustomView)\n\n","slug":"6.自定义View之颜色渐变折线图","published":1,"updated":"2020-08-29T18:02:28.536Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckegm5ns1000jdwoz28kc34wm","content":"<p>首先看下要实现的效果图。<br><img src=\"https://raw.githubusercontent.com/zhpanvip/Resource/master/image/0601.gif\"></p>\n<p>折线图的绘制主要有一下几个步骤。<br>一、定义LineChartView类并继承View。<br>二、添加自定义属性。以在value目录下创建attrs.xml文件,文件中我们可以定义一些用到的属性，比如折线颜色、字体大小等属性。文件内容如下：</p>\n<pre><code class=\"hljs xml\"><span class=\"hljs-meta\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">resources</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">declare-styleable</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;LineChartView&quot;</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">attr</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;axesColor&quot;</span> <span class=\"hljs-attr\">format</span>=<span class=\"hljs-string\">&quot;color&quot;</span>/&gt;</span> <span class=\"hljs-comment\">&lt;!--坐标轴颜色--&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">attr</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;axesWidth&quot;</span> <span class=\"hljs-attr\">format</span>=<span class=\"hljs-string\">&quot;dimension&quot;</span>/&gt;</span><span class=\"hljs-comment\">&lt;!--坐标轴宽度--&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">attr</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;textColor&quot;</span> <span class=\"hljs-attr\">format</span>=<span class=\"hljs-string\">&quot;color&quot;</span>/&gt;</span> <span class=\"hljs-comment\">&lt;!--字体颜色--&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">attr</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;textSize&quot;</span> <span class=\"hljs-attr\">format</span>=<span class=\"hljs-string\">&quot;dimension&quot;</span>/&gt;</span> <span class=\"hljs-comment\">&lt;!--字体大小--&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">attr</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;lineColor&quot;</span> <span class=\"hljs-attr\">format</span>=<span class=\"hljs-string\">&quot;color&quot;</span>/&gt;</span> <span class=\"hljs-comment\">&lt;!--折线颜色--&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">declare-styleable</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">resources</span>&gt;</span></code></pre>\n<p>接下来在LineChartView的构造方法中解析自定义属性的值并做相应的处理。在构造方法里还初始化了渐变颜色、折线数据的List集合以及初始化画笔等操作代码如下：</p>\n<pre><code class=\"hljs reasonml\">public <span class=\"hljs-constructor\">LineChartView(Context <span class=\"hljs-params\">context</span>, AttributeSet <span class=\"hljs-params\">attrs</span>, <span class=\"hljs-params\">int</span> <span class=\"hljs-params\">defStyleAttr</span>)</span> &#123;\n       super(context, attrs, defStyleAttr);\n       TypedArray typedArray = context.obtain<span class=\"hljs-constructor\">StyledAttributes(<span class=\"hljs-params\">attrs</span>, R.<span class=\"hljs-params\">styleable</span>.LineChartView)</span>;\n       mAxesColor = typedArray.get<span class=\"hljs-constructor\">Color(R.<span class=\"hljs-params\">styleable</span>.LineChartView_axesColor, Color.<span class=\"hljs-params\">parseColor</span>(<span class=\"hljs-string\">&quot;#CCCCCC&quot;</span>)</span>);\n       mAxesWidth = typedArray.get<span class=\"hljs-constructor\">Dimension(R.<span class=\"hljs-params\">styleable</span>.LineChartView_axesWidth, 1)</span>;\n       mTextColor = typedArray.get<span class=\"hljs-constructor\">Color(R.<span class=\"hljs-params\">styleable</span>.LineChartView_textColor, Color.<span class=\"hljs-params\">parseColor</span>(<span class=\"hljs-string\">&quot;#ABABAB&quot;</span>)</span>);\n       mTextSize = typedArray.get<span class=\"hljs-constructor\">Dimension(R.<span class=\"hljs-params\">styleable</span>.LineChartView_textSize, 32)</span>;\n       mLineColor = typedArray.get<span class=\"hljs-constructor\">Color(R.<span class=\"hljs-params\">styleable</span>.LineChartView_lineColor, Color.RED)</span>;\n       typedArray.recycle<span class=\"hljs-literal\">()</span>;\n\n       <span class=\"hljs-comment\">//  初始化渐变色</span>\n       shadeColors = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">int</span><span class=\"hljs-literal\">[]</span>&#123;\n               <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">Color</span>.</span></span>argb(<span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">255</span>, <span class=\"hljs-number\">86</span>, <span class=\"hljs-number\">86</span>), <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">Color</span>.</span></span>argb(<span class=\"hljs-number\">15</span>, <span class=\"hljs-number\">255</span>, <span class=\"hljs-number\">86</span>, <span class=\"hljs-number\">86</span>),\n               <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">Color</span>.</span></span>argb(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">255</span>, <span class=\"hljs-number\">86</span>, <span class=\"hljs-number\">86</span>)&#125;;\n     <span class=\"hljs-comment\">//  初始化折线数据</span>\n       mValues = <span class=\"hljs-keyword\">new</span> ArrayList&lt;&gt;<span class=\"hljs-literal\">()</span>;\n       mMargin10 = <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">DensityUtils</span>.</span></span>dp2px(context, <span class=\"hljs-number\">10</span>);\n       init<span class=\"hljs-literal\">()</span>;\n   &#125;</code></pre>\n\n\n<p>三、初始化画笔和路径。代码如下：</p>\n<pre><code class=\"hljs reasonml\"><span class=\"hljs-keyword\">private</span> void init<span class=\"hljs-literal\">()</span> &#123;\n        <span class=\"hljs-comment\">//  初始化坐标轴画笔</span>\n        mPaintAxes = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-constructor\">Paint()</span>;\n        mPaintAxes.set<span class=\"hljs-constructor\">Color(<span class=\"hljs-params\">mAxesColor</span>)</span>;\n        mPaintAxes.set<span class=\"hljs-constructor\">StrokeWidth(<span class=\"hljs-params\">mAxesWidth</span>)</span>;\n\n        <span class=\"hljs-comment\">//  初始化文字画笔</span>\n        mPaintText = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-constructor\">Paint()</span>;\n        mPaintText.set<span class=\"hljs-constructor\">Style(Paint.Style.FILL)</span>;\n        mPaintText.set<span class=\"hljs-constructor\">AntiAlias(<span class=\"hljs-params\">true</span>)</span>; <span class=\"hljs-comment\">//抗锯齿</span>\n        mPaintText.set<span class=\"hljs-constructor\">TextSize(<span class=\"hljs-params\">mTextSize</span>)</span>;\n        mPaintText.set<span class=\"hljs-constructor\">Color(<span class=\"hljs-params\">mTextColor</span>)</span>;\n        mPaintText.set<span class=\"hljs-constructor\">TextAlign(Paint.Align.LEFT)</span>;\n\n        <span class=\"hljs-comment\">//  初始化折线画笔</span>\n        mPaintLine = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-constructor\">Paint()</span>;\n        mPaintLine.set<span class=\"hljs-constructor\">Style(Paint.Style.STROKE)</span>;\n        mPaintLine.set<span class=\"hljs-constructor\">AntiAlias(<span class=\"hljs-params\">true</span>)</span>;\n        mPaintLine.set<span class=\"hljs-constructor\">StrokeWidth(<span class=\"hljs-params\">mAxesWidth</span> <span class=\"hljs-operator\">/</span> 2)</span>;\n        mPaintLine.set<span class=\"hljs-constructor\">Color(<span class=\"hljs-params\">mLineColor</span>)</span>;\n\n        <span class=\"hljs-comment\">//  初始化折线路径</span>\n        mPath = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-constructor\">Path()</span>;\n        mPathShader = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-constructor\">Path()</span>;\n\n        <span class=\"hljs-comment\">//  阴影画笔</span>\n        mPaintShader = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-constructor\">Paint()</span>;\n        mPaintShader.set<span class=\"hljs-constructor\">AntiAlias(<span class=\"hljs-params\">true</span>)</span>;\n        mPaintShader.set<span class=\"hljs-constructor\">StrokeWidth(2f)</span>;\n    &#125;</code></pre>\n<p>四、重写onLayout方法。在onLayout方法中获取控件的宽高、初始化原点坐标以及设置控件的背景。代码如下：</p>\n<pre><code class=\"hljs reasonml\">@Override\n   protected void on<span class=\"hljs-constructor\">Layout(<span class=\"hljs-params\">boolean</span> <span class=\"hljs-params\">changed</span>, <span class=\"hljs-params\">int</span> <span class=\"hljs-params\">left</span>, <span class=\"hljs-params\">int</span> <span class=\"hljs-params\">top</span>, <span class=\"hljs-params\">int</span> <span class=\"hljs-params\">right</span>, <span class=\"hljs-params\">int</span> <span class=\"hljs-params\">bottom</span>)</span> &#123;\n       super.on<span class=\"hljs-constructor\">Layout(<span class=\"hljs-params\">changed</span>, <span class=\"hljs-params\">left</span>, <span class=\"hljs-params\">top</span>, <span class=\"hljs-params\">right</span>, <span class=\"hljs-params\">bottom</span>)</span>;\n       <span class=\"hljs-keyword\">if</span> (changed) &#123;\n\n           mWidth = get<span class=\"hljs-constructor\">Width()</span>;\n           mHeight = get<span class=\"hljs-constructor\">Height()</span>;\n           timeWidth = (<span class=\"hljs-built_in\">int</span>) mPaintText.measure<span class=\"hljs-constructor\">Text(<span class=\"hljs-params\">startTime</span>)</span>;\n           <span class=\"hljs-comment\">//  初始化原点坐标</span>\n           xOrigin = <span class=\"hljs-number\">0</span> + mMargin10;\n           yOrigin = (mHeight - mTextSize - mMargin10); \n       &#125;\n   &#125;</code></pre>\n<p>五、重写onDraw方法。在onDraw方法中完成折线图的绘制。代码如下：</p>\n<pre><code class=\"hljs reasonml\">@Override\n   protected void on<span class=\"hljs-constructor\">Draw(Canvas <span class=\"hljs-params\">canvas</span>)</span> &#123;\n       super.on<span class=\"hljs-constructor\">Draw(<span class=\"hljs-params\">canvas</span>)</span>;\n       <span class=\"hljs-comment\">//  Y轴坐标间距</span>\n       yInterval = (max - min)<span class=\"hljs-operator\"> / </span>(yOrigin - mMargin10);\n\t<span class=\"hljs-comment\">//  X轴坐标间距</span>\n       xInterval = (mWidth - xOrigin)<span class=\"hljs-operator\"> / </span>(mItems.size<span class=\"hljs-literal\">()</span> - <span class=\"hljs-number\">1</span>);\n       <span class=\"hljs-comment\">//  画坐标轴</span>\n       draw<span class=\"hljs-constructor\">Axes(<span class=\"hljs-params\">canvas</span>)</span>;\n       <span class=\"hljs-comment\">//  画文字</span>\n       draw<span class=\"hljs-constructor\">Text(<span class=\"hljs-params\">canvas</span>)</span>;\n       <span class=\"hljs-comment\">//  画折线</span>\n       draw<span class=\"hljs-constructor\">Line(<span class=\"hljs-params\">canvas</span>)</span>;\n\t<span class=\"hljs-comment\">//  绘制路径</span>\n       draw<span class=\"hljs-constructor\">Path(<span class=\"hljs-params\">canvas</span>)</span>;\n   &#125;</code></pre>\n<p>折线图的绘制可以分三部分：1.绘制坐标轴。2.绘制View上的文字。3.绘制折线。</p>\n<p>1.坐标轴绘制的是第一象限，即左下角的点为原点。绘制坐标轴代码如下：</p>\n<pre><code class=\"hljs reasonml\"><span class=\"hljs-comment\">//  画坐标轴</span>\n    <span class=\"hljs-keyword\">private</span> void draw<span class=\"hljs-constructor\">Axes(Canvas <span class=\"hljs-params\">canvas</span>)</span> &#123;\n        <span class=\"hljs-comment\">//  绘制X轴</span>\n        canvas.draw<span class=\"hljs-constructor\">Line(<span class=\"hljs-params\">xOrigin</span>, <span class=\"hljs-params\">yOrigin</span>, <span class=\"hljs-params\">mWidth</span> - <span class=\"hljs-params\">mMargin10</span>, <span class=\"hljs-params\">yOrigin</span>, <span class=\"hljs-params\">mPaintAxes</span>)</span>;\n        <span class=\"hljs-comment\">//  绘制X中轴线</span>\n        canvas.draw<span class=\"hljs-constructor\">Line(<span class=\"hljs-params\">xOrigin</span>, <span class=\"hljs-params\">yOrigin</span> <span class=\"hljs-operator\">/</span> 2, <span class=\"hljs-params\">mWidth</span> - <span class=\"hljs-params\">mMargin10</span>, <span class=\"hljs-params\">yOrigin</span> <span class=\"hljs-operator\">/</span> 2, <span class=\"hljs-params\">mPaintAxes</span>)</span>;\n        <span class=\"hljs-comment\">//  绘制X上边线</span>\n        canvas.draw<span class=\"hljs-constructor\">Line(<span class=\"hljs-params\">xOrigin</span>, <span class=\"hljs-params\">mMargin10</span>, <span class=\"hljs-params\">mWidth</span> - <span class=\"hljs-params\">mMargin10</span>, <span class=\"hljs-params\">mMargin10</span>, <span class=\"hljs-params\">mPaintAxes</span>)</span>;\n        <span class=\"hljs-comment\">//  绘制画Y轴</span>\n        canvas.draw<span class=\"hljs-constructor\">Line(<span class=\"hljs-params\">xOrigin</span>, <span class=\"hljs-params\">yOrigin</span>, <span class=\"hljs-params\">xOrigin</span>, <span class=\"hljs-params\">mMargin10</span>, <span class=\"hljs-params\">mPaintAxes</span>)</span>;\n        <span class=\"hljs-comment\">//  绘制Y右边线</span>\n        canvas.draw<span class=\"hljs-constructor\">Line(<span class=\"hljs-params\">mWidth</span> - <span class=\"hljs-params\">mMargin10</span>, <span class=\"hljs-params\">mMargin10</span>, <span class=\"hljs-params\">mWidth</span> - <span class=\"hljs-params\">mMargin10</span>, <span class=\"hljs-params\">yOrigin</span>, <span class=\"hljs-params\">mPaintAxes</span>)</span>;\n    &#125;</code></pre>\n<p>2.绘制文字，代码如下：</p>\n<pre><code class=\"hljs reasonml\"><span class=\"hljs-keyword\">private</span> void draw<span class=\"hljs-constructor\">Text(Canvas <span class=\"hljs-params\">canvas</span>)</span> &#123;\n        <span class=\"hljs-comment\">//  绘制最大值</span>\n        canvas.draw<span class=\"hljs-constructor\">Text(String.<span class=\"hljs-params\">format</span>(<span class=\"hljs-string\">&quot;%.2f&quot;</span>, <span class=\"hljs-params\">max</span> <span class=\"hljs-operator\">*</span> 100 <span class=\"hljs-operator\">/</span> 100.0)</span> + <span class=\"hljs-string\">&quot;%&quot;</span>, xOrigin + <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">2</span><span class=\"hljs-operator\"> * </span>mMargin10, mPaintText);\n        <span class=\"hljs-comment\">//  绘制最小值</span>\n        canvas.draw<span class=\"hljs-constructor\">Text(String.<span class=\"hljs-params\">format</span>(<span class=\"hljs-string\">&quot;%.2f&quot;</span>, <span class=\"hljs-params\">min</span> <span class=\"hljs-operator\">*</span> 100 <span class=\"hljs-operator\">/</span> 100.0)</span> + <span class=\"hljs-string\">&quot;%&quot;</span>, xOrigin + <span class=\"hljs-number\">6</span>, yOrigin - <span class=\"hljs-number\">6</span>, mPaintText);\n        <span class=\"hljs-comment\">//  绘制中间值</span>\n        canvas.draw<span class=\"hljs-constructor\">Text((String.<span class=\"hljs-params\">format</span>(<span class=\"hljs-string\">&quot;%.2f&quot;</span>, (<span class=\"hljs-params\">min</span> + <span class=\"hljs-params\">max</span>)</span><span class=\"hljs-operator\"> * </span><span class=\"hljs-number\">100</span><span class=\"hljs-operator\"> / </span><span class=\"hljs-number\">200.0</span>) + <span class=\"hljs-string\">&quot;%&quot;</span>), xOrigin + <span class=\"hljs-number\">6</span>, (yOrigin + mMargin10)<span class=\"hljs-operator\"> / </span><span class=\"hljs-number\">2</span>, mPaintText);\n\n        <span class=\"hljs-comment\">//  绘制开始日期</span>\n        canvas.draw<span class=\"hljs-constructor\">Text(<span class=\"hljs-params\">startTime</span>, <span class=\"hljs-params\">xOrigin</span>, <span class=\"hljs-params\">mHeight</span> - <span class=\"hljs-params\">mMargin10</span>, <span class=\"hljs-params\">mPaintText</span>)</span>;\n        <span class=\"hljs-comment\">//  绘制结束日期</span>\n        canvas.draw<span class=\"hljs-constructor\">Text(<span class=\"hljs-params\">endTime</span>, <span class=\"hljs-params\">mWidth</span> - <span class=\"hljs-params\">timeWidth</span> - <span class=\"hljs-params\">mMargin10</span>, <span class=\"hljs-params\">mHeight</span> - <span class=\"hljs-params\">mMargin10</span>, <span class=\"hljs-params\">mPaintText</span>)</span>;\n    &#125;</code></pre>\n<p>3.绘制折线及渐变填充</p>\n<pre><code class=\"hljs reasonml\"><span class=\"hljs-keyword\">private</span> void draw<span class=\"hljs-constructor\">Line(Canvas <span class=\"hljs-params\">canvas</span>)</span> &#123;\n        <span class=\"hljs-comment\">//  画坐标点</span>\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-built_in\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; mValues.size<span class=\"hljs-literal\">()</span>; i++) &#123;\n            <span class=\"hljs-built_in\">float</span> x = i<span class=\"hljs-operator\"> * </span>xInterval + xOrigin + mAxesWidth;\n            <span class=\"hljs-keyword\">if</span> (i<span class=\"hljs-operator\"> == </span><span class=\"hljs-number\">0</span>) &#123;\n                mPathShader.move<span class=\"hljs-constructor\">To(<span class=\"hljs-params\">x</span>, <span class=\"hljs-params\">yOrigin</span> - (<span class=\"hljs-params\">mValues</span>.<span class=\"hljs-params\">get</span>(<span class=\"hljs-params\">i</span>)</span> - min)<span class=\"hljs-operator\"> / </span>yInterval);\n                mPath.move<span class=\"hljs-constructor\">To(<span class=\"hljs-params\">x</span>, <span class=\"hljs-params\">yOrigin</span> - (<span class=\"hljs-params\">mValues</span>.<span class=\"hljs-params\">get</span>(<span class=\"hljs-params\">i</span>)</span> - min)<span class=\"hljs-operator\"> / </span>yInterval);\n            &#125; <span class=\"hljs-keyword\">else</span> &#123;\n                mPath.line<span class=\"hljs-constructor\">To(<span class=\"hljs-params\">x</span> - <span class=\"hljs-params\">mMargin10</span> - <span class=\"hljs-params\">mAxesWidth</span>, <span class=\"hljs-params\">yOrigin</span> - (<span class=\"hljs-params\">mValues</span>.<span class=\"hljs-params\">get</span>(<span class=\"hljs-params\">i</span>)</span> - min)<span class=\"hljs-operator\"> / </span>yInterval);\n                mPathShader.line<span class=\"hljs-constructor\">To(<span class=\"hljs-params\">x</span> - <span class=\"hljs-params\">mMargin10</span> - <span class=\"hljs-params\">mAxesWidth</span>, <span class=\"hljs-params\">yOrigin</span> - (<span class=\"hljs-params\">mValues</span>.<span class=\"hljs-params\">get</span>(<span class=\"hljs-params\">i</span>)</span> - min)<span class=\"hljs-operator\"> / </span>yInterval);\n                <span class=\"hljs-keyword\">if</span> (i<span class=\"hljs-operator\"> == </span>mValues.size<span class=\"hljs-literal\">()</span> - <span class=\"hljs-number\">1</span>) &#123;\n                    mPathShader.line<span class=\"hljs-constructor\">To(<span class=\"hljs-params\">x</span> - <span class=\"hljs-params\">mMargin10</span> - <span class=\"hljs-params\">mAxesWidth</span>, <span class=\"hljs-params\">yOrigin</span>)</span>;\n                    mPathShader.line<span class=\"hljs-constructor\">To(<span class=\"hljs-params\">xOrigin</span>, <span class=\"hljs-params\">yOrigin</span>)</span>;\n                    mPathShader.close<span class=\"hljs-literal\">()</span>;\n                &#125;\n            &#125;\n        &#125;\n        <span class=\"hljs-keyword\">if</span> (null<span class=\"hljs-operator\"> == </span>mShadeColors) &#123;\n            mPaintShader.set<span class=\"hljs-constructor\">Color(Color.<span class=\"hljs-params\">argb</span>(0, 0, 0, 0)</span>);\n        &#125; <span class=\"hljs-keyword\">else</span> &#123;\n            Shader mShader = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-constructor\">LinearGradient(0, 0, 0, <span class=\"hljs-params\">getHeight</span>()</span>, mShadeColors, null, Shader.TileMode.CLAMP);\n            mPaintShader.set<span class=\"hljs-constructor\">Shader(<span class=\"hljs-params\">mShader</span>)</span>;\n        &#125;\n        canvas.draw<span class=\"hljs-constructor\">Path(<span class=\"hljs-params\">mPathShader</span>, <span class=\"hljs-params\">mPaintShader</span>)</span>;\n    &#125;</code></pre>\n<p>六、折线图添加动画。</p>\n<p>1.折线图的动画使用属性动画，首先需要计算动画的进度，因此需要先添加setPercentage方法，当动画开始时，我们可以在该方法中拿到percentage的值</p>\n<pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\"> * Animate this property. It is the percentage of the path that is drawn.</span>\n<span class=\"hljs-comment\"> *</span>\n<span class=\"hljs-comment\"> * @param percentage float the percentage of the path.</span>\n<span class=\"hljs-comment\"> */</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">setPercentage</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">float</span> percentage)</span> </span>&#123;\n    <span class=\"hljs-keyword\">if</span> (percentage &lt; <span class=\"hljs-number\">0.0f</span> || percentage &gt; <span class=\"hljs-number\">1.0f</span>) &#123;\n        <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> IllegalArgumentException(\n                <span class=\"hljs-string\">&quot;setPercentage not between 0.0f and 1.0f&quot;</span>);\n    &#125;\n    mProgress = percentage;\n    invalidate();\n&#125;</code></pre>\n<p>2.通过Path来绘制折线路径，代码如下：</p>\n<pre><code class=\"hljs cpp\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">drawPath</span><span class=\"hljs-params\">(Canvas canvas)</span> </span>&#123;\n\n       PathMeasure measure = <span class=\"hljs-keyword\">new</span> PathMeasure(mPath, <span class=\"hljs-literal\">false</span>);\n       <span class=\"hljs-keyword\">float</span> pathLength = measure.getLength();\n       PathEffect effect = <span class=\"hljs-keyword\">new</span> DashPathEffect(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">float</span>[]&#123;pathLength,\n               pathLength&#125;, pathLength - pathLength * mProgress);\n       mPaintLine.setPathEffect(effect);\n       canvas.drawPath(mPath, mPaintLine);\n   &#125;</code></pre>\n<p>3.通过ObjectAnimator 开启动画，注意ObjectAnimator.ofFloat(lineChartView, “percentage”, 0.0f, 1.0f)中第二个参数必须为“percentage”，对应前那边的setPercentage方法，属性动画会根据“percentage”参数通过反射调用setPercentage：</p>\n<pre><code class=\"hljs reasonml\"><span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">   * @param lineChartView</span>\n<span class=\"hljs-comment\">   * @param duration      动画持续时间</span>\n<span class=\"hljs-comment\">   */</span>\n  public void start<span class=\"hljs-constructor\">Anim(LineChartView <span class=\"hljs-params\">lineChartView</span>, <span class=\"hljs-params\">long</span> <span class=\"hljs-params\">duration</span>)</span> &#123;\n      ObjectAnimator anim = <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">ObjectAnimator</span>.</span></span><span class=\"hljs-keyword\">of</span><span class=\"hljs-constructor\">Float(<span class=\"hljs-params\">lineChartView</span>, <span class=\"hljs-string\">&quot;percentage&quot;</span>, 0.0f, 1.0f)</span>;\n      anim.set<span class=\"hljs-constructor\">Duration(<span class=\"hljs-params\">duration</span>)</span>;\n      anim.set<span class=\"hljs-constructor\">Interpolator(<span class=\"hljs-params\">new</span> LinearInterpolator()</span>);\n      anim.start<span class=\"hljs-literal\">()</span>;\n  &#125;</code></pre>\n\n<p>至此，折线图的绘制已经全部完成。最后还可以添加get() set()方法，暴露出属性接口，以供外部调用。代码就不再贴出来了。</p>\n<p>七、使用LineChartView<br>1.在布局文件中添加LineChartView,可设置折线颜色、字体颜色、等属性，如下：</p>\n<pre><code class=\"hljs routeros\">&lt;com.example.zhpan.linechartview.LineChartView\n        android:<span class=\"hljs-attribute\">id</span>=<span class=\"hljs-string\">&quot;@+id/lcv&quot;</span>\n        android:<span class=\"hljs-attribute\">layout_width</span>=<span class=\"hljs-string\">&quot;match_parent&quot;</span>\n        android:<span class=\"hljs-attribute\">layout_height</span>=<span class=\"hljs-string\">&quot;200dp&quot;</span>\n        android:<span class=\"hljs-attribute\">layout_marginBottom</span>=<span class=\"hljs-string\">&quot;20dp&quot;</span>\n        android:<span class=\"hljs-attribute\">layout_marginLeft</span>=<span class=\"hljs-string\">&quot;15dp&quot;</span>\n        android:<span class=\"hljs-attribute\">layout_marginRight</span>=<span class=\"hljs-string\">&quot;15dp&quot;</span>\n        android:<span class=\"hljs-attribute\">layout_marginTop</span>=<span class=\"hljs-string\">&quot;15dp&quot;</span>\n        app:<span class=\"hljs-attribute\">lineColor</span>=<span class=\"hljs-string\">&quot;#FF0000&quot;</span>\n        app:<span class=\"hljs-attribute\">textColor</span>=<span class=\"hljs-string\">&quot;#ABABAB&quot;</span>\n        app:<span class=\"hljs-attribute\">textSize</span>=<span class=\"hljs-string\">&quot;12dp&quot;</span>/&gt;</code></pre>\n\n<p>2.在Activity中为LineChartView设置数据，也可以通过代码为其设置属性。</p>\n<pre><code class=\"hljs angelscript\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-built_in\">void</span> initData() &#123;\n        <span class=\"hljs-comment\">//  初始化折线数据</span>\n        List&lt;Float&gt; listValues = new ArrayList&lt;&gt;();\n        Random random = new Random();\n        <span class=\"hljs-built_in\">float</span> startValue = random.nextFloat() * <span class=\"hljs-number\">10</span>;\n        listValues.add(startValue);\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-built_in\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">30</span>; i++) &#123;\n            startValue += random.nextFloat() * <span class=\"hljs-number\">10</span> - <span class=\"hljs-number\">5</span>;\n            listValues.add(startValue);\n        &#125;\n        List&lt;Integer&gt; listShadeColors = new ArrayList&lt;&gt;();\n        listShadeColors.add(Color.argb(<span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">255</span>, <span class=\"hljs-number\">86</span>, <span class=\"hljs-number\">86</span>));\n        listShadeColors.add(Color.argb(<span class=\"hljs-number\">15</span>, <span class=\"hljs-number\">255</span>, <span class=\"hljs-number\">86</span>, <span class=\"hljs-number\">86</span>));\n        listShadeColors.add(Color.argb(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">255</span>, <span class=\"hljs-number\">86</span>, <span class=\"hljs-number\">86</span>));\n        <span class=\"hljs-comment\">//  设置折线数据</span>\n        mLineChartView.setValues(listValues);\n        <span class=\"hljs-comment\">//  设置渐变颜色</span>\n        mLineChartView.setShadeColors(listShadeColors);\n        <span class=\"hljs-comment\">//  设置动画插值器</span>\n        mLineChartView.setInterpolator(new DecelerateInterpolator());\n        mLineChartView.setAxisMinValue(<span class=\"hljs-number\">-30</span>);\n        mLineChartView.setAxisMaxValue(<span class=\"hljs-number\">30</span>);\n        mLineChartView.setStartTime(<span class=\"hljs-string\">&quot;2017-03-15&quot;</span>);\n        mLineChartView.setEndTime(<span class=\"hljs-string\">&quot;2017-04-14&quot;</span>);\n        <span class=\"hljs-comment\">//  开启动画</span>\n        mLineChartView.startAnim(<span class=\"hljs-number\">2500</span>);\n    &#125;</code></pre>\n<p><a href=\"https://github.com/zhpanvip/CustomView\">源码下载</a></p>\n","site":{"data":{"fluid_config":{"favicon":"/img/favicon.png","apple_touch_icon":"/img/favicon.png","title_join_string":" - ","force_https":false,"highlight":{"enable":true,"style":"Github Gist","bg_color":false,"copy_btn":true},"fun_features":{"typing":{"enable":true,"typeSpeed":70,"cursorChar":"|","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"mouse_click":{"enable":false,"style":"values"}},"dark_mode":{"enable":true,"default":"auto"},"color":{"body_bg_color":"#eee","body_bg_color_dark":"#181c27","navbar_bg_color":"#2f4154","navbar_bg_color_dark":"#1f3144","navbar_text_color":"#fff","navbar_text_color_dark":"#d0d0d0","text_color":"#3c4858","text_color_dark":"#c4c6c9","sec_text_color":"#718096","sec_text_color_dark":"#a7a9ad","post_text_color":"#2c3e50","post_text_color_dark":"#c4c6c9","post_heading_color":"#1a202c","post_heading_color_dark":"#c4c6c9","post_link_color":"#0366d6","post_link_color_dark":"#1589e9","link_hover_color":"#30a9de","link_hover_color_dark":"#30a9de","link_hover_bg_color":"#f8f9fa","link_hover_bg_color_dark":"#364151","board_color":"#fff","board_color_dark":"#252d38"},"font":{"font_size":"16px","font_family":null,"code_font_size":"85%"},"custom_js":null,"custom_css":null,"custom_html":"","web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"tajs":null,"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}},"lazyload":{"enable":true,"onlypost":false},"daovoice":{"enable":false,"appid":""},"aplayer":{"enable":false,"autoplay":false,"loop":"all","order":"random","theme":"#b7daff","songs":[{"name":"name","artist":"artist","url":"/songs/test.mp3","cover":"/img/cover.jpg"},{"name":"name","artist":"artist","url":"https://...url.mp3","cover":"https://...cover.jpg"}]},"version":{"check":false},"navbar":{"blog_title":"zhangpan","ground_glass":{"enable":false,"px":3,"alpha":0.7},"menu":[{"key":"home","link":"/","icon":"iconfont icon-home-fill"},{"key":"archive","link":"/archives/","icon":"iconfont icon-archive-fill"},{"key":"category","link":"/categories/","icon":"iconfont icon-category-fill"},{"key":"tag","link":"/tags/","icon":"iconfont icon-tags-fill"},{"key":"about","link":"/about/","icon":"iconfont icon-user-fill"}]},"search":{"enable":true,"path":"/local-search.xml","generate_path":"/local-search.xml","field":"post","content":true},"scroll_down_arrow":{"enable":true,"banner_height_limit":90,"scroll_after_turning_page":true},"banner_parallax":true,"footer":{"statistics":{"enable":false,"source":"busuanzi","pv_format":"总访问量 {} 次","uv_format":"总访客数 {} 人"},"beian":{"enable":false,"icp_text":"京ICP证123456号","police_text":"京公网安备12345678号","police_code":12345678,"police_icon":"/img/police_beian.png"}},"scroll_top_arrow":{"enable":true},"index":{"banner_img":"/img/default.png","banner_img_height":100,"banner_mask_alpha":0.3,"post_default_img":"","slogan":{"enable":true,"text":"Talk is cheap, show me the code."},"auto_excerpt":{"enable":true},"post_url_target":"_self","post_meta":{"date":true,"category":true,"tag":true}},"page":{"banner_img":"/img/default.png","banner_img_height":60,"banner_mask_alpha":0.3},"post":{"banner_img":"/img/default.png","banner_img_height":70,"banner_mask_alpha":0.3,"meta":{"date":{"enable":true,"format":"LL a"},"wordcount":{"enable":true,"format":"{} 字"},"min2read":{"enable":true,"format":"{} 分钟","words":100},"views":{"enable":false,"source":"busuanzi","format":"{} 次"}},"updated":{"enable":false,"content":"本文最后更新于：","relative":false},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"copyright":{"enable":true,"content":"本博客所有文章除特别声明外，均采用 <a href=\"https://creativecommons.org/licenses/by-sa/4.0/deed.zh\" rel=\"nofollow noopener\">CC BY-SA 4.0 协议</a> ，转载请注明出处！ <h5>开源库推荐</h5> <a href=\"https://github.com/zhpanvip/BannerViewPager\">1.BannerViewPager</a> <p> 一个基于ViewPager2实现的具有强大功能的无限轮播库。支持多种页面切换效果和指示器样式。 </p>\n<a href=\"https://github.com/zhpanvip/viewpagerindicator\">2.ViewPagerIndicator</a> <p> 一个适用于ViewPager和ViewPager2的指示器，支持多种滑块样式及滑动模式 </p>"},"prev_next":{"enable":true},"custom":{"enable":false,"content":"<img src=\"https://octodex.github.com/images/jetpacktocat.png\" class=\"rounded mx-auto d-block mt-5\" style=\"width:150px; height:150px;\">"},"image_zoom":{"enable":true},"footnote":{"enable":true,"header":""},"math":{"enable":false,"specific":false,"engine":"mathjax"},"mermaid":{"enable":false,"specific":false,"options":{"theme":"default"}},"comments":{"enable":true,"type":"utterances"}},"utterances":{"repo":"zhpanvip/utterances-comment","issue_term":"pathname","label":"utterances","theme":"github-light","crossorigin":"anonymous"},"disqus":{"shortname":null,"disqusjs":false,"apikey":null},"gitalk":{"clientID":null,"clientSecret":null,"repo":null,"owner":null,"admin":["name"],"id":"location.pathname","language":"zh-CN","labels":["Gitalk"],"perPage":10,"pagerDirection":"last","distractionFreeMode":false,"createIssueManually":true},"valine":{"appid":"hXIROaIM5y9qnieojJRWP5hS","appkey":"y0f3w3aqd1MF7JL9ma4WECTy","placeholder":"说点什么","path":"window.location.pathname","avatar":"retro","meta":["nick","mail","link"],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"https://zhangpan.site"},"changyan":{"appid":"","appkey":""},"livere":{"uid":""},"archive":{"banner_img":"/img/bg_article.jpg","banner_img_height":60,"banner_mask_alpha":0.3,"subtitle":null},"category":{"banner_img":"/img/bg_default.png","banner_img_height":60,"banner_mask_alpha":0.3,"subtitle":null,"post_limit":10,"order_by":"-length"},"tag":{"banner_img":"/img/bg_label.jpg","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null,"tagcloud":{"min_font":15,"max_font":30,"unit":"px","start_color":"#BBBBEE","end_color":"#337ab7"}},"about":{"banner_img":"/img/bg_default.png","banner_img_height":60,"banner_mask_alpha":0.3,"subtitle":null,"avatar":"/img/avatar.png","name":"myname","introduce":"一句简短的介绍","icons":[{"class":"iconfont icon-github-fill","link":"https://github.com","tip":"GitHub"},{"class":"iconfont icon-douban-fill","link":"https://douban.com","tip":"豆瓣"},{"class":"iconfont icon-wechat-fill","qrcode":"/img/favicon.png"}]},"page404":{"banner_img":"/img/default.png","banner_img_height":85,"banner_mask_alpha":0.3,"subtitle":"Page not found"},"links":{"banner_img":"/img/default.png","banner_img_height":60,"banner_mask_alpha":0.3,"subtitle":null,"items":[{"title":"Fluid Docs","intro":"主题使用指南","link":"https://hexo.fluid-dev.com/docs/","image":"/img/favicon.png"},{"title":"Fluid Repo","intro":"主题 GitHub 仓库","link":"https://github.com/fluid-dev/hexo-theme-fluid","image":"/img/favicon.png"},{"title":"Fluid Example","intro":"主题操作示例","link":"https://hexo.fluid-dev.com/docs/example/","image":"/img/favicon.png"}]}}}},"excerpt":"","more":"<p>首先看下要实现的效果图。<br><img src=\"https://raw.githubusercontent.com/zhpanvip/Resource/master/image/0601.gif\"></p>\n<p>折线图的绘制主要有一下几个步骤。<br>一、定义LineChartView类并继承View。<br>二、添加自定义属性。以在value目录下创建attrs.xml文件,文件中我们可以定义一些用到的属性，比如折线颜色、字体大小等属性。文件内容如下：</p>\n<pre><code class=\"hljs xml\"><span class=\"hljs-meta\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">resources</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">declare-styleable</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;LineChartView&quot;</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">attr</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;axesColor&quot;</span> <span class=\"hljs-attr\">format</span>=<span class=\"hljs-string\">&quot;color&quot;</span>/&gt;</span> <span class=\"hljs-comment\">&lt;!--坐标轴颜色--&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">attr</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;axesWidth&quot;</span> <span class=\"hljs-attr\">format</span>=<span class=\"hljs-string\">&quot;dimension&quot;</span>/&gt;</span><span class=\"hljs-comment\">&lt;!--坐标轴宽度--&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">attr</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;textColor&quot;</span> <span class=\"hljs-attr\">format</span>=<span class=\"hljs-string\">&quot;color&quot;</span>/&gt;</span> <span class=\"hljs-comment\">&lt;!--字体颜色--&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">attr</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;textSize&quot;</span> <span class=\"hljs-attr\">format</span>=<span class=\"hljs-string\">&quot;dimension&quot;</span>/&gt;</span> <span class=\"hljs-comment\">&lt;!--字体大小--&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">attr</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;lineColor&quot;</span> <span class=\"hljs-attr\">format</span>=<span class=\"hljs-string\">&quot;color&quot;</span>/&gt;</span> <span class=\"hljs-comment\">&lt;!--折线颜色--&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">declare-styleable</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">resources</span>&gt;</span></code></pre>\n<p>接下来在LineChartView的构造方法中解析自定义属性的值并做相应的处理。在构造方法里还初始化了渐变颜色、折线数据的List集合以及初始化画笔等操作代码如下：</p>\n<pre><code class=\"hljs reasonml\">public <span class=\"hljs-constructor\">LineChartView(Context <span class=\"hljs-params\">context</span>, AttributeSet <span class=\"hljs-params\">attrs</span>, <span class=\"hljs-params\">int</span> <span class=\"hljs-params\">defStyleAttr</span>)</span> &#123;\n       super(context, attrs, defStyleAttr);\n       TypedArray typedArray = context.obtain<span class=\"hljs-constructor\">StyledAttributes(<span class=\"hljs-params\">attrs</span>, R.<span class=\"hljs-params\">styleable</span>.LineChartView)</span>;\n       mAxesColor = typedArray.get<span class=\"hljs-constructor\">Color(R.<span class=\"hljs-params\">styleable</span>.LineChartView_axesColor, Color.<span class=\"hljs-params\">parseColor</span>(<span class=\"hljs-string\">&quot;#CCCCCC&quot;</span>)</span>);\n       mAxesWidth = typedArray.get<span class=\"hljs-constructor\">Dimension(R.<span class=\"hljs-params\">styleable</span>.LineChartView_axesWidth, 1)</span>;\n       mTextColor = typedArray.get<span class=\"hljs-constructor\">Color(R.<span class=\"hljs-params\">styleable</span>.LineChartView_textColor, Color.<span class=\"hljs-params\">parseColor</span>(<span class=\"hljs-string\">&quot;#ABABAB&quot;</span>)</span>);\n       mTextSize = typedArray.get<span class=\"hljs-constructor\">Dimension(R.<span class=\"hljs-params\">styleable</span>.LineChartView_textSize, 32)</span>;\n       mLineColor = typedArray.get<span class=\"hljs-constructor\">Color(R.<span class=\"hljs-params\">styleable</span>.LineChartView_lineColor, Color.RED)</span>;\n       typedArray.recycle<span class=\"hljs-literal\">()</span>;\n\n       <span class=\"hljs-comment\">//  初始化渐变色</span>\n       shadeColors = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">int</span><span class=\"hljs-literal\">[]</span>&#123;\n               <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">Color</span>.</span></span>argb(<span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">255</span>, <span class=\"hljs-number\">86</span>, <span class=\"hljs-number\">86</span>), <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">Color</span>.</span></span>argb(<span class=\"hljs-number\">15</span>, <span class=\"hljs-number\">255</span>, <span class=\"hljs-number\">86</span>, <span class=\"hljs-number\">86</span>),\n               <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">Color</span>.</span></span>argb(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">255</span>, <span class=\"hljs-number\">86</span>, <span class=\"hljs-number\">86</span>)&#125;;\n     <span class=\"hljs-comment\">//  初始化折线数据</span>\n       mValues = <span class=\"hljs-keyword\">new</span> ArrayList&lt;&gt;<span class=\"hljs-literal\">()</span>;\n       mMargin10 = <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">DensityUtils</span>.</span></span>dp2px(context, <span class=\"hljs-number\">10</span>);\n       init<span class=\"hljs-literal\">()</span>;\n   &#125;</code></pre>\n\n\n<p>三、初始化画笔和路径。代码如下：</p>\n<pre><code class=\"hljs reasonml\"><span class=\"hljs-keyword\">private</span> void init<span class=\"hljs-literal\">()</span> &#123;\n        <span class=\"hljs-comment\">//  初始化坐标轴画笔</span>\n        mPaintAxes = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-constructor\">Paint()</span>;\n        mPaintAxes.set<span class=\"hljs-constructor\">Color(<span class=\"hljs-params\">mAxesColor</span>)</span>;\n        mPaintAxes.set<span class=\"hljs-constructor\">StrokeWidth(<span class=\"hljs-params\">mAxesWidth</span>)</span>;\n\n        <span class=\"hljs-comment\">//  初始化文字画笔</span>\n        mPaintText = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-constructor\">Paint()</span>;\n        mPaintText.set<span class=\"hljs-constructor\">Style(Paint.Style.FILL)</span>;\n        mPaintText.set<span class=\"hljs-constructor\">AntiAlias(<span class=\"hljs-params\">true</span>)</span>; <span class=\"hljs-comment\">//抗锯齿</span>\n        mPaintText.set<span class=\"hljs-constructor\">TextSize(<span class=\"hljs-params\">mTextSize</span>)</span>;\n        mPaintText.set<span class=\"hljs-constructor\">Color(<span class=\"hljs-params\">mTextColor</span>)</span>;\n        mPaintText.set<span class=\"hljs-constructor\">TextAlign(Paint.Align.LEFT)</span>;\n\n        <span class=\"hljs-comment\">//  初始化折线画笔</span>\n        mPaintLine = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-constructor\">Paint()</span>;\n        mPaintLine.set<span class=\"hljs-constructor\">Style(Paint.Style.STROKE)</span>;\n        mPaintLine.set<span class=\"hljs-constructor\">AntiAlias(<span class=\"hljs-params\">true</span>)</span>;\n        mPaintLine.set<span class=\"hljs-constructor\">StrokeWidth(<span class=\"hljs-params\">mAxesWidth</span> <span class=\"hljs-operator\">/</span> 2)</span>;\n        mPaintLine.set<span class=\"hljs-constructor\">Color(<span class=\"hljs-params\">mLineColor</span>)</span>;\n\n        <span class=\"hljs-comment\">//  初始化折线路径</span>\n        mPath = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-constructor\">Path()</span>;\n        mPathShader = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-constructor\">Path()</span>;\n\n        <span class=\"hljs-comment\">//  阴影画笔</span>\n        mPaintShader = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-constructor\">Paint()</span>;\n        mPaintShader.set<span class=\"hljs-constructor\">AntiAlias(<span class=\"hljs-params\">true</span>)</span>;\n        mPaintShader.set<span class=\"hljs-constructor\">StrokeWidth(2f)</span>;\n    &#125;</code></pre>\n<p>四、重写onLayout方法。在onLayout方法中获取控件的宽高、初始化原点坐标以及设置控件的背景。代码如下：</p>\n<pre><code class=\"hljs reasonml\">@Override\n   protected void on<span class=\"hljs-constructor\">Layout(<span class=\"hljs-params\">boolean</span> <span class=\"hljs-params\">changed</span>, <span class=\"hljs-params\">int</span> <span class=\"hljs-params\">left</span>, <span class=\"hljs-params\">int</span> <span class=\"hljs-params\">top</span>, <span class=\"hljs-params\">int</span> <span class=\"hljs-params\">right</span>, <span class=\"hljs-params\">int</span> <span class=\"hljs-params\">bottom</span>)</span> &#123;\n       super.on<span class=\"hljs-constructor\">Layout(<span class=\"hljs-params\">changed</span>, <span class=\"hljs-params\">left</span>, <span class=\"hljs-params\">top</span>, <span class=\"hljs-params\">right</span>, <span class=\"hljs-params\">bottom</span>)</span>;\n       <span class=\"hljs-keyword\">if</span> (changed) &#123;\n\n           mWidth = get<span class=\"hljs-constructor\">Width()</span>;\n           mHeight = get<span class=\"hljs-constructor\">Height()</span>;\n           timeWidth = (<span class=\"hljs-built_in\">int</span>) mPaintText.measure<span class=\"hljs-constructor\">Text(<span class=\"hljs-params\">startTime</span>)</span>;\n           <span class=\"hljs-comment\">//  初始化原点坐标</span>\n           xOrigin = <span class=\"hljs-number\">0</span> + mMargin10;\n           yOrigin = (mHeight - mTextSize - mMargin10); \n       &#125;\n   &#125;</code></pre>\n<p>五、重写onDraw方法。在onDraw方法中完成折线图的绘制。代码如下：</p>\n<pre><code class=\"hljs reasonml\">@Override\n   protected void on<span class=\"hljs-constructor\">Draw(Canvas <span class=\"hljs-params\">canvas</span>)</span> &#123;\n       super.on<span class=\"hljs-constructor\">Draw(<span class=\"hljs-params\">canvas</span>)</span>;\n       <span class=\"hljs-comment\">//  Y轴坐标间距</span>\n       yInterval = (max - min)<span class=\"hljs-operator\"> / </span>(yOrigin - mMargin10);\n\t<span class=\"hljs-comment\">//  X轴坐标间距</span>\n       xInterval = (mWidth - xOrigin)<span class=\"hljs-operator\"> / </span>(mItems.size<span class=\"hljs-literal\">()</span> - <span class=\"hljs-number\">1</span>);\n       <span class=\"hljs-comment\">//  画坐标轴</span>\n       draw<span class=\"hljs-constructor\">Axes(<span class=\"hljs-params\">canvas</span>)</span>;\n       <span class=\"hljs-comment\">//  画文字</span>\n       draw<span class=\"hljs-constructor\">Text(<span class=\"hljs-params\">canvas</span>)</span>;\n       <span class=\"hljs-comment\">//  画折线</span>\n       draw<span class=\"hljs-constructor\">Line(<span class=\"hljs-params\">canvas</span>)</span>;\n\t<span class=\"hljs-comment\">//  绘制路径</span>\n       draw<span class=\"hljs-constructor\">Path(<span class=\"hljs-params\">canvas</span>)</span>;\n   &#125;</code></pre>\n<p>折线图的绘制可以分三部分：1.绘制坐标轴。2.绘制View上的文字。3.绘制折线。</p>\n<p>1.坐标轴绘制的是第一象限，即左下角的点为原点。绘制坐标轴代码如下：</p>\n<pre><code class=\"hljs reasonml\"><span class=\"hljs-comment\">//  画坐标轴</span>\n    <span class=\"hljs-keyword\">private</span> void draw<span class=\"hljs-constructor\">Axes(Canvas <span class=\"hljs-params\">canvas</span>)</span> &#123;\n        <span class=\"hljs-comment\">//  绘制X轴</span>\n        canvas.draw<span class=\"hljs-constructor\">Line(<span class=\"hljs-params\">xOrigin</span>, <span class=\"hljs-params\">yOrigin</span>, <span class=\"hljs-params\">mWidth</span> - <span class=\"hljs-params\">mMargin10</span>, <span class=\"hljs-params\">yOrigin</span>, <span class=\"hljs-params\">mPaintAxes</span>)</span>;\n        <span class=\"hljs-comment\">//  绘制X中轴线</span>\n        canvas.draw<span class=\"hljs-constructor\">Line(<span class=\"hljs-params\">xOrigin</span>, <span class=\"hljs-params\">yOrigin</span> <span class=\"hljs-operator\">/</span> 2, <span class=\"hljs-params\">mWidth</span> - <span class=\"hljs-params\">mMargin10</span>, <span class=\"hljs-params\">yOrigin</span> <span class=\"hljs-operator\">/</span> 2, <span class=\"hljs-params\">mPaintAxes</span>)</span>;\n        <span class=\"hljs-comment\">//  绘制X上边线</span>\n        canvas.draw<span class=\"hljs-constructor\">Line(<span class=\"hljs-params\">xOrigin</span>, <span class=\"hljs-params\">mMargin10</span>, <span class=\"hljs-params\">mWidth</span> - <span class=\"hljs-params\">mMargin10</span>, <span class=\"hljs-params\">mMargin10</span>, <span class=\"hljs-params\">mPaintAxes</span>)</span>;\n        <span class=\"hljs-comment\">//  绘制画Y轴</span>\n        canvas.draw<span class=\"hljs-constructor\">Line(<span class=\"hljs-params\">xOrigin</span>, <span class=\"hljs-params\">yOrigin</span>, <span class=\"hljs-params\">xOrigin</span>, <span class=\"hljs-params\">mMargin10</span>, <span class=\"hljs-params\">mPaintAxes</span>)</span>;\n        <span class=\"hljs-comment\">//  绘制Y右边线</span>\n        canvas.draw<span class=\"hljs-constructor\">Line(<span class=\"hljs-params\">mWidth</span> - <span class=\"hljs-params\">mMargin10</span>, <span class=\"hljs-params\">mMargin10</span>, <span class=\"hljs-params\">mWidth</span> - <span class=\"hljs-params\">mMargin10</span>, <span class=\"hljs-params\">yOrigin</span>, <span class=\"hljs-params\">mPaintAxes</span>)</span>;\n    &#125;</code></pre>\n<p>2.绘制文字，代码如下：</p>\n<pre><code class=\"hljs reasonml\"><span class=\"hljs-keyword\">private</span> void draw<span class=\"hljs-constructor\">Text(Canvas <span class=\"hljs-params\">canvas</span>)</span> &#123;\n        <span class=\"hljs-comment\">//  绘制最大值</span>\n        canvas.draw<span class=\"hljs-constructor\">Text(String.<span class=\"hljs-params\">format</span>(<span class=\"hljs-string\">&quot;%.2f&quot;</span>, <span class=\"hljs-params\">max</span> <span class=\"hljs-operator\">*</span> 100 <span class=\"hljs-operator\">/</span> 100.0)</span> + <span class=\"hljs-string\">&quot;%&quot;</span>, xOrigin + <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">2</span><span class=\"hljs-operator\"> * </span>mMargin10, mPaintText);\n        <span class=\"hljs-comment\">//  绘制最小值</span>\n        canvas.draw<span class=\"hljs-constructor\">Text(String.<span class=\"hljs-params\">format</span>(<span class=\"hljs-string\">&quot;%.2f&quot;</span>, <span class=\"hljs-params\">min</span> <span class=\"hljs-operator\">*</span> 100 <span class=\"hljs-operator\">/</span> 100.0)</span> + <span class=\"hljs-string\">&quot;%&quot;</span>, xOrigin + <span class=\"hljs-number\">6</span>, yOrigin - <span class=\"hljs-number\">6</span>, mPaintText);\n        <span class=\"hljs-comment\">//  绘制中间值</span>\n        canvas.draw<span class=\"hljs-constructor\">Text((String.<span class=\"hljs-params\">format</span>(<span class=\"hljs-string\">&quot;%.2f&quot;</span>, (<span class=\"hljs-params\">min</span> + <span class=\"hljs-params\">max</span>)</span><span class=\"hljs-operator\"> * </span><span class=\"hljs-number\">100</span><span class=\"hljs-operator\"> / </span><span class=\"hljs-number\">200.0</span>) + <span class=\"hljs-string\">&quot;%&quot;</span>), xOrigin + <span class=\"hljs-number\">6</span>, (yOrigin + mMargin10)<span class=\"hljs-operator\"> / </span><span class=\"hljs-number\">2</span>, mPaintText);\n\n        <span class=\"hljs-comment\">//  绘制开始日期</span>\n        canvas.draw<span class=\"hljs-constructor\">Text(<span class=\"hljs-params\">startTime</span>, <span class=\"hljs-params\">xOrigin</span>, <span class=\"hljs-params\">mHeight</span> - <span class=\"hljs-params\">mMargin10</span>, <span class=\"hljs-params\">mPaintText</span>)</span>;\n        <span class=\"hljs-comment\">//  绘制结束日期</span>\n        canvas.draw<span class=\"hljs-constructor\">Text(<span class=\"hljs-params\">endTime</span>, <span class=\"hljs-params\">mWidth</span> - <span class=\"hljs-params\">timeWidth</span> - <span class=\"hljs-params\">mMargin10</span>, <span class=\"hljs-params\">mHeight</span> - <span class=\"hljs-params\">mMargin10</span>, <span class=\"hljs-params\">mPaintText</span>)</span>;\n    &#125;</code></pre>\n<p>3.绘制折线及渐变填充</p>\n<pre><code class=\"hljs reasonml\"><span class=\"hljs-keyword\">private</span> void draw<span class=\"hljs-constructor\">Line(Canvas <span class=\"hljs-params\">canvas</span>)</span> &#123;\n        <span class=\"hljs-comment\">//  画坐标点</span>\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-built_in\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; mValues.size<span class=\"hljs-literal\">()</span>; i++) &#123;\n            <span class=\"hljs-built_in\">float</span> x = i<span class=\"hljs-operator\"> * </span>xInterval + xOrigin + mAxesWidth;\n            <span class=\"hljs-keyword\">if</span> (i<span class=\"hljs-operator\"> == </span><span class=\"hljs-number\">0</span>) &#123;\n                mPathShader.move<span class=\"hljs-constructor\">To(<span class=\"hljs-params\">x</span>, <span class=\"hljs-params\">yOrigin</span> - (<span class=\"hljs-params\">mValues</span>.<span class=\"hljs-params\">get</span>(<span class=\"hljs-params\">i</span>)</span> - min)<span class=\"hljs-operator\"> / </span>yInterval);\n                mPath.move<span class=\"hljs-constructor\">To(<span class=\"hljs-params\">x</span>, <span class=\"hljs-params\">yOrigin</span> - (<span class=\"hljs-params\">mValues</span>.<span class=\"hljs-params\">get</span>(<span class=\"hljs-params\">i</span>)</span> - min)<span class=\"hljs-operator\"> / </span>yInterval);\n            &#125; <span class=\"hljs-keyword\">else</span> &#123;\n                mPath.line<span class=\"hljs-constructor\">To(<span class=\"hljs-params\">x</span> - <span class=\"hljs-params\">mMargin10</span> - <span class=\"hljs-params\">mAxesWidth</span>, <span class=\"hljs-params\">yOrigin</span> - (<span class=\"hljs-params\">mValues</span>.<span class=\"hljs-params\">get</span>(<span class=\"hljs-params\">i</span>)</span> - min)<span class=\"hljs-operator\"> / </span>yInterval);\n                mPathShader.line<span class=\"hljs-constructor\">To(<span class=\"hljs-params\">x</span> - <span class=\"hljs-params\">mMargin10</span> - <span class=\"hljs-params\">mAxesWidth</span>, <span class=\"hljs-params\">yOrigin</span> - (<span class=\"hljs-params\">mValues</span>.<span class=\"hljs-params\">get</span>(<span class=\"hljs-params\">i</span>)</span> - min)<span class=\"hljs-operator\"> / </span>yInterval);\n                <span class=\"hljs-keyword\">if</span> (i<span class=\"hljs-operator\"> == </span>mValues.size<span class=\"hljs-literal\">()</span> - <span class=\"hljs-number\">1</span>) &#123;\n                    mPathShader.line<span class=\"hljs-constructor\">To(<span class=\"hljs-params\">x</span> - <span class=\"hljs-params\">mMargin10</span> - <span class=\"hljs-params\">mAxesWidth</span>, <span class=\"hljs-params\">yOrigin</span>)</span>;\n                    mPathShader.line<span class=\"hljs-constructor\">To(<span class=\"hljs-params\">xOrigin</span>, <span class=\"hljs-params\">yOrigin</span>)</span>;\n                    mPathShader.close<span class=\"hljs-literal\">()</span>;\n                &#125;\n            &#125;\n        &#125;\n        <span class=\"hljs-keyword\">if</span> (null<span class=\"hljs-operator\"> == </span>mShadeColors) &#123;\n            mPaintShader.set<span class=\"hljs-constructor\">Color(Color.<span class=\"hljs-params\">argb</span>(0, 0, 0, 0)</span>);\n        &#125; <span class=\"hljs-keyword\">else</span> &#123;\n            Shader mShader = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-constructor\">LinearGradient(0, 0, 0, <span class=\"hljs-params\">getHeight</span>()</span>, mShadeColors, null, Shader.TileMode.CLAMP);\n            mPaintShader.set<span class=\"hljs-constructor\">Shader(<span class=\"hljs-params\">mShader</span>)</span>;\n        &#125;\n        canvas.draw<span class=\"hljs-constructor\">Path(<span class=\"hljs-params\">mPathShader</span>, <span class=\"hljs-params\">mPaintShader</span>)</span>;\n    &#125;</code></pre>\n<p>六、折线图添加动画。</p>\n<p>1.折线图的动画使用属性动画，首先需要计算动画的进度，因此需要先添加setPercentage方法，当动画开始时，我们可以在该方法中拿到percentage的值</p>\n<pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\"> * Animate this property. It is the percentage of the path that is drawn.</span>\n<span class=\"hljs-comment\"> *</span>\n<span class=\"hljs-comment\"> * @param percentage float the percentage of the path.</span>\n<span class=\"hljs-comment\"> */</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">setPercentage</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">float</span> percentage)</span> </span>&#123;\n    <span class=\"hljs-keyword\">if</span> (percentage &lt; <span class=\"hljs-number\">0.0f</span> || percentage &gt; <span class=\"hljs-number\">1.0f</span>) &#123;\n        <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> IllegalArgumentException(\n                <span class=\"hljs-string\">&quot;setPercentage not between 0.0f and 1.0f&quot;</span>);\n    &#125;\n    mProgress = percentage;\n    invalidate();\n&#125;</code></pre>\n<p>2.通过Path来绘制折线路径，代码如下：</p>\n<pre><code class=\"hljs cpp\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">drawPath</span><span class=\"hljs-params\">(Canvas canvas)</span> </span>&#123;\n\n       PathMeasure measure = <span class=\"hljs-keyword\">new</span> PathMeasure(mPath, <span class=\"hljs-literal\">false</span>);\n       <span class=\"hljs-keyword\">float</span> pathLength = measure.getLength();\n       PathEffect effect = <span class=\"hljs-keyword\">new</span> DashPathEffect(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">float</span>[]&#123;pathLength,\n               pathLength&#125;, pathLength - pathLength * mProgress);\n       mPaintLine.setPathEffect(effect);\n       canvas.drawPath(mPath, mPaintLine);\n   &#125;</code></pre>\n<p>3.通过ObjectAnimator 开启动画，注意ObjectAnimator.ofFloat(lineChartView, “percentage”, 0.0f, 1.0f)中第二个参数必须为“percentage”，对应前那边的setPercentage方法，属性动画会根据“percentage”参数通过反射调用setPercentage：</p>\n<pre><code class=\"hljs reasonml\"><span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">   * @param lineChartView</span>\n<span class=\"hljs-comment\">   * @param duration      动画持续时间</span>\n<span class=\"hljs-comment\">   */</span>\n  public void start<span class=\"hljs-constructor\">Anim(LineChartView <span class=\"hljs-params\">lineChartView</span>, <span class=\"hljs-params\">long</span> <span class=\"hljs-params\">duration</span>)</span> &#123;\n      ObjectAnimator anim = <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">ObjectAnimator</span>.</span></span><span class=\"hljs-keyword\">of</span><span class=\"hljs-constructor\">Float(<span class=\"hljs-params\">lineChartView</span>, <span class=\"hljs-string\">&quot;percentage&quot;</span>, 0.0f, 1.0f)</span>;\n      anim.set<span class=\"hljs-constructor\">Duration(<span class=\"hljs-params\">duration</span>)</span>;\n      anim.set<span class=\"hljs-constructor\">Interpolator(<span class=\"hljs-params\">new</span> LinearInterpolator()</span>);\n      anim.start<span class=\"hljs-literal\">()</span>;\n  &#125;</code></pre>\n\n<p>至此，折线图的绘制已经全部完成。最后还可以添加get() set()方法，暴露出属性接口，以供外部调用。代码就不再贴出来了。</p>\n<p>七、使用LineChartView<br>1.在布局文件中添加LineChartView,可设置折线颜色、字体颜色、等属性，如下：</p>\n<pre><code class=\"hljs routeros\">&lt;com.example.zhpan.linechartview.LineChartView\n        android:<span class=\"hljs-attribute\">id</span>=<span class=\"hljs-string\">&quot;@+id/lcv&quot;</span>\n        android:<span class=\"hljs-attribute\">layout_width</span>=<span class=\"hljs-string\">&quot;match_parent&quot;</span>\n        android:<span class=\"hljs-attribute\">layout_height</span>=<span class=\"hljs-string\">&quot;200dp&quot;</span>\n        android:<span class=\"hljs-attribute\">layout_marginBottom</span>=<span class=\"hljs-string\">&quot;20dp&quot;</span>\n        android:<span class=\"hljs-attribute\">layout_marginLeft</span>=<span class=\"hljs-string\">&quot;15dp&quot;</span>\n        android:<span class=\"hljs-attribute\">layout_marginRight</span>=<span class=\"hljs-string\">&quot;15dp&quot;</span>\n        android:<span class=\"hljs-attribute\">layout_marginTop</span>=<span class=\"hljs-string\">&quot;15dp&quot;</span>\n        app:<span class=\"hljs-attribute\">lineColor</span>=<span class=\"hljs-string\">&quot;#FF0000&quot;</span>\n        app:<span class=\"hljs-attribute\">textColor</span>=<span class=\"hljs-string\">&quot;#ABABAB&quot;</span>\n        app:<span class=\"hljs-attribute\">textSize</span>=<span class=\"hljs-string\">&quot;12dp&quot;</span>/&gt;</code></pre>\n\n<p>2.在Activity中为LineChartView设置数据，也可以通过代码为其设置属性。</p>\n<pre><code class=\"hljs angelscript\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-built_in\">void</span> initData() &#123;\n        <span class=\"hljs-comment\">//  初始化折线数据</span>\n        List&lt;Float&gt; listValues = new ArrayList&lt;&gt;();\n        Random random = new Random();\n        <span class=\"hljs-built_in\">float</span> startValue = random.nextFloat() * <span class=\"hljs-number\">10</span>;\n        listValues.add(startValue);\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-built_in\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">30</span>; i++) &#123;\n            startValue += random.nextFloat() * <span class=\"hljs-number\">10</span> - <span class=\"hljs-number\">5</span>;\n            listValues.add(startValue);\n        &#125;\n        List&lt;Integer&gt; listShadeColors = new ArrayList&lt;&gt;();\n        listShadeColors.add(Color.argb(<span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">255</span>, <span class=\"hljs-number\">86</span>, <span class=\"hljs-number\">86</span>));\n        listShadeColors.add(Color.argb(<span class=\"hljs-number\">15</span>, <span class=\"hljs-number\">255</span>, <span class=\"hljs-number\">86</span>, <span class=\"hljs-number\">86</span>));\n        listShadeColors.add(Color.argb(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">255</span>, <span class=\"hljs-number\">86</span>, <span class=\"hljs-number\">86</span>));\n        <span class=\"hljs-comment\">//  设置折线数据</span>\n        mLineChartView.setValues(listValues);\n        <span class=\"hljs-comment\">//  设置渐变颜色</span>\n        mLineChartView.setShadeColors(listShadeColors);\n        <span class=\"hljs-comment\">//  设置动画插值器</span>\n        mLineChartView.setInterpolator(new DecelerateInterpolator());\n        mLineChartView.setAxisMinValue(<span class=\"hljs-number\">-30</span>);\n        mLineChartView.setAxisMaxValue(<span class=\"hljs-number\">30</span>);\n        mLineChartView.setStartTime(<span class=\"hljs-string\">&quot;2017-03-15&quot;</span>);\n        mLineChartView.setEndTime(<span class=\"hljs-string\">&quot;2017-04-14&quot;</span>);\n        <span class=\"hljs-comment\">//  开启动画</span>\n        mLineChartView.startAnim(<span class=\"hljs-number\">2500</span>);\n    &#125;</code></pre>\n<p><a href=\"https://github.com/zhpanvip/CustomView\">源码下载</a></p>\n"},{"title":"BaseActivity中封装通用的Toolbar","date":"2017-04-28T15:35:33.000Z","_content":"\n之前写过一篇关于如何使用Toolbar的文章，最近在搭建新项目时对Toolbar做了封装。封装的预期目标是只在BaseActivity中引入Toolbar，然后子Activity通过继承BaseActivity就能显示Toolbar。接下来就看看如何实现这样的功能。\n因为我们使用toolbar作为titlebar，因此首先需要去掉Actionbar。在style文件下修改默认Theme的parent为Theme.AppCompat.Light.NoActionBar便可以去掉默认的Actionbar，如下：\n\n```\n    <style name=\"AppTheme\" parent=\"Theme.AppCompat.Light.NoActionBar\">\n        <!-- Customize your theme here. -->\n        <item name=\"colorPrimary\">@color/colorPrimary</item>\n        <item name=\"colorPrimaryDark\">@color/colorPrimaryDark</item>\n        <item name=\"colorAccent\">@color/colorAccent</item>\n    </style>\n```\n\n然后定义一个toolbar_layout的xml文件，在toolbar中加入俩个TextView作为标题和子标题，如下：\n\n```\n<android.support.v7.widget.Toolbar\n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:id=\"@+id/toolbar\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"wrap_content\"\n    android:background=\"@color/colorPrimary\"\n    android:minHeight=\"?attr/actionBarSize\">\n    <!--自定义toolbar的title 和subtitle -->\n    <TextView\n        android:id=\"@+id/tv_right\"\n        style=\"@style/TextAppearance.AppCompat.Widget.ActionBar.Subtitle\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:maxLines=\"1\"\n        android:textColor=\"@color/white\"\n        android:text=\"right\"\n        android:paddingRight=\"10dp\"\n        android:layout_gravity=\"right\" />\n\n    <TextView\n        android:id=\"@+id/tv_title\"\n        style=\"@style/TextAppearance.AppCompat.Widget.ActionBar.Title\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:lines=\"1\"\n        android:ellipsize=\"end\"\n        android:text=\"title\"\n        android:scrollHorizontally=\"true\"\n        android:textColor=\"@color/white\"\n        android:layout_gravity=\"center\" />\n\n</android.support.v7.widget.Toolbar>\n```\n接着在BaseActivity的布局文件中include进toolbar_layout，如下：\n\n```\n<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"wrap_content\">\n\n    <include layout=\"@layout/toolbar_layout\"/>\n\n</LinearLayout>\n\n```\n这样BaseActivity中就可以正常显示出Toolbar了。那么如何实现子Activity继承BaseActivity而显示toolbar呢？其实我们可以在BaseActivity中做文章。\n首先在BaseActivity中声明一个LinearLayout,然后把BaseActivity的布局文件添加到该LinearLayout中。我们知道子Activity通过setContentView()方法来关联布局文件，因此我们可以在BaseActivity中去重写setContentView()方法，在重写的setContentView中把子类的布局文件也添加到事先声明的LinearLayout中，接下来应该解决如何将这个LinearLayout与Activity关联。查阅相关资料可以知道，可以通过 findViewById(android.R.id.content)拿到window的ViewGroup然后将刚才声明的LinearLayout添加到这个ViewGroup中，这样就可以在子Activity中显示出BaseActivity中的Toolbar了。（具体原因可以查阅android.R.id.content和 DecorView）代码如下：\n\n```\npublic abstract class BaseActivity extends AppCompatActivity{\n     //the container of this activity layout and sub-activity layout\n    private LinearLayout parentLinearLayout;\n    \n    @Override\n    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        initContentView(R.layout.activity_base);\n        setContentView(getLayoutId());\n        initToolBar();\n        init();\n    }\n//  overwrite the function in sub-activity and return the layout id of sub-activity   \n protected abstract int getLayoutId();\n \n private void initContentView(@LayoutRes int layoutResID) {\n        ViewGroup viewGroup = (ViewGroup) findViewById(android.R.id.content);\n        viewGroup.removeAllViews();\n        parentLinearLayout = new LinearLayout(this);\n        parentLinearLayout.setOrientation(LinearLayout.VERTICAL);\n\t\t//  add parentLinearLayout in viewGroup\n        viewGroup.addView(parentLinearLayout);\n        //  add the layout of BaseActivity in parentLinearLayout\n        LayoutInflater.from(this).inflate(layoutResID, parentLinearLayout, true);\n    }\n   /**\n     * @param layoutResID  layout id of sub-activity\n     */\n    @Override\n    public void setContentView(@LayoutRes int layoutResID) {\n        //  added the sub-activity layout id in parentLinearLayout\n        LayoutInflater.from(this).inflate(layoutResID, parentLinearLayout, true);\n\n    }\n}\n\n```\n上述代码通过initContentView()方法将BaseActivity中的布局文件添加到了声明的parentLinearLayout中，通过setContentView()方法将子Activity的布局也添加到了parentLinearLayout中，然后又将parentLinearLayout添加到了viewGroup中实现了Activity与布局文件的关联。至此我们完成了第一步，使子Activity可以显示出BaseActivity中的Toolbar布局。\n接下来，我们需要在BaseActivity中对Toolbar进行封装，使其能够更加方便的在子Activity中使用。比如添加toolbar回退键的监听，添加是否显示回退键的方法等。完整的BaseActivity如下：\n\n```\npublic abstract class BaseActivity extends AppCompatActivity{\n    //the container of this activity layout and sub-activity layout \n    private LinearLayout parentLinearLayout;\n    private TextView mTvTitle;\n    private TextView mTvRight;\n    private Toolbar mToolbar;\n    @Override\n    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        initContentView(R.layout.activity_base);\n\t      \n        setContentView(getLayoutId());\n        initToolBar();\n        setBackIcon();\n        init();\n    }\n//  overwrite the function in sub-activity and return the layout id of sub-activity \n protected abstract int getLayoutId();\n\n private void initContentView(@LayoutRes int layoutResID) {\n        ViewGroup viewGroup = (ViewGroup) findViewById(android.R.id.content);\n        viewGroup.removeAllViews();\n        parentLinearLayout = new LinearLayout(this);\n        parentLinearLayout.setOrientation(LinearLayout.VERTICAL);\n        viewGroup.addView(parentLinearLayout);\n        //  add the layout of BaseActivity in parentLinearLayout\n        LayoutInflater.from(this).inflate(layoutResID, parentLinearLayout, true);\n    }\n   /**\n     * @param layoutResID  the layout id of sub Activity\n     */\n    @Override\n    public void setContentView(@LayoutRes int layoutResID) {\n        //  added the sub-activity layout id in parentLinearLayout\n        LayoutInflater.from(this).inflate(layoutResID, parentLinearLayout, true);\n\n    }\n\nprivate void setBackIcon(){\n        if (null != getToolbar() && isShowBacking()) {\n            getToolbar().setNavigationIcon(R.drawable.icon_back);\n            getToolbar().setNavigationOnClickListener((v) -> onBackPressed());\n        }\n    }\n\n    /**\n     * @return TextView in center\n     */\n    public TextView getToolbarTitle() {\n        return mTvTitle;\n    }\n\n    /**\n     * @return TextView on the right\n     */\n    public TextView getSubTitle() {\n        return mTvRight;\n    }\n\n    /**\n     * set Title\n     * @param title\n     */\n    public void setToolBarTitle(CharSequence title) {\n        if (mTvTitle != null) {\n            mTvTitle.setText(title);\n        } else {\n            getToolbar().setTitle(title);\n            setSupportActionBar(getToolbar());\n        }\n    }\n\n    /**\n     * the toolbar of this Activity\n     * @return support.v7.widget.Toolbar.\n     */\n    public Toolbar getToolbar() {\n        return (Toolbar) findViewById(R.id.toolbar);\n    }\n    \n    /**\n     * is show back icon,default is none。\n     * you can override the function in subclass and return to true show the back icon\n     * @return\n     */\n    protected boolean isShowBacking() {\n        return true;\n    }\n}\n```\n最后我们可以在子Activity中去使用toolbar了。\n我们让MainActivity继承BaseActivity,并在布局文件中添加一个button，切布局文件中没有添加标题栏，布局文件的代码就不再贴出了。然后 重写isShowBacing()方法，使其返回false，隐藏MainActivity的回退键。\n代码如下：\n```\npublic class MainActivity extends BaseActivity {\n    @BindView(R.id.btn)\n    Button mBtn1;\n    @Override\n    protected int getLayoutId() {\n        return R.layout.activity_main;\n    }\n\t\n\t @Override\n    protected boolean isShowBacking() {\n        return false;\n    }\n\n@OnClick({R.id.btn})\n    public void Onclick(View view){\n        switch (view.getId()){\n            case R.id.btn:\n                startActivity(new Intent(this,TestActivity.class));\n                break;\n        }\n    }\n}\n```\n创建TestActivity并继承BaseActivity，TestActivity的布局文件中不添加任何view。然后在TestActivity中给toolbar设置内容，如下：\n\n```\npublic class TestActivity extends BaseActivity {\n\n    @Override\n    protected int getLayoutId() {\n        return R.layout.activity_test;\n    }\n\n    @Override\n    protected void init() {\n        getToolbarTitle().setText(\"中间标题\");\n        getSubTitle().setText(\"右边标题\");\n        Toolbar toolbar = getToolbar();\n        toolbar.setLogo(R.mipmap.ic_launcher);\n        toolbar.setNavigationIcon(R.drawable.back_white);\n    }\n}\n```\n效果如下图所示\n\n\n![](https://raw.githubusercontent.com/zhpanvip/Resource/master/image/0701.jfif)\n","source":"_posts/7.BaseActivity中封装通用的Toolbar.md","raw":"---\ntitle: BaseActivity中封装通用的Toolbar\ndate:  2017-04-28 23:35:33\ntags:  \n---\n\n之前写过一篇关于如何使用Toolbar的文章，最近在搭建新项目时对Toolbar做了封装。封装的预期目标是只在BaseActivity中引入Toolbar，然后子Activity通过继承BaseActivity就能显示Toolbar。接下来就看看如何实现这样的功能。\n因为我们使用toolbar作为titlebar，因此首先需要去掉Actionbar。在style文件下修改默认Theme的parent为Theme.AppCompat.Light.NoActionBar便可以去掉默认的Actionbar，如下：\n\n```\n    <style name=\"AppTheme\" parent=\"Theme.AppCompat.Light.NoActionBar\">\n        <!-- Customize your theme here. -->\n        <item name=\"colorPrimary\">@color/colorPrimary</item>\n        <item name=\"colorPrimaryDark\">@color/colorPrimaryDark</item>\n        <item name=\"colorAccent\">@color/colorAccent</item>\n    </style>\n```\n\n然后定义一个toolbar_layout的xml文件，在toolbar中加入俩个TextView作为标题和子标题，如下：\n\n```\n<android.support.v7.widget.Toolbar\n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:id=\"@+id/toolbar\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"wrap_content\"\n    android:background=\"@color/colorPrimary\"\n    android:minHeight=\"?attr/actionBarSize\">\n    <!--自定义toolbar的title 和subtitle -->\n    <TextView\n        android:id=\"@+id/tv_right\"\n        style=\"@style/TextAppearance.AppCompat.Widget.ActionBar.Subtitle\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:maxLines=\"1\"\n        android:textColor=\"@color/white\"\n        android:text=\"right\"\n        android:paddingRight=\"10dp\"\n        android:layout_gravity=\"right\" />\n\n    <TextView\n        android:id=\"@+id/tv_title\"\n        style=\"@style/TextAppearance.AppCompat.Widget.ActionBar.Title\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:lines=\"1\"\n        android:ellipsize=\"end\"\n        android:text=\"title\"\n        android:scrollHorizontally=\"true\"\n        android:textColor=\"@color/white\"\n        android:layout_gravity=\"center\" />\n\n</android.support.v7.widget.Toolbar>\n```\n接着在BaseActivity的布局文件中include进toolbar_layout，如下：\n\n```\n<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"wrap_content\">\n\n    <include layout=\"@layout/toolbar_layout\"/>\n\n</LinearLayout>\n\n```\n这样BaseActivity中就可以正常显示出Toolbar了。那么如何实现子Activity继承BaseActivity而显示toolbar呢？其实我们可以在BaseActivity中做文章。\n首先在BaseActivity中声明一个LinearLayout,然后把BaseActivity的布局文件添加到该LinearLayout中。我们知道子Activity通过setContentView()方法来关联布局文件，因此我们可以在BaseActivity中去重写setContentView()方法，在重写的setContentView中把子类的布局文件也添加到事先声明的LinearLayout中，接下来应该解决如何将这个LinearLayout与Activity关联。查阅相关资料可以知道，可以通过 findViewById(android.R.id.content)拿到window的ViewGroup然后将刚才声明的LinearLayout添加到这个ViewGroup中，这样就可以在子Activity中显示出BaseActivity中的Toolbar了。（具体原因可以查阅android.R.id.content和 DecorView）代码如下：\n\n```\npublic abstract class BaseActivity extends AppCompatActivity{\n     //the container of this activity layout and sub-activity layout\n    private LinearLayout parentLinearLayout;\n    \n    @Override\n    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        initContentView(R.layout.activity_base);\n        setContentView(getLayoutId());\n        initToolBar();\n        init();\n    }\n//  overwrite the function in sub-activity and return the layout id of sub-activity   \n protected abstract int getLayoutId();\n \n private void initContentView(@LayoutRes int layoutResID) {\n        ViewGroup viewGroup = (ViewGroup) findViewById(android.R.id.content);\n        viewGroup.removeAllViews();\n        parentLinearLayout = new LinearLayout(this);\n        parentLinearLayout.setOrientation(LinearLayout.VERTICAL);\n\t\t//  add parentLinearLayout in viewGroup\n        viewGroup.addView(parentLinearLayout);\n        //  add the layout of BaseActivity in parentLinearLayout\n        LayoutInflater.from(this).inflate(layoutResID, parentLinearLayout, true);\n    }\n   /**\n     * @param layoutResID  layout id of sub-activity\n     */\n    @Override\n    public void setContentView(@LayoutRes int layoutResID) {\n        //  added the sub-activity layout id in parentLinearLayout\n        LayoutInflater.from(this).inflate(layoutResID, parentLinearLayout, true);\n\n    }\n}\n\n```\n上述代码通过initContentView()方法将BaseActivity中的布局文件添加到了声明的parentLinearLayout中，通过setContentView()方法将子Activity的布局也添加到了parentLinearLayout中，然后又将parentLinearLayout添加到了viewGroup中实现了Activity与布局文件的关联。至此我们完成了第一步，使子Activity可以显示出BaseActivity中的Toolbar布局。\n接下来，我们需要在BaseActivity中对Toolbar进行封装，使其能够更加方便的在子Activity中使用。比如添加toolbar回退键的监听，添加是否显示回退键的方法等。完整的BaseActivity如下：\n\n```\npublic abstract class BaseActivity extends AppCompatActivity{\n    //the container of this activity layout and sub-activity layout \n    private LinearLayout parentLinearLayout;\n    private TextView mTvTitle;\n    private TextView mTvRight;\n    private Toolbar mToolbar;\n    @Override\n    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        initContentView(R.layout.activity_base);\n\t      \n        setContentView(getLayoutId());\n        initToolBar();\n        setBackIcon();\n        init();\n    }\n//  overwrite the function in sub-activity and return the layout id of sub-activity \n protected abstract int getLayoutId();\n\n private void initContentView(@LayoutRes int layoutResID) {\n        ViewGroup viewGroup = (ViewGroup) findViewById(android.R.id.content);\n        viewGroup.removeAllViews();\n        parentLinearLayout = new LinearLayout(this);\n        parentLinearLayout.setOrientation(LinearLayout.VERTICAL);\n        viewGroup.addView(parentLinearLayout);\n        //  add the layout of BaseActivity in parentLinearLayout\n        LayoutInflater.from(this).inflate(layoutResID, parentLinearLayout, true);\n    }\n   /**\n     * @param layoutResID  the layout id of sub Activity\n     */\n    @Override\n    public void setContentView(@LayoutRes int layoutResID) {\n        //  added the sub-activity layout id in parentLinearLayout\n        LayoutInflater.from(this).inflate(layoutResID, parentLinearLayout, true);\n\n    }\n\nprivate void setBackIcon(){\n        if (null != getToolbar() && isShowBacking()) {\n            getToolbar().setNavigationIcon(R.drawable.icon_back);\n            getToolbar().setNavigationOnClickListener((v) -> onBackPressed());\n        }\n    }\n\n    /**\n     * @return TextView in center\n     */\n    public TextView getToolbarTitle() {\n        return mTvTitle;\n    }\n\n    /**\n     * @return TextView on the right\n     */\n    public TextView getSubTitle() {\n        return mTvRight;\n    }\n\n    /**\n     * set Title\n     * @param title\n     */\n    public void setToolBarTitle(CharSequence title) {\n        if (mTvTitle != null) {\n            mTvTitle.setText(title);\n        } else {\n            getToolbar().setTitle(title);\n            setSupportActionBar(getToolbar());\n        }\n    }\n\n    /**\n     * the toolbar of this Activity\n     * @return support.v7.widget.Toolbar.\n     */\n    public Toolbar getToolbar() {\n        return (Toolbar) findViewById(R.id.toolbar);\n    }\n    \n    /**\n     * is show back icon,default is none。\n     * you can override the function in subclass and return to true show the back icon\n     * @return\n     */\n    protected boolean isShowBacking() {\n        return true;\n    }\n}\n```\n最后我们可以在子Activity中去使用toolbar了。\n我们让MainActivity继承BaseActivity,并在布局文件中添加一个button，切布局文件中没有添加标题栏，布局文件的代码就不再贴出了。然后 重写isShowBacing()方法，使其返回false，隐藏MainActivity的回退键。\n代码如下：\n```\npublic class MainActivity extends BaseActivity {\n    @BindView(R.id.btn)\n    Button mBtn1;\n    @Override\n    protected int getLayoutId() {\n        return R.layout.activity_main;\n    }\n\t\n\t @Override\n    protected boolean isShowBacking() {\n        return false;\n    }\n\n@OnClick({R.id.btn})\n    public void Onclick(View view){\n        switch (view.getId()){\n            case R.id.btn:\n                startActivity(new Intent(this,TestActivity.class));\n                break;\n        }\n    }\n}\n```\n创建TestActivity并继承BaseActivity，TestActivity的布局文件中不添加任何view。然后在TestActivity中给toolbar设置内容，如下：\n\n```\npublic class TestActivity extends BaseActivity {\n\n    @Override\n    protected int getLayoutId() {\n        return R.layout.activity_test;\n    }\n\n    @Override\n    protected void init() {\n        getToolbarTitle().setText(\"中间标题\");\n        getSubTitle().setText(\"右边标题\");\n        Toolbar toolbar = getToolbar();\n        toolbar.setLogo(R.mipmap.ic_launcher);\n        toolbar.setNavigationIcon(R.drawable.back_white);\n    }\n}\n```\n效果如下图所示\n\n\n![](https://raw.githubusercontent.com/zhpanvip/Resource/master/image/0701.jfif)\n","slug":"7.BaseActivity中封装通用的Toolbar","published":1,"updated":"2020-08-29T17:40:07.347Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckegm5ns2000ldwozaixw7o57","content":"<p>之前写过一篇关于如何使用Toolbar的文章，最近在搭建新项目时对Toolbar做了封装。封装的预期目标是只在BaseActivity中引入Toolbar，然后子Activity通过继承BaseActivity就能显示Toolbar。接下来就看看如何实现这样的功能。<br>因为我们使用toolbar作为titlebar，因此首先需要去掉Actionbar。在style文件下修改默认Theme的parent为Theme.AppCompat.Light.NoActionBar便可以去掉默认的Actionbar，如下：</p>\n<pre><code class=\"hljs xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">style</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;AppTheme&quot;</span> <span class=\"hljs-attr\">parent</span>=<span class=\"hljs-string\">&quot;Theme.AppCompat.Light.NoActionBar&quot;</span>&gt;</span>\n<span class=\"xml\">    <span class=\"hljs-comment\">&lt;!-- Customize your theme here. --&gt;</span></span>\n<span class=\"xml\">    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">item</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;colorPrimary&quot;</span>&gt;</span>@color/colorPrimary<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">item</span>&gt;</span></span>\n<span class=\"xml\">    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">item</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;colorPrimaryDark&quot;</span>&gt;</span>@color/colorPrimaryDark<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">item</span>&gt;</span></span>\n<span class=\"xml\">    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">item</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;colorAccent&quot;</span>&gt;</span>@color/colorAccent<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">item</span>&gt;</span></span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">style</span>&gt;</span></code></pre>\n\n<p>然后定义一个toolbar_layout的xml文件，在toolbar中加入俩个TextView作为标题和子标题，如下：</p>\n<pre><code class=\"hljs xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">android.support.v7.widget.Toolbar</span></span>\n<span class=\"hljs-tag\">    <span class=\"hljs-attr\">xmlns:android</span>=<span class=\"hljs-string\">&quot;http://schemas.android.com/apk/res/android&quot;</span></span>\n<span class=\"hljs-tag\">    <span class=\"hljs-attr\">android:id</span>=<span class=\"hljs-string\">&quot;@+id/toolbar&quot;</span></span>\n<span class=\"hljs-tag\">    <span class=\"hljs-attr\">android:layout_width</span>=<span class=\"hljs-string\">&quot;match_parent&quot;</span></span>\n<span class=\"hljs-tag\">    <span class=\"hljs-attr\">android:layout_height</span>=<span class=\"hljs-string\">&quot;wrap_content&quot;</span></span>\n<span class=\"hljs-tag\">    <span class=\"hljs-attr\">android:background</span>=<span class=\"hljs-string\">&quot;@color/colorPrimary&quot;</span></span>\n<span class=\"hljs-tag\">    <span class=\"hljs-attr\">android:minHeight</span>=<span class=\"hljs-string\">&quot;?attr/actionBarSize&quot;</span>&gt;</span>\n    <span class=\"hljs-comment\">&lt;!--自定义toolbar的title 和subtitle --&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">TextView</span></span>\n<span class=\"hljs-tag\">        <span class=\"hljs-attr\">android:id</span>=<span class=\"hljs-string\">&quot;@+id/tv_right&quot;</span></span>\n<span class=\"hljs-tag\">        <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">&quot;@style/TextAppearance.AppCompat.Widget.ActionBar.Subtitle&quot;</span></span>\n<span class=\"hljs-tag\">        <span class=\"hljs-attr\">android:layout_width</span>=<span class=\"hljs-string\">&quot;wrap_content&quot;</span></span>\n<span class=\"hljs-tag\">        <span class=\"hljs-attr\">android:layout_height</span>=<span class=\"hljs-string\">&quot;wrap_content&quot;</span></span>\n<span class=\"hljs-tag\">        <span class=\"hljs-attr\">android:maxLines</span>=<span class=\"hljs-string\">&quot;1&quot;</span></span>\n<span class=\"hljs-tag\">        <span class=\"hljs-attr\">android:textColor</span>=<span class=\"hljs-string\">&quot;@color/white&quot;</span></span>\n<span class=\"hljs-tag\">        <span class=\"hljs-attr\">android:text</span>=<span class=\"hljs-string\">&quot;right&quot;</span></span>\n<span class=\"hljs-tag\">        <span class=\"hljs-attr\">android:paddingRight</span>=<span class=\"hljs-string\">&quot;10dp&quot;</span></span>\n<span class=\"hljs-tag\">        <span class=\"hljs-attr\">android:layout_gravity</span>=<span class=\"hljs-string\">&quot;right&quot;</span> /&gt;</span>\n\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">TextView</span></span>\n<span class=\"hljs-tag\">        <span class=\"hljs-attr\">android:id</span>=<span class=\"hljs-string\">&quot;@+id/tv_title&quot;</span></span>\n<span class=\"hljs-tag\">        <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">&quot;@style/TextAppearance.AppCompat.Widget.ActionBar.Title&quot;</span></span>\n<span class=\"hljs-tag\">        <span class=\"hljs-attr\">android:layout_width</span>=<span class=\"hljs-string\">&quot;wrap_content&quot;</span></span>\n<span class=\"hljs-tag\">        <span class=\"hljs-attr\">android:layout_height</span>=<span class=\"hljs-string\">&quot;wrap_content&quot;</span></span>\n<span class=\"hljs-tag\">        <span class=\"hljs-attr\">android:lines</span>=<span class=\"hljs-string\">&quot;1&quot;</span></span>\n<span class=\"hljs-tag\">        <span class=\"hljs-attr\">android:ellipsize</span>=<span class=\"hljs-string\">&quot;end&quot;</span></span>\n<span class=\"hljs-tag\">        <span class=\"hljs-attr\">android:text</span>=<span class=\"hljs-string\">&quot;title&quot;</span></span>\n<span class=\"hljs-tag\">        <span class=\"hljs-attr\">android:scrollHorizontally</span>=<span class=\"hljs-string\">&quot;true&quot;</span></span>\n<span class=\"hljs-tag\">        <span class=\"hljs-attr\">android:textColor</span>=<span class=\"hljs-string\">&quot;@color/white&quot;</span></span>\n<span class=\"hljs-tag\">        <span class=\"hljs-attr\">android:layout_gravity</span>=<span class=\"hljs-string\">&quot;center&quot;</span> /&gt;</span>\n\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">android.support.v7.widget.Toolbar</span>&gt;</span></code></pre>\n<p>接着在BaseActivity的布局文件中include进toolbar_layout，如下：</p>\n<pre><code class=\"hljs xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">LinearLayout</span> <span class=\"hljs-attr\">xmlns:android</span>=<span class=\"hljs-string\">&quot;http://schemas.android.com/apk/res/android&quot;</span></span>\n<span class=\"hljs-tag\">    <span class=\"hljs-attr\">android:layout_width</span>=<span class=\"hljs-string\">&quot;match_parent&quot;</span></span>\n<span class=\"hljs-tag\">    <span class=\"hljs-attr\">android:layout_height</span>=<span class=\"hljs-string\">&quot;wrap_content&quot;</span>&gt;</span>\n\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">include</span> <span class=\"hljs-attr\">layout</span>=<span class=\"hljs-string\">&quot;@layout/toolbar_layout&quot;</span>/&gt;</span>\n\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">LinearLayout</span>&gt;</span>\n</code></pre>\n<p>这样BaseActivity中就可以正常显示出Toolbar了。那么如何实现子Activity继承BaseActivity而显示toolbar呢？其实我们可以在BaseActivity中做文章。<br>首先在BaseActivity中声明一个LinearLayout,然后把BaseActivity的布局文件添加到该LinearLayout中。我们知道子Activity通过setContentView()方法来关联布局文件，因此我们可以在BaseActivity中去重写setContentView()方法，在重写的setContentView中把子类的布局文件也添加到事先声明的LinearLayout中，接下来应该解决如何将这个LinearLayout与Activity关联。查阅相关资料可以知道，可以通过 findViewById(android.R.id.content)拿到window的ViewGroup然后将刚才声明的LinearLayout添加到这个ViewGroup中，这样就可以在子Activity中显示出BaseActivity中的Toolbar了。（具体原因可以查阅android.R.id.content和 DecorView）代码如下：</p>\n<pre><code class=\"hljs smali\">public<span class=\"hljs-keyword\"> abstract</span> class BaseActivity extends AppCompatActivity&#123;\n     //the container of this activity layout<span class=\"hljs-built_in\"> and </span>sub-activity layout\n   <span class=\"hljs-keyword\"> private</span> <span class=\"hljs-class\">LinearLayout parentLinearLayout;</span>\n    \n    @Override\n   <span class=\"hljs-keyword\"> public</span> void onCreate(Bundle savedInstanceState) &#123;\n        super.onCreate(savedInstanceState);\n        initContentView(R.layout.activity_base);\n        setContentView(getLayoutId());\n        initToolBar();\n        init();\n    &#125;\n//  overwrite the function in<span class=\"hljs-built_in\"> sub-activity </span>and<span class=\"hljs-built_in\"> return </span>the layout id of<span class=\"hljs-built_in\"> sub-activity </span>  \n<span class=\"hljs-keyword\"> protected</span><span class=\"hljs-keyword\"> abstract</span><span class=\"hljs-built_in\"> int </span>getLayoutId();\n \n<span class=\"hljs-keyword\"> private</span> void initContentView(@LayoutRes<span class=\"hljs-built_in\"> int </span>layoutResID) &#123;\n        ViewGroup viewGroup = (ViewGroup) findViewById(android.R.id.content);\n        viewGroup.removeAllViews();\n        parentLinearLayout =<span class=\"hljs-built_in\"> new </span>LinearLayout(this);\n        parentLinearLayout.setOrientation(<span class=\"hljs-class\">LinearLayout.VERTICAL);</span>\n\t\t// <span class=\"hljs-built_in\"> add </span>parentLinearLayout in viewGroup\n        viewGroup.addView(parent<span class=\"hljs-class\">LinearLayout);</span>\n        // <span class=\"hljs-built_in\"> add </span>the layout of BaseActivity in parentLinearLayout\n        LayoutInflater.from(this).inflate(layoutResID, parent<span class=\"hljs-class\">LinearLayout, true);</span>\n    &#125;\n   /**\n     * @param layoutResID  layout id of sub-activity\n     */\n    @Override\n   <span class=\"hljs-keyword\"> public</span> void setContentView(@LayoutRes<span class=\"hljs-built_in\"> int </span>layoutResID) &#123;\n        //  added the<span class=\"hljs-built_in\"> sub-activity </span>layout id in parentLinearLayout\n        LayoutInflater.from(this).inflate(layoutResID, parent<span class=\"hljs-class\">LinearLayout, true);</span>\n\n    &#125;\n&#125;\n</code></pre>\n<p>上述代码通过initContentView()方法将BaseActivity中的布局文件添加到了声明的parentLinearLayout中，通过setContentView()方法将子Activity的布局也添加到了parentLinearLayout中，然后又将parentLinearLayout添加到了viewGroup中实现了Activity与布局文件的关联。至此我们完成了第一步，使子Activity可以显示出BaseActivity中的Toolbar布局。<br>接下来，我们需要在BaseActivity中对Toolbar进行封装，使其能够更加方便的在子Activity中使用。比如添加toolbar回退键的监听，添加是否显示回退键的方法等。完整的BaseActivity如下：</p>\n<pre><code class=\"hljs reasonml\">public abstract <span class=\"hljs-keyword\">class</span> BaseActivity extends AppCompatActivity&#123;\n    <span class=\"hljs-comment\">//the container of this activity layout and sub-activity layout </span>\n    <span class=\"hljs-keyword\">private</span> LinearLayout parentLinearLayout;\n    <span class=\"hljs-keyword\">private</span> TextView mTvTitle;\n    <span class=\"hljs-keyword\">private</span> TextView mTvRight;\n    <span class=\"hljs-keyword\">private</span> Toolbar mToolbar;\n    @Override\n    public void on<span class=\"hljs-constructor\">Create(Bundle <span class=\"hljs-params\">savedInstanceState</span>)</span> &#123;\n        super.on<span class=\"hljs-constructor\">Create(<span class=\"hljs-params\">savedInstanceState</span>)</span>;\n        init<span class=\"hljs-constructor\">ContentView(R.<span class=\"hljs-params\">layout</span>.<span class=\"hljs-params\">activity_base</span>)</span>;\n\t      \n        set<span class=\"hljs-constructor\">ContentView(<span class=\"hljs-params\">getLayoutId</span>()</span>);\n        init<span class=\"hljs-constructor\">ToolBar()</span>;\n        set<span class=\"hljs-constructor\">BackIcon()</span>;\n        init<span class=\"hljs-literal\">()</span>;\n    &#125;\n<span class=\"hljs-comment\">//  overwrite the function in sub-activity and return the layout id of sub-activity </span>\n protected abstract <span class=\"hljs-built_in\">int</span> get<span class=\"hljs-constructor\">LayoutId()</span>;\n\n <span class=\"hljs-keyword\">private</span> void init<span class=\"hljs-constructor\">ContentView(@LayoutRes <span class=\"hljs-params\">int</span> <span class=\"hljs-params\">layoutResID</span>)</span> &#123;\n        ViewGroup viewGroup = (ViewGroup) find<span class=\"hljs-constructor\">ViewById(<span class=\"hljs-params\">android</span>.R.<span class=\"hljs-params\">id</span>.<span class=\"hljs-params\">content</span>)</span>;\n        viewGroup.remove<span class=\"hljs-constructor\">AllViews()</span>;\n        parentLinearLayout = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-constructor\">LinearLayout(<span class=\"hljs-params\">this</span>)</span>;\n        parentLinearLayout.set<span class=\"hljs-constructor\">Orientation(LinearLayout.VERTICAL)</span>;\n        viewGroup.add<span class=\"hljs-constructor\">View(<span class=\"hljs-params\">parentLinearLayout</span>)</span>;\n        <span class=\"hljs-comment\">//  add the layout of BaseActivity in parentLinearLayout</span>\n        <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">LayoutInflater</span>.</span></span>from(this).inflate(layoutResID, parentLinearLayout, <span class=\"hljs-literal\">true</span>);\n    &#125;\n   <span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">     * @param layoutResID  the layout id of sub Activity</span>\n<span class=\"hljs-comment\">     */</span>\n    @Override\n    public void set<span class=\"hljs-constructor\">ContentView(@LayoutRes <span class=\"hljs-params\">int</span> <span class=\"hljs-params\">layoutResID</span>)</span> &#123;\n        <span class=\"hljs-comment\">//  added the sub-activity layout id in parentLinearLayout</span>\n        <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">LayoutInflater</span>.</span></span>from(this).inflate(layoutResID, parentLinearLayout, <span class=\"hljs-literal\">true</span>);\n\n    &#125;\n\n<span class=\"hljs-keyword\">private</span> void set<span class=\"hljs-constructor\">BackIcon()</span>&#123;\n        <span class=\"hljs-keyword\">if</span> (null != get<span class=\"hljs-constructor\">Toolbar()</span><span class=\"hljs-operator\"> &amp;&amp; </span>is<span class=\"hljs-constructor\">ShowBacking()</span>) &#123;\n            get<span class=\"hljs-constructor\">Toolbar()</span>.set<span class=\"hljs-constructor\">NavigationIcon(R.<span class=\"hljs-params\">drawable</span>.<span class=\"hljs-params\">icon_back</span>)</span>;\n            get<span class=\"hljs-constructor\">Toolbar()</span>.set<span class=\"hljs-constructor\">NavigationOnClickListener((<span class=\"hljs-params\">v</span>)</span> -&gt; on<span class=\"hljs-constructor\">BackPressed()</span>);\n        &#125;\n    &#125;\n\n    <span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">     * @return TextView in center</span>\n<span class=\"hljs-comment\">     */</span>\n    public TextView get<span class=\"hljs-constructor\">ToolbarTitle()</span> &#123;\n        return mTvTitle;\n    &#125;\n\n    <span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">     * @return TextView on the right</span>\n<span class=\"hljs-comment\">     */</span>\n    public TextView get<span class=\"hljs-constructor\">SubTitle()</span> &#123;\n        return mTvRight;\n    &#125;\n\n    <span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">     * set Title</span>\n<span class=\"hljs-comment\">     * @param title</span>\n<span class=\"hljs-comment\">     */</span>\n    public void set<span class=\"hljs-constructor\">ToolBarTitle(CharSequence <span class=\"hljs-params\">title</span>)</span> &#123;\n        <span class=\"hljs-keyword\">if</span> (mTvTitle != null) &#123;\n            mTvTitle.set<span class=\"hljs-constructor\">Text(<span class=\"hljs-params\">title</span>)</span>;\n        &#125; <span class=\"hljs-keyword\">else</span> &#123;\n            get<span class=\"hljs-constructor\">Toolbar()</span>.set<span class=\"hljs-constructor\">Title(<span class=\"hljs-params\">title</span>)</span>;\n            set<span class=\"hljs-constructor\">SupportActionBar(<span class=\"hljs-params\">getToolbar</span>()</span>);\n        &#125;\n    &#125;\n\n    <span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">     * the toolbar of this Activity</span>\n<span class=\"hljs-comment\">     * @return support.v7.widget.Toolbar.</span>\n<span class=\"hljs-comment\">     */</span>\n    public Toolbar get<span class=\"hljs-constructor\">Toolbar()</span> &#123;\n        return (Toolbar) find<span class=\"hljs-constructor\">ViewById(R.<span class=\"hljs-params\">id</span>.<span class=\"hljs-params\">toolbar</span>)</span>;\n    &#125;\n    \n    <span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">     * is show back icon,default is none。</span>\n<span class=\"hljs-comment\">     * you can override the function in subclass and return to true show the back icon</span>\n<span class=\"hljs-comment\">     * @return</span>\n<span class=\"hljs-comment\">     */</span>\n    protected boolean is<span class=\"hljs-constructor\">ShowBacking()</span> &#123;\n        return <span class=\"hljs-literal\">true</span>;\n    &#125;\n&#125;</code></pre>\n<p>最后我们可以在子Activity中去使用toolbar了。<br>我们让MainActivity继承BaseActivity,并在布局文件中添加一个button，切布局文件中没有添加标题栏，布局文件的代码就不再贴出了。然后 重写isShowBacing()方法，使其返回false，隐藏MainActivity的回退键。<br>代码如下：</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MainActivity</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">BaseActivity</span> </span>&#123;\n    <span class=\"hljs-meta\">@BindView(R.id.btn)</span>\n    Button mBtn1;\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">getLayoutId</span><span class=\"hljs-params\">()</span> </span>&#123;\n        <span class=\"hljs-keyword\">return</span> R.layout.activity_main;\n    &#125;\n\t\n\t <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">isShowBacking</span><span class=\"hljs-params\">()</span> </span>&#123;\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>;\n    &#125;\n\n<span class=\"hljs-meta\">@OnClick(&#123;R.id.btn&#125;)</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Onclick</span><span class=\"hljs-params\">(View view)</span></span>&#123;\n        <span class=\"hljs-keyword\">switch</span> (view.getId())&#123;\n            <span class=\"hljs-keyword\">case</span> R.id.btn:\n                startActivity(<span class=\"hljs-keyword\">new</span> Intent(<span class=\"hljs-keyword\">this</span>,TestActivity.class));\n                <span class=\"hljs-keyword\">break</span>;\n        &#125;\n    &#125;\n&#125;</code></pre>\n<p>创建TestActivity并继承BaseActivity，TestActivity的布局文件中不添加任何view。然后在TestActivity中给toolbar设置内容，如下：</p>\n<pre><code class=\"hljs scala\">public <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">TestActivity</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">BaseActivity</span> </span>&#123;\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-keyword\">protected</span> int getLayoutId() &#123;\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-type\">R</span>.layout.activity_test;\n    &#125;\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-keyword\">protected</span> void init() &#123;\n        getToolbarTitle().setText(<span class=\"hljs-string\">&quot;中间标题&quot;</span>);\n        getSubTitle().setText(<span class=\"hljs-string\">&quot;右边标题&quot;</span>);\n        <span class=\"hljs-type\">Toolbar</span> toolbar = getToolbar();\n        toolbar.setLogo(<span class=\"hljs-type\">R</span>.mipmap.ic_launcher);\n        toolbar.setNavigationIcon(<span class=\"hljs-type\">R</span>.drawable.back_white);\n    &#125;\n&#125;</code></pre>\n<p>效果如下图所示</p>\n<p><img src=\"https://raw.githubusercontent.com/zhpanvip/Resource/master/image/0701.jfif\"></p>\n","site":{"data":{"fluid_config":{"favicon":"/img/favicon.png","apple_touch_icon":"/img/favicon.png","title_join_string":" - ","force_https":false,"highlight":{"enable":true,"style":"Github Gist","bg_color":false,"copy_btn":true},"fun_features":{"typing":{"enable":true,"typeSpeed":70,"cursorChar":"|","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"mouse_click":{"enable":false,"style":"values"}},"dark_mode":{"enable":true,"default":"auto"},"color":{"body_bg_color":"#eee","body_bg_color_dark":"#181c27","navbar_bg_color":"#2f4154","navbar_bg_color_dark":"#1f3144","navbar_text_color":"#fff","navbar_text_color_dark":"#d0d0d0","text_color":"#3c4858","text_color_dark":"#c4c6c9","sec_text_color":"#718096","sec_text_color_dark":"#a7a9ad","post_text_color":"#2c3e50","post_text_color_dark":"#c4c6c9","post_heading_color":"#1a202c","post_heading_color_dark":"#c4c6c9","post_link_color":"#0366d6","post_link_color_dark":"#1589e9","link_hover_color":"#30a9de","link_hover_color_dark":"#30a9de","link_hover_bg_color":"#f8f9fa","link_hover_bg_color_dark":"#364151","board_color":"#fff","board_color_dark":"#252d38"},"font":{"font_size":"16px","font_family":null,"code_font_size":"85%"},"custom_js":null,"custom_css":null,"custom_html":"","web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"tajs":null,"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}},"lazyload":{"enable":true,"onlypost":false},"daovoice":{"enable":false,"appid":""},"aplayer":{"enable":false,"autoplay":false,"loop":"all","order":"random","theme":"#b7daff","songs":[{"name":"name","artist":"artist","url":"/songs/test.mp3","cover":"/img/cover.jpg"},{"name":"name","artist":"artist","url":"https://...url.mp3","cover":"https://...cover.jpg"}]},"version":{"check":false},"navbar":{"blog_title":"zhangpan","ground_glass":{"enable":false,"px":3,"alpha":0.7},"menu":[{"key":"home","link":"/","icon":"iconfont icon-home-fill"},{"key":"archive","link":"/archives/","icon":"iconfont icon-archive-fill"},{"key":"category","link":"/categories/","icon":"iconfont icon-category-fill"},{"key":"tag","link":"/tags/","icon":"iconfont icon-tags-fill"},{"key":"about","link":"/about/","icon":"iconfont icon-user-fill"}]},"search":{"enable":true,"path":"/local-search.xml","generate_path":"/local-search.xml","field":"post","content":true},"scroll_down_arrow":{"enable":true,"banner_height_limit":90,"scroll_after_turning_page":true},"banner_parallax":true,"footer":{"statistics":{"enable":false,"source":"busuanzi","pv_format":"总访问量 {} 次","uv_format":"总访客数 {} 人"},"beian":{"enable":false,"icp_text":"京ICP证123456号","police_text":"京公网安备12345678号","police_code":12345678,"police_icon":"/img/police_beian.png"}},"scroll_top_arrow":{"enable":true},"index":{"banner_img":"/img/default.png","banner_img_height":100,"banner_mask_alpha":0.3,"post_default_img":"","slogan":{"enable":true,"text":"Talk is cheap, show me the code."},"auto_excerpt":{"enable":true},"post_url_target":"_self","post_meta":{"date":true,"category":true,"tag":true}},"page":{"banner_img":"/img/default.png","banner_img_height":60,"banner_mask_alpha":0.3},"post":{"banner_img":"/img/default.png","banner_img_height":70,"banner_mask_alpha":0.3,"meta":{"date":{"enable":true,"format":"LL a"},"wordcount":{"enable":true,"format":"{} 字"},"min2read":{"enable":true,"format":"{} 分钟","words":100},"views":{"enable":false,"source":"busuanzi","format":"{} 次"}},"updated":{"enable":false,"content":"本文最后更新于：","relative":false},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"copyright":{"enable":true,"content":"本博客所有文章除特别声明外，均采用 <a href=\"https://creativecommons.org/licenses/by-sa/4.0/deed.zh\" rel=\"nofollow noopener\">CC BY-SA 4.0 协议</a> ，转载请注明出处！ <h5>开源库推荐</h5> <a href=\"https://github.com/zhpanvip/BannerViewPager\">1.BannerViewPager</a> <p> 一个基于ViewPager2实现的具有强大功能的无限轮播库。支持多种页面切换效果和指示器样式。 </p>\n<a href=\"https://github.com/zhpanvip/viewpagerindicator\">2.ViewPagerIndicator</a> <p> 一个适用于ViewPager和ViewPager2的指示器，支持多种滑块样式及滑动模式 </p>"},"prev_next":{"enable":true},"custom":{"enable":false,"content":"<img src=\"https://octodex.github.com/images/jetpacktocat.png\" class=\"rounded mx-auto d-block mt-5\" style=\"width:150px; height:150px;\">"},"image_zoom":{"enable":true},"footnote":{"enable":true,"header":""},"math":{"enable":false,"specific":false,"engine":"mathjax"},"mermaid":{"enable":false,"specific":false,"options":{"theme":"default"}},"comments":{"enable":true,"type":"utterances"}},"utterances":{"repo":"zhpanvip/utterances-comment","issue_term":"pathname","label":"utterances","theme":"github-light","crossorigin":"anonymous"},"disqus":{"shortname":null,"disqusjs":false,"apikey":null},"gitalk":{"clientID":null,"clientSecret":null,"repo":null,"owner":null,"admin":["name"],"id":"location.pathname","language":"zh-CN","labels":["Gitalk"],"perPage":10,"pagerDirection":"last","distractionFreeMode":false,"createIssueManually":true},"valine":{"appid":"hXIROaIM5y9qnieojJRWP5hS","appkey":"y0f3w3aqd1MF7JL9ma4WECTy","placeholder":"说点什么","path":"window.location.pathname","avatar":"retro","meta":["nick","mail","link"],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"https://zhangpan.site"},"changyan":{"appid":"","appkey":""},"livere":{"uid":""},"archive":{"banner_img":"/img/bg_article.jpg","banner_img_height":60,"banner_mask_alpha":0.3,"subtitle":null},"category":{"banner_img":"/img/bg_default.png","banner_img_height":60,"banner_mask_alpha":0.3,"subtitle":null,"post_limit":10,"order_by":"-length"},"tag":{"banner_img":"/img/bg_label.jpg","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null,"tagcloud":{"min_font":15,"max_font":30,"unit":"px","start_color":"#BBBBEE","end_color":"#337ab7"}},"about":{"banner_img":"/img/bg_default.png","banner_img_height":60,"banner_mask_alpha":0.3,"subtitle":null,"avatar":"/img/avatar.png","name":"myname","introduce":"一句简短的介绍","icons":[{"class":"iconfont icon-github-fill","link":"https://github.com","tip":"GitHub"},{"class":"iconfont icon-douban-fill","link":"https://douban.com","tip":"豆瓣"},{"class":"iconfont icon-wechat-fill","qrcode":"/img/favicon.png"}]},"page404":{"banner_img":"/img/default.png","banner_img_height":85,"banner_mask_alpha":0.3,"subtitle":"Page not found"},"links":{"banner_img":"/img/default.png","banner_img_height":60,"banner_mask_alpha":0.3,"subtitle":null,"items":[{"title":"Fluid Docs","intro":"主题使用指南","link":"https://hexo.fluid-dev.com/docs/","image":"/img/favicon.png"},{"title":"Fluid Repo","intro":"主题 GitHub 仓库","link":"https://github.com/fluid-dev/hexo-theme-fluid","image":"/img/favicon.png"},{"title":"Fluid Example","intro":"主题操作示例","link":"https://hexo.fluid-dev.com/docs/example/","image":"/img/favicon.png"}]}}}},"excerpt":"","more":"<p>之前写过一篇关于如何使用Toolbar的文章，最近在搭建新项目时对Toolbar做了封装。封装的预期目标是只在BaseActivity中引入Toolbar，然后子Activity通过继承BaseActivity就能显示Toolbar。接下来就看看如何实现这样的功能。<br>因为我们使用toolbar作为titlebar，因此首先需要去掉Actionbar。在style文件下修改默认Theme的parent为Theme.AppCompat.Light.NoActionBar便可以去掉默认的Actionbar，如下：</p>\n<pre><code class=\"hljs xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">style</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;AppTheme&quot;</span> <span class=\"hljs-attr\">parent</span>=<span class=\"hljs-string\">&quot;Theme.AppCompat.Light.NoActionBar&quot;</span>&gt;</span>\n<span class=\"xml\">    <span class=\"hljs-comment\">&lt;!-- Customize your theme here. --&gt;</span></span>\n<span class=\"xml\">    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">item</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;colorPrimary&quot;</span>&gt;</span>@color/colorPrimary<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">item</span>&gt;</span></span>\n<span class=\"xml\">    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">item</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;colorPrimaryDark&quot;</span>&gt;</span>@color/colorPrimaryDark<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">item</span>&gt;</span></span>\n<span class=\"xml\">    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">item</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;colorAccent&quot;</span>&gt;</span>@color/colorAccent<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">item</span>&gt;</span></span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">style</span>&gt;</span></code></pre>\n\n<p>然后定义一个toolbar_layout的xml文件，在toolbar中加入俩个TextView作为标题和子标题，如下：</p>\n<pre><code class=\"hljs xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">android.support.v7.widget.Toolbar</span></span>\n<span class=\"hljs-tag\">    <span class=\"hljs-attr\">xmlns:android</span>=<span class=\"hljs-string\">&quot;http://schemas.android.com/apk/res/android&quot;</span></span>\n<span class=\"hljs-tag\">    <span class=\"hljs-attr\">android:id</span>=<span class=\"hljs-string\">&quot;@+id/toolbar&quot;</span></span>\n<span class=\"hljs-tag\">    <span class=\"hljs-attr\">android:layout_width</span>=<span class=\"hljs-string\">&quot;match_parent&quot;</span></span>\n<span class=\"hljs-tag\">    <span class=\"hljs-attr\">android:layout_height</span>=<span class=\"hljs-string\">&quot;wrap_content&quot;</span></span>\n<span class=\"hljs-tag\">    <span class=\"hljs-attr\">android:background</span>=<span class=\"hljs-string\">&quot;@color/colorPrimary&quot;</span></span>\n<span class=\"hljs-tag\">    <span class=\"hljs-attr\">android:minHeight</span>=<span class=\"hljs-string\">&quot;?attr/actionBarSize&quot;</span>&gt;</span>\n    <span class=\"hljs-comment\">&lt;!--自定义toolbar的title 和subtitle --&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">TextView</span></span>\n<span class=\"hljs-tag\">        <span class=\"hljs-attr\">android:id</span>=<span class=\"hljs-string\">&quot;@+id/tv_right&quot;</span></span>\n<span class=\"hljs-tag\">        <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">&quot;@style/TextAppearance.AppCompat.Widget.ActionBar.Subtitle&quot;</span></span>\n<span class=\"hljs-tag\">        <span class=\"hljs-attr\">android:layout_width</span>=<span class=\"hljs-string\">&quot;wrap_content&quot;</span></span>\n<span class=\"hljs-tag\">        <span class=\"hljs-attr\">android:layout_height</span>=<span class=\"hljs-string\">&quot;wrap_content&quot;</span></span>\n<span class=\"hljs-tag\">        <span class=\"hljs-attr\">android:maxLines</span>=<span class=\"hljs-string\">&quot;1&quot;</span></span>\n<span class=\"hljs-tag\">        <span class=\"hljs-attr\">android:textColor</span>=<span class=\"hljs-string\">&quot;@color/white&quot;</span></span>\n<span class=\"hljs-tag\">        <span class=\"hljs-attr\">android:text</span>=<span class=\"hljs-string\">&quot;right&quot;</span></span>\n<span class=\"hljs-tag\">        <span class=\"hljs-attr\">android:paddingRight</span>=<span class=\"hljs-string\">&quot;10dp&quot;</span></span>\n<span class=\"hljs-tag\">        <span class=\"hljs-attr\">android:layout_gravity</span>=<span class=\"hljs-string\">&quot;right&quot;</span> /&gt;</span>\n\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">TextView</span></span>\n<span class=\"hljs-tag\">        <span class=\"hljs-attr\">android:id</span>=<span class=\"hljs-string\">&quot;@+id/tv_title&quot;</span></span>\n<span class=\"hljs-tag\">        <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">&quot;@style/TextAppearance.AppCompat.Widget.ActionBar.Title&quot;</span></span>\n<span class=\"hljs-tag\">        <span class=\"hljs-attr\">android:layout_width</span>=<span class=\"hljs-string\">&quot;wrap_content&quot;</span></span>\n<span class=\"hljs-tag\">        <span class=\"hljs-attr\">android:layout_height</span>=<span class=\"hljs-string\">&quot;wrap_content&quot;</span></span>\n<span class=\"hljs-tag\">        <span class=\"hljs-attr\">android:lines</span>=<span class=\"hljs-string\">&quot;1&quot;</span></span>\n<span class=\"hljs-tag\">        <span class=\"hljs-attr\">android:ellipsize</span>=<span class=\"hljs-string\">&quot;end&quot;</span></span>\n<span class=\"hljs-tag\">        <span class=\"hljs-attr\">android:text</span>=<span class=\"hljs-string\">&quot;title&quot;</span></span>\n<span class=\"hljs-tag\">        <span class=\"hljs-attr\">android:scrollHorizontally</span>=<span class=\"hljs-string\">&quot;true&quot;</span></span>\n<span class=\"hljs-tag\">        <span class=\"hljs-attr\">android:textColor</span>=<span class=\"hljs-string\">&quot;@color/white&quot;</span></span>\n<span class=\"hljs-tag\">        <span class=\"hljs-attr\">android:layout_gravity</span>=<span class=\"hljs-string\">&quot;center&quot;</span> /&gt;</span>\n\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">android.support.v7.widget.Toolbar</span>&gt;</span></code></pre>\n<p>接着在BaseActivity的布局文件中include进toolbar_layout，如下：</p>\n<pre><code class=\"hljs xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">LinearLayout</span> <span class=\"hljs-attr\">xmlns:android</span>=<span class=\"hljs-string\">&quot;http://schemas.android.com/apk/res/android&quot;</span></span>\n<span class=\"hljs-tag\">    <span class=\"hljs-attr\">android:layout_width</span>=<span class=\"hljs-string\">&quot;match_parent&quot;</span></span>\n<span class=\"hljs-tag\">    <span class=\"hljs-attr\">android:layout_height</span>=<span class=\"hljs-string\">&quot;wrap_content&quot;</span>&gt;</span>\n\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">include</span> <span class=\"hljs-attr\">layout</span>=<span class=\"hljs-string\">&quot;@layout/toolbar_layout&quot;</span>/&gt;</span>\n\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">LinearLayout</span>&gt;</span>\n</code></pre>\n<p>这样BaseActivity中就可以正常显示出Toolbar了。那么如何实现子Activity继承BaseActivity而显示toolbar呢？其实我们可以在BaseActivity中做文章。<br>首先在BaseActivity中声明一个LinearLayout,然后把BaseActivity的布局文件添加到该LinearLayout中。我们知道子Activity通过setContentView()方法来关联布局文件，因此我们可以在BaseActivity中去重写setContentView()方法，在重写的setContentView中把子类的布局文件也添加到事先声明的LinearLayout中，接下来应该解决如何将这个LinearLayout与Activity关联。查阅相关资料可以知道，可以通过 findViewById(android.R.id.content)拿到window的ViewGroup然后将刚才声明的LinearLayout添加到这个ViewGroup中，这样就可以在子Activity中显示出BaseActivity中的Toolbar了。（具体原因可以查阅android.R.id.content和 DecorView）代码如下：</p>\n<pre><code class=\"hljs smali\">public<span class=\"hljs-keyword\"> abstract</span> class BaseActivity extends AppCompatActivity&#123;\n     //the container of this activity layout<span class=\"hljs-built_in\"> and </span>sub-activity layout\n   <span class=\"hljs-keyword\"> private</span> <span class=\"hljs-class\">LinearLayout parentLinearLayout;</span>\n    \n    @Override\n   <span class=\"hljs-keyword\"> public</span> void onCreate(Bundle savedInstanceState) &#123;\n        super.onCreate(savedInstanceState);\n        initContentView(R.layout.activity_base);\n        setContentView(getLayoutId());\n        initToolBar();\n        init();\n    &#125;\n//  overwrite the function in<span class=\"hljs-built_in\"> sub-activity </span>and<span class=\"hljs-built_in\"> return </span>the layout id of<span class=\"hljs-built_in\"> sub-activity </span>  \n<span class=\"hljs-keyword\"> protected</span><span class=\"hljs-keyword\"> abstract</span><span class=\"hljs-built_in\"> int </span>getLayoutId();\n \n<span class=\"hljs-keyword\"> private</span> void initContentView(@LayoutRes<span class=\"hljs-built_in\"> int </span>layoutResID) &#123;\n        ViewGroup viewGroup = (ViewGroup) findViewById(android.R.id.content);\n        viewGroup.removeAllViews();\n        parentLinearLayout =<span class=\"hljs-built_in\"> new </span>LinearLayout(this);\n        parentLinearLayout.setOrientation(<span class=\"hljs-class\">LinearLayout.VERTICAL);</span>\n\t\t// <span class=\"hljs-built_in\"> add </span>parentLinearLayout in viewGroup\n        viewGroup.addView(parent<span class=\"hljs-class\">LinearLayout);</span>\n        // <span class=\"hljs-built_in\"> add </span>the layout of BaseActivity in parentLinearLayout\n        LayoutInflater.from(this).inflate(layoutResID, parent<span class=\"hljs-class\">LinearLayout, true);</span>\n    &#125;\n   /**\n     * @param layoutResID  layout id of sub-activity\n     */\n    @Override\n   <span class=\"hljs-keyword\"> public</span> void setContentView(@LayoutRes<span class=\"hljs-built_in\"> int </span>layoutResID) &#123;\n        //  added the<span class=\"hljs-built_in\"> sub-activity </span>layout id in parentLinearLayout\n        LayoutInflater.from(this).inflate(layoutResID, parent<span class=\"hljs-class\">LinearLayout, true);</span>\n\n    &#125;\n&#125;\n</code></pre>\n<p>上述代码通过initContentView()方法将BaseActivity中的布局文件添加到了声明的parentLinearLayout中，通过setContentView()方法将子Activity的布局也添加到了parentLinearLayout中，然后又将parentLinearLayout添加到了viewGroup中实现了Activity与布局文件的关联。至此我们完成了第一步，使子Activity可以显示出BaseActivity中的Toolbar布局。<br>接下来，我们需要在BaseActivity中对Toolbar进行封装，使其能够更加方便的在子Activity中使用。比如添加toolbar回退键的监听，添加是否显示回退键的方法等。完整的BaseActivity如下：</p>\n<pre><code class=\"hljs reasonml\">public abstract <span class=\"hljs-keyword\">class</span> BaseActivity extends AppCompatActivity&#123;\n    <span class=\"hljs-comment\">//the container of this activity layout and sub-activity layout </span>\n    <span class=\"hljs-keyword\">private</span> LinearLayout parentLinearLayout;\n    <span class=\"hljs-keyword\">private</span> TextView mTvTitle;\n    <span class=\"hljs-keyword\">private</span> TextView mTvRight;\n    <span class=\"hljs-keyword\">private</span> Toolbar mToolbar;\n    @Override\n    public void on<span class=\"hljs-constructor\">Create(Bundle <span class=\"hljs-params\">savedInstanceState</span>)</span> &#123;\n        super.on<span class=\"hljs-constructor\">Create(<span class=\"hljs-params\">savedInstanceState</span>)</span>;\n        init<span class=\"hljs-constructor\">ContentView(R.<span class=\"hljs-params\">layout</span>.<span class=\"hljs-params\">activity_base</span>)</span>;\n\t      \n        set<span class=\"hljs-constructor\">ContentView(<span class=\"hljs-params\">getLayoutId</span>()</span>);\n        init<span class=\"hljs-constructor\">ToolBar()</span>;\n        set<span class=\"hljs-constructor\">BackIcon()</span>;\n        init<span class=\"hljs-literal\">()</span>;\n    &#125;\n<span class=\"hljs-comment\">//  overwrite the function in sub-activity and return the layout id of sub-activity </span>\n protected abstract <span class=\"hljs-built_in\">int</span> get<span class=\"hljs-constructor\">LayoutId()</span>;\n\n <span class=\"hljs-keyword\">private</span> void init<span class=\"hljs-constructor\">ContentView(@LayoutRes <span class=\"hljs-params\">int</span> <span class=\"hljs-params\">layoutResID</span>)</span> &#123;\n        ViewGroup viewGroup = (ViewGroup) find<span class=\"hljs-constructor\">ViewById(<span class=\"hljs-params\">android</span>.R.<span class=\"hljs-params\">id</span>.<span class=\"hljs-params\">content</span>)</span>;\n        viewGroup.remove<span class=\"hljs-constructor\">AllViews()</span>;\n        parentLinearLayout = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-constructor\">LinearLayout(<span class=\"hljs-params\">this</span>)</span>;\n        parentLinearLayout.set<span class=\"hljs-constructor\">Orientation(LinearLayout.VERTICAL)</span>;\n        viewGroup.add<span class=\"hljs-constructor\">View(<span class=\"hljs-params\">parentLinearLayout</span>)</span>;\n        <span class=\"hljs-comment\">//  add the layout of BaseActivity in parentLinearLayout</span>\n        <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">LayoutInflater</span>.</span></span>from(this).inflate(layoutResID, parentLinearLayout, <span class=\"hljs-literal\">true</span>);\n    &#125;\n   <span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">     * @param layoutResID  the layout id of sub Activity</span>\n<span class=\"hljs-comment\">     */</span>\n    @Override\n    public void set<span class=\"hljs-constructor\">ContentView(@LayoutRes <span class=\"hljs-params\">int</span> <span class=\"hljs-params\">layoutResID</span>)</span> &#123;\n        <span class=\"hljs-comment\">//  added the sub-activity layout id in parentLinearLayout</span>\n        <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">LayoutInflater</span>.</span></span>from(this).inflate(layoutResID, parentLinearLayout, <span class=\"hljs-literal\">true</span>);\n\n    &#125;\n\n<span class=\"hljs-keyword\">private</span> void set<span class=\"hljs-constructor\">BackIcon()</span>&#123;\n        <span class=\"hljs-keyword\">if</span> (null != get<span class=\"hljs-constructor\">Toolbar()</span><span class=\"hljs-operator\"> &amp;&amp; </span>is<span class=\"hljs-constructor\">ShowBacking()</span>) &#123;\n            get<span class=\"hljs-constructor\">Toolbar()</span>.set<span class=\"hljs-constructor\">NavigationIcon(R.<span class=\"hljs-params\">drawable</span>.<span class=\"hljs-params\">icon_back</span>)</span>;\n            get<span class=\"hljs-constructor\">Toolbar()</span>.set<span class=\"hljs-constructor\">NavigationOnClickListener((<span class=\"hljs-params\">v</span>)</span> -&gt; on<span class=\"hljs-constructor\">BackPressed()</span>);\n        &#125;\n    &#125;\n\n    <span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">     * @return TextView in center</span>\n<span class=\"hljs-comment\">     */</span>\n    public TextView get<span class=\"hljs-constructor\">ToolbarTitle()</span> &#123;\n        return mTvTitle;\n    &#125;\n\n    <span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">     * @return TextView on the right</span>\n<span class=\"hljs-comment\">     */</span>\n    public TextView get<span class=\"hljs-constructor\">SubTitle()</span> &#123;\n        return mTvRight;\n    &#125;\n\n    <span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">     * set Title</span>\n<span class=\"hljs-comment\">     * @param title</span>\n<span class=\"hljs-comment\">     */</span>\n    public void set<span class=\"hljs-constructor\">ToolBarTitle(CharSequence <span class=\"hljs-params\">title</span>)</span> &#123;\n        <span class=\"hljs-keyword\">if</span> (mTvTitle != null) &#123;\n            mTvTitle.set<span class=\"hljs-constructor\">Text(<span class=\"hljs-params\">title</span>)</span>;\n        &#125; <span class=\"hljs-keyword\">else</span> &#123;\n            get<span class=\"hljs-constructor\">Toolbar()</span>.set<span class=\"hljs-constructor\">Title(<span class=\"hljs-params\">title</span>)</span>;\n            set<span class=\"hljs-constructor\">SupportActionBar(<span class=\"hljs-params\">getToolbar</span>()</span>);\n        &#125;\n    &#125;\n\n    <span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">     * the toolbar of this Activity</span>\n<span class=\"hljs-comment\">     * @return support.v7.widget.Toolbar.</span>\n<span class=\"hljs-comment\">     */</span>\n    public Toolbar get<span class=\"hljs-constructor\">Toolbar()</span> &#123;\n        return (Toolbar) find<span class=\"hljs-constructor\">ViewById(R.<span class=\"hljs-params\">id</span>.<span class=\"hljs-params\">toolbar</span>)</span>;\n    &#125;\n    \n    <span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">     * is show back icon,default is none。</span>\n<span class=\"hljs-comment\">     * you can override the function in subclass and return to true show the back icon</span>\n<span class=\"hljs-comment\">     * @return</span>\n<span class=\"hljs-comment\">     */</span>\n    protected boolean is<span class=\"hljs-constructor\">ShowBacking()</span> &#123;\n        return <span class=\"hljs-literal\">true</span>;\n    &#125;\n&#125;</code></pre>\n<p>最后我们可以在子Activity中去使用toolbar了。<br>我们让MainActivity继承BaseActivity,并在布局文件中添加一个button，切布局文件中没有添加标题栏，布局文件的代码就不再贴出了。然后 重写isShowBacing()方法，使其返回false，隐藏MainActivity的回退键。<br>代码如下：</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MainActivity</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">BaseActivity</span> </span>&#123;\n    <span class=\"hljs-meta\">@BindView(R.id.btn)</span>\n    Button mBtn1;\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">getLayoutId</span><span class=\"hljs-params\">()</span> </span>&#123;\n        <span class=\"hljs-keyword\">return</span> R.layout.activity_main;\n    &#125;\n\t\n\t <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">isShowBacking</span><span class=\"hljs-params\">()</span> </span>&#123;\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>;\n    &#125;\n\n<span class=\"hljs-meta\">@OnClick(&#123;R.id.btn&#125;)</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Onclick</span><span class=\"hljs-params\">(View view)</span></span>&#123;\n        <span class=\"hljs-keyword\">switch</span> (view.getId())&#123;\n            <span class=\"hljs-keyword\">case</span> R.id.btn:\n                startActivity(<span class=\"hljs-keyword\">new</span> Intent(<span class=\"hljs-keyword\">this</span>,TestActivity.class));\n                <span class=\"hljs-keyword\">break</span>;\n        &#125;\n    &#125;\n&#125;</code></pre>\n<p>创建TestActivity并继承BaseActivity，TestActivity的布局文件中不添加任何view。然后在TestActivity中给toolbar设置内容，如下：</p>\n<pre><code class=\"hljs scala\">public <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">TestActivity</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">BaseActivity</span> </span>&#123;\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-keyword\">protected</span> int getLayoutId() &#123;\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-type\">R</span>.layout.activity_test;\n    &#125;\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-keyword\">protected</span> void init() &#123;\n        getToolbarTitle().setText(<span class=\"hljs-string\">&quot;中间标题&quot;</span>);\n        getSubTitle().setText(<span class=\"hljs-string\">&quot;右边标题&quot;</span>);\n        <span class=\"hljs-type\">Toolbar</span> toolbar = getToolbar();\n        toolbar.setLogo(<span class=\"hljs-type\">R</span>.mipmap.ic_launcher);\n        toolbar.setNavigationIcon(<span class=\"hljs-type\">R</span>.drawable.back_white);\n    &#125;\n&#125;</code></pre>\n<p>效果如下图所示</p>\n<p><img src=\"https://raw.githubusercontent.com/zhpanvip/Resource/master/image/0701.jfif\"></p>\n"},{"title":"RxJava+Retrofit之token自动刷新（二）","date":"2017-07-26T16:34:26.000Z","_content":"\n[ 上篇文章](http://blog.csdn.net/qq_20521573/article/details/70991850)主要对Retrofit做了封装，使之使用起来更加方便。在之前的封装中token过期再次刷新token后需要手动调用之前的请求，这种处理方式不够优雅，因此，在原有的基础上，本篇文章将基于上篇文章的封装并优化Token验证机制。使之能够实现过期自动刷新并重新调用请求。\n接下来将通过以下几个小节来学习如何实现token验证。\n -  为什么要引入token机制\n -  token机制的验证流程\n -  RxJava+Retrofit封装实现token验证\n \n\n# 一、为什么引入token机制\n\n# 1.token是什么？\n\ntoken意为令牌，通常是由客户端携带IMEI/Mac到服务器，服务器根据客户端的IMEI/Mac生成一段字符串并返回给客户端，并为其设置有效期。以此作为客户端和服务端交互的令牌。客户端每次请求都会携带token到服务器来代替用户名和密码。服务端验证token有效后则返回数据给客户端，否则返回特定的错误码给客户端。客户端根据错误码去做相应的处理。\n\n## 2.那么为什么引入token机制呢？\n主要有以下两个原因：\n（1）保证安全性。如果不引入token机制，那么我们每次请求数据都要携带用户名和密码。也就是每次请求数据用户名和密码都会在网络上传输。这样大大增加了安全风险，很容易被黑客截取。因此引入token机制也一定程度上保证了安全性。\n（2）减小服务器压力。在引入token机制前，我们需要通过用户名和密码到服务器去验证用户身份是否合法。服务器认证用户名和密码是一个查询操作，如果用户量大，那么就会相应增加服务器的压力。而引入token机制后，服务器就可以将token作为一个用户的唯一标识来验证用户身份是否合法。这样可以大大减少服务器的压力。\n\n## 二、token机制的验证流程\n\ntoken的验证流程并非唯一的，至于使用怎样的验证流程可以自行确定。本文中采用OAuth2.0协议实现token验证机制。\n主要步骤如下：\n 1. 通过用户名和密码登录成功获取token和refreshToken并保存到本地。\n 2. token的有效期为2小时，refreshToken的有效期为15天。\n 3. 每次网络请求都需要带上token，而不必带上refreshToken。\n 4. 如果服务器端判断token过期，则返回对应的错误码，客户端判断错误码后调用刷新token接口,重新获取token和refreshToken并存储。\n 5. 如果连续15天未使用app或者用户修改了密码，则refreshToken过期，需要重新登录获取token和refreshToken。\n\n# 三、RxJava+Retrofit封装实现token自动刷新\n\n有了以上两节的基础，我们就可以来自己实现token机制的验证了。在这里我们使用[上篇文章](http://blog.csdn.net/qq_20521573/article/details/70991850)中封装的RxJava和Retrofit来实现token机制。\n\n## 1.登录认证，获取token和refresh_token\n\n登录时我们需要两个参数：用户名username、密码password以及appkey作为一个唯一id，每次登录成功服务器会返回token和refreshToken。登录请求的实体类LoginRequest如下：\n\n```\npublic class LoginRequest extends BaseRequest{\n    private String userId;\n    private String password;\n}\n```\n接下来我们就可以来调用登录接口获取token了。登录成功后我们可将token和refreshToekn存储到本地。以提交表单为例，代码如下：\n\n```\npublic void login() {\n         Map<String, Object> map = MapUtils.entityToMap(new BaseRequest());\n        map.put(\"userId\",\"123456\");\n        map.put(\"password\",\"123123\");\n        IdeaApi.getApiService()\n                .login(map)\n                .subscribeOn(Schedulers.io())\n                .compose(activity.<BasicResponse<LoginResponse>>bindToLifecycle())\n                .observeOn(AndroidSchedulers.mainThread())\n                .subscribe(new DefaultObserver<BasicResponse<LoginResponse>>(activity) {\n                    @Override\n                    public void onSuccess(BasicResponse<LoginResponse> response) {\n                        LoginResponse results = response.getResults();\n                        ToastUtils.show(\"登录成功！获取到token\" + results.getToken() + \",可以存储到本地了\");\n                        /**\n                         * 可以将这些数据存储到User中，User存储到本地数据库\n                         */\n                        SharedPreferencesHelper.put(activity, \"token\", results.getToken());\n                        SharedPreferencesHelper.put(activity, \"refresh_token\", results.getRefresh_token());\n                        SharedPreferencesHelper.put(activity, \"refresh_secret\", results.getRefresh_secret());\n                    }\n                });\n    }\n```\n\n\n\n\n## 2.明确需求，抛出异常\n由于token的有效期较短，因此我们需要经常刷新token来保证token的有效性。在请求网络的时候如果token过期或者无效服务器会给我们返回对应的错误码。我们需要根据状态码来判断token是否失效。如果失效则调用刷新token接口重新获取token。如果refreshToekn也过期那么我们需要重新登录。\n\n现在，我们的需求是要实现token过期后自动刷新，刷新成功后自动调用原来的请求，如果refreshToken也过期，则退出登录。基于此，我们可以联想到RxJava的retryWhen操作符，我们可以通过retryWhen操作符判断token过期并自动刷新。\n\n那么，接下来我们首要任务是如何判断token和refreshToken过期。还记得上篇文章中我们修改GsonResponseBodyConverter类来根据后台响应码来获取data中的数据。显然在此处判断token是否过期是比较合适的。接下来看GsonResponseBodyConverter中的代码：\n\n```\n   @Override\n    public Object convert(ResponseBody value) throws IOException {\n        try {\n            BasicResponse response = (BasicResponse) adapter.fromJson(value.charStream());\n            if (response.getCode() == SUCCESS) {\n                if (response.getData() == null)\n                    throw new ServerNoDataException(0, \"\");\n                return response.getData();\n            } else if (response.getCode() == TOKEN_EXPIRED) {\n                throw new TokenExpiredException(response.getCode(), response.getMessage());\n            } else if (response.getCode() == REFRESH_TOKEN_EXPIRED) {\n                throw new RefreshTokenExpiredException(response.getCode(), response.getMessage());\n            } else if (response.getCode() != SUCCESS) {\n                // 特定 API 的错误，在相应的 DefaultObserver 的 onError 的方法中进行处理\n                throw new ServerResponseException(response.getCode(), response.getMessage());\n            }\n        } finally {\n            value.close();\n        }\n        return null;\n    } \n```\n上面代码中我们自定义了几个异常，在判断对应的错误码后抛出对应的异常。此处我们可以着重关心下TokenExpiredException和RefreshTokenExpiredException，分别代表了token过期和refreshToken过期。\n\n## 3.添加代理，实现token过期自动刷新\n因为几乎所有的请求都需要验证token是否过期，因此需要做统一处理。我们可以采用代理类来对Retrofit的API做统一的代理处理。代码如下：\n```\npublic class IdeaApiProxy implements IGlobalManager {\n    @SuppressWarnings(\"unchecked\")\n    public <T> T getApiService(Class<T> tClass,String baseUrl) {\n        T t = RetrofitService.getRetrofitBuilder(baseUrl)\n                .build().create(tClass);\n        return (T) Proxy.newProxyInstance(tClass.getClassLoader(), new Class<?>[] { tClass }, new ProxyHandler(t, this));\n    }\n\n    @Override\n    public void exitLogin() {\n\n    }\n}\n```\n这样，我们就需要通过IdeaApiProxy 中的getApiService方法来创建API请求。其中的ProxyHandler则是实现了InvocationHandler。ProxyHandler类是我们处理token自动刷新的核心类。思想就是针对 method 的调用，做以 retryWhen 的包装，在retryWhen 中获取相应的异常信息来做处理，看 retryWhen 的代码：\n\n```\n  @Override\n    public Object invoke(Object proxy, final Method method, final Object[] args) throws Throwable {\n        return Observable.just(true).flatMap(new Function<Object, ObservableSource<?>>() {\n            @Override\n            public ObservableSource<?> apply(Object o) throws Exception {\n                try {\n                    try {\n                        if (mIsTokenNeedRefresh) {\n                            updateMethodToken(method, args);\n                        }\n                        return (Observable<?>) method.invoke(mProxyObject, args);\n                    } catch (InvocationTargetException e) {\n                        e.printStackTrace();\n                    }\n                } catch (IllegalAccessException e) {\n                    e.printStackTrace();\n                }\n                return null;\n            }\n        }).retryWhen(new Function<Observable<Throwable>, ObservableSource<?>>() {\n            @Override\n            public ObservableSource<?> apply(Observable<Throwable> observable) throws Exception {\n                return observable.flatMap(new Function<Throwable, ObservableSource<?>>() {\n                    @Override\n                    public ObservableSource<?> apply(Throwable throwable) throws Exception {\n                        if (throwable instanceof TokenExpiredException) {// token过期\n                            return refreshTokenWhenTokenInvalid();\n                        } else if (throwable instanceof RefreshTokenExpiredException) {\n                            // RefreshToken过期，执行退出登录的操作。\n                            mGlobalManager.logout();\n                            return Observable.error(throwable);\n                        }\n                        return Observable.error(throwable);\n                    }\n                });\n            }\n        });\n    }\n```\n这里针对 token 过期的 TokenExpiredException的异常，执行刷新 token 的操作，刷新 token 的操作则是直接调用 Retrofit 的方法，而不需要走代理了。另外它必须是个同步的代码块，一起来看refreshTokenWhenTokenInvalid方法中的代码：\n\n```\nprivate Observable<?> refreshTokenWhenTokenInvalid() {\n        synchronized (ProxyHandler.class) {\n            // Have refreshed the token successfully in the valid time.\n            if (new Date().getTime() - tokenChangedTime < REFRESH_TOKEN_VALID_TIME) {   //  防止重复刷新token\n                mIsTokenNeedRefresh = true;\n                return Observable.just(true);\n            } else {\n                Map<String, Object> map = MapUtils.entityToMap(new BaseRequestData());\n                RetrofitHelper.getApiService()\n                        .refreshToken(map)\n                        //.observeOn(AndroidSchedulers.mainThread())\n                        .subscribe(new DefaultObserver<RefreshTokenResponse>() {\n                            @Override\n                            public void onSuccess(RefreshTokenResponse response) {\n                                if (response != null) {\n                                    // 保存数据到本地\n                                    mGlobalManager.tokenRefresh(response);\n                                    mIsTokenNeedRefresh = true;\n                                    tokenChangedTime = new Date().getTime();\n                                }\n                            }\n\n                            @Override\n                            public void onError(Throwable e) {\n                                super.onError(e);\n                                mRefreshTokenError = e;\n                            }\n                        });\n                if (mRefreshTokenError != null) {\n                    return Observable.error(mRefreshTokenError);\n                } else {\n                    return Observable.just(true);\n                }\n            }\n        }\n    }\n```\n\n## 4.刷新token成功后替换旧的token\n当token刷新成功之后，我们将旧的token替换掉呢？java8中的method类，已经支持了动态获取方法名称，而之前的Java版本则是不支持的。那这里怎么办呢？通过看retrofit的调用，可以知道retrofit是可以将接口中的方法转换成API请求，并需要封装参数的。那就需要看一下Retrofit是如何实现的呢？最后发现重头戏是在Retrofit对每个方法添加的@interface的注解，通过Method类中的getParameterAnnotations来进行获取，主要的代码实现如下：\n\n```\nprivate void updateMethodToken(Method method, Object[] args) {\n        ServerKey serverKey = RealmDatabaseHelper.queryFirstFrom(ServerKey.class);\n        String token = serverKey.getToken();\n        if (mIsTokenNeedRefresh && !TextUtils.isEmpty(token)) {\n            Annotation[][] annotationsArray = method.getParameterAnnotations();\n            Annotation[] annotations;\n            if (annotationsArray != null && annotationsArray.length > 0) {\n                for (int i = 0; i < annotationsArray.length; i++) {\n                    annotations = annotationsArray[i];\n                    for (Annotation annotation : annotations) {\n                        if (annotation instanceof FieldMap||annotation instanceof QueryMap) {// 以Map方式提交表单\n                            if (args[i] instanceof Map)\n                                ((Map<String, Object>) args[i]).put(TOKEN, token);\n                        } else if (annotation instanceof Query) {\n                            if (TOKEN.equals(((Query) annotation).value())) {\n                                args[i] = token;\n                            }\n                        } else if (annotation instanceof Field) {\n                            if (TOKEN.equals(((Field) annotation).value())) {\n                                args[i] = token;\n                            }\n                        }else if(annotation instanceof Part){   //  上传文件\n                            if (TOKEN.equals(((Part) annotation).value())) {\n                                RequestBody tokenBody = RequestBody.create(MediaType.parse(\"multipart/form-data\"), token);\n                                args[i] = tokenBody;\n                            }\n                        }else if(annotation instanceof Body){// Post提交json数据\n                            if(args[i] instanceof BaseRequest){\n                                BaseRequest requestData= (BaseRequest) args[i];\n                                requestData.setToken(token);\n                                args[i]=requestData;\n                            }\n                        }\n                    }\n                }\n            }\n            mIsTokenNeedRefresh = false;\n        }\n    }\n```\n这里我们遍历所有的token字段，并将其替换成新的token。但上述方法仅仅适用于get请求和post请求以表单格式提交。如果是post请求且提交格式为json可以自行添加。另外此种方法不适用于token放在请求头的方式。\n\n[（一）Rxjava2+Retrofit完美封装](https://blog.csdn.net/qq_20521573/article/details/70991850)\n[（二）Rxjava2+Retrofit之Token自动刷新](https://blog.csdn.net/qq_20521573/article/details/76100558)\n[（三）Rxjava2+Retrofit实现文件上传与下载](https://blog.csdn.net/qq_20521573/article/details/78356747)\n\n参考\n[RxJava+Retrofit实现全局过期token自动刷新Demo篇](http://alighters.com/blog/2016/08/22/rxjava-plus-retrofitshi-xian-zhi-demo/) \n\n\n[源码下载](https://github.com/zhpanvip/Retrofit2/tree/token)\n\n","source":"_posts/9.RxJava-Retrofit之token自动刷新（二）.md","raw":"---\ntitle: RxJava+Retrofit之token自动刷新（二）\ndate: 2017-07-27 00:34:26\ntags: \n- RxJava\n- token\n---\n\n[ 上篇文章](http://blog.csdn.net/qq_20521573/article/details/70991850)主要对Retrofit做了封装，使之使用起来更加方便。在之前的封装中token过期再次刷新token后需要手动调用之前的请求，这种处理方式不够优雅，因此，在原有的基础上，本篇文章将基于上篇文章的封装并优化Token验证机制。使之能够实现过期自动刷新并重新调用请求。\n接下来将通过以下几个小节来学习如何实现token验证。\n -  为什么要引入token机制\n -  token机制的验证流程\n -  RxJava+Retrofit封装实现token验证\n \n\n# 一、为什么引入token机制\n\n# 1.token是什么？\n\ntoken意为令牌，通常是由客户端携带IMEI/Mac到服务器，服务器根据客户端的IMEI/Mac生成一段字符串并返回给客户端，并为其设置有效期。以此作为客户端和服务端交互的令牌。客户端每次请求都会携带token到服务器来代替用户名和密码。服务端验证token有效后则返回数据给客户端，否则返回特定的错误码给客户端。客户端根据错误码去做相应的处理。\n\n## 2.那么为什么引入token机制呢？\n主要有以下两个原因：\n（1）保证安全性。如果不引入token机制，那么我们每次请求数据都要携带用户名和密码。也就是每次请求数据用户名和密码都会在网络上传输。这样大大增加了安全风险，很容易被黑客截取。因此引入token机制也一定程度上保证了安全性。\n（2）减小服务器压力。在引入token机制前，我们需要通过用户名和密码到服务器去验证用户身份是否合法。服务器认证用户名和密码是一个查询操作，如果用户量大，那么就会相应增加服务器的压力。而引入token机制后，服务器就可以将token作为一个用户的唯一标识来验证用户身份是否合法。这样可以大大减少服务器的压力。\n\n## 二、token机制的验证流程\n\ntoken的验证流程并非唯一的，至于使用怎样的验证流程可以自行确定。本文中采用OAuth2.0协议实现token验证机制。\n主要步骤如下：\n 1. 通过用户名和密码登录成功获取token和refreshToken并保存到本地。\n 2. token的有效期为2小时，refreshToken的有效期为15天。\n 3. 每次网络请求都需要带上token，而不必带上refreshToken。\n 4. 如果服务器端判断token过期，则返回对应的错误码，客户端判断错误码后调用刷新token接口,重新获取token和refreshToken并存储。\n 5. 如果连续15天未使用app或者用户修改了密码，则refreshToken过期，需要重新登录获取token和refreshToken。\n\n# 三、RxJava+Retrofit封装实现token自动刷新\n\n有了以上两节的基础，我们就可以来自己实现token机制的验证了。在这里我们使用[上篇文章](http://blog.csdn.net/qq_20521573/article/details/70991850)中封装的RxJava和Retrofit来实现token机制。\n\n## 1.登录认证，获取token和refresh_token\n\n登录时我们需要两个参数：用户名username、密码password以及appkey作为一个唯一id，每次登录成功服务器会返回token和refreshToken。登录请求的实体类LoginRequest如下：\n\n```\npublic class LoginRequest extends BaseRequest{\n    private String userId;\n    private String password;\n}\n```\n接下来我们就可以来调用登录接口获取token了。登录成功后我们可将token和refreshToekn存储到本地。以提交表单为例，代码如下：\n\n```\npublic void login() {\n         Map<String, Object> map = MapUtils.entityToMap(new BaseRequest());\n        map.put(\"userId\",\"123456\");\n        map.put(\"password\",\"123123\");\n        IdeaApi.getApiService()\n                .login(map)\n                .subscribeOn(Schedulers.io())\n                .compose(activity.<BasicResponse<LoginResponse>>bindToLifecycle())\n                .observeOn(AndroidSchedulers.mainThread())\n                .subscribe(new DefaultObserver<BasicResponse<LoginResponse>>(activity) {\n                    @Override\n                    public void onSuccess(BasicResponse<LoginResponse> response) {\n                        LoginResponse results = response.getResults();\n                        ToastUtils.show(\"登录成功！获取到token\" + results.getToken() + \",可以存储到本地了\");\n                        /**\n                         * 可以将这些数据存储到User中，User存储到本地数据库\n                         */\n                        SharedPreferencesHelper.put(activity, \"token\", results.getToken());\n                        SharedPreferencesHelper.put(activity, \"refresh_token\", results.getRefresh_token());\n                        SharedPreferencesHelper.put(activity, \"refresh_secret\", results.getRefresh_secret());\n                    }\n                });\n    }\n```\n\n\n\n\n## 2.明确需求，抛出异常\n由于token的有效期较短，因此我们需要经常刷新token来保证token的有效性。在请求网络的时候如果token过期或者无效服务器会给我们返回对应的错误码。我们需要根据状态码来判断token是否失效。如果失效则调用刷新token接口重新获取token。如果refreshToekn也过期那么我们需要重新登录。\n\n现在，我们的需求是要实现token过期后自动刷新，刷新成功后自动调用原来的请求，如果refreshToken也过期，则退出登录。基于此，我们可以联想到RxJava的retryWhen操作符，我们可以通过retryWhen操作符判断token过期并自动刷新。\n\n那么，接下来我们首要任务是如何判断token和refreshToken过期。还记得上篇文章中我们修改GsonResponseBodyConverter类来根据后台响应码来获取data中的数据。显然在此处判断token是否过期是比较合适的。接下来看GsonResponseBodyConverter中的代码：\n\n```\n   @Override\n    public Object convert(ResponseBody value) throws IOException {\n        try {\n            BasicResponse response = (BasicResponse) adapter.fromJson(value.charStream());\n            if (response.getCode() == SUCCESS) {\n                if (response.getData() == null)\n                    throw new ServerNoDataException(0, \"\");\n                return response.getData();\n            } else if (response.getCode() == TOKEN_EXPIRED) {\n                throw new TokenExpiredException(response.getCode(), response.getMessage());\n            } else if (response.getCode() == REFRESH_TOKEN_EXPIRED) {\n                throw new RefreshTokenExpiredException(response.getCode(), response.getMessage());\n            } else if (response.getCode() != SUCCESS) {\n                // 特定 API 的错误，在相应的 DefaultObserver 的 onError 的方法中进行处理\n                throw new ServerResponseException(response.getCode(), response.getMessage());\n            }\n        } finally {\n            value.close();\n        }\n        return null;\n    } \n```\n上面代码中我们自定义了几个异常，在判断对应的错误码后抛出对应的异常。此处我们可以着重关心下TokenExpiredException和RefreshTokenExpiredException，分别代表了token过期和refreshToken过期。\n\n## 3.添加代理，实现token过期自动刷新\n因为几乎所有的请求都需要验证token是否过期，因此需要做统一处理。我们可以采用代理类来对Retrofit的API做统一的代理处理。代码如下：\n```\npublic class IdeaApiProxy implements IGlobalManager {\n    @SuppressWarnings(\"unchecked\")\n    public <T> T getApiService(Class<T> tClass,String baseUrl) {\n        T t = RetrofitService.getRetrofitBuilder(baseUrl)\n                .build().create(tClass);\n        return (T) Proxy.newProxyInstance(tClass.getClassLoader(), new Class<?>[] { tClass }, new ProxyHandler(t, this));\n    }\n\n    @Override\n    public void exitLogin() {\n\n    }\n}\n```\n这样，我们就需要通过IdeaApiProxy 中的getApiService方法来创建API请求。其中的ProxyHandler则是实现了InvocationHandler。ProxyHandler类是我们处理token自动刷新的核心类。思想就是针对 method 的调用，做以 retryWhen 的包装，在retryWhen 中获取相应的异常信息来做处理，看 retryWhen 的代码：\n\n```\n  @Override\n    public Object invoke(Object proxy, final Method method, final Object[] args) throws Throwable {\n        return Observable.just(true).flatMap(new Function<Object, ObservableSource<?>>() {\n            @Override\n            public ObservableSource<?> apply(Object o) throws Exception {\n                try {\n                    try {\n                        if (mIsTokenNeedRefresh) {\n                            updateMethodToken(method, args);\n                        }\n                        return (Observable<?>) method.invoke(mProxyObject, args);\n                    } catch (InvocationTargetException e) {\n                        e.printStackTrace();\n                    }\n                } catch (IllegalAccessException e) {\n                    e.printStackTrace();\n                }\n                return null;\n            }\n        }).retryWhen(new Function<Observable<Throwable>, ObservableSource<?>>() {\n            @Override\n            public ObservableSource<?> apply(Observable<Throwable> observable) throws Exception {\n                return observable.flatMap(new Function<Throwable, ObservableSource<?>>() {\n                    @Override\n                    public ObservableSource<?> apply(Throwable throwable) throws Exception {\n                        if (throwable instanceof TokenExpiredException) {// token过期\n                            return refreshTokenWhenTokenInvalid();\n                        } else if (throwable instanceof RefreshTokenExpiredException) {\n                            // RefreshToken过期，执行退出登录的操作。\n                            mGlobalManager.logout();\n                            return Observable.error(throwable);\n                        }\n                        return Observable.error(throwable);\n                    }\n                });\n            }\n        });\n    }\n```\n这里针对 token 过期的 TokenExpiredException的异常，执行刷新 token 的操作，刷新 token 的操作则是直接调用 Retrofit 的方法，而不需要走代理了。另外它必须是个同步的代码块，一起来看refreshTokenWhenTokenInvalid方法中的代码：\n\n```\nprivate Observable<?> refreshTokenWhenTokenInvalid() {\n        synchronized (ProxyHandler.class) {\n            // Have refreshed the token successfully in the valid time.\n            if (new Date().getTime() - tokenChangedTime < REFRESH_TOKEN_VALID_TIME) {   //  防止重复刷新token\n                mIsTokenNeedRefresh = true;\n                return Observable.just(true);\n            } else {\n                Map<String, Object> map = MapUtils.entityToMap(new BaseRequestData());\n                RetrofitHelper.getApiService()\n                        .refreshToken(map)\n                        //.observeOn(AndroidSchedulers.mainThread())\n                        .subscribe(new DefaultObserver<RefreshTokenResponse>() {\n                            @Override\n                            public void onSuccess(RefreshTokenResponse response) {\n                                if (response != null) {\n                                    // 保存数据到本地\n                                    mGlobalManager.tokenRefresh(response);\n                                    mIsTokenNeedRefresh = true;\n                                    tokenChangedTime = new Date().getTime();\n                                }\n                            }\n\n                            @Override\n                            public void onError(Throwable e) {\n                                super.onError(e);\n                                mRefreshTokenError = e;\n                            }\n                        });\n                if (mRefreshTokenError != null) {\n                    return Observable.error(mRefreshTokenError);\n                } else {\n                    return Observable.just(true);\n                }\n            }\n        }\n    }\n```\n\n## 4.刷新token成功后替换旧的token\n当token刷新成功之后，我们将旧的token替换掉呢？java8中的method类，已经支持了动态获取方法名称，而之前的Java版本则是不支持的。那这里怎么办呢？通过看retrofit的调用，可以知道retrofit是可以将接口中的方法转换成API请求，并需要封装参数的。那就需要看一下Retrofit是如何实现的呢？最后发现重头戏是在Retrofit对每个方法添加的@interface的注解，通过Method类中的getParameterAnnotations来进行获取，主要的代码实现如下：\n\n```\nprivate void updateMethodToken(Method method, Object[] args) {\n        ServerKey serverKey = RealmDatabaseHelper.queryFirstFrom(ServerKey.class);\n        String token = serverKey.getToken();\n        if (mIsTokenNeedRefresh && !TextUtils.isEmpty(token)) {\n            Annotation[][] annotationsArray = method.getParameterAnnotations();\n            Annotation[] annotations;\n            if (annotationsArray != null && annotationsArray.length > 0) {\n                for (int i = 0; i < annotationsArray.length; i++) {\n                    annotations = annotationsArray[i];\n                    for (Annotation annotation : annotations) {\n                        if (annotation instanceof FieldMap||annotation instanceof QueryMap) {// 以Map方式提交表单\n                            if (args[i] instanceof Map)\n                                ((Map<String, Object>) args[i]).put(TOKEN, token);\n                        } else if (annotation instanceof Query) {\n                            if (TOKEN.equals(((Query) annotation).value())) {\n                                args[i] = token;\n                            }\n                        } else if (annotation instanceof Field) {\n                            if (TOKEN.equals(((Field) annotation).value())) {\n                                args[i] = token;\n                            }\n                        }else if(annotation instanceof Part){   //  上传文件\n                            if (TOKEN.equals(((Part) annotation).value())) {\n                                RequestBody tokenBody = RequestBody.create(MediaType.parse(\"multipart/form-data\"), token);\n                                args[i] = tokenBody;\n                            }\n                        }else if(annotation instanceof Body){// Post提交json数据\n                            if(args[i] instanceof BaseRequest){\n                                BaseRequest requestData= (BaseRequest) args[i];\n                                requestData.setToken(token);\n                                args[i]=requestData;\n                            }\n                        }\n                    }\n                }\n            }\n            mIsTokenNeedRefresh = false;\n        }\n    }\n```\n这里我们遍历所有的token字段，并将其替换成新的token。但上述方法仅仅适用于get请求和post请求以表单格式提交。如果是post请求且提交格式为json可以自行添加。另外此种方法不适用于token放在请求头的方式。\n\n[（一）Rxjava2+Retrofit完美封装](https://blog.csdn.net/qq_20521573/article/details/70991850)\n[（二）Rxjava2+Retrofit之Token自动刷新](https://blog.csdn.net/qq_20521573/article/details/76100558)\n[（三）Rxjava2+Retrofit实现文件上传与下载](https://blog.csdn.net/qq_20521573/article/details/78356747)\n\n参考\n[RxJava+Retrofit实现全局过期token自动刷新Demo篇](http://alighters.com/blog/2016/08/22/rxjava-plus-retrofitshi-xian-zhi-demo/) \n\n\n[源码下载](https://github.com/zhpanvip/Retrofit2/tree/token)\n\n","slug":"9.RxJava-Retrofit之token自动刷新（二）","published":1,"updated":"2020-08-29T18:02:12.728Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckegm5ns2000ndwozai4re9j3","content":"<p><a href=\"http://blog.csdn.net/qq_20521573/article/details/70991850\"> 上篇文章</a>主要对Retrofit做了封装，使之使用起来更加方便。在之前的封装中token过期再次刷新token后需要手动调用之前的请求，这种处理方式不够优雅，因此，在原有的基础上，本篇文章将基于上篇文章的封装并优化Token验证机制。使之能够实现过期自动刷新并重新调用请求。<br>接下来将通过以下几个小节来学习如何实现token验证。</p>\n<ul>\n<li>为什么要引入token机制</li>\n<li>token机制的验证流程</li>\n<li>RxJava+Retrofit封装实现token验证</li>\n</ul>\n<h1 id=\"一、为什么引入token机制\"><a href=\"#一、为什么引入token机制\" class=\"headerlink\" title=\"一、为什么引入token机制\"></a>一、为什么引入token机制</h1><h1 id=\"1-token是什么？\"><a href=\"#1-token是什么？\" class=\"headerlink\" title=\"1.token是什么？\"></a>1.token是什么？</h1><p>token意为令牌，通常是由客户端携带IMEI/Mac到服务器，服务器根据客户端的IMEI/Mac生成一段字符串并返回给客户端，并为其设置有效期。以此作为客户端和服务端交互的令牌。客户端每次请求都会携带token到服务器来代替用户名和密码。服务端验证token有效后则返回数据给客户端，否则返回特定的错误码给客户端。客户端根据错误码去做相应的处理。</p>\n<h2 id=\"2-那么为什么引入token机制呢？\"><a href=\"#2-那么为什么引入token机制呢？\" class=\"headerlink\" title=\"2.那么为什么引入token机制呢？\"></a>2.那么为什么引入token机制呢？</h2><p>主要有以下两个原因：<br>（1）保证安全性。如果不引入token机制，那么我们每次请求数据都要携带用户名和密码。也就是每次请求数据用户名和密码都会在网络上传输。这样大大增加了安全风险，很容易被黑客截取。因此引入token机制也一定程度上保证了安全性。<br>（2）减小服务器压力。在引入token机制前，我们需要通过用户名和密码到服务器去验证用户身份是否合法。服务器认证用户名和密码是一个查询操作，如果用户量大，那么就会相应增加服务器的压力。而引入token机制后，服务器就可以将token作为一个用户的唯一标识来验证用户身份是否合法。这样可以大大减少服务器的压力。</p>\n<h2 id=\"二、token机制的验证流程\"><a href=\"#二、token机制的验证流程\" class=\"headerlink\" title=\"二、token机制的验证流程\"></a>二、token机制的验证流程</h2><p>token的验证流程并非唯一的，至于使用怎样的验证流程可以自行确定。本文中采用OAuth2.0协议实现token验证机制。<br>主要步骤如下：</p>\n<ol>\n<li>通过用户名和密码登录成功获取token和refreshToken并保存到本地。</li>\n<li>token的有效期为2小时，refreshToken的有效期为15天。</li>\n<li>每次网络请求都需要带上token，而不必带上refreshToken。</li>\n<li>如果服务器端判断token过期，则返回对应的错误码，客户端判断错误码后调用刷新token接口,重新获取token和refreshToken并存储。</li>\n<li>如果连续15天未使用app或者用户修改了密码，则refreshToken过期，需要重新登录获取token和refreshToken。</li>\n</ol>\n<h1 id=\"三、RxJava-Retrofit封装实现token自动刷新\"><a href=\"#三、RxJava-Retrofit封装实现token自动刷新\" class=\"headerlink\" title=\"三、RxJava+Retrofit封装实现token自动刷新\"></a>三、RxJava+Retrofit封装实现token自动刷新</h1><p>有了以上两节的基础，我们就可以来自己实现token机制的验证了。在这里我们使用<a href=\"http://blog.csdn.net/qq_20521573/article/details/70991850\">上篇文章</a>中封装的RxJava和Retrofit来实现token机制。</p>\n<h2 id=\"1-登录认证，获取token和refresh-token\"><a href=\"#1-登录认证，获取token和refresh-token\" class=\"headerlink\" title=\"1.登录认证，获取token和refresh_token\"></a>1.登录认证，获取token和refresh_token</h2><p>登录时我们需要两个参数：用户名username、密码password以及appkey作为一个唯一id，每次登录成功服务器会返回token和refreshToken。登录请求的实体类LoginRequest如下：</p>\n<pre><code class=\"hljs scala\">public <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">LoginRequest</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">BaseRequest</span></span>&#123;\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-type\">String</span> userId;\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-type\">String</span> password;\n&#125;</code></pre>\n<p>接下来我们就可以来调用登录接口获取token了。登录成功后我们可将token和refreshToekn存储到本地。以提交表单为例，代码如下：</p>\n<pre><code class=\"hljs reasonml\">public void login<span class=\"hljs-literal\">()</span> &#123;\n         Map&lt;String, Object&gt; map = <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">MapUtils</span>.</span></span>entity<span class=\"hljs-constructor\">ToMap(<span class=\"hljs-params\">new</span> BaseRequest()</span>);\n        map.put(<span class=\"hljs-string\">&quot;userId&quot;</span>,<span class=\"hljs-string\">&quot;123456&quot;</span>);\n        map.put(<span class=\"hljs-string\">&quot;password&quot;</span>,<span class=\"hljs-string\">&quot;123123&quot;</span>);\n        <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">IdeaApi</span>.</span></span>get<span class=\"hljs-constructor\">ApiService()</span>\n                .login(map)\n                .subscribe<span class=\"hljs-constructor\">On(Schedulers.<span class=\"hljs-params\">io</span>()</span>)\n                .compose(activity.&lt;BasicResponse&lt;LoginResponse&gt;&gt;bind<span class=\"hljs-constructor\">ToLifecycle()</span>)\n                .observe<span class=\"hljs-constructor\">On(AndroidSchedulers.<span class=\"hljs-params\">mainThread</span>()</span>)\n                .subscribe(<span class=\"hljs-keyword\">new</span> DefaultObserver&lt;BasicResponse&lt;LoginResponse&gt;&gt;(activity) &#123;\n                    @Override\n                    public void on<span class=\"hljs-constructor\">Success(BasicResponse&lt;LoginResponse&gt; <span class=\"hljs-params\">response</span>)</span> &#123;\n                        LoginResponse results = response.get<span class=\"hljs-constructor\">Results()</span>;\n                        <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">ToastUtils</span>.</span></span>show(<span class=\"hljs-string\">&quot;登录成功！获取到token&quot;</span> + results.get<span class=\"hljs-constructor\">Token()</span> + <span class=\"hljs-string\">&quot;,可以存储到本地了&quot;</span>);\n                        <span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">                         * 可以将这些数据存储到User中，User存储到本地数据库</span>\n<span class=\"hljs-comment\">                         */</span>\n                        <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">SharedPreferencesHelper</span>.</span></span>put(activity, <span class=\"hljs-string\">&quot;token&quot;</span>, results.get<span class=\"hljs-constructor\">Token()</span>);\n                        <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">SharedPreferencesHelper</span>.</span></span>put(activity, <span class=\"hljs-string\">&quot;refresh_token&quot;</span>, results.get<span class=\"hljs-constructor\">Refresh_token()</span>);\n                        <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">SharedPreferencesHelper</span>.</span></span>put(activity, <span class=\"hljs-string\">&quot;refresh_secret&quot;</span>, results.get<span class=\"hljs-constructor\">Refresh_secret()</span>);\n                    &#125;\n                &#125;);\n    &#125;</code></pre>\n\n\n\n\n<h2 id=\"2-明确需求，抛出异常\"><a href=\"#2-明确需求，抛出异常\" class=\"headerlink\" title=\"2.明确需求，抛出异常\"></a>2.明确需求，抛出异常</h2><p>由于token的有效期较短，因此我们需要经常刷新token来保证token的有效性。在请求网络的时候如果token过期或者无效服务器会给我们返回对应的错误码。我们需要根据状态码来判断token是否失效。如果失效则调用刷新token接口重新获取token。如果refreshToekn也过期那么我们需要重新登录。</p>\n<p>现在，我们的需求是要实现token过期后自动刷新，刷新成功后自动调用原来的请求，如果refreshToken也过期，则退出登录。基于此，我们可以联想到RxJava的retryWhen操作符，我们可以通过retryWhen操作符判断token过期并自动刷新。</p>\n<p>那么，接下来我们首要任务是如何判断token和refreshToken过期。还记得上篇文章中我们修改GsonResponseBodyConverter类来根据后台响应码来获取data中的数据。显然在此处判断token是否过期是比较合适的。接下来看GsonResponseBodyConverter中的代码：</p>\n<pre><code class=\"hljs reasonml\">@Override\n public Object convert(ResponseBody value) throws IOException &#123;\n     <span class=\"hljs-keyword\">try</span> &#123;\n         BasicResponse response = (BasicResponse) adapter.from<span class=\"hljs-constructor\">Json(<span class=\"hljs-params\">value</span>.<span class=\"hljs-params\">charStream</span>()</span>);\n         <span class=\"hljs-keyword\">if</span> (response.get<span class=\"hljs-constructor\">Code()</span><span class=\"hljs-operator\"> == </span>SUCCESS) &#123;\n             <span class=\"hljs-keyword\">if</span> (response.get<span class=\"hljs-constructor\">Data()</span><span class=\"hljs-operator\"> == </span>null)\n                 throw <span class=\"hljs-keyword\">new</span> <span class=\"hljs-constructor\">ServerNoDataException(0, <span class=\"hljs-string\">&quot;&quot;</span>)</span>;\n             return response.get<span class=\"hljs-constructor\">Data()</span>;\n         &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (response.get<span class=\"hljs-constructor\">Code()</span><span class=\"hljs-operator\"> == </span>TOKEN_EXPIRED) &#123;\n             throw <span class=\"hljs-keyword\">new</span> <span class=\"hljs-constructor\">TokenExpiredException(<span class=\"hljs-params\">response</span>.<span class=\"hljs-params\">getCode</span>()</span>, response.get<span class=\"hljs-constructor\">Message()</span>);\n         &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (response.get<span class=\"hljs-constructor\">Code()</span><span class=\"hljs-operator\"> == </span>REFRESH_TOKEN_EXPIRED) &#123;\n             throw <span class=\"hljs-keyword\">new</span> <span class=\"hljs-constructor\">RefreshTokenExpiredException(<span class=\"hljs-params\">response</span>.<span class=\"hljs-params\">getCode</span>()</span>, response.get<span class=\"hljs-constructor\">Message()</span>);\n         &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (response.get<span class=\"hljs-constructor\">Code()</span> != SUCCESS) &#123;\n             <span class=\"hljs-comment\">// 特定 API 的错误，在相应的 DefaultObserver 的 onError 的方法中进行处理</span>\n             throw <span class=\"hljs-keyword\">new</span> <span class=\"hljs-constructor\">ServerResponseException(<span class=\"hljs-params\">response</span>.<span class=\"hljs-params\">getCode</span>()</span>, response.get<span class=\"hljs-constructor\">Message()</span>);\n         &#125;\n     &#125; finally &#123;\n         value.close<span class=\"hljs-literal\">()</span>;\n     &#125;\n     return null;\n &#125;</code></pre>\n<p>上面代码中我们自定义了几个异常，在判断对应的错误码后抛出对应的异常。此处我们可以着重关心下TokenExpiredException和RefreshTokenExpiredException，分别代表了token过期和refreshToken过期。</p>\n<h2 id=\"3-添加代理，实现token过期自动刷新\"><a href=\"#3-添加代理，实现token过期自动刷新\" class=\"headerlink\" title=\"3.添加代理，实现token过期自动刷新\"></a>3.添加代理，实现token过期自动刷新</h2><p>因为几乎所有的请求都需要验证token是否过期，因此需要做统一处理。我们可以采用代理类来对Retrofit的API做统一的代理处理。代码如下：</p>\n<pre><code class=\"hljs reasonml\">public <span class=\"hljs-keyword\">class</span> IdeaApiProxy implements IGlobalManager &#123;\n    @<span class=\"hljs-constructor\">SuppressWarnings(<span class=\"hljs-string\">&quot;unchecked&quot;</span>)</span>\n    public &lt;T&gt; T get<span class=\"hljs-constructor\">ApiService(Class&lt;T&gt; <span class=\"hljs-params\">tClass</span>,String <span class=\"hljs-params\">baseUrl</span>)</span> &#123;\n        T t = <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">RetrofitService</span>.</span></span>get<span class=\"hljs-constructor\">RetrofitBuilder(<span class=\"hljs-params\">baseUrl</span>)</span>\n                .build<span class=\"hljs-literal\">()</span>.create(tClass);\n        return (T) <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">Proxy</span>.</span></span><span class=\"hljs-keyword\">new</span><span class=\"hljs-constructor\">ProxyInstance(<span class=\"hljs-params\">tClass</span>.<span class=\"hljs-params\">getClassLoader</span>()</span>, <span class=\"hljs-keyword\">new</span> Class&lt;?&gt;<span class=\"hljs-literal\">[]</span> &#123; tClass &#125;, <span class=\"hljs-keyword\">new</span> <span class=\"hljs-constructor\">ProxyHandler(<span class=\"hljs-params\">t</span>, <span class=\"hljs-params\">this</span>)</span>);\n    &#125;\n\n    @Override\n    public void exit<span class=\"hljs-constructor\">Login()</span> &#123;\n\n    &#125;\n&#125;</code></pre>\n<p>这样，我们就需要通过IdeaApiProxy 中的getApiService方法来创建API请求。其中的ProxyHandler则是实现了InvocationHandler。ProxyHandler类是我们处理token自动刷新的核心类。思想就是针对 method 的调用，做以 retryWhen 的包装，在retryWhen 中获取相应的异常信息来做处理，看 retryWhen 的代码：</p>\n<pre><code class=\"hljs php\">@Override\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">Object</span> invoke(<span class=\"hljs-keyword\">Object</span> proxy, <span class=\"hljs-keyword\">final</span> Method method, <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">Object</span>[] args) throws <span class=\"hljs-built_in\">Throwable</span> &#123;\n      <span class=\"hljs-keyword\">return</span> Observable.just(<span class=\"hljs-literal\">true</span>).flatMap(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">Function</span>&lt;<span class=\"hljs-title\">Object</span>, <span class=\"hljs-title\">ObservableSource</span>&lt;?&gt;&gt;(<span class=\"hljs-params\"></span>) </span>&#123;\n          @Override\n          <span class=\"hljs-keyword\">public</span> ObservableSource<span class=\"hljs-meta\">&lt;?</span>&gt; apply(<span class=\"hljs-keyword\">Object</span> o) throws <span class=\"hljs-built_in\">Exception</span> &#123;\n              <span class=\"hljs-keyword\">try</span> &#123;\n                  <span class=\"hljs-keyword\">try</span> &#123;\n                      <span class=\"hljs-keyword\">if</span> (mIsTokenNeedRefresh) &#123;\n                          updateMethodToken(method, args);\n                      &#125;\n                      <span class=\"hljs-keyword\">return</span> (Observable<span class=\"hljs-meta\">&lt;?</span>&gt;) method.invoke(mProxyObject, args);\n                  &#125; <span class=\"hljs-keyword\">catch</span> (InvocationTargetException e) &#123;\n                      e.printStackTrace();\n                  &#125;\n              &#125; <span class=\"hljs-keyword\">catch</span> (IllegalAccessException e) &#123;\n                  e.printStackTrace();\n              &#125;\n              <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">null</span>;\n          &#125;\n      &#125;).retryWhen(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">Function</span>&lt;<span class=\"hljs-title\">Observable</span>&lt;<span class=\"hljs-title\">Throwable</span>&gt;, <span class=\"hljs-title\">ObservableSource</span>&lt;?&gt;&gt;(<span class=\"hljs-params\"></span>) </span>&#123;\n          @Override\n          <span class=\"hljs-keyword\">public</span> ObservableSource<span class=\"hljs-meta\">&lt;?</span>&gt; apply(Observable&lt;<span class=\"hljs-built_in\">Throwable</span>&gt; observable) throws <span class=\"hljs-built_in\">Exception</span> &#123;\n              <span class=\"hljs-keyword\">return</span> observable.flatMap(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">Function</span>&lt;<span class=\"hljs-title\">Throwable</span>, <span class=\"hljs-title\">ObservableSource</span>&lt;?&gt;&gt;(<span class=\"hljs-params\"></span>) </span>&#123;\n                  @Override\n                  <span class=\"hljs-keyword\">public</span> ObservableSource<span class=\"hljs-meta\">&lt;?</span>&gt; apply(<span class=\"hljs-built_in\">Throwable</span> <span class=\"hljs-built_in\">throwable</span>) throws <span class=\"hljs-built_in\">Exception</span> &#123;\n                      <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">throwable</span> <span class=\"hljs-keyword\">instanceof</span> TokenExpiredException) &#123;<span class=\"hljs-comment\">// token过期</span>\n                          <span class=\"hljs-keyword\">return</span> refreshTokenWhenTokenInvalid();\n                      &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">throwable</span> <span class=\"hljs-keyword\">instanceof</span> RefreshTokenExpiredException) &#123;\n                          <span class=\"hljs-comment\">// RefreshToken过期，执行退出登录的操作。</span>\n                          mGlobalManager.logout();\n                          <span class=\"hljs-keyword\">return</span> Observable.<span class=\"hljs-built_in\">error</span>(<span class=\"hljs-built_in\">throwable</span>);\n                      &#125;\n                      <span class=\"hljs-keyword\">return</span> Observable.<span class=\"hljs-built_in\">error</span>(<span class=\"hljs-built_in\">throwable</span>);\n                  &#125;\n              &#125;);\n          &#125;\n      &#125;);\n  &#125;</code></pre>\n<p>这里针对 token 过期的 TokenExpiredException的异常，执行刷新 token 的操作，刷新 token 的操作则是直接调用 Retrofit 的方法，而不需要走代理了。另外它必须是个同步的代码块，一起来看refreshTokenWhenTokenInvalid方法中的代码：</p>\n<pre><code class=\"hljs reasonml\"><span class=\"hljs-keyword\">private</span> Observable&lt;?&gt; refresh<span class=\"hljs-constructor\">TokenWhenTokenInvalid()</span> &#123;\n        synchronized (<span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">ProxyHandler</span>.</span></span><span class=\"hljs-keyword\">class</span>) &#123;\n            <span class=\"hljs-comment\">// Have refreshed the token successfully in the valid time.</span>\n            <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">new</span> <span class=\"hljs-constructor\">Date()</span>.get<span class=\"hljs-constructor\">Time()</span> - tokenChangedTime &lt; REFRESH_TOKEN_VALID_TIME) &#123;   <span class=\"hljs-comment\">//  防止重复刷新token</span>\n                mIsTokenNeedRefresh = <span class=\"hljs-literal\">true</span>;\n                return <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">Observable</span>.</span></span>just(<span class=\"hljs-literal\">true</span>);\n            &#125; <span class=\"hljs-keyword\">else</span> &#123;\n                Map&lt;String, Object&gt; map = <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">MapUtils</span>.</span></span>entity<span class=\"hljs-constructor\">ToMap(<span class=\"hljs-params\">new</span> BaseRequestData()</span>);\n                <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">RetrofitHelper</span>.</span></span>get<span class=\"hljs-constructor\">ApiService()</span>\n                        .refresh<span class=\"hljs-constructor\">Token(<span class=\"hljs-params\">map</span>)</span>\n                        <span class=\"hljs-comment\">//.observeOn(AndroidSchedulers.mainThread())</span>\n                        .subscribe(<span class=\"hljs-keyword\">new</span> DefaultObserver&lt;RefreshTokenResponse&gt;<span class=\"hljs-literal\">()</span> &#123;\n                            @Override\n                            public void on<span class=\"hljs-constructor\">Success(RefreshTokenResponse <span class=\"hljs-params\">response</span>)</span> &#123;\n                                <span class=\"hljs-keyword\">if</span> (response != null) &#123;\n                                    <span class=\"hljs-comment\">// 保存数据到本地</span>\n                                    mGlobalManager.token<span class=\"hljs-constructor\">Refresh(<span class=\"hljs-params\">response</span>)</span>;\n                                    mIsTokenNeedRefresh = <span class=\"hljs-literal\">true</span>;\n                                    tokenChangedTime = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-constructor\">Date()</span>.get<span class=\"hljs-constructor\">Time()</span>;\n                                &#125;\n                            &#125;\n\n                            @Override\n                            public void on<span class=\"hljs-constructor\">Error(Throwable <span class=\"hljs-params\">e</span>)</span> &#123;\n                                super.on<span class=\"hljs-constructor\">Error(<span class=\"hljs-params\">e</span>)</span>;\n                                mRefreshTokenError = e;\n                            &#125;\n                        &#125;);\n                <span class=\"hljs-keyword\">if</span> (mRefreshTokenError != null) &#123;\n                    return <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">Observable</span>.</span></span>error(mRefreshTokenError);\n                &#125; <span class=\"hljs-keyword\">else</span> &#123;\n                    return <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">Observable</span>.</span></span>just(<span class=\"hljs-literal\">true</span>);\n                &#125;\n            &#125;\n        &#125;\n    &#125;</code></pre>\n\n<h2 id=\"4-刷新token成功后替换旧的token\"><a href=\"#4-刷新token成功后替换旧的token\" class=\"headerlink\" title=\"4.刷新token成功后替换旧的token\"></a>4.刷新token成功后替换旧的token</h2><p>当token刷新成功之后，我们将旧的token替换掉呢？java8中的method类，已经支持了动态获取方法名称，而之前的Java版本则是不支持的。那这里怎么办呢？通过看retrofit的调用，可以知道retrofit是可以将接口中的方法转换成API请求，并需要封装参数的。那就需要看一下Retrofit是如何实现的呢？最后发现重头戏是在Retrofit对每个方法添加的@interface的注解，通过Method类中的getParameterAnnotations来进行获取，主要的代码实现如下：</p>\n<pre><code class=\"hljs crystal\"><span class=\"hljs-keyword\">private</span> void updateMethodToken(Method method, Object[] args) &#123;\n        ServerKey serverKey = RealmDatabaseHelper.queryFirstFrom(ServerKey.<span class=\"hljs-keyword\">class</span>);\n        String token = serverKey.getToken();\n        <span class=\"hljs-keyword\">if</span> (mIsTokenNeedRefresh &amp;&amp; !TextUtils.isEmpty(token)) &#123;\n            Annotation[][] annotationsArray = method.getParameterAnnotations();\n            Annotation[] annotations;\n            <span class=\"hljs-keyword\">if</span> (annotationsArray != null &amp;&amp; annotationsArray.length &gt; <span class=\"hljs-number\">0</span>) &#123;\n                <span class=\"hljs-keyword\">for</span> (int i = <span class=\"hljs-number\">0</span>; i &lt; annotationsArray.length; i++) &#123;\n                    annotations = annotationsArray[i];\n                    <span class=\"hljs-keyword\">for</span> (Annotation <span class=\"hljs-keyword\">annotation</span> : <span class=\"hljs-title\">annotations</span>) &#123;\n                        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">annotation</span> <span class=\"hljs-title\">instanceof</span> <span class=\"hljs-title\">FieldMap</span>||<span class=\"hljs-title\">annotation</span> <span class=\"hljs-title\">instanceof</span> <span class=\"hljs-title\">QueryMap</span>) &#123;// 以<span class=\"hljs-title\">Map</span>方式提交表单\n                            <span class=\"hljs-keyword\">if</span> (args[i] instanceof Map)\n                                ((Map&lt;String, Object&gt;) args[i]).put(TOKEN, token);\n                        &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">annotation</span> <span class=\"hljs-title\">instanceof</span> <span class=\"hljs-title\">Query</span>) &#123;\n                            <span class=\"hljs-keyword\">if</span> (TOKEN.equals(((Query) <span class=\"hljs-keyword\">annotation</span>).<span class=\"hljs-title\">value</span>())) &#123;\n                                args[i] = token;\n                            &#125;\n                        &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">annotation</span> <span class=\"hljs-title\">instanceof</span> <span class=\"hljs-title\">Field</span>) &#123;\n                            <span class=\"hljs-keyword\">if</span> (TOKEN.equals(((Field) <span class=\"hljs-keyword\">annotation</span>).<span class=\"hljs-title\">value</span>())) &#123;\n                                args[i] = token;\n                            &#125;\n                        &#125;<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-keyword\">annotation</span> <span class=\"hljs-title\">instanceof</span> <span class=\"hljs-title\">Part</span>)&#123;   //  上传文件\n                            <span class=\"hljs-keyword\">if</span> (TOKEN.equals(((Part) <span class=\"hljs-keyword\">annotation</span>).<span class=\"hljs-title\">value</span>())) &#123;\n                                RequestBody tokenBody = RequestBody.create(MediaType.parse(<span class=\"hljs-string\">&quot;multipart/form-data&quot;</span>), token);\n                                args[i] = tokenBody;\n                            &#125;\n                        &#125;<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-keyword\">annotation</span> <span class=\"hljs-title\">instanceof</span> <span class=\"hljs-title\">Body</span>)&#123;// <span class=\"hljs-title\">Post</span>提交<span class=\"hljs-title\">json</span>数据\n                            <span class=\"hljs-keyword\">if</span>(args[i] instanceof BaseRequest)&#123;\n                                BaseRequest requestData= (BaseRequest) args[i];\n                                requestData.setToken(token);\n                                args[i]=requestData;\n                            &#125;\n                        &#125;\n                    &#125;\n                &#125;\n            &#125;\n            mIsTokenNeedRefresh = <span class=\"hljs-literal\">false</span>;\n        &#125;\n    &#125;</code></pre>\n<p>这里我们遍历所有的token字段，并将其替换成新的token。但上述方法仅仅适用于get请求和post请求以表单格式提交。如果是post请求且提交格式为json可以自行添加。另外此种方法不适用于token放在请求头的方式。</p>\n<p><a href=\"https://blog.csdn.net/qq_20521573/article/details/70991850\">（一）Rxjava2+Retrofit完美封装</a><br><a href=\"https://blog.csdn.net/qq_20521573/article/details/76100558\">（二）Rxjava2+Retrofit之Token自动刷新</a><br><a href=\"https://blog.csdn.net/qq_20521573/article/details/78356747\">（三）Rxjava2+Retrofit实现文件上传与下载</a></p>\n<p>参考<br><a href=\"http://alighters.com/blog/2016/08/22/rxjava-plus-retrofitshi-xian-zhi-demo/\">RxJava+Retrofit实现全局过期token自动刷新Demo篇</a> </p>\n<p><a href=\"https://github.com/zhpanvip/Retrofit2/tree/token\">源码下载</a></p>\n","site":{"data":{"fluid_config":{"favicon":"/img/favicon.png","apple_touch_icon":"/img/favicon.png","title_join_string":" - ","force_https":false,"highlight":{"enable":true,"style":"Github Gist","bg_color":false,"copy_btn":true},"fun_features":{"typing":{"enable":true,"typeSpeed":70,"cursorChar":"|","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"mouse_click":{"enable":false,"style":"values"}},"dark_mode":{"enable":true,"default":"auto"},"color":{"body_bg_color":"#eee","body_bg_color_dark":"#181c27","navbar_bg_color":"#2f4154","navbar_bg_color_dark":"#1f3144","navbar_text_color":"#fff","navbar_text_color_dark":"#d0d0d0","text_color":"#3c4858","text_color_dark":"#c4c6c9","sec_text_color":"#718096","sec_text_color_dark":"#a7a9ad","post_text_color":"#2c3e50","post_text_color_dark":"#c4c6c9","post_heading_color":"#1a202c","post_heading_color_dark":"#c4c6c9","post_link_color":"#0366d6","post_link_color_dark":"#1589e9","link_hover_color":"#30a9de","link_hover_color_dark":"#30a9de","link_hover_bg_color":"#f8f9fa","link_hover_bg_color_dark":"#364151","board_color":"#fff","board_color_dark":"#252d38"},"font":{"font_size":"16px","font_family":null,"code_font_size":"85%"},"custom_js":null,"custom_css":null,"custom_html":"","web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"tajs":null,"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}},"lazyload":{"enable":true,"onlypost":false},"daovoice":{"enable":false,"appid":""},"aplayer":{"enable":false,"autoplay":false,"loop":"all","order":"random","theme":"#b7daff","songs":[{"name":"name","artist":"artist","url":"/songs/test.mp3","cover":"/img/cover.jpg"},{"name":"name","artist":"artist","url":"https://...url.mp3","cover":"https://...cover.jpg"}]},"version":{"check":false},"navbar":{"blog_title":"zhangpan","ground_glass":{"enable":false,"px":3,"alpha":0.7},"menu":[{"key":"home","link":"/","icon":"iconfont icon-home-fill"},{"key":"archive","link":"/archives/","icon":"iconfont icon-archive-fill"},{"key":"category","link":"/categories/","icon":"iconfont icon-category-fill"},{"key":"tag","link":"/tags/","icon":"iconfont icon-tags-fill"},{"key":"about","link":"/about/","icon":"iconfont icon-user-fill"}]},"search":{"enable":true,"path":"/local-search.xml","generate_path":"/local-search.xml","field":"post","content":true},"scroll_down_arrow":{"enable":true,"banner_height_limit":90,"scroll_after_turning_page":true},"banner_parallax":true,"footer":{"statistics":{"enable":false,"source":"busuanzi","pv_format":"总访问量 {} 次","uv_format":"总访客数 {} 人"},"beian":{"enable":false,"icp_text":"京ICP证123456号","police_text":"京公网安备12345678号","police_code":12345678,"police_icon":"/img/police_beian.png"}},"scroll_top_arrow":{"enable":true},"index":{"banner_img":"/img/default.png","banner_img_height":100,"banner_mask_alpha":0.3,"post_default_img":"","slogan":{"enable":true,"text":"Talk is cheap, show me the code."},"auto_excerpt":{"enable":true},"post_url_target":"_self","post_meta":{"date":true,"category":true,"tag":true}},"page":{"banner_img":"/img/default.png","banner_img_height":60,"banner_mask_alpha":0.3},"post":{"banner_img":"/img/default.png","banner_img_height":70,"banner_mask_alpha":0.3,"meta":{"date":{"enable":true,"format":"LL a"},"wordcount":{"enable":true,"format":"{} 字"},"min2read":{"enable":true,"format":"{} 分钟","words":100},"views":{"enable":false,"source":"busuanzi","format":"{} 次"}},"updated":{"enable":false,"content":"本文最后更新于：","relative":false},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"copyright":{"enable":true,"content":"本博客所有文章除特别声明外，均采用 <a href=\"https://creativecommons.org/licenses/by-sa/4.0/deed.zh\" rel=\"nofollow noopener\">CC BY-SA 4.0 协议</a> ，转载请注明出处！ <h5>开源库推荐</h5> <a href=\"https://github.com/zhpanvip/BannerViewPager\">1.BannerViewPager</a> <p> 一个基于ViewPager2实现的具有强大功能的无限轮播库。支持多种页面切换效果和指示器样式。 </p>\n<a href=\"https://github.com/zhpanvip/viewpagerindicator\">2.ViewPagerIndicator</a> <p> 一个适用于ViewPager和ViewPager2的指示器，支持多种滑块样式及滑动模式 </p>"},"prev_next":{"enable":true},"custom":{"enable":false,"content":"<img src=\"https://octodex.github.com/images/jetpacktocat.png\" class=\"rounded mx-auto d-block mt-5\" style=\"width:150px; height:150px;\">"},"image_zoom":{"enable":true},"footnote":{"enable":true,"header":""},"math":{"enable":false,"specific":false,"engine":"mathjax"},"mermaid":{"enable":false,"specific":false,"options":{"theme":"default"}},"comments":{"enable":true,"type":"utterances"}},"utterances":{"repo":"zhpanvip/utterances-comment","issue_term":"pathname","label":"utterances","theme":"github-light","crossorigin":"anonymous"},"disqus":{"shortname":null,"disqusjs":false,"apikey":null},"gitalk":{"clientID":null,"clientSecret":null,"repo":null,"owner":null,"admin":["name"],"id":"location.pathname","language":"zh-CN","labels":["Gitalk"],"perPage":10,"pagerDirection":"last","distractionFreeMode":false,"createIssueManually":true},"valine":{"appid":"hXIROaIM5y9qnieojJRWP5hS","appkey":"y0f3w3aqd1MF7JL9ma4WECTy","placeholder":"说点什么","path":"window.location.pathname","avatar":"retro","meta":["nick","mail","link"],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"https://zhangpan.site"},"changyan":{"appid":"","appkey":""},"livere":{"uid":""},"archive":{"banner_img":"/img/bg_article.jpg","banner_img_height":60,"banner_mask_alpha":0.3,"subtitle":null},"category":{"banner_img":"/img/bg_default.png","banner_img_height":60,"banner_mask_alpha":0.3,"subtitle":null,"post_limit":10,"order_by":"-length"},"tag":{"banner_img":"/img/bg_label.jpg","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null,"tagcloud":{"min_font":15,"max_font":30,"unit":"px","start_color":"#BBBBEE","end_color":"#337ab7"}},"about":{"banner_img":"/img/bg_default.png","banner_img_height":60,"banner_mask_alpha":0.3,"subtitle":null,"avatar":"/img/avatar.png","name":"myname","introduce":"一句简短的介绍","icons":[{"class":"iconfont icon-github-fill","link":"https://github.com","tip":"GitHub"},{"class":"iconfont icon-douban-fill","link":"https://douban.com","tip":"豆瓣"},{"class":"iconfont icon-wechat-fill","qrcode":"/img/favicon.png"}]},"page404":{"banner_img":"/img/default.png","banner_img_height":85,"banner_mask_alpha":0.3,"subtitle":"Page not found"},"links":{"banner_img":"/img/default.png","banner_img_height":60,"banner_mask_alpha":0.3,"subtitle":null,"items":[{"title":"Fluid Docs","intro":"主题使用指南","link":"https://hexo.fluid-dev.com/docs/","image":"/img/favicon.png"},{"title":"Fluid Repo","intro":"主题 GitHub 仓库","link":"https://github.com/fluid-dev/hexo-theme-fluid","image":"/img/favicon.png"},{"title":"Fluid Example","intro":"主题操作示例","link":"https://hexo.fluid-dev.com/docs/example/","image":"/img/favicon.png"}]}}}},"excerpt":"","more":"<p><a href=\"http://blog.csdn.net/qq_20521573/article/details/70991850\"> 上篇文章</a>主要对Retrofit做了封装，使之使用起来更加方便。在之前的封装中token过期再次刷新token后需要手动调用之前的请求，这种处理方式不够优雅，因此，在原有的基础上，本篇文章将基于上篇文章的封装并优化Token验证机制。使之能够实现过期自动刷新并重新调用请求。<br>接下来将通过以下几个小节来学习如何实现token验证。</p>\n<ul>\n<li>为什么要引入token机制</li>\n<li>token机制的验证流程</li>\n<li>RxJava+Retrofit封装实现token验证</li>\n</ul>\n<h1 id=\"一、为什么引入token机制\"><a href=\"#一、为什么引入token机制\" class=\"headerlink\" title=\"一、为什么引入token机制\"></a>一、为什么引入token机制</h1><h1 id=\"1-token是什么？\"><a href=\"#1-token是什么？\" class=\"headerlink\" title=\"1.token是什么？\"></a>1.token是什么？</h1><p>token意为令牌，通常是由客户端携带IMEI/Mac到服务器，服务器根据客户端的IMEI/Mac生成一段字符串并返回给客户端，并为其设置有效期。以此作为客户端和服务端交互的令牌。客户端每次请求都会携带token到服务器来代替用户名和密码。服务端验证token有效后则返回数据给客户端，否则返回特定的错误码给客户端。客户端根据错误码去做相应的处理。</p>\n<h2 id=\"2-那么为什么引入token机制呢？\"><a href=\"#2-那么为什么引入token机制呢？\" class=\"headerlink\" title=\"2.那么为什么引入token机制呢？\"></a>2.那么为什么引入token机制呢？</h2><p>主要有以下两个原因：<br>（1）保证安全性。如果不引入token机制，那么我们每次请求数据都要携带用户名和密码。也就是每次请求数据用户名和密码都会在网络上传输。这样大大增加了安全风险，很容易被黑客截取。因此引入token机制也一定程度上保证了安全性。<br>（2）减小服务器压力。在引入token机制前，我们需要通过用户名和密码到服务器去验证用户身份是否合法。服务器认证用户名和密码是一个查询操作，如果用户量大，那么就会相应增加服务器的压力。而引入token机制后，服务器就可以将token作为一个用户的唯一标识来验证用户身份是否合法。这样可以大大减少服务器的压力。</p>\n<h2 id=\"二、token机制的验证流程\"><a href=\"#二、token机制的验证流程\" class=\"headerlink\" title=\"二、token机制的验证流程\"></a>二、token机制的验证流程</h2><p>token的验证流程并非唯一的，至于使用怎样的验证流程可以自行确定。本文中采用OAuth2.0协议实现token验证机制。<br>主要步骤如下：</p>\n<ol>\n<li>通过用户名和密码登录成功获取token和refreshToken并保存到本地。</li>\n<li>token的有效期为2小时，refreshToken的有效期为15天。</li>\n<li>每次网络请求都需要带上token，而不必带上refreshToken。</li>\n<li>如果服务器端判断token过期，则返回对应的错误码，客户端判断错误码后调用刷新token接口,重新获取token和refreshToken并存储。</li>\n<li>如果连续15天未使用app或者用户修改了密码，则refreshToken过期，需要重新登录获取token和refreshToken。</li>\n</ol>\n<h1 id=\"三、RxJava-Retrofit封装实现token自动刷新\"><a href=\"#三、RxJava-Retrofit封装实现token自动刷新\" class=\"headerlink\" title=\"三、RxJava+Retrofit封装实现token自动刷新\"></a>三、RxJava+Retrofit封装实现token自动刷新</h1><p>有了以上两节的基础，我们就可以来自己实现token机制的验证了。在这里我们使用<a href=\"http://blog.csdn.net/qq_20521573/article/details/70991850\">上篇文章</a>中封装的RxJava和Retrofit来实现token机制。</p>\n<h2 id=\"1-登录认证，获取token和refresh-token\"><a href=\"#1-登录认证，获取token和refresh-token\" class=\"headerlink\" title=\"1.登录认证，获取token和refresh_token\"></a>1.登录认证，获取token和refresh_token</h2><p>登录时我们需要两个参数：用户名username、密码password以及appkey作为一个唯一id，每次登录成功服务器会返回token和refreshToken。登录请求的实体类LoginRequest如下：</p>\n<pre><code class=\"hljs scala\">public <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">LoginRequest</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">BaseRequest</span></span>&#123;\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-type\">String</span> userId;\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-type\">String</span> password;\n&#125;</code></pre>\n<p>接下来我们就可以来调用登录接口获取token了。登录成功后我们可将token和refreshToekn存储到本地。以提交表单为例，代码如下：</p>\n<pre><code class=\"hljs reasonml\">public void login<span class=\"hljs-literal\">()</span> &#123;\n         Map&lt;String, Object&gt; map = <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">MapUtils</span>.</span></span>entity<span class=\"hljs-constructor\">ToMap(<span class=\"hljs-params\">new</span> BaseRequest()</span>);\n        map.put(<span class=\"hljs-string\">&quot;userId&quot;</span>,<span class=\"hljs-string\">&quot;123456&quot;</span>);\n        map.put(<span class=\"hljs-string\">&quot;password&quot;</span>,<span class=\"hljs-string\">&quot;123123&quot;</span>);\n        <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">IdeaApi</span>.</span></span>get<span class=\"hljs-constructor\">ApiService()</span>\n                .login(map)\n                .subscribe<span class=\"hljs-constructor\">On(Schedulers.<span class=\"hljs-params\">io</span>()</span>)\n                .compose(activity.&lt;BasicResponse&lt;LoginResponse&gt;&gt;bind<span class=\"hljs-constructor\">ToLifecycle()</span>)\n                .observe<span class=\"hljs-constructor\">On(AndroidSchedulers.<span class=\"hljs-params\">mainThread</span>()</span>)\n                .subscribe(<span class=\"hljs-keyword\">new</span> DefaultObserver&lt;BasicResponse&lt;LoginResponse&gt;&gt;(activity) &#123;\n                    @Override\n                    public void on<span class=\"hljs-constructor\">Success(BasicResponse&lt;LoginResponse&gt; <span class=\"hljs-params\">response</span>)</span> &#123;\n                        LoginResponse results = response.get<span class=\"hljs-constructor\">Results()</span>;\n                        <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">ToastUtils</span>.</span></span>show(<span class=\"hljs-string\">&quot;登录成功！获取到token&quot;</span> + results.get<span class=\"hljs-constructor\">Token()</span> + <span class=\"hljs-string\">&quot;,可以存储到本地了&quot;</span>);\n                        <span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">                         * 可以将这些数据存储到User中，User存储到本地数据库</span>\n<span class=\"hljs-comment\">                         */</span>\n                        <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">SharedPreferencesHelper</span>.</span></span>put(activity, <span class=\"hljs-string\">&quot;token&quot;</span>, results.get<span class=\"hljs-constructor\">Token()</span>);\n                        <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">SharedPreferencesHelper</span>.</span></span>put(activity, <span class=\"hljs-string\">&quot;refresh_token&quot;</span>, results.get<span class=\"hljs-constructor\">Refresh_token()</span>);\n                        <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">SharedPreferencesHelper</span>.</span></span>put(activity, <span class=\"hljs-string\">&quot;refresh_secret&quot;</span>, results.get<span class=\"hljs-constructor\">Refresh_secret()</span>);\n                    &#125;\n                &#125;);\n    &#125;</code></pre>\n\n\n\n\n<h2 id=\"2-明确需求，抛出异常\"><a href=\"#2-明确需求，抛出异常\" class=\"headerlink\" title=\"2.明确需求，抛出异常\"></a>2.明确需求，抛出异常</h2><p>由于token的有效期较短，因此我们需要经常刷新token来保证token的有效性。在请求网络的时候如果token过期或者无效服务器会给我们返回对应的错误码。我们需要根据状态码来判断token是否失效。如果失效则调用刷新token接口重新获取token。如果refreshToekn也过期那么我们需要重新登录。</p>\n<p>现在，我们的需求是要实现token过期后自动刷新，刷新成功后自动调用原来的请求，如果refreshToken也过期，则退出登录。基于此，我们可以联想到RxJava的retryWhen操作符，我们可以通过retryWhen操作符判断token过期并自动刷新。</p>\n<p>那么，接下来我们首要任务是如何判断token和refreshToken过期。还记得上篇文章中我们修改GsonResponseBodyConverter类来根据后台响应码来获取data中的数据。显然在此处判断token是否过期是比较合适的。接下来看GsonResponseBodyConverter中的代码：</p>\n<pre><code class=\"hljs reasonml\">@Override\n public Object convert(ResponseBody value) throws IOException &#123;\n     <span class=\"hljs-keyword\">try</span> &#123;\n         BasicResponse response = (BasicResponse) adapter.from<span class=\"hljs-constructor\">Json(<span class=\"hljs-params\">value</span>.<span class=\"hljs-params\">charStream</span>()</span>);\n         <span class=\"hljs-keyword\">if</span> (response.get<span class=\"hljs-constructor\">Code()</span><span class=\"hljs-operator\"> == </span>SUCCESS) &#123;\n             <span class=\"hljs-keyword\">if</span> (response.get<span class=\"hljs-constructor\">Data()</span><span class=\"hljs-operator\"> == </span>null)\n                 throw <span class=\"hljs-keyword\">new</span> <span class=\"hljs-constructor\">ServerNoDataException(0, <span class=\"hljs-string\">&quot;&quot;</span>)</span>;\n             return response.get<span class=\"hljs-constructor\">Data()</span>;\n         &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (response.get<span class=\"hljs-constructor\">Code()</span><span class=\"hljs-operator\"> == </span>TOKEN_EXPIRED) &#123;\n             throw <span class=\"hljs-keyword\">new</span> <span class=\"hljs-constructor\">TokenExpiredException(<span class=\"hljs-params\">response</span>.<span class=\"hljs-params\">getCode</span>()</span>, response.get<span class=\"hljs-constructor\">Message()</span>);\n         &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (response.get<span class=\"hljs-constructor\">Code()</span><span class=\"hljs-operator\"> == </span>REFRESH_TOKEN_EXPIRED) &#123;\n             throw <span class=\"hljs-keyword\">new</span> <span class=\"hljs-constructor\">RefreshTokenExpiredException(<span class=\"hljs-params\">response</span>.<span class=\"hljs-params\">getCode</span>()</span>, response.get<span class=\"hljs-constructor\">Message()</span>);\n         &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (response.get<span class=\"hljs-constructor\">Code()</span> != SUCCESS) &#123;\n             <span class=\"hljs-comment\">// 特定 API 的错误，在相应的 DefaultObserver 的 onError 的方法中进行处理</span>\n             throw <span class=\"hljs-keyword\">new</span> <span class=\"hljs-constructor\">ServerResponseException(<span class=\"hljs-params\">response</span>.<span class=\"hljs-params\">getCode</span>()</span>, response.get<span class=\"hljs-constructor\">Message()</span>);\n         &#125;\n     &#125; finally &#123;\n         value.close<span class=\"hljs-literal\">()</span>;\n     &#125;\n     return null;\n &#125;</code></pre>\n<p>上面代码中我们自定义了几个异常，在判断对应的错误码后抛出对应的异常。此处我们可以着重关心下TokenExpiredException和RefreshTokenExpiredException，分别代表了token过期和refreshToken过期。</p>\n<h2 id=\"3-添加代理，实现token过期自动刷新\"><a href=\"#3-添加代理，实现token过期自动刷新\" class=\"headerlink\" title=\"3.添加代理，实现token过期自动刷新\"></a>3.添加代理，实现token过期自动刷新</h2><p>因为几乎所有的请求都需要验证token是否过期，因此需要做统一处理。我们可以采用代理类来对Retrofit的API做统一的代理处理。代码如下：</p>\n<pre><code class=\"hljs reasonml\">public <span class=\"hljs-keyword\">class</span> IdeaApiProxy implements IGlobalManager &#123;\n    @<span class=\"hljs-constructor\">SuppressWarnings(<span class=\"hljs-string\">&quot;unchecked&quot;</span>)</span>\n    public &lt;T&gt; T get<span class=\"hljs-constructor\">ApiService(Class&lt;T&gt; <span class=\"hljs-params\">tClass</span>,String <span class=\"hljs-params\">baseUrl</span>)</span> &#123;\n        T t = <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">RetrofitService</span>.</span></span>get<span class=\"hljs-constructor\">RetrofitBuilder(<span class=\"hljs-params\">baseUrl</span>)</span>\n                .build<span class=\"hljs-literal\">()</span>.create(tClass);\n        return (T) <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">Proxy</span>.</span></span><span class=\"hljs-keyword\">new</span><span class=\"hljs-constructor\">ProxyInstance(<span class=\"hljs-params\">tClass</span>.<span class=\"hljs-params\">getClassLoader</span>()</span>, <span class=\"hljs-keyword\">new</span> Class&lt;?&gt;<span class=\"hljs-literal\">[]</span> &#123; tClass &#125;, <span class=\"hljs-keyword\">new</span> <span class=\"hljs-constructor\">ProxyHandler(<span class=\"hljs-params\">t</span>, <span class=\"hljs-params\">this</span>)</span>);\n    &#125;\n\n    @Override\n    public void exit<span class=\"hljs-constructor\">Login()</span> &#123;\n\n    &#125;\n&#125;</code></pre>\n<p>这样，我们就需要通过IdeaApiProxy 中的getApiService方法来创建API请求。其中的ProxyHandler则是实现了InvocationHandler。ProxyHandler类是我们处理token自动刷新的核心类。思想就是针对 method 的调用，做以 retryWhen 的包装，在retryWhen 中获取相应的异常信息来做处理，看 retryWhen 的代码：</p>\n<pre><code class=\"hljs php\">@Override\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">Object</span> invoke(<span class=\"hljs-keyword\">Object</span> proxy, <span class=\"hljs-keyword\">final</span> Method method, <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">Object</span>[] args) throws <span class=\"hljs-built_in\">Throwable</span> &#123;\n      <span class=\"hljs-keyword\">return</span> Observable.just(<span class=\"hljs-literal\">true</span>).flatMap(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">Function</span>&lt;<span class=\"hljs-title\">Object</span>, <span class=\"hljs-title\">ObservableSource</span>&lt;?&gt;&gt;(<span class=\"hljs-params\"></span>) </span>&#123;\n          @Override\n          <span class=\"hljs-keyword\">public</span> ObservableSource<span class=\"hljs-meta\">&lt;?</span>&gt; apply(<span class=\"hljs-keyword\">Object</span> o) throws <span class=\"hljs-built_in\">Exception</span> &#123;\n              <span class=\"hljs-keyword\">try</span> &#123;\n                  <span class=\"hljs-keyword\">try</span> &#123;\n                      <span class=\"hljs-keyword\">if</span> (mIsTokenNeedRefresh) &#123;\n                          updateMethodToken(method, args);\n                      &#125;\n                      <span class=\"hljs-keyword\">return</span> (Observable<span class=\"hljs-meta\">&lt;?</span>&gt;) method.invoke(mProxyObject, args);\n                  &#125; <span class=\"hljs-keyword\">catch</span> (InvocationTargetException e) &#123;\n                      e.printStackTrace();\n                  &#125;\n              &#125; <span class=\"hljs-keyword\">catch</span> (IllegalAccessException e) &#123;\n                  e.printStackTrace();\n              &#125;\n              <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">null</span>;\n          &#125;\n      &#125;).retryWhen(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">Function</span>&lt;<span class=\"hljs-title\">Observable</span>&lt;<span class=\"hljs-title\">Throwable</span>&gt;, <span class=\"hljs-title\">ObservableSource</span>&lt;?&gt;&gt;(<span class=\"hljs-params\"></span>) </span>&#123;\n          @Override\n          <span class=\"hljs-keyword\">public</span> ObservableSource<span class=\"hljs-meta\">&lt;?</span>&gt; apply(Observable&lt;<span class=\"hljs-built_in\">Throwable</span>&gt; observable) throws <span class=\"hljs-built_in\">Exception</span> &#123;\n              <span class=\"hljs-keyword\">return</span> observable.flatMap(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">Function</span>&lt;<span class=\"hljs-title\">Throwable</span>, <span class=\"hljs-title\">ObservableSource</span>&lt;?&gt;&gt;(<span class=\"hljs-params\"></span>) </span>&#123;\n                  @Override\n                  <span class=\"hljs-keyword\">public</span> ObservableSource<span class=\"hljs-meta\">&lt;?</span>&gt; apply(<span class=\"hljs-built_in\">Throwable</span> <span class=\"hljs-built_in\">throwable</span>) throws <span class=\"hljs-built_in\">Exception</span> &#123;\n                      <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">throwable</span> <span class=\"hljs-keyword\">instanceof</span> TokenExpiredException) &#123;<span class=\"hljs-comment\">// token过期</span>\n                          <span class=\"hljs-keyword\">return</span> refreshTokenWhenTokenInvalid();\n                      &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">throwable</span> <span class=\"hljs-keyword\">instanceof</span> RefreshTokenExpiredException) &#123;\n                          <span class=\"hljs-comment\">// RefreshToken过期，执行退出登录的操作。</span>\n                          mGlobalManager.logout();\n                          <span class=\"hljs-keyword\">return</span> Observable.<span class=\"hljs-built_in\">error</span>(<span class=\"hljs-built_in\">throwable</span>);\n                      &#125;\n                      <span class=\"hljs-keyword\">return</span> Observable.<span class=\"hljs-built_in\">error</span>(<span class=\"hljs-built_in\">throwable</span>);\n                  &#125;\n              &#125;);\n          &#125;\n      &#125;);\n  &#125;</code></pre>\n<p>这里针对 token 过期的 TokenExpiredException的异常，执行刷新 token 的操作，刷新 token 的操作则是直接调用 Retrofit 的方法，而不需要走代理了。另外它必须是个同步的代码块，一起来看refreshTokenWhenTokenInvalid方法中的代码：</p>\n<pre><code class=\"hljs reasonml\"><span class=\"hljs-keyword\">private</span> Observable&lt;?&gt; refresh<span class=\"hljs-constructor\">TokenWhenTokenInvalid()</span> &#123;\n        synchronized (<span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">ProxyHandler</span>.</span></span><span class=\"hljs-keyword\">class</span>) &#123;\n            <span class=\"hljs-comment\">// Have refreshed the token successfully in the valid time.</span>\n            <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">new</span> <span class=\"hljs-constructor\">Date()</span>.get<span class=\"hljs-constructor\">Time()</span> - tokenChangedTime &lt; REFRESH_TOKEN_VALID_TIME) &#123;   <span class=\"hljs-comment\">//  防止重复刷新token</span>\n                mIsTokenNeedRefresh = <span class=\"hljs-literal\">true</span>;\n                return <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">Observable</span>.</span></span>just(<span class=\"hljs-literal\">true</span>);\n            &#125; <span class=\"hljs-keyword\">else</span> &#123;\n                Map&lt;String, Object&gt; map = <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">MapUtils</span>.</span></span>entity<span class=\"hljs-constructor\">ToMap(<span class=\"hljs-params\">new</span> BaseRequestData()</span>);\n                <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">RetrofitHelper</span>.</span></span>get<span class=\"hljs-constructor\">ApiService()</span>\n                        .refresh<span class=\"hljs-constructor\">Token(<span class=\"hljs-params\">map</span>)</span>\n                        <span class=\"hljs-comment\">//.observeOn(AndroidSchedulers.mainThread())</span>\n                        .subscribe(<span class=\"hljs-keyword\">new</span> DefaultObserver&lt;RefreshTokenResponse&gt;<span class=\"hljs-literal\">()</span> &#123;\n                            @Override\n                            public void on<span class=\"hljs-constructor\">Success(RefreshTokenResponse <span class=\"hljs-params\">response</span>)</span> &#123;\n                                <span class=\"hljs-keyword\">if</span> (response != null) &#123;\n                                    <span class=\"hljs-comment\">// 保存数据到本地</span>\n                                    mGlobalManager.token<span class=\"hljs-constructor\">Refresh(<span class=\"hljs-params\">response</span>)</span>;\n                                    mIsTokenNeedRefresh = <span class=\"hljs-literal\">true</span>;\n                                    tokenChangedTime = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-constructor\">Date()</span>.get<span class=\"hljs-constructor\">Time()</span>;\n                                &#125;\n                            &#125;\n\n                            @Override\n                            public void on<span class=\"hljs-constructor\">Error(Throwable <span class=\"hljs-params\">e</span>)</span> &#123;\n                                super.on<span class=\"hljs-constructor\">Error(<span class=\"hljs-params\">e</span>)</span>;\n                                mRefreshTokenError = e;\n                            &#125;\n                        &#125;);\n                <span class=\"hljs-keyword\">if</span> (mRefreshTokenError != null) &#123;\n                    return <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">Observable</span>.</span></span>error(mRefreshTokenError);\n                &#125; <span class=\"hljs-keyword\">else</span> &#123;\n                    return <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">Observable</span>.</span></span>just(<span class=\"hljs-literal\">true</span>);\n                &#125;\n            &#125;\n        &#125;\n    &#125;</code></pre>\n\n<h2 id=\"4-刷新token成功后替换旧的token\"><a href=\"#4-刷新token成功后替换旧的token\" class=\"headerlink\" title=\"4.刷新token成功后替换旧的token\"></a>4.刷新token成功后替换旧的token</h2><p>当token刷新成功之后，我们将旧的token替换掉呢？java8中的method类，已经支持了动态获取方法名称，而之前的Java版本则是不支持的。那这里怎么办呢？通过看retrofit的调用，可以知道retrofit是可以将接口中的方法转换成API请求，并需要封装参数的。那就需要看一下Retrofit是如何实现的呢？最后发现重头戏是在Retrofit对每个方法添加的@interface的注解，通过Method类中的getParameterAnnotations来进行获取，主要的代码实现如下：</p>\n<pre><code class=\"hljs crystal\"><span class=\"hljs-keyword\">private</span> void updateMethodToken(Method method, Object[] args) &#123;\n        ServerKey serverKey = RealmDatabaseHelper.queryFirstFrom(ServerKey.<span class=\"hljs-keyword\">class</span>);\n        String token = serverKey.getToken();\n        <span class=\"hljs-keyword\">if</span> (mIsTokenNeedRefresh &amp;&amp; !TextUtils.isEmpty(token)) &#123;\n            Annotation[][] annotationsArray = method.getParameterAnnotations();\n            Annotation[] annotations;\n            <span class=\"hljs-keyword\">if</span> (annotationsArray != null &amp;&amp; annotationsArray.length &gt; <span class=\"hljs-number\">0</span>) &#123;\n                <span class=\"hljs-keyword\">for</span> (int i = <span class=\"hljs-number\">0</span>; i &lt; annotationsArray.length; i++) &#123;\n                    annotations = annotationsArray[i];\n                    <span class=\"hljs-keyword\">for</span> (Annotation <span class=\"hljs-keyword\">annotation</span> : <span class=\"hljs-title\">annotations</span>) &#123;\n                        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">annotation</span> <span class=\"hljs-title\">instanceof</span> <span class=\"hljs-title\">FieldMap</span>||<span class=\"hljs-title\">annotation</span> <span class=\"hljs-title\">instanceof</span> <span class=\"hljs-title\">QueryMap</span>) &#123;// 以<span class=\"hljs-title\">Map</span>方式提交表单\n                            <span class=\"hljs-keyword\">if</span> (args[i] instanceof Map)\n                                ((Map&lt;String, Object&gt;) args[i]).put(TOKEN, token);\n                        &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">annotation</span> <span class=\"hljs-title\">instanceof</span> <span class=\"hljs-title\">Query</span>) &#123;\n                            <span class=\"hljs-keyword\">if</span> (TOKEN.equals(((Query) <span class=\"hljs-keyword\">annotation</span>).<span class=\"hljs-title\">value</span>())) &#123;\n                                args[i] = token;\n                            &#125;\n                        &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">annotation</span> <span class=\"hljs-title\">instanceof</span> <span class=\"hljs-title\">Field</span>) &#123;\n                            <span class=\"hljs-keyword\">if</span> (TOKEN.equals(((Field) <span class=\"hljs-keyword\">annotation</span>).<span class=\"hljs-title\">value</span>())) &#123;\n                                args[i] = token;\n                            &#125;\n                        &#125;<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-keyword\">annotation</span> <span class=\"hljs-title\">instanceof</span> <span class=\"hljs-title\">Part</span>)&#123;   //  上传文件\n                            <span class=\"hljs-keyword\">if</span> (TOKEN.equals(((Part) <span class=\"hljs-keyword\">annotation</span>).<span class=\"hljs-title\">value</span>())) &#123;\n                                RequestBody tokenBody = RequestBody.create(MediaType.parse(<span class=\"hljs-string\">&quot;multipart/form-data&quot;</span>), token);\n                                args[i] = tokenBody;\n                            &#125;\n                        &#125;<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-keyword\">annotation</span> <span class=\"hljs-title\">instanceof</span> <span class=\"hljs-title\">Body</span>)&#123;// <span class=\"hljs-title\">Post</span>提交<span class=\"hljs-title\">json</span>数据\n                            <span class=\"hljs-keyword\">if</span>(args[i] instanceof BaseRequest)&#123;\n                                BaseRequest requestData= (BaseRequest) args[i];\n                                requestData.setToken(token);\n                                args[i]=requestData;\n                            &#125;\n                        &#125;\n                    &#125;\n                &#125;\n            &#125;\n            mIsTokenNeedRefresh = <span class=\"hljs-literal\">false</span>;\n        &#125;\n    &#125;</code></pre>\n<p>这里我们遍历所有的token字段，并将其替换成新的token。但上述方法仅仅适用于get请求和post请求以表单格式提交。如果是post请求且提交格式为json可以自行添加。另外此种方法不适用于token放在请求头的方式。</p>\n<p><a href=\"https://blog.csdn.net/qq_20521573/article/details/70991850\">（一）Rxjava2+Retrofit完美封装</a><br><a href=\"https://blog.csdn.net/qq_20521573/article/details/76100558\">（二）Rxjava2+Retrofit之Token自动刷新</a><br><a href=\"https://blog.csdn.net/qq_20521573/article/details/78356747\">（三）Rxjava2+Retrofit实现文件上传与下载</a></p>\n<p>参考<br><a href=\"http://alighters.com/blog/2016/08/22/rxjava-plus-retrofitshi-xian-zhi-demo/\">RxJava+Retrofit实现全局过期token自动刷新Demo篇</a> </p>\n<p><a href=\"https://github.com/zhpanvip/Retrofit2/tree/token\">源码下载</a></p>\n"},{"title":"追根溯源--探究Handler的实现原理","date":"2017-09-09T18:27:27.000Z","_content":"\n\n\n## 一、初识Handler\n要分析一个框架的源码，首先需要了解它的使用。我们就从最基础的知识开始吧！\n\n### 场景1：将数据从子线程发送到主线程。\n\n我们知道Android系统中更新UI只能在主线程中进行。而通常网络请求实在子线程中进行的。在获取到服务器数据后我们需要切换到主线程来更新UI。通常在这种情况下我们会考虑使用Handler来进行线程切换。我们来模拟一个网络请求，并通过Handler将数据发送出去：\n\n```java\n\n\tprivate Handler mHandler = new Handler(){\n\t        @Override\n\t        public void dispatchMessage(@NonNull Message msg) {\n\t            super.dispatchMessage(msg);\n\t            updateUI(msg);\n\t        }\n\t    };\n\t// 或者可以通过传入Handler.Callback的参数\n\tHandler mHandler = new Handler(new Handler.Callback() {\n        @Override\n        public boolean handleMessage(Message msg) {\n\t\t\tupdateUI(msg);\n            return false;\n        }\n    });\n\t    \n\t// 模拟网络请求\n\t private void fetchData() {\n\t        new Thread(){\n\t            @Override\n\t            public void run() {\n\t                super.run();\n\t                Message message = mHandler.obtainMessage();\n\t                message.obj=\"data from server\";\n\t                mHandler.sendMessage(message);\n\t            }\n\t        }.start();\n\t\n\t    }\n```\n我们通过子线程模拟网络请求，并将获取的数据通过Handler的sendMessage方法将数据发送了出去。而在Handler的dispatchMessage方法中便可收到刚刚发送的message。并且此时dispatchMessage处于主线程，因此可以直接在dispatchMessage方法中更新UI了。\n### 场景2：延迟发送Runnable\n场景1是Handler很典型的一个应用，除此之外，我们还经常会通过Handler延迟发送一个Runnable，在delayMillis时间之后会执行Runnable的run方法。代码示例如下：\n\n```java\n\t// 假设是运行在Activity中的代码\n\tprivate Handler mHandler = new Handler();\n\tprivate Runnable mRunnable = new Runnable() {\n\t        @Override\n\t        public void run() {\n\t            handleMessage();\n\t        }\n\t    };\n\t @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n\t \tnew Thread(){\n            @Override\n            public void run() {\n                super.run();\n                mHandler.postDelayed(mRunnable,1000);\n            }\n        }.start();\n\t}\n```\n### 场景3：在子线程中初始化Handler\n\n```java\n Handler mHandler;\n new Thread(){\n            @Override\n            public void run() {\n                super.run();\n                mHandler=new Handler();\n            }\n        }.start();\n```\n此时，运行程序我们会发现程序Crash掉了，并且抛出了以下错误日志：\n\n> java.lang.RuntimeException: Can't create handler inside thread that has not called Looper.prepare()\n\n日志信息提示我们在子线程中创建Handler需要调用Looper.prepare()方法。\n\n(注:以上场景均未考虑内存泄露问题)\n\n那么针对以上三个应用场景，有些同学可能表示会有问题：\n\n**问题1：** 在场景1中Handler在子线程中发送出来的消息为什么到了dispatchMessage方法就变成了主线程呢？\n\n**问题2：** 在场景2的代码中我故意在子线程中调用了Handler的postDelayed方法，那么此时通过postDelayed方法发出来的Runnable究竟是运行在主线程还是子线程呢？\n\n**问题3：**  为什么在主线程中直接创建Handler可以正常运行而在子线程中创建Handler需要调用Looper.prepare()方法呢？\n\n如果想要解开以上几个疑惑，就需要我们对Handler的源码有深入的了解。那么接下来我们就进入Handler的源码分析环节吧！\n\n## 二、Handler源码溯源历程\n\n### 1.从实例化一个Handler说起\n在使用Handler的第一步就需要我们先实例化一个Handler。那么，我们就从new Handler()着手，看看在初始化Handler的时候做了哪些操作：\n\n```java\n\n\tfinal Looper mLooper;\n    final MessageQueue mQueue;\n\tfinal Callback mCallback;\n    final boolean mAsynchronous;\n    public Handler() {\n        this(null, false);\n    }\n\n\tpublic Handler(@Nullable Callback callback, boolean async) {\n\t        if (FIND_POTENTIAL_LEAKS) {\n\t            final Class<? extends Handler> klass = getClass();\n\t            if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &&\n\t                    (klass.getModifiers() & Modifier.STATIC) == 0) {\n\t                Log.w(TAG, \"The following Handler class should be static or leaks might occur: \" +\n\t                    klass.getCanonicalName());\n\t            }\n\t        }\n\t\n\t        mLooper = Looper.myLooper();\n\t        if (mLooper == null) {\n\t            throw new RuntimeException(\n\t                \"Can't create handler inside thread \" + Thread.currentThread()\n\t                        + \" that has not called Looper.prepare()\");\n\t        }\n\t        mQueue = mLooper.mQueue;\n\t        mCallback = callback;\n\t        mAsynchronous = async;\n\t    }\n\n```\n可以看到，调用Handler的无参构造方法实例化Handler最终调用了Handler(@Nullable Callback callback, boolean async)的构造方法，而在这个构造方法中的逻辑似乎也很简单，通过调用Looper.myLooper()方法得到了一个Looper对象，如果此时mLooper为null，则会抛出一个RuntimeException。仔细看看发现这个异常信息不就是我们在第一章场景三中在子线程中初始化Handler的时候抛出来的异常吗？那么，什么时候通过Looper.myPrepare()方法得到的Handler会是空呢？要解决这个问题怕是要到Looper中一探究竟了。\n\n首先来看下Looper.myPrepare()方法的源码：\n\n```java\n\n    public static @Nullable Looper myLooper() {\n        return sThreadLocal.get();\n    }\n\n```\n\n这是Looper中的一个静态方法，这个方法简单到只有一行代码，即调用了ThreadLocal的get()方法来得到一个Looper。ThreadLocal是Java中的一个类，它是一个泛型类，有set(T)和T get()两个方法。ThreadLocal的神奇之处在于它可以在指定线程中存储数据，什么意思呢？即你在某个线程中存储的数据只能在该线程中获取的到。关于ThreadLocal我们只需要了解这些就够了，其实现原理不做深究，有兴趣的可以自从查阅源码。\n\n既然了解了ThreadLocal的作用，那么在Looper内部一定事先调用了ThreadLocal的set方法。通过全局搜索sThreadLocal，发现了prepare()方法，其源码如下：\n\n```java\n\n   private static void prepare(boolean quitAllowed) {\n        if (sThreadLocal.get() != null) {\n            throw new RuntimeException(\"Only one Looper may be created per thread\");\n        }\n        sThreadLocal.set(new Looper(quitAllowed));\n    }\n\n```\n果真如我们预料的那样，在Looper的prepare方法中实例化了Looper，并将其放入到了ThreadLocal中。而如果没有调用Looper.prepare()方法，那么获取到的Looper一定是null。到这里似乎解释了第一章的场景三在子线程中实例化Handler需要事先调用Looper.prepare()方法。但是，到这里我们似乎还是没有解释清楚疑惑三，为什么在主线程中直接实例化Handler却没有抛出异常呢？其实，当程序启动的时候会同时启动主线程，我们知道Java程序的入口是main方法。而在Android程序启动的入口同样是main方法。我们在ActivityThread中找到main方法，源码如下：\n\n```java\n\t\n\t# ActivityThread\n\tpublic static void main(String[] args) {\n\t        \n\t\t\t...\n\t\n\t        Looper.prepareMainLooper();\n\t\t\t...\n\n\t        Looper.loop();\n\t\n\t        throw new RuntimeException(\"Main thread loop unexpectedly exited\");\n\t    }\n\n\t # Looper\n\t public static void prepareMainLooper() {\n\t        prepare(false);\n\t        synchronized (Looper.class) {\n\t            if (sMainLooper != null) {\n\t                throw new IllegalStateException(\"The main Looper has already been prepared.\");\n\t            }\n\t            sMainLooper = myLooper();\n\t        }\n\t    }\n\n\n```\n\n在main方法中调用了Looper.prepareMauinLooper()方法，而Looper.prepareMauinLooper()中又调用了prepare方法。因此，我们可以在主线程中直接实例化Handler而不用担心抛出异常。\n\n### 2.Handler的postXXX()或sendXXX\n\n实例化Handler后，我们通常会通过Handler提供的方法来发送一个消息。在第一章节中列举了Handler的sendMessage()和postDelay()方法，其实除了这两个方法之外，Handler还提供了一系列的sendXXX()和postXXX()的方法。但追踪源码发现这些方法最终都会调用到sendMessageAtTime方法。\n\n\n我们就以postDelayed方法为例来分析。首先，来看postDelayed的源码：\n\n\n```java\npublic final boolean postDelayed(@NonNull Runnable r, long delayMillis) {\n        return sendMessageDelayed(getPostMessage(r), delayMillis);\n    }\n```\n\n在postDelayed中调用了sendMessageDelayed方法，这个方法的第一个参数接收一个Message，这里通过getPostMessage(r)方法得到了Message对象，getPostMessage(r)源码如下：\n\n```java\n\tprivate static Message getPostMessage(Runnable r) {\n\t        Message m = Message.obtain();\n\t        m.callback = r;\n\t        return m;\n\t    }\n\n```\n可以看到，在getPostMessage方法中将Runnable赋值给了Message.callback，此处我们先立一个Flag。\n\n接下来追溯到sendMessageDelayed方法中：\n\n```java\npublic final boolean sendMessageDelayed(@NonNull Message msg, long delayMillis) {\n        if (delayMillis < 0) {\n            delayMillis = 0;\n        }\n        return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);\n    }\n```\n在这个方法中我们终于看到了sendMessageAtTime方法，其源码如下：\n\n```java\npublic boolean sendMessageAtTime(@NonNull Message msg, long uptimeMillis) {\n        MessageQueue queue = mQueue;\n        if (queue == null) {\n            RuntimeException e = new RuntimeException(\n                    this + \" sendMessageAtTime() called with no mQueue\");\n            Log.w(\"Looper\", e.getMessage(), e);\n            return false;\n        }\n        return enqueueMessage(queue, msg, uptimeMillis);\n    }\n```\n这个方法中的代码逻辑很简单，仅仅调用了enqueueMessage方法，源码如下：\n```java\nprivate boolean enqueueMessage(@NonNull MessageQueue queue, @NonNull Message msg,\n            long uptimeMillis) {\n        msg.target = this;\n        msg.workSourceUid = ThreadLocalWorkSource.getUid();\n\n        if (mAsynchronous) {\n            msg.setAsynchronous(true);\n        }\n        return queue.enqueueMessage(msg, uptimeMillis);\n    }\n```\n在这个方法中我们需要注意的一点-- msg.target = this，把当前Handler的对象赋值给了Message.target。紧接着调用了MessageQueue的enqueueMessage方法。MessageQueue这个类我们在上边已经碰到过了。即在实例化Handler的时候将mLooper.mQueue赋值给了Handler的mQueue.那么现在是时候来认识一下MessageQueue了。\n\n\n### 3.MessageQueue\n\n上一小节中我们在Handler的构造方法中看到了将mLooper.mQueue赋值给了Handler中的mQueue。而MessageQueue从名字上似乎也可以看出来它是一个存储消息的队列。并且在Handler的enqueueMessage方法中通过MessageQueue的enqueueMessage将消息添加到了MessageQueue中。接下来，我们看下enqueueMessage的源码：\n\n\n```java\nboolean enqueueMessage(Message msg, long when) {\n        if (msg.target == null) {\n            throw new IllegalArgumentException(\"Message must have a target.\");\n        }\n        if (msg.isInUse()) {\n            throw new IllegalStateException(msg + \" This message is already in use.\");\n        }\n\n        synchronized (this) {\n            if (mQuitting) {\n                IllegalStateException e = new IllegalStateException(\n                        msg.target + \" sending message to a Handler on a dead thread\");\n                Log.w(TAG, e.getMessage(), e);\n                msg.recycle();\n                return false;\n            }\n\n            msg.markInUse();\n            msg.when = when;\n            Message p = mMessages;\n            boolean needWake;\n            if (p == null || when == 0 || when < p.when) {\n                // New head, wake up the event queue if blocked.\n                msg.next = p;\n                mMessages = msg;\n                needWake = mBlocked;\n            } else {\n                // Inserted within the middle of the queue.  Usually we don't have to wake\n                // up the event queue unless there is a barrier at the head of the queue\n                // and the message is the earliest asynchronous message in the queue.\n                needWake = mBlocked && p.target == null && msg.isAsynchronous();\n                Message prev;\n                for (;;) {\n                    prev = p;\n                    p = p.next;\n                    if (p == null || when < p.when) {\n                        break;\n                    }\n                    if (needWake && p.isAsynchronous()) {\n                        needWake = false;\n                    }\n                }\n                msg.next = p; // invariant: p == prev.next\n                prev.next = msg;\n            }\n\n            // We can assume mPtr != 0 because mQuitting is false.\n            if (needWake) {\n                nativeWake(mPtr);\n            }\n        }\n        return true;\n    }\n\n```\nemmmmmm...阅读源码发现MessageQueue是一个用单项链表实现的队列，为什么是用链表？其实细想一下也不奇怪，因为我们可能频繁的将Message进行插入和删除。而使用链表性能上很明显要优于顺序表。这一段代码就是一个将Message插入到链表的一个过程，其实也没什么可以解释的。\n\n既然有插入消息，那必然也会有取出消息。我们进入MessageQueue的源码，发现在MessageQueue中发现还有另外一个叫next的方法：\n\n```java\nMessage next() {\n        // Return here if the message loop has already quit and been disposed.\n        // This can happen if the application tries to restart a looper after quit\n        // which is not supported.\n        final long ptr = mPtr;\n        if (ptr == 0) {\n            return null;\n        }\n\n        int pendingIdleHandlerCount = -1; // -1 only during first iteration\n        int nextPollTimeoutMillis = 0;\n        for (;;) {\n            if (nextPollTimeoutMillis != 0) {\n                Binder.flushPendingCommands();\n            }\n\n            nativePollOnce(ptr, nextPollTimeoutMillis);\n\n            synchronized (this) {\n                // Try to retrieve the next message.  Return if found.\n                final long now = SystemClock.uptimeMillis();\n                Message prevMsg = null;\n                Message msg = mMessages;\n                if (msg != null && msg.target == null) {\n                    // Stalled by a barrier.  Find the next asynchronous message in the queue.\n                    do {\n                        prevMsg = msg;\n                        msg = msg.next;\n                    } while (msg != null && !msg.isAsynchronous());\n                }\n                if (msg != null) {\n                    if (now < msg.when) {\n                        // Next message is not ready.  Set a timeout to wake up when it is ready.\n                        nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);\n                    } else {\n                        // Got a message.\n                        mBlocked = false;\n                        if (prevMsg != null) {\n                            prevMsg.next = msg.next;\n                        } else {\n                            mMessages = msg.next;\n                        }\n                        msg.next = null;\n                        if (DEBUG) Log.v(TAG, \"Returning message: \" + msg);\n                        msg.markInUse();\n                        return msg;\n                    }\n                } else {\n                    // No more messages.\n                    nextPollTimeoutMillis = -1;\n                }\n\n                // Process the quit message now that all pending messages have been handled.\n                if (mQuitting) {\n                    dispose();\n                    return null;\n                }\n\n                // If first time idle, then get the number of idlers to run.\n                // Idle handles only run if the queue is empty or if the first message\n                // in the queue (possibly a barrier) is due to be handled in the future.\n                if (pendingIdleHandlerCount < 0\n                        && (mMessages == null || now < mMessages.when)) {\n                    pendingIdleHandlerCount = mIdleHandlers.size();\n                }\n                if (pendingIdleHandlerCount <= 0) {\n                    // No idle handlers to run.  Loop and wait some more.\n                    mBlocked = true;\n                    continue;\n                }\n\n                if (mPendingIdleHandlers == null) {\n                    mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)];\n                }\n                mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);\n            }\n\n            // Run the idle handlers.\n            // We only ever reach this code block during the first iteration.\n            for (int i = 0; i < pendingIdleHandlerCount; i++) {\n                final IdleHandler idler = mPendingIdleHandlers[i];\n                mPendingIdleHandlers[i] = null; // release the reference to the handler\n\n                boolean keep = false;\n                try {\n                    keep = idler.queueIdle();\n                } catch (Throwable t) {\n                    Log.wtf(TAG, \"IdleHandler threw exception\", t);\n                }\n\n                if (!keep) {\n                    synchronized (this) {\n                        mIdleHandlers.remove(idler);\n                    }\n                }\n            }\n\n            // Reset the idle handler count to 0 so we do not run them again.\n            pendingIdleHandlerCount = 0;\n\n            // While calling an idle handler, a new message could have been delivered\n            // so go back and look again for a pending message without waiting.\n            nextPollTimeoutMillis = 0;\n        }\n    }\n\n```\n这个方法的返回值是一个Message，很显然，这个方法就是从MessageQueue中取出消息的。我们注意到第12行代码，这里是一个for(;;)死循环。如果在MessageQueue中有Message的时候，next会将这个Message移除并返回。而当MessageQueue为空时，next方法将会被阻塞。\n\n### 4.回归Looper\n\n我们了解了MessageQueue的插入和删除，但直到此时还没有看到在什么地方调用了MessageQueue的next方法将消息取出的。此时，我们将目光再次回归到Looper中。如果你刚才留意了ActivityThread中的main方法的话，应该注意到了main方法中的Looper.loop()方法,没错，一切将从这里开始，只有调用loop方法后消息循环系统才会真正运作起来，我们们来看loop的源码：\n\n```\n /**\n     * Run the message queue in this thread. Be sure to call\n     * {@link #quit()} to end the loop.\n     */\n    public static void loop() {\n        final Looper me = myLooper();\n        if (me == null) {\n            throw new RuntimeException(\"No Looper; Looper.prepare() wasn't called on this thread.\");\n        }\n        final MessageQueue queue = me.mQueue;\n\n        // Make sure the identity of this thread is that of the local process,\n        // and keep track of what that identity token actually is.\n        Binder.clearCallingIdentity();\n        final long ident = Binder.clearCallingIdentity();\n\n        for (;;) {\n            Message msg = queue.next(); // might block\n            if (msg == null) {\n                // No message indicates that the message queue is quitting.\n                return;\n            }\n\n            // This must be in a local variable, in case a UI event sets the logger\n            final Printer logging = me.mLogging;\n            if (logging != null) {\n                logging.println(\">>>>> Dispatching to \" + msg.target + \" \" +\n                        msg.callback + \": \" + msg.what);\n            }\n\n            final long traceTag = me.mTraceTag;\n            if (traceTag != 0 && Trace.isTagEnabled(traceTag)) {\n                Trace.traceBegin(traceTag, msg.target.getTraceName(msg));\n            }\n            try {\n                msg.target.dispatchMessage(msg);\n            } finally {\n                if (traceTag != 0) {\n                    Trace.traceEnd(traceTag);\n                }\n            }\n\n            if (logging != null) {\n                logging.println(\"<<<<< Finished to \" + msg.target + \" \" + msg.callback);\n            }\n\n            // Make sure that during the course of dispatching the\n            // identity of the thread wasn't corrupted.\n            final long newIdent = Binder.clearCallingIdentity();\n            if (ident != newIdent) {\n                Log.wtf(TAG, \"Thread identity changed from 0x\"\n                        + Long.toHexString(ident) + \" to 0x\"\n                        + Long.toHexString(newIdent) + \" while dispatching to \"\n                        + msg.target.getClass().getName() + \" \"\n                        + msg.callback + \" what=\" + msg.what);\n            }\n\n            msg.recycleUnchecked();\n        }\n    }\n```\n这里的loop方法同样也是一个死循环。只有当MessageQueue.next()返回null时才会跳出循环。上一小节中我们分析了Message.next方法是一个阻塞操作当MessageQueue中没有消息时next方法会一直被阻塞，因此也致使loop方法被阻塞。而当MessageQueue中添加了一条消息后，loop方法则会立即通过MessageQueue.next方法将消息取出并处理。可以看到通过调用msg.target.dispatchMessage(msg)处理消息。而msg.target是什么呢？我们回过头来看本章第二小节，在Handler的enqueueMessage中将Handler赋值给了msg.target,我们从Message的源码中也可以得到印证：\n\n```java\npublic final class Message implements Parcelable {\n\t...\n\t\n  /*package*/ Handler target;\n\t\n\t...\n}\n\n```\n也就是此时的target其实就是Handler本身，此时我们找到Handler的dispatchMessage方法，源码如下：\n\n```java\n\n\tpublic void dispatchMessage(@NonNull Message msg) {\n        if (msg.callback != null) {\n            handleCallback(msg);\n        } else {\n            if (mCallback != null) {\n                if (mCallback.handleMessage(msg)) {\n                    return;\n                }\n            }\n            handleMessage(msg);\n        }\n    }\n\n```\n\n看到这里想必大家应该就都明白了，上述代码首先检查了Message的callback是否为null，不为null就通过handleCallback来处理消息。Message的callback是一个Runnable对象，实际上就是Handler的post方法传递的Runnable参数，此时对应的是我们在第一章中的场景二。handleCallback方法代码如下：\n\n```\nprivate static void handleCallback(Message message) {\n        message.callback.run();\n    }\n```\nemmmm....原来我们post出来的Runnable的run方法就是在这里被调用的呀！\n\n接着检查mCallback是否为null，不为null就调用mCallback的handleMessage方法处理消息，这里对应的是我们在实例化Handler时传入的Callback参数。如果mCallback也为null的话则调用了Handler中的handleMessage(msg)方法。这不正对应了我们第一章的场景一嘛！因此现在再来看下面的代码会不会豁然开朗呢？\n\n```\n\n//\t\t实例化Handler对象 传入Callback参数并重写handleMessage(Message msg)\n static Handler mHandler1 = new Handler(new Handler.Callback() {\n        @Override\n        public boolean handleMessage(Message msg) {\n\n            return false;\n        }\n    });\n\n//\t实例化Handler对象 并重写Handler中的handleMessage(Message msg)\nhandleMessage(Message msg)\n static Handler mHandler = new Handler(){\n\t\t  @Override\n        public boolean handleMessage(Message msg) {\n\n            return false;\n        }\n};\n\n```\n到这里我们总算把Handler的消息机制给串联了起来。\n\n## 三、总结\n\n Handler、Looper和MessageQueue三者共支撑了Android中的消息机制。在使用的时候我们通常只需要和Handler打交道，通过Handler将消息发送出来。而在Handler内部的MessageQueue通过equeueMessage方法将Handler发送的消息以队列的形式进行存储。而Looper则作为一个消息泵，通过loop方法不断的调用MessageQueue的next方法将消息取出并进行处理，依次完成了整个的消息循环。同时，我们还应该特别强调ThreadLocal，正是有了它的存在，才使得我们能够轻松的进行切换线程。\n\n整个过程当如下图所示：\n\n![](https://raw.githubusercontent.com/zhpanvip/Resource/master/image/1101.jfif)\n\n\n看到这里，在第一章中提到的几点疑惑相信你心中应该也已经有了答案。我们不妨再来总结一下：\n\n**问题1：** 在场景1中Handler在子线程中发送出来的消息为什么到了dispatchMessage方法就变成了主线程呢？\n虽然post消息是在子线程，但因为Handler是在主线程中被实例化的，由于在ActivityThread的main方法中调用了Looper.prepare(),因此，通过ThreadLocal将Looper缓存到了主线程中，而MessageQueue是Looper的成员变量，所以其也应是在主线程中。同时，Looper.loop方法将Message取出并通过Message.target.handlerMessage方法最终调用了dispatchMessage方法，所以dispatchMessage方法当然也是在主线程了。\n\n**问题2：** 在场景2的代码中我故意在子线程中调用了Handler的postDelayed方法，那么此时通过postDelayed方法发出来的Runnable究竟是运行在主线程还是子线程呢？\n\n这个问题其实和问题1本质上是同一个问题，就无需多言了！\n\n**问题3**在文中已经给出了答案，这里也不再赘述。\n\n\n\n\n","source":"_posts/11.追根溯源-探究Handler的实现原理.md","raw":"---\ntitle: 追根溯源--探究Handler的实现原理\ndate: 2017-09-10 02:27:27\ntags: \n-  源码分析\n---\n\n\n\n## 一、初识Handler\n要分析一个框架的源码，首先需要了解它的使用。我们就从最基础的知识开始吧！\n\n### 场景1：将数据从子线程发送到主线程。\n\n我们知道Android系统中更新UI只能在主线程中进行。而通常网络请求实在子线程中进行的。在获取到服务器数据后我们需要切换到主线程来更新UI。通常在这种情况下我们会考虑使用Handler来进行线程切换。我们来模拟一个网络请求，并通过Handler将数据发送出去：\n\n```java\n\n\tprivate Handler mHandler = new Handler(){\n\t        @Override\n\t        public void dispatchMessage(@NonNull Message msg) {\n\t            super.dispatchMessage(msg);\n\t            updateUI(msg);\n\t        }\n\t    };\n\t// 或者可以通过传入Handler.Callback的参数\n\tHandler mHandler = new Handler(new Handler.Callback() {\n        @Override\n        public boolean handleMessage(Message msg) {\n\t\t\tupdateUI(msg);\n            return false;\n        }\n    });\n\t    \n\t// 模拟网络请求\n\t private void fetchData() {\n\t        new Thread(){\n\t            @Override\n\t            public void run() {\n\t                super.run();\n\t                Message message = mHandler.obtainMessage();\n\t                message.obj=\"data from server\";\n\t                mHandler.sendMessage(message);\n\t            }\n\t        }.start();\n\t\n\t    }\n```\n我们通过子线程模拟网络请求，并将获取的数据通过Handler的sendMessage方法将数据发送了出去。而在Handler的dispatchMessage方法中便可收到刚刚发送的message。并且此时dispatchMessage处于主线程，因此可以直接在dispatchMessage方法中更新UI了。\n### 场景2：延迟发送Runnable\n场景1是Handler很典型的一个应用，除此之外，我们还经常会通过Handler延迟发送一个Runnable，在delayMillis时间之后会执行Runnable的run方法。代码示例如下：\n\n```java\n\t// 假设是运行在Activity中的代码\n\tprivate Handler mHandler = new Handler();\n\tprivate Runnable mRunnable = new Runnable() {\n\t        @Override\n\t        public void run() {\n\t            handleMessage();\n\t        }\n\t    };\n\t @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n\t \tnew Thread(){\n            @Override\n            public void run() {\n                super.run();\n                mHandler.postDelayed(mRunnable,1000);\n            }\n        }.start();\n\t}\n```\n### 场景3：在子线程中初始化Handler\n\n```java\n Handler mHandler;\n new Thread(){\n            @Override\n            public void run() {\n                super.run();\n                mHandler=new Handler();\n            }\n        }.start();\n```\n此时，运行程序我们会发现程序Crash掉了，并且抛出了以下错误日志：\n\n> java.lang.RuntimeException: Can't create handler inside thread that has not called Looper.prepare()\n\n日志信息提示我们在子线程中创建Handler需要调用Looper.prepare()方法。\n\n(注:以上场景均未考虑内存泄露问题)\n\n那么针对以上三个应用场景，有些同学可能表示会有问题：\n\n**问题1：** 在场景1中Handler在子线程中发送出来的消息为什么到了dispatchMessage方法就变成了主线程呢？\n\n**问题2：** 在场景2的代码中我故意在子线程中调用了Handler的postDelayed方法，那么此时通过postDelayed方法发出来的Runnable究竟是运行在主线程还是子线程呢？\n\n**问题3：**  为什么在主线程中直接创建Handler可以正常运行而在子线程中创建Handler需要调用Looper.prepare()方法呢？\n\n如果想要解开以上几个疑惑，就需要我们对Handler的源码有深入的了解。那么接下来我们就进入Handler的源码分析环节吧！\n\n## 二、Handler源码溯源历程\n\n### 1.从实例化一个Handler说起\n在使用Handler的第一步就需要我们先实例化一个Handler。那么，我们就从new Handler()着手，看看在初始化Handler的时候做了哪些操作：\n\n```java\n\n\tfinal Looper mLooper;\n    final MessageQueue mQueue;\n\tfinal Callback mCallback;\n    final boolean mAsynchronous;\n    public Handler() {\n        this(null, false);\n    }\n\n\tpublic Handler(@Nullable Callback callback, boolean async) {\n\t        if (FIND_POTENTIAL_LEAKS) {\n\t            final Class<? extends Handler> klass = getClass();\n\t            if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &&\n\t                    (klass.getModifiers() & Modifier.STATIC) == 0) {\n\t                Log.w(TAG, \"The following Handler class should be static or leaks might occur: \" +\n\t                    klass.getCanonicalName());\n\t            }\n\t        }\n\t\n\t        mLooper = Looper.myLooper();\n\t        if (mLooper == null) {\n\t            throw new RuntimeException(\n\t                \"Can't create handler inside thread \" + Thread.currentThread()\n\t                        + \" that has not called Looper.prepare()\");\n\t        }\n\t        mQueue = mLooper.mQueue;\n\t        mCallback = callback;\n\t        mAsynchronous = async;\n\t    }\n\n```\n可以看到，调用Handler的无参构造方法实例化Handler最终调用了Handler(@Nullable Callback callback, boolean async)的构造方法，而在这个构造方法中的逻辑似乎也很简单，通过调用Looper.myLooper()方法得到了一个Looper对象，如果此时mLooper为null，则会抛出一个RuntimeException。仔细看看发现这个异常信息不就是我们在第一章场景三中在子线程中初始化Handler的时候抛出来的异常吗？那么，什么时候通过Looper.myPrepare()方法得到的Handler会是空呢？要解决这个问题怕是要到Looper中一探究竟了。\n\n首先来看下Looper.myPrepare()方法的源码：\n\n```java\n\n    public static @Nullable Looper myLooper() {\n        return sThreadLocal.get();\n    }\n\n```\n\n这是Looper中的一个静态方法，这个方法简单到只有一行代码，即调用了ThreadLocal的get()方法来得到一个Looper。ThreadLocal是Java中的一个类，它是一个泛型类，有set(T)和T get()两个方法。ThreadLocal的神奇之处在于它可以在指定线程中存储数据，什么意思呢？即你在某个线程中存储的数据只能在该线程中获取的到。关于ThreadLocal我们只需要了解这些就够了，其实现原理不做深究，有兴趣的可以自从查阅源码。\n\n既然了解了ThreadLocal的作用，那么在Looper内部一定事先调用了ThreadLocal的set方法。通过全局搜索sThreadLocal，发现了prepare()方法，其源码如下：\n\n```java\n\n   private static void prepare(boolean quitAllowed) {\n        if (sThreadLocal.get() != null) {\n            throw new RuntimeException(\"Only one Looper may be created per thread\");\n        }\n        sThreadLocal.set(new Looper(quitAllowed));\n    }\n\n```\n果真如我们预料的那样，在Looper的prepare方法中实例化了Looper，并将其放入到了ThreadLocal中。而如果没有调用Looper.prepare()方法，那么获取到的Looper一定是null。到这里似乎解释了第一章的场景三在子线程中实例化Handler需要事先调用Looper.prepare()方法。但是，到这里我们似乎还是没有解释清楚疑惑三，为什么在主线程中直接实例化Handler却没有抛出异常呢？其实，当程序启动的时候会同时启动主线程，我们知道Java程序的入口是main方法。而在Android程序启动的入口同样是main方法。我们在ActivityThread中找到main方法，源码如下：\n\n```java\n\t\n\t# ActivityThread\n\tpublic static void main(String[] args) {\n\t        \n\t\t\t...\n\t\n\t        Looper.prepareMainLooper();\n\t\t\t...\n\n\t        Looper.loop();\n\t\n\t        throw new RuntimeException(\"Main thread loop unexpectedly exited\");\n\t    }\n\n\t # Looper\n\t public static void prepareMainLooper() {\n\t        prepare(false);\n\t        synchronized (Looper.class) {\n\t            if (sMainLooper != null) {\n\t                throw new IllegalStateException(\"The main Looper has already been prepared.\");\n\t            }\n\t            sMainLooper = myLooper();\n\t        }\n\t    }\n\n\n```\n\n在main方法中调用了Looper.prepareMauinLooper()方法，而Looper.prepareMauinLooper()中又调用了prepare方法。因此，我们可以在主线程中直接实例化Handler而不用担心抛出异常。\n\n### 2.Handler的postXXX()或sendXXX\n\n实例化Handler后，我们通常会通过Handler提供的方法来发送一个消息。在第一章节中列举了Handler的sendMessage()和postDelay()方法，其实除了这两个方法之外，Handler还提供了一系列的sendXXX()和postXXX()的方法。但追踪源码发现这些方法最终都会调用到sendMessageAtTime方法。\n\n\n我们就以postDelayed方法为例来分析。首先，来看postDelayed的源码：\n\n\n```java\npublic final boolean postDelayed(@NonNull Runnable r, long delayMillis) {\n        return sendMessageDelayed(getPostMessage(r), delayMillis);\n    }\n```\n\n在postDelayed中调用了sendMessageDelayed方法，这个方法的第一个参数接收一个Message，这里通过getPostMessage(r)方法得到了Message对象，getPostMessage(r)源码如下：\n\n```java\n\tprivate static Message getPostMessage(Runnable r) {\n\t        Message m = Message.obtain();\n\t        m.callback = r;\n\t        return m;\n\t    }\n\n```\n可以看到，在getPostMessage方法中将Runnable赋值给了Message.callback，此处我们先立一个Flag。\n\n接下来追溯到sendMessageDelayed方法中：\n\n```java\npublic final boolean sendMessageDelayed(@NonNull Message msg, long delayMillis) {\n        if (delayMillis < 0) {\n            delayMillis = 0;\n        }\n        return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);\n    }\n```\n在这个方法中我们终于看到了sendMessageAtTime方法，其源码如下：\n\n```java\npublic boolean sendMessageAtTime(@NonNull Message msg, long uptimeMillis) {\n        MessageQueue queue = mQueue;\n        if (queue == null) {\n            RuntimeException e = new RuntimeException(\n                    this + \" sendMessageAtTime() called with no mQueue\");\n            Log.w(\"Looper\", e.getMessage(), e);\n            return false;\n        }\n        return enqueueMessage(queue, msg, uptimeMillis);\n    }\n```\n这个方法中的代码逻辑很简单，仅仅调用了enqueueMessage方法，源码如下：\n```java\nprivate boolean enqueueMessage(@NonNull MessageQueue queue, @NonNull Message msg,\n            long uptimeMillis) {\n        msg.target = this;\n        msg.workSourceUid = ThreadLocalWorkSource.getUid();\n\n        if (mAsynchronous) {\n            msg.setAsynchronous(true);\n        }\n        return queue.enqueueMessage(msg, uptimeMillis);\n    }\n```\n在这个方法中我们需要注意的一点-- msg.target = this，把当前Handler的对象赋值给了Message.target。紧接着调用了MessageQueue的enqueueMessage方法。MessageQueue这个类我们在上边已经碰到过了。即在实例化Handler的时候将mLooper.mQueue赋值给了Handler的mQueue.那么现在是时候来认识一下MessageQueue了。\n\n\n### 3.MessageQueue\n\n上一小节中我们在Handler的构造方法中看到了将mLooper.mQueue赋值给了Handler中的mQueue。而MessageQueue从名字上似乎也可以看出来它是一个存储消息的队列。并且在Handler的enqueueMessage方法中通过MessageQueue的enqueueMessage将消息添加到了MessageQueue中。接下来，我们看下enqueueMessage的源码：\n\n\n```java\nboolean enqueueMessage(Message msg, long when) {\n        if (msg.target == null) {\n            throw new IllegalArgumentException(\"Message must have a target.\");\n        }\n        if (msg.isInUse()) {\n            throw new IllegalStateException(msg + \" This message is already in use.\");\n        }\n\n        synchronized (this) {\n            if (mQuitting) {\n                IllegalStateException e = new IllegalStateException(\n                        msg.target + \" sending message to a Handler on a dead thread\");\n                Log.w(TAG, e.getMessage(), e);\n                msg.recycle();\n                return false;\n            }\n\n            msg.markInUse();\n            msg.when = when;\n            Message p = mMessages;\n            boolean needWake;\n            if (p == null || when == 0 || when < p.when) {\n                // New head, wake up the event queue if blocked.\n                msg.next = p;\n                mMessages = msg;\n                needWake = mBlocked;\n            } else {\n                // Inserted within the middle of the queue.  Usually we don't have to wake\n                // up the event queue unless there is a barrier at the head of the queue\n                // and the message is the earliest asynchronous message in the queue.\n                needWake = mBlocked && p.target == null && msg.isAsynchronous();\n                Message prev;\n                for (;;) {\n                    prev = p;\n                    p = p.next;\n                    if (p == null || when < p.when) {\n                        break;\n                    }\n                    if (needWake && p.isAsynchronous()) {\n                        needWake = false;\n                    }\n                }\n                msg.next = p; // invariant: p == prev.next\n                prev.next = msg;\n            }\n\n            // We can assume mPtr != 0 because mQuitting is false.\n            if (needWake) {\n                nativeWake(mPtr);\n            }\n        }\n        return true;\n    }\n\n```\nemmmmmm...阅读源码发现MessageQueue是一个用单项链表实现的队列，为什么是用链表？其实细想一下也不奇怪，因为我们可能频繁的将Message进行插入和删除。而使用链表性能上很明显要优于顺序表。这一段代码就是一个将Message插入到链表的一个过程，其实也没什么可以解释的。\n\n既然有插入消息，那必然也会有取出消息。我们进入MessageQueue的源码，发现在MessageQueue中发现还有另外一个叫next的方法：\n\n```java\nMessage next() {\n        // Return here if the message loop has already quit and been disposed.\n        // This can happen if the application tries to restart a looper after quit\n        // which is not supported.\n        final long ptr = mPtr;\n        if (ptr == 0) {\n            return null;\n        }\n\n        int pendingIdleHandlerCount = -1; // -1 only during first iteration\n        int nextPollTimeoutMillis = 0;\n        for (;;) {\n            if (nextPollTimeoutMillis != 0) {\n                Binder.flushPendingCommands();\n            }\n\n            nativePollOnce(ptr, nextPollTimeoutMillis);\n\n            synchronized (this) {\n                // Try to retrieve the next message.  Return if found.\n                final long now = SystemClock.uptimeMillis();\n                Message prevMsg = null;\n                Message msg = mMessages;\n                if (msg != null && msg.target == null) {\n                    // Stalled by a barrier.  Find the next asynchronous message in the queue.\n                    do {\n                        prevMsg = msg;\n                        msg = msg.next;\n                    } while (msg != null && !msg.isAsynchronous());\n                }\n                if (msg != null) {\n                    if (now < msg.when) {\n                        // Next message is not ready.  Set a timeout to wake up when it is ready.\n                        nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);\n                    } else {\n                        // Got a message.\n                        mBlocked = false;\n                        if (prevMsg != null) {\n                            prevMsg.next = msg.next;\n                        } else {\n                            mMessages = msg.next;\n                        }\n                        msg.next = null;\n                        if (DEBUG) Log.v(TAG, \"Returning message: \" + msg);\n                        msg.markInUse();\n                        return msg;\n                    }\n                } else {\n                    // No more messages.\n                    nextPollTimeoutMillis = -1;\n                }\n\n                // Process the quit message now that all pending messages have been handled.\n                if (mQuitting) {\n                    dispose();\n                    return null;\n                }\n\n                // If first time idle, then get the number of idlers to run.\n                // Idle handles only run if the queue is empty or if the first message\n                // in the queue (possibly a barrier) is due to be handled in the future.\n                if (pendingIdleHandlerCount < 0\n                        && (mMessages == null || now < mMessages.when)) {\n                    pendingIdleHandlerCount = mIdleHandlers.size();\n                }\n                if (pendingIdleHandlerCount <= 0) {\n                    // No idle handlers to run.  Loop and wait some more.\n                    mBlocked = true;\n                    continue;\n                }\n\n                if (mPendingIdleHandlers == null) {\n                    mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)];\n                }\n                mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);\n            }\n\n            // Run the idle handlers.\n            // We only ever reach this code block during the first iteration.\n            for (int i = 0; i < pendingIdleHandlerCount; i++) {\n                final IdleHandler idler = mPendingIdleHandlers[i];\n                mPendingIdleHandlers[i] = null; // release the reference to the handler\n\n                boolean keep = false;\n                try {\n                    keep = idler.queueIdle();\n                } catch (Throwable t) {\n                    Log.wtf(TAG, \"IdleHandler threw exception\", t);\n                }\n\n                if (!keep) {\n                    synchronized (this) {\n                        mIdleHandlers.remove(idler);\n                    }\n                }\n            }\n\n            // Reset the idle handler count to 0 so we do not run them again.\n            pendingIdleHandlerCount = 0;\n\n            // While calling an idle handler, a new message could have been delivered\n            // so go back and look again for a pending message without waiting.\n            nextPollTimeoutMillis = 0;\n        }\n    }\n\n```\n这个方法的返回值是一个Message，很显然，这个方法就是从MessageQueue中取出消息的。我们注意到第12行代码，这里是一个for(;;)死循环。如果在MessageQueue中有Message的时候，next会将这个Message移除并返回。而当MessageQueue为空时，next方法将会被阻塞。\n\n### 4.回归Looper\n\n我们了解了MessageQueue的插入和删除，但直到此时还没有看到在什么地方调用了MessageQueue的next方法将消息取出的。此时，我们将目光再次回归到Looper中。如果你刚才留意了ActivityThread中的main方法的话，应该注意到了main方法中的Looper.loop()方法,没错，一切将从这里开始，只有调用loop方法后消息循环系统才会真正运作起来，我们们来看loop的源码：\n\n```\n /**\n     * Run the message queue in this thread. Be sure to call\n     * {@link #quit()} to end the loop.\n     */\n    public static void loop() {\n        final Looper me = myLooper();\n        if (me == null) {\n            throw new RuntimeException(\"No Looper; Looper.prepare() wasn't called on this thread.\");\n        }\n        final MessageQueue queue = me.mQueue;\n\n        // Make sure the identity of this thread is that of the local process,\n        // and keep track of what that identity token actually is.\n        Binder.clearCallingIdentity();\n        final long ident = Binder.clearCallingIdentity();\n\n        for (;;) {\n            Message msg = queue.next(); // might block\n            if (msg == null) {\n                // No message indicates that the message queue is quitting.\n                return;\n            }\n\n            // This must be in a local variable, in case a UI event sets the logger\n            final Printer logging = me.mLogging;\n            if (logging != null) {\n                logging.println(\">>>>> Dispatching to \" + msg.target + \" \" +\n                        msg.callback + \": \" + msg.what);\n            }\n\n            final long traceTag = me.mTraceTag;\n            if (traceTag != 0 && Trace.isTagEnabled(traceTag)) {\n                Trace.traceBegin(traceTag, msg.target.getTraceName(msg));\n            }\n            try {\n                msg.target.dispatchMessage(msg);\n            } finally {\n                if (traceTag != 0) {\n                    Trace.traceEnd(traceTag);\n                }\n            }\n\n            if (logging != null) {\n                logging.println(\"<<<<< Finished to \" + msg.target + \" \" + msg.callback);\n            }\n\n            // Make sure that during the course of dispatching the\n            // identity of the thread wasn't corrupted.\n            final long newIdent = Binder.clearCallingIdentity();\n            if (ident != newIdent) {\n                Log.wtf(TAG, \"Thread identity changed from 0x\"\n                        + Long.toHexString(ident) + \" to 0x\"\n                        + Long.toHexString(newIdent) + \" while dispatching to \"\n                        + msg.target.getClass().getName() + \" \"\n                        + msg.callback + \" what=\" + msg.what);\n            }\n\n            msg.recycleUnchecked();\n        }\n    }\n```\n这里的loop方法同样也是一个死循环。只有当MessageQueue.next()返回null时才会跳出循环。上一小节中我们分析了Message.next方法是一个阻塞操作当MessageQueue中没有消息时next方法会一直被阻塞，因此也致使loop方法被阻塞。而当MessageQueue中添加了一条消息后，loop方法则会立即通过MessageQueue.next方法将消息取出并处理。可以看到通过调用msg.target.dispatchMessage(msg)处理消息。而msg.target是什么呢？我们回过头来看本章第二小节，在Handler的enqueueMessage中将Handler赋值给了msg.target,我们从Message的源码中也可以得到印证：\n\n```java\npublic final class Message implements Parcelable {\n\t...\n\t\n  /*package*/ Handler target;\n\t\n\t...\n}\n\n```\n也就是此时的target其实就是Handler本身，此时我们找到Handler的dispatchMessage方法，源码如下：\n\n```java\n\n\tpublic void dispatchMessage(@NonNull Message msg) {\n        if (msg.callback != null) {\n            handleCallback(msg);\n        } else {\n            if (mCallback != null) {\n                if (mCallback.handleMessage(msg)) {\n                    return;\n                }\n            }\n            handleMessage(msg);\n        }\n    }\n\n```\n\n看到这里想必大家应该就都明白了，上述代码首先检查了Message的callback是否为null，不为null就通过handleCallback来处理消息。Message的callback是一个Runnable对象，实际上就是Handler的post方法传递的Runnable参数，此时对应的是我们在第一章中的场景二。handleCallback方法代码如下：\n\n```\nprivate static void handleCallback(Message message) {\n        message.callback.run();\n    }\n```\nemmmm....原来我们post出来的Runnable的run方法就是在这里被调用的呀！\n\n接着检查mCallback是否为null，不为null就调用mCallback的handleMessage方法处理消息，这里对应的是我们在实例化Handler时传入的Callback参数。如果mCallback也为null的话则调用了Handler中的handleMessage(msg)方法。这不正对应了我们第一章的场景一嘛！因此现在再来看下面的代码会不会豁然开朗呢？\n\n```\n\n//\t\t实例化Handler对象 传入Callback参数并重写handleMessage(Message msg)\n static Handler mHandler1 = new Handler(new Handler.Callback() {\n        @Override\n        public boolean handleMessage(Message msg) {\n\n            return false;\n        }\n    });\n\n//\t实例化Handler对象 并重写Handler中的handleMessage(Message msg)\nhandleMessage(Message msg)\n static Handler mHandler = new Handler(){\n\t\t  @Override\n        public boolean handleMessage(Message msg) {\n\n            return false;\n        }\n};\n\n```\n到这里我们总算把Handler的消息机制给串联了起来。\n\n## 三、总结\n\n Handler、Looper和MessageQueue三者共支撑了Android中的消息机制。在使用的时候我们通常只需要和Handler打交道，通过Handler将消息发送出来。而在Handler内部的MessageQueue通过equeueMessage方法将Handler发送的消息以队列的形式进行存储。而Looper则作为一个消息泵，通过loop方法不断的调用MessageQueue的next方法将消息取出并进行处理，依次完成了整个的消息循环。同时，我们还应该特别强调ThreadLocal，正是有了它的存在，才使得我们能够轻松的进行切换线程。\n\n整个过程当如下图所示：\n\n![](https://raw.githubusercontent.com/zhpanvip/Resource/master/image/1101.jfif)\n\n\n看到这里，在第一章中提到的几点疑惑相信你心中应该也已经有了答案。我们不妨再来总结一下：\n\n**问题1：** 在场景1中Handler在子线程中发送出来的消息为什么到了dispatchMessage方法就变成了主线程呢？\n虽然post消息是在子线程，但因为Handler是在主线程中被实例化的，由于在ActivityThread的main方法中调用了Looper.prepare(),因此，通过ThreadLocal将Looper缓存到了主线程中，而MessageQueue是Looper的成员变量，所以其也应是在主线程中。同时，Looper.loop方法将Message取出并通过Message.target.handlerMessage方法最终调用了dispatchMessage方法，所以dispatchMessage方法当然也是在主线程了。\n\n**问题2：** 在场景2的代码中我故意在子线程中调用了Handler的postDelayed方法，那么此时通过postDelayed方法发出来的Runnable究竟是运行在主线程还是子线程呢？\n\n这个问题其实和问题1本质上是同一个问题，就无需多言了！\n\n**问题3**在文中已经给出了答案，这里也不再赘述。\n\n\n\n\n","slug":"11.追根溯源-探究Handler的实现原理","published":1,"updated":"2020-08-29T01:30:48.332Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckegm5nsh0010dwoz2zyp77vo","content":"<h2 id=\"一、初识Handler\"><a href=\"#一、初识Handler\" class=\"headerlink\" title=\"一、初识Handler\"></a>一、初识Handler</h2><p>要分析一个框架的源码，首先需要了解它的使用。我们就从最基础的知识开始吧！</p>\n<h3 id=\"场景1：将数据从子线程发送到主线程。\"><a href=\"#场景1：将数据从子线程发送到主线程。\" class=\"headerlink\" title=\"场景1：将数据从子线程发送到主线程。\"></a>场景1：将数据从子线程发送到主线程。</h3><p>我们知道Android系统中更新UI只能在主线程中进行。而通常网络请求实在子线程中进行的。在获取到服务器数据后我们需要切换到主线程来更新UI。通常在这种情况下我们会考虑使用Handler来进行线程切换。我们来模拟一个网络请求，并通过Handler将数据发送出去：</p>\n<pre><code class=\"hljs java\">\n<span class=\"hljs-keyword\">private</span> Handler mHandler = <span class=\"hljs-keyword\">new</span> Handler()&#123;\n        <span class=\"hljs-meta\">@Override</span>\n        <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">dispatchMessage</span><span class=\"hljs-params\">(<span class=\"hljs-meta\">@NonNull</span> Message msg)</span> </span>&#123;\n            <span class=\"hljs-keyword\">super</span>.dispatchMessage(msg);\n            updateUI(msg);\n        &#125;\n    &#125;;\n<span class=\"hljs-comment\">// 或者可以通过传入Handler.Callback的参数</span>\nHandler mHandler = <span class=\"hljs-keyword\">new</span> Handler(<span class=\"hljs-keyword\">new</span> Handler.Callback() &#123;\n       <span class=\"hljs-meta\">@Override</span>\n       <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">handleMessage</span><span class=\"hljs-params\">(Message msg)</span> </span>&#123;\n\t\tupdateUI(msg);\n           <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>;\n       &#125;\n   &#125;);\n    \n<span class=\"hljs-comment\">// 模拟网络请求</span>\n <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">fetchData</span><span class=\"hljs-params\">()</span> </span>&#123;\n        <span class=\"hljs-keyword\">new</span> Thread()&#123;\n            <span class=\"hljs-meta\">@Override</span>\n            <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">run</span><span class=\"hljs-params\">()</span> </span>&#123;\n                <span class=\"hljs-keyword\">super</span>.run();\n                Message message = mHandler.obtainMessage();\n                message.obj=<span class=\"hljs-string\">&quot;data from server&quot;</span>;\n                mHandler.sendMessage(message);\n            &#125;\n        &#125;.start();\n\n    &#125;</code></pre>\n<p>我们通过子线程模拟网络请求，并将获取的数据通过Handler的sendMessage方法将数据发送了出去。而在Handler的dispatchMessage方法中便可收到刚刚发送的message。并且此时dispatchMessage处于主线程，因此可以直接在dispatchMessage方法中更新UI了。</p>\n<h3 id=\"场景2：延迟发送Runnable\"><a href=\"#场景2：延迟发送Runnable\" class=\"headerlink\" title=\"场景2：延迟发送Runnable\"></a>场景2：延迟发送Runnable</h3><p>场景1是Handler很典型的一个应用，除此之外，我们还经常会通过Handler延迟发送一个Runnable，在delayMillis时间之后会执行Runnable的run方法。代码示例如下：</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-comment\">// 假设是运行在Activity中的代码</span>\n<span class=\"hljs-keyword\">private</span> Handler mHandler = <span class=\"hljs-keyword\">new</span> Handler();\n<span class=\"hljs-keyword\">private</span> Runnable mRunnable = <span class=\"hljs-keyword\">new</span> Runnable() &#123;\n        <span class=\"hljs-meta\">@Override</span>\n        <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">run</span><span class=\"hljs-params\">()</span> </span>&#123;\n            handleMessage();\n        &#125;\n    &#125;;\n <span class=\"hljs-meta\">@Override</span>\n   <span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onCreate</span><span class=\"hljs-params\">(Bundle savedInstanceState)</span> </span>&#123;\n       <span class=\"hljs-keyword\">super</span>.onCreate(savedInstanceState);\n \t<span class=\"hljs-keyword\">new</span> Thread()&#123;\n           <span class=\"hljs-meta\">@Override</span>\n           <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">run</span><span class=\"hljs-params\">()</span> </span>&#123;\n               <span class=\"hljs-keyword\">super</span>.run();\n               mHandler.postDelayed(mRunnable,<span class=\"hljs-number\">1000</span>);\n           &#125;\n       &#125;.start();\n&#125;</code></pre>\n<h3 id=\"场景3：在子线程中初始化Handler\"><a href=\"#场景3：在子线程中初始化Handler\" class=\"headerlink\" title=\"场景3：在子线程中初始化Handler\"></a>场景3：在子线程中初始化Handler</h3><pre><code class=\"hljs java\">Handler mHandler;\n<span class=\"hljs-keyword\">new</span> Thread()&#123;\n           <span class=\"hljs-meta\">@Override</span>\n           <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">run</span><span class=\"hljs-params\">()</span> </span>&#123;\n               <span class=\"hljs-keyword\">super</span>.run();\n               mHandler=<span class=\"hljs-keyword\">new</span> Handler();\n           &#125;\n       &#125;.start();</code></pre>\n<p>此时，运行程序我们会发现程序Crash掉了，并且抛出了以下错误日志：</p>\n<blockquote>\n<p>java.lang.RuntimeException: Can’t create handler inside thread that has not called Looper.prepare()</p>\n</blockquote>\n<p>日志信息提示我们在子线程中创建Handler需要调用Looper.prepare()方法。</p>\n<p>(注:以上场景均未考虑内存泄露问题)</p>\n<p>那么针对以上三个应用场景，有些同学可能表示会有问题：</p>\n<p><strong>问题1：</strong> 在场景1中Handler在子线程中发送出来的消息为什么到了dispatchMessage方法就变成了主线程呢？</p>\n<p><strong>问题2：</strong> 在场景2的代码中我故意在子线程中调用了Handler的postDelayed方法，那么此时通过postDelayed方法发出来的Runnable究竟是运行在主线程还是子线程呢？</p>\n<p><strong>问题3：</strong>  为什么在主线程中直接创建Handler可以正常运行而在子线程中创建Handler需要调用Looper.prepare()方法呢？</p>\n<p>如果想要解开以上几个疑惑，就需要我们对Handler的源码有深入的了解。那么接下来我们就进入Handler的源码分析环节吧！</p>\n<h2 id=\"二、Handler源码溯源历程\"><a href=\"#二、Handler源码溯源历程\" class=\"headerlink\" title=\"二、Handler源码溯源历程\"></a>二、Handler源码溯源历程</h2><h3 id=\"1-从实例化一个Handler说起\"><a href=\"#1-从实例化一个Handler说起\" class=\"headerlink\" title=\"1.从实例化一个Handler说起\"></a>1.从实例化一个Handler说起</h3><p>在使用Handler的第一步就需要我们先实例化一个Handler。那么，我们就从new Handler()着手，看看在初始化Handler的时候做了哪些操作：</p>\n<pre><code class=\"hljs java\">\n<span class=\"hljs-keyword\">final</span> Looper mLooper;\n   <span class=\"hljs-keyword\">final</span> MessageQueue mQueue;\n<span class=\"hljs-keyword\">final</span> Callback mCallback;\n   <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">boolean</span> mAsynchronous;\n   <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">Handler</span><span class=\"hljs-params\">()</span> </span>&#123;\n       <span class=\"hljs-keyword\">this</span>(<span class=\"hljs-keyword\">null</span>, <span class=\"hljs-keyword\">false</span>);\n   &#125;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">Handler</span><span class=\"hljs-params\">(<span class=\"hljs-meta\">@Nullable</span> Callback callback, <span class=\"hljs-keyword\">boolean</span> async)</span> </span>&#123;\n        <span class=\"hljs-keyword\">if</span> (FIND_POTENTIAL_LEAKS) &#123;\n            <span class=\"hljs-keyword\">final</span> Class&lt;? extends Handler&gt; klass = getClass();\n            <span class=\"hljs-keyword\">if</span> ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;\n                    (klass.getModifiers() &amp; Modifier.STATIC) == <span class=\"hljs-number\">0</span>) &#123;\n                Log.w(TAG, <span class=\"hljs-string\">&quot;The following Handler class should be static or leaks might occur: &quot;</span> +\n                    klass.getCanonicalName());\n            &#125;\n        &#125;\n\n        mLooper = Looper.myLooper();\n        <span class=\"hljs-keyword\">if</span> (mLooper == <span class=\"hljs-keyword\">null</span>) &#123;\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> RuntimeException(\n                <span class=\"hljs-string\">&quot;Can&#x27;t create handler inside thread &quot;</span> + Thread.currentThread()\n                        + <span class=\"hljs-string\">&quot; that has not called Looper.prepare()&quot;</span>);\n        &#125;\n        mQueue = mLooper.mQueue;\n        mCallback = callback;\n        mAsynchronous = async;\n    &#125;\n</code></pre>\n<p>可以看到，调用Handler的无参构造方法实例化Handler最终调用了Handler(@Nullable Callback callback, boolean async)的构造方法，而在这个构造方法中的逻辑似乎也很简单，通过调用Looper.myLooper()方法得到了一个Looper对象，如果此时mLooper为null，则会抛出一个RuntimeException。仔细看看发现这个异常信息不就是我们在第一章场景三中在子线程中初始化Handler的时候抛出来的异常吗？那么，什么时候通过Looper.myPrepare()方法得到的Handler会是空呢？要解决这个问题怕是要到Looper中一探究竟了。</p>\n<p>首先来看下Looper.myPrepare()方法的源码：</p>\n<pre><code class=\"hljs java\">\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-meta\">@Nullable</span> <span class=\"hljs-function\">Looper <span class=\"hljs-title\">myLooper</span><span class=\"hljs-params\">()</span> </span>&#123;\n    <span class=\"hljs-keyword\">return</span> sThreadLocal.get();\n&#125;\n</code></pre>\n\n<p>这是Looper中的一个静态方法，这个方法简单到只有一行代码，即调用了ThreadLocal的get()方法来得到一个Looper。ThreadLocal是Java中的一个类，它是一个泛型类，有set(T)和T get()两个方法。ThreadLocal的神奇之处在于它可以在指定线程中存储数据，什么意思呢？即你在某个线程中存储的数据只能在该线程中获取的到。关于ThreadLocal我们只需要了解这些就够了，其实现原理不做深究，有兴趣的可以自从查阅源码。</p>\n<p>既然了解了ThreadLocal的作用，那么在Looper内部一定事先调用了ThreadLocal的set方法。通过全局搜索sThreadLocal，发现了prepare()方法，其源码如下：</p>\n<pre><code class=\"hljs java\">\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">prepare</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">boolean</span> quitAllowed)</span> </span>&#123;\n     <span class=\"hljs-keyword\">if</span> (sThreadLocal.get() != <span class=\"hljs-keyword\">null</span>) &#123;\n         <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> RuntimeException(<span class=\"hljs-string\">&quot;Only one Looper may be created per thread&quot;</span>);\n     &#125;\n     sThreadLocal.set(<span class=\"hljs-keyword\">new</span> Looper(quitAllowed));\n &#125;\n</code></pre>\n<p>果真如我们预料的那样，在Looper的prepare方法中实例化了Looper，并将其放入到了ThreadLocal中。而如果没有调用Looper.prepare()方法，那么获取到的Looper一定是null。到这里似乎解释了第一章的场景三在子线程中实例化Handler需要事先调用Looper.prepare()方法。但是，到这里我们似乎还是没有解释清楚疑惑三，为什么在主线程中直接实例化Handler却没有抛出异常呢？其实，当程序启动的时候会同时启动主线程，我们知道Java程序的入口是main方法。而在Android程序启动的入口同样是main方法。我们在ActivityThread中找到main方法，源码如下：</p>\n<pre><code class=\"hljs java\">\n# ActivityThread\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>&#123;\n        \n\t\t...\n\n        Looper.prepareMainLooper();\n\t\t...\n\n        Looper.loop();\n\n        <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> RuntimeException(<span class=\"hljs-string\">&quot;Main thread loop unexpectedly exited&quot;</span>);\n    &#125;\n\n # Looper\n <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">prepareMainLooper</span><span class=\"hljs-params\">()</span> </span>&#123;\n        prepare(<span class=\"hljs-keyword\">false</span>);\n        <span class=\"hljs-keyword\">synchronized</span> (Looper.class) &#123;\n            <span class=\"hljs-keyword\">if</span> (sMainLooper != <span class=\"hljs-keyword\">null</span>) &#123;\n                <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> IllegalStateException(<span class=\"hljs-string\">&quot;The main Looper has already been prepared.&quot;</span>);\n            &#125;\n            sMainLooper = myLooper();\n        &#125;\n    &#125;\n\n</code></pre>\n\n<p>在main方法中调用了Looper.prepareMauinLooper()方法，而Looper.prepareMauinLooper()中又调用了prepare方法。因此，我们可以在主线程中直接实例化Handler而不用担心抛出异常。</p>\n<h3 id=\"2-Handler的postXXX-或sendXXX\"><a href=\"#2-Handler的postXXX-或sendXXX\" class=\"headerlink\" title=\"2.Handler的postXXX()或sendXXX\"></a>2.Handler的postXXX()或sendXXX</h3><p>实例化Handler后，我们通常会通过Handler提供的方法来发送一个消息。在第一章节中列举了Handler的sendMessage()和postDelay()方法，其实除了这两个方法之外，Handler还提供了一系列的sendXXX()和postXXX()的方法。但追踪源码发现这些方法最终都会调用到sendMessageAtTime方法。</p>\n<p>我们就以postDelayed方法为例来分析。首先，来看postDelayed的源码：</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">postDelayed</span><span class=\"hljs-params\">(<span class=\"hljs-meta\">@NonNull</span> Runnable r, <span class=\"hljs-keyword\">long</span> delayMillis)</span> </span>&#123;\n        <span class=\"hljs-keyword\">return</span> sendMessageDelayed(getPostMessage(r), delayMillis);\n    &#125;</code></pre>\n\n<p>在postDelayed中调用了sendMessageDelayed方法，这个方法的第一个参数接收一个Message，这里通过getPostMessage(r)方法得到了Message对象，getPostMessage(r)源码如下：</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> Message <span class=\"hljs-title\">getPostMessage</span><span class=\"hljs-params\">(Runnable r)</span> </span>&#123;\n        Message m = Message.obtain();\n        m.callback = r;\n        <span class=\"hljs-keyword\">return</span> m;\n    &#125;\n</code></pre>\n<p>可以看到，在getPostMessage方法中将Runnable赋值给了Message.callback，此处我们先立一个Flag。</p>\n<p>接下来追溯到sendMessageDelayed方法中：</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">sendMessageDelayed</span><span class=\"hljs-params\">(<span class=\"hljs-meta\">@NonNull</span> Message msg, <span class=\"hljs-keyword\">long</span> delayMillis)</span> </span>&#123;\n        <span class=\"hljs-keyword\">if</span> (delayMillis &lt; <span class=\"hljs-number\">0</span>) &#123;\n            delayMillis = <span class=\"hljs-number\">0</span>;\n        &#125;\n        <span class=\"hljs-keyword\">return</span> sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);\n    &#125;</code></pre>\n<p>在这个方法中我们终于看到了sendMessageAtTime方法，其源码如下：</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">sendMessageAtTime</span><span class=\"hljs-params\">(<span class=\"hljs-meta\">@NonNull</span> Message msg, <span class=\"hljs-keyword\">long</span> uptimeMillis)</span> </span>&#123;\n        MessageQueue queue = mQueue;\n        <span class=\"hljs-keyword\">if</span> (queue == <span class=\"hljs-keyword\">null</span>) &#123;\n            RuntimeException e = <span class=\"hljs-keyword\">new</span> RuntimeException(\n                    <span class=\"hljs-keyword\">this</span> + <span class=\"hljs-string\">&quot; sendMessageAtTime() called with no mQueue&quot;</span>);\n            Log.w(<span class=\"hljs-string\">&quot;Looper&quot;</span>, e.getMessage(), e);\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>;\n        &#125;\n        <span class=\"hljs-keyword\">return</span> enqueueMessage(queue, msg, uptimeMillis);\n    &#125;</code></pre>\n<p>这个方法中的代码逻辑很简单，仅仅调用了enqueueMessage方法，源码如下：</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">enqueueMessage</span><span class=\"hljs-params\">(<span class=\"hljs-meta\">@NonNull</span> MessageQueue queue, <span class=\"hljs-meta\">@NonNull</span> Message msg,</span></span>\n<span class=\"hljs-function\"><span class=\"hljs-params\">            <span class=\"hljs-keyword\">long</span> uptimeMillis)</span> </span>&#123;\n        msg.target = <span class=\"hljs-keyword\">this</span>;\n        msg.workSourceUid = ThreadLocalWorkSource.getUid();\n\n        <span class=\"hljs-keyword\">if</span> (mAsynchronous) &#123;\n            msg.setAsynchronous(<span class=\"hljs-keyword\">true</span>);\n        &#125;\n        <span class=\"hljs-keyword\">return</span> queue.enqueueMessage(msg, uptimeMillis);\n    &#125;</code></pre>\n<p>在这个方法中我们需要注意的一点– msg.target = this，把当前Handler的对象赋值给了Message.target。紧接着调用了MessageQueue的enqueueMessage方法。MessageQueue这个类我们在上边已经碰到过了。即在实例化Handler的时候将mLooper.mQueue赋值给了Handler的mQueue.那么现在是时候来认识一下MessageQueue了。</p>\n<h3 id=\"3-MessageQueue\"><a href=\"#3-MessageQueue\" class=\"headerlink\" title=\"3.MessageQueue\"></a>3.MessageQueue</h3><p>上一小节中我们在Handler的构造方法中看到了将mLooper.mQueue赋值给了Handler中的mQueue。而MessageQueue从名字上似乎也可以看出来它是一个存储消息的队列。并且在Handler的enqueueMessage方法中通过MessageQueue的enqueueMessage将消息添加到了MessageQueue中。接下来，我们看下enqueueMessage的源码：</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">enqueueMessage</span><span class=\"hljs-params\">(Message msg, <span class=\"hljs-keyword\">long</span> when)</span> </span>&#123;\n        <span class=\"hljs-keyword\">if</span> (msg.target == <span class=\"hljs-keyword\">null</span>) &#123;\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> IllegalArgumentException(<span class=\"hljs-string\">&quot;Message must have a target.&quot;</span>);\n        &#125;\n        <span class=\"hljs-keyword\">if</span> (msg.isInUse()) &#123;\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> IllegalStateException(msg + <span class=\"hljs-string\">&quot; This message is already in use.&quot;</span>);\n        &#125;\n\n        <span class=\"hljs-keyword\">synchronized</span> (<span class=\"hljs-keyword\">this</span>) &#123;\n            <span class=\"hljs-keyword\">if</span> (mQuitting) &#123;\n                IllegalStateException e = <span class=\"hljs-keyword\">new</span> IllegalStateException(\n                        msg.target + <span class=\"hljs-string\">&quot; sending message to a Handler on a dead thread&quot;</span>);\n                Log.w(TAG, e.getMessage(), e);\n                msg.recycle();\n                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>;\n            &#125;\n\n            msg.markInUse();\n            msg.when = when;\n            Message p = mMessages;\n            <span class=\"hljs-keyword\">boolean</span> needWake;\n            <span class=\"hljs-keyword\">if</span> (p == <span class=\"hljs-keyword\">null</span> || when == <span class=\"hljs-number\">0</span> || when &lt; p.when) &#123;\n                <span class=\"hljs-comment\">// New head, wake up the event queue if blocked.</span>\n                msg.next = p;\n                mMessages = msg;\n                needWake = mBlocked;\n            &#125; <span class=\"hljs-keyword\">else</span> &#123;\n                <span class=\"hljs-comment\">// Inserted within the middle of the queue.  Usually we don&#x27;t have to wake</span>\n                <span class=\"hljs-comment\">// up the event queue unless there is a barrier at the head of the queue</span>\n                <span class=\"hljs-comment\">// and the message is the earliest asynchronous message in the queue.</span>\n                needWake = mBlocked &amp;&amp; p.target == <span class=\"hljs-keyword\">null</span> &amp;&amp; msg.isAsynchronous();\n                Message prev;\n                <span class=\"hljs-keyword\">for</span> (;;) &#123;\n                    prev = p;\n                    p = p.next;\n                    <span class=\"hljs-keyword\">if</span> (p == <span class=\"hljs-keyword\">null</span> || when &lt; p.when) &#123;\n                        <span class=\"hljs-keyword\">break</span>;\n                    &#125;\n                    <span class=\"hljs-keyword\">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;\n                        needWake = <span class=\"hljs-keyword\">false</span>;\n                    &#125;\n                &#125;\n                msg.next = p; <span class=\"hljs-comment\">// invariant: p == prev.next</span>\n                prev.next = msg;\n            &#125;\n\n            <span class=\"hljs-comment\">// We can assume mPtr != 0 because mQuitting is false.</span>\n            <span class=\"hljs-keyword\">if</span> (needWake) &#123;\n                nativeWake(mPtr);\n            &#125;\n        &#125;\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">true</span>;\n    &#125;\n</code></pre>\n<p>emmmmmm…阅读源码发现MessageQueue是一个用单项链表实现的队列，为什么是用链表？其实细想一下也不奇怪，因为我们可能频繁的将Message进行插入和删除。而使用链表性能上很明显要优于顺序表。这一段代码就是一个将Message插入到链表的一个过程，其实也没什么可以解释的。</p>\n<p>既然有插入消息，那必然也会有取出消息。我们进入MessageQueue的源码，发现在MessageQueue中发现还有另外一个叫next的方法：</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-function\">Message <span class=\"hljs-title\">next</span><span class=\"hljs-params\">()</span> </span>&#123;\n        <span class=\"hljs-comment\">// Return here if the message loop has already quit and been disposed.</span>\n        <span class=\"hljs-comment\">// This can happen if the application tries to restart a looper after quit</span>\n        <span class=\"hljs-comment\">// which is not supported.</span>\n        <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">long</span> ptr = mPtr;\n        <span class=\"hljs-keyword\">if</span> (ptr == <span class=\"hljs-number\">0</span>) &#123;\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">null</span>;\n        &#125;\n\n        <span class=\"hljs-keyword\">int</span> pendingIdleHandlerCount = -<span class=\"hljs-number\">1</span>; <span class=\"hljs-comment\">// -1 only during first iteration</span>\n        <span class=\"hljs-keyword\">int</span> nextPollTimeoutMillis = <span class=\"hljs-number\">0</span>;\n        <span class=\"hljs-keyword\">for</span> (;;) &#123;\n            <span class=\"hljs-keyword\">if</span> (nextPollTimeoutMillis != <span class=\"hljs-number\">0</span>) &#123;\n                Binder.flushPendingCommands();\n            &#125;\n\n            nativePollOnce(ptr, nextPollTimeoutMillis);\n\n            <span class=\"hljs-keyword\">synchronized</span> (<span class=\"hljs-keyword\">this</span>) &#123;\n                <span class=\"hljs-comment\">// Try to retrieve the next message.  Return if found.</span>\n                <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">long</span> now = SystemClock.uptimeMillis();\n                Message prevMsg = <span class=\"hljs-keyword\">null</span>;\n                Message msg = mMessages;\n                <span class=\"hljs-keyword\">if</span> (msg != <span class=\"hljs-keyword\">null</span> &amp;&amp; msg.target == <span class=\"hljs-keyword\">null</span>) &#123;\n                    <span class=\"hljs-comment\">// Stalled by a barrier.  Find the next asynchronous message in the queue.</span>\n                    <span class=\"hljs-keyword\">do</span> &#123;\n                        prevMsg = msg;\n                        msg = msg.next;\n                    &#125; <span class=\"hljs-keyword\">while</span> (msg != <span class=\"hljs-keyword\">null</span> &amp;&amp; !msg.isAsynchronous());\n                &#125;\n                <span class=\"hljs-keyword\">if</span> (msg != <span class=\"hljs-keyword\">null</span>) &#123;\n                    <span class=\"hljs-keyword\">if</span> (now &lt; msg.when) &#123;\n                        <span class=\"hljs-comment\">// Next message is not ready.  Set a timeout to wake up when it is ready.</span>\n                        nextPollTimeoutMillis = (<span class=\"hljs-keyword\">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);\n                    &#125; <span class=\"hljs-keyword\">else</span> &#123;\n                        <span class=\"hljs-comment\">// Got a message.</span>\n                        mBlocked = <span class=\"hljs-keyword\">false</span>;\n                        <span class=\"hljs-keyword\">if</span> (prevMsg != <span class=\"hljs-keyword\">null</span>) &#123;\n                            prevMsg.next = msg.next;\n                        &#125; <span class=\"hljs-keyword\">else</span> &#123;\n                            mMessages = msg.next;\n                        &#125;\n                        msg.next = <span class=\"hljs-keyword\">null</span>;\n                        <span class=\"hljs-keyword\">if</span> (DEBUG) Log.v(TAG, <span class=\"hljs-string\">&quot;Returning message: &quot;</span> + msg);\n                        msg.markInUse();\n                        <span class=\"hljs-keyword\">return</span> msg;\n                    &#125;\n                &#125; <span class=\"hljs-keyword\">else</span> &#123;\n                    <span class=\"hljs-comment\">// No more messages.</span>\n                    nextPollTimeoutMillis = -<span class=\"hljs-number\">1</span>;\n                &#125;\n\n                <span class=\"hljs-comment\">// Process the quit message now that all pending messages have been handled.</span>\n                <span class=\"hljs-keyword\">if</span> (mQuitting) &#123;\n                    dispose();\n                    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">null</span>;\n                &#125;\n\n                <span class=\"hljs-comment\">// If first time idle, then get the number of idlers to run.</span>\n                <span class=\"hljs-comment\">// Idle handles only run if the queue is empty or if the first message</span>\n                <span class=\"hljs-comment\">// in the queue (possibly a barrier) is due to be handled in the future.</span>\n                <span class=\"hljs-keyword\">if</span> (pendingIdleHandlerCount &lt; <span class=\"hljs-number\">0</span>\n                        &amp;&amp; (mMessages == <span class=\"hljs-keyword\">null</span> || now &lt; mMessages.when)) &#123;\n                    pendingIdleHandlerCount = mIdleHandlers.size();\n                &#125;\n                <span class=\"hljs-keyword\">if</span> (pendingIdleHandlerCount &lt;= <span class=\"hljs-number\">0</span>) &#123;\n                    <span class=\"hljs-comment\">// No idle handlers to run.  Loop and wait some more.</span>\n                    mBlocked = <span class=\"hljs-keyword\">true</span>;\n                    <span class=\"hljs-keyword\">continue</span>;\n                &#125;\n\n                <span class=\"hljs-keyword\">if</span> (mPendingIdleHandlers == <span class=\"hljs-keyword\">null</span>) &#123;\n                    mPendingIdleHandlers = <span class=\"hljs-keyword\">new</span> IdleHandler[Math.max(pendingIdleHandlerCount, <span class=\"hljs-number\">4</span>)];\n                &#125;\n                mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);\n            &#125;\n\n            <span class=\"hljs-comment\">// Run the idle handlers.</span>\n            <span class=\"hljs-comment\">// We only ever reach this code block during the first iteration.</span>\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; pendingIdleHandlerCount; i++) &#123;\n                <span class=\"hljs-keyword\">final</span> IdleHandler idler = mPendingIdleHandlers[i];\n                mPendingIdleHandlers[i] = <span class=\"hljs-keyword\">null</span>; <span class=\"hljs-comment\">// release the reference to the handler</span>\n\n                <span class=\"hljs-keyword\">boolean</span> keep = <span class=\"hljs-keyword\">false</span>;\n                <span class=\"hljs-keyword\">try</span> &#123;\n                    keep = idler.queueIdle();\n                &#125; <span class=\"hljs-keyword\">catch</span> (Throwable t) &#123;\n                    Log.wtf(TAG, <span class=\"hljs-string\">&quot;IdleHandler threw exception&quot;</span>, t);\n                &#125;\n\n                <span class=\"hljs-keyword\">if</span> (!keep) &#123;\n                    <span class=\"hljs-keyword\">synchronized</span> (<span class=\"hljs-keyword\">this</span>) &#123;\n                        mIdleHandlers.remove(idler);\n                    &#125;\n                &#125;\n            &#125;\n\n            <span class=\"hljs-comment\">// Reset the idle handler count to 0 so we do not run them again.</span>\n            pendingIdleHandlerCount = <span class=\"hljs-number\">0</span>;\n\n            <span class=\"hljs-comment\">// While calling an idle handler, a new message could have been delivered</span>\n            <span class=\"hljs-comment\">// so go back and look again for a pending message without waiting.</span>\n            nextPollTimeoutMillis = <span class=\"hljs-number\">0</span>;\n        &#125;\n    &#125;\n</code></pre>\n<p>这个方法的返回值是一个Message，很显然，这个方法就是从MessageQueue中取出消息的。我们注意到第12行代码，这里是一个for(;;)死循环。如果在MessageQueue中有Message的时候，next会将这个Message移除并返回。而当MessageQueue为空时，next方法将会被阻塞。</p>\n<h3 id=\"4-回归Looper\"><a href=\"#4-回归Looper\" class=\"headerlink\" title=\"4.回归Looper\"></a>4.回归Looper</h3><p>我们了解了MessageQueue的插入和删除，但直到此时还没有看到在什么地方调用了MessageQueue的next方法将消息取出的。此时，我们将目光再次回归到Looper中。如果你刚才留意了ActivityThread中的main方法的话，应该注意到了main方法中的Looper.loop()方法,没错，一切将从这里开始，只有调用loop方法后消息循环系统才会真正运作起来，我们们来看loop的源码：</p>\n<pre><code class=\"hljs reasonml\"><span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">    * Run the message queue in this thread. Be sure to call</span>\n<span class=\"hljs-comment\">    * &#123;@link #quit()&#125; to end the loop.</span>\n<span class=\"hljs-comment\">    */</span>\n   public static void loop<span class=\"hljs-literal\">()</span> &#123;\n       final Looper me = my<span class=\"hljs-constructor\">Looper()</span>;\n       <span class=\"hljs-keyword\">if</span> (me<span class=\"hljs-operator\"> == </span>null) &#123;\n           throw <span class=\"hljs-keyword\">new</span> <span class=\"hljs-constructor\">RuntimeException(<span class=\"hljs-string\">&quot;No Looper; Looper.prepare() wasn&#x27;t called on this thread.&quot;</span>)</span>;\n       &#125;\n       final MessageQueue queue = me.mQueue;\n\n       <span class=\"hljs-comment\">// Make sure the identity of this thread is that of the local process,</span>\n       <span class=\"hljs-comment\">// and keep track of what that identity token actually is.</span>\n       <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">Binder</span>.</span></span>clear<span class=\"hljs-constructor\">CallingIdentity()</span>;\n       final long ident = <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">Binder</span>.</span></span>clear<span class=\"hljs-constructor\">CallingIdentity()</span>;\n\n       <span class=\"hljs-keyword\">for</span> (;;) &#123;\n           Message msg = queue.next<span class=\"hljs-literal\">()</span>; <span class=\"hljs-comment\">// might block</span>\n           <span class=\"hljs-keyword\">if</span> (msg<span class=\"hljs-operator\"> == </span>null) &#123;\n               <span class=\"hljs-comment\">// No message indicates that the message queue is quitting.</span>\n               return;\n           &#125;\n\n           <span class=\"hljs-comment\">// This must be in a local variable, in case a UI event sets the logger</span>\n           final Printer logging = me.mLogging;\n           <span class=\"hljs-keyword\">if</span> (logging != null) &#123;\n               logging.println(<span class=\"hljs-string\">&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot;</span> + msg.target + <span class=\"hljs-string\">&quot; &quot;</span> +\n                       msg.callback + <span class=\"hljs-string\">&quot;: &quot;</span> + msg.what);\n           &#125;\n\n           final long traceTag = me.mTraceTag;\n           <span class=\"hljs-keyword\">if</span> (traceTag != <span class=\"hljs-number\">0</span><span class=\"hljs-operator\"> &amp;&amp; </span><span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">Trace</span>.</span></span>is<span class=\"hljs-constructor\">TagEnabled(<span class=\"hljs-params\">traceTag</span>)</span>) &#123;\n               <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">Trace</span>.</span></span>trace<span class=\"hljs-constructor\">Begin(<span class=\"hljs-params\">traceTag</span>, <span class=\"hljs-params\">msg</span>.<span class=\"hljs-params\">target</span>.<span class=\"hljs-params\">getTraceName</span>(<span class=\"hljs-params\">msg</span>)</span>);\n           &#125;\n           <span class=\"hljs-keyword\">try</span> &#123;\n               msg.target.dispatch<span class=\"hljs-constructor\">Message(<span class=\"hljs-params\">msg</span>)</span>;\n           &#125; finally &#123;\n               <span class=\"hljs-keyword\">if</span> (traceTag != <span class=\"hljs-number\">0</span>) &#123;\n                   <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">Trace</span>.</span></span>trace<span class=\"hljs-constructor\">End(<span class=\"hljs-params\">traceTag</span>)</span>;\n               &#125;\n           &#125;\n\n           <span class=\"hljs-keyword\">if</span> (logging != null) &#123;\n               logging.println(<span class=\"hljs-string\">&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot;</span> + msg.target + <span class=\"hljs-string\">&quot; &quot;</span> + msg.callback);\n           &#125;\n\n           <span class=\"hljs-comment\">// Make sure that during the course of dispatching the</span>\n           <span class=\"hljs-comment\">// identity of the thread wasn&#x27;t corrupted.</span>\n           final long newIdent = <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">Binder</span>.</span></span>clear<span class=\"hljs-constructor\">CallingIdentity()</span>;\n           <span class=\"hljs-keyword\">if</span> (ident != newIdent) &#123;\n               <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">Log</span>.</span></span>wtf(TAG, <span class=\"hljs-string\">&quot;Thread identity changed from 0x&quot;</span>\n                       + <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">Long</span>.</span></span><span class=\"hljs-keyword\">to</span><span class=\"hljs-constructor\">HexString(<span class=\"hljs-params\">ident</span>)</span> + <span class=\"hljs-string\">&quot; to 0x&quot;</span>\n                       + <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">Long</span>.</span></span><span class=\"hljs-keyword\">to</span><span class=\"hljs-constructor\">HexString(<span class=\"hljs-params\">newIdent</span>)</span> + <span class=\"hljs-string\">&quot; while dispatching to &quot;</span>\n                       + msg.target.get<span class=\"hljs-constructor\">Class()</span>.get<span class=\"hljs-constructor\">Name()</span> + <span class=\"hljs-string\">&quot; &quot;</span>\n                       + msg.callback + <span class=\"hljs-string\">&quot; what=&quot;</span> + msg.what);\n           &#125;\n\n           msg.recycle<span class=\"hljs-constructor\">Unchecked()</span>;\n       &#125;\n   &#125;</code></pre>\n<p>这里的loop方法同样也是一个死循环。只有当MessageQueue.next()返回null时才会跳出循环。上一小节中我们分析了Message.next方法是一个阻塞操作当MessageQueue中没有消息时next方法会一直被阻塞，因此也致使loop方法被阻塞。而当MessageQueue中添加了一条消息后，loop方法则会立即通过MessageQueue.next方法将消息取出并处理。可以看到通过调用msg.target.dispatchMessage(msg)处理消息。而msg.target是什么呢？我们回过头来看本章第二小节，在Handler的enqueueMessage中将Handler赋值给了msg.target,我们从Message的源码中也可以得到印证：</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Message</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">Parcelable</span> </span>&#123;\n\t...\n\t\n  <span class=\"hljs-comment\">/*package*/</span> Handler target;\n\t\n\t...\n&#125;\n</code></pre>\n<p>也就是此时的target其实就是Handler本身，此时我们找到Handler的dispatchMessage方法，源码如下：</p>\n<pre><code class=\"hljs java\">\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">dispatchMessage</span><span class=\"hljs-params\">(<span class=\"hljs-meta\">@NonNull</span> Message msg)</span> </span>&#123;\n       <span class=\"hljs-keyword\">if</span> (msg.callback != <span class=\"hljs-keyword\">null</span>) &#123;\n           handleCallback(msg);\n       &#125; <span class=\"hljs-keyword\">else</span> &#123;\n           <span class=\"hljs-keyword\">if</span> (mCallback != <span class=\"hljs-keyword\">null</span>) &#123;\n               <span class=\"hljs-keyword\">if</span> (mCallback.handleMessage(msg)) &#123;\n                   <span class=\"hljs-keyword\">return</span>;\n               &#125;\n           &#125;\n           handleMessage(msg);\n       &#125;\n   &#125;\n</code></pre>\n\n<p>看到这里想必大家应该就都明白了，上述代码首先检查了Message的callback是否为null，不为null就通过handleCallback来处理消息。Message的callback是一个Runnable对象，实际上就是Handler的post方法传递的Runnable参数，此时对应的是我们在第一章中的场景二。handleCallback方法代码如下：</p>\n<pre><code class=\"hljs arduino\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">handleCallback</span><span class=\"hljs-params\">(Message message)</span> </span>&#123;\n        message.callback.<span class=\"hljs-built_in\">run</span>();\n    &#125;</code></pre>\n<p>emmmm….原来我们post出来的Runnable的run方法就是在这里被调用的呀！</p>\n<p>接着检查mCallback是否为null，不为null就调用mCallback的handleMessage方法处理消息，这里对应的是我们在实例化Handler时传入的Callback参数。如果mCallback也为null的话则调用了Handler中的handleMessage(msg)方法。这不正对应了我们第一章的场景一嘛！因此现在再来看下面的代码会不会豁然开朗呢？</p>\n<pre><code class=\"hljs aspectj\">\n<span class=\"hljs-comment\">//\t\t实例化Handler对象 传入Callback参数并重写handleMessage(Message msg)</span>\n <span class=\"hljs-keyword\">static</span> Handler mHandler1 = <span class=\"hljs-keyword\">new</span> Handler(<span class=\"hljs-keyword\">new</span> Handler.Callback() &#123;\n        <span class=\"hljs-meta\">@Override</span>\n        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">handleMessage</span><span class=\"hljs-params\">(Message msg)</span> </span>&#123;\n\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>;\n        &#125;\n    &#125;);\n\n<span class=\"hljs-comment\">//\t实例化Handler对象 并重写Handler中的handleMessage(Message msg)</span>\nhandleMessage(Message msg)\n <span class=\"hljs-keyword\">static</span> Handler mHandler = <span class=\"hljs-keyword\">new</span> Handler()&#123;\n\t\t  <span class=\"hljs-meta\">@Override</span>\n        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">handleMessage</span><span class=\"hljs-params\">(Message msg)</span> </span>&#123;\n\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>;\n        &#125;\n&#125;;\n</code></pre>\n<p>到这里我们总算把Handler的消息机制给串联了起来。</p>\n<h2 id=\"三、总结\"><a href=\"#三、总结\" class=\"headerlink\" title=\"三、总结\"></a>三、总结</h2><p> Handler、Looper和MessageQueue三者共支撑了Android中的消息机制。在使用的时候我们通常只需要和Handler打交道，通过Handler将消息发送出来。而在Handler内部的MessageQueue通过equeueMessage方法将Handler发送的消息以队列的形式进行存储。而Looper则作为一个消息泵，通过loop方法不断的调用MessageQueue的next方法将消息取出并进行处理，依次完成了整个的消息循环。同时，我们还应该特别强调ThreadLocal，正是有了它的存在，才使得我们能够轻松的进行切换线程。</p>\n<p>整个过程当如下图所示：</p>\n<p><img src=\"https://raw.githubusercontent.com/zhpanvip/Resource/master/image/1101.jfif\"></p>\n<p>看到这里，在第一章中提到的几点疑惑相信你心中应该也已经有了答案。我们不妨再来总结一下：</p>\n<p><strong>问题1：</strong> 在场景1中Handler在子线程中发送出来的消息为什么到了dispatchMessage方法就变成了主线程呢？<br>虽然post消息是在子线程，但因为Handler是在主线程中被实例化的，由于在ActivityThread的main方法中调用了Looper.prepare(),因此，通过ThreadLocal将Looper缓存到了主线程中，而MessageQueue是Looper的成员变量，所以其也应是在主线程中。同时，Looper.loop方法将Message取出并通过Message.target.handlerMessage方法最终调用了dispatchMessage方法，所以dispatchMessage方法当然也是在主线程了。</p>\n<p><strong>问题2：</strong> 在场景2的代码中我故意在子线程中调用了Handler的postDelayed方法，那么此时通过postDelayed方法发出来的Runnable究竟是运行在主线程还是子线程呢？</p>\n<p>这个问题其实和问题1本质上是同一个问题，就无需多言了！</p>\n<p><strong>问题3</strong>在文中已经给出了答案，这里也不再赘述。</p>\n","site":{"data":{"fluid_config":{"favicon":"/img/favicon.png","apple_touch_icon":"/img/favicon.png","title_join_string":" - ","force_https":false,"highlight":{"enable":true,"style":"Github Gist","bg_color":false,"copy_btn":true},"fun_features":{"typing":{"enable":true,"typeSpeed":70,"cursorChar":"|","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"mouse_click":{"enable":false,"style":"values"}},"dark_mode":{"enable":true,"default":"auto"},"color":{"body_bg_color":"#eee","body_bg_color_dark":"#181c27","navbar_bg_color":"#2f4154","navbar_bg_color_dark":"#1f3144","navbar_text_color":"#fff","navbar_text_color_dark":"#d0d0d0","text_color":"#3c4858","text_color_dark":"#c4c6c9","sec_text_color":"#718096","sec_text_color_dark":"#a7a9ad","post_text_color":"#2c3e50","post_text_color_dark":"#c4c6c9","post_heading_color":"#1a202c","post_heading_color_dark":"#c4c6c9","post_link_color":"#0366d6","post_link_color_dark":"#1589e9","link_hover_color":"#30a9de","link_hover_color_dark":"#30a9de","link_hover_bg_color":"#f8f9fa","link_hover_bg_color_dark":"#364151","board_color":"#fff","board_color_dark":"#252d38"},"font":{"font_size":"16px","font_family":null,"code_font_size":"85%"},"custom_js":null,"custom_css":null,"custom_html":"","web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"tajs":null,"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}},"lazyload":{"enable":true,"onlypost":false},"daovoice":{"enable":false,"appid":""},"aplayer":{"enable":false,"autoplay":false,"loop":"all","order":"random","theme":"#b7daff","songs":[{"name":"name","artist":"artist","url":"/songs/test.mp3","cover":"/img/cover.jpg"},{"name":"name","artist":"artist","url":"https://...url.mp3","cover":"https://...cover.jpg"}]},"version":{"check":false},"navbar":{"blog_title":"zhangpan","ground_glass":{"enable":false,"px":3,"alpha":0.7},"menu":[{"key":"home","link":"/","icon":"iconfont icon-home-fill"},{"key":"archive","link":"/archives/","icon":"iconfont icon-archive-fill"},{"key":"category","link":"/categories/","icon":"iconfont icon-category-fill"},{"key":"tag","link":"/tags/","icon":"iconfont icon-tags-fill"},{"key":"about","link":"/about/","icon":"iconfont icon-user-fill"}]},"search":{"enable":true,"path":"/local-search.xml","generate_path":"/local-search.xml","field":"post","content":true},"scroll_down_arrow":{"enable":true,"banner_height_limit":90,"scroll_after_turning_page":true},"banner_parallax":true,"footer":{"statistics":{"enable":false,"source":"busuanzi","pv_format":"总访问量 {} 次","uv_format":"总访客数 {} 人"},"beian":{"enable":false,"icp_text":"京ICP证123456号","police_text":"京公网安备12345678号","police_code":12345678,"police_icon":"/img/police_beian.png"}},"scroll_top_arrow":{"enable":true},"index":{"banner_img":"/img/default.png","banner_img_height":100,"banner_mask_alpha":0.3,"post_default_img":"","slogan":{"enable":true,"text":"Talk is cheap, show me the code."},"auto_excerpt":{"enable":true},"post_url_target":"_self","post_meta":{"date":true,"category":true,"tag":true}},"page":{"banner_img":"/img/default.png","banner_img_height":60,"banner_mask_alpha":0.3},"post":{"banner_img":"/img/default.png","banner_img_height":70,"banner_mask_alpha":0.3,"meta":{"date":{"enable":true,"format":"LL a"},"wordcount":{"enable":true,"format":"{} 字"},"min2read":{"enable":true,"format":"{} 分钟","words":100},"views":{"enable":false,"source":"busuanzi","format":"{} 次"}},"updated":{"enable":false,"content":"本文最后更新于：","relative":false},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"copyright":{"enable":true,"content":"本博客所有文章除特别声明外，均采用 <a href=\"https://creativecommons.org/licenses/by-sa/4.0/deed.zh\" rel=\"nofollow noopener\">CC BY-SA 4.0 协议</a> ，转载请注明出处！ <h5>开源库推荐</h5> <a href=\"https://github.com/zhpanvip/BannerViewPager\">1.BannerViewPager</a> <p> 一个基于ViewPager2实现的具有强大功能的无限轮播库。支持多种页面切换效果和指示器样式。 </p>\n<a href=\"https://github.com/zhpanvip/viewpagerindicator\">2.ViewPagerIndicator</a> <p> 一个适用于ViewPager和ViewPager2的指示器，支持多种滑块样式及滑动模式 </p>"},"prev_next":{"enable":true},"custom":{"enable":false,"content":"<img src=\"https://octodex.github.com/images/jetpacktocat.png\" class=\"rounded mx-auto d-block mt-5\" style=\"width:150px; height:150px;\">"},"image_zoom":{"enable":true},"footnote":{"enable":true,"header":""},"math":{"enable":false,"specific":false,"engine":"mathjax"},"mermaid":{"enable":false,"specific":false,"options":{"theme":"default"}},"comments":{"enable":true,"type":"utterances"}},"utterances":{"repo":"zhpanvip/utterances-comment","issue_term":"pathname","label":"utterances","theme":"github-light","crossorigin":"anonymous"},"disqus":{"shortname":null,"disqusjs":false,"apikey":null},"gitalk":{"clientID":null,"clientSecret":null,"repo":null,"owner":null,"admin":["name"],"id":"location.pathname","language":"zh-CN","labels":["Gitalk"],"perPage":10,"pagerDirection":"last","distractionFreeMode":false,"createIssueManually":true},"valine":{"appid":"hXIROaIM5y9qnieojJRWP5hS","appkey":"y0f3w3aqd1MF7JL9ma4WECTy","placeholder":"说点什么","path":"window.location.pathname","avatar":"retro","meta":["nick","mail","link"],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"https://zhangpan.site"},"changyan":{"appid":"","appkey":""},"livere":{"uid":""},"archive":{"banner_img":"/img/bg_article.jpg","banner_img_height":60,"banner_mask_alpha":0.3,"subtitle":null},"category":{"banner_img":"/img/bg_default.png","banner_img_height":60,"banner_mask_alpha":0.3,"subtitle":null,"post_limit":10,"order_by":"-length"},"tag":{"banner_img":"/img/bg_label.jpg","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null,"tagcloud":{"min_font":15,"max_font":30,"unit":"px","start_color":"#BBBBEE","end_color":"#337ab7"}},"about":{"banner_img":"/img/bg_default.png","banner_img_height":60,"banner_mask_alpha":0.3,"subtitle":null,"avatar":"/img/avatar.png","name":"myname","introduce":"一句简短的介绍","icons":[{"class":"iconfont icon-github-fill","link":"https://github.com","tip":"GitHub"},{"class":"iconfont icon-douban-fill","link":"https://douban.com","tip":"豆瓣"},{"class":"iconfont icon-wechat-fill","qrcode":"/img/favicon.png"}]},"page404":{"banner_img":"/img/default.png","banner_img_height":85,"banner_mask_alpha":0.3,"subtitle":"Page not found"},"links":{"banner_img":"/img/default.png","banner_img_height":60,"banner_mask_alpha":0.3,"subtitle":null,"items":[{"title":"Fluid Docs","intro":"主题使用指南","link":"https://hexo.fluid-dev.com/docs/","image":"/img/favicon.png"},{"title":"Fluid Repo","intro":"主题 GitHub 仓库","link":"https://github.com/fluid-dev/hexo-theme-fluid","image":"/img/favicon.png"},{"title":"Fluid Example","intro":"主题操作示例","link":"https://hexo.fluid-dev.com/docs/example/","image":"/img/favicon.png"}]}}}},"excerpt":"","more":"<h2 id=\"一、初识Handler\"><a href=\"#一、初识Handler\" class=\"headerlink\" title=\"一、初识Handler\"></a>一、初识Handler</h2><p>要分析一个框架的源码，首先需要了解它的使用。我们就从最基础的知识开始吧！</p>\n<h3 id=\"场景1：将数据从子线程发送到主线程。\"><a href=\"#场景1：将数据从子线程发送到主线程。\" class=\"headerlink\" title=\"场景1：将数据从子线程发送到主线程。\"></a>场景1：将数据从子线程发送到主线程。</h3><p>我们知道Android系统中更新UI只能在主线程中进行。而通常网络请求实在子线程中进行的。在获取到服务器数据后我们需要切换到主线程来更新UI。通常在这种情况下我们会考虑使用Handler来进行线程切换。我们来模拟一个网络请求，并通过Handler将数据发送出去：</p>\n<pre><code class=\"hljs java\">\n<span class=\"hljs-keyword\">private</span> Handler mHandler = <span class=\"hljs-keyword\">new</span> Handler()&#123;\n        <span class=\"hljs-meta\">@Override</span>\n        <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">dispatchMessage</span><span class=\"hljs-params\">(<span class=\"hljs-meta\">@NonNull</span> Message msg)</span> </span>&#123;\n            <span class=\"hljs-keyword\">super</span>.dispatchMessage(msg);\n            updateUI(msg);\n        &#125;\n    &#125;;\n<span class=\"hljs-comment\">// 或者可以通过传入Handler.Callback的参数</span>\nHandler mHandler = <span class=\"hljs-keyword\">new</span> Handler(<span class=\"hljs-keyword\">new</span> Handler.Callback() &#123;\n       <span class=\"hljs-meta\">@Override</span>\n       <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">handleMessage</span><span class=\"hljs-params\">(Message msg)</span> </span>&#123;\n\t\tupdateUI(msg);\n           <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>;\n       &#125;\n   &#125;);\n    \n<span class=\"hljs-comment\">// 模拟网络请求</span>\n <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">fetchData</span><span class=\"hljs-params\">()</span> </span>&#123;\n        <span class=\"hljs-keyword\">new</span> Thread()&#123;\n            <span class=\"hljs-meta\">@Override</span>\n            <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">run</span><span class=\"hljs-params\">()</span> </span>&#123;\n                <span class=\"hljs-keyword\">super</span>.run();\n                Message message = mHandler.obtainMessage();\n                message.obj=<span class=\"hljs-string\">&quot;data from server&quot;</span>;\n                mHandler.sendMessage(message);\n            &#125;\n        &#125;.start();\n\n    &#125;</code></pre>\n<p>我们通过子线程模拟网络请求，并将获取的数据通过Handler的sendMessage方法将数据发送了出去。而在Handler的dispatchMessage方法中便可收到刚刚发送的message。并且此时dispatchMessage处于主线程，因此可以直接在dispatchMessage方法中更新UI了。</p>\n<h3 id=\"场景2：延迟发送Runnable\"><a href=\"#场景2：延迟发送Runnable\" class=\"headerlink\" title=\"场景2：延迟发送Runnable\"></a>场景2：延迟发送Runnable</h3><p>场景1是Handler很典型的一个应用，除此之外，我们还经常会通过Handler延迟发送一个Runnable，在delayMillis时间之后会执行Runnable的run方法。代码示例如下：</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-comment\">// 假设是运行在Activity中的代码</span>\n<span class=\"hljs-keyword\">private</span> Handler mHandler = <span class=\"hljs-keyword\">new</span> Handler();\n<span class=\"hljs-keyword\">private</span> Runnable mRunnable = <span class=\"hljs-keyword\">new</span> Runnable() &#123;\n        <span class=\"hljs-meta\">@Override</span>\n        <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">run</span><span class=\"hljs-params\">()</span> </span>&#123;\n            handleMessage();\n        &#125;\n    &#125;;\n <span class=\"hljs-meta\">@Override</span>\n   <span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onCreate</span><span class=\"hljs-params\">(Bundle savedInstanceState)</span> </span>&#123;\n       <span class=\"hljs-keyword\">super</span>.onCreate(savedInstanceState);\n \t<span class=\"hljs-keyword\">new</span> Thread()&#123;\n           <span class=\"hljs-meta\">@Override</span>\n           <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">run</span><span class=\"hljs-params\">()</span> </span>&#123;\n               <span class=\"hljs-keyword\">super</span>.run();\n               mHandler.postDelayed(mRunnable,<span class=\"hljs-number\">1000</span>);\n           &#125;\n       &#125;.start();\n&#125;</code></pre>\n<h3 id=\"场景3：在子线程中初始化Handler\"><a href=\"#场景3：在子线程中初始化Handler\" class=\"headerlink\" title=\"场景3：在子线程中初始化Handler\"></a>场景3：在子线程中初始化Handler</h3><pre><code class=\"hljs java\">Handler mHandler;\n<span class=\"hljs-keyword\">new</span> Thread()&#123;\n           <span class=\"hljs-meta\">@Override</span>\n           <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">run</span><span class=\"hljs-params\">()</span> </span>&#123;\n               <span class=\"hljs-keyword\">super</span>.run();\n               mHandler=<span class=\"hljs-keyword\">new</span> Handler();\n           &#125;\n       &#125;.start();</code></pre>\n<p>此时，运行程序我们会发现程序Crash掉了，并且抛出了以下错误日志：</p>\n<blockquote>\n<p>java.lang.RuntimeException: Can’t create handler inside thread that has not called Looper.prepare()</p>\n</blockquote>\n<p>日志信息提示我们在子线程中创建Handler需要调用Looper.prepare()方法。</p>\n<p>(注:以上场景均未考虑内存泄露问题)</p>\n<p>那么针对以上三个应用场景，有些同学可能表示会有问题：</p>\n<p><strong>问题1：</strong> 在场景1中Handler在子线程中发送出来的消息为什么到了dispatchMessage方法就变成了主线程呢？</p>\n<p><strong>问题2：</strong> 在场景2的代码中我故意在子线程中调用了Handler的postDelayed方法，那么此时通过postDelayed方法发出来的Runnable究竟是运行在主线程还是子线程呢？</p>\n<p><strong>问题3：</strong>  为什么在主线程中直接创建Handler可以正常运行而在子线程中创建Handler需要调用Looper.prepare()方法呢？</p>\n<p>如果想要解开以上几个疑惑，就需要我们对Handler的源码有深入的了解。那么接下来我们就进入Handler的源码分析环节吧！</p>\n<h2 id=\"二、Handler源码溯源历程\"><a href=\"#二、Handler源码溯源历程\" class=\"headerlink\" title=\"二、Handler源码溯源历程\"></a>二、Handler源码溯源历程</h2><h3 id=\"1-从实例化一个Handler说起\"><a href=\"#1-从实例化一个Handler说起\" class=\"headerlink\" title=\"1.从实例化一个Handler说起\"></a>1.从实例化一个Handler说起</h3><p>在使用Handler的第一步就需要我们先实例化一个Handler。那么，我们就从new Handler()着手，看看在初始化Handler的时候做了哪些操作：</p>\n<pre><code class=\"hljs java\">\n<span class=\"hljs-keyword\">final</span> Looper mLooper;\n   <span class=\"hljs-keyword\">final</span> MessageQueue mQueue;\n<span class=\"hljs-keyword\">final</span> Callback mCallback;\n   <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">boolean</span> mAsynchronous;\n   <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">Handler</span><span class=\"hljs-params\">()</span> </span>&#123;\n       <span class=\"hljs-keyword\">this</span>(<span class=\"hljs-keyword\">null</span>, <span class=\"hljs-keyword\">false</span>);\n   &#125;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">Handler</span><span class=\"hljs-params\">(<span class=\"hljs-meta\">@Nullable</span> Callback callback, <span class=\"hljs-keyword\">boolean</span> async)</span> </span>&#123;\n        <span class=\"hljs-keyword\">if</span> (FIND_POTENTIAL_LEAKS) &#123;\n            <span class=\"hljs-keyword\">final</span> Class&lt;? extends Handler&gt; klass = getClass();\n            <span class=\"hljs-keyword\">if</span> ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;\n                    (klass.getModifiers() &amp; Modifier.STATIC) == <span class=\"hljs-number\">0</span>) &#123;\n                Log.w(TAG, <span class=\"hljs-string\">&quot;The following Handler class should be static or leaks might occur: &quot;</span> +\n                    klass.getCanonicalName());\n            &#125;\n        &#125;\n\n        mLooper = Looper.myLooper();\n        <span class=\"hljs-keyword\">if</span> (mLooper == <span class=\"hljs-keyword\">null</span>) &#123;\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> RuntimeException(\n                <span class=\"hljs-string\">&quot;Can&#x27;t create handler inside thread &quot;</span> + Thread.currentThread()\n                        + <span class=\"hljs-string\">&quot; that has not called Looper.prepare()&quot;</span>);\n        &#125;\n        mQueue = mLooper.mQueue;\n        mCallback = callback;\n        mAsynchronous = async;\n    &#125;\n</code></pre>\n<p>可以看到，调用Handler的无参构造方法实例化Handler最终调用了Handler(@Nullable Callback callback, boolean async)的构造方法，而在这个构造方法中的逻辑似乎也很简单，通过调用Looper.myLooper()方法得到了一个Looper对象，如果此时mLooper为null，则会抛出一个RuntimeException。仔细看看发现这个异常信息不就是我们在第一章场景三中在子线程中初始化Handler的时候抛出来的异常吗？那么，什么时候通过Looper.myPrepare()方法得到的Handler会是空呢？要解决这个问题怕是要到Looper中一探究竟了。</p>\n<p>首先来看下Looper.myPrepare()方法的源码：</p>\n<pre><code class=\"hljs java\">\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-meta\">@Nullable</span> <span class=\"hljs-function\">Looper <span class=\"hljs-title\">myLooper</span><span class=\"hljs-params\">()</span> </span>&#123;\n    <span class=\"hljs-keyword\">return</span> sThreadLocal.get();\n&#125;\n</code></pre>\n\n<p>这是Looper中的一个静态方法，这个方法简单到只有一行代码，即调用了ThreadLocal的get()方法来得到一个Looper。ThreadLocal是Java中的一个类，它是一个泛型类，有set(T)和T get()两个方法。ThreadLocal的神奇之处在于它可以在指定线程中存储数据，什么意思呢？即你在某个线程中存储的数据只能在该线程中获取的到。关于ThreadLocal我们只需要了解这些就够了，其实现原理不做深究，有兴趣的可以自从查阅源码。</p>\n<p>既然了解了ThreadLocal的作用，那么在Looper内部一定事先调用了ThreadLocal的set方法。通过全局搜索sThreadLocal，发现了prepare()方法，其源码如下：</p>\n<pre><code class=\"hljs java\">\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">prepare</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">boolean</span> quitAllowed)</span> </span>&#123;\n     <span class=\"hljs-keyword\">if</span> (sThreadLocal.get() != <span class=\"hljs-keyword\">null</span>) &#123;\n         <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> RuntimeException(<span class=\"hljs-string\">&quot;Only one Looper may be created per thread&quot;</span>);\n     &#125;\n     sThreadLocal.set(<span class=\"hljs-keyword\">new</span> Looper(quitAllowed));\n &#125;\n</code></pre>\n<p>果真如我们预料的那样，在Looper的prepare方法中实例化了Looper，并将其放入到了ThreadLocal中。而如果没有调用Looper.prepare()方法，那么获取到的Looper一定是null。到这里似乎解释了第一章的场景三在子线程中实例化Handler需要事先调用Looper.prepare()方法。但是，到这里我们似乎还是没有解释清楚疑惑三，为什么在主线程中直接实例化Handler却没有抛出异常呢？其实，当程序启动的时候会同时启动主线程，我们知道Java程序的入口是main方法。而在Android程序启动的入口同样是main方法。我们在ActivityThread中找到main方法，源码如下：</p>\n<pre><code class=\"hljs java\">\n# ActivityThread\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>&#123;\n        \n\t\t...\n\n        Looper.prepareMainLooper();\n\t\t...\n\n        Looper.loop();\n\n        <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> RuntimeException(<span class=\"hljs-string\">&quot;Main thread loop unexpectedly exited&quot;</span>);\n    &#125;\n\n # Looper\n <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">prepareMainLooper</span><span class=\"hljs-params\">()</span> </span>&#123;\n        prepare(<span class=\"hljs-keyword\">false</span>);\n        <span class=\"hljs-keyword\">synchronized</span> (Looper.class) &#123;\n            <span class=\"hljs-keyword\">if</span> (sMainLooper != <span class=\"hljs-keyword\">null</span>) &#123;\n                <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> IllegalStateException(<span class=\"hljs-string\">&quot;The main Looper has already been prepared.&quot;</span>);\n            &#125;\n            sMainLooper = myLooper();\n        &#125;\n    &#125;\n\n</code></pre>\n\n<p>在main方法中调用了Looper.prepareMauinLooper()方法，而Looper.prepareMauinLooper()中又调用了prepare方法。因此，我们可以在主线程中直接实例化Handler而不用担心抛出异常。</p>\n<h3 id=\"2-Handler的postXXX-或sendXXX\"><a href=\"#2-Handler的postXXX-或sendXXX\" class=\"headerlink\" title=\"2.Handler的postXXX()或sendXXX\"></a>2.Handler的postXXX()或sendXXX</h3><p>实例化Handler后，我们通常会通过Handler提供的方法来发送一个消息。在第一章节中列举了Handler的sendMessage()和postDelay()方法，其实除了这两个方法之外，Handler还提供了一系列的sendXXX()和postXXX()的方法。但追踪源码发现这些方法最终都会调用到sendMessageAtTime方法。</p>\n<p>我们就以postDelayed方法为例来分析。首先，来看postDelayed的源码：</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">postDelayed</span><span class=\"hljs-params\">(<span class=\"hljs-meta\">@NonNull</span> Runnable r, <span class=\"hljs-keyword\">long</span> delayMillis)</span> </span>&#123;\n        <span class=\"hljs-keyword\">return</span> sendMessageDelayed(getPostMessage(r), delayMillis);\n    &#125;</code></pre>\n\n<p>在postDelayed中调用了sendMessageDelayed方法，这个方法的第一个参数接收一个Message，这里通过getPostMessage(r)方法得到了Message对象，getPostMessage(r)源码如下：</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> Message <span class=\"hljs-title\">getPostMessage</span><span class=\"hljs-params\">(Runnable r)</span> </span>&#123;\n        Message m = Message.obtain();\n        m.callback = r;\n        <span class=\"hljs-keyword\">return</span> m;\n    &#125;\n</code></pre>\n<p>可以看到，在getPostMessage方法中将Runnable赋值给了Message.callback，此处我们先立一个Flag。</p>\n<p>接下来追溯到sendMessageDelayed方法中：</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">sendMessageDelayed</span><span class=\"hljs-params\">(<span class=\"hljs-meta\">@NonNull</span> Message msg, <span class=\"hljs-keyword\">long</span> delayMillis)</span> </span>&#123;\n        <span class=\"hljs-keyword\">if</span> (delayMillis &lt; <span class=\"hljs-number\">0</span>) &#123;\n            delayMillis = <span class=\"hljs-number\">0</span>;\n        &#125;\n        <span class=\"hljs-keyword\">return</span> sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);\n    &#125;</code></pre>\n<p>在这个方法中我们终于看到了sendMessageAtTime方法，其源码如下：</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">sendMessageAtTime</span><span class=\"hljs-params\">(<span class=\"hljs-meta\">@NonNull</span> Message msg, <span class=\"hljs-keyword\">long</span> uptimeMillis)</span> </span>&#123;\n        MessageQueue queue = mQueue;\n        <span class=\"hljs-keyword\">if</span> (queue == <span class=\"hljs-keyword\">null</span>) &#123;\n            RuntimeException e = <span class=\"hljs-keyword\">new</span> RuntimeException(\n                    <span class=\"hljs-keyword\">this</span> + <span class=\"hljs-string\">&quot; sendMessageAtTime() called with no mQueue&quot;</span>);\n            Log.w(<span class=\"hljs-string\">&quot;Looper&quot;</span>, e.getMessage(), e);\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>;\n        &#125;\n        <span class=\"hljs-keyword\">return</span> enqueueMessage(queue, msg, uptimeMillis);\n    &#125;</code></pre>\n<p>这个方法中的代码逻辑很简单，仅仅调用了enqueueMessage方法，源码如下：</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">enqueueMessage</span><span class=\"hljs-params\">(<span class=\"hljs-meta\">@NonNull</span> MessageQueue queue, <span class=\"hljs-meta\">@NonNull</span> Message msg,</span></span>\n<span class=\"hljs-function\"><span class=\"hljs-params\">            <span class=\"hljs-keyword\">long</span> uptimeMillis)</span> </span>&#123;\n        msg.target = <span class=\"hljs-keyword\">this</span>;\n        msg.workSourceUid = ThreadLocalWorkSource.getUid();\n\n        <span class=\"hljs-keyword\">if</span> (mAsynchronous) &#123;\n            msg.setAsynchronous(<span class=\"hljs-keyword\">true</span>);\n        &#125;\n        <span class=\"hljs-keyword\">return</span> queue.enqueueMessage(msg, uptimeMillis);\n    &#125;</code></pre>\n<p>在这个方法中我们需要注意的一点– msg.target = this，把当前Handler的对象赋值给了Message.target。紧接着调用了MessageQueue的enqueueMessage方法。MessageQueue这个类我们在上边已经碰到过了。即在实例化Handler的时候将mLooper.mQueue赋值给了Handler的mQueue.那么现在是时候来认识一下MessageQueue了。</p>\n<h3 id=\"3-MessageQueue\"><a href=\"#3-MessageQueue\" class=\"headerlink\" title=\"3.MessageQueue\"></a>3.MessageQueue</h3><p>上一小节中我们在Handler的构造方法中看到了将mLooper.mQueue赋值给了Handler中的mQueue。而MessageQueue从名字上似乎也可以看出来它是一个存储消息的队列。并且在Handler的enqueueMessage方法中通过MessageQueue的enqueueMessage将消息添加到了MessageQueue中。接下来，我们看下enqueueMessage的源码：</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">enqueueMessage</span><span class=\"hljs-params\">(Message msg, <span class=\"hljs-keyword\">long</span> when)</span> </span>&#123;\n        <span class=\"hljs-keyword\">if</span> (msg.target == <span class=\"hljs-keyword\">null</span>) &#123;\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> IllegalArgumentException(<span class=\"hljs-string\">&quot;Message must have a target.&quot;</span>);\n        &#125;\n        <span class=\"hljs-keyword\">if</span> (msg.isInUse()) &#123;\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> IllegalStateException(msg + <span class=\"hljs-string\">&quot; This message is already in use.&quot;</span>);\n        &#125;\n\n        <span class=\"hljs-keyword\">synchronized</span> (<span class=\"hljs-keyword\">this</span>) &#123;\n            <span class=\"hljs-keyword\">if</span> (mQuitting) &#123;\n                IllegalStateException e = <span class=\"hljs-keyword\">new</span> IllegalStateException(\n                        msg.target + <span class=\"hljs-string\">&quot; sending message to a Handler on a dead thread&quot;</span>);\n                Log.w(TAG, e.getMessage(), e);\n                msg.recycle();\n                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>;\n            &#125;\n\n            msg.markInUse();\n            msg.when = when;\n            Message p = mMessages;\n            <span class=\"hljs-keyword\">boolean</span> needWake;\n            <span class=\"hljs-keyword\">if</span> (p == <span class=\"hljs-keyword\">null</span> || when == <span class=\"hljs-number\">0</span> || when &lt; p.when) &#123;\n                <span class=\"hljs-comment\">// New head, wake up the event queue if blocked.</span>\n                msg.next = p;\n                mMessages = msg;\n                needWake = mBlocked;\n            &#125; <span class=\"hljs-keyword\">else</span> &#123;\n                <span class=\"hljs-comment\">// Inserted within the middle of the queue.  Usually we don&#x27;t have to wake</span>\n                <span class=\"hljs-comment\">// up the event queue unless there is a barrier at the head of the queue</span>\n                <span class=\"hljs-comment\">// and the message is the earliest asynchronous message in the queue.</span>\n                needWake = mBlocked &amp;&amp; p.target == <span class=\"hljs-keyword\">null</span> &amp;&amp; msg.isAsynchronous();\n                Message prev;\n                <span class=\"hljs-keyword\">for</span> (;;) &#123;\n                    prev = p;\n                    p = p.next;\n                    <span class=\"hljs-keyword\">if</span> (p == <span class=\"hljs-keyword\">null</span> || when &lt; p.when) &#123;\n                        <span class=\"hljs-keyword\">break</span>;\n                    &#125;\n                    <span class=\"hljs-keyword\">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;\n                        needWake = <span class=\"hljs-keyword\">false</span>;\n                    &#125;\n                &#125;\n                msg.next = p; <span class=\"hljs-comment\">// invariant: p == prev.next</span>\n                prev.next = msg;\n            &#125;\n\n            <span class=\"hljs-comment\">// We can assume mPtr != 0 because mQuitting is false.</span>\n            <span class=\"hljs-keyword\">if</span> (needWake) &#123;\n                nativeWake(mPtr);\n            &#125;\n        &#125;\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">true</span>;\n    &#125;\n</code></pre>\n<p>emmmmmm…阅读源码发现MessageQueue是一个用单项链表实现的队列，为什么是用链表？其实细想一下也不奇怪，因为我们可能频繁的将Message进行插入和删除。而使用链表性能上很明显要优于顺序表。这一段代码就是一个将Message插入到链表的一个过程，其实也没什么可以解释的。</p>\n<p>既然有插入消息，那必然也会有取出消息。我们进入MessageQueue的源码，发现在MessageQueue中发现还有另外一个叫next的方法：</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-function\">Message <span class=\"hljs-title\">next</span><span class=\"hljs-params\">()</span> </span>&#123;\n        <span class=\"hljs-comment\">// Return here if the message loop has already quit and been disposed.</span>\n        <span class=\"hljs-comment\">// This can happen if the application tries to restart a looper after quit</span>\n        <span class=\"hljs-comment\">// which is not supported.</span>\n        <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">long</span> ptr = mPtr;\n        <span class=\"hljs-keyword\">if</span> (ptr == <span class=\"hljs-number\">0</span>) &#123;\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">null</span>;\n        &#125;\n\n        <span class=\"hljs-keyword\">int</span> pendingIdleHandlerCount = -<span class=\"hljs-number\">1</span>; <span class=\"hljs-comment\">// -1 only during first iteration</span>\n        <span class=\"hljs-keyword\">int</span> nextPollTimeoutMillis = <span class=\"hljs-number\">0</span>;\n        <span class=\"hljs-keyword\">for</span> (;;) &#123;\n            <span class=\"hljs-keyword\">if</span> (nextPollTimeoutMillis != <span class=\"hljs-number\">0</span>) &#123;\n                Binder.flushPendingCommands();\n            &#125;\n\n            nativePollOnce(ptr, nextPollTimeoutMillis);\n\n            <span class=\"hljs-keyword\">synchronized</span> (<span class=\"hljs-keyword\">this</span>) &#123;\n                <span class=\"hljs-comment\">// Try to retrieve the next message.  Return if found.</span>\n                <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">long</span> now = SystemClock.uptimeMillis();\n                Message prevMsg = <span class=\"hljs-keyword\">null</span>;\n                Message msg = mMessages;\n                <span class=\"hljs-keyword\">if</span> (msg != <span class=\"hljs-keyword\">null</span> &amp;&amp; msg.target == <span class=\"hljs-keyword\">null</span>) &#123;\n                    <span class=\"hljs-comment\">// Stalled by a barrier.  Find the next asynchronous message in the queue.</span>\n                    <span class=\"hljs-keyword\">do</span> &#123;\n                        prevMsg = msg;\n                        msg = msg.next;\n                    &#125; <span class=\"hljs-keyword\">while</span> (msg != <span class=\"hljs-keyword\">null</span> &amp;&amp; !msg.isAsynchronous());\n                &#125;\n                <span class=\"hljs-keyword\">if</span> (msg != <span class=\"hljs-keyword\">null</span>) &#123;\n                    <span class=\"hljs-keyword\">if</span> (now &lt; msg.when) &#123;\n                        <span class=\"hljs-comment\">// Next message is not ready.  Set a timeout to wake up when it is ready.</span>\n                        nextPollTimeoutMillis = (<span class=\"hljs-keyword\">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);\n                    &#125; <span class=\"hljs-keyword\">else</span> &#123;\n                        <span class=\"hljs-comment\">// Got a message.</span>\n                        mBlocked = <span class=\"hljs-keyword\">false</span>;\n                        <span class=\"hljs-keyword\">if</span> (prevMsg != <span class=\"hljs-keyword\">null</span>) &#123;\n                            prevMsg.next = msg.next;\n                        &#125; <span class=\"hljs-keyword\">else</span> &#123;\n                            mMessages = msg.next;\n                        &#125;\n                        msg.next = <span class=\"hljs-keyword\">null</span>;\n                        <span class=\"hljs-keyword\">if</span> (DEBUG) Log.v(TAG, <span class=\"hljs-string\">&quot;Returning message: &quot;</span> + msg);\n                        msg.markInUse();\n                        <span class=\"hljs-keyword\">return</span> msg;\n                    &#125;\n                &#125; <span class=\"hljs-keyword\">else</span> &#123;\n                    <span class=\"hljs-comment\">// No more messages.</span>\n                    nextPollTimeoutMillis = -<span class=\"hljs-number\">1</span>;\n                &#125;\n\n                <span class=\"hljs-comment\">// Process the quit message now that all pending messages have been handled.</span>\n                <span class=\"hljs-keyword\">if</span> (mQuitting) &#123;\n                    dispose();\n                    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">null</span>;\n                &#125;\n\n                <span class=\"hljs-comment\">// If first time idle, then get the number of idlers to run.</span>\n                <span class=\"hljs-comment\">// Idle handles only run if the queue is empty or if the first message</span>\n                <span class=\"hljs-comment\">// in the queue (possibly a barrier) is due to be handled in the future.</span>\n                <span class=\"hljs-keyword\">if</span> (pendingIdleHandlerCount &lt; <span class=\"hljs-number\">0</span>\n                        &amp;&amp; (mMessages == <span class=\"hljs-keyword\">null</span> || now &lt; mMessages.when)) &#123;\n                    pendingIdleHandlerCount = mIdleHandlers.size();\n                &#125;\n                <span class=\"hljs-keyword\">if</span> (pendingIdleHandlerCount &lt;= <span class=\"hljs-number\">0</span>) &#123;\n                    <span class=\"hljs-comment\">// No idle handlers to run.  Loop and wait some more.</span>\n                    mBlocked = <span class=\"hljs-keyword\">true</span>;\n                    <span class=\"hljs-keyword\">continue</span>;\n                &#125;\n\n                <span class=\"hljs-keyword\">if</span> (mPendingIdleHandlers == <span class=\"hljs-keyword\">null</span>) &#123;\n                    mPendingIdleHandlers = <span class=\"hljs-keyword\">new</span> IdleHandler[Math.max(pendingIdleHandlerCount, <span class=\"hljs-number\">4</span>)];\n                &#125;\n                mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);\n            &#125;\n\n            <span class=\"hljs-comment\">// Run the idle handlers.</span>\n            <span class=\"hljs-comment\">// We only ever reach this code block during the first iteration.</span>\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; pendingIdleHandlerCount; i++) &#123;\n                <span class=\"hljs-keyword\">final</span> IdleHandler idler = mPendingIdleHandlers[i];\n                mPendingIdleHandlers[i] = <span class=\"hljs-keyword\">null</span>; <span class=\"hljs-comment\">// release the reference to the handler</span>\n\n                <span class=\"hljs-keyword\">boolean</span> keep = <span class=\"hljs-keyword\">false</span>;\n                <span class=\"hljs-keyword\">try</span> &#123;\n                    keep = idler.queueIdle();\n                &#125; <span class=\"hljs-keyword\">catch</span> (Throwable t) &#123;\n                    Log.wtf(TAG, <span class=\"hljs-string\">&quot;IdleHandler threw exception&quot;</span>, t);\n                &#125;\n\n                <span class=\"hljs-keyword\">if</span> (!keep) &#123;\n                    <span class=\"hljs-keyword\">synchronized</span> (<span class=\"hljs-keyword\">this</span>) &#123;\n                        mIdleHandlers.remove(idler);\n                    &#125;\n                &#125;\n            &#125;\n\n            <span class=\"hljs-comment\">// Reset the idle handler count to 0 so we do not run them again.</span>\n            pendingIdleHandlerCount = <span class=\"hljs-number\">0</span>;\n\n            <span class=\"hljs-comment\">// While calling an idle handler, a new message could have been delivered</span>\n            <span class=\"hljs-comment\">// so go back and look again for a pending message without waiting.</span>\n            nextPollTimeoutMillis = <span class=\"hljs-number\">0</span>;\n        &#125;\n    &#125;\n</code></pre>\n<p>这个方法的返回值是一个Message，很显然，这个方法就是从MessageQueue中取出消息的。我们注意到第12行代码，这里是一个for(;;)死循环。如果在MessageQueue中有Message的时候，next会将这个Message移除并返回。而当MessageQueue为空时，next方法将会被阻塞。</p>\n<h3 id=\"4-回归Looper\"><a href=\"#4-回归Looper\" class=\"headerlink\" title=\"4.回归Looper\"></a>4.回归Looper</h3><p>我们了解了MessageQueue的插入和删除，但直到此时还没有看到在什么地方调用了MessageQueue的next方法将消息取出的。此时，我们将目光再次回归到Looper中。如果你刚才留意了ActivityThread中的main方法的话，应该注意到了main方法中的Looper.loop()方法,没错，一切将从这里开始，只有调用loop方法后消息循环系统才会真正运作起来，我们们来看loop的源码：</p>\n<pre><code class=\"hljs reasonml\"><span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">    * Run the message queue in this thread. Be sure to call</span>\n<span class=\"hljs-comment\">    * &#123;@link #quit()&#125; to end the loop.</span>\n<span class=\"hljs-comment\">    */</span>\n   public static void loop<span class=\"hljs-literal\">()</span> &#123;\n       final Looper me = my<span class=\"hljs-constructor\">Looper()</span>;\n       <span class=\"hljs-keyword\">if</span> (me<span class=\"hljs-operator\"> == </span>null) &#123;\n           throw <span class=\"hljs-keyword\">new</span> <span class=\"hljs-constructor\">RuntimeException(<span class=\"hljs-string\">&quot;No Looper; Looper.prepare() wasn&#x27;t called on this thread.&quot;</span>)</span>;\n       &#125;\n       final MessageQueue queue = me.mQueue;\n\n       <span class=\"hljs-comment\">// Make sure the identity of this thread is that of the local process,</span>\n       <span class=\"hljs-comment\">// and keep track of what that identity token actually is.</span>\n       <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">Binder</span>.</span></span>clear<span class=\"hljs-constructor\">CallingIdentity()</span>;\n       final long ident = <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">Binder</span>.</span></span>clear<span class=\"hljs-constructor\">CallingIdentity()</span>;\n\n       <span class=\"hljs-keyword\">for</span> (;;) &#123;\n           Message msg = queue.next<span class=\"hljs-literal\">()</span>; <span class=\"hljs-comment\">// might block</span>\n           <span class=\"hljs-keyword\">if</span> (msg<span class=\"hljs-operator\"> == </span>null) &#123;\n               <span class=\"hljs-comment\">// No message indicates that the message queue is quitting.</span>\n               return;\n           &#125;\n\n           <span class=\"hljs-comment\">// This must be in a local variable, in case a UI event sets the logger</span>\n           final Printer logging = me.mLogging;\n           <span class=\"hljs-keyword\">if</span> (logging != null) &#123;\n               logging.println(<span class=\"hljs-string\">&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot;</span> + msg.target + <span class=\"hljs-string\">&quot; &quot;</span> +\n                       msg.callback + <span class=\"hljs-string\">&quot;: &quot;</span> + msg.what);\n           &#125;\n\n           final long traceTag = me.mTraceTag;\n           <span class=\"hljs-keyword\">if</span> (traceTag != <span class=\"hljs-number\">0</span><span class=\"hljs-operator\"> &amp;&amp; </span><span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">Trace</span>.</span></span>is<span class=\"hljs-constructor\">TagEnabled(<span class=\"hljs-params\">traceTag</span>)</span>) &#123;\n               <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">Trace</span>.</span></span>trace<span class=\"hljs-constructor\">Begin(<span class=\"hljs-params\">traceTag</span>, <span class=\"hljs-params\">msg</span>.<span class=\"hljs-params\">target</span>.<span class=\"hljs-params\">getTraceName</span>(<span class=\"hljs-params\">msg</span>)</span>);\n           &#125;\n           <span class=\"hljs-keyword\">try</span> &#123;\n               msg.target.dispatch<span class=\"hljs-constructor\">Message(<span class=\"hljs-params\">msg</span>)</span>;\n           &#125; finally &#123;\n               <span class=\"hljs-keyword\">if</span> (traceTag != <span class=\"hljs-number\">0</span>) &#123;\n                   <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">Trace</span>.</span></span>trace<span class=\"hljs-constructor\">End(<span class=\"hljs-params\">traceTag</span>)</span>;\n               &#125;\n           &#125;\n\n           <span class=\"hljs-keyword\">if</span> (logging != null) &#123;\n               logging.println(<span class=\"hljs-string\">&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot;</span> + msg.target + <span class=\"hljs-string\">&quot; &quot;</span> + msg.callback);\n           &#125;\n\n           <span class=\"hljs-comment\">// Make sure that during the course of dispatching the</span>\n           <span class=\"hljs-comment\">// identity of the thread wasn&#x27;t corrupted.</span>\n           final long newIdent = <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">Binder</span>.</span></span>clear<span class=\"hljs-constructor\">CallingIdentity()</span>;\n           <span class=\"hljs-keyword\">if</span> (ident != newIdent) &#123;\n               <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">Log</span>.</span></span>wtf(TAG, <span class=\"hljs-string\">&quot;Thread identity changed from 0x&quot;</span>\n                       + <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">Long</span>.</span></span><span class=\"hljs-keyword\">to</span><span class=\"hljs-constructor\">HexString(<span class=\"hljs-params\">ident</span>)</span> + <span class=\"hljs-string\">&quot; to 0x&quot;</span>\n                       + <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">Long</span>.</span></span><span class=\"hljs-keyword\">to</span><span class=\"hljs-constructor\">HexString(<span class=\"hljs-params\">newIdent</span>)</span> + <span class=\"hljs-string\">&quot; while dispatching to &quot;</span>\n                       + msg.target.get<span class=\"hljs-constructor\">Class()</span>.get<span class=\"hljs-constructor\">Name()</span> + <span class=\"hljs-string\">&quot; &quot;</span>\n                       + msg.callback + <span class=\"hljs-string\">&quot; what=&quot;</span> + msg.what);\n           &#125;\n\n           msg.recycle<span class=\"hljs-constructor\">Unchecked()</span>;\n       &#125;\n   &#125;</code></pre>\n<p>这里的loop方法同样也是一个死循环。只有当MessageQueue.next()返回null时才会跳出循环。上一小节中我们分析了Message.next方法是一个阻塞操作当MessageQueue中没有消息时next方法会一直被阻塞，因此也致使loop方法被阻塞。而当MessageQueue中添加了一条消息后，loop方法则会立即通过MessageQueue.next方法将消息取出并处理。可以看到通过调用msg.target.dispatchMessage(msg)处理消息。而msg.target是什么呢？我们回过头来看本章第二小节，在Handler的enqueueMessage中将Handler赋值给了msg.target,我们从Message的源码中也可以得到印证：</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Message</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">Parcelable</span> </span>&#123;\n\t...\n\t\n  <span class=\"hljs-comment\">/*package*/</span> Handler target;\n\t\n\t...\n&#125;\n</code></pre>\n<p>也就是此时的target其实就是Handler本身，此时我们找到Handler的dispatchMessage方法，源码如下：</p>\n<pre><code class=\"hljs java\">\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">dispatchMessage</span><span class=\"hljs-params\">(<span class=\"hljs-meta\">@NonNull</span> Message msg)</span> </span>&#123;\n       <span class=\"hljs-keyword\">if</span> (msg.callback != <span class=\"hljs-keyword\">null</span>) &#123;\n           handleCallback(msg);\n       &#125; <span class=\"hljs-keyword\">else</span> &#123;\n           <span class=\"hljs-keyword\">if</span> (mCallback != <span class=\"hljs-keyword\">null</span>) &#123;\n               <span class=\"hljs-keyword\">if</span> (mCallback.handleMessage(msg)) &#123;\n                   <span class=\"hljs-keyword\">return</span>;\n               &#125;\n           &#125;\n           handleMessage(msg);\n       &#125;\n   &#125;\n</code></pre>\n\n<p>看到这里想必大家应该就都明白了，上述代码首先检查了Message的callback是否为null，不为null就通过handleCallback来处理消息。Message的callback是一个Runnable对象，实际上就是Handler的post方法传递的Runnable参数，此时对应的是我们在第一章中的场景二。handleCallback方法代码如下：</p>\n<pre><code class=\"hljs arduino\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">handleCallback</span><span class=\"hljs-params\">(Message message)</span> </span>&#123;\n        message.callback.<span class=\"hljs-built_in\">run</span>();\n    &#125;</code></pre>\n<p>emmmm….原来我们post出来的Runnable的run方法就是在这里被调用的呀！</p>\n<p>接着检查mCallback是否为null，不为null就调用mCallback的handleMessage方法处理消息，这里对应的是我们在实例化Handler时传入的Callback参数。如果mCallback也为null的话则调用了Handler中的handleMessage(msg)方法。这不正对应了我们第一章的场景一嘛！因此现在再来看下面的代码会不会豁然开朗呢？</p>\n<pre><code class=\"hljs aspectj\">\n<span class=\"hljs-comment\">//\t\t实例化Handler对象 传入Callback参数并重写handleMessage(Message msg)</span>\n <span class=\"hljs-keyword\">static</span> Handler mHandler1 = <span class=\"hljs-keyword\">new</span> Handler(<span class=\"hljs-keyword\">new</span> Handler.Callback() &#123;\n        <span class=\"hljs-meta\">@Override</span>\n        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">handleMessage</span><span class=\"hljs-params\">(Message msg)</span> </span>&#123;\n\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>;\n        &#125;\n    &#125;);\n\n<span class=\"hljs-comment\">//\t实例化Handler对象 并重写Handler中的handleMessage(Message msg)</span>\nhandleMessage(Message msg)\n <span class=\"hljs-keyword\">static</span> Handler mHandler = <span class=\"hljs-keyword\">new</span> Handler()&#123;\n\t\t  <span class=\"hljs-meta\">@Override</span>\n        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">handleMessage</span><span class=\"hljs-params\">(Message msg)</span> </span>&#123;\n\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>;\n        &#125;\n&#125;;\n</code></pre>\n<p>到这里我们总算把Handler的消息机制给串联了起来。</p>\n<h2 id=\"三、总结\"><a href=\"#三、总结\" class=\"headerlink\" title=\"三、总结\"></a>三、总结</h2><p> Handler、Looper和MessageQueue三者共支撑了Android中的消息机制。在使用的时候我们通常只需要和Handler打交道，通过Handler将消息发送出来。而在Handler内部的MessageQueue通过equeueMessage方法将Handler发送的消息以队列的形式进行存储。而Looper则作为一个消息泵，通过loop方法不断的调用MessageQueue的next方法将消息取出并进行处理，依次完成了整个的消息循环。同时，我们还应该特别强调ThreadLocal，正是有了它的存在，才使得我们能够轻松的进行切换线程。</p>\n<p>整个过程当如下图所示：</p>\n<p><img src=\"https://raw.githubusercontent.com/zhpanvip/Resource/master/image/1101.jfif\"></p>\n<p>看到这里，在第一章中提到的几点疑惑相信你心中应该也已经有了答案。我们不妨再来总结一下：</p>\n<p><strong>问题1：</strong> 在场景1中Handler在子线程中发送出来的消息为什么到了dispatchMessage方法就变成了主线程呢？<br>虽然post消息是在子线程，但因为Handler是在主线程中被实例化的，由于在ActivityThread的main方法中调用了Looper.prepare(),因此，通过ThreadLocal将Looper缓存到了主线程中，而MessageQueue是Looper的成员变量，所以其也应是在主线程中。同时，Looper.loop方法将Message取出并通过Message.target.handlerMessage方法最终调用了dispatchMessage方法，所以dispatchMessage方法当然也是在主线程了。</p>\n<p><strong>问题2：</strong> 在场景2的代码中我故意在子线程中调用了Handler的postDelayed方法，那么此时通过postDelayed方法发出来的Runnable究竟是运行在主线程还是子线程呢？</p>\n<p>这个问题其实和问题1本质上是同一个问题，就无需多言了！</p>\n<p><strong>问题3</strong>在文中已经给出了答案，这里也不再赘述。</p>\n"},{"title":"关于Https的那些事儿","date":"2018-02-11T17:24:11.000Z","_content":"**** 本篇文章已授权微信公众号 guolin_blog （郭霖）独家发布***\n\n由于前不久苹果公司已经强制IOS应用必须使用HTTPS协议开发，虽然Google没有强制开发者使用HTTPS，但相信不久的将来Android也会跟随IOS全面转向HTTPS。因此，HTTPS的学习也是相当重要。本篇文章涉及到的代码不多，主要内容是对HTTPS协议的讲解，最后将结合Retrofit实现HTTPS的单双向认证。\n\n下面将通过以下几节内容来学习HTTPS。\n\n - HTTPS概述 \n - HTTPS实现原理  \n - 数字证书   \n - Https单项认证   \n - Https双向认证\n\n \n \n一、HTTPS概述\n-----------\n\n **1.什么是HTTPS？**\n 我们看维基百科给HTTPS的定义：\n\n> HTTPS（Hypertext Transfer Protocol Secure）是一种通过计算机网络进行安全通信的传输协议。HTTPS经由HTTP进行通信，但利用TLS来加密数据包。HTTPS开发的主要目的，是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。\n\n原来HTTPS就是在HTTP协议的基础上加入了TLS协议。目的是保证我们的数据在网络上传输的安全性。\n\n> TLS是传输层加密协议，前身是SSL协议。由网景公司于1995年发布。后改名为TLS。常用的 TLS 协议版本有：TLS1.2, TLS1.1, TLS1.0 和 SSL3.0。其中 SSL3.0 由于 POODLE 攻击已经被证明不安全。TLS1.0 也存在部分安全漏洞，比如 RC4 和 BEAST 攻击。\n\n由于HTTP协议采用明文传输，我们可以通过抓包很轻松的获取到HTTP所传输的数据。因此，采用HTTP协议是不安全的。这才催生了HTTPS的诞生。HTTPS相对HTTP提供了更安全的数据传输保障。主要体现在三个方面：\n> 1，  内容加密。客户端到服务器的内容都是以加密形式传输，中间者无法直接查看明文内容。\n> 2，  身份认证。通过校验保证客户端访问的是自己的服务器。\n> 3，  数据完整性。防止内容被第三方冒充或者篡改。\n\n\n二、HTTPS实现原理\n-----------\n\n在学习HTTPS原理之前我们先了解一下两种加密方式： 对称加密和非对称加密。\n**对称加密** 即加密和解密使用同一个密钥，虽然对称加密破解难度很大，但由于对称加密需要在网络上传输密钥和密文，一旦被黑客截取很容就能被破解，因此对称加密并不是一个较好的选择。\n**非对称加密** 即加密和解密使用不同的密钥，分别称为公钥和私钥。我们可以用公钥对数据进行加密，但必须要用私钥才能解密。在网络上只需要传送公钥，私钥保存在服务端用于解密公钥加密后的密文。但是非对称加密消耗的CPU资源非常大，效率很低，严重影响HTTPS的性能和速度。因此非对称加密也不是HTTPS的理想选择。\n\n那么HTTPS采用了怎样的加密方式呢？其实为了提高安全性和效率HTTPS结合了对称和非对称两种加密方式。即客户端使用对称加密生成密钥（key）对传输数据进行加密，然后使用非对称加密的公钥再对key进行加密。因此网络上传输的数据是被key加密的密文和用公钥加密后的密文key，因此即使被黑客截取，由于没有私钥，无法获取到明文key，便无法获取到明文数据。所以HTTPS的加密方式是安全的。\n\n接下来我们以TLS1.2为例来认识HTTPS的握手过程。\n\n> 1，  客户端发送 client_hello，包含一个随机数 random1。\n> 2，  服务端回复 server_hello，包含一个随机数 random2，携带了证书公钥 P。\n> 3，  客户端接收到 random2 之后就能够生成 premaster_secrect （对称加密的密钥）以及 master_secrect（用premaster_secret加密后的数据）。\n> 4，  客户端使用证书公钥 P 将 premaster_secrect 加密后发送给服务器 (用公钥P对premaster_secret加密)。\n> 5，  服务端使用私钥解密得到 premaster_secrect。又由于服务端之前就收到了随机数 1，所以服务端根据相同的生成算法，在相同的输入参数下，求出了相同的 master secrect。\n\nHTTPS的握手过程如下图：\n![](https://raw.githubusercontent.com/zhpanvip/Resource/master/image/1201.jfif)\n\n\n\n\n三、数字证书\n------\n\n我们上面提到了HTTPS的工作原理，通过对称加密和非对称加密实现数据的安全传输。我们也知道非对称加密过程需要用到公钥进行加密。那么公钥从何而来？其实公钥就被包含在数字证书中。数字证书通常来说是由受信任的数字证书颁发机构CA，在验证服务器身份后颁发，证书中包含了一个密钥对（公钥和私钥）和所有者识别信息。数字证书被放到服务端，具有服务器身份验证和数据传输加密功能。\n\n除了CA机构颁发的证书之外，还有非CA机构颁发的证书和自签名证书。\n\n - 非CA机构即是不受信任的机构颁发的证书，理所当然这样的证书是不受信任的。\n - 自签名证书，就是自己给自己颁发的证书。当然自签名证书也是不受信任的。\n\n例如大(chou)名(ming)鼎(zhao)鼎(zhu)的12306网站使用的就是非CA机构颁发的证书（最近发现12306购票页面已经改为CA证书了），12306的证书是由SRCA颁发，SRCA中文名叫中铁数字证书认证中心，简称中铁CA。这是个铁道部自己搞的机构，相当于是自己给自己颁发证书。因此我们访问12306时通常会看到如下情景：\n![这里写图片描述](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTgwMjExMTczMjQ4NjE3?x-oss-process=image/format,png)\n\n说了这么多，我们来总结一下数字证书的两个作用：\n> 1， 分发公钥。每个数字证书都包含了注册者生成的公钥。在 TLS握手时会通过 certificate 消息传输给客户端。\n> 2， 身份授权。确保客户端访问的网站是经过 CA 验证的可信任的网站。（在自签名证书的情况下可以验证是否是我们自己的服务器）\n\n最后我们从[别处](http://blog.csdn.net/dd864140130/article/details/52625666)搬来一个中间人攻击的例子，来认识证书是如何保证我们的数据安全的。\n对于一个正常的网络请求，其流程通常如下：\n![](https://raw.githubusercontent.com/zhpanvip/Resource/master/image/1203.jfif)\n\n但是，如果有黑客在通信过程中拦截了这个请求。试想在客户端和服务端中间有一个中间人，两者之间的传输对中间人来说是透明的，那么中间人完全可以获取两端之间的任何数据并加以修改，然后转发给两端。其流程如下图：\n![](https://raw.githubusercontent.com/zhpanvip/Resource/master/image/1204.jfif)\n\n此时恶意服务端完全可以发起双向攻击：对上可以欺骗服务端，对下可以欺骗客户端，更严重的是客户端段和服务端完全感知不到已经被攻击了。这就是所谓的中间人攻击。\n\n> 中间人攻击（MITM攻击）是指，黑客拦截并篡改网络中的通信数据。又分为被动MITM和主动MITM，被动MITM只窃取通信数据而不修改，而主动MITM不但能窃取数据，还会篡改通信数据。最常见的中间人攻击常常发生在公共wifi或者公共路由上。\n\n现在可以看看使用证书是怎么样提高安全性，避免中间人攻击的，用一张简单的流程图来说明：\n\n![](https://raw.githubusercontent.com/zhpanvip/Resource/master/image/1205.jfif)\n\n\n\n 四、HTTPS单项认证\n-----------\n所谓单项认证只要服务端配置证书，客户端在请求服务端时验证服务器的证书即可。我们上述讲到的内容其实都是说的HTTPS单项认证。通常来说对于安全性要求不高的网站单项认证就可以满足我们的需求了。因此我们访问的HTTPS网站大部分都是单项认证。\n\n**1.关于HTTPS的使用存在的误区**\n由于我们对安全性的认识不够重视，通常对于HTTPS存在一些误区，这些误区可能直接给我们带来一些安全隐患。\n***误区（1）：对于CA机构颁发的证书客户端无须内置***  \n上面提到访问HTTPS服务器是需要在客户端配置服务器证书的。有些小伙伴可能就纳闷了，说我们用的就是HTTPS但是并没有在客户端配置证书呢？比如请求百度的网站https://www.baidu.com/，和请求HTTP服务器没什么区别。其实这是因为在Android系统中已经内置了所有CA机构的根证书，也就是只要是CA机构颁发的证书，Android是直接信任的。对于此种情况，虽然可以正常访问到服务器，但是仍然存在安全隐患。假如黑客自家搭建了一个服务器并申请到了CA证书，由于我们客户端没有内置服务器证书，默认信任所有CA证书（客户端可以访问所有持有由CA机构颁发的证书的服务器），那么黑客仍然可以发起中间人攻击劫持我们的请求到黑客的服务器，实际上就成了我们的客户端和黑客的服务器建立起了连接。\n***误区（2）：对于非CA机构颁发的证书和自签名证书，可以忽略证书校验***\n另外一种情况，如果我们服务器的证书是非认证机构颁发的 (例如12306)或者自签名证书，那么我们是无法直接访问到服务器的，直接访问通常会抛出如下异常：\n\n```\njavax.net.ssl.SSLHandshakeException: \n    java.security.cert.CertPathValidatorException: \n        Trust anchor for certification path not found.\n```\n网上很多解决SSLHandshakeException异常的方案是自定义TrustManager忽略证书校验。代码如下：\n\n```\npublic static SSLSocketFactory getSSLSocketFactory() throws Exception {\n        //创建一个不验证证书链的证书信任管理器。\n        final TrustManager[] trustAllCerts = new TrustManager[]{new X509TrustManager() {\n            @Override\n            public void checkClientTrusted(\n                    java.security.cert.X509Certificate[] chain,\n                    String authType) throws CertificateException {\n            }\n\n            @Override\n            public void checkServerTrusted(\n                    java.security.cert.X509Certificate[] chain,\n                    String authType) throws CertificateException {\n            }\n\n            @Override\n            public java.security.cert.X509Certificate[] getAcceptedIssuers() {\n                return new java.security.cert.X509Certificate[0];\n            }\n        }};\n\n        // Install the all-trusting trust manager\n        final SSLContext sslContext = SSLContext.getInstance(\"TLS\");\n        sslContext.init(null, trustAllCerts,\n                new java.security.SecureRandom());\n        // Create an ssl socket factory with our all-trusting manager\n        return sslContext\n                .getSocketFactory();\n    }\n\n\n  //使用自定义SSLSocketFactory\n  private void onHttps(OkHttpClient.Builder builder) {\n       try {\n            builder.sslSocketFactory(getSSLSocketFactory()).hostnameVerifier(org.apache.http.conn.ssl.SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n\n    }\n```\n对于这样的处理方式虽然解决了SSLHandshakeException异常，但是却存在更大的安全隐患。因为此种做法直接使我们的客户端信任了所有证书（包括CA机构颁发的证书和非CA机构颁发的证书以及自签名证书），因此，这样配置将比第一种情况危害更大。\n\n**2.Retrofit绑定证书实现HTTPS单项认证**\n对于上述两种情况中存在的安全隐患，我们应该如何应对？最简单的解决方案就是在客户端内置服务器的证书，我们在校验服务端证书的时候只比对和App内置的证书是否完全相同，如果不同则断开连接。那么此时再遭遇中间人攻击劫持我们的请求时由于黑客服务器没有相应的证书，此时HTTPS请求校验不通过，则无法与黑客的服务器建立起连接。\n\n那么接下来我们就结合Retrofit以访问12306为例来实现HTTPS的单项认证。\n首先从12306网站下载签名证书，并放置到我们项目资源目录raw下。然后根据证书构造SSLSocketFactory，代码如下：\n\n```\n\t/**\n     * 单项认证\n     */\n    public static SSLSocketFactory getSSLSocketFactoryForOneWay(InputStream... certificates) {\n        try {\n            CertificateFactory certificateFactory = CertificateFactory.getInstance(CLIENT_TRUST_MANAGER, CLIENT_TRUST_PROVIDER);\n            KeyStore keyStore = KeyStore.getInstance(CLIENT_TRUST_KEYSTORE);\n            keyStore.load(null);\n            int index = 0;\n            for (InputStream certificate : certificates) {\n                String certificateAlias = Integer.toString(index++);\n                keyStore.setCertificateEntry(certificateAlias, certificateFactory.generateCertificate(certificate));\n                try {\n                    if (certificate != null)\n                        certificate.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n\n            SSLContext sslContext = SSLContext.getInstance(CLIENT_AGREEMENT);\n\n            TrustManagerFactory trustManagerFactory =\n                    TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());\n\n            trustManagerFactory.init(keyStore);\n            sslContext.init(null, trustManagerFactory.getTrustManagers(), new SecureRandom());\n            return sslContext.getSocketFactory();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n```\n接下来为OKHttpClient设置SslSocketFactory以及hostnameVerifier，代码如下：\n\n```\nInputStream certificate12306 = Utils.getContext().getResources().openRawResource(R.raw.srca);\n        OkHttpClient okHttpClient = new OkHttpClient.Builder()\n                .readTimeout(Constants.DEFAULT_TIMEOUT, TimeUnit.MILLISECONDS)\n                .connectTimeout(Constants.DEFAULT_TIMEOUT, TimeUnit.MILLISECONDS)\n                .addInterceptor(interceptor)\n                .addInterceptor(new HttpHeaderInterceptor())\n                .addNetworkInterceptor(new HttpCacheInterceptor())\n                .sslSocketFactory(SslContextFactory.getSSLSocketFactoryForOneWay(certificate12306))  \n                .hostnameVerifier(new SafeHostnameVerifier())\n                .cache(cache)\n                .build();\n```\n上述代码中hostnameVerifier是对服务器的校验，SafeHostnameVerifier代码如下：\n\n```\n private class SafeHostnameVerifier implements HostnameVerifier {\n        @Override\n        public boolean verify(String hostname, SSLSession session) {\n            if (Constants.IP.equals(hostname)) {//校验hostname是否正确，如果正确则建立连接\n                return true;\n            }\n            return false;\n        }\n    }\n```\nverify方法中对比了请求的IP和服务器的IP是否一致，一致则返回true表示校验通过，否则返回false，检验不通过，断开连接。对于网上有些处理是直接返回true，即不对请求的服务器IP做校验，我们不推荐这样使用。而且现在谷歌应用商店已经对此种做法做了限制，禁止在verify方法中直接返回true的App上线。\n\n 五、HTTPS双向认证\n-----------\n对于HTTPS双向认证，用到的情况不多。但是对于像金融行业等对安全性要求较高的企业，通常都会使用双向认证。所谓双向认证就是客户端校验服务器证书，同时服务器也需要校验客户端的证书。因此，双向认证就另需一张证书放到客户端待服务端去验证。\n\n> 单项认证保证了我们自己的客户端只能访问我们自己的服务器，但并不能保证我们自己的服务器只能被我们自己的客户端访问（第三方客户端忽略证书校验即可）。那么双向认证则保证了我们的客户端只能访问我们自己的服务器，同时我们的服务器也只能被我们自己的客户端访问。因此双向认证可以说相比单项认证安全性足足提高一个等级。\n\n**1.双向认证流程**\n接下来我们来了解下双向认证的流程，以加深对双向认证的理解：\n\n> a. 客户端发送一个连接请求给服务器。 \n　　b. 服务器将自己的证书，以及同证书相关的信息发送给客户端。 \n　　c. 客户端检查服务器送过来的证书是否和App内置证书相同。如果是，就继续执行协议；如果不是则终止此次请求。\n　　d. 接着客户端比较证书里的消息，例如域名和公钥，与服务器刚刚发送的相关消息是否一致，如果是一致的，客户端认可这个服务器的合法身份。 \n　　e. 服务器要求客户发送客户自己的证书。收到后，服务器验证客户端的证书，如果没有通过验证，拒绝连接；如果通过验证，服务器获得用户的公钥。 \n　　f. 客户端告诉服务器自己所能够支持的通讯对称密码方案。\n　　g. 服务器从客户发送过来的密码方案中，选择一种加密程度最高的密码方案，用客户的公钥加过密后通知客户端。 \n　　h. 客户端针对这个密码方案，选择一个通话密钥，接着用服务器的公钥加过密后发送给服务器。\n　　i. 服务器接收到客户端送过来的消息，用自己的私钥解密，获得通话密钥。 \n　　j. 服务器通过密钥解密客户端发送的被加密数据，得到明文数据。\n\n**2.Retrofit实现HTTPS双向认证**\n对于双向认证，我们以华为北向平台登录接口为例来进行学习。想了解华为北向API[请戳此处](http://developer.huawei.com/ict/cn/doc/site-oceanconnect-northbound_api_reference-zh/index.html/zh-cn_topic_0087306564)\n我们直接通过浏览器访问登录接口可以看到如下情景：\n![](https://raw.githubusercontent.com/zhpanvip/Resource/master/image/1206.jfif)\n\n哈，惊喜不？直接被拒绝了！这就是双向认证，没有证书想访问服务器门都没有。那么对于双向认证我们应该做怎样的配置？我们可以参考华为开源出来的代码[戳此处](https://github.com/Huawei/IoT_OceanConnect_North_GUI_APPDemo) \n源码中由两个证书文件ca.jks和outgoing.CertwithKey.pkcs12，其中ca.jks是在客户端配置的证书，outgoing.CertwithKey.pkcs12是在服务端配置的证书。因为我们当前客户端是Android系统，由于Android系统不支持jks格式的证书，因此需要把jks转成Android支持的bks格式。转换方式不再贴出，可自行查阅。\n有了证书，接下来看获取SSLSocketFactory的代码：\n\n```\n  /**\n     * 双向认证\n     *\n     * @return SSLSocketFactory\n     */\n    public static SSLSocketFactory getSSLSocketFactoryForTwoWay() {\n        try {\n            InputStream certificate = Utils.getContext().getResources().openRawResource(R.raw.capk);\n            //  CertificateFactory certificateFactory = CertificateFactory.getInstance(\"X.509\", \"BC\");\n            KeyStore keyStore = KeyStore.getInstance(CLIENT_TRUST_KEY);\n            keyStore.load(certificate, SELF_CERT_PWD.toCharArray());\n            KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\n            kmf.init(keyStore, SELF_CERT_PWD.toCharArray());\n\n            try {\n                if (certificate != null)\n                    certificate.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n\n            //初始化keystore\n            KeyStore clientKeyStore = KeyStore.getInstance(CLIENT_TRUST_KEYSTORE);\n            clientKeyStore.load(Utils.getContext().getResources().openRawResource(R.raw.cabks), TRUST_CA_PWD.toCharArray());\n\n            SSLContext sslContext = SSLContext.getInstance(CLIENT_AGREEMENT);\n            TrustManagerFactory trustManagerFactory = TrustManagerFactory.\n                    getInstance(TrustManagerFactory.getDefaultAlgorithm());\n\n            trustManagerFactory.init(clientKeyStore);\n\n            KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\n            keyManagerFactory.init(clientKeyStore, SELF_CERT_PWD.toCharArray());\n\n            sslContext.init(kmf.getKeyManagers(), trustManagerFactory.getTrustManagers(), new SecureRandom());\n            return sslContext.getSocketFactory();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n```\n接下来同样需要配置OKHttpClient，代码如下：\n\n```\nOkHttpClient okHttpClient = new OkHttpClient.Builder()\n                .readTimeout(Constants.DEFAULT_TIMEOUT, TimeUnit.MILLISECONDS)\n                .connectTimeout(Constants.DEFAULT_TIMEOUT, TimeUnit.MILLISECONDS)\n                .addInterceptor(interceptor)\n                .addInterceptor(new HttpHeaderInterceptor())\n                .addNetworkInterceptor(new HttpCacheInterceptor())\n                .sslSocketFactory(SslContextFactory.getSSLSocketFactoryForTwoWay()) \n                .hostnameVerifier(new SafeHostnameVerifier())\n                .cache(cache)\n                .build();\n```\n这样就完成了HTTPS的配置，接下来就可以愉快的访问HTTPS 双向认证的接口了。由于北向登录接口中需要appId和secret两个参数，因此，登录相关代码就不再贴出。\n\n好了，到此关于HTTPS的学习就结束了，如果有不明白的地方可以参看文末源码。以上内容纯属个人对HTTPS的一些认识，如果文中有错误之处还请多多包涵，欢迎留言指正。\n\n本文写成参考了大量的相关文章，在此表示感谢。\n\n[源码参考](https://github.com/zhpanvip/Retrofit2/tree/master/idea/src/main/java/com/zhpan/idea/net/https)\n\n参考\n--\n[大型网站的 HTTPS 实践（1）：HTTPS 协议和原理](http://blog.jobbole.com/86660/)\n[Retrofit中如何正确的使用https？](http://blog.csdn.net/dd864140130/article/details/52625666)\n[Android Https相关完全解析 当OkHttp遇到Https](http://blog.csdn.net/lmj623565791/article/details/48129405)\n[HTTPS原理及OKHTTP对HTTPS的支持](https://www.jianshu.com/p/f2097616e65e)\n\n\n","source":"_posts/12.关于Https的那些事儿.md","raw":"---\ntitle: 关于Https的那些事儿\ndate:  2018-02-12 01:24:11\ntags: https\n---\n**** 本篇文章已授权微信公众号 guolin_blog （郭霖）独家发布***\n\n由于前不久苹果公司已经强制IOS应用必须使用HTTPS协议开发，虽然Google没有强制开发者使用HTTPS，但相信不久的将来Android也会跟随IOS全面转向HTTPS。因此，HTTPS的学习也是相当重要。本篇文章涉及到的代码不多，主要内容是对HTTPS协议的讲解，最后将结合Retrofit实现HTTPS的单双向认证。\n\n下面将通过以下几节内容来学习HTTPS。\n\n - HTTPS概述 \n - HTTPS实现原理  \n - 数字证书   \n - Https单项认证   \n - Https双向认证\n\n \n \n一、HTTPS概述\n-----------\n\n **1.什么是HTTPS？**\n 我们看维基百科给HTTPS的定义：\n\n> HTTPS（Hypertext Transfer Protocol Secure）是一种通过计算机网络进行安全通信的传输协议。HTTPS经由HTTP进行通信，但利用TLS来加密数据包。HTTPS开发的主要目的，是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。\n\n原来HTTPS就是在HTTP协议的基础上加入了TLS协议。目的是保证我们的数据在网络上传输的安全性。\n\n> TLS是传输层加密协议，前身是SSL协议。由网景公司于1995年发布。后改名为TLS。常用的 TLS 协议版本有：TLS1.2, TLS1.1, TLS1.0 和 SSL3.0。其中 SSL3.0 由于 POODLE 攻击已经被证明不安全。TLS1.0 也存在部分安全漏洞，比如 RC4 和 BEAST 攻击。\n\n由于HTTP协议采用明文传输，我们可以通过抓包很轻松的获取到HTTP所传输的数据。因此，采用HTTP协议是不安全的。这才催生了HTTPS的诞生。HTTPS相对HTTP提供了更安全的数据传输保障。主要体现在三个方面：\n> 1，  内容加密。客户端到服务器的内容都是以加密形式传输，中间者无法直接查看明文内容。\n> 2，  身份认证。通过校验保证客户端访问的是自己的服务器。\n> 3，  数据完整性。防止内容被第三方冒充或者篡改。\n\n\n二、HTTPS实现原理\n-----------\n\n在学习HTTPS原理之前我们先了解一下两种加密方式： 对称加密和非对称加密。\n**对称加密** 即加密和解密使用同一个密钥，虽然对称加密破解难度很大，但由于对称加密需要在网络上传输密钥和密文，一旦被黑客截取很容就能被破解，因此对称加密并不是一个较好的选择。\n**非对称加密** 即加密和解密使用不同的密钥，分别称为公钥和私钥。我们可以用公钥对数据进行加密，但必须要用私钥才能解密。在网络上只需要传送公钥，私钥保存在服务端用于解密公钥加密后的密文。但是非对称加密消耗的CPU资源非常大，效率很低，严重影响HTTPS的性能和速度。因此非对称加密也不是HTTPS的理想选择。\n\n那么HTTPS采用了怎样的加密方式呢？其实为了提高安全性和效率HTTPS结合了对称和非对称两种加密方式。即客户端使用对称加密生成密钥（key）对传输数据进行加密，然后使用非对称加密的公钥再对key进行加密。因此网络上传输的数据是被key加密的密文和用公钥加密后的密文key，因此即使被黑客截取，由于没有私钥，无法获取到明文key，便无法获取到明文数据。所以HTTPS的加密方式是安全的。\n\n接下来我们以TLS1.2为例来认识HTTPS的握手过程。\n\n> 1，  客户端发送 client_hello，包含一个随机数 random1。\n> 2，  服务端回复 server_hello，包含一个随机数 random2，携带了证书公钥 P。\n> 3，  客户端接收到 random2 之后就能够生成 premaster_secrect （对称加密的密钥）以及 master_secrect（用premaster_secret加密后的数据）。\n> 4，  客户端使用证书公钥 P 将 premaster_secrect 加密后发送给服务器 (用公钥P对premaster_secret加密)。\n> 5，  服务端使用私钥解密得到 premaster_secrect。又由于服务端之前就收到了随机数 1，所以服务端根据相同的生成算法，在相同的输入参数下，求出了相同的 master secrect。\n\nHTTPS的握手过程如下图：\n![](https://raw.githubusercontent.com/zhpanvip/Resource/master/image/1201.jfif)\n\n\n\n\n三、数字证书\n------\n\n我们上面提到了HTTPS的工作原理，通过对称加密和非对称加密实现数据的安全传输。我们也知道非对称加密过程需要用到公钥进行加密。那么公钥从何而来？其实公钥就被包含在数字证书中。数字证书通常来说是由受信任的数字证书颁发机构CA，在验证服务器身份后颁发，证书中包含了一个密钥对（公钥和私钥）和所有者识别信息。数字证书被放到服务端，具有服务器身份验证和数据传输加密功能。\n\n除了CA机构颁发的证书之外，还有非CA机构颁发的证书和自签名证书。\n\n - 非CA机构即是不受信任的机构颁发的证书，理所当然这样的证书是不受信任的。\n - 自签名证书，就是自己给自己颁发的证书。当然自签名证书也是不受信任的。\n\n例如大(chou)名(ming)鼎(zhao)鼎(zhu)的12306网站使用的就是非CA机构颁发的证书（最近发现12306购票页面已经改为CA证书了），12306的证书是由SRCA颁发，SRCA中文名叫中铁数字证书认证中心，简称中铁CA。这是个铁道部自己搞的机构，相当于是自己给自己颁发证书。因此我们访问12306时通常会看到如下情景：\n![这里写图片描述](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTgwMjExMTczMjQ4NjE3?x-oss-process=image/format,png)\n\n说了这么多，我们来总结一下数字证书的两个作用：\n> 1， 分发公钥。每个数字证书都包含了注册者生成的公钥。在 TLS握手时会通过 certificate 消息传输给客户端。\n> 2， 身份授权。确保客户端访问的网站是经过 CA 验证的可信任的网站。（在自签名证书的情况下可以验证是否是我们自己的服务器）\n\n最后我们从[别处](http://blog.csdn.net/dd864140130/article/details/52625666)搬来一个中间人攻击的例子，来认识证书是如何保证我们的数据安全的。\n对于一个正常的网络请求，其流程通常如下：\n![](https://raw.githubusercontent.com/zhpanvip/Resource/master/image/1203.jfif)\n\n但是，如果有黑客在通信过程中拦截了这个请求。试想在客户端和服务端中间有一个中间人，两者之间的传输对中间人来说是透明的，那么中间人完全可以获取两端之间的任何数据并加以修改，然后转发给两端。其流程如下图：\n![](https://raw.githubusercontent.com/zhpanvip/Resource/master/image/1204.jfif)\n\n此时恶意服务端完全可以发起双向攻击：对上可以欺骗服务端，对下可以欺骗客户端，更严重的是客户端段和服务端完全感知不到已经被攻击了。这就是所谓的中间人攻击。\n\n> 中间人攻击（MITM攻击）是指，黑客拦截并篡改网络中的通信数据。又分为被动MITM和主动MITM，被动MITM只窃取通信数据而不修改，而主动MITM不但能窃取数据，还会篡改通信数据。最常见的中间人攻击常常发生在公共wifi或者公共路由上。\n\n现在可以看看使用证书是怎么样提高安全性，避免中间人攻击的，用一张简单的流程图来说明：\n\n![](https://raw.githubusercontent.com/zhpanvip/Resource/master/image/1205.jfif)\n\n\n\n 四、HTTPS单项认证\n-----------\n所谓单项认证只要服务端配置证书，客户端在请求服务端时验证服务器的证书即可。我们上述讲到的内容其实都是说的HTTPS单项认证。通常来说对于安全性要求不高的网站单项认证就可以满足我们的需求了。因此我们访问的HTTPS网站大部分都是单项认证。\n\n**1.关于HTTPS的使用存在的误区**\n由于我们对安全性的认识不够重视，通常对于HTTPS存在一些误区，这些误区可能直接给我们带来一些安全隐患。\n***误区（1）：对于CA机构颁发的证书客户端无须内置***  \n上面提到访问HTTPS服务器是需要在客户端配置服务器证书的。有些小伙伴可能就纳闷了，说我们用的就是HTTPS但是并没有在客户端配置证书呢？比如请求百度的网站https://www.baidu.com/，和请求HTTP服务器没什么区别。其实这是因为在Android系统中已经内置了所有CA机构的根证书，也就是只要是CA机构颁发的证书，Android是直接信任的。对于此种情况，虽然可以正常访问到服务器，但是仍然存在安全隐患。假如黑客自家搭建了一个服务器并申请到了CA证书，由于我们客户端没有内置服务器证书，默认信任所有CA证书（客户端可以访问所有持有由CA机构颁发的证书的服务器），那么黑客仍然可以发起中间人攻击劫持我们的请求到黑客的服务器，实际上就成了我们的客户端和黑客的服务器建立起了连接。\n***误区（2）：对于非CA机构颁发的证书和自签名证书，可以忽略证书校验***\n另外一种情况，如果我们服务器的证书是非认证机构颁发的 (例如12306)或者自签名证书，那么我们是无法直接访问到服务器的，直接访问通常会抛出如下异常：\n\n```\njavax.net.ssl.SSLHandshakeException: \n    java.security.cert.CertPathValidatorException: \n        Trust anchor for certification path not found.\n```\n网上很多解决SSLHandshakeException异常的方案是自定义TrustManager忽略证书校验。代码如下：\n\n```\npublic static SSLSocketFactory getSSLSocketFactory() throws Exception {\n        //创建一个不验证证书链的证书信任管理器。\n        final TrustManager[] trustAllCerts = new TrustManager[]{new X509TrustManager() {\n            @Override\n            public void checkClientTrusted(\n                    java.security.cert.X509Certificate[] chain,\n                    String authType) throws CertificateException {\n            }\n\n            @Override\n            public void checkServerTrusted(\n                    java.security.cert.X509Certificate[] chain,\n                    String authType) throws CertificateException {\n            }\n\n            @Override\n            public java.security.cert.X509Certificate[] getAcceptedIssuers() {\n                return new java.security.cert.X509Certificate[0];\n            }\n        }};\n\n        // Install the all-trusting trust manager\n        final SSLContext sslContext = SSLContext.getInstance(\"TLS\");\n        sslContext.init(null, trustAllCerts,\n                new java.security.SecureRandom());\n        // Create an ssl socket factory with our all-trusting manager\n        return sslContext\n                .getSocketFactory();\n    }\n\n\n  //使用自定义SSLSocketFactory\n  private void onHttps(OkHttpClient.Builder builder) {\n       try {\n            builder.sslSocketFactory(getSSLSocketFactory()).hostnameVerifier(org.apache.http.conn.ssl.SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n\n    }\n```\n对于这样的处理方式虽然解决了SSLHandshakeException异常，但是却存在更大的安全隐患。因为此种做法直接使我们的客户端信任了所有证书（包括CA机构颁发的证书和非CA机构颁发的证书以及自签名证书），因此，这样配置将比第一种情况危害更大。\n\n**2.Retrofit绑定证书实现HTTPS单项认证**\n对于上述两种情况中存在的安全隐患，我们应该如何应对？最简单的解决方案就是在客户端内置服务器的证书，我们在校验服务端证书的时候只比对和App内置的证书是否完全相同，如果不同则断开连接。那么此时再遭遇中间人攻击劫持我们的请求时由于黑客服务器没有相应的证书，此时HTTPS请求校验不通过，则无法与黑客的服务器建立起连接。\n\n那么接下来我们就结合Retrofit以访问12306为例来实现HTTPS的单项认证。\n首先从12306网站下载签名证书，并放置到我们项目资源目录raw下。然后根据证书构造SSLSocketFactory，代码如下：\n\n```\n\t/**\n     * 单项认证\n     */\n    public static SSLSocketFactory getSSLSocketFactoryForOneWay(InputStream... certificates) {\n        try {\n            CertificateFactory certificateFactory = CertificateFactory.getInstance(CLIENT_TRUST_MANAGER, CLIENT_TRUST_PROVIDER);\n            KeyStore keyStore = KeyStore.getInstance(CLIENT_TRUST_KEYSTORE);\n            keyStore.load(null);\n            int index = 0;\n            for (InputStream certificate : certificates) {\n                String certificateAlias = Integer.toString(index++);\n                keyStore.setCertificateEntry(certificateAlias, certificateFactory.generateCertificate(certificate));\n                try {\n                    if (certificate != null)\n                        certificate.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n\n            SSLContext sslContext = SSLContext.getInstance(CLIENT_AGREEMENT);\n\n            TrustManagerFactory trustManagerFactory =\n                    TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());\n\n            trustManagerFactory.init(keyStore);\n            sslContext.init(null, trustManagerFactory.getTrustManagers(), new SecureRandom());\n            return sslContext.getSocketFactory();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n```\n接下来为OKHttpClient设置SslSocketFactory以及hostnameVerifier，代码如下：\n\n```\nInputStream certificate12306 = Utils.getContext().getResources().openRawResource(R.raw.srca);\n        OkHttpClient okHttpClient = new OkHttpClient.Builder()\n                .readTimeout(Constants.DEFAULT_TIMEOUT, TimeUnit.MILLISECONDS)\n                .connectTimeout(Constants.DEFAULT_TIMEOUT, TimeUnit.MILLISECONDS)\n                .addInterceptor(interceptor)\n                .addInterceptor(new HttpHeaderInterceptor())\n                .addNetworkInterceptor(new HttpCacheInterceptor())\n                .sslSocketFactory(SslContextFactory.getSSLSocketFactoryForOneWay(certificate12306))  \n                .hostnameVerifier(new SafeHostnameVerifier())\n                .cache(cache)\n                .build();\n```\n上述代码中hostnameVerifier是对服务器的校验，SafeHostnameVerifier代码如下：\n\n```\n private class SafeHostnameVerifier implements HostnameVerifier {\n        @Override\n        public boolean verify(String hostname, SSLSession session) {\n            if (Constants.IP.equals(hostname)) {//校验hostname是否正确，如果正确则建立连接\n                return true;\n            }\n            return false;\n        }\n    }\n```\nverify方法中对比了请求的IP和服务器的IP是否一致，一致则返回true表示校验通过，否则返回false，检验不通过，断开连接。对于网上有些处理是直接返回true，即不对请求的服务器IP做校验，我们不推荐这样使用。而且现在谷歌应用商店已经对此种做法做了限制，禁止在verify方法中直接返回true的App上线。\n\n 五、HTTPS双向认证\n-----------\n对于HTTPS双向认证，用到的情况不多。但是对于像金融行业等对安全性要求较高的企业，通常都会使用双向认证。所谓双向认证就是客户端校验服务器证书，同时服务器也需要校验客户端的证书。因此，双向认证就另需一张证书放到客户端待服务端去验证。\n\n> 单项认证保证了我们自己的客户端只能访问我们自己的服务器，但并不能保证我们自己的服务器只能被我们自己的客户端访问（第三方客户端忽略证书校验即可）。那么双向认证则保证了我们的客户端只能访问我们自己的服务器，同时我们的服务器也只能被我们自己的客户端访问。因此双向认证可以说相比单项认证安全性足足提高一个等级。\n\n**1.双向认证流程**\n接下来我们来了解下双向认证的流程，以加深对双向认证的理解：\n\n> a. 客户端发送一个连接请求给服务器。 \n　　b. 服务器将自己的证书，以及同证书相关的信息发送给客户端。 \n　　c. 客户端检查服务器送过来的证书是否和App内置证书相同。如果是，就继续执行协议；如果不是则终止此次请求。\n　　d. 接着客户端比较证书里的消息，例如域名和公钥，与服务器刚刚发送的相关消息是否一致，如果是一致的，客户端认可这个服务器的合法身份。 \n　　e. 服务器要求客户发送客户自己的证书。收到后，服务器验证客户端的证书，如果没有通过验证，拒绝连接；如果通过验证，服务器获得用户的公钥。 \n　　f. 客户端告诉服务器自己所能够支持的通讯对称密码方案。\n　　g. 服务器从客户发送过来的密码方案中，选择一种加密程度最高的密码方案，用客户的公钥加过密后通知客户端。 \n　　h. 客户端针对这个密码方案，选择一个通话密钥，接着用服务器的公钥加过密后发送给服务器。\n　　i. 服务器接收到客户端送过来的消息，用自己的私钥解密，获得通话密钥。 \n　　j. 服务器通过密钥解密客户端发送的被加密数据，得到明文数据。\n\n**2.Retrofit实现HTTPS双向认证**\n对于双向认证，我们以华为北向平台登录接口为例来进行学习。想了解华为北向API[请戳此处](http://developer.huawei.com/ict/cn/doc/site-oceanconnect-northbound_api_reference-zh/index.html/zh-cn_topic_0087306564)\n我们直接通过浏览器访问登录接口可以看到如下情景：\n![](https://raw.githubusercontent.com/zhpanvip/Resource/master/image/1206.jfif)\n\n哈，惊喜不？直接被拒绝了！这就是双向认证，没有证书想访问服务器门都没有。那么对于双向认证我们应该做怎样的配置？我们可以参考华为开源出来的代码[戳此处](https://github.com/Huawei/IoT_OceanConnect_North_GUI_APPDemo) \n源码中由两个证书文件ca.jks和outgoing.CertwithKey.pkcs12，其中ca.jks是在客户端配置的证书，outgoing.CertwithKey.pkcs12是在服务端配置的证书。因为我们当前客户端是Android系统，由于Android系统不支持jks格式的证书，因此需要把jks转成Android支持的bks格式。转换方式不再贴出，可自行查阅。\n有了证书，接下来看获取SSLSocketFactory的代码：\n\n```\n  /**\n     * 双向认证\n     *\n     * @return SSLSocketFactory\n     */\n    public static SSLSocketFactory getSSLSocketFactoryForTwoWay() {\n        try {\n            InputStream certificate = Utils.getContext().getResources().openRawResource(R.raw.capk);\n            //  CertificateFactory certificateFactory = CertificateFactory.getInstance(\"X.509\", \"BC\");\n            KeyStore keyStore = KeyStore.getInstance(CLIENT_TRUST_KEY);\n            keyStore.load(certificate, SELF_CERT_PWD.toCharArray());\n            KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\n            kmf.init(keyStore, SELF_CERT_PWD.toCharArray());\n\n            try {\n                if (certificate != null)\n                    certificate.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n\n            //初始化keystore\n            KeyStore clientKeyStore = KeyStore.getInstance(CLIENT_TRUST_KEYSTORE);\n            clientKeyStore.load(Utils.getContext().getResources().openRawResource(R.raw.cabks), TRUST_CA_PWD.toCharArray());\n\n            SSLContext sslContext = SSLContext.getInstance(CLIENT_AGREEMENT);\n            TrustManagerFactory trustManagerFactory = TrustManagerFactory.\n                    getInstance(TrustManagerFactory.getDefaultAlgorithm());\n\n            trustManagerFactory.init(clientKeyStore);\n\n            KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\n            keyManagerFactory.init(clientKeyStore, SELF_CERT_PWD.toCharArray());\n\n            sslContext.init(kmf.getKeyManagers(), trustManagerFactory.getTrustManagers(), new SecureRandom());\n            return sslContext.getSocketFactory();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n```\n接下来同样需要配置OKHttpClient，代码如下：\n\n```\nOkHttpClient okHttpClient = new OkHttpClient.Builder()\n                .readTimeout(Constants.DEFAULT_TIMEOUT, TimeUnit.MILLISECONDS)\n                .connectTimeout(Constants.DEFAULT_TIMEOUT, TimeUnit.MILLISECONDS)\n                .addInterceptor(interceptor)\n                .addInterceptor(new HttpHeaderInterceptor())\n                .addNetworkInterceptor(new HttpCacheInterceptor())\n                .sslSocketFactory(SslContextFactory.getSSLSocketFactoryForTwoWay()) \n                .hostnameVerifier(new SafeHostnameVerifier())\n                .cache(cache)\n                .build();\n```\n这样就完成了HTTPS的配置，接下来就可以愉快的访问HTTPS 双向认证的接口了。由于北向登录接口中需要appId和secret两个参数，因此，登录相关代码就不再贴出。\n\n好了，到此关于HTTPS的学习就结束了，如果有不明白的地方可以参看文末源码。以上内容纯属个人对HTTPS的一些认识，如果文中有错误之处还请多多包涵，欢迎留言指正。\n\n本文写成参考了大量的相关文章，在此表示感谢。\n\n[源码参考](https://github.com/zhpanvip/Retrofit2/tree/master/idea/src/main/java/com/zhpan/idea/net/https)\n\n参考\n--\n[大型网站的 HTTPS 实践（1）：HTTPS 协议和原理](http://blog.jobbole.com/86660/)\n[Retrofit中如何正确的使用https？](http://blog.csdn.net/dd864140130/article/details/52625666)\n[Android Https相关完全解析 当OkHttp遇到Https](http://blog.csdn.net/lmj623565791/article/details/48129405)\n[HTTPS原理及OKHTTP对HTTPS的支持](https://www.jianshu.com/p/f2097616e65e)\n\n\n","slug":"12.关于Https的那些事儿","published":1,"updated":"2020-08-29T18:01:57.275Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckegm5nsi0011dwozevsm7hup","content":"<p>*<strong>* 本篇文章已授权微信公众号 guolin_blog （郭霖）独家发布*</strong></p>\n<p>由于前不久苹果公司已经强制IOS应用必须使用HTTPS协议开发，虽然Google没有强制开发者使用HTTPS，但相信不久的将来Android也会跟随IOS全面转向HTTPS。因此，HTTPS的学习也是相当重要。本篇文章涉及到的代码不多，主要内容是对HTTPS协议的讲解，最后将结合Retrofit实现HTTPS的单双向认证。</p>\n<p>下面将通过以下几节内容来学习HTTPS。</p>\n<ul>\n<li>HTTPS概述 </li>\n<li>HTTPS实现原理  </li>\n<li>数字证书   </li>\n<li>Https单项认证   </li>\n<li>Https双向认证</li>\n</ul>\n<h2 id=\"一、HTTPS概述\"><a href=\"#一、HTTPS概述\" class=\"headerlink\" title=\"一、HTTPS概述\"></a>一、HTTPS概述</h2><p> <strong>1.什么是HTTPS？</strong><br> 我们看维基百科给HTTPS的定义：</p>\n<blockquote>\n<p>HTTPS（Hypertext Transfer Protocol Secure）是一种通过计算机网络进行安全通信的传输协议。HTTPS经由HTTP进行通信，但利用TLS来加密数据包。HTTPS开发的主要目的，是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。</p>\n</blockquote>\n<p>原来HTTPS就是在HTTP协议的基础上加入了TLS协议。目的是保证我们的数据在网络上传输的安全性。</p>\n<blockquote>\n<p>TLS是传输层加密协议，前身是SSL协议。由网景公司于1995年发布。后改名为TLS。常用的 TLS 协议版本有：TLS1.2, TLS1.1, TLS1.0 和 SSL3.0。其中 SSL3.0 由于 POODLE 攻击已经被证明不安全。TLS1.0 也存在部分安全漏洞，比如 RC4 和 BEAST 攻击。</p>\n</blockquote>\n<p>由于HTTP协议采用明文传输，我们可以通过抓包很轻松的获取到HTTP所传输的数据。因此，采用HTTP协议是不安全的。这才催生了HTTPS的诞生。HTTPS相对HTTP提供了更安全的数据传输保障。主要体现在三个方面：</p>\n<blockquote>\n<p>1，  内容加密。客户端到服务器的内容都是以加密形式传输，中间者无法直接查看明文内容。<br>2，  身份认证。通过校验保证客户端访问的是自己的服务器。<br>3，  数据完整性。防止内容被第三方冒充或者篡改。</p>\n</blockquote>\n<h2 id=\"二、HTTPS实现原理\"><a href=\"#二、HTTPS实现原理\" class=\"headerlink\" title=\"二、HTTPS实现原理\"></a>二、HTTPS实现原理</h2><p>在学习HTTPS原理之前我们先了解一下两种加密方式： 对称加密和非对称加密。<br><strong>对称加密</strong> 即加密和解密使用同一个密钥，虽然对称加密破解难度很大，但由于对称加密需要在网络上传输密钥和密文，一旦被黑客截取很容就能被破解，因此对称加密并不是一个较好的选择。<br><strong>非对称加密</strong> 即加密和解密使用不同的密钥，分别称为公钥和私钥。我们可以用公钥对数据进行加密，但必须要用私钥才能解密。在网络上只需要传送公钥，私钥保存在服务端用于解密公钥加密后的密文。但是非对称加密消耗的CPU资源非常大，效率很低，严重影响HTTPS的性能和速度。因此非对称加密也不是HTTPS的理想选择。</p>\n<p>那么HTTPS采用了怎样的加密方式呢？其实为了提高安全性和效率HTTPS结合了对称和非对称两种加密方式。即客户端使用对称加密生成密钥（key）对传输数据进行加密，然后使用非对称加密的公钥再对key进行加密。因此网络上传输的数据是被key加密的密文和用公钥加密后的密文key，因此即使被黑客截取，由于没有私钥，无法获取到明文key，便无法获取到明文数据。所以HTTPS的加密方式是安全的。</p>\n<p>接下来我们以TLS1.2为例来认识HTTPS的握手过程。</p>\n<blockquote>\n<p>1，  客户端发送 client_hello，包含一个随机数 random1。<br>2，  服务端回复 server_hello，包含一个随机数 random2，携带了证书公钥 P。<br>3，  客户端接收到 random2 之后就能够生成 premaster_secrect （对称加密的密钥）以及 master_secrect（用premaster_secret加密后的数据）。<br>4，  客户端使用证书公钥 P 将 premaster_secrect 加密后发送给服务器 (用公钥P对premaster_secret加密)。<br>5，  服务端使用私钥解密得到 premaster_secrect。又由于服务端之前就收到了随机数 1，所以服务端根据相同的生成算法，在相同的输入参数下，求出了相同的 master secrect。</p>\n</blockquote>\n<p>HTTPS的握手过程如下图：<br><img src=\"https://raw.githubusercontent.com/zhpanvip/Resource/master/image/1201.jfif\"></p>\n<h2 id=\"三、数字证书\"><a href=\"#三、数字证书\" class=\"headerlink\" title=\"三、数字证书\"></a>三、数字证书</h2><p>我们上面提到了HTTPS的工作原理，通过对称加密和非对称加密实现数据的安全传输。我们也知道非对称加密过程需要用到公钥进行加密。那么公钥从何而来？其实公钥就被包含在数字证书中。数字证书通常来说是由受信任的数字证书颁发机构CA，在验证服务器身份后颁发，证书中包含了一个密钥对（公钥和私钥）和所有者识别信息。数字证书被放到服务端，具有服务器身份验证和数据传输加密功能。</p>\n<p>除了CA机构颁发的证书之外，还有非CA机构颁发的证书和自签名证书。</p>\n<ul>\n<li>非CA机构即是不受信任的机构颁发的证书，理所当然这样的证书是不受信任的。</li>\n<li>自签名证书，就是自己给自己颁发的证书。当然自签名证书也是不受信任的。</li>\n</ul>\n<p>例如大(chou)名(ming)鼎(zhao)鼎(zhu)的12306网站使用的就是非CA机构颁发的证书（最近发现12306购票页面已经改为CA证书了），12306的证书是由SRCA颁发，SRCA中文名叫中铁数字证书认证中心，简称中铁CA。这是个铁道部自己搞的机构，相当于是自己给自己颁发证书。因此我们访问12306时通常会看到如下情景：<br><img src=\"https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTgwMjExMTczMjQ4NjE3?x-oss-process=image/format,png\" alt=\"这里写图片描述\"></p>\n<p>说了这么多，我们来总结一下数字证书的两个作用：</p>\n<blockquote>\n<p>1， 分发公钥。每个数字证书都包含了注册者生成的公钥。在 TLS握手时会通过 certificate 消息传输给客户端。<br>2， 身份授权。确保客户端访问的网站是经过 CA 验证的可信任的网站。（在自签名证书的情况下可以验证是否是我们自己的服务器）</p>\n</blockquote>\n<p>最后我们从<a href=\"http://blog.csdn.net/dd864140130/article/details/52625666\">别处</a>搬来一个中间人攻击的例子，来认识证书是如何保证我们的数据安全的。<br>对于一个正常的网络请求，其流程通常如下：<br><img src=\"https://raw.githubusercontent.com/zhpanvip/Resource/master/image/1203.jfif\"></p>\n<p>但是，如果有黑客在通信过程中拦截了这个请求。试想在客户端和服务端中间有一个中间人，两者之间的传输对中间人来说是透明的，那么中间人完全可以获取两端之间的任何数据并加以修改，然后转发给两端。其流程如下图：<br><img src=\"https://raw.githubusercontent.com/zhpanvip/Resource/master/image/1204.jfif\"></p>\n<p>此时恶意服务端完全可以发起双向攻击：对上可以欺骗服务端，对下可以欺骗客户端，更严重的是客户端段和服务端完全感知不到已经被攻击了。这就是所谓的中间人攻击。</p>\n<blockquote>\n<p>中间人攻击（MITM攻击）是指，黑客拦截并篡改网络中的通信数据。又分为被动MITM和主动MITM，被动MITM只窃取通信数据而不修改，而主动MITM不但能窃取数据，还会篡改通信数据。最常见的中间人攻击常常发生在公共wifi或者公共路由上。</p>\n</blockquote>\n<p>现在可以看看使用证书是怎么样提高安全性，避免中间人攻击的，用一张简单的流程图来说明：</p>\n<p><img src=\"https://raw.githubusercontent.com/zhpanvip/Resource/master/image/1205.jfif\"></p>\n<h2 id=\"四、HTTPS单项认证\"><a href=\"#四、HTTPS单项认证\" class=\"headerlink\" title=\" 四、HTTPS单项认证\"></a> 四、HTTPS单项认证</h2><p>所谓单项认证只要服务端配置证书，客户端在请求服务端时验证服务器的证书即可。我们上述讲到的内容其实都是说的HTTPS单项认证。通常来说对于安全性要求不高的网站单项认证就可以满足我们的需求了。因此我们访问的HTTPS网站大部分都是单项认证。</p>\n<p><strong>1.关于HTTPS的使用存在的误区</strong><br>由于我们对安全性的认识不够重视，通常对于HTTPS存在一些误区，这些误区可能直接给我们带来一些安全隐患。<br>*<strong>误区（1）：对于CA机构颁发的证书客户端无须内置***<br>上面提到访问HTTPS服务器是需要在客户端配置服务器证书的。有些小伙伴可能就纳闷了，说我们用的就是HTTPS但是并没有在客户端配置证书呢？比如请求百度的网站<a href=\"https://www.baidu.com/%EF%BC%8C%E5%92%8C%E8%AF%B7%E6%B1%82HTTP%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%B2%A1%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%E3%80%82%E5%85%B6%E5%AE%9E%E8%BF%99%E6%98%AF%E5%9B%A0%E4%B8%BA%E5%9C%A8Android%E7%B3%BB%E7%BB%9F%E4%B8%AD%E5%B7%B2%E7%BB%8F%E5%86%85%E7%BD%AE%E4%BA%86%E6%89%80%E6%9C%89CA%E6%9C%BA%E6%9E%84%E7%9A%84%E6%A0%B9%E8%AF%81%E4%B9%A6%EF%BC%8C%E4%B9%9F%E5%B0%B1%E6%98%AF%E5%8F%AA%E8%A6%81%E6%98%AFCA%E6%9C%BA%E6%9E%84%E9%A2%81%E5%8F%91%E7%9A%84%E8%AF%81%E4%B9%A6%EF%BC%8CAndroid%E6%98%AF%E7%9B%B4%E6%8E%A5%E4%BF%A1%E4%BB%BB%E7%9A%84%E3%80%82%E5%AF%B9%E4%BA%8E%E6%AD%A4%E7%A7%8D%E6%83%85%E5%86%B5%EF%BC%8C%E8%99%BD%E7%84%B6%E5%8F%AF%E4%BB%A5%E6%AD%A3%E5%B8%B8%E8%AE%BF%E9%97%AE%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%8C%E4%BD%86%E6%98%AF%E4%BB%8D%E7%84%B6%E5%AD%98%E5%9C%A8%E5%AE%89%E5%85%A8%E9%9A%90%E6%82%A3%E3%80%82%E5%81%87%E5%A6%82%E9%BB%91%E5%AE%A2%E8%87%AA%E5%AE%B6%E6%90%AD%E5%BB%BA%E4%BA%86%E4%B8%80%E4%B8%AA%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%B9%B6%E7%94%B3%E8%AF%B7%E5%88%B0%E4%BA%86CA%E8%AF%81%E4%B9%A6%EF%BC%8C%E7%94%B1%E4%BA%8E%E6%88%91%E4%BB%AC%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%B2%A1%E6%9C%89%E5%86%85%E7%BD%AE%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AF%81%E4%B9%A6%EF%BC%8C%E9%BB%98%E8%AE%A4%E4%BF%A1%E4%BB%BB%E6%89%80%E6%9C%89CA%E8%AF%81%E4%B9%A6%EF%BC%88%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%8F%AF%E4%BB%A5%E8%AE%BF%E9%97%AE%E6%89%80%E6%9C%89%E6%8C%81%E6%9C%89%E7%94%B1CA%E6%9C%BA%E6%9E%84%E9%A2%81%E5%8F%91%E7%9A%84%E8%AF%81%E4%B9%A6%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%89%EF%BC%8C%E9%82%A3%E4%B9%88%E9%BB%91%E5%AE%A2%E4%BB%8D%E7%84%B6%E5%8F%AF%E4%BB%A5%E5%8F%91%E8%B5%B7%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB%E5%8A%AB%E6%8C%81%E6%88%91%E4%BB%AC%E7%9A%84%E8%AF%B7%E6%B1%82%E5%88%B0%E9%BB%91%E5%AE%A2%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%8C%E5%AE%9E%E9%99%85%E4%B8%8A%E5%B0%B1%E6%88%90%E4%BA%86%E6%88%91%E4%BB%AC%E7%9A%84%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%92%8C%E9%BB%91%E5%AE%A2%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BB%BA%E7%AB%8B%E8%B5%B7%E4%BA%86%E8%BF%9E%E6%8E%A5%E3%80%82\">https://www.baidu.com/，和请求HTTP服务器没什么区别。其实这是因为在Android系统中已经内置了所有CA机构的根证书，也就是只要是CA机构颁发的证书，Android是直接信任的。对于此种情况，虽然可以正常访问到服务器，但是仍然存在安全隐患。假如黑客自家搭建了一个服务器并申请到了CA证书，由于我们客户端没有内置服务器证书，默认信任所有CA证书（客户端可以访问所有持有由CA机构颁发的证书的服务器），那么黑客仍然可以发起中间人攻击劫持我们的请求到黑客的服务器，实际上就成了我们的客户端和黑客的服务器建立起了连接。</a><br>*</strong>误区（2）：对于非CA机构颁发的证书和自签名证书，可以忽略证书校验***<br>另外一种情况，如果我们服务器的证书是非认证机构颁发的 (例如12306)或者自签名证书，那么我们是无法直接访问到服务器的，直接访问通常会抛出如下异常：</p>\n<pre><code class=\"hljs css\"><span class=\"hljs-selector-tag\">javax</span><span class=\"hljs-selector-class\">.net</span><span class=\"hljs-selector-class\">.ssl</span><span class=\"hljs-selector-class\">.SSLHandshakeException</span>: \n    <span class=\"hljs-selector-tag\">java</span><span class=\"hljs-selector-class\">.security</span><span class=\"hljs-selector-class\">.cert</span><span class=\"hljs-selector-class\">.CertPathValidatorException</span>: \n        <span class=\"hljs-selector-tag\">Trust</span> <span class=\"hljs-selector-tag\">anchor</span> <span class=\"hljs-selector-tag\">for</span> <span class=\"hljs-selector-tag\">certification</span> <span class=\"hljs-selector-tag\">path</span> <span class=\"hljs-selector-tag\">not</span> <span class=\"hljs-selector-tag\">found</span>.</code></pre>\n<p>网上很多解决SSLHandshakeException异常的方案是自定义TrustManager忽略证书校验。代码如下：</p>\n<pre><code class=\"hljs aspectj\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-function\">SSLSocketFactory <span class=\"hljs-title\">getSSLSocketFactory</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> Exception </span>&#123;\n        <span class=\"hljs-comment\">//创建一个不验证证书链的证书信任管理器。</span>\n        <span class=\"hljs-keyword\">final</span> TrustManager[] trustAllCerts = <span class=\"hljs-keyword\">new</span> TrustManager[]&#123;<span class=\"hljs-keyword\">new</span> X509TrustManager() &#123;\n            <span class=\"hljs-meta\">@Override</span>\n            <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> checkClientTrusted(\n                    java.security.cert.X509Certificate[] chain,\n                    String authType) <span class=\"hljs-keyword\">throws</span> CertificateException &#123;\n            &#125;\n\n            <span class=\"hljs-meta\">@Override</span>\n            <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> checkServerTrusted(\n                    java.security.cert.X509Certificate[] chain,\n                    String authType) <span class=\"hljs-keyword\">throws</span> CertificateException &#123;\n            &#125;\n\n            <span class=\"hljs-meta\">@Override</span>\n            <span class=\"hljs-keyword\">public</span> java.security.cert.X509Certificate[] getAcceptedIssuers() &#123;\n                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> java.security.cert.X509Certificate[<span class=\"hljs-number\">0</span>];\n            &#125;\n        &#125;&#125;;\n\n        <span class=\"hljs-comment\">// Install the all-trusting trust manager</span>\n        <span class=\"hljs-keyword\">final</span> SSLContext sslContext = SSLContext.getInstance(<span class=\"hljs-string\">&quot;TLS&quot;</span>);\n        sslContext.init(<span class=\"hljs-keyword\">null</span>, trustAllCerts,\n                <span class=\"hljs-keyword\">new</span> java.security.SecureRandom());\n        <span class=\"hljs-comment\">// Create an ssl socket factory with our all-trusting manager</span>\n        <span class=\"hljs-keyword\">return</span> sslContext\n                .getSocketFactory();\n    &#125;\n\n\n  <span class=\"hljs-comment\">//使用自定义SSLSocketFactory</span>\n  <span class=\"hljs-keyword\">private</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onHttps</span><span class=\"hljs-params\">(OkHttpClient.Builder builder)</span> </span>&#123;\n       <span class=\"hljs-keyword\">try</span> &#123;\n            builder.sslSocketFactory(getSSLSocketFactory()).hostnameVerifier(org.apache.http.conn.ssl.SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);\n        &#125; <span class=\"hljs-keyword\">catch</span> (Exception e) &#123;\n            e.printStackTrace();\n        &#125;\n\n    &#125;</code></pre>\n<p>对于这样的处理方式虽然解决了SSLHandshakeException异常，但是却存在更大的安全隐患。因为此种做法直接使我们的客户端信任了所有证书（包括CA机构颁发的证书和非CA机构颁发的证书以及自签名证书），因此，这样配置将比第一种情况危害更大。</p>\n<p><strong>2.Retrofit绑定证书实现HTTPS单项认证</strong><br>对于上述两种情况中存在的安全隐患，我们应该如何应对？最简单的解决方案就是在客户端内置服务器的证书，我们在校验服务端证书的时候只比对和App内置的证书是否完全相同，如果不同则断开连接。那么此时再遭遇中间人攻击劫持我们的请求时由于黑客服务器没有相应的证书，此时HTTPS请求校验不通过，则无法与黑客的服务器建立起连接。</p>\n<p>那么接下来我们就结合Retrofit以访问12306为例来实现HTTPS的单项认证。<br>首先从12306网站下载签名证书，并放置到我们项目资源目录raw下。然后根据证书构造SSLSocketFactory，代码如下：</p>\n<pre><code class=\"hljs reasonml\"><span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">    * 单项认证</span>\n<span class=\"hljs-comment\">    */</span>\n   public static SSLSocketFactory get<span class=\"hljs-constructor\">SSLSocketFactoryForOneWay(InputStream<span class=\"hljs-operator\">...</span> <span class=\"hljs-params\">certificates</span>)</span> &#123;\n       <span class=\"hljs-keyword\">try</span> &#123;\n           CertificateFactory certificateFactory = <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">CertificateFactory</span>.</span></span>get<span class=\"hljs-constructor\">Instance(CLIENT_TRUST_MANAGER, CLIENT_TRUST_PROVIDER)</span>;\n           KeyStore keyStore = <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">KeyStore</span>.</span></span>get<span class=\"hljs-constructor\">Instance(CLIENT_TRUST_KEYSTORE)</span>;\n           keyStore.load(null);\n           <span class=\"hljs-built_in\">int</span> index = <span class=\"hljs-number\">0</span>;\n           <span class=\"hljs-keyword\">for</span> (InputStream certificate : certificates) &#123;\n               String certificateAlias = <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">Integer</span>.</span></span><span class=\"hljs-keyword\">to</span><span class=\"hljs-constructor\">String(<span class=\"hljs-params\">index</span><span class=\"hljs-operator\">++</span>)</span>;\n               keyStore.set<span class=\"hljs-constructor\">CertificateEntry(<span class=\"hljs-params\">certificateAlias</span>, <span class=\"hljs-params\">certificateFactory</span>.<span class=\"hljs-params\">generateCertificate</span>(<span class=\"hljs-params\">certificate</span>)</span>);\n               <span class=\"hljs-keyword\">try</span> &#123;\n                   <span class=\"hljs-keyword\">if</span> (certificate != null)\n                       certificate.close<span class=\"hljs-literal\">()</span>;\n               &#125; catch (IOException e) &#123;\n                   e.print<span class=\"hljs-constructor\">StackTrace()</span>;\n               &#125;\n           &#125;\n\n           SSLContext sslContext = <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">SSLContext</span>.</span></span>get<span class=\"hljs-constructor\">Instance(CLIENT_AGREEMENT)</span>;\n\n           TrustManagerFactory trustManagerFactory =\n                   <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">TrustManagerFactory</span>.</span></span>get<span class=\"hljs-constructor\">Instance(TrustManagerFactory.<span class=\"hljs-params\">getDefaultAlgorithm</span>()</span>);\n\n           trustManagerFactory.init(keyStore);\n           sslContext.init(null, trustManagerFactory.get<span class=\"hljs-constructor\">TrustManagers()</span>, <span class=\"hljs-keyword\">new</span> <span class=\"hljs-constructor\">SecureRandom()</span>);\n           return sslContext.get<span class=\"hljs-constructor\">SocketFactory()</span>;\n       &#125; catch (Exception e) &#123;\n           e.print<span class=\"hljs-constructor\">StackTrace()</span>;\n       &#125;\n       return null;\n   &#125;</code></pre>\n<p>接下来为OKHttpClient设置SslSocketFactory以及hostnameVerifier，代码如下：</p>\n<pre><code class=\"hljs reasonml\">InputStream certificate12306 = <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">Utils</span>.</span></span>get<span class=\"hljs-constructor\">Context()</span>.get<span class=\"hljs-constructor\">Resources()</span>.<span class=\"hljs-keyword\">open</span><span class=\"hljs-constructor\">RawResource(R.<span class=\"hljs-params\">raw</span>.<span class=\"hljs-params\">srca</span>)</span>;\n        OkHttpClient okHttpClient = <span class=\"hljs-keyword\">new</span> OkHttpClient.<span class=\"hljs-constructor\">Builder()</span>\n                .read<span class=\"hljs-constructor\">Timeout(Constants.DEFAULT_TIMEOUT, TimeUnit.MILLISECONDS)</span>\n                .connect<span class=\"hljs-constructor\">Timeout(Constants.DEFAULT_TIMEOUT, TimeUnit.MILLISECONDS)</span>\n                .add<span class=\"hljs-constructor\">Interceptor(<span class=\"hljs-params\">interceptor</span>)</span>\n                .add<span class=\"hljs-constructor\">Interceptor(<span class=\"hljs-params\">new</span> HttpHeaderInterceptor()</span>)\n                .add<span class=\"hljs-constructor\">NetworkInterceptor(<span class=\"hljs-params\">new</span> HttpCacheInterceptor()</span>)\n                .ssl<span class=\"hljs-constructor\">SocketFactory(SslContextFactory.<span class=\"hljs-params\">getSSLSocketFactoryForOneWay</span>(<span class=\"hljs-params\">certificate12306</span>)</span>)  \n                .hostname<span class=\"hljs-constructor\">Verifier(<span class=\"hljs-params\">new</span> SafeHostnameVerifier()</span>)\n                .cache(cache)\n                .build<span class=\"hljs-literal\">()</span>;</code></pre>\n<p>上述代码中hostnameVerifier是对服务器的校验，SafeHostnameVerifier代码如下：</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">SafeHostnameVerifier</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">HostnameVerifier</span> </span>&#123;\n       <span class=\"hljs-meta\">@Override</span>\n       <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">verify</span><span class=\"hljs-params\">(String hostname, SSLSession session)</span> </span>&#123;\n           <span class=\"hljs-keyword\">if</span> (Constants.IP.equals(hostname)) &#123;<span class=\"hljs-comment\">//校验hostname是否正确，如果正确则建立连接</span>\n               <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">true</span>;\n           &#125;\n           <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>;\n       &#125;\n   &#125;</code></pre>\n<p>verify方法中对比了请求的IP和服务器的IP是否一致，一致则返回true表示校验通过，否则返回false，检验不通过，断开连接。对于网上有些处理是直接返回true，即不对请求的服务器IP做校验，我们不推荐这样使用。而且现在谷歌应用商店已经对此种做法做了限制，禁止在verify方法中直接返回true的App上线。</p>\n<h2 id=\"五、HTTPS双向认证\"><a href=\"#五、HTTPS双向认证\" class=\"headerlink\" title=\" 五、HTTPS双向认证\"></a> 五、HTTPS双向认证</h2><p>对于HTTPS双向认证，用到的情况不多。但是对于像金融行业等对安全性要求较高的企业，通常都会使用双向认证。所谓双向认证就是客户端校验服务器证书，同时服务器也需要校验客户端的证书。因此，双向认证就另需一张证书放到客户端待服务端去验证。</p>\n<blockquote>\n<p>单项认证保证了我们自己的客户端只能访问我们自己的服务器，但并不能保证我们自己的服务器只能被我们自己的客户端访问（第三方客户端忽略证书校验即可）。那么双向认证则保证了我们的客户端只能访问我们自己的服务器，同时我们的服务器也只能被我们自己的客户端访问。因此双向认证可以说相比单项认证安全性足足提高一个等级。</p>\n</blockquote>\n<p><strong>1.双向认证流程</strong><br>接下来我们来了解下双向认证的流程，以加深对双向认证的理解：</p>\n<blockquote>\n<p>a. 客户端发送一个连接请求给服务器。<br>　　b. 服务器将自己的证书，以及同证书相关的信息发送给客户端。<br>　　c. 客户端检查服务器送过来的证书是否和App内置证书相同。如果是，就继续执行协议；如果不是则终止此次请求。<br>　　d. 接着客户端比较证书里的消息，例如域名和公钥，与服务器刚刚发送的相关消息是否一致，如果是一致的，客户端认可这个服务器的合法身份。<br>　　e. 服务器要求客户发送客户自己的证书。收到后，服务器验证客户端的证书，如果没有通过验证，拒绝连接；如果通过验证，服务器获得用户的公钥。<br>　　f. 客户端告诉服务器自己所能够支持的通讯对称密码方案。<br>　　g. 服务器从客户发送过来的密码方案中，选择一种加密程度最高的密码方案，用客户的公钥加过密后通知客户端。<br>　　h. 客户端针对这个密码方案，选择一个通话密钥，接着用服务器的公钥加过密后发送给服务器。<br>　　i. 服务器接收到客户端送过来的消息，用自己的私钥解密，获得通话密钥。<br>　　j. 服务器通过密钥解密客户端发送的被加密数据，得到明文数据。</p>\n</blockquote>\n<p><strong>2.Retrofit实现HTTPS双向认证</strong><br>对于双向认证，我们以华为北向平台登录接口为例来进行学习。想了解华为北向API<a href=\"http://developer.huawei.com/ict/cn/doc/site-oceanconnect-northbound_api_reference-zh/index.html/zh-cn_topic_0087306564\">请戳此处</a><br>我们直接通过浏览器访问登录接口可以看到如下情景：<br><img src=\"https://raw.githubusercontent.com/zhpanvip/Resource/master/image/1206.jfif\"></p>\n<p>哈，惊喜不？直接被拒绝了！这就是双向认证，没有证书想访问服务器门都没有。那么对于双向认证我们应该做怎样的配置？我们可以参考华为开源出来的代码<a href=\"https://github.com/Huawei/IoT_OceanConnect_North_GUI_APPDemo\">戳此处</a><br>源码中由两个证书文件ca.jks和outgoing.CertwithKey.pkcs12，其中ca.jks是在客户端配置的证书，outgoing.CertwithKey.pkcs12是在服务端配置的证书。因为我们当前客户端是Android系统，由于Android系统不支持jks格式的证书，因此需要把jks转成Android支持的bks格式。转换方式不再贴出，可自行查阅。<br>有了证书，接下来看获取SSLSocketFactory的代码：</p>\n<pre><code class=\"hljs reasonml\"><span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">   * 双向认证</span>\n<span class=\"hljs-comment\">   *</span>\n<span class=\"hljs-comment\">   * @return SSLSocketFactory</span>\n<span class=\"hljs-comment\">   */</span>\n  public static SSLSocketFactory get<span class=\"hljs-constructor\">SSLSocketFactoryForTwoWay()</span> &#123;\n      <span class=\"hljs-keyword\">try</span> &#123;\n          InputStream certificate = <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">Utils</span>.</span></span>get<span class=\"hljs-constructor\">Context()</span>.get<span class=\"hljs-constructor\">Resources()</span>.<span class=\"hljs-keyword\">open</span><span class=\"hljs-constructor\">RawResource(R.<span class=\"hljs-params\">raw</span>.<span class=\"hljs-params\">capk</span>)</span>;\n          <span class=\"hljs-comment\">//  CertificateFactory certificateFactory = CertificateFactory.getInstance(&quot;X.509&quot;, &quot;BC&quot;);</span>\n          KeyStore keyStore = <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">KeyStore</span>.</span></span>get<span class=\"hljs-constructor\">Instance(CLIENT_TRUST_KEY)</span>;\n          keyStore.load(certificate, <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">SELF_CERT_PWD</span>.</span></span><span class=\"hljs-keyword\">to</span><span class=\"hljs-constructor\">CharArray()</span>);\n          KeyManagerFactory kmf = <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">KeyManagerFactory</span>.</span></span>get<span class=\"hljs-constructor\">Instance(KeyManagerFactory.<span class=\"hljs-params\">getDefaultAlgorithm</span>()</span>);\n          kmf.init(keyStore, <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">SELF_CERT_PWD</span>.</span></span><span class=\"hljs-keyword\">to</span><span class=\"hljs-constructor\">CharArray()</span>);\n\n          <span class=\"hljs-keyword\">try</span> &#123;\n              <span class=\"hljs-keyword\">if</span> (certificate != null)\n                  certificate.close<span class=\"hljs-literal\">()</span>;\n          &#125; catch (IOException e) &#123;\n              e.print<span class=\"hljs-constructor\">StackTrace()</span>;\n          &#125;\n\n          <span class=\"hljs-comment\">//初始化keystore</span>\n          KeyStore clientKeyStore = <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">KeyStore</span>.</span></span>get<span class=\"hljs-constructor\">Instance(CLIENT_TRUST_KEYSTORE)</span>;\n          clientKeyStore.load(<span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">Utils</span>.</span></span>get<span class=\"hljs-constructor\">Context()</span>.get<span class=\"hljs-constructor\">Resources()</span>.<span class=\"hljs-keyword\">open</span><span class=\"hljs-constructor\">RawResource(R.<span class=\"hljs-params\">raw</span>.<span class=\"hljs-params\">cabks</span>)</span>, <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">TRUST_CA_PWD</span>.</span></span><span class=\"hljs-keyword\">to</span><span class=\"hljs-constructor\">CharArray()</span>);\n\n          SSLContext sslContext = <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">SSLContext</span>.</span></span>get<span class=\"hljs-constructor\">Instance(CLIENT_AGREEMENT)</span>;\n          TrustManagerFactory trustManagerFactory = TrustManagerFactory.\n                  get<span class=\"hljs-constructor\">Instance(TrustManagerFactory.<span class=\"hljs-params\">getDefaultAlgorithm</span>()</span>);\n\n          trustManagerFactory.init(clientKeyStore);\n\n          KeyManagerFactory keyManagerFactory = <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">KeyManagerFactory</span>.</span></span>get<span class=\"hljs-constructor\">Instance(KeyManagerFactory.<span class=\"hljs-params\">getDefaultAlgorithm</span>()</span>);\n          keyManagerFactory.init(clientKeyStore, <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">SELF_CERT_PWD</span>.</span></span><span class=\"hljs-keyword\">to</span><span class=\"hljs-constructor\">CharArray()</span>);\n\n          sslContext.init(kmf.get<span class=\"hljs-constructor\">KeyManagers()</span>, trustManagerFactory.get<span class=\"hljs-constructor\">TrustManagers()</span>, <span class=\"hljs-keyword\">new</span> <span class=\"hljs-constructor\">SecureRandom()</span>);\n          return sslContext.get<span class=\"hljs-constructor\">SocketFactory()</span>;\n      &#125; catch (Exception e) &#123;\n          e.print<span class=\"hljs-constructor\">StackTrace()</span>;\n      &#125;\n      return null;\n  &#125;</code></pre>\n<p>接下来同样需要配置OKHttpClient，代码如下：</p>\n<pre><code class=\"hljs reasonml\">OkHttpClient okHttpClient = <span class=\"hljs-keyword\">new</span> OkHttpClient.<span class=\"hljs-constructor\">Builder()</span>\n                .read<span class=\"hljs-constructor\">Timeout(Constants.DEFAULT_TIMEOUT, TimeUnit.MILLISECONDS)</span>\n                .connect<span class=\"hljs-constructor\">Timeout(Constants.DEFAULT_TIMEOUT, TimeUnit.MILLISECONDS)</span>\n                .add<span class=\"hljs-constructor\">Interceptor(<span class=\"hljs-params\">interceptor</span>)</span>\n                .add<span class=\"hljs-constructor\">Interceptor(<span class=\"hljs-params\">new</span> HttpHeaderInterceptor()</span>)\n                .add<span class=\"hljs-constructor\">NetworkInterceptor(<span class=\"hljs-params\">new</span> HttpCacheInterceptor()</span>)\n                .ssl<span class=\"hljs-constructor\">SocketFactory(SslContextFactory.<span class=\"hljs-params\">getSSLSocketFactoryForTwoWay</span>()</span>) \n                .hostname<span class=\"hljs-constructor\">Verifier(<span class=\"hljs-params\">new</span> SafeHostnameVerifier()</span>)\n                .cache(cache)\n                .build<span class=\"hljs-literal\">()</span>;</code></pre>\n<p>这样就完成了HTTPS的配置，接下来就可以愉快的访问HTTPS 双向认证的接口了。由于北向登录接口中需要appId和secret两个参数，因此，登录相关代码就不再贴出。</p>\n<p>好了，到此关于HTTPS的学习就结束了，如果有不明白的地方可以参看文末源码。以上内容纯属个人对HTTPS的一些认识，如果文中有错误之处还请多多包涵，欢迎留言指正。</p>\n<p>本文写成参考了大量的相关文章，在此表示感谢。</p>\n<p><a href=\"https://github.com/zhpanvip/Retrofit2/tree/master/idea/src/main/java/com/zhpan/idea/net/https\">源码参考</a></p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"http://blog.jobbole.com/86660/\">大型网站的 HTTPS 实践（1）：HTTPS 协议和原理</a><br><a href=\"http://blog.csdn.net/dd864140130/article/details/52625666\">Retrofit中如何正确的使用https？</a><br><a href=\"http://blog.csdn.net/lmj623565791/article/details/48129405\">Android Https相关完全解析 当OkHttp遇到Https</a><br><a href=\"https://www.jianshu.com/p/f2097616e65e\">HTTPS原理及OKHTTP对HTTPS的支持</a></p>\n","site":{"data":{"fluid_config":{"favicon":"/img/favicon.png","apple_touch_icon":"/img/favicon.png","title_join_string":" - ","force_https":false,"highlight":{"enable":true,"style":"Github Gist","bg_color":false,"copy_btn":true},"fun_features":{"typing":{"enable":true,"typeSpeed":70,"cursorChar":"|","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"mouse_click":{"enable":false,"style":"values"}},"dark_mode":{"enable":true,"default":"auto"},"color":{"body_bg_color":"#eee","body_bg_color_dark":"#181c27","navbar_bg_color":"#2f4154","navbar_bg_color_dark":"#1f3144","navbar_text_color":"#fff","navbar_text_color_dark":"#d0d0d0","text_color":"#3c4858","text_color_dark":"#c4c6c9","sec_text_color":"#718096","sec_text_color_dark":"#a7a9ad","post_text_color":"#2c3e50","post_text_color_dark":"#c4c6c9","post_heading_color":"#1a202c","post_heading_color_dark":"#c4c6c9","post_link_color":"#0366d6","post_link_color_dark":"#1589e9","link_hover_color":"#30a9de","link_hover_color_dark":"#30a9de","link_hover_bg_color":"#f8f9fa","link_hover_bg_color_dark":"#364151","board_color":"#fff","board_color_dark":"#252d38"},"font":{"font_size":"16px","font_family":null,"code_font_size":"85%"},"custom_js":null,"custom_css":null,"custom_html":"","web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"tajs":null,"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}},"lazyload":{"enable":true,"onlypost":false},"daovoice":{"enable":false,"appid":""},"aplayer":{"enable":false,"autoplay":false,"loop":"all","order":"random","theme":"#b7daff","songs":[{"name":"name","artist":"artist","url":"/songs/test.mp3","cover":"/img/cover.jpg"},{"name":"name","artist":"artist","url":"https://...url.mp3","cover":"https://...cover.jpg"}]},"version":{"check":false},"navbar":{"blog_title":"zhangpan","ground_glass":{"enable":false,"px":3,"alpha":0.7},"menu":[{"key":"home","link":"/","icon":"iconfont icon-home-fill"},{"key":"archive","link":"/archives/","icon":"iconfont icon-archive-fill"},{"key":"category","link":"/categories/","icon":"iconfont icon-category-fill"},{"key":"tag","link":"/tags/","icon":"iconfont icon-tags-fill"},{"key":"about","link":"/about/","icon":"iconfont icon-user-fill"}]},"search":{"enable":true,"path":"/local-search.xml","generate_path":"/local-search.xml","field":"post","content":true},"scroll_down_arrow":{"enable":true,"banner_height_limit":90,"scroll_after_turning_page":true},"banner_parallax":true,"footer":{"statistics":{"enable":false,"source":"busuanzi","pv_format":"总访问量 {} 次","uv_format":"总访客数 {} 人"},"beian":{"enable":false,"icp_text":"京ICP证123456号","police_text":"京公网安备12345678号","police_code":12345678,"police_icon":"/img/police_beian.png"}},"scroll_top_arrow":{"enable":true},"index":{"banner_img":"/img/default.png","banner_img_height":100,"banner_mask_alpha":0.3,"post_default_img":"","slogan":{"enable":true,"text":"Talk is cheap, show me the code."},"auto_excerpt":{"enable":true},"post_url_target":"_self","post_meta":{"date":true,"category":true,"tag":true}},"page":{"banner_img":"/img/default.png","banner_img_height":60,"banner_mask_alpha":0.3},"post":{"banner_img":"/img/default.png","banner_img_height":70,"banner_mask_alpha":0.3,"meta":{"date":{"enable":true,"format":"LL a"},"wordcount":{"enable":true,"format":"{} 字"},"min2read":{"enable":true,"format":"{} 分钟","words":100},"views":{"enable":false,"source":"busuanzi","format":"{} 次"}},"updated":{"enable":false,"content":"本文最后更新于：","relative":false},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"copyright":{"enable":true,"content":"本博客所有文章除特别声明外，均采用 <a href=\"https://creativecommons.org/licenses/by-sa/4.0/deed.zh\" rel=\"nofollow noopener\">CC BY-SA 4.0 协议</a> ，转载请注明出处！ <h5>开源库推荐</h5> <a href=\"https://github.com/zhpanvip/BannerViewPager\">1.BannerViewPager</a> <p> 一个基于ViewPager2实现的具有强大功能的无限轮播库。支持多种页面切换效果和指示器样式。 </p>\n<a href=\"https://github.com/zhpanvip/viewpagerindicator\">2.ViewPagerIndicator</a> <p> 一个适用于ViewPager和ViewPager2的指示器，支持多种滑块样式及滑动模式 </p>"},"prev_next":{"enable":true},"custom":{"enable":false,"content":"<img src=\"https://octodex.github.com/images/jetpacktocat.png\" class=\"rounded mx-auto d-block mt-5\" style=\"width:150px; height:150px;\">"},"image_zoom":{"enable":true},"footnote":{"enable":true,"header":""},"math":{"enable":false,"specific":false,"engine":"mathjax"},"mermaid":{"enable":false,"specific":false,"options":{"theme":"default"}},"comments":{"enable":true,"type":"utterances"}},"utterances":{"repo":"zhpanvip/utterances-comment","issue_term":"pathname","label":"utterances","theme":"github-light","crossorigin":"anonymous"},"disqus":{"shortname":null,"disqusjs":false,"apikey":null},"gitalk":{"clientID":null,"clientSecret":null,"repo":null,"owner":null,"admin":["name"],"id":"location.pathname","language":"zh-CN","labels":["Gitalk"],"perPage":10,"pagerDirection":"last","distractionFreeMode":false,"createIssueManually":true},"valine":{"appid":"hXIROaIM5y9qnieojJRWP5hS","appkey":"y0f3w3aqd1MF7JL9ma4WECTy","placeholder":"说点什么","path":"window.location.pathname","avatar":"retro","meta":["nick","mail","link"],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"https://zhangpan.site"},"changyan":{"appid":"","appkey":""},"livere":{"uid":""},"archive":{"banner_img":"/img/bg_article.jpg","banner_img_height":60,"banner_mask_alpha":0.3,"subtitle":null},"category":{"banner_img":"/img/bg_default.png","banner_img_height":60,"banner_mask_alpha":0.3,"subtitle":null,"post_limit":10,"order_by":"-length"},"tag":{"banner_img":"/img/bg_label.jpg","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null,"tagcloud":{"min_font":15,"max_font":30,"unit":"px","start_color":"#BBBBEE","end_color":"#337ab7"}},"about":{"banner_img":"/img/bg_default.png","banner_img_height":60,"banner_mask_alpha":0.3,"subtitle":null,"avatar":"/img/avatar.png","name":"myname","introduce":"一句简短的介绍","icons":[{"class":"iconfont icon-github-fill","link":"https://github.com","tip":"GitHub"},{"class":"iconfont icon-douban-fill","link":"https://douban.com","tip":"豆瓣"},{"class":"iconfont icon-wechat-fill","qrcode":"/img/favicon.png"}]},"page404":{"banner_img":"/img/default.png","banner_img_height":85,"banner_mask_alpha":0.3,"subtitle":"Page not found"},"links":{"banner_img":"/img/default.png","banner_img_height":60,"banner_mask_alpha":0.3,"subtitle":null,"items":[{"title":"Fluid Docs","intro":"主题使用指南","link":"https://hexo.fluid-dev.com/docs/","image":"/img/favicon.png"},{"title":"Fluid Repo","intro":"主题 GitHub 仓库","link":"https://github.com/fluid-dev/hexo-theme-fluid","image":"/img/favicon.png"},{"title":"Fluid Example","intro":"主题操作示例","link":"https://hexo.fluid-dev.com/docs/example/","image":"/img/favicon.png"}]}}}},"excerpt":"","more":"<p>*<strong>* 本篇文章已授权微信公众号 guolin_blog （郭霖）独家发布*</strong></p>\n<p>由于前不久苹果公司已经强制IOS应用必须使用HTTPS协议开发，虽然Google没有强制开发者使用HTTPS，但相信不久的将来Android也会跟随IOS全面转向HTTPS。因此，HTTPS的学习也是相当重要。本篇文章涉及到的代码不多，主要内容是对HTTPS协议的讲解，最后将结合Retrofit实现HTTPS的单双向认证。</p>\n<p>下面将通过以下几节内容来学习HTTPS。</p>\n<ul>\n<li>HTTPS概述 </li>\n<li>HTTPS实现原理  </li>\n<li>数字证书   </li>\n<li>Https单项认证   </li>\n<li>Https双向认证</li>\n</ul>\n<h2 id=\"一、HTTPS概述\"><a href=\"#一、HTTPS概述\" class=\"headerlink\" title=\"一、HTTPS概述\"></a>一、HTTPS概述</h2><p> <strong>1.什么是HTTPS？</strong><br> 我们看维基百科给HTTPS的定义：</p>\n<blockquote>\n<p>HTTPS（Hypertext Transfer Protocol Secure）是一种通过计算机网络进行安全通信的传输协议。HTTPS经由HTTP进行通信，但利用TLS来加密数据包。HTTPS开发的主要目的，是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。</p>\n</blockquote>\n<p>原来HTTPS就是在HTTP协议的基础上加入了TLS协议。目的是保证我们的数据在网络上传输的安全性。</p>\n<blockquote>\n<p>TLS是传输层加密协议，前身是SSL协议。由网景公司于1995年发布。后改名为TLS。常用的 TLS 协议版本有：TLS1.2, TLS1.1, TLS1.0 和 SSL3.0。其中 SSL3.0 由于 POODLE 攻击已经被证明不安全。TLS1.0 也存在部分安全漏洞，比如 RC4 和 BEAST 攻击。</p>\n</blockquote>\n<p>由于HTTP协议采用明文传输，我们可以通过抓包很轻松的获取到HTTP所传输的数据。因此，采用HTTP协议是不安全的。这才催生了HTTPS的诞生。HTTPS相对HTTP提供了更安全的数据传输保障。主要体现在三个方面：</p>\n<blockquote>\n<p>1，  内容加密。客户端到服务器的内容都是以加密形式传输，中间者无法直接查看明文内容。<br>2，  身份认证。通过校验保证客户端访问的是自己的服务器。<br>3，  数据完整性。防止内容被第三方冒充或者篡改。</p>\n</blockquote>\n<h2 id=\"二、HTTPS实现原理\"><a href=\"#二、HTTPS实现原理\" class=\"headerlink\" title=\"二、HTTPS实现原理\"></a>二、HTTPS实现原理</h2><p>在学习HTTPS原理之前我们先了解一下两种加密方式： 对称加密和非对称加密。<br><strong>对称加密</strong> 即加密和解密使用同一个密钥，虽然对称加密破解难度很大，但由于对称加密需要在网络上传输密钥和密文，一旦被黑客截取很容就能被破解，因此对称加密并不是一个较好的选择。<br><strong>非对称加密</strong> 即加密和解密使用不同的密钥，分别称为公钥和私钥。我们可以用公钥对数据进行加密，但必须要用私钥才能解密。在网络上只需要传送公钥，私钥保存在服务端用于解密公钥加密后的密文。但是非对称加密消耗的CPU资源非常大，效率很低，严重影响HTTPS的性能和速度。因此非对称加密也不是HTTPS的理想选择。</p>\n<p>那么HTTPS采用了怎样的加密方式呢？其实为了提高安全性和效率HTTPS结合了对称和非对称两种加密方式。即客户端使用对称加密生成密钥（key）对传输数据进行加密，然后使用非对称加密的公钥再对key进行加密。因此网络上传输的数据是被key加密的密文和用公钥加密后的密文key，因此即使被黑客截取，由于没有私钥，无法获取到明文key，便无法获取到明文数据。所以HTTPS的加密方式是安全的。</p>\n<p>接下来我们以TLS1.2为例来认识HTTPS的握手过程。</p>\n<blockquote>\n<p>1，  客户端发送 client_hello，包含一个随机数 random1。<br>2，  服务端回复 server_hello，包含一个随机数 random2，携带了证书公钥 P。<br>3，  客户端接收到 random2 之后就能够生成 premaster_secrect （对称加密的密钥）以及 master_secrect（用premaster_secret加密后的数据）。<br>4，  客户端使用证书公钥 P 将 premaster_secrect 加密后发送给服务器 (用公钥P对premaster_secret加密)。<br>5，  服务端使用私钥解密得到 premaster_secrect。又由于服务端之前就收到了随机数 1，所以服务端根据相同的生成算法，在相同的输入参数下，求出了相同的 master secrect。</p>\n</blockquote>\n<p>HTTPS的握手过程如下图：<br><img src=\"https://raw.githubusercontent.com/zhpanvip/Resource/master/image/1201.jfif\"></p>\n<h2 id=\"三、数字证书\"><a href=\"#三、数字证书\" class=\"headerlink\" title=\"三、数字证书\"></a>三、数字证书</h2><p>我们上面提到了HTTPS的工作原理，通过对称加密和非对称加密实现数据的安全传输。我们也知道非对称加密过程需要用到公钥进行加密。那么公钥从何而来？其实公钥就被包含在数字证书中。数字证书通常来说是由受信任的数字证书颁发机构CA，在验证服务器身份后颁发，证书中包含了一个密钥对（公钥和私钥）和所有者识别信息。数字证书被放到服务端，具有服务器身份验证和数据传输加密功能。</p>\n<p>除了CA机构颁发的证书之外，还有非CA机构颁发的证书和自签名证书。</p>\n<ul>\n<li>非CA机构即是不受信任的机构颁发的证书，理所当然这样的证书是不受信任的。</li>\n<li>自签名证书，就是自己给自己颁发的证书。当然自签名证书也是不受信任的。</li>\n</ul>\n<p>例如大(chou)名(ming)鼎(zhao)鼎(zhu)的12306网站使用的就是非CA机构颁发的证书（最近发现12306购票页面已经改为CA证书了），12306的证书是由SRCA颁发，SRCA中文名叫中铁数字证书认证中心，简称中铁CA。这是个铁道部自己搞的机构，相当于是自己给自己颁发证书。因此我们访问12306时通常会看到如下情景：<br><img src=\"https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTgwMjExMTczMjQ4NjE3?x-oss-process=image/format,png\" alt=\"这里写图片描述\"></p>\n<p>说了这么多，我们来总结一下数字证书的两个作用：</p>\n<blockquote>\n<p>1， 分发公钥。每个数字证书都包含了注册者生成的公钥。在 TLS握手时会通过 certificate 消息传输给客户端。<br>2， 身份授权。确保客户端访问的网站是经过 CA 验证的可信任的网站。（在自签名证书的情况下可以验证是否是我们自己的服务器）</p>\n</blockquote>\n<p>最后我们从<a href=\"http://blog.csdn.net/dd864140130/article/details/52625666\">别处</a>搬来一个中间人攻击的例子，来认识证书是如何保证我们的数据安全的。<br>对于一个正常的网络请求，其流程通常如下：<br><img src=\"https://raw.githubusercontent.com/zhpanvip/Resource/master/image/1203.jfif\"></p>\n<p>但是，如果有黑客在通信过程中拦截了这个请求。试想在客户端和服务端中间有一个中间人，两者之间的传输对中间人来说是透明的，那么中间人完全可以获取两端之间的任何数据并加以修改，然后转发给两端。其流程如下图：<br><img src=\"https://raw.githubusercontent.com/zhpanvip/Resource/master/image/1204.jfif\"></p>\n<p>此时恶意服务端完全可以发起双向攻击：对上可以欺骗服务端，对下可以欺骗客户端，更严重的是客户端段和服务端完全感知不到已经被攻击了。这就是所谓的中间人攻击。</p>\n<blockquote>\n<p>中间人攻击（MITM攻击）是指，黑客拦截并篡改网络中的通信数据。又分为被动MITM和主动MITM，被动MITM只窃取通信数据而不修改，而主动MITM不但能窃取数据，还会篡改通信数据。最常见的中间人攻击常常发生在公共wifi或者公共路由上。</p>\n</blockquote>\n<p>现在可以看看使用证书是怎么样提高安全性，避免中间人攻击的，用一张简单的流程图来说明：</p>\n<p><img src=\"https://raw.githubusercontent.com/zhpanvip/Resource/master/image/1205.jfif\"></p>\n<h2 id=\"四、HTTPS单项认证\"><a href=\"#四、HTTPS单项认证\" class=\"headerlink\" title=\" 四、HTTPS单项认证\"></a> 四、HTTPS单项认证</h2><p>所谓单项认证只要服务端配置证书，客户端在请求服务端时验证服务器的证书即可。我们上述讲到的内容其实都是说的HTTPS单项认证。通常来说对于安全性要求不高的网站单项认证就可以满足我们的需求了。因此我们访问的HTTPS网站大部分都是单项认证。</p>\n<p><strong>1.关于HTTPS的使用存在的误区</strong><br>由于我们对安全性的认识不够重视，通常对于HTTPS存在一些误区，这些误区可能直接给我们带来一些安全隐患。<br>*<strong>误区（1）：对于CA机构颁发的证书客户端无须内置***<br>上面提到访问HTTPS服务器是需要在客户端配置服务器证书的。有些小伙伴可能就纳闷了，说我们用的就是HTTPS但是并没有在客户端配置证书呢？比如请求百度的网站<a href=\"https://www.baidu.com/%EF%BC%8C%E5%92%8C%E8%AF%B7%E6%B1%82HTTP%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%B2%A1%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%E3%80%82%E5%85%B6%E5%AE%9E%E8%BF%99%E6%98%AF%E5%9B%A0%E4%B8%BA%E5%9C%A8Android%E7%B3%BB%E7%BB%9F%E4%B8%AD%E5%B7%B2%E7%BB%8F%E5%86%85%E7%BD%AE%E4%BA%86%E6%89%80%E6%9C%89CA%E6%9C%BA%E6%9E%84%E7%9A%84%E6%A0%B9%E8%AF%81%E4%B9%A6%EF%BC%8C%E4%B9%9F%E5%B0%B1%E6%98%AF%E5%8F%AA%E8%A6%81%E6%98%AFCA%E6%9C%BA%E6%9E%84%E9%A2%81%E5%8F%91%E7%9A%84%E8%AF%81%E4%B9%A6%EF%BC%8CAndroid%E6%98%AF%E7%9B%B4%E6%8E%A5%E4%BF%A1%E4%BB%BB%E7%9A%84%E3%80%82%E5%AF%B9%E4%BA%8E%E6%AD%A4%E7%A7%8D%E6%83%85%E5%86%B5%EF%BC%8C%E8%99%BD%E7%84%B6%E5%8F%AF%E4%BB%A5%E6%AD%A3%E5%B8%B8%E8%AE%BF%E9%97%AE%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%8C%E4%BD%86%E6%98%AF%E4%BB%8D%E7%84%B6%E5%AD%98%E5%9C%A8%E5%AE%89%E5%85%A8%E9%9A%90%E6%82%A3%E3%80%82%E5%81%87%E5%A6%82%E9%BB%91%E5%AE%A2%E8%87%AA%E5%AE%B6%E6%90%AD%E5%BB%BA%E4%BA%86%E4%B8%80%E4%B8%AA%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%B9%B6%E7%94%B3%E8%AF%B7%E5%88%B0%E4%BA%86CA%E8%AF%81%E4%B9%A6%EF%BC%8C%E7%94%B1%E4%BA%8E%E6%88%91%E4%BB%AC%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%B2%A1%E6%9C%89%E5%86%85%E7%BD%AE%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AF%81%E4%B9%A6%EF%BC%8C%E9%BB%98%E8%AE%A4%E4%BF%A1%E4%BB%BB%E6%89%80%E6%9C%89CA%E8%AF%81%E4%B9%A6%EF%BC%88%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%8F%AF%E4%BB%A5%E8%AE%BF%E9%97%AE%E6%89%80%E6%9C%89%E6%8C%81%E6%9C%89%E7%94%B1CA%E6%9C%BA%E6%9E%84%E9%A2%81%E5%8F%91%E7%9A%84%E8%AF%81%E4%B9%A6%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%89%EF%BC%8C%E9%82%A3%E4%B9%88%E9%BB%91%E5%AE%A2%E4%BB%8D%E7%84%B6%E5%8F%AF%E4%BB%A5%E5%8F%91%E8%B5%B7%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB%E5%8A%AB%E6%8C%81%E6%88%91%E4%BB%AC%E7%9A%84%E8%AF%B7%E6%B1%82%E5%88%B0%E9%BB%91%E5%AE%A2%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%8C%E5%AE%9E%E9%99%85%E4%B8%8A%E5%B0%B1%E6%88%90%E4%BA%86%E6%88%91%E4%BB%AC%E7%9A%84%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%92%8C%E9%BB%91%E5%AE%A2%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BB%BA%E7%AB%8B%E8%B5%B7%E4%BA%86%E8%BF%9E%E6%8E%A5%E3%80%82\">https://www.baidu.com/，和请求HTTP服务器没什么区别。其实这是因为在Android系统中已经内置了所有CA机构的根证书，也就是只要是CA机构颁发的证书，Android是直接信任的。对于此种情况，虽然可以正常访问到服务器，但是仍然存在安全隐患。假如黑客自家搭建了一个服务器并申请到了CA证书，由于我们客户端没有内置服务器证书，默认信任所有CA证书（客户端可以访问所有持有由CA机构颁发的证书的服务器），那么黑客仍然可以发起中间人攻击劫持我们的请求到黑客的服务器，实际上就成了我们的客户端和黑客的服务器建立起了连接。</a><br>*</strong>误区（2）：对于非CA机构颁发的证书和自签名证书，可以忽略证书校验***<br>另外一种情况，如果我们服务器的证书是非认证机构颁发的 (例如12306)或者自签名证书，那么我们是无法直接访问到服务器的，直接访问通常会抛出如下异常：</p>\n<pre><code class=\"hljs css\"><span class=\"hljs-selector-tag\">javax</span><span class=\"hljs-selector-class\">.net</span><span class=\"hljs-selector-class\">.ssl</span><span class=\"hljs-selector-class\">.SSLHandshakeException</span>: \n    <span class=\"hljs-selector-tag\">java</span><span class=\"hljs-selector-class\">.security</span><span class=\"hljs-selector-class\">.cert</span><span class=\"hljs-selector-class\">.CertPathValidatorException</span>: \n        <span class=\"hljs-selector-tag\">Trust</span> <span class=\"hljs-selector-tag\">anchor</span> <span class=\"hljs-selector-tag\">for</span> <span class=\"hljs-selector-tag\">certification</span> <span class=\"hljs-selector-tag\">path</span> <span class=\"hljs-selector-tag\">not</span> <span class=\"hljs-selector-tag\">found</span>.</code></pre>\n<p>网上很多解决SSLHandshakeException异常的方案是自定义TrustManager忽略证书校验。代码如下：</p>\n<pre><code class=\"hljs aspectj\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-function\">SSLSocketFactory <span class=\"hljs-title\">getSSLSocketFactory</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> Exception </span>&#123;\n        <span class=\"hljs-comment\">//创建一个不验证证书链的证书信任管理器。</span>\n        <span class=\"hljs-keyword\">final</span> TrustManager[] trustAllCerts = <span class=\"hljs-keyword\">new</span> TrustManager[]&#123;<span class=\"hljs-keyword\">new</span> X509TrustManager() &#123;\n            <span class=\"hljs-meta\">@Override</span>\n            <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> checkClientTrusted(\n                    java.security.cert.X509Certificate[] chain,\n                    String authType) <span class=\"hljs-keyword\">throws</span> CertificateException &#123;\n            &#125;\n\n            <span class=\"hljs-meta\">@Override</span>\n            <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> checkServerTrusted(\n                    java.security.cert.X509Certificate[] chain,\n                    String authType) <span class=\"hljs-keyword\">throws</span> CertificateException &#123;\n            &#125;\n\n            <span class=\"hljs-meta\">@Override</span>\n            <span class=\"hljs-keyword\">public</span> java.security.cert.X509Certificate[] getAcceptedIssuers() &#123;\n                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> java.security.cert.X509Certificate[<span class=\"hljs-number\">0</span>];\n            &#125;\n        &#125;&#125;;\n\n        <span class=\"hljs-comment\">// Install the all-trusting trust manager</span>\n        <span class=\"hljs-keyword\">final</span> SSLContext sslContext = SSLContext.getInstance(<span class=\"hljs-string\">&quot;TLS&quot;</span>);\n        sslContext.init(<span class=\"hljs-keyword\">null</span>, trustAllCerts,\n                <span class=\"hljs-keyword\">new</span> java.security.SecureRandom());\n        <span class=\"hljs-comment\">// Create an ssl socket factory with our all-trusting manager</span>\n        <span class=\"hljs-keyword\">return</span> sslContext\n                .getSocketFactory();\n    &#125;\n\n\n  <span class=\"hljs-comment\">//使用自定义SSLSocketFactory</span>\n  <span class=\"hljs-keyword\">private</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onHttps</span><span class=\"hljs-params\">(OkHttpClient.Builder builder)</span> </span>&#123;\n       <span class=\"hljs-keyword\">try</span> &#123;\n            builder.sslSocketFactory(getSSLSocketFactory()).hostnameVerifier(org.apache.http.conn.ssl.SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);\n        &#125; <span class=\"hljs-keyword\">catch</span> (Exception e) &#123;\n            e.printStackTrace();\n        &#125;\n\n    &#125;</code></pre>\n<p>对于这样的处理方式虽然解决了SSLHandshakeException异常，但是却存在更大的安全隐患。因为此种做法直接使我们的客户端信任了所有证书（包括CA机构颁发的证书和非CA机构颁发的证书以及自签名证书），因此，这样配置将比第一种情况危害更大。</p>\n<p><strong>2.Retrofit绑定证书实现HTTPS单项认证</strong><br>对于上述两种情况中存在的安全隐患，我们应该如何应对？最简单的解决方案就是在客户端内置服务器的证书，我们在校验服务端证书的时候只比对和App内置的证书是否完全相同，如果不同则断开连接。那么此时再遭遇中间人攻击劫持我们的请求时由于黑客服务器没有相应的证书，此时HTTPS请求校验不通过，则无法与黑客的服务器建立起连接。</p>\n<p>那么接下来我们就结合Retrofit以访问12306为例来实现HTTPS的单项认证。<br>首先从12306网站下载签名证书，并放置到我们项目资源目录raw下。然后根据证书构造SSLSocketFactory，代码如下：</p>\n<pre><code class=\"hljs reasonml\"><span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">    * 单项认证</span>\n<span class=\"hljs-comment\">    */</span>\n   public static SSLSocketFactory get<span class=\"hljs-constructor\">SSLSocketFactoryForOneWay(InputStream<span class=\"hljs-operator\">...</span> <span class=\"hljs-params\">certificates</span>)</span> &#123;\n       <span class=\"hljs-keyword\">try</span> &#123;\n           CertificateFactory certificateFactory = <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">CertificateFactory</span>.</span></span>get<span class=\"hljs-constructor\">Instance(CLIENT_TRUST_MANAGER, CLIENT_TRUST_PROVIDER)</span>;\n           KeyStore keyStore = <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">KeyStore</span>.</span></span>get<span class=\"hljs-constructor\">Instance(CLIENT_TRUST_KEYSTORE)</span>;\n           keyStore.load(null);\n           <span class=\"hljs-built_in\">int</span> index = <span class=\"hljs-number\">0</span>;\n           <span class=\"hljs-keyword\">for</span> (InputStream certificate : certificates) &#123;\n               String certificateAlias = <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">Integer</span>.</span></span><span class=\"hljs-keyword\">to</span><span class=\"hljs-constructor\">String(<span class=\"hljs-params\">index</span><span class=\"hljs-operator\">++</span>)</span>;\n               keyStore.set<span class=\"hljs-constructor\">CertificateEntry(<span class=\"hljs-params\">certificateAlias</span>, <span class=\"hljs-params\">certificateFactory</span>.<span class=\"hljs-params\">generateCertificate</span>(<span class=\"hljs-params\">certificate</span>)</span>);\n               <span class=\"hljs-keyword\">try</span> &#123;\n                   <span class=\"hljs-keyword\">if</span> (certificate != null)\n                       certificate.close<span class=\"hljs-literal\">()</span>;\n               &#125; catch (IOException e) &#123;\n                   e.print<span class=\"hljs-constructor\">StackTrace()</span>;\n               &#125;\n           &#125;\n\n           SSLContext sslContext = <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">SSLContext</span>.</span></span>get<span class=\"hljs-constructor\">Instance(CLIENT_AGREEMENT)</span>;\n\n           TrustManagerFactory trustManagerFactory =\n                   <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">TrustManagerFactory</span>.</span></span>get<span class=\"hljs-constructor\">Instance(TrustManagerFactory.<span class=\"hljs-params\">getDefaultAlgorithm</span>()</span>);\n\n           trustManagerFactory.init(keyStore);\n           sslContext.init(null, trustManagerFactory.get<span class=\"hljs-constructor\">TrustManagers()</span>, <span class=\"hljs-keyword\">new</span> <span class=\"hljs-constructor\">SecureRandom()</span>);\n           return sslContext.get<span class=\"hljs-constructor\">SocketFactory()</span>;\n       &#125; catch (Exception e) &#123;\n           e.print<span class=\"hljs-constructor\">StackTrace()</span>;\n       &#125;\n       return null;\n   &#125;</code></pre>\n<p>接下来为OKHttpClient设置SslSocketFactory以及hostnameVerifier，代码如下：</p>\n<pre><code class=\"hljs reasonml\">InputStream certificate12306 = <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">Utils</span>.</span></span>get<span class=\"hljs-constructor\">Context()</span>.get<span class=\"hljs-constructor\">Resources()</span>.<span class=\"hljs-keyword\">open</span><span class=\"hljs-constructor\">RawResource(R.<span class=\"hljs-params\">raw</span>.<span class=\"hljs-params\">srca</span>)</span>;\n        OkHttpClient okHttpClient = <span class=\"hljs-keyword\">new</span> OkHttpClient.<span class=\"hljs-constructor\">Builder()</span>\n                .read<span class=\"hljs-constructor\">Timeout(Constants.DEFAULT_TIMEOUT, TimeUnit.MILLISECONDS)</span>\n                .connect<span class=\"hljs-constructor\">Timeout(Constants.DEFAULT_TIMEOUT, TimeUnit.MILLISECONDS)</span>\n                .add<span class=\"hljs-constructor\">Interceptor(<span class=\"hljs-params\">interceptor</span>)</span>\n                .add<span class=\"hljs-constructor\">Interceptor(<span class=\"hljs-params\">new</span> HttpHeaderInterceptor()</span>)\n                .add<span class=\"hljs-constructor\">NetworkInterceptor(<span class=\"hljs-params\">new</span> HttpCacheInterceptor()</span>)\n                .ssl<span class=\"hljs-constructor\">SocketFactory(SslContextFactory.<span class=\"hljs-params\">getSSLSocketFactoryForOneWay</span>(<span class=\"hljs-params\">certificate12306</span>)</span>)  \n                .hostname<span class=\"hljs-constructor\">Verifier(<span class=\"hljs-params\">new</span> SafeHostnameVerifier()</span>)\n                .cache(cache)\n                .build<span class=\"hljs-literal\">()</span>;</code></pre>\n<p>上述代码中hostnameVerifier是对服务器的校验，SafeHostnameVerifier代码如下：</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">SafeHostnameVerifier</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">HostnameVerifier</span> </span>&#123;\n       <span class=\"hljs-meta\">@Override</span>\n       <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">verify</span><span class=\"hljs-params\">(String hostname, SSLSession session)</span> </span>&#123;\n           <span class=\"hljs-keyword\">if</span> (Constants.IP.equals(hostname)) &#123;<span class=\"hljs-comment\">//校验hostname是否正确，如果正确则建立连接</span>\n               <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">true</span>;\n           &#125;\n           <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>;\n       &#125;\n   &#125;</code></pre>\n<p>verify方法中对比了请求的IP和服务器的IP是否一致，一致则返回true表示校验通过，否则返回false，检验不通过，断开连接。对于网上有些处理是直接返回true，即不对请求的服务器IP做校验，我们不推荐这样使用。而且现在谷歌应用商店已经对此种做法做了限制，禁止在verify方法中直接返回true的App上线。</p>\n<h2 id=\"五、HTTPS双向认证\"><a href=\"#五、HTTPS双向认证\" class=\"headerlink\" title=\" 五、HTTPS双向认证\"></a> 五、HTTPS双向认证</h2><p>对于HTTPS双向认证，用到的情况不多。但是对于像金融行业等对安全性要求较高的企业，通常都会使用双向认证。所谓双向认证就是客户端校验服务器证书，同时服务器也需要校验客户端的证书。因此，双向认证就另需一张证书放到客户端待服务端去验证。</p>\n<blockquote>\n<p>单项认证保证了我们自己的客户端只能访问我们自己的服务器，但并不能保证我们自己的服务器只能被我们自己的客户端访问（第三方客户端忽略证书校验即可）。那么双向认证则保证了我们的客户端只能访问我们自己的服务器，同时我们的服务器也只能被我们自己的客户端访问。因此双向认证可以说相比单项认证安全性足足提高一个等级。</p>\n</blockquote>\n<p><strong>1.双向认证流程</strong><br>接下来我们来了解下双向认证的流程，以加深对双向认证的理解：</p>\n<blockquote>\n<p>a. 客户端发送一个连接请求给服务器。<br>　　b. 服务器将自己的证书，以及同证书相关的信息发送给客户端。<br>　　c. 客户端检查服务器送过来的证书是否和App内置证书相同。如果是，就继续执行协议；如果不是则终止此次请求。<br>　　d. 接着客户端比较证书里的消息，例如域名和公钥，与服务器刚刚发送的相关消息是否一致，如果是一致的，客户端认可这个服务器的合法身份。<br>　　e. 服务器要求客户发送客户自己的证书。收到后，服务器验证客户端的证书，如果没有通过验证，拒绝连接；如果通过验证，服务器获得用户的公钥。<br>　　f. 客户端告诉服务器自己所能够支持的通讯对称密码方案。<br>　　g. 服务器从客户发送过来的密码方案中，选择一种加密程度最高的密码方案，用客户的公钥加过密后通知客户端。<br>　　h. 客户端针对这个密码方案，选择一个通话密钥，接着用服务器的公钥加过密后发送给服务器。<br>　　i. 服务器接收到客户端送过来的消息，用自己的私钥解密，获得通话密钥。<br>　　j. 服务器通过密钥解密客户端发送的被加密数据，得到明文数据。</p>\n</blockquote>\n<p><strong>2.Retrofit实现HTTPS双向认证</strong><br>对于双向认证，我们以华为北向平台登录接口为例来进行学习。想了解华为北向API<a href=\"http://developer.huawei.com/ict/cn/doc/site-oceanconnect-northbound_api_reference-zh/index.html/zh-cn_topic_0087306564\">请戳此处</a><br>我们直接通过浏览器访问登录接口可以看到如下情景：<br><img src=\"https://raw.githubusercontent.com/zhpanvip/Resource/master/image/1206.jfif\"></p>\n<p>哈，惊喜不？直接被拒绝了！这就是双向认证，没有证书想访问服务器门都没有。那么对于双向认证我们应该做怎样的配置？我们可以参考华为开源出来的代码<a href=\"https://github.com/Huawei/IoT_OceanConnect_North_GUI_APPDemo\">戳此处</a><br>源码中由两个证书文件ca.jks和outgoing.CertwithKey.pkcs12，其中ca.jks是在客户端配置的证书，outgoing.CertwithKey.pkcs12是在服务端配置的证书。因为我们当前客户端是Android系统，由于Android系统不支持jks格式的证书，因此需要把jks转成Android支持的bks格式。转换方式不再贴出，可自行查阅。<br>有了证书，接下来看获取SSLSocketFactory的代码：</p>\n<pre><code class=\"hljs reasonml\"><span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">   * 双向认证</span>\n<span class=\"hljs-comment\">   *</span>\n<span class=\"hljs-comment\">   * @return SSLSocketFactory</span>\n<span class=\"hljs-comment\">   */</span>\n  public static SSLSocketFactory get<span class=\"hljs-constructor\">SSLSocketFactoryForTwoWay()</span> &#123;\n      <span class=\"hljs-keyword\">try</span> &#123;\n          InputStream certificate = <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">Utils</span>.</span></span>get<span class=\"hljs-constructor\">Context()</span>.get<span class=\"hljs-constructor\">Resources()</span>.<span class=\"hljs-keyword\">open</span><span class=\"hljs-constructor\">RawResource(R.<span class=\"hljs-params\">raw</span>.<span class=\"hljs-params\">capk</span>)</span>;\n          <span class=\"hljs-comment\">//  CertificateFactory certificateFactory = CertificateFactory.getInstance(&quot;X.509&quot;, &quot;BC&quot;);</span>\n          KeyStore keyStore = <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">KeyStore</span>.</span></span>get<span class=\"hljs-constructor\">Instance(CLIENT_TRUST_KEY)</span>;\n          keyStore.load(certificate, <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">SELF_CERT_PWD</span>.</span></span><span class=\"hljs-keyword\">to</span><span class=\"hljs-constructor\">CharArray()</span>);\n          KeyManagerFactory kmf = <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">KeyManagerFactory</span>.</span></span>get<span class=\"hljs-constructor\">Instance(KeyManagerFactory.<span class=\"hljs-params\">getDefaultAlgorithm</span>()</span>);\n          kmf.init(keyStore, <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">SELF_CERT_PWD</span>.</span></span><span class=\"hljs-keyword\">to</span><span class=\"hljs-constructor\">CharArray()</span>);\n\n          <span class=\"hljs-keyword\">try</span> &#123;\n              <span class=\"hljs-keyword\">if</span> (certificate != null)\n                  certificate.close<span class=\"hljs-literal\">()</span>;\n          &#125; catch (IOException e) &#123;\n              e.print<span class=\"hljs-constructor\">StackTrace()</span>;\n          &#125;\n\n          <span class=\"hljs-comment\">//初始化keystore</span>\n          KeyStore clientKeyStore = <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">KeyStore</span>.</span></span>get<span class=\"hljs-constructor\">Instance(CLIENT_TRUST_KEYSTORE)</span>;\n          clientKeyStore.load(<span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">Utils</span>.</span></span>get<span class=\"hljs-constructor\">Context()</span>.get<span class=\"hljs-constructor\">Resources()</span>.<span class=\"hljs-keyword\">open</span><span class=\"hljs-constructor\">RawResource(R.<span class=\"hljs-params\">raw</span>.<span class=\"hljs-params\">cabks</span>)</span>, <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">TRUST_CA_PWD</span>.</span></span><span class=\"hljs-keyword\">to</span><span class=\"hljs-constructor\">CharArray()</span>);\n\n          SSLContext sslContext = <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">SSLContext</span>.</span></span>get<span class=\"hljs-constructor\">Instance(CLIENT_AGREEMENT)</span>;\n          TrustManagerFactory trustManagerFactory = TrustManagerFactory.\n                  get<span class=\"hljs-constructor\">Instance(TrustManagerFactory.<span class=\"hljs-params\">getDefaultAlgorithm</span>()</span>);\n\n          trustManagerFactory.init(clientKeyStore);\n\n          KeyManagerFactory keyManagerFactory = <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">KeyManagerFactory</span>.</span></span>get<span class=\"hljs-constructor\">Instance(KeyManagerFactory.<span class=\"hljs-params\">getDefaultAlgorithm</span>()</span>);\n          keyManagerFactory.init(clientKeyStore, <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">SELF_CERT_PWD</span>.</span></span><span class=\"hljs-keyword\">to</span><span class=\"hljs-constructor\">CharArray()</span>);\n\n          sslContext.init(kmf.get<span class=\"hljs-constructor\">KeyManagers()</span>, trustManagerFactory.get<span class=\"hljs-constructor\">TrustManagers()</span>, <span class=\"hljs-keyword\">new</span> <span class=\"hljs-constructor\">SecureRandom()</span>);\n          return sslContext.get<span class=\"hljs-constructor\">SocketFactory()</span>;\n      &#125; catch (Exception e) &#123;\n          e.print<span class=\"hljs-constructor\">StackTrace()</span>;\n      &#125;\n      return null;\n  &#125;</code></pre>\n<p>接下来同样需要配置OKHttpClient，代码如下：</p>\n<pre><code class=\"hljs reasonml\">OkHttpClient okHttpClient = <span class=\"hljs-keyword\">new</span> OkHttpClient.<span class=\"hljs-constructor\">Builder()</span>\n                .read<span class=\"hljs-constructor\">Timeout(Constants.DEFAULT_TIMEOUT, TimeUnit.MILLISECONDS)</span>\n                .connect<span class=\"hljs-constructor\">Timeout(Constants.DEFAULT_TIMEOUT, TimeUnit.MILLISECONDS)</span>\n                .add<span class=\"hljs-constructor\">Interceptor(<span class=\"hljs-params\">interceptor</span>)</span>\n                .add<span class=\"hljs-constructor\">Interceptor(<span class=\"hljs-params\">new</span> HttpHeaderInterceptor()</span>)\n                .add<span class=\"hljs-constructor\">NetworkInterceptor(<span class=\"hljs-params\">new</span> HttpCacheInterceptor()</span>)\n                .ssl<span class=\"hljs-constructor\">SocketFactory(SslContextFactory.<span class=\"hljs-params\">getSSLSocketFactoryForTwoWay</span>()</span>) \n                .hostname<span class=\"hljs-constructor\">Verifier(<span class=\"hljs-params\">new</span> SafeHostnameVerifier()</span>)\n                .cache(cache)\n                .build<span class=\"hljs-literal\">()</span>;</code></pre>\n<p>这样就完成了HTTPS的配置，接下来就可以愉快的访问HTTPS 双向认证的接口了。由于北向登录接口中需要appId和secret两个参数，因此，登录相关代码就不再贴出。</p>\n<p>好了，到此关于HTTPS的学习就结束了，如果有不明白的地方可以参看文末源码。以上内容纯属个人对HTTPS的一些认识，如果文中有错误之处还请多多包涵，欢迎留言指正。</p>\n<p>本文写成参考了大量的相关文章，在此表示感谢。</p>\n<p><a href=\"https://github.com/zhpanvip/Retrofit2/tree/master/idea/src/main/java/com/zhpan/idea/net/https\">源码参考</a></p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"http://blog.jobbole.com/86660/\">大型网站的 HTTPS 实践（1）：HTTPS 协议和原理</a><br><a href=\"http://blog.csdn.net/dd864140130/article/details/52625666\">Retrofit中如何正确的使用https？</a><br><a href=\"http://blog.csdn.net/lmj623565791/article/details/48129405\">Android Https相关完全解析 当OkHttp遇到Https</a><br><a href=\"https://www.jianshu.com/p/f2097616e65e\">HTTPS原理及OKHTTP对HTTPS的支持</a></p>\n"},{"title":"Android Widget开发详解","date":"2018-06-21T05:35:28.000Z","_content":"好久没博客更新了，本篇文章来学习一下如何实现一个Android列表小部件，效果可以参看下图：\n![](https://raw.githubusercontent.com/zhpanvip/Resource/master/image/1303.gif)\n\n这个页面如果是在App内部实现，相信只要有一点Android基础的童鞋都能很轻松写出来。但是如果放到Widget中可能就不是那么简单了。因为Widget并没有运行在我们App的进程中，而是运行在系统的SystemServer进程中。你可能会惊讶，Whf！竟然不在我们App进程中！那么是不是意味着我们也不能像在App中那样操作View控件了？答案确实如此。不过不必过于担心，为了我们能在远程进程中更新界面，Google爸爸专门为我们提供了一个RemoteViews类。从名字上看，可能会觉得RemoteViews就是一个View。但事实并非如此，RemoteViews仅仅表示的是一个View结构。它可以在远程进程中展示和更新界面。今天我们要实现的列表小部件就是基于RemoteVeiw实现的。\n那么接下来我们来学习如何实现一个桌面Widget，我们先列出要实现Widget的几个核心步骤：\n\n - widget页面布局  \n - 小部件配置信息 \n - 了解AppWidgetProvider\n - RemoteViewsFactory实现列表适配\n - 点击的事件处理\n\n一. 实现Widget界面\n-------------\n\n**1.widget页面布局。**首先创建一个布局文件layout_widget.xml，内容如下：\n```\n<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:id=\"@+id/ll_right\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"wrap_content\"\n    android:background=\"@drawable/bg_widget\"\n    android:orientation=\"vertical\">\n\n    <RelativeLayout\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"40dp\"\n        android:background=\"#ccc\">\n\n        <ImageView\n            android:id=\"@+id/iv_icon\"\n            android:layout_width=\"30dp\"\n            android:layout_height=\"30dp\"\n            android:layout_centerVertical=\"true\"\n            android:layout_marginEnd=\"5dp\"\n            android:layout_marginStart=\"5dp\"\n            android:background=\"@mipmap/ic_launcher_round\" />\n\n        <TextView\n            android:id=\"@+id/tv_title\"\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:layout_centerVertical=\"true\"\n            android:layout_toEndOf=\"@id/iv_icon\"\n            android:text=\"Widget\" />\n\n        <LinearLayout\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"match_parent\"\n            android:layout_alignParentEnd=\"true\"\n            android:gravity=\"center_vertical\"\n            android:orientation=\"horizontal\">\n\n            <ProgressBar\n                android:id=\"@+id/progress_bar\"\n                android:layout_width=\"20dp\"\n                android:layout_height=\"20dp\"\n                android:indeterminateTint=\"@color/colorAccent\"\n                android:indeterminateTintMode=\"src_atop\"\n                android:visibility=\"gone\" />\n\n            <TextView\n                android:id=\"@+id/tv_refresh\"\n                android:layout_width=\"wrap_content\"\n                android:layout_height=\"wrap_content\"\n                android:layout_marginEnd=\"15dp\"\n                android:text=\"刷新\"\n                android:padding=\"5dp\"\n                android:textSize=\"12sp\" />\n        </LinearLayout>\n\n    </RelativeLayout>\n\n    <ListView\n        android:id=\"@+id/lv_device\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"match_parent\"\n        android:columnWidth=\"80dip\"\n        android:gravity=\"center\"\n        android:horizontalSpacing=\"4dip\"\n        android:numColumns=\"auto_fit\"\n        android:verticalSpacing=\"4dip\" />\n\n</LinearLayout>\n```\n看到布局中的ListView控件，你可能会不屑一笑，都什么年代了还在用ListView？RecyclerView才是王道吧？可是我只能说句抱歉，Widget不支持RecyclerView。对，你没看错，真的不支持。在Widget中我们没办法做到想用什么就用什么，甚至觉得原生用着不爽，自己撸一个控件出来。对不起，Widget都不支持。因此Widget也有很大的局限性。我们来看下支持在Widget中运行的有哪些控件：\n\n> A RemoteViews object (and, consequently, an App Widget) can support the following layout classes:\n> FrameLayout\nLinearLayout\nRelativeLayout\nGridLayout\nAnd the following widget classes:\nAnalogClock\nButton\nChronometer\nImageButton\nImageView\nProgressBar\nTextView\nViewFlipper\nListView\nGridView\nStackView\nAdapterViewFlipper\nDescendants of these classes are not supported.\n\n除了上述列出的几个View，其它的包括Android原生View和自定义View是都不支持在Widget中运行的。因此基于Widget页面限制我们基本就可以告别炫酷的动画效果了。\n\n二.小部件配置信息\n------------\n\n配置信息主要是设定小部件的一些属性，比如宽高、缩放模式、更新时间间隔等。我们需要在res/xml目录下新建widget_provider.xml文件，文件名字可以任意取。文件内容如下（可做参考）：\n\n```\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<appwidget-provider xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:minHeight=\"180dp\"\n    android:minWidth=\"300dp\"\n    android:previewImage=\"@drawable/ic_launcher_background\"\n    android:initialLayout=\"@layout/layout_widget\"\n    android:updatePeriodMillis=\"50000\"\n    android:resizeMode=\"horizontal|vertical\"\n    android:widgetCategory=\"home_screen\"> \n    \n</appwidget-provider>\n```\n针对上述文件中的配置信息来做下介绍。\n\n - ***minHeight、minWidth*** 定义Widget的最小高度和最小宽度（Widget可以通过拉伸来调整尺寸大小）。\n - ***previewImage*** 定义添加小部件时显示的图标。\n - ***initialLayout*** 定义了小部件使用的布局。\n - ***updatePeriodMillis***定义小部件自动更新的周期，单位为毫秒。\n - ***resizeMode*** 指定了 widget 的调整尺寸的规则。可取的值有: \"horizontal\", \"vertical\", \"none\"。\"horizontal\"意味着widget可以水平拉伸，“vertical”意味着widget可以竖值拉伸，“none”意味着widget不能拉伸；默认值是\"none\"。\n - ***widgetCategory*** 指定了 widget 能显示的地方：能否显示在 home Screen 或 lock screen 或 两者都可以。它的取值包括：\"home_screen\" 和 \"keyguard\"。Android 4.2 引入。\n 最后，需要我们在AndroidManifest中注册AppWidgetProvider时引用该文件，使用如下：\n \n```\n<receiver android:name=\".widget.ListWidgetProvider\">\n     ...\n    <meta-data\n        android:name=\"android.appwidget.provider\"\n        android:resource=\"@xml/widget_provider\" />\n</receiver>\n```\n\n三.了解AppWidgetProvider类\n-----------\n\n我们来简单了解下AppWidgetProvider这个类。Widget的功能均是通过AppWidgetProvider来实现的。我们跟进源码可以发现它是继承自BroadcastReceiver类，也就是一个广播接收者。上面我们提到过RemoteViews是运行在SystemServer进程中的，再结合此处我们应该可以推测小部件的事件应该是通过广播来实现的。像小部件的添加、删除、更新、启用、禁用等均是在AppWidgetProvider中通过接受广播来完成的。看AppWidgetProvider中的几个方法：\n\n - onUpdate() 当Widget被添加或者被更新时会调用该方法。上边我们提到通过配置updatePeriodMillis可以定期更新Widget。但是当我们在widget的配置文件中声明了android:configure的时候，添加Widget时则不会调用onUpdate方法。\n - onEnable() 这个方法会在用户首次添加Widget时调用。\n - onAppWidgetOptionsChanged() 这个方法会在添加Widget或者改变Widget的大小时候被调用。在这个方法中我们还可以根据Widget的大小来选择性的显示或隐藏某些控件。\n - onDeleted(Context, int[]) 当控件被删除的时候调用该方法\n - onEnabled(Context) 当第一个Widget被添加的时候调用。如果用户添加了两个这个小部件，那么只有第一个添加时才会调用onEnabled.\n - onDisabled(Context) 当最后一个Widget实例被移除的时候调用这个方法。在这个方法中我们可以做一些清除工作，例如删掉临时的数据库等。\n - onReceive(Context, Intent) 当接收到广播的时候会被调用。\n\n\n上述方法中，我们需要着重关心一下onUpdate()方法和onReceive()方法。因为onUpdate()方法会在Widget被添加时候调用，我们可以在此时为Widget添加一View的些交互事件，例如点击事件。由于本篇我们要实现的是一个列表小部件。因此我们还需要RemoteViewsFactory这个类来适配列表数据。\n\n先来看下ListWidgetProvider这个类中的代码：\n```\npublic class ListWidgetProvider extends AppWidgetProvider {\n\n    private static final String TAG = \"WIDGET\";\n\n    public static final String REFRESH_WIDGET = \"com.oitsme.REFRESH_WIDGET\";\n    public static final String COLLECTION_VIEW_ACTION = \"com.oitsme.COLLECTION_VIEW_ACTION\";\n    public static final String COLLECTION_VIEW_EXTRA = \"com.oitsme.COLLECTION_VIEW_EXTRA\";\n    private static Handler mHandler=new Handler();\n    private Runnable runnable=new Runnable() {\n        @Override\n        public void run() {\n            hideLoading(Utils.getContext());\n            Toast.makeText(Utils.getContext(), \"刷新成功\", Toast.LENGTH_SHORT).show();\n        }\n    };\n\n    @Override\n    public void onUpdate(Context context, AppWidgetManager appWidgetManager,\n                         int[] appWidgetIds) {\n\n        Log.d(TAG, \"ListWidgetProvider onUpdate\");\n        for (int appWidgetId : appWidgetIds) {\n            // 获取AppWidget对应的视图\n            RemoteViews remoteViews = new RemoteViews(context.getPackageName(), R.layout.layout_widget);\n\n            // 设置响应 “按钮(bt_refresh)” 的intent\n            Intent btIntent = new Intent().setAction(REFRESH_WIDGET);\n            PendingIntent btPendingIntent = PendingIntent.getBroadcast(context, 0, btIntent, PendingIntent.FLAG_UPDATE_CURRENT);\n            remoteViews.setOnClickPendingIntent(R.id.tv_refresh, btPendingIntent);\n\n            // 设置 “ListView” 的adapter。\n            // (01) intent: 对应启动 ListWidgetService(RemoteViewsService) 的intent\n            // (02) setRemoteAdapter: 设置 gridview的适配器\n            //    通过setRemoteAdapter将ListView和ListWidgetService关联起来，\n            //    以达到通过 ListWidgetService 更新 ListView的目的\n            Intent serviceIntent = new Intent(context, ListWidgetService.class);\n            remoteViews.setRemoteAdapter(R.id.lv_device, serviceIntent);\n\n\n            // 设置响应 “ListView” 的intent模板\n            // 说明：“集合控件(如GridView、ListView、StackView等)”中包含很多子元素，如GridView包含很多格子。\n            //     它们不能像普通的按钮一样通过 setOnClickPendingIntent 设置点击事件，必须先通过两步。\n            //        (01) 通过 setPendingIntentTemplate 设置 “intent模板”，这是比不可少的！\n            //        (02) 然后在处理该“集合控件”的RemoteViewsFactory类的getViewAt()接口中 通过 setOnClickFillInIntent 设置“集合控件的某一项的数据”\n            Intent gridIntent = new Intent();\n\n            gridIntent.setAction(COLLECTION_VIEW_ACTION);\n            gridIntent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, appWidgetId);\n            PendingIntent pendingIntent = PendingIntent.getBroadcast(context, 0, gridIntent, PendingIntent.FLAG_UPDATE_CURRENT);\n            // 设置intent模板\n            remoteViews.setPendingIntentTemplate(R.id.lv_device, pendingIntent);\n            // 调用集合管理器对集合进行更新\n            appWidgetManager.updateAppWidget(appWidgetId, remoteViews);\n        }\n        super.onUpdate(context, appWidgetManager, appWidgetIds);\n    }\n\n\n    @Override\n    public void onReceive(Context context, Intent intent) {\n        String action = intent.getAction();\n        AppWidgetManager appWidgetManager = AppWidgetManager.getInstance(context);\n        if (action.equals(COLLECTION_VIEW_ACTION)) {\n            // 接受“ListView”的点击事件的广播\n            int type = intent.getIntExtra(\"Type\", 0);\n            int appWidgetId = intent.getIntExtra(AppWidgetManager.EXTRA_APPWIDGET_ID,\n                    AppWidgetManager.INVALID_APPWIDGET_ID);\n            int index = intent.getIntExtra(COLLECTION_VIEW_EXTRA, 0);\n            switch (type) {\n                case 0:\n                    Toast.makeText(context, \"item\" + index, Toast.LENGTH_SHORT).show();\n                    break;\n                case 1:\n                    Toast.makeText(context, \"lock\"+index, Toast.LENGTH_SHORT).show();\n                    break;\n                case 2:\n                    Toast.makeText(context, \"unlock\"+index, Toast.LENGTH_SHORT).show();\n                    break;\n            }\n        } else if (action.equals(REFRESH_WIDGET)) {\n            // 接受“bt_refresh”的点击事件的广播\n            Toast.makeText(context, \"刷新...\", Toast.LENGTH_SHORT).show();\n            final AppWidgetManager mgr = AppWidgetManager.getInstance(context);\n            final ComponentName cn = new ComponentName(context,ListWidgetProvider.class);\n            ListRemoteViewsFactory.refresh();\n            mgr.notifyAppWidgetViewDataChanged(mgr.getAppWidgetIds(cn),R.id.lv_device);\n            mHandler.postDelayed(runnable,2000);\n            showLoading(context);\n        }\n        super.onReceive(context, intent);\n    }\n\n    /**\n     * 显示加载loading\n     *\n     */\n    private void showLoading(Context context) {\n        RemoteViews remoteViews = new RemoteViews(context.getPackageName(), R.layout.layout_widget);\n        remoteViews.setViewVisibility(R.id.tv_refresh, View.VISIBLE);\n        remoteViews.setViewVisibility(R.id.progress_bar, View.VISIBLE);\n        remoteViews.setTextViewText(R.id.tv_refresh, \"正在刷新...\");\n        refreshWidget(context, remoteViews, false);\n    }\n\n    /**\n     * 隐藏加载loading\n     */\n    private void hideLoading(Context context) {\n        RemoteViews remoteViews = new RemoteViews(context.getPackageName(), R.layout.layout_widget);\n        remoteViews.setViewVisibility(R.id.progress_bar, View.GONE);\n        remoteViews.setTextViewText(R.id.tv_refresh, \"刷新\");\n        refreshWidget(context, remoteViews, false);\n    }\n\n\n\n    /**\n     * 刷新Widget\n     */\n    private void refreshWidget(Context context, RemoteViews remoteViews, boolean refreshList) {\n        AppWidgetManager appWidgetManager = AppWidgetManager.getInstance(context);\n        ComponentName componentName = new ComponentName(context, ListWidgetProvider.class);\n        appWidgetManager.updateAppWidget(componentName, remoteViews);\n        if (refreshList)\n            appWidgetManager.notifyAppWidgetViewDataChanged(appWidgetManager.getAppWidgetIds(componentName), R.id.lv_device);\n    }\n}\n```\n针对以上代码，我们着重来看onUpdate()方法。在onUpdate()中我们主要实现了两个功能，第一个功能ListView以外的事件点击，例如点击“刷新”来更新小部件。第二个功能是适配ListView并实现ListView内部Item控件的点击事件。在这个方法中我们首先获取到了一个RemoteView的实例，这个RemoteView对应的就是我们Widget布局的View。关于点击事件的实现代码中注释写的也比较详细，在这里就不做过多解释了。重点是需要了解如何实现并适配ListView，具体实现请看下节。\n\n四.RemoteViewsFactory实现列表适配\n--------------------------\n\n上面我们提到了RemoteViewsFactory，这个类其实可以类比为ListView的Adapter，该类存在的意义就是为了适配ListView的数据。只不过这里是把Adapter换成RemoteViews来实现的。看下ListRemoteViewsFactory中的代码：\n```\nclass ListRemoteViewsFactory implements RemoteViewsService.RemoteViewsFactory {\n    private final static String TAG=\"Widget\";\n    private Context mContext;\n    private int mAppWidgetId;\n\n    private static List<Device> mDevices;\n\n    /**\n     * 构造GridRemoteViewsFactory\n     */\n    public ListRemoteViewsFactory(Context context, Intent intent) {\n        mContext = context;\n        mAppWidgetId = intent.getIntExtra(AppWidgetManager.EXTRA_APPWIDGET_ID,\n                AppWidgetManager.INVALID_APPWIDGET_ID);\n    }\n\n    @Override\n    public RemoteViews getViewAt(int position) {\n        //  HashMap<String, Object> map;\n\n        // 获取 item_widget_device.xml 对应的RemoteViews\n        RemoteViews rv = new RemoteViews(mContext.getPackageName(), R.layout.item_widget_device);\n\n        // 设置 第position位的“视图”的数据\n        Device device = mDevices.get(position);\n        //  rv.setImageViewResource(R.id.iv_lock, ((Integer) map.get(IMAGE_ITEM)).intValue());\n        rv.setTextViewText(R.id.tv_name, device.getName());\n\n        // 设置 第position位的“视图”对应的响应事件\n        Intent fillInIntent = new Intent();\n        fillInIntent.putExtra(\"Type\", 0);\n        fillInIntent.putExtra(ListWidgetProvider.COLLECTION_VIEW_EXTRA, position);\n        rv.setOnClickFillInIntent(R.id.rl_widget_device, fillInIntent);\n\n\n        Intent lockIntent = new Intent();\n        lockIntent.putExtra(ListWidgetProvider.COLLECTION_VIEW_EXTRA, position);\n        lockIntent.putExtra(\"Type\", 1);\n        rv.setOnClickFillInIntent(R.id.iv_lock, lockIntent);\n\n        Intent unlockIntent = new Intent();\n        unlockIntent.putExtra(\"Type\", 2);\n        unlockIntent.putExtra(ListWidgetProvider.COLLECTION_VIEW_EXTRA, position);\n        rv.setOnClickFillInIntent(R.id.iv_unlock, unlockIntent);\n\n        return rv;\n    }\n\n\n    /**\n     * 初始化ListView的数据\n     */\n    private void initListViewData() {\n        mDevices = new ArrayList<>();\n        mDevices.add(new Device(\"Hello\", 0));\n        mDevices.add(new Device(\"Oitsme\", 1));\n        mDevices.add(new Device(\"Hi\", 0));\n        mDevices.add(new Device(\"Hey\", 1));\n    }\n    private static int i;\n    public static void refresh(){\n        i++;\n        mDevices.add(new Device(\"Refresh\"+i, 1));\n    }\n\n    @Override\n    public void onCreate() {\n        Log.e(TAG,\"onCreate\");\n        // 初始化“集合视图”中的数据\n        initListViewData();\n    }\n\n    @Override\n    public int getCount() {\n        // 返回“集合视图”中的数据的总数\n        return mDevices.size();\n    }\n\n    @Override\n    public long getItemId(int position) {\n        // 返回当前项在“集合视图”中的位置\n        return position;\n    }\n\n    @Override\n    public RemoteViews getLoadingView() {\n        return null;\n    }\n\n    @Override\n    public int getViewTypeCount() {\n        // 只有一类 ListView\n        return 1;\n    }\n\n    @Override\n    public boolean hasStableIds() {\n        return true;\n    }\n\n    @Override\n    public void onDataSetChanged() {\n    }\n\n    @Override\n    public void onDestroy() {\n        mDevices.clear();\n    }\n}\n```\n有了RemoteViewsFactory 还需要有RemoteViewsService才能与ListView关联起来。来看RemoteViewsService的实现类ListWidgetService，很简单，只重写了onGetViewFactory方法：\n```\npublic class ListWidgetService extends RemoteViewsService {\n\n    @Override\n    public RemoteViewsService.RemoteViewsFactory onGetViewFactory(Intent intent) {\n        return new ListRemoteViewsFactory(this, intent);\n    }\n}\n```\n至此我们可以再次回到ListWidgetProvider中的onUpdate()方法，来看ListWidgetService 是如何与ListView关联到一起的了。\n\n```\n //  设置 “ListView” 的adapter。\n // (01) intent: 对应启动 ListWidgetService(RemoteViewsService) 的intent\n // (02) setRemoteAdapter: 设置 ListView的适配器\n //  通过setRemoteAdapter将ListView和ListWidgetService关联起来，\n //  以达到通过 ListWidgetService 更新 ListView 的目的\n  Intent serviceIntent = new Intent(context, ListWidgetService.class);\n  remoteViews.setRemoteAdapter(R.id.lv_device, serviceIntent);\n```\n\n五.点击事件处理\n------\nWidget中事件点击以及适配ListView，想必大家都有所了解了。那么对于事件的处理我们还没有提到，例如在Widget中点击了刷新后我们不能像在App中那样给控件设置一个事件监听来在回掉方法中处理。在文章开头我们就提到了Widget是依赖广播来实现，因此我们点击了刷新后其实仅仅是发送出来一个广播。如果我们不去处理广播那么点击事件其实是没有任何意义的。因此，来看ListWidgetProvider中第二个比较重要的方法onReceive()。这个方法比较简单，只要我们对特定的广播来做相应的处理就可以了。\n```\n@Override\n    public void onReceive(Context context, Intent intent) {\n        String action = intent.getAction();\n        AppWidgetManager appWidgetManager = AppWidgetManager.getInstance(context);\n\t        if (action.equals(COLLECTION_VIEW_ACTION)) {//处理列表中的事件\n            // 接受“ListView”的点击事件的广播\n            int type = intent.getIntExtra(\"Type\", 0);\n            int appWidgetId = intent.getIntExtra(AppWidgetManager.EXTRA_APPWIDGET_ID,\n                    AppWidgetManager.INVALID_APPWIDGET_ID);\n            int index = intent.getIntExtra(COLLECTION_VIEW_EXTRA, 0);\n            switch (type) {\n                case 0:\n                    Toast.makeText(context, \"item\" + index, Toast.LENGTH_SHORT).show();\n                    break;\n                case 1:\n                    Toast.makeText(context, \"lock\"+index, Toast.LENGTH_SHORT).show();\n                    break;\n                case 2:\n                    Toast.makeText(context, \"unlock\"+index, Toast.LENGTH_SHORT).show();\n                    break;\n            }\n        } else if (action.equals(REFRESH_WIDGET)) {//处理刷新事件\n            // 接受“bt_refresh”的点击事件的广播\n            Toast.makeText(context, \"刷新...\", Toast.LENGTH_SHORT).show();\n            final AppWidgetManager mgr = AppWidgetManager.getInstance(context);\n            final ComponentName cn = new ComponentName(context,ListWidgetProvider.class);\n            ListRemoteViewsFactory.refresh();\n            mgr.notifyAppWidgetViewDataChanged(mgr.getAppWidgetIds(cn),R.id.lv_device);\n            mHandler.postDelayed(runnable,2000);\n            showLoading(context);\n        }\n        super.onReceive(context, intent);\n    }\n```\n最后，别忘了ListWidgetProvider是广播，ListWidgetService是服务，都需要我们在AndroidManifest文件中来注册：\n\n```\n\t   <receiver android:name=\".widget.ListWidgetProvider\">\n            <intent-filter>\n                <action android:name=\"android.appwidget.action.APPWIDGET_UPDATE\" />\n\n                <!-- ListWidgetProvider接收点击ListView的响应事件 -->\n                <action android:name=\"com.oitsme.COLLECTION_VIEW_ACTION\" />\n                <!-- ListWidgetProvider接收点击bt_refresh的响应事件 -->\n                <action android:name=\"com.oitsme.REFRESH_WIDGET\" />\n                <action android:name=\"com.oitsme.LOCK_ACTION\"/>\n                <action android:name=\"com.oitsme.UNLOCK_ACTION\"/>\n            </intent-filter>\n            <meta-data android:name=\"android.appwidget.provider\"\n                android:resource=\"@xml/widget_provider\"/>\n        </receiver>\n\n        <service\n            android:name=\".widget.ListWidgetService\"\n            android:permission=\"android.permission.BIND_REMOTEVIEWS\" />\n```\n\n六.小结\n----\n\n至此关于列表小部件的讲解就完成了。只是自我感觉文章的逻辑有点乱。如果没明白，大家可以参考下面Demo源码。其实关于Widget的这个Demo其实早在几个月前就已经写好了，但由于最近项目紧再加上本身也是第一次接触Widget控件，因此直至近日才开始动笔写这篇文章。所以文章中避免不了有错误和不合理的地方，欢迎留言指正。\n\n参考\nhttps://developer.android.com/guide/topics/appwidgets/\n\n[源码下载](https://download.csdn.net/download/qq_20521573/11659588)\n\n","source":"_posts/13.Android-Widget开发详解.md","raw":"---\ntitle: Android Widget开发详解\ndate: 2018-06-21 13:35:28\ntags: Widget\n---\n好久没博客更新了，本篇文章来学习一下如何实现一个Android列表小部件，效果可以参看下图：\n![](https://raw.githubusercontent.com/zhpanvip/Resource/master/image/1303.gif)\n\n这个页面如果是在App内部实现，相信只要有一点Android基础的童鞋都能很轻松写出来。但是如果放到Widget中可能就不是那么简单了。因为Widget并没有运行在我们App的进程中，而是运行在系统的SystemServer进程中。你可能会惊讶，Whf！竟然不在我们App进程中！那么是不是意味着我们也不能像在App中那样操作View控件了？答案确实如此。不过不必过于担心，为了我们能在远程进程中更新界面，Google爸爸专门为我们提供了一个RemoteViews类。从名字上看，可能会觉得RemoteViews就是一个View。但事实并非如此，RemoteViews仅仅表示的是一个View结构。它可以在远程进程中展示和更新界面。今天我们要实现的列表小部件就是基于RemoteVeiw实现的。\n那么接下来我们来学习如何实现一个桌面Widget，我们先列出要实现Widget的几个核心步骤：\n\n - widget页面布局  \n - 小部件配置信息 \n - 了解AppWidgetProvider\n - RemoteViewsFactory实现列表适配\n - 点击的事件处理\n\n一. 实现Widget界面\n-------------\n\n**1.widget页面布局。**首先创建一个布局文件layout_widget.xml，内容如下：\n```\n<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:id=\"@+id/ll_right\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"wrap_content\"\n    android:background=\"@drawable/bg_widget\"\n    android:orientation=\"vertical\">\n\n    <RelativeLayout\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"40dp\"\n        android:background=\"#ccc\">\n\n        <ImageView\n            android:id=\"@+id/iv_icon\"\n            android:layout_width=\"30dp\"\n            android:layout_height=\"30dp\"\n            android:layout_centerVertical=\"true\"\n            android:layout_marginEnd=\"5dp\"\n            android:layout_marginStart=\"5dp\"\n            android:background=\"@mipmap/ic_launcher_round\" />\n\n        <TextView\n            android:id=\"@+id/tv_title\"\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:layout_centerVertical=\"true\"\n            android:layout_toEndOf=\"@id/iv_icon\"\n            android:text=\"Widget\" />\n\n        <LinearLayout\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"match_parent\"\n            android:layout_alignParentEnd=\"true\"\n            android:gravity=\"center_vertical\"\n            android:orientation=\"horizontal\">\n\n            <ProgressBar\n                android:id=\"@+id/progress_bar\"\n                android:layout_width=\"20dp\"\n                android:layout_height=\"20dp\"\n                android:indeterminateTint=\"@color/colorAccent\"\n                android:indeterminateTintMode=\"src_atop\"\n                android:visibility=\"gone\" />\n\n            <TextView\n                android:id=\"@+id/tv_refresh\"\n                android:layout_width=\"wrap_content\"\n                android:layout_height=\"wrap_content\"\n                android:layout_marginEnd=\"15dp\"\n                android:text=\"刷新\"\n                android:padding=\"5dp\"\n                android:textSize=\"12sp\" />\n        </LinearLayout>\n\n    </RelativeLayout>\n\n    <ListView\n        android:id=\"@+id/lv_device\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"match_parent\"\n        android:columnWidth=\"80dip\"\n        android:gravity=\"center\"\n        android:horizontalSpacing=\"4dip\"\n        android:numColumns=\"auto_fit\"\n        android:verticalSpacing=\"4dip\" />\n\n</LinearLayout>\n```\n看到布局中的ListView控件，你可能会不屑一笑，都什么年代了还在用ListView？RecyclerView才是王道吧？可是我只能说句抱歉，Widget不支持RecyclerView。对，你没看错，真的不支持。在Widget中我们没办法做到想用什么就用什么，甚至觉得原生用着不爽，自己撸一个控件出来。对不起，Widget都不支持。因此Widget也有很大的局限性。我们来看下支持在Widget中运行的有哪些控件：\n\n> A RemoteViews object (and, consequently, an App Widget) can support the following layout classes:\n> FrameLayout\nLinearLayout\nRelativeLayout\nGridLayout\nAnd the following widget classes:\nAnalogClock\nButton\nChronometer\nImageButton\nImageView\nProgressBar\nTextView\nViewFlipper\nListView\nGridView\nStackView\nAdapterViewFlipper\nDescendants of these classes are not supported.\n\n除了上述列出的几个View，其它的包括Android原生View和自定义View是都不支持在Widget中运行的。因此基于Widget页面限制我们基本就可以告别炫酷的动画效果了。\n\n二.小部件配置信息\n------------\n\n配置信息主要是设定小部件的一些属性，比如宽高、缩放模式、更新时间间隔等。我们需要在res/xml目录下新建widget_provider.xml文件，文件名字可以任意取。文件内容如下（可做参考）：\n\n```\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<appwidget-provider xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:minHeight=\"180dp\"\n    android:minWidth=\"300dp\"\n    android:previewImage=\"@drawable/ic_launcher_background\"\n    android:initialLayout=\"@layout/layout_widget\"\n    android:updatePeriodMillis=\"50000\"\n    android:resizeMode=\"horizontal|vertical\"\n    android:widgetCategory=\"home_screen\"> \n    \n</appwidget-provider>\n```\n针对上述文件中的配置信息来做下介绍。\n\n - ***minHeight、minWidth*** 定义Widget的最小高度和最小宽度（Widget可以通过拉伸来调整尺寸大小）。\n - ***previewImage*** 定义添加小部件时显示的图标。\n - ***initialLayout*** 定义了小部件使用的布局。\n - ***updatePeriodMillis***定义小部件自动更新的周期，单位为毫秒。\n - ***resizeMode*** 指定了 widget 的调整尺寸的规则。可取的值有: \"horizontal\", \"vertical\", \"none\"。\"horizontal\"意味着widget可以水平拉伸，“vertical”意味着widget可以竖值拉伸，“none”意味着widget不能拉伸；默认值是\"none\"。\n - ***widgetCategory*** 指定了 widget 能显示的地方：能否显示在 home Screen 或 lock screen 或 两者都可以。它的取值包括：\"home_screen\" 和 \"keyguard\"。Android 4.2 引入。\n 最后，需要我们在AndroidManifest中注册AppWidgetProvider时引用该文件，使用如下：\n \n```\n<receiver android:name=\".widget.ListWidgetProvider\">\n     ...\n    <meta-data\n        android:name=\"android.appwidget.provider\"\n        android:resource=\"@xml/widget_provider\" />\n</receiver>\n```\n\n三.了解AppWidgetProvider类\n-----------\n\n我们来简单了解下AppWidgetProvider这个类。Widget的功能均是通过AppWidgetProvider来实现的。我们跟进源码可以发现它是继承自BroadcastReceiver类，也就是一个广播接收者。上面我们提到过RemoteViews是运行在SystemServer进程中的，再结合此处我们应该可以推测小部件的事件应该是通过广播来实现的。像小部件的添加、删除、更新、启用、禁用等均是在AppWidgetProvider中通过接受广播来完成的。看AppWidgetProvider中的几个方法：\n\n - onUpdate() 当Widget被添加或者被更新时会调用该方法。上边我们提到通过配置updatePeriodMillis可以定期更新Widget。但是当我们在widget的配置文件中声明了android:configure的时候，添加Widget时则不会调用onUpdate方法。\n - onEnable() 这个方法会在用户首次添加Widget时调用。\n - onAppWidgetOptionsChanged() 这个方法会在添加Widget或者改变Widget的大小时候被调用。在这个方法中我们还可以根据Widget的大小来选择性的显示或隐藏某些控件。\n - onDeleted(Context, int[]) 当控件被删除的时候调用该方法\n - onEnabled(Context) 当第一个Widget被添加的时候调用。如果用户添加了两个这个小部件，那么只有第一个添加时才会调用onEnabled.\n - onDisabled(Context) 当最后一个Widget实例被移除的时候调用这个方法。在这个方法中我们可以做一些清除工作，例如删掉临时的数据库等。\n - onReceive(Context, Intent) 当接收到广播的时候会被调用。\n\n\n上述方法中，我们需要着重关心一下onUpdate()方法和onReceive()方法。因为onUpdate()方法会在Widget被添加时候调用，我们可以在此时为Widget添加一View的些交互事件，例如点击事件。由于本篇我们要实现的是一个列表小部件。因此我们还需要RemoteViewsFactory这个类来适配列表数据。\n\n先来看下ListWidgetProvider这个类中的代码：\n```\npublic class ListWidgetProvider extends AppWidgetProvider {\n\n    private static final String TAG = \"WIDGET\";\n\n    public static final String REFRESH_WIDGET = \"com.oitsme.REFRESH_WIDGET\";\n    public static final String COLLECTION_VIEW_ACTION = \"com.oitsme.COLLECTION_VIEW_ACTION\";\n    public static final String COLLECTION_VIEW_EXTRA = \"com.oitsme.COLLECTION_VIEW_EXTRA\";\n    private static Handler mHandler=new Handler();\n    private Runnable runnable=new Runnable() {\n        @Override\n        public void run() {\n            hideLoading(Utils.getContext());\n            Toast.makeText(Utils.getContext(), \"刷新成功\", Toast.LENGTH_SHORT).show();\n        }\n    };\n\n    @Override\n    public void onUpdate(Context context, AppWidgetManager appWidgetManager,\n                         int[] appWidgetIds) {\n\n        Log.d(TAG, \"ListWidgetProvider onUpdate\");\n        for (int appWidgetId : appWidgetIds) {\n            // 获取AppWidget对应的视图\n            RemoteViews remoteViews = new RemoteViews(context.getPackageName(), R.layout.layout_widget);\n\n            // 设置响应 “按钮(bt_refresh)” 的intent\n            Intent btIntent = new Intent().setAction(REFRESH_WIDGET);\n            PendingIntent btPendingIntent = PendingIntent.getBroadcast(context, 0, btIntent, PendingIntent.FLAG_UPDATE_CURRENT);\n            remoteViews.setOnClickPendingIntent(R.id.tv_refresh, btPendingIntent);\n\n            // 设置 “ListView” 的adapter。\n            // (01) intent: 对应启动 ListWidgetService(RemoteViewsService) 的intent\n            // (02) setRemoteAdapter: 设置 gridview的适配器\n            //    通过setRemoteAdapter将ListView和ListWidgetService关联起来，\n            //    以达到通过 ListWidgetService 更新 ListView的目的\n            Intent serviceIntent = new Intent(context, ListWidgetService.class);\n            remoteViews.setRemoteAdapter(R.id.lv_device, serviceIntent);\n\n\n            // 设置响应 “ListView” 的intent模板\n            // 说明：“集合控件(如GridView、ListView、StackView等)”中包含很多子元素，如GridView包含很多格子。\n            //     它们不能像普通的按钮一样通过 setOnClickPendingIntent 设置点击事件，必须先通过两步。\n            //        (01) 通过 setPendingIntentTemplate 设置 “intent模板”，这是比不可少的！\n            //        (02) 然后在处理该“集合控件”的RemoteViewsFactory类的getViewAt()接口中 通过 setOnClickFillInIntent 设置“集合控件的某一项的数据”\n            Intent gridIntent = new Intent();\n\n            gridIntent.setAction(COLLECTION_VIEW_ACTION);\n            gridIntent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, appWidgetId);\n            PendingIntent pendingIntent = PendingIntent.getBroadcast(context, 0, gridIntent, PendingIntent.FLAG_UPDATE_CURRENT);\n            // 设置intent模板\n            remoteViews.setPendingIntentTemplate(R.id.lv_device, pendingIntent);\n            // 调用集合管理器对集合进行更新\n            appWidgetManager.updateAppWidget(appWidgetId, remoteViews);\n        }\n        super.onUpdate(context, appWidgetManager, appWidgetIds);\n    }\n\n\n    @Override\n    public void onReceive(Context context, Intent intent) {\n        String action = intent.getAction();\n        AppWidgetManager appWidgetManager = AppWidgetManager.getInstance(context);\n        if (action.equals(COLLECTION_VIEW_ACTION)) {\n            // 接受“ListView”的点击事件的广播\n            int type = intent.getIntExtra(\"Type\", 0);\n            int appWidgetId = intent.getIntExtra(AppWidgetManager.EXTRA_APPWIDGET_ID,\n                    AppWidgetManager.INVALID_APPWIDGET_ID);\n            int index = intent.getIntExtra(COLLECTION_VIEW_EXTRA, 0);\n            switch (type) {\n                case 0:\n                    Toast.makeText(context, \"item\" + index, Toast.LENGTH_SHORT).show();\n                    break;\n                case 1:\n                    Toast.makeText(context, \"lock\"+index, Toast.LENGTH_SHORT).show();\n                    break;\n                case 2:\n                    Toast.makeText(context, \"unlock\"+index, Toast.LENGTH_SHORT).show();\n                    break;\n            }\n        } else if (action.equals(REFRESH_WIDGET)) {\n            // 接受“bt_refresh”的点击事件的广播\n            Toast.makeText(context, \"刷新...\", Toast.LENGTH_SHORT).show();\n            final AppWidgetManager mgr = AppWidgetManager.getInstance(context);\n            final ComponentName cn = new ComponentName(context,ListWidgetProvider.class);\n            ListRemoteViewsFactory.refresh();\n            mgr.notifyAppWidgetViewDataChanged(mgr.getAppWidgetIds(cn),R.id.lv_device);\n            mHandler.postDelayed(runnable,2000);\n            showLoading(context);\n        }\n        super.onReceive(context, intent);\n    }\n\n    /**\n     * 显示加载loading\n     *\n     */\n    private void showLoading(Context context) {\n        RemoteViews remoteViews = new RemoteViews(context.getPackageName(), R.layout.layout_widget);\n        remoteViews.setViewVisibility(R.id.tv_refresh, View.VISIBLE);\n        remoteViews.setViewVisibility(R.id.progress_bar, View.VISIBLE);\n        remoteViews.setTextViewText(R.id.tv_refresh, \"正在刷新...\");\n        refreshWidget(context, remoteViews, false);\n    }\n\n    /**\n     * 隐藏加载loading\n     */\n    private void hideLoading(Context context) {\n        RemoteViews remoteViews = new RemoteViews(context.getPackageName(), R.layout.layout_widget);\n        remoteViews.setViewVisibility(R.id.progress_bar, View.GONE);\n        remoteViews.setTextViewText(R.id.tv_refresh, \"刷新\");\n        refreshWidget(context, remoteViews, false);\n    }\n\n\n\n    /**\n     * 刷新Widget\n     */\n    private void refreshWidget(Context context, RemoteViews remoteViews, boolean refreshList) {\n        AppWidgetManager appWidgetManager = AppWidgetManager.getInstance(context);\n        ComponentName componentName = new ComponentName(context, ListWidgetProvider.class);\n        appWidgetManager.updateAppWidget(componentName, remoteViews);\n        if (refreshList)\n            appWidgetManager.notifyAppWidgetViewDataChanged(appWidgetManager.getAppWidgetIds(componentName), R.id.lv_device);\n    }\n}\n```\n针对以上代码，我们着重来看onUpdate()方法。在onUpdate()中我们主要实现了两个功能，第一个功能ListView以外的事件点击，例如点击“刷新”来更新小部件。第二个功能是适配ListView并实现ListView内部Item控件的点击事件。在这个方法中我们首先获取到了一个RemoteView的实例，这个RemoteView对应的就是我们Widget布局的View。关于点击事件的实现代码中注释写的也比较详细，在这里就不做过多解释了。重点是需要了解如何实现并适配ListView，具体实现请看下节。\n\n四.RemoteViewsFactory实现列表适配\n--------------------------\n\n上面我们提到了RemoteViewsFactory，这个类其实可以类比为ListView的Adapter，该类存在的意义就是为了适配ListView的数据。只不过这里是把Adapter换成RemoteViews来实现的。看下ListRemoteViewsFactory中的代码：\n```\nclass ListRemoteViewsFactory implements RemoteViewsService.RemoteViewsFactory {\n    private final static String TAG=\"Widget\";\n    private Context mContext;\n    private int mAppWidgetId;\n\n    private static List<Device> mDevices;\n\n    /**\n     * 构造GridRemoteViewsFactory\n     */\n    public ListRemoteViewsFactory(Context context, Intent intent) {\n        mContext = context;\n        mAppWidgetId = intent.getIntExtra(AppWidgetManager.EXTRA_APPWIDGET_ID,\n                AppWidgetManager.INVALID_APPWIDGET_ID);\n    }\n\n    @Override\n    public RemoteViews getViewAt(int position) {\n        //  HashMap<String, Object> map;\n\n        // 获取 item_widget_device.xml 对应的RemoteViews\n        RemoteViews rv = new RemoteViews(mContext.getPackageName(), R.layout.item_widget_device);\n\n        // 设置 第position位的“视图”的数据\n        Device device = mDevices.get(position);\n        //  rv.setImageViewResource(R.id.iv_lock, ((Integer) map.get(IMAGE_ITEM)).intValue());\n        rv.setTextViewText(R.id.tv_name, device.getName());\n\n        // 设置 第position位的“视图”对应的响应事件\n        Intent fillInIntent = new Intent();\n        fillInIntent.putExtra(\"Type\", 0);\n        fillInIntent.putExtra(ListWidgetProvider.COLLECTION_VIEW_EXTRA, position);\n        rv.setOnClickFillInIntent(R.id.rl_widget_device, fillInIntent);\n\n\n        Intent lockIntent = new Intent();\n        lockIntent.putExtra(ListWidgetProvider.COLLECTION_VIEW_EXTRA, position);\n        lockIntent.putExtra(\"Type\", 1);\n        rv.setOnClickFillInIntent(R.id.iv_lock, lockIntent);\n\n        Intent unlockIntent = new Intent();\n        unlockIntent.putExtra(\"Type\", 2);\n        unlockIntent.putExtra(ListWidgetProvider.COLLECTION_VIEW_EXTRA, position);\n        rv.setOnClickFillInIntent(R.id.iv_unlock, unlockIntent);\n\n        return rv;\n    }\n\n\n    /**\n     * 初始化ListView的数据\n     */\n    private void initListViewData() {\n        mDevices = new ArrayList<>();\n        mDevices.add(new Device(\"Hello\", 0));\n        mDevices.add(new Device(\"Oitsme\", 1));\n        mDevices.add(new Device(\"Hi\", 0));\n        mDevices.add(new Device(\"Hey\", 1));\n    }\n    private static int i;\n    public static void refresh(){\n        i++;\n        mDevices.add(new Device(\"Refresh\"+i, 1));\n    }\n\n    @Override\n    public void onCreate() {\n        Log.e(TAG,\"onCreate\");\n        // 初始化“集合视图”中的数据\n        initListViewData();\n    }\n\n    @Override\n    public int getCount() {\n        // 返回“集合视图”中的数据的总数\n        return mDevices.size();\n    }\n\n    @Override\n    public long getItemId(int position) {\n        // 返回当前项在“集合视图”中的位置\n        return position;\n    }\n\n    @Override\n    public RemoteViews getLoadingView() {\n        return null;\n    }\n\n    @Override\n    public int getViewTypeCount() {\n        // 只有一类 ListView\n        return 1;\n    }\n\n    @Override\n    public boolean hasStableIds() {\n        return true;\n    }\n\n    @Override\n    public void onDataSetChanged() {\n    }\n\n    @Override\n    public void onDestroy() {\n        mDevices.clear();\n    }\n}\n```\n有了RemoteViewsFactory 还需要有RemoteViewsService才能与ListView关联起来。来看RemoteViewsService的实现类ListWidgetService，很简单，只重写了onGetViewFactory方法：\n```\npublic class ListWidgetService extends RemoteViewsService {\n\n    @Override\n    public RemoteViewsService.RemoteViewsFactory onGetViewFactory(Intent intent) {\n        return new ListRemoteViewsFactory(this, intent);\n    }\n}\n```\n至此我们可以再次回到ListWidgetProvider中的onUpdate()方法，来看ListWidgetService 是如何与ListView关联到一起的了。\n\n```\n //  设置 “ListView” 的adapter。\n // (01) intent: 对应启动 ListWidgetService(RemoteViewsService) 的intent\n // (02) setRemoteAdapter: 设置 ListView的适配器\n //  通过setRemoteAdapter将ListView和ListWidgetService关联起来，\n //  以达到通过 ListWidgetService 更新 ListView 的目的\n  Intent serviceIntent = new Intent(context, ListWidgetService.class);\n  remoteViews.setRemoteAdapter(R.id.lv_device, serviceIntent);\n```\n\n五.点击事件处理\n------\nWidget中事件点击以及适配ListView，想必大家都有所了解了。那么对于事件的处理我们还没有提到，例如在Widget中点击了刷新后我们不能像在App中那样给控件设置一个事件监听来在回掉方法中处理。在文章开头我们就提到了Widget是依赖广播来实现，因此我们点击了刷新后其实仅仅是发送出来一个广播。如果我们不去处理广播那么点击事件其实是没有任何意义的。因此，来看ListWidgetProvider中第二个比较重要的方法onReceive()。这个方法比较简单，只要我们对特定的广播来做相应的处理就可以了。\n```\n@Override\n    public void onReceive(Context context, Intent intent) {\n        String action = intent.getAction();\n        AppWidgetManager appWidgetManager = AppWidgetManager.getInstance(context);\n\t        if (action.equals(COLLECTION_VIEW_ACTION)) {//处理列表中的事件\n            // 接受“ListView”的点击事件的广播\n            int type = intent.getIntExtra(\"Type\", 0);\n            int appWidgetId = intent.getIntExtra(AppWidgetManager.EXTRA_APPWIDGET_ID,\n                    AppWidgetManager.INVALID_APPWIDGET_ID);\n            int index = intent.getIntExtra(COLLECTION_VIEW_EXTRA, 0);\n            switch (type) {\n                case 0:\n                    Toast.makeText(context, \"item\" + index, Toast.LENGTH_SHORT).show();\n                    break;\n                case 1:\n                    Toast.makeText(context, \"lock\"+index, Toast.LENGTH_SHORT).show();\n                    break;\n                case 2:\n                    Toast.makeText(context, \"unlock\"+index, Toast.LENGTH_SHORT).show();\n                    break;\n            }\n        } else if (action.equals(REFRESH_WIDGET)) {//处理刷新事件\n            // 接受“bt_refresh”的点击事件的广播\n            Toast.makeText(context, \"刷新...\", Toast.LENGTH_SHORT).show();\n            final AppWidgetManager mgr = AppWidgetManager.getInstance(context);\n            final ComponentName cn = new ComponentName(context,ListWidgetProvider.class);\n            ListRemoteViewsFactory.refresh();\n            mgr.notifyAppWidgetViewDataChanged(mgr.getAppWidgetIds(cn),R.id.lv_device);\n            mHandler.postDelayed(runnable,2000);\n            showLoading(context);\n        }\n        super.onReceive(context, intent);\n    }\n```\n最后，别忘了ListWidgetProvider是广播，ListWidgetService是服务，都需要我们在AndroidManifest文件中来注册：\n\n```\n\t   <receiver android:name=\".widget.ListWidgetProvider\">\n            <intent-filter>\n                <action android:name=\"android.appwidget.action.APPWIDGET_UPDATE\" />\n\n                <!-- ListWidgetProvider接收点击ListView的响应事件 -->\n                <action android:name=\"com.oitsme.COLLECTION_VIEW_ACTION\" />\n                <!-- ListWidgetProvider接收点击bt_refresh的响应事件 -->\n                <action android:name=\"com.oitsme.REFRESH_WIDGET\" />\n                <action android:name=\"com.oitsme.LOCK_ACTION\"/>\n                <action android:name=\"com.oitsme.UNLOCK_ACTION\"/>\n            </intent-filter>\n            <meta-data android:name=\"android.appwidget.provider\"\n                android:resource=\"@xml/widget_provider\"/>\n        </receiver>\n\n        <service\n            android:name=\".widget.ListWidgetService\"\n            android:permission=\"android.permission.BIND_REMOTEVIEWS\" />\n```\n\n六.小结\n----\n\n至此关于列表小部件的讲解就完成了。只是自我感觉文章的逻辑有点乱。如果没明白，大家可以参考下面Demo源码。其实关于Widget的这个Demo其实早在几个月前就已经写好了，但由于最近项目紧再加上本身也是第一次接触Widget控件，因此直至近日才开始动笔写这篇文章。所以文章中避免不了有错误和不合理的地方，欢迎留言指正。\n\n参考\nhttps://developer.android.com/guide/topics/appwidgets/\n\n[源码下载](https://download.csdn.net/download/qq_20521573/11659588)\n\n","slug":"13.Android-Widget开发详解","published":1,"updated":"2020-08-29T18:01:51.473Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckegm5nsj0013dwoz70yc5m2i","content":"<p>好久没博客更新了，本篇文章来学习一下如何实现一个Android列表小部件，效果可以参看下图：<br><img src=\"https://raw.githubusercontent.com/zhpanvip/Resource/master/image/1303.gif\"></p>\n<p>这个页面如果是在App内部实现，相信只要有一点Android基础的童鞋都能很轻松写出来。但是如果放到Widget中可能就不是那么简单了。因为Widget并没有运行在我们App的进程中，而是运行在系统的SystemServer进程中。你可能会惊讶，Whf！竟然不在我们App进程中！那么是不是意味着我们也不能像在App中那样操作View控件了？答案确实如此。不过不必过于担心，为了我们能在远程进程中更新界面，Google爸爸专门为我们提供了一个RemoteViews类。从名字上看，可能会觉得RemoteViews就是一个View。但事实并非如此，RemoteViews仅仅表示的是一个View结构。它可以在远程进程中展示和更新界面。今天我们要实现的列表小部件就是基于RemoteVeiw实现的。<br>那么接下来我们来学习如何实现一个桌面Widget，我们先列出要实现Widget的几个核心步骤：</p>\n<ul>\n<li>widget页面布局  </li>\n<li>小部件配置信息 </li>\n<li>了解AppWidgetProvider</li>\n<li>RemoteViewsFactory实现列表适配</li>\n<li>点击的事件处理</li>\n</ul>\n<h2 id=\"一-实现Widget界面\"><a href=\"#一-实现Widget界面\" class=\"headerlink\" title=\"一. 实现Widget界面\"></a>一. 实现Widget界面</h2><p><strong>1.widget页面布局。</strong>首先创建一个布局文件layout_widget.xml，内容如下：</p>\n<pre><code class=\"hljs xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">LinearLayout</span> <span class=\"hljs-attr\">xmlns:android</span>=<span class=\"hljs-string\">&quot;http://schemas.android.com/apk/res/android&quot;</span></span>\n<span class=\"hljs-tag\">    <span class=\"hljs-attr\">android:id</span>=<span class=\"hljs-string\">&quot;@+id/ll_right&quot;</span></span>\n<span class=\"hljs-tag\">    <span class=\"hljs-attr\">android:layout_width</span>=<span class=\"hljs-string\">&quot;match_parent&quot;</span></span>\n<span class=\"hljs-tag\">    <span class=\"hljs-attr\">android:layout_height</span>=<span class=\"hljs-string\">&quot;wrap_content&quot;</span></span>\n<span class=\"hljs-tag\">    <span class=\"hljs-attr\">android:background</span>=<span class=\"hljs-string\">&quot;@drawable/bg_widget&quot;</span></span>\n<span class=\"hljs-tag\">    <span class=\"hljs-attr\">android:orientation</span>=<span class=\"hljs-string\">&quot;vertical&quot;</span>&gt;</span>\n\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">RelativeLayout</span></span>\n<span class=\"hljs-tag\">        <span class=\"hljs-attr\">android:layout_width</span>=<span class=\"hljs-string\">&quot;match_parent&quot;</span></span>\n<span class=\"hljs-tag\">        <span class=\"hljs-attr\">android:layout_height</span>=<span class=\"hljs-string\">&quot;40dp&quot;</span></span>\n<span class=\"hljs-tag\">        <span class=\"hljs-attr\">android:background</span>=<span class=\"hljs-string\">&quot;#ccc&quot;</span>&gt;</span>\n\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ImageView</span></span>\n<span class=\"hljs-tag\">            <span class=\"hljs-attr\">android:id</span>=<span class=\"hljs-string\">&quot;@+id/iv_icon&quot;</span></span>\n<span class=\"hljs-tag\">            <span class=\"hljs-attr\">android:layout_width</span>=<span class=\"hljs-string\">&quot;30dp&quot;</span></span>\n<span class=\"hljs-tag\">            <span class=\"hljs-attr\">android:layout_height</span>=<span class=\"hljs-string\">&quot;30dp&quot;</span></span>\n<span class=\"hljs-tag\">            <span class=\"hljs-attr\">android:layout_centerVertical</span>=<span class=\"hljs-string\">&quot;true&quot;</span></span>\n<span class=\"hljs-tag\">            <span class=\"hljs-attr\">android:layout_marginEnd</span>=<span class=\"hljs-string\">&quot;5dp&quot;</span></span>\n<span class=\"hljs-tag\">            <span class=\"hljs-attr\">android:layout_marginStart</span>=<span class=\"hljs-string\">&quot;5dp&quot;</span></span>\n<span class=\"hljs-tag\">            <span class=\"hljs-attr\">android:background</span>=<span class=\"hljs-string\">&quot;@mipmap/ic_launcher_round&quot;</span> /&gt;</span>\n\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">TextView</span></span>\n<span class=\"hljs-tag\">            <span class=\"hljs-attr\">android:id</span>=<span class=\"hljs-string\">&quot;@+id/tv_title&quot;</span></span>\n<span class=\"hljs-tag\">            <span class=\"hljs-attr\">android:layout_width</span>=<span class=\"hljs-string\">&quot;wrap_content&quot;</span></span>\n<span class=\"hljs-tag\">            <span class=\"hljs-attr\">android:layout_height</span>=<span class=\"hljs-string\">&quot;wrap_content&quot;</span></span>\n<span class=\"hljs-tag\">            <span class=\"hljs-attr\">android:layout_centerVertical</span>=<span class=\"hljs-string\">&quot;true&quot;</span></span>\n<span class=\"hljs-tag\">            <span class=\"hljs-attr\">android:layout_toEndOf</span>=<span class=\"hljs-string\">&quot;@id/iv_icon&quot;</span></span>\n<span class=\"hljs-tag\">            <span class=\"hljs-attr\">android:text</span>=<span class=\"hljs-string\">&quot;Widget&quot;</span> /&gt;</span>\n\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">LinearLayout</span></span>\n<span class=\"hljs-tag\">            <span class=\"hljs-attr\">android:layout_width</span>=<span class=\"hljs-string\">&quot;wrap_content&quot;</span></span>\n<span class=\"hljs-tag\">            <span class=\"hljs-attr\">android:layout_height</span>=<span class=\"hljs-string\">&quot;match_parent&quot;</span></span>\n<span class=\"hljs-tag\">            <span class=\"hljs-attr\">android:layout_alignParentEnd</span>=<span class=\"hljs-string\">&quot;true&quot;</span></span>\n<span class=\"hljs-tag\">            <span class=\"hljs-attr\">android:gravity</span>=<span class=\"hljs-string\">&quot;center_vertical&quot;</span></span>\n<span class=\"hljs-tag\">            <span class=\"hljs-attr\">android:orientation</span>=<span class=\"hljs-string\">&quot;horizontal&quot;</span>&gt;</span>\n\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ProgressBar</span></span>\n<span class=\"hljs-tag\">                <span class=\"hljs-attr\">android:id</span>=<span class=\"hljs-string\">&quot;@+id/progress_bar&quot;</span></span>\n<span class=\"hljs-tag\">                <span class=\"hljs-attr\">android:layout_width</span>=<span class=\"hljs-string\">&quot;20dp&quot;</span></span>\n<span class=\"hljs-tag\">                <span class=\"hljs-attr\">android:layout_height</span>=<span class=\"hljs-string\">&quot;20dp&quot;</span></span>\n<span class=\"hljs-tag\">                <span class=\"hljs-attr\">android:indeterminateTint</span>=<span class=\"hljs-string\">&quot;@color/colorAccent&quot;</span></span>\n<span class=\"hljs-tag\">                <span class=\"hljs-attr\">android:indeterminateTintMode</span>=<span class=\"hljs-string\">&quot;src_atop&quot;</span></span>\n<span class=\"hljs-tag\">                <span class=\"hljs-attr\">android:visibility</span>=<span class=\"hljs-string\">&quot;gone&quot;</span> /&gt;</span>\n\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">TextView</span></span>\n<span class=\"hljs-tag\">                <span class=\"hljs-attr\">android:id</span>=<span class=\"hljs-string\">&quot;@+id/tv_refresh&quot;</span></span>\n<span class=\"hljs-tag\">                <span class=\"hljs-attr\">android:layout_width</span>=<span class=\"hljs-string\">&quot;wrap_content&quot;</span></span>\n<span class=\"hljs-tag\">                <span class=\"hljs-attr\">android:layout_height</span>=<span class=\"hljs-string\">&quot;wrap_content&quot;</span></span>\n<span class=\"hljs-tag\">                <span class=\"hljs-attr\">android:layout_marginEnd</span>=<span class=\"hljs-string\">&quot;15dp&quot;</span></span>\n<span class=\"hljs-tag\">                <span class=\"hljs-attr\">android:text</span>=<span class=\"hljs-string\">&quot;刷新&quot;</span></span>\n<span class=\"hljs-tag\">                <span class=\"hljs-attr\">android:padding</span>=<span class=\"hljs-string\">&quot;5dp&quot;</span></span>\n<span class=\"hljs-tag\">                <span class=\"hljs-attr\">android:textSize</span>=<span class=\"hljs-string\">&quot;12sp&quot;</span> /&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">LinearLayout</span>&gt;</span>\n\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">RelativeLayout</span>&gt;</span>\n\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ListView</span></span>\n<span class=\"hljs-tag\">        <span class=\"hljs-attr\">android:id</span>=<span class=\"hljs-string\">&quot;@+id/lv_device&quot;</span></span>\n<span class=\"hljs-tag\">        <span class=\"hljs-attr\">android:layout_width</span>=<span class=\"hljs-string\">&quot;match_parent&quot;</span></span>\n<span class=\"hljs-tag\">        <span class=\"hljs-attr\">android:layout_height</span>=<span class=\"hljs-string\">&quot;match_parent&quot;</span></span>\n<span class=\"hljs-tag\">        <span class=\"hljs-attr\">android:columnWidth</span>=<span class=\"hljs-string\">&quot;80dip&quot;</span></span>\n<span class=\"hljs-tag\">        <span class=\"hljs-attr\">android:gravity</span>=<span class=\"hljs-string\">&quot;center&quot;</span></span>\n<span class=\"hljs-tag\">        <span class=\"hljs-attr\">android:horizontalSpacing</span>=<span class=\"hljs-string\">&quot;4dip&quot;</span></span>\n<span class=\"hljs-tag\">        <span class=\"hljs-attr\">android:numColumns</span>=<span class=\"hljs-string\">&quot;auto_fit&quot;</span></span>\n<span class=\"hljs-tag\">        <span class=\"hljs-attr\">android:verticalSpacing</span>=<span class=\"hljs-string\">&quot;4dip&quot;</span> /&gt;</span>\n\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">LinearLayout</span>&gt;</span></code></pre>\n<p>看到布局中的ListView控件，你可能会不屑一笑，都什么年代了还在用ListView？RecyclerView才是王道吧？可是我只能说句抱歉，Widget不支持RecyclerView。对，你没看错，真的不支持。在Widget中我们没办法做到想用什么就用什么，甚至觉得原生用着不爽，自己撸一个控件出来。对不起，Widget都不支持。因此Widget也有很大的局限性。我们来看下支持在Widget中运行的有哪些控件：</p>\n<blockquote>\n<p>A RemoteViews object (and, consequently, an App Widget) can support the following layout classes:<br>FrameLayout<br>LinearLayout<br>RelativeLayout<br>GridLayout<br>And the following widget classes:<br>AnalogClock<br>Button<br>Chronometer<br>ImageButton<br>ImageView<br>ProgressBar<br>TextView<br>ViewFlipper<br>ListView<br>GridView<br>StackView<br>AdapterViewFlipper<br>Descendants of these classes are not supported.</p>\n</blockquote>\n<p>除了上述列出的几个View，其它的包括Android原生View和自定义View是都不支持在Widget中运行的。因此基于Widget页面限制我们基本就可以告别炫酷的动画效果了。</p>\n<h2 id=\"二-小部件配置信息\"><a href=\"#二-小部件配置信息\" class=\"headerlink\" title=\"二.小部件配置信息\"></a>二.小部件配置信息</h2><p>配置信息主要是设定小部件的一些属性，比如宽高、缩放模式、更新时间间隔等。我们需要在res/xml目录下新建widget_provider.xml文件，文件名字可以任意取。文件内容如下（可做参考）：</p>\n<pre><code class=\"hljs xml\"><span class=\"hljs-meta\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">appwidget-provider</span> <span class=\"hljs-attr\">xmlns:android</span>=<span class=\"hljs-string\">&quot;http://schemas.android.com/apk/res/android&quot;</span></span>\n<span class=\"hljs-tag\">    <span class=\"hljs-attr\">android:minHeight</span>=<span class=\"hljs-string\">&quot;180dp&quot;</span></span>\n<span class=\"hljs-tag\">    <span class=\"hljs-attr\">android:minWidth</span>=<span class=\"hljs-string\">&quot;300dp&quot;</span></span>\n<span class=\"hljs-tag\">    <span class=\"hljs-attr\">android:previewImage</span>=<span class=\"hljs-string\">&quot;@drawable/ic_launcher_background&quot;</span></span>\n<span class=\"hljs-tag\">    <span class=\"hljs-attr\">android:initialLayout</span>=<span class=\"hljs-string\">&quot;@layout/layout_widget&quot;</span></span>\n<span class=\"hljs-tag\">    <span class=\"hljs-attr\">android:updatePeriodMillis</span>=<span class=\"hljs-string\">&quot;50000&quot;</span></span>\n<span class=\"hljs-tag\">    <span class=\"hljs-attr\">android:resizeMode</span>=<span class=\"hljs-string\">&quot;horizontal|vertical&quot;</span></span>\n<span class=\"hljs-tag\">    <span class=\"hljs-attr\">android:widgetCategory</span>=<span class=\"hljs-string\">&quot;home_screen&quot;</span>&gt;</span> \n    \n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">appwidget-provider</span>&gt;</span></code></pre>\n<p>针对上述文件中的配置信息来做下介绍。</p>\n<ul>\n<li><strong><em>minHeight、minWidth</em></strong> 定义Widget的最小高度和最小宽度（Widget可以通过拉伸来调整尺寸大小）。</li>\n<li><strong><em>previewImage</em></strong> 定义添加小部件时显示的图标。</li>\n<li><strong><em>initialLayout</em></strong> 定义了小部件使用的布局。</li>\n<li><strong><em>updatePeriodMillis</em></strong>定义小部件自动更新的周期，单位为毫秒。</li>\n<li><strong><em>resizeMode</em></strong> 指定了 widget 的调整尺寸的规则。可取的值有: “horizontal”, “vertical”, “none”。”horizontal”意味着widget可以水平拉伸，“vertical”意味着widget可以竖值拉伸，“none”意味着widget不能拉伸；默认值是”none”。</li>\n<li><strong><em>widgetCategory</em></strong> 指定了 widget 能显示的地方：能否显示在 home Screen 或 lock screen 或 两者都可以。它的取值包括：”home_screen” 和 “keyguard”。Android 4.2 引入。<br>最后，需要我们在AndroidManifest中注册AppWidgetProvider时引用该文件，使用如下：</li>\n</ul>\n<pre><code class=\"hljs xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">receiver</span> <span class=\"hljs-attr\">android:name</span>=<span class=\"hljs-string\">&quot;.widget.ListWidgetProvider&quot;</span>&gt;</span>\n     ...\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta-data</span></span>\n<span class=\"hljs-tag\">        <span class=\"hljs-attr\">android:name</span>=<span class=\"hljs-string\">&quot;android.appwidget.provider&quot;</span></span>\n<span class=\"hljs-tag\">        <span class=\"hljs-attr\">android:resource</span>=<span class=\"hljs-string\">&quot;@xml/widget_provider&quot;</span> /&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">receiver</span>&gt;</span></code></pre>\n\n<h2 id=\"三-了解AppWidgetProvider类\"><a href=\"#三-了解AppWidgetProvider类\" class=\"headerlink\" title=\"三.了解AppWidgetProvider类\"></a>三.了解AppWidgetProvider类</h2><p>我们来简单了解下AppWidgetProvider这个类。Widget的功能均是通过AppWidgetProvider来实现的。我们跟进源码可以发现它是继承自BroadcastReceiver类，也就是一个广播接收者。上面我们提到过RemoteViews是运行在SystemServer进程中的，再结合此处我们应该可以推测小部件的事件应该是通过广播来实现的。像小部件的添加、删除、更新、启用、禁用等均是在AppWidgetProvider中通过接受广播来完成的。看AppWidgetProvider中的几个方法：</p>\n<ul>\n<li>onUpdate() 当Widget被添加或者被更新时会调用该方法。上边我们提到通过配置updatePeriodMillis可以定期更新Widget。但是当我们在widget的配置文件中声明了android:configure的时候，添加Widget时则不会调用onUpdate方法。</li>\n<li>onEnable() 这个方法会在用户首次添加Widget时调用。</li>\n<li>onAppWidgetOptionsChanged() 这个方法会在添加Widget或者改变Widget的大小时候被调用。在这个方法中我们还可以根据Widget的大小来选择性的显示或隐藏某些控件。</li>\n<li>onDeleted(Context, int[]) 当控件被删除的时候调用该方法</li>\n<li>onEnabled(Context) 当第一个Widget被添加的时候调用。如果用户添加了两个这个小部件，那么只有第一个添加时才会调用onEnabled.</li>\n<li>onDisabled(Context) 当最后一个Widget实例被移除的时候调用这个方法。在这个方法中我们可以做一些清除工作，例如删掉临时的数据库等。</li>\n<li>onReceive(Context, Intent) 当接收到广播的时候会被调用。</li>\n</ul>\n<p>上述方法中，我们需要着重关心一下onUpdate()方法和onReceive()方法。因为onUpdate()方法会在Widget被添加时候调用，我们可以在此时为Widget添加一View的些交互事件，例如点击事件。由于本篇我们要实现的是一个列表小部件。因此我们还需要RemoteViewsFactory这个类来适配列表数据。</p>\n<p>先来看下ListWidgetProvider这个类中的代码：</p>\n<pre><code class=\"hljs arduino\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ListWidgetProvider</span> <span class=\"hljs-title\">extends</span> <span class=\"hljs-title\">AppWidgetProvider</span> &#123;</span>\n\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">String</span> TAG = <span class=\"hljs-string\">&quot;WIDGET&quot;</span>;\n\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">String</span> REFRESH_WIDGET = <span class=\"hljs-string\">&quot;com.oitsme.REFRESH_WIDGET&quot;</span>;\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">String</span> COLLECTION_VIEW_ACTION = <span class=\"hljs-string\">&quot;com.oitsme.COLLECTION_VIEW_ACTION&quot;</span>;\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">String</span> COLLECTION_VIEW_EXTRA = <span class=\"hljs-string\">&quot;com.oitsme.COLLECTION_VIEW_EXTRA&quot;</span>;\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> Handler mHandler=<span class=\"hljs-keyword\">new</span> Handler();\n    <span class=\"hljs-keyword\">private</span> Runnable runnable=<span class=\"hljs-keyword\">new</span> Runnable() &#123;\n        @Override\n        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-built_in\">run</span>() &#123;\n            hideLoading(Utils.getContext());\n            Toast.makeText(Utils.getContext(), <span class=\"hljs-string\">&quot;刷新成功&quot;</span>, Toast.LENGTH_SHORT).show();\n        &#125;\n    &#125;;\n\n    @Override\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onUpdate</span><span class=\"hljs-params\">(Context context, AppWidgetManager appWidgetManager,</span></span>\n<span class=\"hljs-function\"><span class=\"hljs-params\">                         <span class=\"hljs-keyword\">int</span>[] appWidgetIds)</span> </span>&#123;\n\n        Log.d(TAG, <span class=\"hljs-string\">&quot;ListWidgetProvider onUpdate&quot;</span>);\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> appWidgetId : appWidgetIds) &#123;\n            <span class=\"hljs-comment\">// 获取AppWidget对应的视图</span>\n            RemoteViews remoteViews = <span class=\"hljs-keyword\">new</span> RemoteViews(context.getPackageName(), R.layout.layout_widget);\n\n            <span class=\"hljs-comment\">// 设置响应 “按钮(bt_refresh)” 的intent</span>\n            Intent btIntent = <span class=\"hljs-keyword\">new</span> Intent().setAction(REFRESH_WIDGET);\n            PendingIntent btPendingIntent = PendingIntent.getBroadcast(context, <span class=\"hljs-number\">0</span>, btIntent, PendingIntent.FLAG_UPDATE_CURRENT);\n            remoteViews.setOnClickPendingIntent(R.id.tv_refresh, btPendingIntent);\n\n            <span class=\"hljs-comment\">// 设置 “ListView” 的adapter。</span>\n            <span class=\"hljs-comment\">// (01) intent: 对应启动 ListWidgetService(RemoteViewsService) 的intent</span>\n            <span class=\"hljs-comment\">// (02) setRemoteAdapter: 设置 gridview的适配器</span>\n            <span class=\"hljs-comment\">//    通过setRemoteAdapter将ListView和ListWidgetService关联起来，</span>\n            <span class=\"hljs-comment\">//    以达到通过 ListWidgetService 更新 ListView的目的</span>\n            Intent serviceIntent = <span class=\"hljs-keyword\">new</span> Intent(context, ListWidgetService.class);\n            remoteViews.setRemoteAdapter(R.id.lv_device, serviceIntent);\n\n\n            <span class=\"hljs-comment\">// 设置响应 “ListView” 的intent模板</span>\n            <span class=\"hljs-comment\">// 说明：“集合控件(如GridView、ListView、StackView等)”中包含很多子元素，如GridView包含很多格子。</span>\n            <span class=\"hljs-comment\">//     它们不能像普通的按钮一样通过 setOnClickPendingIntent 设置点击事件，必须先通过两步。</span>\n            <span class=\"hljs-comment\">//        (01) 通过 setPendingIntentTemplate 设置 “intent模板”，这是比不可少的！</span>\n            <span class=\"hljs-comment\">//        (02) 然后在处理该“集合控件”的RemoteViewsFactory类的getViewAt()接口中 通过 setOnClickFillInIntent 设置“集合控件的某一项的数据”</span>\n            Intent gridIntent = <span class=\"hljs-keyword\">new</span> Intent();\n\n            gridIntent.setAction(COLLECTION_VIEW_ACTION);\n            gridIntent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, appWidgetId);\n            PendingIntent pendingIntent = PendingIntent.getBroadcast(context, <span class=\"hljs-number\">0</span>, gridIntent, PendingIntent.FLAG_UPDATE_CURRENT);\n            <span class=\"hljs-comment\">// 设置intent模板</span>\n            remoteViews.setPendingIntentTemplate(R.id.lv_device, pendingIntent);\n            <span class=\"hljs-comment\">// 调用集合管理器对集合进行更新</span>\n            appWidgetManager.updateAppWidget(appWidgetId, remoteViews);\n        &#125;\n        super.onUpdate(context, appWidgetManager, appWidgetIds);\n    &#125;\n\n\n    @Override\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onReceive</span><span class=\"hljs-params\">(Context context, Intent intent)</span> </span>&#123;\n        <span class=\"hljs-keyword\">String</span> action = intent.getAction();\n        AppWidgetManager appWidgetManager = AppWidgetManager.getInstance(context);\n        <span class=\"hljs-keyword\">if</span> (action.equals(COLLECTION_VIEW_ACTION)) &#123;\n            <span class=\"hljs-comment\">// 接受“ListView”的点击事件的广播</span>\n            <span class=\"hljs-keyword\">int</span> type = intent.getIntExtra(<span class=\"hljs-string\">&quot;Type&quot;</span>, <span class=\"hljs-number\">0</span>);\n            <span class=\"hljs-keyword\">int</span> appWidgetId = intent.getIntExtra(AppWidgetManager.EXTRA_APPWIDGET_ID,\n                    AppWidgetManager.INVALID_APPWIDGET_ID);\n            <span class=\"hljs-keyword\">int</span> index = intent.getIntExtra(COLLECTION_VIEW_EXTRA, <span class=\"hljs-number\">0</span>);\n            <span class=\"hljs-keyword\">switch</span> (type) &#123;\n                <span class=\"hljs-keyword\">case</span> <span class=\"hljs-number\">0</span>:\n                    Toast.makeText(context, <span class=\"hljs-string\">&quot;item&quot;</span> + index, Toast.LENGTH_SHORT).show();\n                    <span class=\"hljs-keyword\">break</span>;\n                <span class=\"hljs-keyword\">case</span> <span class=\"hljs-number\">1</span>:\n                    Toast.makeText(context, <span class=\"hljs-string\">&quot;lock&quot;</span>+index, Toast.LENGTH_SHORT).show();\n                    <span class=\"hljs-keyword\">break</span>;\n                <span class=\"hljs-keyword\">case</span> <span class=\"hljs-number\">2</span>:\n                    Toast.makeText(context, <span class=\"hljs-string\">&quot;unlock&quot;</span>+index, Toast.LENGTH_SHORT).show();\n                    <span class=\"hljs-keyword\">break</span>;\n            &#125;\n        &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (action.equals(REFRESH_WIDGET)) &#123;\n            <span class=\"hljs-comment\">// 接受“bt_refresh”的点击事件的广播</span>\n            Toast.makeText(context, <span class=\"hljs-string\">&quot;刷新...&quot;</span>, Toast.LENGTH_SHORT).show();\n            <span class=\"hljs-keyword\">final</span> AppWidgetManager mgr = AppWidgetManager.getInstance(context);\n            <span class=\"hljs-keyword\">final</span> ComponentName cn = <span class=\"hljs-keyword\">new</span> ComponentName(context,ListWidgetProvider.class);\n            ListRemoteViewsFactory.refresh();\n            mgr.notifyAppWidgetViewDataChanged(mgr.getAppWidgetIds(cn),R.id.lv_device);\n            mHandler.postDelayed(runnable,<span class=\"hljs-number\">2000</span>);\n            showLoading(context);\n        &#125;\n        super.<span class=\"hljs-built_in\">onReceive</span>(context, intent);\n    &#125;\n\n    <span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">     * 显示加载loading</span>\n<span class=\"hljs-comment\">     *</span>\n<span class=\"hljs-comment\">     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">showLoading</span><span class=\"hljs-params\">(Context context)</span> </span>&#123;\n        RemoteViews remoteViews = <span class=\"hljs-keyword\">new</span> RemoteViews(context.getPackageName(), R.layout.layout_widget);\n        remoteViews.setViewVisibility(R.id.tv_refresh, View.VISIBLE);\n        remoteViews.setViewVisibility(R.id.progress_bar, View.VISIBLE);\n        remoteViews.setTextViewText(R.id.tv_refresh, <span class=\"hljs-string\">&quot;正在刷新...&quot;</span>);\n        refreshWidget(context, remoteViews, <span class=\"hljs-literal\">false</span>);\n    &#125;\n\n    <span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">     * 隐藏加载loading</span>\n<span class=\"hljs-comment\">     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">hideLoading</span><span class=\"hljs-params\">(Context context)</span> </span>&#123;\n        RemoteViews remoteViews = <span class=\"hljs-keyword\">new</span> RemoteViews(context.getPackageName(), R.layout.layout_widget);\n        remoteViews.setViewVisibility(R.id.progress_bar, View.GONE);\n        remoteViews.setTextViewText(R.id.tv_refresh, <span class=\"hljs-string\">&quot;刷新&quot;</span>);\n        refreshWidget(context, remoteViews, <span class=\"hljs-literal\">false</span>);\n    &#125;\n\n\n\n    <span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">     * 刷新Widget</span>\n<span class=\"hljs-comment\">     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">refreshWidget</span><span class=\"hljs-params\">(Context context, RemoteViews remoteViews, <span class=\"hljs-keyword\">boolean</span> refreshList)</span> </span>&#123;\n        AppWidgetManager appWidgetManager = AppWidgetManager.getInstance(context);\n        ComponentName componentName = <span class=\"hljs-keyword\">new</span> ComponentName(context, ListWidgetProvider.class);\n        appWidgetManager.updateAppWidget(componentName, remoteViews);\n        <span class=\"hljs-keyword\">if</span> (refreshList)\n            appWidgetManager.notifyAppWidgetViewDataChanged(appWidgetManager.getAppWidgetIds(componentName), R.id.lv_device);\n    &#125;\n&#125;</code></pre>\n<p>针对以上代码，我们着重来看onUpdate()方法。在onUpdate()中我们主要实现了两个功能，第一个功能ListView以外的事件点击，例如点击“刷新”来更新小部件。第二个功能是适配ListView并实现ListView内部Item控件的点击事件。在这个方法中我们首先获取到了一个RemoteView的实例，这个RemoteView对应的就是我们Widget布局的View。关于点击事件的实现代码中注释写的也比较详细，在这里就不做过多解释了。重点是需要了解如何实现并适配ListView，具体实现请看下节。</p>\n<h2 id=\"四-RemoteViewsFactory实现列表适配\"><a href=\"#四-RemoteViewsFactory实现列表适配\" class=\"headerlink\" title=\"四.RemoteViewsFactory实现列表适配\"></a>四.RemoteViewsFactory实现列表适配</h2><p>上面我们提到了RemoteViewsFactory，这个类其实可以类比为ListView的Adapter，该类存在的意义就是为了适配ListView的数据。只不过这里是把Adapter换成RemoteViews来实现的。看下ListRemoteViewsFactory中的代码：</p>\n<pre><code class=\"hljs arduino\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ListRemoteViewsFactory</span> <span class=\"hljs-title\">implements</span> <span class=\"hljs-title\">RemoteViewsService</span>.<span class=\"hljs-title\">RemoteViewsFactory</span> &#123;</span>\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">String</span> TAG=<span class=\"hljs-string\">&quot;Widget&quot;</span>;\n    <span class=\"hljs-keyword\">private</span> Context mContext;\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">int</span> mAppWidgetId;\n\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> List&lt;Device&gt; mDevices;\n\n    <span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">     * 构造GridRemoteViewsFactory</span>\n<span class=\"hljs-comment\">     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">ListRemoteViewsFactory</span><span class=\"hljs-params\">(Context context, Intent intent)</span> </span>&#123;\n        mContext = context;\n        mAppWidgetId = intent.getIntExtra(AppWidgetManager.EXTRA_APPWIDGET_ID,\n                AppWidgetManager.INVALID_APPWIDGET_ID);\n    &#125;\n\n    @Override\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> RemoteViews <span class=\"hljs-title\">getViewAt</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> <span class=\"hljs-built_in\">position</span>)</span> </span>&#123;\n        <span class=\"hljs-comment\">//  HashMap&lt;String, Object&gt; map;</span>\n\n        <span class=\"hljs-comment\">// 获取 item_widget_device.xml 对应的RemoteViews</span>\n        RemoteViews rv = <span class=\"hljs-keyword\">new</span> RemoteViews(mContext.getPackageName(), R.layout.item_widget_device);\n\n        <span class=\"hljs-comment\">// 设置 第position位的“视图”的数据</span>\n        Device device = mDevices.<span class=\"hljs-built_in\">get</span>(<span class=\"hljs-built_in\">position</span>);\n        <span class=\"hljs-comment\">//  rv.setImageViewResource(R.id.iv_lock, ((Integer) map.get(IMAGE_ITEM)).intValue());</span>\n        rv.setTextViewText(R.id.tv_name, device.getName());\n\n        <span class=\"hljs-comment\">// 设置 第position位的“视图”对应的响应事件</span>\n        Intent fillInIntent = <span class=\"hljs-keyword\">new</span> Intent();\n        fillInIntent.putExtra(<span class=\"hljs-string\">&quot;Type&quot;</span>, <span class=\"hljs-number\">0</span>);\n        fillInIntent.putExtra(ListWidgetProvider.COLLECTION_VIEW_EXTRA, <span class=\"hljs-built_in\">position</span>);\n        rv.setOnClickFillInIntent(R.id.rl_widget_device, fillInIntent);\n\n\n        Intent lockIntent = <span class=\"hljs-keyword\">new</span> Intent();\n        lockIntent.putExtra(ListWidgetProvider.COLLECTION_VIEW_EXTRA, <span class=\"hljs-built_in\">position</span>);\n        lockIntent.putExtra(<span class=\"hljs-string\">&quot;Type&quot;</span>, <span class=\"hljs-number\">1</span>);\n        rv.setOnClickFillInIntent(R.id.iv_lock, lockIntent);\n\n        Intent unlockIntent = <span class=\"hljs-keyword\">new</span> Intent();\n        unlockIntent.putExtra(<span class=\"hljs-string\">&quot;Type&quot;</span>, <span class=\"hljs-number\">2</span>);\n        unlockIntent.putExtra(ListWidgetProvider.COLLECTION_VIEW_EXTRA, <span class=\"hljs-built_in\">position</span>);\n        rv.setOnClickFillInIntent(R.id.iv_unlock, unlockIntent);\n\n        <span class=\"hljs-keyword\">return</span> rv;\n    &#125;\n\n\n    <span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">     * 初始化ListView的数据</span>\n<span class=\"hljs-comment\">     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">initListViewData</span><span class=\"hljs-params\">()</span> </span>&#123;\n        mDevices = <span class=\"hljs-keyword\">new</span> ArrayList&lt;&gt;();\n        mDevices.add(<span class=\"hljs-keyword\">new</span> Device(<span class=\"hljs-string\">&quot;Hello&quot;</span>, <span class=\"hljs-number\">0</span>));\n        mDevices.add(<span class=\"hljs-keyword\">new</span> Device(<span class=\"hljs-string\">&quot;Oitsme&quot;</span>, <span class=\"hljs-number\">1</span>));\n        mDevices.add(<span class=\"hljs-keyword\">new</span> Device(<span class=\"hljs-string\">&quot;Hi&quot;</span>, <span class=\"hljs-number\">0</span>));\n        mDevices.add(<span class=\"hljs-keyword\">new</span> Device(<span class=\"hljs-string\">&quot;Hey&quot;</span>, <span class=\"hljs-number\">1</span>));\n    &#125;\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">int</span> i;\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">refresh</span><span class=\"hljs-params\">()</span></span>&#123;\n        i++;\n        mDevices.add(<span class=\"hljs-keyword\">new</span> Device(<span class=\"hljs-string\">&quot;Refresh&quot;</span>+i, <span class=\"hljs-number\">1</span>));\n    &#125;\n\n    @Override\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onCreate</span><span class=\"hljs-params\">()</span> </span>&#123;\n        Log.e(TAG,<span class=\"hljs-string\">&quot;onCreate&quot;</span>);\n        <span class=\"hljs-comment\">// 初始化“集合视图”中的数据</span>\n        initListViewData();\n    &#125;\n\n    @Override\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">getCount</span><span class=\"hljs-params\">()</span> </span>&#123;\n        <span class=\"hljs-comment\">// 返回“集合视图”中的数据的总数</span>\n        <span class=\"hljs-keyword\">return</span> mDevices.<span class=\"hljs-built_in\">size</span>();\n    &#125;\n\n    @Override\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">long</span> <span class=\"hljs-title\">getItemId</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> <span class=\"hljs-built_in\">position</span>)</span> </span>&#123;\n        <span class=\"hljs-comment\">// 返回当前项在“集合视图”中的位置</span>\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">position</span>;\n    &#125;\n\n    @Override\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> RemoteViews <span class=\"hljs-title\">getLoadingView</span><span class=\"hljs-params\">()</span> </span>&#123;\n        <span class=\"hljs-keyword\">return</span> null;\n    &#125;\n\n    @Override\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">getViewTypeCount</span><span class=\"hljs-params\">()</span> </span>&#123;\n        <span class=\"hljs-comment\">// 只有一类 ListView</span>\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>;\n    &#125;\n\n    @Override\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">hasStableIds</span><span class=\"hljs-params\">()</span> </span>&#123;\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\n    &#125;\n\n    @Override\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onDataSetChanged</span><span class=\"hljs-params\">()</span> </span>&#123;\n    &#125;\n\n    @Override\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onDestroy</span><span class=\"hljs-params\">()</span> </span>&#123;\n        mDevices.<span class=\"hljs-built_in\">clear</span>();\n    &#125;\n&#125;</code></pre>\n<p>有了RemoteViewsFactory 还需要有RemoteViewsService才能与ListView关联起来。来看RemoteViewsService的实现类ListWidgetService，很简单，只重写了onGetViewFactory方法：</p>\n<pre><code class=\"hljs scala\">public <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ListWidgetService</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">RemoteViewsService</span> </span>&#123;\n\n    <span class=\"hljs-meta\">@Override</span>\n    public <span class=\"hljs-type\">RemoteViewsService</span>.<span class=\"hljs-type\">RemoteViewsFactory</span> onGetViewFactory(<span class=\"hljs-type\">Intent</span> intent) &#123;\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">ListRemoteViewsFactory</span>(<span class=\"hljs-keyword\">this</span>, intent);\n    &#125;\n&#125;</code></pre>\n<p>至此我们可以再次回到ListWidgetProvider中的onUpdate()方法，来看ListWidgetService 是如何与ListView关联到一起的了。</p>\n<pre><code class=\"hljs reasonml\"><span class=\"hljs-comment\">//  设置 “ListView” 的adapter。</span>\n<span class=\"hljs-comment\">// (01) intent: 对应启动 ListWidgetService(RemoteViewsService) 的intent</span>\n<span class=\"hljs-comment\">// (02) setRemoteAdapter: 设置 ListView的适配器</span>\n<span class=\"hljs-comment\">//  通过setRemoteAdapter将ListView和ListWidgetService关联起来，</span>\n<span class=\"hljs-comment\">//  以达到通过 ListWidgetService 更新 ListView 的目的</span>\n Intent serviceIntent = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-constructor\">Intent(<span class=\"hljs-params\">context</span>, ListWidgetService.<span class=\"hljs-params\">class</span>)</span>;\n remoteViews.set<span class=\"hljs-constructor\">RemoteAdapter(R.<span class=\"hljs-params\">id</span>.<span class=\"hljs-params\">lv_device</span>, <span class=\"hljs-params\">serviceIntent</span>)</span>;</code></pre>\n\n<h2 id=\"五-点击事件处理\"><a href=\"#五-点击事件处理\" class=\"headerlink\" title=\"五.点击事件处理\"></a>五.点击事件处理</h2><p>Widget中事件点击以及适配ListView，想必大家都有所了解了。那么对于事件的处理我们还没有提到，例如在Widget中点击了刷新后我们不能像在App中那样给控件设置一个事件监听来在回掉方法中处理。在文章开头我们就提到了Widget是依赖广播来实现，因此我们点击了刷新后其实仅仅是发送出来一个广播。如果我们不去处理广播那么点击事件其实是没有任何意义的。因此，来看ListWidgetProvider中第二个比较重要的方法onReceive()。这个方法比较简单，只要我们对特定的广播来做相应的处理就可以了。</p>\n<pre><code class=\"hljs verilog\">@Override\n    public <span class=\"hljs-keyword\">void</span> onReceive(Context <span class=\"hljs-keyword\">context</span>, Intent intent) &#123;\n        String action = intent<span class=\"hljs-variable\">.getAction</span>();\n        AppWidgetManager appWidgetManager = AppWidgetManager<span class=\"hljs-variable\">.getInstance</span>(<span class=\"hljs-keyword\">context</span>);\n\t        <span class=\"hljs-keyword\">if</span> (action<span class=\"hljs-variable\">.equals</span>(COLLECTION_VIEW_ACTION)) &#123;<span class=\"hljs-comment\">//处理列表中的事件</span>\n            <span class=\"hljs-comment\">// 接受“ListView”的点击事件的广播</span>\n            <span class=\"hljs-keyword\">int</span> <span class=\"hljs-keyword\">type</span> = intent<span class=\"hljs-variable\">.getIntExtra</span>(<span class=\"hljs-string\">&quot;Type&quot;</span>, <span class=\"hljs-number\">0</span>);\n            <span class=\"hljs-keyword\">int</span> appWidgetId = intent<span class=\"hljs-variable\">.getIntExtra</span>(AppWidgetManager<span class=\"hljs-variable\">.EXTRA_APPWIDGET_ID</span>,\n                    AppWidgetManager<span class=\"hljs-variable\">.INVALID_APPWIDGET_ID</span>);\n            <span class=\"hljs-keyword\">int</span> index = intent<span class=\"hljs-variable\">.getIntExtra</span>(COLLECTION_VIEW_EXTRA, <span class=\"hljs-number\">0</span>);\n            switch (<span class=\"hljs-keyword\">type</span>) &#123;\n                <span class=\"hljs-keyword\">case</span> <span class=\"hljs-number\">0</span>:\n                    Toast<span class=\"hljs-variable\">.makeText</span>(<span class=\"hljs-keyword\">context</span>, <span class=\"hljs-string\">&quot;item&quot;</span> + index, Toast<span class=\"hljs-variable\">.LENGTH_SHORT</span>)<span class=\"hljs-variable\">.show</span>();\n                    <span class=\"hljs-keyword\">break</span>;\n                <span class=\"hljs-keyword\">case</span> <span class=\"hljs-number\">1</span>:\n                    Toast<span class=\"hljs-variable\">.makeText</span>(<span class=\"hljs-keyword\">context</span>, <span class=\"hljs-string\">&quot;lock&quot;</span>+index, Toast<span class=\"hljs-variable\">.LENGTH_SHORT</span>)<span class=\"hljs-variable\">.show</span>();\n                    <span class=\"hljs-keyword\">break</span>;\n                <span class=\"hljs-keyword\">case</span> <span class=\"hljs-number\">2</span>:\n                    Toast<span class=\"hljs-variable\">.makeText</span>(<span class=\"hljs-keyword\">context</span>, <span class=\"hljs-string\">&quot;unlock&quot;</span>+index, Toast<span class=\"hljs-variable\">.LENGTH_SHORT</span>)<span class=\"hljs-variable\">.show</span>();\n                    <span class=\"hljs-keyword\">break</span>;\n            &#125;\n        &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (action<span class=\"hljs-variable\">.equals</span>(REFRESH_WIDGET)) &#123;<span class=\"hljs-comment\">//处理刷新事件</span>\n            <span class=\"hljs-comment\">// 接受“bt_refresh”的点击事件的广播</span>\n            Toast<span class=\"hljs-variable\">.makeText</span>(<span class=\"hljs-keyword\">context</span>, <span class=\"hljs-string\">&quot;刷新...&quot;</span>, Toast<span class=\"hljs-variable\">.LENGTH_SHORT</span>)<span class=\"hljs-variable\">.show</span>();\n            <span class=\"hljs-keyword\">final</span> AppWidgetManager mgr = AppWidgetManager<span class=\"hljs-variable\">.getInstance</span>(<span class=\"hljs-keyword\">context</span>);\n            <span class=\"hljs-keyword\">final</span> ComponentName cn = <span class=\"hljs-keyword\">new</span> ComponentName(<span class=\"hljs-keyword\">context</span>,ListWidgetProvider<span class=\"hljs-variable\">.class</span>);\n            ListRemoteViewsFactory<span class=\"hljs-variable\">.refresh</span>();\n            mgr<span class=\"hljs-variable\">.notifyAppWidgetViewDataChanged</span>(mgr<span class=\"hljs-variable\">.getAppWidgetIds</span>(cn),R<span class=\"hljs-variable\">.id</span><span class=\"hljs-variable\">.lv_device</span>);\n            mHandler<span class=\"hljs-variable\">.postDelayed</span>(runnable,<span class=\"hljs-number\">2000</span>);\n            showLoading(<span class=\"hljs-keyword\">context</span>);\n        &#125;\n        <span class=\"hljs-keyword\">super</span><span class=\"hljs-variable\">.onReceive</span>(<span class=\"hljs-keyword\">context</span>, intent);\n    &#125;</code></pre>\n<p>最后，别忘了ListWidgetProvider是广播，ListWidgetService是服务，都需要我们在AndroidManifest文件中来注册：</p>\n<pre><code class=\"hljs xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">receiver</span> <span class=\"hljs-attr\">android:name</span>=<span class=\"hljs-string\">&quot;.widget.ListWidgetProvider&quot;</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">intent-filter</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">action</span> <span class=\"hljs-attr\">android:name</span>=<span class=\"hljs-string\">&quot;android.appwidget.action.APPWIDGET_UPDATE&quot;</span> /&gt;</span>\n\n            <span class=\"hljs-comment\">&lt;!-- ListWidgetProvider接收点击ListView的响应事件 --&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">action</span> <span class=\"hljs-attr\">android:name</span>=<span class=\"hljs-string\">&quot;com.oitsme.COLLECTION_VIEW_ACTION&quot;</span> /&gt;</span>\n            <span class=\"hljs-comment\">&lt;!-- ListWidgetProvider接收点击bt_refresh的响应事件 --&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">action</span> <span class=\"hljs-attr\">android:name</span>=<span class=\"hljs-string\">&quot;com.oitsme.REFRESH_WIDGET&quot;</span> /&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">action</span> <span class=\"hljs-attr\">android:name</span>=<span class=\"hljs-string\">&quot;com.oitsme.LOCK_ACTION&quot;</span>/&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">action</span> <span class=\"hljs-attr\">android:name</span>=<span class=\"hljs-string\">&quot;com.oitsme.UNLOCK_ACTION&quot;</span>/&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">intent-filter</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta-data</span> <span class=\"hljs-attr\">android:name</span>=<span class=\"hljs-string\">&quot;android.appwidget.provider&quot;</span></span>\n<span class=\"hljs-tag\">            <span class=\"hljs-attr\">android:resource</span>=<span class=\"hljs-string\">&quot;@xml/widget_provider&quot;</span>/&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">receiver</span>&gt;</span>\n\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">service</span></span>\n<span class=\"hljs-tag\">        <span class=\"hljs-attr\">android:name</span>=<span class=\"hljs-string\">&quot;.widget.ListWidgetService&quot;</span></span>\n<span class=\"hljs-tag\">        <span class=\"hljs-attr\">android:permission</span>=<span class=\"hljs-string\">&quot;android.permission.BIND_REMOTEVIEWS&quot;</span> /&gt;</span></code></pre>\n\n<h2 id=\"六-小结\"><a href=\"#六-小结\" class=\"headerlink\" title=\"六.小结\"></a>六.小结</h2><p>至此关于列表小部件的讲解就完成了。只是自我感觉文章的逻辑有点乱。如果没明白，大家可以参考下面Demo源码。其实关于Widget的这个Demo其实早在几个月前就已经写好了，但由于最近项目紧再加上本身也是第一次接触Widget控件，因此直至近日才开始动笔写这篇文章。所以文章中避免不了有错误和不合理的地方，欢迎留言指正。</p>\n<p>参考<br><a href=\"https://developer.android.com/guide/topics/appwidgets/\">https://developer.android.com/guide/topics/appwidgets/</a></p>\n<p><a href=\"https://download.csdn.net/download/qq_20521573/11659588\">源码下载</a></p>\n","site":{"data":{"fluid_config":{"favicon":"/img/favicon.png","apple_touch_icon":"/img/favicon.png","title_join_string":" - ","force_https":false,"highlight":{"enable":true,"style":"Github Gist","bg_color":false,"copy_btn":true},"fun_features":{"typing":{"enable":true,"typeSpeed":70,"cursorChar":"|","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"mouse_click":{"enable":false,"style":"values"}},"dark_mode":{"enable":true,"default":"auto"},"color":{"body_bg_color":"#eee","body_bg_color_dark":"#181c27","navbar_bg_color":"#2f4154","navbar_bg_color_dark":"#1f3144","navbar_text_color":"#fff","navbar_text_color_dark":"#d0d0d0","text_color":"#3c4858","text_color_dark":"#c4c6c9","sec_text_color":"#718096","sec_text_color_dark":"#a7a9ad","post_text_color":"#2c3e50","post_text_color_dark":"#c4c6c9","post_heading_color":"#1a202c","post_heading_color_dark":"#c4c6c9","post_link_color":"#0366d6","post_link_color_dark":"#1589e9","link_hover_color":"#30a9de","link_hover_color_dark":"#30a9de","link_hover_bg_color":"#f8f9fa","link_hover_bg_color_dark":"#364151","board_color":"#fff","board_color_dark":"#252d38"},"font":{"font_size":"16px","font_family":null,"code_font_size":"85%"},"custom_js":null,"custom_css":null,"custom_html":"","web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"tajs":null,"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}},"lazyload":{"enable":true,"onlypost":false},"daovoice":{"enable":false,"appid":""},"aplayer":{"enable":false,"autoplay":false,"loop":"all","order":"random","theme":"#b7daff","songs":[{"name":"name","artist":"artist","url":"/songs/test.mp3","cover":"/img/cover.jpg"},{"name":"name","artist":"artist","url":"https://...url.mp3","cover":"https://...cover.jpg"}]},"version":{"check":false},"navbar":{"blog_title":"zhangpan","ground_glass":{"enable":false,"px":3,"alpha":0.7},"menu":[{"key":"home","link":"/","icon":"iconfont icon-home-fill"},{"key":"archive","link":"/archives/","icon":"iconfont icon-archive-fill"},{"key":"category","link":"/categories/","icon":"iconfont icon-category-fill"},{"key":"tag","link":"/tags/","icon":"iconfont icon-tags-fill"},{"key":"about","link":"/about/","icon":"iconfont icon-user-fill"}]},"search":{"enable":true,"path":"/local-search.xml","generate_path":"/local-search.xml","field":"post","content":true},"scroll_down_arrow":{"enable":true,"banner_height_limit":90,"scroll_after_turning_page":true},"banner_parallax":true,"footer":{"statistics":{"enable":false,"source":"busuanzi","pv_format":"总访问量 {} 次","uv_format":"总访客数 {} 人"},"beian":{"enable":false,"icp_text":"京ICP证123456号","police_text":"京公网安备12345678号","police_code":12345678,"police_icon":"/img/police_beian.png"}},"scroll_top_arrow":{"enable":true},"index":{"banner_img":"/img/default.png","banner_img_height":100,"banner_mask_alpha":0.3,"post_default_img":"","slogan":{"enable":true,"text":"Talk is cheap, show me the code."},"auto_excerpt":{"enable":true},"post_url_target":"_self","post_meta":{"date":true,"category":true,"tag":true}},"page":{"banner_img":"/img/default.png","banner_img_height":60,"banner_mask_alpha":0.3},"post":{"banner_img":"/img/default.png","banner_img_height":70,"banner_mask_alpha":0.3,"meta":{"date":{"enable":true,"format":"LL a"},"wordcount":{"enable":true,"format":"{} 字"},"min2read":{"enable":true,"format":"{} 分钟","words":100},"views":{"enable":false,"source":"busuanzi","format":"{} 次"}},"updated":{"enable":false,"content":"本文最后更新于：","relative":false},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"copyright":{"enable":true,"content":"本博客所有文章除特别声明外，均采用 <a href=\"https://creativecommons.org/licenses/by-sa/4.0/deed.zh\" rel=\"nofollow noopener\">CC BY-SA 4.0 协议</a> ，转载请注明出处！ <h5>开源库推荐</h5> <a href=\"https://github.com/zhpanvip/BannerViewPager\">1.BannerViewPager</a> <p> 一个基于ViewPager2实现的具有强大功能的无限轮播库。支持多种页面切换效果和指示器样式。 </p>\n<a href=\"https://github.com/zhpanvip/viewpagerindicator\">2.ViewPagerIndicator</a> <p> 一个适用于ViewPager和ViewPager2的指示器，支持多种滑块样式及滑动模式 </p>"},"prev_next":{"enable":true},"custom":{"enable":false,"content":"<img src=\"https://octodex.github.com/images/jetpacktocat.png\" class=\"rounded mx-auto d-block mt-5\" style=\"width:150px; height:150px;\">"},"image_zoom":{"enable":true},"footnote":{"enable":true,"header":""},"math":{"enable":false,"specific":false,"engine":"mathjax"},"mermaid":{"enable":false,"specific":false,"options":{"theme":"default"}},"comments":{"enable":true,"type":"utterances"}},"utterances":{"repo":"zhpanvip/utterances-comment","issue_term":"pathname","label":"utterances","theme":"github-light","crossorigin":"anonymous"},"disqus":{"shortname":null,"disqusjs":false,"apikey":null},"gitalk":{"clientID":null,"clientSecret":null,"repo":null,"owner":null,"admin":["name"],"id":"location.pathname","language":"zh-CN","labels":["Gitalk"],"perPage":10,"pagerDirection":"last","distractionFreeMode":false,"createIssueManually":true},"valine":{"appid":"hXIROaIM5y9qnieojJRWP5hS","appkey":"y0f3w3aqd1MF7JL9ma4WECTy","placeholder":"说点什么","path":"window.location.pathname","avatar":"retro","meta":["nick","mail","link"],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"https://zhangpan.site"},"changyan":{"appid":"","appkey":""},"livere":{"uid":""},"archive":{"banner_img":"/img/bg_article.jpg","banner_img_height":60,"banner_mask_alpha":0.3,"subtitle":null},"category":{"banner_img":"/img/bg_default.png","banner_img_height":60,"banner_mask_alpha":0.3,"subtitle":null,"post_limit":10,"order_by":"-length"},"tag":{"banner_img":"/img/bg_label.jpg","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null,"tagcloud":{"min_font":15,"max_font":30,"unit":"px","start_color":"#BBBBEE","end_color":"#337ab7"}},"about":{"banner_img":"/img/bg_default.png","banner_img_height":60,"banner_mask_alpha":0.3,"subtitle":null,"avatar":"/img/avatar.png","name":"myname","introduce":"一句简短的介绍","icons":[{"class":"iconfont icon-github-fill","link":"https://github.com","tip":"GitHub"},{"class":"iconfont icon-douban-fill","link":"https://douban.com","tip":"豆瓣"},{"class":"iconfont icon-wechat-fill","qrcode":"/img/favicon.png"}]},"page404":{"banner_img":"/img/default.png","banner_img_height":85,"banner_mask_alpha":0.3,"subtitle":"Page not found"},"links":{"banner_img":"/img/default.png","banner_img_height":60,"banner_mask_alpha":0.3,"subtitle":null,"items":[{"title":"Fluid Docs","intro":"主题使用指南","link":"https://hexo.fluid-dev.com/docs/","image":"/img/favicon.png"},{"title":"Fluid Repo","intro":"主题 GitHub 仓库","link":"https://github.com/fluid-dev/hexo-theme-fluid","image":"/img/favicon.png"},{"title":"Fluid Example","intro":"主题操作示例","link":"https://hexo.fluid-dev.com/docs/example/","image":"/img/favicon.png"}]}}}},"excerpt":"","more":"<p>好久没博客更新了，本篇文章来学习一下如何实现一个Android列表小部件，效果可以参看下图：<br><img src=\"https://raw.githubusercontent.com/zhpanvip/Resource/master/image/1303.gif\"></p>\n<p>这个页面如果是在App内部实现，相信只要有一点Android基础的童鞋都能很轻松写出来。但是如果放到Widget中可能就不是那么简单了。因为Widget并没有运行在我们App的进程中，而是运行在系统的SystemServer进程中。你可能会惊讶，Whf！竟然不在我们App进程中！那么是不是意味着我们也不能像在App中那样操作View控件了？答案确实如此。不过不必过于担心，为了我们能在远程进程中更新界面，Google爸爸专门为我们提供了一个RemoteViews类。从名字上看，可能会觉得RemoteViews就是一个View。但事实并非如此，RemoteViews仅仅表示的是一个View结构。它可以在远程进程中展示和更新界面。今天我们要实现的列表小部件就是基于RemoteVeiw实现的。<br>那么接下来我们来学习如何实现一个桌面Widget，我们先列出要实现Widget的几个核心步骤：</p>\n<ul>\n<li>widget页面布局  </li>\n<li>小部件配置信息 </li>\n<li>了解AppWidgetProvider</li>\n<li>RemoteViewsFactory实现列表适配</li>\n<li>点击的事件处理</li>\n</ul>\n<h2 id=\"一-实现Widget界面\"><a href=\"#一-实现Widget界面\" class=\"headerlink\" title=\"一. 实现Widget界面\"></a>一. 实现Widget界面</h2><p><strong>1.widget页面布局。</strong>首先创建一个布局文件layout_widget.xml，内容如下：</p>\n<pre><code class=\"hljs xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">LinearLayout</span> <span class=\"hljs-attr\">xmlns:android</span>=<span class=\"hljs-string\">&quot;http://schemas.android.com/apk/res/android&quot;</span></span>\n<span class=\"hljs-tag\">    <span class=\"hljs-attr\">android:id</span>=<span class=\"hljs-string\">&quot;@+id/ll_right&quot;</span></span>\n<span class=\"hljs-tag\">    <span class=\"hljs-attr\">android:layout_width</span>=<span class=\"hljs-string\">&quot;match_parent&quot;</span></span>\n<span class=\"hljs-tag\">    <span class=\"hljs-attr\">android:layout_height</span>=<span class=\"hljs-string\">&quot;wrap_content&quot;</span></span>\n<span class=\"hljs-tag\">    <span class=\"hljs-attr\">android:background</span>=<span class=\"hljs-string\">&quot;@drawable/bg_widget&quot;</span></span>\n<span class=\"hljs-tag\">    <span class=\"hljs-attr\">android:orientation</span>=<span class=\"hljs-string\">&quot;vertical&quot;</span>&gt;</span>\n\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">RelativeLayout</span></span>\n<span class=\"hljs-tag\">        <span class=\"hljs-attr\">android:layout_width</span>=<span class=\"hljs-string\">&quot;match_parent&quot;</span></span>\n<span class=\"hljs-tag\">        <span class=\"hljs-attr\">android:layout_height</span>=<span class=\"hljs-string\">&quot;40dp&quot;</span></span>\n<span class=\"hljs-tag\">        <span class=\"hljs-attr\">android:background</span>=<span class=\"hljs-string\">&quot;#ccc&quot;</span>&gt;</span>\n\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ImageView</span></span>\n<span class=\"hljs-tag\">            <span class=\"hljs-attr\">android:id</span>=<span class=\"hljs-string\">&quot;@+id/iv_icon&quot;</span></span>\n<span class=\"hljs-tag\">            <span class=\"hljs-attr\">android:layout_width</span>=<span class=\"hljs-string\">&quot;30dp&quot;</span></span>\n<span class=\"hljs-tag\">            <span class=\"hljs-attr\">android:layout_height</span>=<span class=\"hljs-string\">&quot;30dp&quot;</span></span>\n<span class=\"hljs-tag\">            <span class=\"hljs-attr\">android:layout_centerVertical</span>=<span class=\"hljs-string\">&quot;true&quot;</span></span>\n<span class=\"hljs-tag\">            <span class=\"hljs-attr\">android:layout_marginEnd</span>=<span class=\"hljs-string\">&quot;5dp&quot;</span></span>\n<span class=\"hljs-tag\">            <span class=\"hljs-attr\">android:layout_marginStart</span>=<span class=\"hljs-string\">&quot;5dp&quot;</span></span>\n<span class=\"hljs-tag\">            <span class=\"hljs-attr\">android:background</span>=<span class=\"hljs-string\">&quot;@mipmap/ic_launcher_round&quot;</span> /&gt;</span>\n\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">TextView</span></span>\n<span class=\"hljs-tag\">            <span class=\"hljs-attr\">android:id</span>=<span class=\"hljs-string\">&quot;@+id/tv_title&quot;</span></span>\n<span class=\"hljs-tag\">            <span class=\"hljs-attr\">android:layout_width</span>=<span class=\"hljs-string\">&quot;wrap_content&quot;</span></span>\n<span class=\"hljs-tag\">            <span class=\"hljs-attr\">android:layout_height</span>=<span class=\"hljs-string\">&quot;wrap_content&quot;</span></span>\n<span class=\"hljs-tag\">            <span class=\"hljs-attr\">android:layout_centerVertical</span>=<span class=\"hljs-string\">&quot;true&quot;</span></span>\n<span class=\"hljs-tag\">            <span class=\"hljs-attr\">android:layout_toEndOf</span>=<span class=\"hljs-string\">&quot;@id/iv_icon&quot;</span></span>\n<span class=\"hljs-tag\">            <span class=\"hljs-attr\">android:text</span>=<span class=\"hljs-string\">&quot;Widget&quot;</span> /&gt;</span>\n\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">LinearLayout</span></span>\n<span class=\"hljs-tag\">            <span class=\"hljs-attr\">android:layout_width</span>=<span class=\"hljs-string\">&quot;wrap_content&quot;</span></span>\n<span class=\"hljs-tag\">            <span class=\"hljs-attr\">android:layout_height</span>=<span class=\"hljs-string\">&quot;match_parent&quot;</span></span>\n<span class=\"hljs-tag\">            <span class=\"hljs-attr\">android:layout_alignParentEnd</span>=<span class=\"hljs-string\">&quot;true&quot;</span></span>\n<span class=\"hljs-tag\">            <span class=\"hljs-attr\">android:gravity</span>=<span class=\"hljs-string\">&quot;center_vertical&quot;</span></span>\n<span class=\"hljs-tag\">            <span class=\"hljs-attr\">android:orientation</span>=<span class=\"hljs-string\">&quot;horizontal&quot;</span>&gt;</span>\n\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ProgressBar</span></span>\n<span class=\"hljs-tag\">                <span class=\"hljs-attr\">android:id</span>=<span class=\"hljs-string\">&quot;@+id/progress_bar&quot;</span></span>\n<span class=\"hljs-tag\">                <span class=\"hljs-attr\">android:layout_width</span>=<span class=\"hljs-string\">&quot;20dp&quot;</span></span>\n<span class=\"hljs-tag\">                <span class=\"hljs-attr\">android:layout_height</span>=<span class=\"hljs-string\">&quot;20dp&quot;</span></span>\n<span class=\"hljs-tag\">                <span class=\"hljs-attr\">android:indeterminateTint</span>=<span class=\"hljs-string\">&quot;@color/colorAccent&quot;</span></span>\n<span class=\"hljs-tag\">                <span class=\"hljs-attr\">android:indeterminateTintMode</span>=<span class=\"hljs-string\">&quot;src_atop&quot;</span></span>\n<span class=\"hljs-tag\">                <span class=\"hljs-attr\">android:visibility</span>=<span class=\"hljs-string\">&quot;gone&quot;</span> /&gt;</span>\n\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">TextView</span></span>\n<span class=\"hljs-tag\">                <span class=\"hljs-attr\">android:id</span>=<span class=\"hljs-string\">&quot;@+id/tv_refresh&quot;</span></span>\n<span class=\"hljs-tag\">                <span class=\"hljs-attr\">android:layout_width</span>=<span class=\"hljs-string\">&quot;wrap_content&quot;</span></span>\n<span class=\"hljs-tag\">                <span class=\"hljs-attr\">android:layout_height</span>=<span class=\"hljs-string\">&quot;wrap_content&quot;</span></span>\n<span class=\"hljs-tag\">                <span class=\"hljs-attr\">android:layout_marginEnd</span>=<span class=\"hljs-string\">&quot;15dp&quot;</span></span>\n<span class=\"hljs-tag\">                <span class=\"hljs-attr\">android:text</span>=<span class=\"hljs-string\">&quot;刷新&quot;</span></span>\n<span class=\"hljs-tag\">                <span class=\"hljs-attr\">android:padding</span>=<span class=\"hljs-string\">&quot;5dp&quot;</span></span>\n<span class=\"hljs-tag\">                <span class=\"hljs-attr\">android:textSize</span>=<span class=\"hljs-string\">&quot;12sp&quot;</span> /&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">LinearLayout</span>&gt;</span>\n\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">RelativeLayout</span>&gt;</span>\n\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ListView</span></span>\n<span class=\"hljs-tag\">        <span class=\"hljs-attr\">android:id</span>=<span class=\"hljs-string\">&quot;@+id/lv_device&quot;</span></span>\n<span class=\"hljs-tag\">        <span class=\"hljs-attr\">android:layout_width</span>=<span class=\"hljs-string\">&quot;match_parent&quot;</span></span>\n<span class=\"hljs-tag\">        <span class=\"hljs-attr\">android:layout_height</span>=<span class=\"hljs-string\">&quot;match_parent&quot;</span></span>\n<span class=\"hljs-tag\">        <span class=\"hljs-attr\">android:columnWidth</span>=<span class=\"hljs-string\">&quot;80dip&quot;</span></span>\n<span class=\"hljs-tag\">        <span class=\"hljs-attr\">android:gravity</span>=<span class=\"hljs-string\">&quot;center&quot;</span></span>\n<span class=\"hljs-tag\">        <span class=\"hljs-attr\">android:horizontalSpacing</span>=<span class=\"hljs-string\">&quot;4dip&quot;</span></span>\n<span class=\"hljs-tag\">        <span class=\"hljs-attr\">android:numColumns</span>=<span class=\"hljs-string\">&quot;auto_fit&quot;</span></span>\n<span class=\"hljs-tag\">        <span class=\"hljs-attr\">android:verticalSpacing</span>=<span class=\"hljs-string\">&quot;4dip&quot;</span> /&gt;</span>\n\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">LinearLayout</span>&gt;</span></code></pre>\n<p>看到布局中的ListView控件，你可能会不屑一笑，都什么年代了还在用ListView？RecyclerView才是王道吧？可是我只能说句抱歉，Widget不支持RecyclerView。对，你没看错，真的不支持。在Widget中我们没办法做到想用什么就用什么，甚至觉得原生用着不爽，自己撸一个控件出来。对不起，Widget都不支持。因此Widget也有很大的局限性。我们来看下支持在Widget中运行的有哪些控件：</p>\n<blockquote>\n<p>A RemoteViews object (and, consequently, an App Widget) can support the following layout classes:<br>FrameLayout<br>LinearLayout<br>RelativeLayout<br>GridLayout<br>And the following widget classes:<br>AnalogClock<br>Button<br>Chronometer<br>ImageButton<br>ImageView<br>ProgressBar<br>TextView<br>ViewFlipper<br>ListView<br>GridView<br>StackView<br>AdapterViewFlipper<br>Descendants of these classes are not supported.</p>\n</blockquote>\n<p>除了上述列出的几个View，其它的包括Android原生View和自定义View是都不支持在Widget中运行的。因此基于Widget页面限制我们基本就可以告别炫酷的动画效果了。</p>\n<h2 id=\"二-小部件配置信息\"><a href=\"#二-小部件配置信息\" class=\"headerlink\" title=\"二.小部件配置信息\"></a>二.小部件配置信息</h2><p>配置信息主要是设定小部件的一些属性，比如宽高、缩放模式、更新时间间隔等。我们需要在res/xml目录下新建widget_provider.xml文件，文件名字可以任意取。文件内容如下（可做参考）：</p>\n<pre><code class=\"hljs xml\"><span class=\"hljs-meta\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">appwidget-provider</span> <span class=\"hljs-attr\">xmlns:android</span>=<span class=\"hljs-string\">&quot;http://schemas.android.com/apk/res/android&quot;</span></span>\n<span class=\"hljs-tag\">    <span class=\"hljs-attr\">android:minHeight</span>=<span class=\"hljs-string\">&quot;180dp&quot;</span></span>\n<span class=\"hljs-tag\">    <span class=\"hljs-attr\">android:minWidth</span>=<span class=\"hljs-string\">&quot;300dp&quot;</span></span>\n<span class=\"hljs-tag\">    <span class=\"hljs-attr\">android:previewImage</span>=<span class=\"hljs-string\">&quot;@drawable/ic_launcher_background&quot;</span></span>\n<span class=\"hljs-tag\">    <span class=\"hljs-attr\">android:initialLayout</span>=<span class=\"hljs-string\">&quot;@layout/layout_widget&quot;</span></span>\n<span class=\"hljs-tag\">    <span class=\"hljs-attr\">android:updatePeriodMillis</span>=<span class=\"hljs-string\">&quot;50000&quot;</span></span>\n<span class=\"hljs-tag\">    <span class=\"hljs-attr\">android:resizeMode</span>=<span class=\"hljs-string\">&quot;horizontal|vertical&quot;</span></span>\n<span class=\"hljs-tag\">    <span class=\"hljs-attr\">android:widgetCategory</span>=<span class=\"hljs-string\">&quot;home_screen&quot;</span>&gt;</span> \n    \n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">appwidget-provider</span>&gt;</span></code></pre>\n<p>针对上述文件中的配置信息来做下介绍。</p>\n<ul>\n<li><strong><em>minHeight、minWidth</em></strong> 定义Widget的最小高度和最小宽度（Widget可以通过拉伸来调整尺寸大小）。</li>\n<li><strong><em>previewImage</em></strong> 定义添加小部件时显示的图标。</li>\n<li><strong><em>initialLayout</em></strong> 定义了小部件使用的布局。</li>\n<li><strong><em>updatePeriodMillis</em></strong>定义小部件自动更新的周期，单位为毫秒。</li>\n<li><strong><em>resizeMode</em></strong> 指定了 widget 的调整尺寸的规则。可取的值有: “horizontal”, “vertical”, “none”。”horizontal”意味着widget可以水平拉伸，“vertical”意味着widget可以竖值拉伸，“none”意味着widget不能拉伸；默认值是”none”。</li>\n<li><strong><em>widgetCategory</em></strong> 指定了 widget 能显示的地方：能否显示在 home Screen 或 lock screen 或 两者都可以。它的取值包括：”home_screen” 和 “keyguard”。Android 4.2 引入。<br>最后，需要我们在AndroidManifest中注册AppWidgetProvider时引用该文件，使用如下：</li>\n</ul>\n<pre><code class=\"hljs xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">receiver</span> <span class=\"hljs-attr\">android:name</span>=<span class=\"hljs-string\">&quot;.widget.ListWidgetProvider&quot;</span>&gt;</span>\n     ...\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta-data</span></span>\n<span class=\"hljs-tag\">        <span class=\"hljs-attr\">android:name</span>=<span class=\"hljs-string\">&quot;android.appwidget.provider&quot;</span></span>\n<span class=\"hljs-tag\">        <span class=\"hljs-attr\">android:resource</span>=<span class=\"hljs-string\">&quot;@xml/widget_provider&quot;</span> /&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">receiver</span>&gt;</span></code></pre>\n\n<h2 id=\"三-了解AppWidgetProvider类\"><a href=\"#三-了解AppWidgetProvider类\" class=\"headerlink\" title=\"三.了解AppWidgetProvider类\"></a>三.了解AppWidgetProvider类</h2><p>我们来简单了解下AppWidgetProvider这个类。Widget的功能均是通过AppWidgetProvider来实现的。我们跟进源码可以发现它是继承自BroadcastReceiver类，也就是一个广播接收者。上面我们提到过RemoteViews是运行在SystemServer进程中的，再结合此处我们应该可以推测小部件的事件应该是通过广播来实现的。像小部件的添加、删除、更新、启用、禁用等均是在AppWidgetProvider中通过接受广播来完成的。看AppWidgetProvider中的几个方法：</p>\n<ul>\n<li>onUpdate() 当Widget被添加或者被更新时会调用该方法。上边我们提到通过配置updatePeriodMillis可以定期更新Widget。但是当我们在widget的配置文件中声明了android:configure的时候，添加Widget时则不会调用onUpdate方法。</li>\n<li>onEnable() 这个方法会在用户首次添加Widget时调用。</li>\n<li>onAppWidgetOptionsChanged() 这个方法会在添加Widget或者改变Widget的大小时候被调用。在这个方法中我们还可以根据Widget的大小来选择性的显示或隐藏某些控件。</li>\n<li>onDeleted(Context, int[]) 当控件被删除的时候调用该方法</li>\n<li>onEnabled(Context) 当第一个Widget被添加的时候调用。如果用户添加了两个这个小部件，那么只有第一个添加时才会调用onEnabled.</li>\n<li>onDisabled(Context) 当最后一个Widget实例被移除的时候调用这个方法。在这个方法中我们可以做一些清除工作，例如删掉临时的数据库等。</li>\n<li>onReceive(Context, Intent) 当接收到广播的时候会被调用。</li>\n</ul>\n<p>上述方法中，我们需要着重关心一下onUpdate()方法和onReceive()方法。因为onUpdate()方法会在Widget被添加时候调用，我们可以在此时为Widget添加一View的些交互事件，例如点击事件。由于本篇我们要实现的是一个列表小部件。因此我们还需要RemoteViewsFactory这个类来适配列表数据。</p>\n<p>先来看下ListWidgetProvider这个类中的代码：</p>\n<pre><code class=\"hljs arduino\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ListWidgetProvider</span> <span class=\"hljs-title\">extends</span> <span class=\"hljs-title\">AppWidgetProvider</span> &#123;</span>\n\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">String</span> TAG = <span class=\"hljs-string\">&quot;WIDGET&quot;</span>;\n\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">String</span> REFRESH_WIDGET = <span class=\"hljs-string\">&quot;com.oitsme.REFRESH_WIDGET&quot;</span>;\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">String</span> COLLECTION_VIEW_ACTION = <span class=\"hljs-string\">&quot;com.oitsme.COLLECTION_VIEW_ACTION&quot;</span>;\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">String</span> COLLECTION_VIEW_EXTRA = <span class=\"hljs-string\">&quot;com.oitsme.COLLECTION_VIEW_EXTRA&quot;</span>;\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> Handler mHandler=<span class=\"hljs-keyword\">new</span> Handler();\n    <span class=\"hljs-keyword\">private</span> Runnable runnable=<span class=\"hljs-keyword\">new</span> Runnable() &#123;\n        @Override\n        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-built_in\">run</span>() &#123;\n            hideLoading(Utils.getContext());\n            Toast.makeText(Utils.getContext(), <span class=\"hljs-string\">&quot;刷新成功&quot;</span>, Toast.LENGTH_SHORT).show();\n        &#125;\n    &#125;;\n\n    @Override\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onUpdate</span><span class=\"hljs-params\">(Context context, AppWidgetManager appWidgetManager,</span></span>\n<span class=\"hljs-function\"><span class=\"hljs-params\">                         <span class=\"hljs-keyword\">int</span>[] appWidgetIds)</span> </span>&#123;\n\n        Log.d(TAG, <span class=\"hljs-string\">&quot;ListWidgetProvider onUpdate&quot;</span>);\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> appWidgetId : appWidgetIds) &#123;\n            <span class=\"hljs-comment\">// 获取AppWidget对应的视图</span>\n            RemoteViews remoteViews = <span class=\"hljs-keyword\">new</span> RemoteViews(context.getPackageName(), R.layout.layout_widget);\n\n            <span class=\"hljs-comment\">// 设置响应 “按钮(bt_refresh)” 的intent</span>\n            Intent btIntent = <span class=\"hljs-keyword\">new</span> Intent().setAction(REFRESH_WIDGET);\n            PendingIntent btPendingIntent = PendingIntent.getBroadcast(context, <span class=\"hljs-number\">0</span>, btIntent, PendingIntent.FLAG_UPDATE_CURRENT);\n            remoteViews.setOnClickPendingIntent(R.id.tv_refresh, btPendingIntent);\n\n            <span class=\"hljs-comment\">// 设置 “ListView” 的adapter。</span>\n            <span class=\"hljs-comment\">// (01) intent: 对应启动 ListWidgetService(RemoteViewsService) 的intent</span>\n            <span class=\"hljs-comment\">// (02) setRemoteAdapter: 设置 gridview的适配器</span>\n            <span class=\"hljs-comment\">//    通过setRemoteAdapter将ListView和ListWidgetService关联起来，</span>\n            <span class=\"hljs-comment\">//    以达到通过 ListWidgetService 更新 ListView的目的</span>\n            Intent serviceIntent = <span class=\"hljs-keyword\">new</span> Intent(context, ListWidgetService.class);\n            remoteViews.setRemoteAdapter(R.id.lv_device, serviceIntent);\n\n\n            <span class=\"hljs-comment\">// 设置响应 “ListView” 的intent模板</span>\n            <span class=\"hljs-comment\">// 说明：“集合控件(如GridView、ListView、StackView等)”中包含很多子元素，如GridView包含很多格子。</span>\n            <span class=\"hljs-comment\">//     它们不能像普通的按钮一样通过 setOnClickPendingIntent 设置点击事件，必须先通过两步。</span>\n            <span class=\"hljs-comment\">//        (01) 通过 setPendingIntentTemplate 设置 “intent模板”，这是比不可少的！</span>\n            <span class=\"hljs-comment\">//        (02) 然后在处理该“集合控件”的RemoteViewsFactory类的getViewAt()接口中 通过 setOnClickFillInIntent 设置“集合控件的某一项的数据”</span>\n            Intent gridIntent = <span class=\"hljs-keyword\">new</span> Intent();\n\n            gridIntent.setAction(COLLECTION_VIEW_ACTION);\n            gridIntent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, appWidgetId);\n            PendingIntent pendingIntent = PendingIntent.getBroadcast(context, <span class=\"hljs-number\">0</span>, gridIntent, PendingIntent.FLAG_UPDATE_CURRENT);\n            <span class=\"hljs-comment\">// 设置intent模板</span>\n            remoteViews.setPendingIntentTemplate(R.id.lv_device, pendingIntent);\n            <span class=\"hljs-comment\">// 调用集合管理器对集合进行更新</span>\n            appWidgetManager.updateAppWidget(appWidgetId, remoteViews);\n        &#125;\n        super.onUpdate(context, appWidgetManager, appWidgetIds);\n    &#125;\n\n\n    @Override\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onReceive</span><span class=\"hljs-params\">(Context context, Intent intent)</span> </span>&#123;\n        <span class=\"hljs-keyword\">String</span> action = intent.getAction();\n        AppWidgetManager appWidgetManager = AppWidgetManager.getInstance(context);\n        <span class=\"hljs-keyword\">if</span> (action.equals(COLLECTION_VIEW_ACTION)) &#123;\n            <span class=\"hljs-comment\">// 接受“ListView”的点击事件的广播</span>\n            <span class=\"hljs-keyword\">int</span> type = intent.getIntExtra(<span class=\"hljs-string\">&quot;Type&quot;</span>, <span class=\"hljs-number\">0</span>);\n            <span class=\"hljs-keyword\">int</span> appWidgetId = intent.getIntExtra(AppWidgetManager.EXTRA_APPWIDGET_ID,\n                    AppWidgetManager.INVALID_APPWIDGET_ID);\n            <span class=\"hljs-keyword\">int</span> index = intent.getIntExtra(COLLECTION_VIEW_EXTRA, <span class=\"hljs-number\">0</span>);\n            <span class=\"hljs-keyword\">switch</span> (type) &#123;\n                <span class=\"hljs-keyword\">case</span> <span class=\"hljs-number\">0</span>:\n                    Toast.makeText(context, <span class=\"hljs-string\">&quot;item&quot;</span> + index, Toast.LENGTH_SHORT).show();\n                    <span class=\"hljs-keyword\">break</span>;\n                <span class=\"hljs-keyword\">case</span> <span class=\"hljs-number\">1</span>:\n                    Toast.makeText(context, <span class=\"hljs-string\">&quot;lock&quot;</span>+index, Toast.LENGTH_SHORT).show();\n                    <span class=\"hljs-keyword\">break</span>;\n                <span class=\"hljs-keyword\">case</span> <span class=\"hljs-number\">2</span>:\n                    Toast.makeText(context, <span class=\"hljs-string\">&quot;unlock&quot;</span>+index, Toast.LENGTH_SHORT).show();\n                    <span class=\"hljs-keyword\">break</span>;\n            &#125;\n        &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (action.equals(REFRESH_WIDGET)) &#123;\n            <span class=\"hljs-comment\">// 接受“bt_refresh”的点击事件的广播</span>\n            Toast.makeText(context, <span class=\"hljs-string\">&quot;刷新...&quot;</span>, Toast.LENGTH_SHORT).show();\n            <span class=\"hljs-keyword\">final</span> AppWidgetManager mgr = AppWidgetManager.getInstance(context);\n            <span class=\"hljs-keyword\">final</span> ComponentName cn = <span class=\"hljs-keyword\">new</span> ComponentName(context,ListWidgetProvider.class);\n            ListRemoteViewsFactory.refresh();\n            mgr.notifyAppWidgetViewDataChanged(mgr.getAppWidgetIds(cn),R.id.lv_device);\n            mHandler.postDelayed(runnable,<span class=\"hljs-number\">2000</span>);\n            showLoading(context);\n        &#125;\n        super.<span class=\"hljs-built_in\">onReceive</span>(context, intent);\n    &#125;\n\n    <span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">     * 显示加载loading</span>\n<span class=\"hljs-comment\">     *</span>\n<span class=\"hljs-comment\">     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">showLoading</span><span class=\"hljs-params\">(Context context)</span> </span>&#123;\n        RemoteViews remoteViews = <span class=\"hljs-keyword\">new</span> RemoteViews(context.getPackageName(), R.layout.layout_widget);\n        remoteViews.setViewVisibility(R.id.tv_refresh, View.VISIBLE);\n        remoteViews.setViewVisibility(R.id.progress_bar, View.VISIBLE);\n        remoteViews.setTextViewText(R.id.tv_refresh, <span class=\"hljs-string\">&quot;正在刷新...&quot;</span>);\n        refreshWidget(context, remoteViews, <span class=\"hljs-literal\">false</span>);\n    &#125;\n\n    <span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">     * 隐藏加载loading</span>\n<span class=\"hljs-comment\">     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">hideLoading</span><span class=\"hljs-params\">(Context context)</span> </span>&#123;\n        RemoteViews remoteViews = <span class=\"hljs-keyword\">new</span> RemoteViews(context.getPackageName(), R.layout.layout_widget);\n        remoteViews.setViewVisibility(R.id.progress_bar, View.GONE);\n        remoteViews.setTextViewText(R.id.tv_refresh, <span class=\"hljs-string\">&quot;刷新&quot;</span>);\n        refreshWidget(context, remoteViews, <span class=\"hljs-literal\">false</span>);\n    &#125;\n\n\n\n    <span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">     * 刷新Widget</span>\n<span class=\"hljs-comment\">     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">refreshWidget</span><span class=\"hljs-params\">(Context context, RemoteViews remoteViews, <span class=\"hljs-keyword\">boolean</span> refreshList)</span> </span>&#123;\n        AppWidgetManager appWidgetManager = AppWidgetManager.getInstance(context);\n        ComponentName componentName = <span class=\"hljs-keyword\">new</span> ComponentName(context, ListWidgetProvider.class);\n        appWidgetManager.updateAppWidget(componentName, remoteViews);\n        <span class=\"hljs-keyword\">if</span> (refreshList)\n            appWidgetManager.notifyAppWidgetViewDataChanged(appWidgetManager.getAppWidgetIds(componentName), R.id.lv_device);\n    &#125;\n&#125;</code></pre>\n<p>针对以上代码，我们着重来看onUpdate()方法。在onUpdate()中我们主要实现了两个功能，第一个功能ListView以外的事件点击，例如点击“刷新”来更新小部件。第二个功能是适配ListView并实现ListView内部Item控件的点击事件。在这个方法中我们首先获取到了一个RemoteView的实例，这个RemoteView对应的就是我们Widget布局的View。关于点击事件的实现代码中注释写的也比较详细，在这里就不做过多解释了。重点是需要了解如何实现并适配ListView，具体实现请看下节。</p>\n<h2 id=\"四-RemoteViewsFactory实现列表适配\"><a href=\"#四-RemoteViewsFactory实现列表适配\" class=\"headerlink\" title=\"四.RemoteViewsFactory实现列表适配\"></a>四.RemoteViewsFactory实现列表适配</h2><p>上面我们提到了RemoteViewsFactory，这个类其实可以类比为ListView的Adapter，该类存在的意义就是为了适配ListView的数据。只不过这里是把Adapter换成RemoteViews来实现的。看下ListRemoteViewsFactory中的代码：</p>\n<pre><code class=\"hljs arduino\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ListRemoteViewsFactory</span> <span class=\"hljs-title\">implements</span> <span class=\"hljs-title\">RemoteViewsService</span>.<span class=\"hljs-title\">RemoteViewsFactory</span> &#123;</span>\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">String</span> TAG=<span class=\"hljs-string\">&quot;Widget&quot;</span>;\n    <span class=\"hljs-keyword\">private</span> Context mContext;\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">int</span> mAppWidgetId;\n\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> List&lt;Device&gt; mDevices;\n\n    <span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">     * 构造GridRemoteViewsFactory</span>\n<span class=\"hljs-comment\">     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">ListRemoteViewsFactory</span><span class=\"hljs-params\">(Context context, Intent intent)</span> </span>&#123;\n        mContext = context;\n        mAppWidgetId = intent.getIntExtra(AppWidgetManager.EXTRA_APPWIDGET_ID,\n                AppWidgetManager.INVALID_APPWIDGET_ID);\n    &#125;\n\n    @Override\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> RemoteViews <span class=\"hljs-title\">getViewAt</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> <span class=\"hljs-built_in\">position</span>)</span> </span>&#123;\n        <span class=\"hljs-comment\">//  HashMap&lt;String, Object&gt; map;</span>\n\n        <span class=\"hljs-comment\">// 获取 item_widget_device.xml 对应的RemoteViews</span>\n        RemoteViews rv = <span class=\"hljs-keyword\">new</span> RemoteViews(mContext.getPackageName(), R.layout.item_widget_device);\n\n        <span class=\"hljs-comment\">// 设置 第position位的“视图”的数据</span>\n        Device device = mDevices.<span class=\"hljs-built_in\">get</span>(<span class=\"hljs-built_in\">position</span>);\n        <span class=\"hljs-comment\">//  rv.setImageViewResource(R.id.iv_lock, ((Integer) map.get(IMAGE_ITEM)).intValue());</span>\n        rv.setTextViewText(R.id.tv_name, device.getName());\n\n        <span class=\"hljs-comment\">// 设置 第position位的“视图”对应的响应事件</span>\n        Intent fillInIntent = <span class=\"hljs-keyword\">new</span> Intent();\n        fillInIntent.putExtra(<span class=\"hljs-string\">&quot;Type&quot;</span>, <span class=\"hljs-number\">0</span>);\n        fillInIntent.putExtra(ListWidgetProvider.COLLECTION_VIEW_EXTRA, <span class=\"hljs-built_in\">position</span>);\n        rv.setOnClickFillInIntent(R.id.rl_widget_device, fillInIntent);\n\n\n        Intent lockIntent = <span class=\"hljs-keyword\">new</span> Intent();\n        lockIntent.putExtra(ListWidgetProvider.COLLECTION_VIEW_EXTRA, <span class=\"hljs-built_in\">position</span>);\n        lockIntent.putExtra(<span class=\"hljs-string\">&quot;Type&quot;</span>, <span class=\"hljs-number\">1</span>);\n        rv.setOnClickFillInIntent(R.id.iv_lock, lockIntent);\n\n        Intent unlockIntent = <span class=\"hljs-keyword\">new</span> Intent();\n        unlockIntent.putExtra(<span class=\"hljs-string\">&quot;Type&quot;</span>, <span class=\"hljs-number\">2</span>);\n        unlockIntent.putExtra(ListWidgetProvider.COLLECTION_VIEW_EXTRA, <span class=\"hljs-built_in\">position</span>);\n        rv.setOnClickFillInIntent(R.id.iv_unlock, unlockIntent);\n\n        <span class=\"hljs-keyword\">return</span> rv;\n    &#125;\n\n\n    <span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">     * 初始化ListView的数据</span>\n<span class=\"hljs-comment\">     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">initListViewData</span><span class=\"hljs-params\">()</span> </span>&#123;\n        mDevices = <span class=\"hljs-keyword\">new</span> ArrayList&lt;&gt;();\n        mDevices.add(<span class=\"hljs-keyword\">new</span> Device(<span class=\"hljs-string\">&quot;Hello&quot;</span>, <span class=\"hljs-number\">0</span>));\n        mDevices.add(<span class=\"hljs-keyword\">new</span> Device(<span class=\"hljs-string\">&quot;Oitsme&quot;</span>, <span class=\"hljs-number\">1</span>));\n        mDevices.add(<span class=\"hljs-keyword\">new</span> Device(<span class=\"hljs-string\">&quot;Hi&quot;</span>, <span class=\"hljs-number\">0</span>));\n        mDevices.add(<span class=\"hljs-keyword\">new</span> Device(<span class=\"hljs-string\">&quot;Hey&quot;</span>, <span class=\"hljs-number\">1</span>));\n    &#125;\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">int</span> i;\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">refresh</span><span class=\"hljs-params\">()</span></span>&#123;\n        i++;\n        mDevices.add(<span class=\"hljs-keyword\">new</span> Device(<span class=\"hljs-string\">&quot;Refresh&quot;</span>+i, <span class=\"hljs-number\">1</span>));\n    &#125;\n\n    @Override\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onCreate</span><span class=\"hljs-params\">()</span> </span>&#123;\n        Log.e(TAG,<span class=\"hljs-string\">&quot;onCreate&quot;</span>);\n        <span class=\"hljs-comment\">// 初始化“集合视图”中的数据</span>\n        initListViewData();\n    &#125;\n\n    @Override\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">getCount</span><span class=\"hljs-params\">()</span> </span>&#123;\n        <span class=\"hljs-comment\">// 返回“集合视图”中的数据的总数</span>\n        <span class=\"hljs-keyword\">return</span> mDevices.<span class=\"hljs-built_in\">size</span>();\n    &#125;\n\n    @Override\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">long</span> <span class=\"hljs-title\">getItemId</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> <span class=\"hljs-built_in\">position</span>)</span> </span>&#123;\n        <span class=\"hljs-comment\">// 返回当前项在“集合视图”中的位置</span>\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">position</span>;\n    &#125;\n\n    @Override\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> RemoteViews <span class=\"hljs-title\">getLoadingView</span><span class=\"hljs-params\">()</span> </span>&#123;\n        <span class=\"hljs-keyword\">return</span> null;\n    &#125;\n\n    @Override\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">getViewTypeCount</span><span class=\"hljs-params\">()</span> </span>&#123;\n        <span class=\"hljs-comment\">// 只有一类 ListView</span>\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>;\n    &#125;\n\n    @Override\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">hasStableIds</span><span class=\"hljs-params\">()</span> </span>&#123;\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\n    &#125;\n\n    @Override\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onDataSetChanged</span><span class=\"hljs-params\">()</span> </span>&#123;\n    &#125;\n\n    @Override\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onDestroy</span><span class=\"hljs-params\">()</span> </span>&#123;\n        mDevices.<span class=\"hljs-built_in\">clear</span>();\n    &#125;\n&#125;</code></pre>\n<p>有了RemoteViewsFactory 还需要有RemoteViewsService才能与ListView关联起来。来看RemoteViewsService的实现类ListWidgetService，很简单，只重写了onGetViewFactory方法：</p>\n<pre><code class=\"hljs scala\">public <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ListWidgetService</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">RemoteViewsService</span> </span>&#123;\n\n    <span class=\"hljs-meta\">@Override</span>\n    public <span class=\"hljs-type\">RemoteViewsService</span>.<span class=\"hljs-type\">RemoteViewsFactory</span> onGetViewFactory(<span class=\"hljs-type\">Intent</span> intent) &#123;\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">ListRemoteViewsFactory</span>(<span class=\"hljs-keyword\">this</span>, intent);\n    &#125;\n&#125;</code></pre>\n<p>至此我们可以再次回到ListWidgetProvider中的onUpdate()方法，来看ListWidgetService 是如何与ListView关联到一起的了。</p>\n<pre><code class=\"hljs reasonml\"><span class=\"hljs-comment\">//  设置 “ListView” 的adapter。</span>\n<span class=\"hljs-comment\">// (01) intent: 对应启动 ListWidgetService(RemoteViewsService) 的intent</span>\n<span class=\"hljs-comment\">// (02) setRemoteAdapter: 设置 ListView的适配器</span>\n<span class=\"hljs-comment\">//  通过setRemoteAdapter将ListView和ListWidgetService关联起来，</span>\n<span class=\"hljs-comment\">//  以达到通过 ListWidgetService 更新 ListView 的目的</span>\n Intent serviceIntent = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-constructor\">Intent(<span class=\"hljs-params\">context</span>, ListWidgetService.<span class=\"hljs-params\">class</span>)</span>;\n remoteViews.set<span class=\"hljs-constructor\">RemoteAdapter(R.<span class=\"hljs-params\">id</span>.<span class=\"hljs-params\">lv_device</span>, <span class=\"hljs-params\">serviceIntent</span>)</span>;</code></pre>\n\n<h2 id=\"五-点击事件处理\"><a href=\"#五-点击事件处理\" class=\"headerlink\" title=\"五.点击事件处理\"></a>五.点击事件处理</h2><p>Widget中事件点击以及适配ListView，想必大家都有所了解了。那么对于事件的处理我们还没有提到，例如在Widget中点击了刷新后我们不能像在App中那样给控件设置一个事件监听来在回掉方法中处理。在文章开头我们就提到了Widget是依赖广播来实现，因此我们点击了刷新后其实仅仅是发送出来一个广播。如果我们不去处理广播那么点击事件其实是没有任何意义的。因此，来看ListWidgetProvider中第二个比较重要的方法onReceive()。这个方法比较简单，只要我们对特定的广播来做相应的处理就可以了。</p>\n<pre><code class=\"hljs verilog\">@Override\n    public <span class=\"hljs-keyword\">void</span> onReceive(Context <span class=\"hljs-keyword\">context</span>, Intent intent) &#123;\n        String action = intent<span class=\"hljs-variable\">.getAction</span>();\n        AppWidgetManager appWidgetManager = AppWidgetManager<span class=\"hljs-variable\">.getInstance</span>(<span class=\"hljs-keyword\">context</span>);\n\t        <span class=\"hljs-keyword\">if</span> (action<span class=\"hljs-variable\">.equals</span>(COLLECTION_VIEW_ACTION)) &#123;<span class=\"hljs-comment\">//处理列表中的事件</span>\n            <span class=\"hljs-comment\">// 接受“ListView”的点击事件的广播</span>\n            <span class=\"hljs-keyword\">int</span> <span class=\"hljs-keyword\">type</span> = intent<span class=\"hljs-variable\">.getIntExtra</span>(<span class=\"hljs-string\">&quot;Type&quot;</span>, <span class=\"hljs-number\">0</span>);\n            <span class=\"hljs-keyword\">int</span> appWidgetId = intent<span class=\"hljs-variable\">.getIntExtra</span>(AppWidgetManager<span class=\"hljs-variable\">.EXTRA_APPWIDGET_ID</span>,\n                    AppWidgetManager<span class=\"hljs-variable\">.INVALID_APPWIDGET_ID</span>);\n            <span class=\"hljs-keyword\">int</span> index = intent<span class=\"hljs-variable\">.getIntExtra</span>(COLLECTION_VIEW_EXTRA, <span class=\"hljs-number\">0</span>);\n            switch (<span class=\"hljs-keyword\">type</span>) &#123;\n                <span class=\"hljs-keyword\">case</span> <span class=\"hljs-number\">0</span>:\n                    Toast<span class=\"hljs-variable\">.makeText</span>(<span class=\"hljs-keyword\">context</span>, <span class=\"hljs-string\">&quot;item&quot;</span> + index, Toast<span class=\"hljs-variable\">.LENGTH_SHORT</span>)<span class=\"hljs-variable\">.show</span>();\n                    <span class=\"hljs-keyword\">break</span>;\n                <span class=\"hljs-keyword\">case</span> <span class=\"hljs-number\">1</span>:\n                    Toast<span class=\"hljs-variable\">.makeText</span>(<span class=\"hljs-keyword\">context</span>, <span class=\"hljs-string\">&quot;lock&quot;</span>+index, Toast<span class=\"hljs-variable\">.LENGTH_SHORT</span>)<span class=\"hljs-variable\">.show</span>();\n                    <span class=\"hljs-keyword\">break</span>;\n                <span class=\"hljs-keyword\">case</span> <span class=\"hljs-number\">2</span>:\n                    Toast<span class=\"hljs-variable\">.makeText</span>(<span class=\"hljs-keyword\">context</span>, <span class=\"hljs-string\">&quot;unlock&quot;</span>+index, Toast<span class=\"hljs-variable\">.LENGTH_SHORT</span>)<span class=\"hljs-variable\">.show</span>();\n                    <span class=\"hljs-keyword\">break</span>;\n            &#125;\n        &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (action<span class=\"hljs-variable\">.equals</span>(REFRESH_WIDGET)) &#123;<span class=\"hljs-comment\">//处理刷新事件</span>\n            <span class=\"hljs-comment\">// 接受“bt_refresh”的点击事件的广播</span>\n            Toast<span class=\"hljs-variable\">.makeText</span>(<span class=\"hljs-keyword\">context</span>, <span class=\"hljs-string\">&quot;刷新...&quot;</span>, Toast<span class=\"hljs-variable\">.LENGTH_SHORT</span>)<span class=\"hljs-variable\">.show</span>();\n            <span class=\"hljs-keyword\">final</span> AppWidgetManager mgr = AppWidgetManager<span class=\"hljs-variable\">.getInstance</span>(<span class=\"hljs-keyword\">context</span>);\n            <span class=\"hljs-keyword\">final</span> ComponentName cn = <span class=\"hljs-keyword\">new</span> ComponentName(<span class=\"hljs-keyword\">context</span>,ListWidgetProvider<span class=\"hljs-variable\">.class</span>);\n            ListRemoteViewsFactory<span class=\"hljs-variable\">.refresh</span>();\n            mgr<span class=\"hljs-variable\">.notifyAppWidgetViewDataChanged</span>(mgr<span class=\"hljs-variable\">.getAppWidgetIds</span>(cn),R<span class=\"hljs-variable\">.id</span><span class=\"hljs-variable\">.lv_device</span>);\n            mHandler<span class=\"hljs-variable\">.postDelayed</span>(runnable,<span class=\"hljs-number\">2000</span>);\n            showLoading(<span class=\"hljs-keyword\">context</span>);\n        &#125;\n        <span class=\"hljs-keyword\">super</span><span class=\"hljs-variable\">.onReceive</span>(<span class=\"hljs-keyword\">context</span>, intent);\n    &#125;</code></pre>\n<p>最后，别忘了ListWidgetProvider是广播，ListWidgetService是服务，都需要我们在AndroidManifest文件中来注册：</p>\n<pre><code class=\"hljs xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">receiver</span> <span class=\"hljs-attr\">android:name</span>=<span class=\"hljs-string\">&quot;.widget.ListWidgetProvider&quot;</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">intent-filter</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">action</span> <span class=\"hljs-attr\">android:name</span>=<span class=\"hljs-string\">&quot;android.appwidget.action.APPWIDGET_UPDATE&quot;</span> /&gt;</span>\n\n            <span class=\"hljs-comment\">&lt;!-- ListWidgetProvider接收点击ListView的响应事件 --&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">action</span> <span class=\"hljs-attr\">android:name</span>=<span class=\"hljs-string\">&quot;com.oitsme.COLLECTION_VIEW_ACTION&quot;</span> /&gt;</span>\n            <span class=\"hljs-comment\">&lt;!-- ListWidgetProvider接收点击bt_refresh的响应事件 --&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">action</span> <span class=\"hljs-attr\">android:name</span>=<span class=\"hljs-string\">&quot;com.oitsme.REFRESH_WIDGET&quot;</span> /&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">action</span> <span class=\"hljs-attr\">android:name</span>=<span class=\"hljs-string\">&quot;com.oitsme.LOCK_ACTION&quot;</span>/&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">action</span> <span class=\"hljs-attr\">android:name</span>=<span class=\"hljs-string\">&quot;com.oitsme.UNLOCK_ACTION&quot;</span>/&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">intent-filter</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta-data</span> <span class=\"hljs-attr\">android:name</span>=<span class=\"hljs-string\">&quot;android.appwidget.provider&quot;</span></span>\n<span class=\"hljs-tag\">            <span class=\"hljs-attr\">android:resource</span>=<span class=\"hljs-string\">&quot;@xml/widget_provider&quot;</span>/&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">receiver</span>&gt;</span>\n\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">service</span></span>\n<span class=\"hljs-tag\">        <span class=\"hljs-attr\">android:name</span>=<span class=\"hljs-string\">&quot;.widget.ListWidgetService&quot;</span></span>\n<span class=\"hljs-tag\">        <span class=\"hljs-attr\">android:permission</span>=<span class=\"hljs-string\">&quot;android.permission.BIND_REMOTEVIEWS&quot;</span> /&gt;</span></code></pre>\n\n<h2 id=\"六-小结\"><a href=\"#六-小结\" class=\"headerlink\" title=\"六.小结\"></a>六.小结</h2><p>至此关于列表小部件的讲解就完成了。只是自我感觉文章的逻辑有点乱。如果没明白，大家可以参考下面Demo源码。其实关于Widget的这个Demo其实早在几个月前就已经写好了，但由于最近项目紧再加上本身也是第一次接触Widget控件，因此直至近日才开始动笔写这篇文章。所以文章中避免不了有错误和不合理的地方，欢迎留言指正。</p>\n<p>参考<br><a href=\"https://developer.android.com/guide/topics/appwidgets/\">https://developer.android.com/guide/topics/appwidgets/</a></p>\n<p><a href=\"https://download.csdn.net/download/qq_20521573/11659588\">源码下载</a></p>\n"},{"title":"自定义View之弹性滑动的LockView","date":"2018-07-14T12:30:41.000Z","_content":"***本文已发表在[掘金](https://juejin.im/post/5d465e18518825219c280e5c)，转载请注明出处。***\n\n本篇文章我们来实现一个带有弹性滑动效果的自定义View。当然，文章的侧重点是自定义View但也会涉及到View的事件分发以及一些其他方面的知识，例如使用Scroller实现带有阻尼效果的弹性滑动。因此，我相信看完这篇文章你不仅能学到自定义View的相关知识，还会了解到View的事件分发！还是老规矩，看下最终实现效果。\n![](https://raw.githubusercontent.com/zhpanvip/Resource/master/image/1401.gif)\n\n 分析图中效果会发现其核心功能类似于一个简单的下拉刷新、上拉加载的框架，但又有区别。开始前还是先来罗列一下几个核心步骤，如下：\n      一. 明确需求，确定对外开放的接口\n      二. 分析滑动效果，初步实现控件布局\n      三. 关于滑动，不得不说的事件分发\n      四. 实现自定义CircleWaveView\n\t\n           \n一. 明确需求，确定对外开放接口\n----------------\n\n首先应该明确控件的需求，确定有哪些功能，然后做针对性开发。这里先贴出该控件的使用方法，也是为了更好地认识控件的需求。\n**1.布局文件添加**\n```\n<RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:tools=\"http://schemas.android.com/tools\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    tools:context=\".MainActivity\">\n\n    <com.zhpan.lockview.view.LockView\n        android:id=\"@+id/lock_view\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:layout_centerInParent=\"true\" />\n\n</RelativeLayout>\n```\n**2.设置操作的监听事件。**代码如下：\n\n```\n    mLockView.setOnLockOperateListener(new OnLockOperateListener() {\n         @Override\n         public void onLockPrepared() {//  上锁就绪\n             \n         }\n\n         @Override\n         public void onUnLockPrepared() {//  开锁就绪\n\n         }\n\n         @Override\n         public void onLockStart() {// 开始上锁\n\n         }\n\n         @Override\n         public void onUnlockStart() {// 开始开锁\n\n         }\n\n         @Override\n         public void onNotPrepared() {// 上下滑动距离未达到就绪状态\n\n         }\n     });\n```\n\n**3.对外开放接口**\n\n```\n// 设置蓝牙是否连接\nmLockView.setBluetoothConnect(false);\n// 设置上锁状态\nmLockView.setLockState(isLock);\n// 设置View是否可以滑动\nmLockView.setCanSlide(true)\n// 设置滑动阻尼大小\nmLockView.setDamping(1.7)\n// 设置View中心文字\nmLockView.setText(\"已上锁\");\n// 设置中心大圆的颜色\nmLockView.setCircleColor\n// 开启心跳动画\nmLockView.startWave();\n// 停止心跳动画\nmLockView.stopWave();\n// 是否正在搜索/连接蓝牙\nmLockView.connecting(true);\n\n// 点击事件监听（只有在未连接蓝牙时有效）\nmLockView.setOnClickListener(new View.OnClickListener() {\n         @Override\n         public void onClick(View v) {\n             \n         }\n     });\n```\n我们来总结下控件中需要实现的功能：\n\n 1. 控件布局的实现。\n 2. 蓝牙未连接时，只能点击而不能滑动。\n 3. 点击事件以及连接中动画。\n 4. 更改连接状态。\n 5. 实现上下弹性滑动，且需要控制滑动边界。\n 6. 滑动事件回掉。\n 7. 心跳动画实现。\n\n以上几点就是我们要完成的核心功能，有了需求之后就直接进入主题来实现我们想要的效果吧。\n\n二、分析控件，初步实现控件布局\n--------\n分析上图的效果发现，中间的View是可滑动的，且覆盖在上下小圆点的上面。对于这种效果直接继承View实现起来会不太方便。因此我们可以想到利用自定义ViewGroup来布局页面。这么一来使开发简单了许多。那么接下来先新建一个layout_oval_lock.xml的布局为文件，并采用FrameLayout来布局控件，这样就实现了层次叠加效果，FrameLayout内部是两个自定义View，我们可以暂且搁置不管，后面会讲到如何实现。布局文件如下：\n\n```\n<FrameLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    android:orientation=\"vertical\">\n\n    <com.zhpan.lockview.view.CircleView\n        android:id=\"@+id/green_cv\"\n        android:layout_width=\"15dp\"\n        android:layout_height=\"15dp\"\n        android:layout_marginTop=\"110dp\"\n        app:circle_color=\"@color/green\"\n        android:layout_gravity=\"center\"/>\n\n    <com.zhpan.lockview.view.CircleView\n        android:id=\"@+id/red_cv\"\n        android:layout_width=\"15dp\"\n        android:layout_height=\"15dp\"\n        app:circle_color=\"@color/red\"\n        android:layout_marginTop=\"-110dp\"\n        android:layout_gravity=\"center\"/>\n\n    <com.zhpan.lockview.view.CircleWaveView\n        android:id=\"@+id/circle_wave_view\"\n        android:layout_width=\"220dp\"\n        android:layout_height=\"300dp\"\n        android:layout_gravity=\"center\"\n        android:padding=\"20dp\"/>\n\n    <ProgressBar\n        android:id=\"@+id/progress\"\n        android:layout_width=\"30dp\"\n        android:layout_height=\"30dp\"\n        android:visibility=\"gone\"\n        android:indeterminateTint=\"@color/white\"\n        android:layout_gravity=\"center\"/>\n</FrameLayout>\n```\n接下来新建一个LockView类并继承FrameLayout。LockView与 上边layout_oval_lock的布局文件关联，并重写相应的方法。代码如下：\n```\npublic LockView(Context context) {\n        this(context, null);\n    }\n\n    public LockView(Context context, AttributeSet attrs) {\n        this(context, attrs, 0);\n    }\n\n    public LockView(Context context, AttributeSet attrs, int defStyleAttr) {\n        super(context, attrs, defStyleAttr);\n        init(context, attrs);\n    }\n\n    private void init(Context context, AttributeSet attrs) {\n        mTouchSlop = ViewConfiguration.get(context).getScaledTouchSlop();\n        View view = View.inflate(context, R.layout.layout_oval_lock, this);\n        mCircleWaveView = (CircleWaveView) view.findViewById(R.id.circle_wave_view);\n        mCircleView = (CircleView) view.findViewById(R.id.green_cv);\n        distance = ((LayoutParams) mCircleView.getLayoutParams()).topMargin;\n        mProgressBar = (ProgressBar) view.findViewById(R.id.progress);\n        mScroller = mCircleWaveView.getScroller();\n        mContext = context;\n        mCircleWaveView.setOnClickListener(new OnClickListener() {\n            @Override\n            public void onClick(View v) {\n            }\n        });\n    }\n\n    @Override\n    protected void onLayout(boolean changed, int l, int t, int r, int b) {\n        View view = getChildAt(0);\n        view.layout(0, 0, getMeasuredWidth(), getMeasuredHeight());\n    }\n\n    @Override\n    protected void onSizeChanged(int w, int h, int oldw, int oldh) {\n        super.onSizeChanged(w, h, oldw, oldh);\n    }\n```\n三.关于滑动，不得不说的事件分发\n-----------\n接下来就要来处理中心View的滑动了！说到滑动，避免不了的就应该想到Android中View的事件分发，那么对于滑动事件的处理我们需要重写三个方法。我想很多小伙伴肯定已经想到了！没错，就是事件分发的三个核心方法：dispatchTouchEvent、onInterceptTouchEvent、以及onTouchEvent。我觉得还是先简单来了解一下这三个方法吧，因为它确实挺重要的。\n\n - ***dispatchTouchEvent***   顾名思义，这个方法就是用来对事件进行分发的。如果事件传递到了当前View，那么这个方法一定会被调用。它的返回结果受当前View的onTouchEvent或下级View的dispatchTouchEvent方法的影响，表示是否消费当前事件。\n - ***onInterceptTouchEvent***  这个方法在dispatchTouchEvent方法的内部被调用，用来表示是否拦截某个事件。返回结果表示是否拦截当前事件。需要注意的是View并没有该方法，这个方法仅仅存在于ViewGroup中！如果事件传递到View中，那么会直接调用该View的onTouchEvent方法。\n - ***onTouchEvent***  这个方法在dispatchTouchEvent方法中调用。用来处理点击事件。返回结果表示是否消费当前事件。View中的onTouchEvent方法默认会消费事件，只有当设置clickable和longClickable为false时则不会消费该事件。\n\n**首先来看LockView中重写的dispatchTouchEvent方法中的代码**：\n\n```\n    @Override\n    public boolean dispatchTouchEvent(MotionEvent ev) {\n        if (!canSlide)\n            switch (ev.getAction()) {\n                case ACTION_DOWN:\n                    timestamp = System.currentTimeMillis();\n                    break;\n                case ACTION_UP:\n                    if (System.currentTimeMillis() - timestamp < 500) {\n                        performClick();\n                        return true;\n                    }\n                    break;\n            }\n        return super.dispatchTouchEvent(ev);\n    }\n```\n\n上面提到，只要有事件传递到当前的ViewGroup那么dispatchTouchEvent就会首先被调用！因此在这个方法里先来判断当前是否是可以滑动状态（蓝牙未连接时不可滑动）。如果不可以滑动，那么就去处理点击事件，我们认为ACTION_DOWN和ACTION_UP之间间隔小于500毫秒就是一次点击事件，那么就在此处调用performClick方法并消费掉当前事件，如果间隔大于500毫秒，不认为是点击事件，那么紧接着就去调用父类的dispatchTouchEvent方法。如果当前可以滑动，那么同样调用父类的dispatchTouchEvent方法来处理。\n\n**接下来我们看重写的onInterceptTouchEvent方法**\n\n```\n\n@Override\npublic boolean onInterceptTouchEvent(MotionEvent ev) {\n        boolean intercepted = true;\n        int y = (int) ev.getY();\n        switch (ev.getAction()) {\n            case ACTION_DOWN:\n                intercepted = false;\n                if (!mScroller.isFinished()) {\n                    mScroller.abortAnimation();\n                }\n                break;\n            case MotionEvent.ACTION_MOVE:\n                if (Math.abs(y - mLastY) > mTouchSlop) {\n                    intercepted = true;\n                }\n                break;\n            case MotionEvent.ACTION_UP:\n                intercepted = false;\n                break;\n        }\n        mLastY = y;\n        return intercepted;\n    }\n```\n在这个方法中我们重点来看ACTION_MOVE的时候，在这里先判断了滑动的距离是否大于mTouchSlop，这个值是认为滑动的最小距离，当大于这个值的时候就认为是滑动了。那么看此时intercepted返回了true，表示要拦截这个事件！此处拦截了这个滑动事件会怎么样呢？答案是当前View中的onTouchEvent方法被调用了！现在请将我们的目光聚焦到onTouchEvent方法中，注意前方高能！\n\n**核心中最核心的onTouchEvent方法**\n```\n    \n    @Override\n    public boolean onTouchEvent(MotionEvent event) {\n\n        int y = (int) event.getY();\n        int scrollY = mCircleWaveView.getScrollY();\n        switch (event.getAction()) {\n            case ACTION_DOWN:\n                if (!mScroller.isFinished()) {\n                    mScroller.abortAnimation();\n                }\n                break;\n            case MotionEvent.ACTION_MOVE:\n                if (!canSlide) {\n                    return super.onTouchEvent(event);\n                }\n                int deltaY = (int) ((mLastY - y) / damping);\n                if (mCircleWaveView.getScrollY() > mTouchSlop) {\n                    mOption = Option.LOCK;\n                } else if (mCircleWaveView.getScrollY() < -mTouchSlop) {\n                    mOption = Option.UNLOCK;\n                }\n                if (Math.abs(scrollY) > (distance - mCircleWaveView.getRadius() + mCircleView.getRadius())) {\n                    if (mOption != null) {\n                        switch (mOption) {\n                            case LOCK:\n                                if (mOnLockOperateListener != null)\n                                    mOnLockOperateListener.onLockPrepared();\n                                mCircleWaveView.setLockPrepared(true);\n                                break;\n                            case UNLOCK:\n                                if (mOnLockOperateListener != null)\n                                    mOnLockOperateListener.onUnLockPrepared();\n                                mCircleWaveView.setUnLockPrePared(true);\n                                break;\n                        }\n                    }\n                } else {\n                    mCircleWaveView.setUnLockPrePared(false);\n                    mCircleWaveView.setLockPrepared(false);\n                    mOnLockOperateListener.onNotPrepared();\n                   /* if (isLock()) {\n                        mCircleWaveView.setText(mContext.getResources().getString(R.string.device_control_unlock));\n                    } else {\n                        mCircleWaveView.setText(mContext.getResources().getString(R.string.device_control_lock));\n                    }*/\n//                    isOperating = false;\n                }\n\n                /**\n                 * 控制滑动边界\n                 */\n                int border = (distance - mCircleWaveView.getRadius() + mCircleView.getRadius()) +\n                        DensityUtils.dp2px(mContext, 25);//  可上下滑动的最大距离\n                //  当前上下滑动的距离\n                int slideHeight = deltaY + mCircleWaveView.getScrollY();\n                if (slideHeight > border) {\n                    mCircleWaveView.scrollTo(0, border);\n                    return true;\n                } else if (slideHeight + border < 0) {\n                    mCircleWaveView.scrollTo(0, -border);\n                    return true;\n                }\n                mCircleWaveView.scrollBy(0, deltaY);\n                break;\n            case MotionEvent.ACTION_UP:\n                mCircleWaveView.setUnLockPrePared(false);\n                mCircleWaveView.setLockPrepared(false);\n                scrollY = mCircleWaveView.getScrollY();\n                if (Math.abs(scrollY) > (distance - mCircleWaveView.getRadius() + mCircleView.getRadius()) && mOption != null) {\n                    switch (mOption) {\n                        case LOCK:\n                            if (mOnLockOperateListener != null)\n                                mOnLockOperateListener.onLockStart();\n                            break;\n                        case UNLOCK:\n                            if (mOnLockOperateListener != null)\n                                mOnLockOperateListener.onUnlockStart();\n                            break;\n                    }\n                }\n                mCircleWaveView.smoothScroll(0, 0);\n                break;\n        }\n        mLastY = y;\n        return super.onTouchEvent(event);\n    }\n\n```\n看到这个方法中这么多代码不知道各位是否已经懵逼？（好吧，我承认，这地方代码写的确实比较乱）不过没关系，其实细细分析来还是不难理解的！同样，我们选择比较重要的点来看。首先来看ACTION_MOVE的时候，在这里先判断了是否可以滑动（其实不可以滑动的情况下应该不会走到这个方法，但是为了严谨还是加了判断），如果不能滑动则下边的逻辑全都不会再走了。接下来\n通过判断滑动的方向来确定是要开锁还是上锁，并根据滑动距离来给出回调处理。即当中心圆CircleWaveView向上或向下滑动并完全覆盖到上/下的小圆点时则会回掉上锁就绪或者开锁就绪（onLockPrepared、onUnLockPrepared）的方法。此时释放CircleWaveView，则会回调开锁或者上锁（onLockStart、onUnlockStart）的方法。如果CircleWaveView在完全覆盖到上/下的小圆点的状态下，再向反方向滑动至未完全覆盖小圆点，此时则会回掉未就绪（onNotPrepared）的方法。下边贴一下回调接口，一共五个方法，如下：\n\n```\npublic interface  OnLockOperateListener {\n   // 上锁就绪\n   void onLockPrepared();\n   // 开锁就绪\n   void onUnLockPrepared();\n   // 开始上锁\n   void onLockStart();\n   // 开始开锁\n   void onUnlockStart();\n   // 未就绪\n   void onNotPrepared();\n}\n```\n接下来是通过一系列计算来控制CircleWaveView的滑动边界。思路大致如此：首先根据CircleWaveView和上下小圆的位置来计算出可上下滑动的最大距离border。然后计算当CircleWaveView滑动的距离超过border时就强制将其滚动到border位置，已达到固定的效果。代码如下：\n\n```\n\t/**\n      * 控制滑动边界\n      */\n    int border = (distance - mCircleWaveView.getRadius() + mCircleView.getRadius()) +\n                        DensityUtils.dp2px(mContext, 25);//  可上下滑动的最大距离\n    int deltaY = (int) ((mLastY - y) / damping);\n    //  当前上下滑动的距离\n    int slideHeight = deltaY + mCircleWaveView.getScrollY();\n    if (slideHeight > border) {\n         mCircleWaveView.scrollTo(0, border);\n         return true;\n        } else if (slideHeight + border < 0) {\n          mCircleWaveView.scrollTo(0, -border);\n          return true;\n        }\n    mCircleWaveView.scrollBy(0, deltaY);\n```\n\n然后是实现CircleWaveView的弹性滑动，这里我们给CircleWaveView加了一个弹性滑动和阻尼效果。弹性滑动是在CircleWaveView中通过Scroller来实现的，CircleWaveView暴漏出来smoothScroll的弹性滑动接口供在LockView中调用。这点我们在后面讲解CircleWaveView时再说。而阻尼滑动则是将原滑动距离除以阻尼系数以减小滑动距离从而产生阻尼效果。\n最后来看ACTION_UP，同样是根据Y轴滑动距离与滑动方向回掉对应的方法，并将CircleWaveView恢复到原位。代码如下：\n\n```\n scrollY = mCircleWaveView.getScrollY();\n if (Math.abs(scrollY) > (distance - mCircleWaveView.getRadius() + mCircleView.getRadius()) && mOption != null) {\n    switch (mOption) {\n          case LOCK:\n               if (mOnLockOperateListener != null)\n                    mOnLockOperateListener.onLockStart();\n           break;\n           case UNLOCK:\n               if (mOnLockOperateListener != null)\n                    mOnLockOperateListener.onUnlockStart();\n           break;\n     }\n mCircleWaveView.smoothScroll(0, 0);\n```\n\n\n四. 实现自定义CircleWaveView\n----------------------\n\n关于自定义CircleWaveView就不具体来讲了，因为关于自定义View都是一样的步骤。这里我们只选取几个重要的地方来说。1.CircleWaveView中内容的绘制。2.关于弹性滑动的实现。3.心跳动画的实现以及状态改变的扩散动画。\n\n**1.CircleWaveView中内容的绘制。**\n\n**绘制主体圆。**主要分为几种情况：\na.蓝牙未连接，且未能获取到网络数据，背景色为灰色。\nb.蓝牙未连接，且能获取到网络数据，背景色为淡绿色或淡红色。\nc.蓝牙已连接，开锁状态为绿色，未开锁状态为红色。\nd.上拉上锁就绪状态为深红色，下拉开锁就绪状态为深绿色。\n\n结合以上需求有如下代码：\n```\nprivate void drawCircle(Canvas canvas) {\n        mPaint.setColor(circleColor);\n        int verticalCenter = getHeight() / 2;\n        int horizontalCenter = getWidth() / 2;\n        int mRadius = Math.min(verticalCenter, horizontalCenter) - Math.min(verticalCenter, horizontalCenter) / 5;\n        radius = Math.min(verticalCenter, horizontalCenter) - Math.min(verticalCenter, horizontalCenter) / 5;\n        if (transforming) {\n            mPaint.setColor(getResources().getColor(R.color.green));\n            canvas.drawCircle(mPieCenterX, mPieCenterY, mRadius, mPaint);\n            mRadius = isLock ? transformDelta : mRadius - transformDelta;\n            mPaint.setColor(getResources().getColor(R.color.red));\n            canvas.drawCircle(mPieCenterX, mPieCenterY, mRadius, mPaint);\n        } else {\n            mRadius = mRadius - waveDelta;\n            if (!isBluetoothConnect) {\n                if (isNoNetData) {\n                    mPaint.setColor(getColor(R.color.gray));\n                } else\n                    mPaint.setColor(isLock ? getColor(R.color.redLight) : getColor(R.color.greenLight));\n            } else {\n                if (isLockPrepared) {\n                    mPaint.setColor(getColor(R.color.redDark));\n                } else if (isUnLockPrePared) {\n                    mPaint.setColor(getColor(R.color.greenDark));\n                } else {\n                    mPaint.setColor(isLock ? getColor(R.color.red) : getColor(R.color.green));\n                }\n            }\n            canvas.drawCircle(mPieCenterX, mPieCenterY, mRadius, mPaint);\n        }\n    }\n```\n \n**绘制CircleWaveView中上下箭头。**  关于箭头绘制，注释部分是通过Path来绘制的，但是发现效果不太好，绘制三角形圆角比较麻烦，所以后台改为了直接在canvas上绘制Bitmap来实现。代码如下：\n\n```\n//  绘制圆中两个三角\n    private void drawTriangle(Canvas canvas) {\n        int left = (mWidth - arrowUp.getWidth()) / 2;\n        canvas.drawBitmap(arrowUp, left, mHeight / 2 - radius + dp13, mPaint);\n        canvas.drawBitmap(arrowDown, left, mHeight / 2 + radius - dp13 - arrowDown.getHeight(), mPaint);\n        /*int radius = Math.min(mHeight, mWidth) / 2 - Math.min(mHeight, mWidth) / 8;\n        mPaintTrangel.setStyle(Paint.Style.FILL);\n        mPaintTrangel.setShadowLayer(4, 0, 3, Color.GRAY);\n        //  三角形顶点到圆边的距离\n        int h0 = DensityUtils.dp2px(mContext, 10);\n        //  三角形高\n        int h1 = DensityUtils.dp2px(mContext, 12);\n        //  三角形底边长\n        int w = DensityUtils.dp2px(mContext, 14);\n        mPaintTrangel.setColor(getResources().getColor(R.color.transparent_33));\n        mPath.moveTo(mWidth / 2, mHeight / 2 - (radius - h0));\n        mPath.lineTo(mWidth / 2 - w, mHeight / 2 - (radius - h1 - h0));\n        mPath.lineTo(mWidth / 2 + w, mHeight / 2 - (radius - h1 - h0));\n        canvas.drawPath(mPath, mPaintTrangel);\n        mPaintTrangel.setShadowLayer(4, 0, -3, Color.GRAY);\n        mPath.moveTo(mWidth / 2, mHeight / 2 + (radius - h0));\n        mPath.lineTo(mWidth / 2 - w, mHeight / 2 + (radius - h1 - h0));\n        mPath.lineTo(mWidth / 2 + w, mHeight / 2 + (radius - h1 - h0));\n        canvas.drawPath(mPath, mPaintTrangel);*/\n    }\n```\n**绘制CircleWaveView中心的文字** 中心文字分为两种情况：当蓝牙未连接时，显示为两行。当蓝牙已连接时显示为一行。绘制思路是先计算出中心基线，然后再来分情况实现。代码如下：\n\n```\n//  绘制圆中的文字\n    private void drawText(Canvas canvas) {\n        if (isConnecting) return;\n        if (TextUtils.isEmpty(mText)) { //   绘制单行文字\n            String text = mContext.getResources().getString(R.string.ble_not_connect);\n            canvas.drawText(text, mPieCenterX, getBaseline(text), mPaintText);\n            return;\n        }\n        if (isBluetoothConnect) {   //   绘制单行文字\n            canvas.drawText(mText, mPieCenterX, getBaseline(mText), mPaintText);\n        } else {    //   绘制两行文字\n            String text = mContext.getResources().getString(R.string.ble_not_connect);\n            int baseline = getBaseline(text);\n            canvas.drawText(text, mPieCenterX, baseline - 30, mPaintText);\n            mPaintText.setTextSize(DensityUtils.dp2px(mContext, 12));\n            canvas.drawText(mText, mPieCenterX, baseline + 30, mPaintText);\n        }\n    }\n\n    private int getBaseline(String text) {\n        mPaintText.setTextSize(mTextSize);\n        mPaintText.getTextBounds(text, 0, text.length(), bounds);\n        Paint.FontMetricsInt fontMetricsInt = mPaintText.getFontMetricsInt();\n        return (getMeasuredHeight() - fontMetricsInt.bottom + fontMetricsInt.top) / 2\n                - fontMetricsInt.top;\n    }\n```\n**2.关于弹性滑动的实现。** 关于滑动，通常我们会想到用ScrollTo或ScrollBy来实现。但由于这两个方法实现滑动都是瞬间完成的，因此滑动看起来会比较生硬，体验也很不好。因此想到可以使用Scroller来做一个滑动延迟实现带有弹性效果的滑动。由于Scroller本身时无法实现滑动的，因此还必须配合computeScroll方法共同完成。这里我们封装一个smoothScroll方法，提供给LockView调用。具体代码如下：\n\n```\npublic void smoothScroll(int destX, int destY) {\n        int scrollY = getScrollY();\n        int delta = destY - scrollY;\n        mScroller.startScroll(destX, scrollY, 0, delta, 400);\n        invalidate();\n    }\n\n    @Override\n    public void computeScroll() {\n        if (mScroller.computeScrollOffset()) {\n            scrollTo(mScroller.getCurrX(), mScroller.getCurrY());\n            postInvalidate();\n        }\n    }\n```\n**3.心跳动画的实现以及状态改变的扩散动画。** \n\n首先来看心跳动画的实现，这里使用属性动画，首先为ValueAnimator设置从0到1再到0的一个数值变化，并且周期时间设置为600毫秒、重复次数设置为ValueAnimator.INFINITE，即为无限次循环。通过ValueAnimator中不断变化的value来计算圆半径的大小，并通过invalidate()方法不断重绘View，从而达到一个心跳动画的效果。代码如下：\n\n```\n//  开始心跳动画\npublic void startWave() {\n        if (animator != null && animator.isRunning())\n            animator.end();\n        animator = ValueAnimator.ofFloat(0f, 1f, 0f);\n        animator.setRepeatCount(ValueAnimator.INFINITE);\n        animator.setRepeatMode(ValueAnimator.RESTART);\n        animator.setDuration(600);\n\n        animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {\n            @Override\n            public void onAnimationUpdate(ValueAnimator animation) {\n                int verticalCenter = getHeight() / 2;\n                int horizontalCenter = getWidth() / 2;\n                waveDelta = (int) (Math.min(verticalCenter, horizontalCenter) * (float) animation.getAnimatedValue() / 16);\n                invalidate();\n            }\n        });\n\n        animator.start();\n    }\n //  停止心跳动画\n public void stopWave() {\n        if (animator != null && animator.isRunning())\n            animator.end();\n    }\n```\n接下来看状态改变时扩散动画的实现，其实方法和心跳动画一样，都是采用ValueAnimator动态计算绘制圆的半径，不在赘述。参考如下代码：\n\n```\npublic void changeLockState(final boolean lock) {\n        stopWave();\n        if (this.isLock != lock) {\n            transforming = true;\n            ValueAnimator valueAnimator = ValueAnimator.ofFloat(0f, 0.99f);\n            valueAnimator.setDuration(500);\n            valueAnimator.addListener(new Animator.AnimatorListener() {\n                @Override\n                public void onAnimationStart(Animator animation) {\n\n                }\n\n                @Override\n                public void onAnimationEnd(Animator animation) {\n                    transforming = false;\n                    isLock = lock;\n                    invalidate();\n                }\n\n                @Override\n                public void onAnimationCancel(Animator animation) {\n                    transforming = false;\n                }\n\n                @Override\n                public void onAnimationRepeat(Animator animation) {\n\n                }\n            });\n            valueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {\n                @Override\n                public void onAnimationUpdate(ValueAnimator animation) {\n                    int verticalCenter = getHeight() / 2;\n                    int horizontalCenter = getWidth() / 2;\n                    transformDelta = (int) ((Math.min(verticalCenter, horizontalCenter) - Math.min(verticalCenter, horizontalCenter) / 6)\n                            * (float) animation.getAnimatedValue());\n                    invalidate();\n                }\n            });\n            valueAnimator.start();\n        }\n    }\n```\n至此，关于LockView的绘制到这里就完全结束了。回顾一下本篇文章，重讲解了自定义LockView以及弹性滑动实现，然后探讨了关于事件分发的一些知识以及使用属性动画来实现心跳和扩散效果。相信看完本篇文章的小伙伴也会有不小的收获，最后关于源码，已放在文章末尾，欢迎start、forck！\n\n\n [源码链接](https://github.com/zhpanvip/CustomView)\n","source":"_posts/14.自定义View之弹性滑动的LockView.md","raw":"---\ntitle: 自定义View之弹性滑动的LockView\ndate: 2018-07-14 20:30:41\ntags:\n- 自定义View\n---\n***本文已发表在[掘金](https://juejin.im/post/5d465e18518825219c280e5c)，转载请注明出处。***\n\n本篇文章我们来实现一个带有弹性滑动效果的自定义View。当然，文章的侧重点是自定义View但也会涉及到View的事件分发以及一些其他方面的知识，例如使用Scroller实现带有阻尼效果的弹性滑动。因此，我相信看完这篇文章你不仅能学到自定义View的相关知识，还会了解到View的事件分发！还是老规矩，看下最终实现效果。\n![](https://raw.githubusercontent.com/zhpanvip/Resource/master/image/1401.gif)\n\n 分析图中效果会发现其核心功能类似于一个简单的下拉刷新、上拉加载的框架，但又有区别。开始前还是先来罗列一下几个核心步骤，如下：\n      一. 明确需求，确定对外开放的接口\n      二. 分析滑动效果，初步实现控件布局\n      三. 关于滑动，不得不说的事件分发\n      四. 实现自定义CircleWaveView\n\t\n           \n一. 明确需求，确定对外开放接口\n----------------\n\n首先应该明确控件的需求，确定有哪些功能，然后做针对性开发。这里先贴出该控件的使用方法，也是为了更好地认识控件的需求。\n**1.布局文件添加**\n```\n<RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:tools=\"http://schemas.android.com/tools\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    tools:context=\".MainActivity\">\n\n    <com.zhpan.lockview.view.LockView\n        android:id=\"@+id/lock_view\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:layout_centerInParent=\"true\" />\n\n</RelativeLayout>\n```\n**2.设置操作的监听事件。**代码如下：\n\n```\n    mLockView.setOnLockOperateListener(new OnLockOperateListener() {\n         @Override\n         public void onLockPrepared() {//  上锁就绪\n             \n         }\n\n         @Override\n         public void onUnLockPrepared() {//  开锁就绪\n\n         }\n\n         @Override\n         public void onLockStart() {// 开始上锁\n\n         }\n\n         @Override\n         public void onUnlockStart() {// 开始开锁\n\n         }\n\n         @Override\n         public void onNotPrepared() {// 上下滑动距离未达到就绪状态\n\n         }\n     });\n```\n\n**3.对外开放接口**\n\n```\n// 设置蓝牙是否连接\nmLockView.setBluetoothConnect(false);\n// 设置上锁状态\nmLockView.setLockState(isLock);\n// 设置View是否可以滑动\nmLockView.setCanSlide(true)\n// 设置滑动阻尼大小\nmLockView.setDamping(1.7)\n// 设置View中心文字\nmLockView.setText(\"已上锁\");\n// 设置中心大圆的颜色\nmLockView.setCircleColor\n// 开启心跳动画\nmLockView.startWave();\n// 停止心跳动画\nmLockView.stopWave();\n// 是否正在搜索/连接蓝牙\nmLockView.connecting(true);\n\n// 点击事件监听（只有在未连接蓝牙时有效）\nmLockView.setOnClickListener(new View.OnClickListener() {\n         @Override\n         public void onClick(View v) {\n             \n         }\n     });\n```\n我们来总结下控件中需要实现的功能：\n\n 1. 控件布局的实现。\n 2. 蓝牙未连接时，只能点击而不能滑动。\n 3. 点击事件以及连接中动画。\n 4. 更改连接状态。\n 5. 实现上下弹性滑动，且需要控制滑动边界。\n 6. 滑动事件回掉。\n 7. 心跳动画实现。\n\n以上几点就是我们要完成的核心功能，有了需求之后就直接进入主题来实现我们想要的效果吧。\n\n二、分析控件，初步实现控件布局\n--------\n分析上图的效果发现，中间的View是可滑动的，且覆盖在上下小圆点的上面。对于这种效果直接继承View实现起来会不太方便。因此我们可以想到利用自定义ViewGroup来布局页面。这么一来使开发简单了许多。那么接下来先新建一个layout_oval_lock.xml的布局为文件，并采用FrameLayout来布局控件，这样就实现了层次叠加效果，FrameLayout内部是两个自定义View，我们可以暂且搁置不管，后面会讲到如何实现。布局文件如下：\n\n```\n<FrameLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    android:orientation=\"vertical\">\n\n    <com.zhpan.lockview.view.CircleView\n        android:id=\"@+id/green_cv\"\n        android:layout_width=\"15dp\"\n        android:layout_height=\"15dp\"\n        android:layout_marginTop=\"110dp\"\n        app:circle_color=\"@color/green\"\n        android:layout_gravity=\"center\"/>\n\n    <com.zhpan.lockview.view.CircleView\n        android:id=\"@+id/red_cv\"\n        android:layout_width=\"15dp\"\n        android:layout_height=\"15dp\"\n        app:circle_color=\"@color/red\"\n        android:layout_marginTop=\"-110dp\"\n        android:layout_gravity=\"center\"/>\n\n    <com.zhpan.lockview.view.CircleWaveView\n        android:id=\"@+id/circle_wave_view\"\n        android:layout_width=\"220dp\"\n        android:layout_height=\"300dp\"\n        android:layout_gravity=\"center\"\n        android:padding=\"20dp\"/>\n\n    <ProgressBar\n        android:id=\"@+id/progress\"\n        android:layout_width=\"30dp\"\n        android:layout_height=\"30dp\"\n        android:visibility=\"gone\"\n        android:indeterminateTint=\"@color/white\"\n        android:layout_gravity=\"center\"/>\n</FrameLayout>\n```\n接下来新建一个LockView类并继承FrameLayout。LockView与 上边layout_oval_lock的布局文件关联，并重写相应的方法。代码如下：\n```\npublic LockView(Context context) {\n        this(context, null);\n    }\n\n    public LockView(Context context, AttributeSet attrs) {\n        this(context, attrs, 0);\n    }\n\n    public LockView(Context context, AttributeSet attrs, int defStyleAttr) {\n        super(context, attrs, defStyleAttr);\n        init(context, attrs);\n    }\n\n    private void init(Context context, AttributeSet attrs) {\n        mTouchSlop = ViewConfiguration.get(context).getScaledTouchSlop();\n        View view = View.inflate(context, R.layout.layout_oval_lock, this);\n        mCircleWaveView = (CircleWaveView) view.findViewById(R.id.circle_wave_view);\n        mCircleView = (CircleView) view.findViewById(R.id.green_cv);\n        distance = ((LayoutParams) mCircleView.getLayoutParams()).topMargin;\n        mProgressBar = (ProgressBar) view.findViewById(R.id.progress);\n        mScroller = mCircleWaveView.getScroller();\n        mContext = context;\n        mCircleWaveView.setOnClickListener(new OnClickListener() {\n            @Override\n            public void onClick(View v) {\n            }\n        });\n    }\n\n    @Override\n    protected void onLayout(boolean changed, int l, int t, int r, int b) {\n        View view = getChildAt(0);\n        view.layout(0, 0, getMeasuredWidth(), getMeasuredHeight());\n    }\n\n    @Override\n    protected void onSizeChanged(int w, int h, int oldw, int oldh) {\n        super.onSizeChanged(w, h, oldw, oldh);\n    }\n```\n三.关于滑动，不得不说的事件分发\n-----------\n接下来就要来处理中心View的滑动了！说到滑动，避免不了的就应该想到Android中View的事件分发，那么对于滑动事件的处理我们需要重写三个方法。我想很多小伙伴肯定已经想到了！没错，就是事件分发的三个核心方法：dispatchTouchEvent、onInterceptTouchEvent、以及onTouchEvent。我觉得还是先简单来了解一下这三个方法吧，因为它确实挺重要的。\n\n - ***dispatchTouchEvent***   顾名思义，这个方法就是用来对事件进行分发的。如果事件传递到了当前View，那么这个方法一定会被调用。它的返回结果受当前View的onTouchEvent或下级View的dispatchTouchEvent方法的影响，表示是否消费当前事件。\n - ***onInterceptTouchEvent***  这个方法在dispatchTouchEvent方法的内部被调用，用来表示是否拦截某个事件。返回结果表示是否拦截当前事件。需要注意的是View并没有该方法，这个方法仅仅存在于ViewGroup中！如果事件传递到View中，那么会直接调用该View的onTouchEvent方法。\n - ***onTouchEvent***  这个方法在dispatchTouchEvent方法中调用。用来处理点击事件。返回结果表示是否消费当前事件。View中的onTouchEvent方法默认会消费事件，只有当设置clickable和longClickable为false时则不会消费该事件。\n\n**首先来看LockView中重写的dispatchTouchEvent方法中的代码**：\n\n```\n    @Override\n    public boolean dispatchTouchEvent(MotionEvent ev) {\n        if (!canSlide)\n            switch (ev.getAction()) {\n                case ACTION_DOWN:\n                    timestamp = System.currentTimeMillis();\n                    break;\n                case ACTION_UP:\n                    if (System.currentTimeMillis() - timestamp < 500) {\n                        performClick();\n                        return true;\n                    }\n                    break;\n            }\n        return super.dispatchTouchEvent(ev);\n    }\n```\n\n上面提到，只要有事件传递到当前的ViewGroup那么dispatchTouchEvent就会首先被调用！因此在这个方法里先来判断当前是否是可以滑动状态（蓝牙未连接时不可滑动）。如果不可以滑动，那么就去处理点击事件，我们认为ACTION_DOWN和ACTION_UP之间间隔小于500毫秒就是一次点击事件，那么就在此处调用performClick方法并消费掉当前事件，如果间隔大于500毫秒，不认为是点击事件，那么紧接着就去调用父类的dispatchTouchEvent方法。如果当前可以滑动，那么同样调用父类的dispatchTouchEvent方法来处理。\n\n**接下来我们看重写的onInterceptTouchEvent方法**\n\n```\n\n@Override\npublic boolean onInterceptTouchEvent(MotionEvent ev) {\n        boolean intercepted = true;\n        int y = (int) ev.getY();\n        switch (ev.getAction()) {\n            case ACTION_DOWN:\n                intercepted = false;\n                if (!mScroller.isFinished()) {\n                    mScroller.abortAnimation();\n                }\n                break;\n            case MotionEvent.ACTION_MOVE:\n                if (Math.abs(y - mLastY) > mTouchSlop) {\n                    intercepted = true;\n                }\n                break;\n            case MotionEvent.ACTION_UP:\n                intercepted = false;\n                break;\n        }\n        mLastY = y;\n        return intercepted;\n    }\n```\n在这个方法中我们重点来看ACTION_MOVE的时候，在这里先判断了滑动的距离是否大于mTouchSlop，这个值是认为滑动的最小距离，当大于这个值的时候就认为是滑动了。那么看此时intercepted返回了true，表示要拦截这个事件！此处拦截了这个滑动事件会怎么样呢？答案是当前View中的onTouchEvent方法被调用了！现在请将我们的目光聚焦到onTouchEvent方法中，注意前方高能！\n\n**核心中最核心的onTouchEvent方法**\n```\n    \n    @Override\n    public boolean onTouchEvent(MotionEvent event) {\n\n        int y = (int) event.getY();\n        int scrollY = mCircleWaveView.getScrollY();\n        switch (event.getAction()) {\n            case ACTION_DOWN:\n                if (!mScroller.isFinished()) {\n                    mScroller.abortAnimation();\n                }\n                break;\n            case MotionEvent.ACTION_MOVE:\n                if (!canSlide) {\n                    return super.onTouchEvent(event);\n                }\n                int deltaY = (int) ((mLastY - y) / damping);\n                if (mCircleWaveView.getScrollY() > mTouchSlop) {\n                    mOption = Option.LOCK;\n                } else if (mCircleWaveView.getScrollY() < -mTouchSlop) {\n                    mOption = Option.UNLOCK;\n                }\n                if (Math.abs(scrollY) > (distance - mCircleWaveView.getRadius() + mCircleView.getRadius())) {\n                    if (mOption != null) {\n                        switch (mOption) {\n                            case LOCK:\n                                if (mOnLockOperateListener != null)\n                                    mOnLockOperateListener.onLockPrepared();\n                                mCircleWaveView.setLockPrepared(true);\n                                break;\n                            case UNLOCK:\n                                if (mOnLockOperateListener != null)\n                                    mOnLockOperateListener.onUnLockPrepared();\n                                mCircleWaveView.setUnLockPrePared(true);\n                                break;\n                        }\n                    }\n                } else {\n                    mCircleWaveView.setUnLockPrePared(false);\n                    mCircleWaveView.setLockPrepared(false);\n                    mOnLockOperateListener.onNotPrepared();\n                   /* if (isLock()) {\n                        mCircleWaveView.setText(mContext.getResources().getString(R.string.device_control_unlock));\n                    } else {\n                        mCircleWaveView.setText(mContext.getResources().getString(R.string.device_control_lock));\n                    }*/\n//                    isOperating = false;\n                }\n\n                /**\n                 * 控制滑动边界\n                 */\n                int border = (distance - mCircleWaveView.getRadius() + mCircleView.getRadius()) +\n                        DensityUtils.dp2px(mContext, 25);//  可上下滑动的最大距离\n                //  当前上下滑动的距离\n                int slideHeight = deltaY + mCircleWaveView.getScrollY();\n                if (slideHeight > border) {\n                    mCircleWaveView.scrollTo(0, border);\n                    return true;\n                } else if (slideHeight + border < 0) {\n                    mCircleWaveView.scrollTo(0, -border);\n                    return true;\n                }\n                mCircleWaveView.scrollBy(0, deltaY);\n                break;\n            case MotionEvent.ACTION_UP:\n                mCircleWaveView.setUnLockPrePared(false);\n                mCircleWaveView.setLockPrepared(false);\n                scrollY = mCircleWaveView.getScrollY();\n                if (Math.abs(scrollY) > (distance - mCircleWaveView.getRadius() + mCircleView.getRadius()) && mOption != null) {\n                    switch (mOption) {\n                        case LOCK:\n                            if (mOnLockOperateListener != null)\n                                mOnLockOperateListener.onLockStart();\n                            break;\n                        case UNLOCK:\n                            if (mOnLockOperateListener != null)\n                                mOnLockOperateListener.onUnlockStart();\n                            break;\n                    }\n                }\n                mCircleWaveView.smoothScroll(0, 0);\n                break;\n        }\n        mLastY = y;\n        return super.onTouchEvent(event);\n    }\n\n```\n看到这个方法中这么多代码不知道各位是否已经懵逼？（好吧，我承认，这地方代码写的确实比较乱）不过没关系，其实细细分析来还是不难理解的！同样，我们选择比较重要的点来看。首先来看ACTION_MOVE的时候，在这里先判断了是否可以滑动（其实不可以滑动的情况下应该不会走到这个方法，但是为了严谨还是加了判断），如果不能滑动则下边的逻辑全都不会再走了。接下来\n通过判断滑动的方向来确定是要开锁还是上锁，并根据滑动距离来给出回调处理。即当中心圆CircleWaveView向上或向下滑动并完全覆盖到上/下的小圆点时则会回掉上锁就绪或者开锁就绪（onLockPrepared、onUnLockPrepared）的方法。此时释放CircleWaveView，则会回调开锁或者上锁（onLockStart、onUnlockStart）的方法。如果CircleWaveView在完全覆盖到上/下的小圆点的状态下，再向反方向滑动至未完全覆盖小圆点，此时则会回掉未就绪（onNotPrepared）的方法。下边贴一下回调接口，一共五个方法，如下：\n\n```\npublic interface  OnLockOperateListener {\n   // 上锁就绪\n   void onLockPrepared();\n   // 开锁就绪\n   void onUnLockPrepared();\n   // 开始上锁\n   void onLockStart();\n   // 开始开锁\n   void onUnlockStart();\n   // 未就绪\n   void onNotPrepared();\n}\n```\n接下来是通过一系列计算来控制CircleWaveView的滑动边界。思路大致如此：首先根据CircleWaveView和上下小圆的位置来计算出可上下滑动的最大距离border。然后计算当CircleWaveView滑动的距离超过border时就强制将其滚动到border位置，已达到固定的效果。代码如下：\n\n```\n\t/**\n      * 控制滑动边界\n      */\n    int border = (distance - mCircleWaveView.getRadius() + mCircleView.getRadius()) +\n                        DensityUtils.dp2px(mContext, 25);//  可上下滑动的最大距离\n    int deltaY = (int) ((mLastY - y) / damping);\n    //  当前上下滑动的距离\n    int slideHeight = deltaY + mCircleWaveView.getScrollY();\n    if (slideHeight > border) {\n         mCircleWaveView.scrollTo(0, border);\n         return true;\n        } else if (slideHeight + border < 0) {\n          mCircleWaveView.scrollTo(0, -border);\n          return true;\n        }\n    mCircleWaveView.scrollBy(0, deltaY);\n```\n\n然后是实现CircleWaveView的弹性滑动，这里我们给CircleWaveView加了一个弹性滑动和阻尼效果。弹性滑动是在CircleWaveView中通过Scroller来实现的，CircleWaveView暴漏出来smoothScroll的弹性滑动接口供在LockView中调用。这点我们在后面讲解CircleWaveView时再说。而阻尼滑动则是将原滑动距离除以阻尼系数以减小滑动距离从而产生阻尼效果。\n最后来看ACTION_UP，同样是根据Y轴滑动距离与滑动方向回掉对应的方法，并将CircleWaveView恢复到原位。代码如下：\n\n```\n scrollY = mCircleWaveView.getScrollY();\n if (Math.abs(scrollY) > (distance - mCircleWaveView.getRadius() + mCircleView.getRadius()) && mOption != null) {\n    switch (mOption) {\n          case LOCK:\n               if (mOnLockOperateListener != null)\n                    mOnLockOperateListener.onLockStart();\n           break;\n           case UNLOCK:\n               if (mOnLockOperateListener != null)\n                    mOnLockOperateListener.onUnlockStart();\n           break;\n     }\n mCircleWaveView.smoothScroll(0, 0);\n```\n\n\n四. 实现自定义CircleWaveView\n----------------------\n\n关于自定义CircleWaveView就不具体来讲了，因为关于自定义View都是一样的步骤。这里我们只选取几个重要的地方来说。1.CircleWaveView中内容的绘制。2.关于弹性滑动的实现。3.心跳动画的实现以及状态改变的扩散动画。\n\n**1.CircleWaveView中内容的绘制。**\n\n**绘制主体圆。**主要分为几种情况：\na.蓝牙未连接，且未能获取到网络数据，背景色为灰色。\nb.蓝牙未连接，且能获取到网络数据，背景色为淡绿色或淡红色。\nc.蓝牙已连接，开锁状态为绿色，未开锁状态为红色。\nd.上拉上锁就绪状态为深红色，下拉开锁就绪状态为深绿色。\n\n结合以上需求有如下代码：\n```\nprivate void drawCircle(Canvas canvas) {\n        mPaint.setColor(circleColor);\n        int verticalCenter = getHeight() / 2;\n        int horizontalCenter = getWidth() / 2;\n        int mRadius = Math.min(verticalCenter, horizontalCenter) - Math.min(verticalCenter, horizontalCenter) / 5;\n        radius = Math.min(verticalCenter, horizontalCenter) - Math.min(verticalCenter, horizontalCenter) / 5;\n        if (transforming) {\n            mPaint.setColor(getResources().getColor(R.color.green));\n            canvas.drawCircle(mPieCenterX, mPieCenterY, mRadius, mPaint);\n            mRadius = isLock ? transformDelta : mRadius - transformDelta;\n            mPaint.setColor(getResources().getColor(R.color.red));\n            canvas.drawCircle(mPieCenterX, mPieCenterY, mRadius, mPaint);\n        } else {\n            mRadius = mRadius - waveDelta;\n            if (!isBluetoothConnect) {\n                if (isNoNetData) {\n                    mPaint.setColor(getColor(R.color.gray));\n                } else\n                    mPaint.setColor(isLock ? getColor(R.color.redLight) : getColor(R.color.greenLight));\n            } else {\n                if (isLockPrepared) {\n                    mPaint.setColor(getColor(R.color.redDark));\n                } else if (isUnLockPrePared) {\n                    mPaint.setColor(getColor(R.color.greenDark));\n                } else {\n                    mPaint.setColor(isLock ? getColor(R.color.red) : getColor(R.color.green));\n                }\n            }\n            canvas.drawCircle(mPieCenterX, mPieCenterY, mRadius, mPaint);\n        }\n    }\n```\n \n**绘制CircleWaveView中上下箭头。**  关于箭头绘制，注释部分是通过Path来绘制的，但是发现效果不太好，绘制三角形圆角比较麻烦，所以后台改为了直接在canvas上绘制Bitmap来实现。代码如下：\n\n```\n//  绘制圆中两个三角\n    private void drawTriangle(Canvas canvas) {\n        int left = (mWidth - arrowUp.getWidth()) / 2;\n        canvas.drawBitmap(arrowUp, left, mHeight / 2 - radius + dp13, mPaint);\n        canvas.drawBitmap(arrowDown, left, mHeight / 2 + radius - dp13 - arrowDown.getHeight(), mPaint);\n        /*int radius = Math.min(mHeight, mWidth) / 2 - Math.min(mHeight, mWidth) / 8;\n        mPaintTrangel.setStyle(Paint.Style.FILL);\n        mPaintTrangel.setShadowLayer(4, 0, 3, Color.GRAY);\n        //  三角形顶点到圆边的距离\n        int h0 = DensityUtils.dp2px(mContext, 10);\n        //  三角形高\n        int h1 = DensityUtils.dp2px(mContext, 12);\n        //  三角形底边长\n        int w = DensityUtils.dp2px(mContext, 14);\n        mPaintTrangel.setColor(getResources().getColor(R.color.transparent_33));\n        mPath.moveTo(mWidth / 2, mHeight / 2 - (radius - h0));\n        mPath.lineTo(mWidth / 2 - w, mHeight / 2 - (radius - h1 - h0));\n        mPath.lineTo(mWidth / 2 + w, mHeight / 2 - (radius - h1 - h0));\n        canvas.drawPath(mPath, mPaintTrangel);\n        mPaintTrangel.setShadowLayer(4, 0, -3, Color.GRAY);\n        mPath.moveTo(mWidth / 2, mHeight / 2 + (radius - h0));\n        mPath.lineTo(mWidth / 2 - w, mHeight / 2 + (radius - h1 - h0));\n        mPath.lineTo(mWidth / 2 + w, mHeight / 2 + (radius - h1 - h0));\n        canvas.drawPath(mPath, mPaintTrangel);*/\n    }\n```\n**绘制CircleWaveView中心的文字** 中心文字分为两种情况：当蓝牙未连接时，显示为两行。当蓝牙已连接时显示为一行。绘制思路是先计算出中心基线，然后再来分情况实现。代码如下：\n\n```\n//  绘制圆中的文字\n    private void drawText(Canvas canvas) {\n        if (isConnecting) return;\n        if (TextUtils.isEmpty(mText)) { //   绘制单行文字\n            String text = mContext.getResources().getString(R.string.ble_not_connect);\n            canvas.drawText(text, mPieCenterX, getBaseline(text), mPaintText);\n            return;\n        }\n        if (isBluetoothConnect) {   //   绘制单行文字\n            canvas.drawText(mText, mPieCenterX, getBaseline(mText), mPaintText);\n        } else {    //   绘制两行文字\n            String text = mContext.getResources().getString(R.string.ble_not_connect);\n            int baseline = getBaseline(text);\n            canvas.drawText(text, mPieCenterX, baseline - 30, mPaintText);\n            mPaintText.setTextSize(DensityUtils.dp2px(mContext, 12));\n            canvas.drawText(mText, mPieCenterX, baseline + 30, mPaintText);\n        }\n    }\n\n    private int getBaseline(String text) {\n        mPaintText.setTextSize(mTextSize);\n        mPaintText.getTextBounds(text, 0, text.length(), bounds);\n        Paint.FontMetricsInt fontMetricsInt = mPaintText.getFontMetricsInt();\n        return (getMeasuredHeight() - fontMetricsInt.bottom + fontMetricsInt.top) / 2\n                - fontMetricsInt.top;\n    }\n```\n**2.关于弹性滑动的实现。** 关于滑动，通常我们会想到用ScrollTo或ScrollBy来实现。但由于这两个方法实现滑动都是瞬间完成的，因此滑动看起来会比较生硬，体验也很不好。因此想到可以使用Scroller来做一个滑动延迟实现带有弹性效果的滑动。由于Scroller本身时无法实现滑动的，因此还必须配合computeScroll方法共同完成。这里我们封装一个smoothScroll方法，提供给LockView调用。具体代码如下：\n\n```\npublic void smoothScroll(int destX, int destY) {\n        int scrollY = getScrollY();\n        int delta = destY - scrollY;\n        mScroller.startScroll(destX, scrollY, 0, delta, 400);\n        invalidate();\n    }\n\n    @Override\n    public void computeScroll() {\n        if (mScroller.computeScrollOffset()) {\n            scrollTo(mScroller.getCurrX(), mScroller.getCurrY());\n            postInvalidate();\n        }\n    }\n```\n**3.心跳动画的实现以及状态改变的扩散动画。** \n\n首先来看心跳动画的实现，这里使用属性动画，首先为ValueAnimator设置从0到1再到0的一个数值变化，并且周期时间设置为600毫秒、重复次数设置为ValueAnimator.INFINITE，即为无限次循环。通过ValueAnimator中不断变化的value来计算圆半径的大小，并通过invalidate()方法不断重绘View，从而达到一个心跳动画的效果。代码如下：\n\n```\n//  开始心跳动画\npublic void startWave() {\n        if (animator != null && animator.isRunning())\n            animator.end();\n        animator = ValueAnimator.ofFloat(0f, 1f, 0f);\n        animator.setRepeatCount(ValueAnimator.INFINITE);\n        animator.setRepeatMode(ValueAnimator.RESTART);\n        animator.setDuration(600);\n\n        animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {\n            @Override\n            public void onAnimationUpdate(ValueAnimator animation) {\n                int verticalCenter = getHeight() / 2;\n                int horizontalCenter = getWidth() / 2;\n                waveDelta = (int) (Math.min(verticalCenter, horizontalCenter) * (float) animation.getAnimatedValue() / 16);\n                invalidate();\n            }\n        });\n\n        animator.start();\n    }\n //  停止心跳动画\n public void stopWave() {\n        if (animator != null && animator.isRunning())\n            animator.end();\n    }\n```\n接下来看状态改变时扩散动画的实现，其实方法和心跳动画一样，都是采用ValueAnimator动态计算绘制圆的半径，不在赘述。参考如下代码：\n\n```\npublic void changeLockState(final boolean lock) {\n        stopWave();\n        if (this.isLock != lock) {\n            transforming = true;\n            ValueAnimator valueAnimator = ValueAnimator.ofFloat(0f, 0.99f);\n            valueAnimator.setDuration(500);\n            valueAnimator.addListener(new Animator.AnimatorListener() {\n                @Override\n                public void onAnimationStart(Animator animation) {\n\n                }\n\n                @Override\n                public void onAnimationEnd(Animator animation) {\n                    transforming = false;\n                    isLock = lock;\n                    invalidate();\n                }\n\n                @Override\n                public void onAnimationCancel(Animator animation) {\n                    transforming = false;\n                }\n\n                @Override\n                public void onAnimationRepeat(Animator animation) {\n\n                }\n            });\n            valueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {\n                @Override\n                public void onAnimationUpdate(ValueAnimator animation) {\n                    int verticalCenter = getHeight() / 2;\n                    int horizontalCenter = getWidth() / 2;\n                    transformDelta = (int) ((Math.min(verticalCenter, horizontalCenter) - Math.min(verticalCenter, horizontalCenter) / 6)\n                            * (float) animation.getAnimatedValue());\n                    invalidate();\n                }\n            });\n            valueAnimator.start();\n        }\n    }\n```\n至此，关于LockView的绘制到这里就完全结束了。回顾一下本篇文章，重讲解了自定义LockView以及弹性滑动实现，然后探讨了关于事件分发的一些知识以及使用属性动画来实现心跳和扩散效果。相信看完本篇文章的小伙伴也会有不小的收获，最后关于源码，已放在文章末尾，欢迎start、forck！\n\n\n [源码链接](https://github.com/zhpanvip/CustomView)\n","slug":"14.自定义View之弹性滑动的LockView","published":1,"updated":"2020-08-29T18:01:45.364Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckegm5nsk0015dwoz2nrn4ljo","content":"<p><strong><em>本文已发表在<a href=\"https://juejin.im/post/5d465e18518825219c280e5c\">掘金</a>，转载请注明出处。</em></strong></p>\n<p>本篇文章我们来实现一个带有弹性滑动效果的自定义View。当然，文章的侧重点是自定义View但也会涉及到View的事件分发以及一些其他方面的知识，例如使用Scroller实现带有阻尼效果的弹性滑动。因此，我相信看完这篇文章你不仅能学到自定义View的相关知识，还会了解到View的事件分发！还是老规矩，看下最终实现效果。<br><img src=\"https://raw.githubusercontent.com/zhpanvip/Resource/master/image/1401.gif\"></p>\n<p> 分析图中效果会发现其核心功能类似于一个简单的下拉刷新、上拉加载的框架，但又有区别。开始前还是先来罗列一下几个核心步骤，如下：<br>      一. 明确需求，确定对外开放的接口<br>      二. 分析滑动效果，初步实现控件布局<br>      三. 关于滑动，不得不说的事件分发<br>      四. 实现自定义CircleWaveView</p>\n<h2 id=\"一-明确需求，确定对外开放接口\"><a href=\"#一-明确需求，确定对外开放接口\" class=\"headerlink\" title=\"一. 明确需求，确定对外开放接口\"></a>一. 明确需求，确定对外开放接口</h2><p>首先应该明确控件的需求，确定有哪些功能，然后做针对性开发。这里先贴出该控件的使用方法，也是为了更好地认识控件的需求。<br><strong>1.布局文件添加</strong></p>\n<pre><code class=\"hljs vim\">&lt;RelativeLayout xmln<span class=\"hljs-variable\">s:android</span>=<span class=\"hljs-string\">&quot;http://schemas.android.com/apk/res/android&quot;</span>\n    xmln<span class=\"hljs-variable\">s:tools</span>=<span class=\"hljs-string\">&quot;http://schemas.android.com/tools&quot;</span>\n    android:layout_width=<span class=\"hljs-string\">&quot;match_parent&quot;</span>\n    android:layout_height=<span class=\"hljs-string\">&quot;match_parent&quot;</span>\n    tool<span class=\"hljs-variable\">s:context</span>=<span class=\"hljs-string\">&quot;.MainActivity&quot;</span>&gt;\n\n    &lt;<span class=\"hljs-keyword\">com</span>.zhpan.lockview.<span class=\"hljs-keyword\">view</span>.LockView\n        android:id=<span class=\"hljs-string\">&quot;@+id/lock_view&quot;</span>\n        android:layout_width=<span class=\"hljs-string\">&quot;wrap_content&quot;</span>\n        android:layout_height=<span class=\"hljs-string\">&quot;wrap_content&quot;</span>\n        android:layout_centerInParent=<span class=\"hljs-string\">&quot;true&quot;</span> /&gt;\n\n&lt;/RelativeLayout&gt;</code></pre>\n<p><strong>2.设置操作的监听事件。</strong>代码如下：</p>\n<pre><code class=\"hljs less\"><span class=\"hljs-selector-tag\">mLockView</span><span class=\"hljs-selector-class\">.setOnLockOperateListener</span>(new OnLockOperateListener() &#123;\n     <span class=\"hljs-variable\">@Override</span>\n     public void onLockPrepared() &#123;<span class=\"hljs-comment\">//  上锁就绪</span>\n         \n     &#125;\n\n     <span class=\"hljs-variable\">@Override</span>\n     public void onUnLockPrepared() &#123;<span class=\"hljs-comment\">//  开锁就绪</span>\n\n     &#125;\n\n     <span class=\"hljs-variable\">@Override</span>\n     public void onLockStart() &#123;<span class=\"hljs-comment\">// 开始上锁</span>\n\n     &#125;\n\n     <span class=\"hljs-variable\">@Override</span>\n     public void onUnlockStart() &#123;<span class=\"hljs-comment\">// 开始开锁</span>\n\n     &#125;\n\n     <span class=\"hljs-variable\">@Override</span>\n     public void onNotPrepared() &#123;<span class=\"hljs-comment\">// 上下滑动距离未达到就绪状态</span>\n\n     &#125;\n &#125;);</code></pre>\n\n<p><strong>3.对外开放接口</strong></p>\n<pre><code class=\"hljs reasonml\"><span class=\"hljs-comment\">// 设置蓝牙是否连接</span>\nmLockView.set<span class=\"hljs-constructor\">BluetoothConnect(<span class=\"hljs-params\">false</span>)</span>;\n<span class=\"hljs-comment\">// 设置上锁状态</span>\nmLockView.set<span class=\"hljs-constructor\">LockState(<span class=\"hljs-params\">isLock</span>)</span>;\n<span class=\"hljs-comment\">// 设置View是否可以滑动</span>\nmLockView.set<span class=\"hljs-constructor\">CanSlide(<span class=\"hljs-params\">true</span>)</span>\n<span class=\"hljs-comment\">// 设置滑动阻尼大小</span>\nmLockView.set<span class=\"hljs-constructor\">Damping(1.7)</span>\n<span class=\"hljs-comment\">// 设置View中心文字</span>\nmLockView.set<span class=\"hljs-constructor\">Text(<span class=\"hljs-string\">&quot;已上锁&quot;</span>)</span>;\n<span class=\"hljs-comment\">// 设置中心大圆的颜色</span>\nmLockView.setCircleColor\n<span class=\"hljs-comment\">// 开启心跳动画</span>\nmLockView.start<span class=\"hljs-constructor\">Wave()</span>;\n<span class=\"hljs-comment\">// 停止心跳动画</span>\nmLockView.stop<span class=\"hljs-constructor\">Wave()</span>;\n<span class=\"hljs-comment\">// 是否正在搜索/连接蓝牙</span>\nmLockView.connecting(<span class=\"hljs-literal\">true</span>);\n\n<span class=\"hljs-comment\">// 点击事件监听（只有在未连接蓝牙时有效）</span>\nmLockView.set<span class=\"hljs-constructor\">OnClickListener(<span class=\"hljs-params\">new</span> View.OnClickListener()</span> &#123;\n         @Override\n         public void on<span class=\"hljs-constructor\">Click(View <span class=\"hljs-params\">v</span>)</span> &#123;\n             \n         &#125;\n     &#125;);</code></pre>\n<p>我们来总结下控件中需要实现的功能：</p>\n<ol>\n<li>控件布局的实现。</li>\n<li>蓝牙未连接时，只能点击而不能滑动。</li>\n<li>点击事件以及连接中动画。</li>\n<li>更改连接状态。</li>\n<li>实现上下弹性滑动，且需要控制滑动边界。</li>\n<li>滑动事件回掉。</li>\n<li>心跳动画实现。</li>\n</ol>\n<p>以上几点就是我们要完成的核心功能，有了需求之后就直接进入主题来实现我们想要的效果吧。</p>\n<h2 id=\"二、分析控件，初步实现控件布局\"><a href=\"#二、分析控件，初步实现控件布局\" class=\"headerlink\" title=\"二、分析控件，初步实现控件布局\"></a>二、分析控件，初步实现控件布局</h2><p>分析上图的效果发现，中间的View是可滑动的，且覆盖在上下小圆点的上面。对于这种效果直接继承View实现起来会不太方便。因此我们可以想到利用自定义ViewGroup来布局页面。这么一来使开发简单了许多。那么接下来先新建一个layout_oval_lock.xml的布局为文件，并采用FrameLayout来布局控件，这样就实现了层次叠加效果，FrameLayout内部是两个自定义View，我们可以暂且搁置不管，后面会讲到如何实现。布局文件如下：</p>\n<pre><code class=\"hljs stylus\">&lt;FrameLayout xmlns:android=<span class=\"hljs-string\">&quot;http://schemas.android.com/apk/res/android&quot;</span>\n    android:layout_width=<span class=\"hljs-string\">&quot;match_parent&quot;</span>\n    android:layout_height=<span class=\"hljs-string\">&quot;match_parent&quot;</span>\n    xmlns:app=<span class=\"hljs-string\">&quot;http://schemas.android.com/apk/res-auto&quot;</span>\n    android:orientation=<span class=\"hljs-string\">&quot;vertical&quot;</span>&gt;\n\n    &lt;com<span class=\"hljs-selector-class\">.zhpan</span><span class=\"hljs-selector-class\">.lockview</span><span class=\"hljs-selector-class\">.view</span>.CircleView\n        android:id=<span class=\"hljs-string\">&quot;@+id/green_cv&quot;</span>\n        android:layout_width=<span class=\"hljs-string\">&quot;15dp&quot;</span>\n        android:layout_height=<span class=\"hljs-string\">&quot;15dp&quot;</span>\n        android:layout_marginTop=<span class=\"hljs-string\">&quot;110dp&quot;</span>\n        app:circle_color=<span class=\"hljs-string\">&quot;@color/green&quot;</span>\n        android:layout_gravity=<span class=\"hljs-string\">&quot;center&quot;</span>/&gt;\n\n    &lt;com<span class=\"hljs-selector-class\">.zhpan</span><span class=\"hljs-selector-class\">.lockview</span><span class=\"hljs-selector-class\">.view</span>.CircleView\n        android:id=<span class=\"hljs-string\">&quot;@+id/red_cv&quot;</span>\n        android:layout_width=<span class=\"hljs-string\">&quot;15dp&quot;</span>\n        android:layout_height=<span class=\"hljs-string\">&quot;15dp&quot;</span>\n        app:circle_color=<span class=\"hljs-string\">&quot;@color/red&quot;</span>\n        android:layout_marginTop=<span class=\"hljs-string\">&quot;-110dp&quot;</span>\n        android:layout_gravity=<span class=\"hljs-string\">&quot;center&quot;</span>/&gt;\n\n    &lt;com<span class=\"hljs-selector-class\">.zhpan</span><span class=\"hljs-selector-class\">.lockview</span><span class=\"hljs-selector-class\">.view</span>.CircleWaveView\n        android:id=<span class=\"hljs-string\">&quot;@+id/circle_wave_view&quot;</span>\n        android:layout_width=<span class=\"hljs-string\">&quot;220dp&quot;</span>\n        android:layout_height=<span class=\"hljs-string\">&quot;300dp&quot;</span>\n        android:layout_gravity=<span class=\"hljs-string\">&quot;center&quot;</span>\n        android:<span class=\"hljs-attribute\">padding</span>=<span class=\"hljs-string\">&quot;20dp&quot;</span>/&gt;\n\n    &lt;ProgressBar\n        android:id=<span class=\"hljs-string\">&quot;@+id/progress&quot;</span>\n        android:layout_width=<span class=\"hljs-string\">&quot;30dp&quot;</span>\n        android:layout_height=<span class=\"hljs-string\">&quot;30dp&quot;</span>\n        android:<span class=\"hljs-attribute\">visibility</span>=<span class=\"hljs-string\">&quot;gone&quot;</span>\n        android:indeterminateTint=<span class=\"hljs-string\">&quot;@color/white&quot;</span>\n        android:layout_gravity=<span class=\"hljs-string\">&quot;center&quot;</span>/&gt;\n&lt;/FrameLayout&gt;</code></pre>\n<p>接下来新建一个LockView类并继承FrameLayout。LockView与 上边layout_oval_lock的布局文件关联，并重写相应的方法。代码如下：</p>\n<pre><code class=\"hljs reasonml\">public <span class=\"hljs-constructor\">LockView(Context <span class=\"hljs-params\">context</span>)</span> &#123;\n        this(context, null);\n    &#125;\n\n    public <span class=\"hljs-constructor\">LockView(Context <span class=\"hljs-params\">context</span>, AttributeSet <span class=\"hljs-params\">attrs</span>)</span> &#123;\n        this(context, attrs, <span class=\"hljs-number\">0</span>);\n    &#125;\n\n    public <span class=\"hljs-constructor\">LockView(Context <span class=\"hljs-params\">context</span>, AttributeSet <span class=\"hljs-params\">attrs</span>, <span class=\"hljs-params\">int</span> <span class=\"hljs-params\">defStyleAttr</span>)</span> &#123;\n        super(context, attrs, defStyleAttr);\n        init(context, attrs);\n    &#125;\n\n    <span class=\"hljs-keyword\">private</span> void init(Context context, AttributeSet attrs) &#123;\n        mTouchSlop = <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">ViewConfiguration</span>.</span></span>get(context).get<span class=\"hljs-constructor\">ScaledTouchSlop()</span>;\n        View view = <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">View</span>.</span></span>inflate(context, <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">R</span>.</span></span>layout.layout_oval_lock, this);\n        mCircleWaveView = (CircleWaveView) view.find<span class=\"hljs-constructor\">ViewById(R.<span class=\"hljs-params\">id</span>.<span class=\"hljs-params\">circle_wave_view</span>)</span>;\n        mCircleView = (CircleView) view.find<span class=\"hljs-constructor\">ViewById(R.<span class=\"hljs-params\">id</span>.<span class=\"hljs-params\">green_cv</span>)</span>;\n        distance = ((LayoutParams) mCircleView.get<span class=\"hljs-constructor\">LayoutParams()</span>).topMargin;\n        mProgressBar = (ProgressBar) view.find<span class=\"hljs-constructor\">ViewById(R.<span class=\"hljs-params\">id</span>.<span class=\"hljs-params\">progress</span>)</span>;\n        mScroller = mCircleWaveView.get<span class=\"hljs-constructor\">Scroller()</span>;\n        mContext = context;\n        mCircleWaveView.set<span class=\"hljs-constructor\">OnClickListener(<span class=\"hljs-params\">new</span> OnClickListener()</span> &#123;\n            @Override\n            public void on<span class=\"hljs-constructor\">Click(View <span class=\"hljs-params\">v</span>)</span> &#123;\n            &#125;\n        &#125;);\n    &#125;\n\n    @Override\n    protected void on<span class=\"hljs-constructor\">Layout(<span class=\"hljs-params\">boolean</span> <span class=\"hljs-params\">changed</span>, <span class=\"hljs-params\">int</span> <span class=\"hljs-params\">l</span>, <span class=\"hljs-params\">int</span> <span class=\"hljs-params\">t</span>, <span class=\"hljs-params\">int</span> <span class=\"hljs-params\">r</span>, <span class=\"hljs-params\">int</span> <span class=\"hljs-params\">b</span>)</span> &#123;\n        View view = get<span class=\"hljs-constructor\">ChildAt(0)</span>;\n        view.layout(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, get<span class=\"hljs-constructor\">MeasuredWidth()</span>, get<span class=\"hljs-constructor\">MeasuredHeight()</span>);\n    &#125;\n\n    @Override\n    protected void on<span class=\"hljs-constructor\">SizeChanged(<span class=\"hljs-params\">int</span> <span class=\"hljs-params\">w</span>, <span class=\"hljs-params\">int</span> <span class=\"hljs-params\">h</span>, <span class=\"hljs-params\">int</span> <span class=\"hljs-params\">oldw</span>, <span class=\"hljs-params\">int</span> <span class=\"hljs-params\">oldh</span>)</span> &#123;\n        super.on<span class=\"hljs-constructor\">SizeChanged(<span class=\"hljs-params\">w</span>, <span class=\"hljs-params\">h</span>, <span class=\"hljs-params\">oldw</span>, <span class=\"hljs-params\">oldh</span>)</span>;\n    &#125;</code></pre>\n<h2 id=\"三-关于滑动，不得不说的事件分发\"><a href=\"#三-关于滑动，不得不说的事件分发\" class=\"headerlink\" title=\"三.关于滑动，不得不说的事件分发\"></a>三.关于滑动，不得不说的事件分发</h2><p>接下来就要来处理中心View的滑动了！说到滑动，避免不了的就应该想到Android中View的事件分发，那么对于滑动事件的处理我们需要重写三个方法。我想很多小伙伴肯定已经想到了！没错，就是事件分发的三个核心方法：dispatchTouchEvent、onInterceptTouchEvent、以及onTouchEvent。我觉得还是先简单来了解一下这三个方法吧，因为它确实挺重要的。</p>\n<ul>\n<li><strong><em>dispatchTouchEvent</em></strong>   顾名思义，这个方法就是用来对事件进行分发的。如果事件传递到了当前View，那么这个方法一定会被调用。它的返回结果受当前View的onTouchEvent或下级View的dispatchTouchEvent方法的影响，表示是否消费当前事件。</li>\n<li><strong><em>onInterceptTouchEvent</em></strong>  这个方法在dispatchTouchEvent方法的内部被调用，用来表示是否拦截某个事件。返回结果表示是否拦截当前事件。需要注意的是View并没有该方法，这个方法仅仅存在于ViewGroup中！如果事件传递到View中，那么会直接调用该View的onTouchEvent方法。</li>\n<li><strong><em>onTouchEvent</em></strong>  这个方法在dispatchTouchEvent方法中调用。用来处理点击事件。返回结果表示是否消费当前事件。View中的onTouchEvent方法默认会消费事件，只有当设置clickable和longClickable为false时则不会消费该事件。</li>\n</ul>\n<p><strong>首先来看LockView中重写的dispatchTouchEvent方法中的代码</strong>：</p>\n<pre><code class=\"hljs aspectj\"><span class=\"hljs-meta\">@Override</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">dispatchTouchEvent</span><span class=\"hljs-params\">(MotionEvent ev)</span> </span>&#123;\n    <span class=\"hljs-keyword\">if</span> (!canSlide)\n        <span class=\"hljs-keyword\">switch</span> (ev.getAction()) &#123;\n            <span class=\"hljs-keyword\">case</span> ACTION_DOWN:\n                timestamp = System.currentTimeMillis();\n                <span class=\"hljs-keyword\">break</span>;\n            <span class=\"hljs-keyword\">case</span> ACTION_UP:\n                <span class=\"hljs-keyword\">if</span> (System.currentTimeMillis() - timestamp &lt; 500) &#123;\n                    performClick();\n                    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">true</span>;\n                &#125;\n                <span class=\"hljs-keyword\">break</span>;\n        &#125;\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">super</span>.<span class=\"hljs-title\">dispatchTouchEvent</span><span class=\"hljs-params\">(ev)</span></span>;\n&#125;</code></pre>\n\n<p>上面提到，只要有事件传递到当前的ViewGroup那么dispatchTouchEvent就会首先被调用！因此在这个方法里先来判断当前是否是可以滑动状态（蓝牙未连接时不可滑动）。如果不可以滑动，那么就去处理点击事件，我们认为ACTION_DOWN和ACTION_UP之间间隔小于500毫秒就是一次点击事件，那么就在此处调用performClick方法并消费掉当前事件，如果间隔大于500毫秒，不认为是点击事件，那么紧接着就去调用父类的dispatchTouchEvent方法。如果当前可以滑动，那么同样调用父类的dispatchTouchEvent方法来处理。</p>\n<p><strong>接下来我们看重写的onInterceptTouchEvent方法</strong></p>\n<pre><code class=\"hljs angelscript\">\n@Override\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-built_in\">bool</span>ean onInterceptTouchEvent(MotionEvent ev) &#123;\n        <span class=\"hljs-built_in\">bool</span>ean <span class=\"hljs-built_in\">int</span>ercepted = <span class=\"hljs-literal\">true</span>;\n        <span class=\"hljs-built_in\">int</span> y = (<span class=\"hljs-built_in\">int</span>) ev.getY();\n        <span class=\"hljs-keyword\">switch</span> (ev.getAction()) &#123;\n            <span class=\"hljs-keyword\">case</span> ACTION_DOWN:\n                <span class=\"hljs-built_in\">int</span>ercepted = <span class=\"hljs-literal\">false</span>;\n                <span class=\"hljs-keyword\">if</span> (!mScroller.isFinished()) &#123;\n                    mScroller.abortAnimation();\n                &#125;\n                <span class=\"hljs-keyword\">break</span>;\n            <span class=\"hljs-keyword\">case</span> MotionEvent.ACTION_MOVE:\n                <span class=\"hljs-keyword\">if</span> (Math.abs(y - mLastY) &gt; mTouchSlop) &#123;\n                    <span class=\"hljs-built_in\">int</span>ercepted = <span class=\"hljs-literal\">true</span>;\n                &#125;\n                <span class=\"hljs-keyword\">break</span>;\n            <span class=\"hljs-keyword\">case</span> MotionEvent.ACTION_UP:\n                <span class=\"hljs-built_in\">int</span>ercepted = <span class=\"hljs-literal\">false</span>;\n                <span class=\"hljs-keyword\">break</span>;\n        &#125;\n        mLastY = y;\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">int</span>ercepted;\n    &#125;</code></pre>\n<p>在这个方法中我们重点来看ACTION_MOVE的时候，在这里先判断了滑动的距离是否大于mTouchSlop，这个值是认为滑动的最小距离，当大于这个值的时候就认为是滑动了。那么看此时intercepted返回了true，表示要拦截这个事件！此处拦截了这个滑动事件会怎么样呢？答案是当前View中的onTouchEvent方法被调用了！现在请将我们的目光聚焦到onTouchEvent方法中，注意前方高能！</p>\n<p><strong>核心中最核心的onTouchEvent方法</strong></p>\n<pre><code class=\"hljs reasonml\">    \n    @Override\n    public boolean on<span class=\"hljs-constructor\">TouchEvent(MotionEvent <span class=\"hljs-params\">event</span>)</span> &#123;\n\n        <span class=\"hljs-built_in\">int</span> y = (<span class=\"hljs-built_in\">int</span>) event.get<span class=\"hljs-constructor\">Y()</span>;\n        <span class=\"hljs-built_in\">int</span> scrollY = mCircleWaveView.get<span class=\"hljs-constructor\">ScrollY()</span>;\n        switch (event.get<span class=\"hljs-constructor\">Action()</span>) &#123;\n            case ACTION_DOWN:\n                <span class=\"hljs-keyword\">if</span> (!mScroller.is<span class=\"hljs-constructor\">Finished()</span>) &#123;\n                    mScroller.abort<span class=\"hljs-constructor\">Animation()</span>;\n                &#125;\n                break;\n            case MotionEvent.ACTION_MOVE:\n                <span class=\"hljs-keyword\">if</span> (!canSlide) &#123;\n                    return super.on<span class=\"hljs-constructor\">TouchEvent(<span class=\"hljs-params\">event</span>)</span>;\n                &#125;\n                <span class=\"hljs-built_in\">int</span> deltaY = (<span class=\"hljs-built_in\">int</span>) ((mLastY - y)<span class=\"hljs-operator\"> / </span>damping);\n                <span class=\"hljs-keyword\">if</span> (mCircleWaveView.get<span class=\"hljs-constructor\">ScrollY()</span> &gt; mTouchSlop) &#123;\n                    mOption = Option.LOCK;\n                &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (mCircleWaveView.get<span class=\"hljs-constructor\">ScrollY()</span> &lt; -mTouchSlop) &#123;\n                    mOption = Option.UNLOCK;\n                &#125;\n                <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">Math</span>.</span></span>abs(scrollY) &gt; (distance - mCircleWaveView.get<span class=\"hljs-constructor\">Radius()</span> + mCircleView.get<span class=\"hljs-constructor\">Radius()</span>)) &#123;\n                    <span class=\"hljs-keyword\">if</span> (mOption != null) &#123;\n                        switch (mOption) &#123;\n                            case LOCK:\n                                <span class=\"hljs-keyword\">if</span> (mOnLockOperateListener != null)\n                                    mOnLockOperateListener.on<span class=\"hljs-constructor\">LockPrepared()</span>;\n                                mCircleWaveView.set<span class=\"hljs-constructor\">LockPrepared(<span class=\"hljs-params\">true</span>)</span>;\n                                break;\n                            case UNLOCK:\n                                <span class=\"hljs-keyword\">if</span> (mOnLockOperateListener != null)\n                                    mOnLockOperateListener.on<span class=\"hljs-constructor\">UnLockPrepared()</span>;\n                                mCircleWaveView.set<span class=\"hljs-constructor\">UnLockPrePared(<span class=\"hljs-params\">true</span>)</span>;\n                                break;\n                        &#125;\n                    &#125;\n                &#125; <span class=\"hljs-keyword\">else</span> &#123;\n                    mCircleWaveView.set<span class=\"hljs-constructor\">UnLockPrePared(<span class=\"hljs-params\">false</span>)</span>;\n                    mCircleWaveView.set<span class=\"hljs-constructor\">LockPrepared(<span class=\"hljs-params\">false</span>)</span>;\n                    mOnLockOperateListener.on<span class=\"hljs-constructor\">NotPrepared()</span>;\n                   <span class=\"hljs-comment\">/* if (isLock()) &#123;</span>\n<span class=\"hljs-comment\">                        mCircleWaveView.setText(mContext.getResources().getString(R.string.device_control_unlock));</span>\n<span class=\"hljs-comment\">                    &#125; else &#123;</span>\n<span class=\"hljs-comment\">                        mCircleWaveView.setText(mContext.getResources().getString(R.string.device_control_lock));</span>\n<span class=\"hljs-comment\">                    &#125;*/</span>\n<span class=\"hljs-comment\">//                    isOperating = false;</span>\n                &#125;\n\n                <span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">                 * 控制滑动边界</span>\n<span class=\"hljs-comment\">                 */</span>\n                <span class=\"hljs-built_in\">int</span> border = (distance - mCircleWaveView.get<span class=\"hljs-constructor\">Radius()</span> + mCircleView.get<span class=\"hljs-constructor\">Radius()</span>) +\n                        <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">DensityUtils</span>.</span></span>dp2px(mContext, <span class=\"hljs-number\">25</span>);<span class=\"hljs-comment\">//  可上下滑动的最大距离</span>\n                <span class=\"hljs-comment\">//  当前上下滑动的距离</span>\n                <span class=\"hljs-built_in\">int</span> slideHeight = deltaY + mCircleWaveView.get<span class=\"hljs-constructor\">ScrollY()</span>;\n                <span class=\"hljs-keyword\">if</span> (slideHeight &gt; border) &#123;\n                    mCircleWaveView.scroll<span class=\"hljs-constructor\">To(0, <span class=\"hljs-params\">border</span>)</span>;\n                    return <span class=\"hljs-literal\">true</span>;\n                &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (slideHeight + border &lt; <span class=\"hljs-number\">0</span>) &#123;\n                    mCircleWaveView.scroll<span class=\"hljs-constructor\">To(0, -<span class=\"hljs-params\">border</span>)</span>;\n                    return <span class=\"hljs-literal\">true</span>;\n                &#125;\n                mCircleWaveView.scroll<span class=\"hljs-constructor\">By(0, <span class=\"hljs-params\">deltaY</span>)</span>;\n                break;\n            case MotionEvent.ACTION_UP:\n                mCircleWaveView.set<span class=\"hljs-constructor\">UnLockPrePared(<span class=\"hljs-params\">false</span>)</span>;\n                mCircleWaveView.set<span class=\"hljs-constructor\">LockPrepared(<span class=\"hljs-params\">false</span>)</span>;\n                scrollY = mCircleWaveView.get<span class=\"hljs-constructor\">ScrollY()</span>;\n                <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">Math</span>.</span></span>abs(scrollY) &gt; (distance - mCircleWaveView.get<span class=\"hljs-constructor\">Radius()</span> + mCircleView.get<span class=\"hljs-constructor\">Radius()</span>)<span class=\"hljs-operator\"> &amp;&amp; </span>mOption != null) &#123;\n                    switch (mOption) &#123;\n                        case LOCK:\n                            <span class=\"hljs-keyword\">if</span> (mOnLockOperateListener != null)\n                                mOnLockOperateListener.on<span class=\"hljs-constructor\">LockStart()</span>;\n                            break;\n                        case UNLOCK:\n                            <span class=\"hljs-keyword\">if</span> (mOnLockOperateListener != null)\n                                mOnLockOperateListener.on<span class=\"hljs-constructor\">UnlockStart()</span>;\n                            break;\n                    &#125;\n                &#125;\n                mCircleWaveView.smooth<span class=\"hljs-constructor\">Scroll(0, 0)</span>;\n                break;\n        &#125;\n        mLastY = y;\n        return super.on<span class=\"hljs-constructor\">TouchEvent(<span class=\"hljs-params\">event</span>)</span>;\n    &#125;\n</code></pre>\n<p>看到这个方法中这么多代码不知道各位是否已经懵逼？（好吧，我承认，这地方代码写的确实比较乱）不过没关系，其实细细分析来还是不难理解的！同样，我们选择比较重要的点来看。首先来看ACTION_MOVE的时候，在这里先判断了是否可以滑动（其实不可以滑动的情况下应该不会走到这个方法，但是为了严谨还是加了判断），如果不能滑动则下边的逻辑全都不会再走了。接下来<br>通过判断滑动的方向来确定是要开锁还是上锁，并根据滑动距离来给出回调处理。即当中心圆CircleWaveView向上或向下滑动并完全覆盖到上/下的小圆点时则会回掉上锁就绪或者开锁就绪（onLockPrepared、onUnLockPrepared）的方法。此时释放CircleWaveView，则会回调开锁或者上锁（onLockStart、onUnlockStart）的方法。如果CircleWaveView在完全覆盖到上/下的小圆点的状态下，再向反方向滑动至未完全覆盖小圆点，此时则会回掉未就绪（onNotPrepared）的方法。下边贴一下回调接口，一共五个方法，如下：</p>\n<pre><code class=\"hljs csharp\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">interface</span>  <span class=\"hljs-title\">OnLockOperateListener</span> &#123;\n   <span class=\"hljs-comment\">// 上锁就绪</span>\n   <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onLockPrepared</span>(<span class=\"hljs-params\"></span>)</span>;\n   <span class=\"hljs-comment\">// 开锁就绪</span>\n   <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onUnLockPrepared</span>(<span class=\"hljs-params\"></span>)</span>;\n   <span class=\"hljs-comment\">// 开始上锁</span>\n   <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onLockStart</span>(<span class=\"hljs-params\"></span>)</span>;\n   <span class=\"hljs-comment\">// 开始开锁</span>\n   <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onUnlockStart</span>(<span class=\"hljs-params\"></span>)</span>;\n   <span class=\"hljs-comment\">// 未就绪</span>\n   <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onNotPrepared</span>(<span class=\"hljs-params\"></span>)</span>;\n&#125;</code></pre>\n<p>接下来是通过一系列计算来控制CircleWaveView的滑动边界。思路大致如此：首先根据CircleWaveView和上下小圆的位置来计算出可上下滑动的最大距离border。然后计算当CircleWaveView滑动的距离超过border时就强制将其滚动到border位置，已达到固定的效果。代码如下：</p>\n<pre><code class=\"hljs reasonml\"><span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">     * 控制滑动边界</span>\n<span class=\"hljs-comment\">     */</span>\n   <span class=\"hljs-built_in\">int</span> border = (distance - mCircleWaveView.get<span class=\"hljs-constructor\">Radius()</span> + mCircleView.get<span class=\"hljs-constructor\">Radius()</span>) +\n                       <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">DensityUtils</span>.</span></span>dp2px(mContext, <span class=\"hljs-number\">25</span>);<span class=\"hljs-comment\">//  可上下滑动的最大距离</span>\n   <span class=\"hljs-built_in\">int</span> deltaY = (<span class=\"hljs-built_in\">int</span>) ((mLastY - y)<span class=\"hljs-operator\"> / </span>damping);\n   <span class=\"hljs-comment\">//  当前上下滑动的距离</span>\n   <span class=\"hljs-built_in\">int</span> slideHeight = deltaY + mCircleWaveView.get<span class=\"hljs-constructor\">ScrollY()</span>;\n   <span class=\"hljs-keyword\">if</span> (slideHeight &gt; border) &#123;\n        mCircleWaveView.scroll<span class=\"hljs-constructor\">To(0, <span class=\"hljs-params\">border</span>)</span>;\n        return <span class=\"hljs-literal\">true</span>;\n       &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (slideHeight + border &lt; <span class=\"hljs-number\">0</span>) &#123;\n         mCircleWaveView.scroll<span class=\"hljs-constructor\">To(0, -<span class=\"hljs-params\">border</span>)</span>;\n         return <span class=\"hljs-literal\">true</span>;\n       &#125;\n   mCircleWaveView.scroll<span class=\"hljs-constructor\">By(0, <span class=\"hljs-params\">deltaY</span>)</span>;</code></pre>\n\n<p>然后是实现CircleWaveView的弹性滑动，这里我们给CircleWaveView加了一个弹性滑动和阻尼效果。弹性滑动是在CircleWaveView中通过Scroller来实现的，CircleWaveView暴漏出来smoothScroll的弹性滑动接口供在LockView中调用。这点我们在后面讲解CircleWaveView时再说。而阻尼滑动则是将原滑动距离除以阻尼系数以减小滑动距离从而产生阻尼效果。<br>最后来看ACTION_UP，同样是根据Y轴滑动距离与滑动方向回掉对应的方法，并将CircleWaveView恢复到原位。代码如下：</p>\n<pre><code class=\"hljs yaml\"><span class=\"hljs-string\">scrollY</span> <span class=\"hljs-string\">=</span> <span class=\"hljs-string\">mCircleWaveView.getScrollY();</span>\n<span class=\"hljs-string\">if</span> <span class=\"hljs-string\">(Math.abs(scrollY)</span> <span class=\"hljs-string\">&gt;</span> <span class=\"hljs-string\">(distance</span> <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">mCircleWaveView.getRadius()</span> <span class=\"hljs-string\">+</span> <span class=\"hljs-string\">mCircleView.getRadius())</span> <span class=\"hljs-string\">&amp;&amp;</span> <span class=\"hljs-string\">mOption</span> <span class=\"hljs-type\">!=</span> <span class=\"hljs-literal\">null</span><span class=\"hljs-string\">)</span> &#123;\n   <span class=\"hljs-string\">switch</span> <span class=\"hljs-string\">(mOption)</span> &#123;\n         <span class=\"hljs-attr\">case LOCK:</span>\n              <span class=\"hljs-string\">if</span> <span class=\"hljs-string\">(mOnLockOperateListener</span> <span class=\"hljs-type\">!=</span> <span class=\"hljs-literal\">null</span><span class=\"hljs-string\">)</span>\n                   <span class=\"hljs-string\">mOnLockOperateListener.onLockStart();</span>\n          <span class=\"hljs-string\">break;</span>\n          <span class=\"hljs-attr\">case UNLOCK:</span>\n              <span class=\"hljs-string\">if</span> <span class=\"hljs-string\">(mOnLockOperateListener</span> <span class=\"hljs-type\">!=</span> <span class=\"hljs-literal\">null</span><span class=\"hljs-string\">)</span>\n                   <span class=\"hljs-string\">mOnLockOperateListener.onUnlockStart();</span>\n          <span class=\"hljs-string\">break;</span>\n    &#125;\n<span class=\"hljs-string\">mCircleWaveView.smoothScroll(0</span>, <span class=\"hljs-number\">0</span><span class=\"hljs-string\">);</span></code></pre>\n\n\n<h2 id=\"四-实现自定义CircleWaveView\"><a href=\"#四-实现自定义CircleWaveView\" class=\"headerlink\" title=\"四. 实现自定义CircleWaveView\"></a>四. 实现自定义CircleWaveView</h2><p>关于自定义CircleWaveView就不具体来讲了，因为关于自定义View都是一样的步骤。这里我们只选取几个重要的地方来说。1.CircleWaveView中内容的绘制。2.关于弹性滑动的实现。3.心跳动画的实现以及状态改变的扩散动画。</p>\n<p><strong>1.CircleWaveView中内容的绘制。</strong></p>\n<p><strong>绘制主体圆。</strong>主要分为几种情况：<br>a.蓝牙未连接，且未能获取到网络数据，背景色为灰色。<br>b.蓝牙未连接，且能获取到网络数据，背景色为淡绿色或淡红色。<br>c.蓝牙已连接，开锁状态为绿色，未开锁状态为红色。<br>d.上拉上锁就绪状态为深红色，下拉开锁就绪状态为深绿色。</p>\n<p>结合以上需求有如下代码：</p>\n<pre><code class=\"hljs reasonml\"><span class=\"hljs-keyword\">private</span> void draw<span class=\"hljs-constructor\">Circle(Canvas <span class=\"hljs-params\">canvas</span>)</span> &#123;\n        mPaint.set<span class=\"hljs-constructor\">Color(<span class=\"hljs-params\">circleColor</span>)</span>;\n        <span class=\"hljs-built_in\">int</span> verticalCenter = get<span class=\"hljs-constructor\">Height()</span><span class=\"hljs-operator\"> / </span><span class=\"hljs-number\">2</span>;\n        <span class=\"hljs-built_in\">int</span> horizontalCenter = get<span class=\"hljs-constructor\">Width()</span><span class=\"hljs-operator\"> / </span><span class=\"hljs-number\">2</span>;\n        <span class=\"hljs-built_in\">int</span> mRadius = <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">Math</span>.</span></span>min(verticalCenter, horizontalCenter) - <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">Math</span>.</span></span>min(verticalCenter, horizontalCenter)<span class=\"hljs-operator\"> / </span><span class=\"hljs-number\">5</span>;\n        radius = <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">Math</span>.</span></span>min(verticalCenter, horizontalCenter) - <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">Math</span>.</span></span>min(verticalCenter, horizontalCenter)<span class=\"hljs-operator\"> / </span><span class=\"hljs-number\">5</span>;\n        <span class=\"hljs-keyword\">if</span> (transforming) &#123;\n            mPaint.set<span class=\"hljs-constructor\">Color(<span class=\"hljs-params\">getResources</span>()</span>.get<span class=\"hljs-constructor\">Color(R.<span class=\"hljs-params\">color</span>.<span class=\"hljs-params\">green</span>)</span>);\n            canvas.draw<span class=\"hljs-constructor\">Circle(<span class=\"hljs-params\">mPieCenterX</span>, <span class=\"hljs-params\">mPieCenterY</span>, <span class=\"hljs-params\">mRadius</span>, <span class=\"hljs-params\">mPaint</span>)</span>;\n            mRadius = isLock ? transformDelta : mRadius - transformDelta;\n            mPaint.set<span class=\"hljs-constructor\">Color(<span class=\"hljs-params\">getResources</span>()</span>.get<span class=\"hljs-constructor\">Color(R.<span class=\"hljs-params\">color</span>.<span class=\"hljs-params\">red</span>)</span>);\n            canvas.draw<span class=\"hljs-constructor\">Circle(<span class=\"hljs-params\">mPieCenterX</span>, <span class=\"hljs-params\">mPieCenterY</span>, <span class=\"hljs-params\">mRadius</span>, <span class=\"hljs-params\">mPaint</span>)</span>;\n        &#125; <span class=\"hljs-keyword\">else</span> &#123;\n            mRadius = mRadius - waveDelta;\n            <span class=\"hljs-keyword\">if</span> (!isBluetoothConnect) &#123;\n                <span class=\"hljs-keyword\">if</span> (isNoNetData) &#123;\n                    mPaint.set<span class=\"hljs-constructor\">Color(<span class=\"hljs-params\">getColor</span>(R.<span class=\"hljs-params\">color</span>.<span class=\"hljs-params\">gray</span>)</span>);\n                &#125; <span class=\"hljs-keyword\">else</span>\n                    mPaint.set<span class=\"hljs-constructor\">Color(<span class=\"hljs-params\">isLock</span> ? <span class=\"hljs-params\">getColor</span>(R.<span class=\"hljs-params\">color</span>.<span class=\"hljs-params\">redLight</span>)</span> : get<span class=\"hljs-constructor\">Color(R.<span class=\"hljs-params\">color</span>.<span class=\"hljs-params\">greenLight</span>)</span>);\n            &#125; <span class=\"hljs-keyword\">else</span> &#123;\n                <span class=\"hljs-keyword\">if</span> (isLockPrepared) &#123;\n                    mPaint.set<span class=\"hljs-constructor\">Color(<span class=\"hljs-params\">getColor</span>(R.<span class=\"hljs-params\">color</span>.<span class=\"hljs-params\">redDark</span>)</span>);\n                &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (isUnLockPrePared) &#123;\n                    mPaint.set<span class=\"hljs-constructor\">Color(<span class=\"hljs-params\">getColor</span>(R.<span class=\"hljs-params\">color</span>.<span class=\"hljs-params\">greenDark</span>)</span>);\n                &#125; <span class=\"hljs-keyword\">else</span> &#123;\n                    mPaint.set<span class=\"hljs-constructor\">Color(<span class=\"hljs-params\">isLock</span> ? <span class=\"hljs-params\">getColor</span>(R.<span class=\"hljs-params\">color</span>.<span class=\"hljs-params\">red</span>)</span> : get<span class=\"hljs-constructor\">Color(R.<span class=\"hljs-params\">color</span>.<span class=\"hljs-params\">green</span>)</span>);\n                &#125;\n            &#125;\n            canvas.draw<span class=\"hljs-constructor\">Circle(<span class=\"hljs-params\">mPieCenterX</span>, <span class=\"hljs-params\">mPieCenterY</span>, <span class=\"hljs-params\">mRadius</span>, <span class=\"hljs-params\">mPaint</span>)</span>;\n        &#125;\n    &#125;</code></pre>\n\n<p><strong>绘制CircleWaveView中上下箭头。</strong>  关于箭头绘制，注释部分是通过Path来绘制的，但是发现效果不太好，绘制三角形圆角比较麻烦，所以后台改为了直接在canvas上绘制Bitmap来实现。代码如下：</p>\n<pre><code class=\"hljs yaml\"><span class=\"hljs-string\">//</span>  <span class=\"hljs-string\">绘制圆中两个三角</span>\n    <span class=\"hljs-string\">private</span> <span class=\"hljs-string\">void</span> <span class=\"hljs-string\">drawTriangle(Canvas</span> <span class=\"hljs-string\">canvas)</span> &#123;\n        <span class=\"hljs-string\">int</span> <span class=\"hljs-string\">left</span> <span class=\"hljs-string\">=</span> <span class=\"hljs-string\">(mWidth</span> <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">arrowUp.getWidth())</span> <span class=\"hljs-string\">/</span> <span class=\"hljs-number\">2</span><span class=\"hljs-string\">;</span>\n        <span class=\"hljs-string\">canvas.drawBitmap(arrowUp</span>, <span class=\"hljs-string\">left</span>, <span class=\"hljs-string\">mHeight</span> <span class=\"hljs-string\">/</span> <span class=\"hljs-number\">2</span> <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">radius</span> <span class=\"hljs-string\">+</span> <span class=\"hljs-string\">dp13</span>, <span class=\"hljs-string\">mPaint);</span>\n        <span class=\"hljs-string\">canvas.drawBitmap(arrowDown</span>, <span class=\"hljs-string\">left</span>, <span class=\"hljs-string\">mHeight</span> <span class=\"hljs-string\">/</span> <span class=\"hljs-number\">2</span> <span class=\"hljs-string\">+</span> <span class=\"hljs-string\">radius</span> <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">dp13</span> <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">arrowDown.getHeight()</span>, <span class=\"hljs-string\">mPaint);</span>\n        <span class=\"hljs-string\">/*int</span> <span class=\"hljs-string\">radius</span> <span class=\"hljs-string\">=</span> <span class=\"hljs-string\">Math.min(mHeight</span>, <span class=\"hljs-string\">mWidth)</span> <span class=\"hljs-string\">/</span> <span class=\"hljs-number\">2</span> <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">Math.min(mHeight</span>, <span class=\"hljs-string\">mWidth)</span> <span class=\"hljs-string\">/</span> <span class=\"hljs-number\">8</span><span class=\"hljs-string\">;</span>\n        <span class=\"hljs-string\">mPaintTrangel.setStyle(Paint.Style.FILL);</span>\n        <span class=\"hljs-string\">mPaintTrangel.setShadowLayer(4</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-string\">Color.GRAY);</span>\n        <span class=\"hljs-string\">//</span>  <span class=\"hljs-string\">三角形顶点到圆边的距离</span>\n        <span class=\"hljs-string\">int</span> <span class=\"hljs-string\">h0</span> <span class=\"hljs-string\">=</span> <span class=\"hljs-string\">DensityUtils.dp2px(mContext</span>, <span class=\"hljs-number\">10</span><span class=\"hljs-string\">);</span>\n        <span class=\"hljs-string\">//</span>  <span class=\"hljs-string\">三角形高</span>\n        <span class=\"hljs-string\">int</span> <span class=\"hljs-string\">h1</span> <span class=\"hljs-string\">=</span> <span class=\"hljs-string\">DensityUtils.dp2px(mContext</span>, <span class=\"hljs-number\">12</span><span class=\"hljs-string\">);</span>\n        <span class=\"hljs-string\">//</span>  <span class=\"hljs-string\">三角形底边长</span>\n        <span class=\"hljs-string\">int</span> <span class=\"hljs-string\">w</span> <span class=\"hljs-string\">=</span> <span class=\"hljs-string\">DensityUtils.dp2px(mContext</span>, <span class=\"hljs-number\">14</span><span class=\"hljs-string\">);</span>\n        <span class=\"hljs-string\">mPaintTrangel.setColor(getResources().getColor(R.color.transparent_33));</span>\n        <span class=\"hljs-string\">mPath.moveTo(mWidth</span> <span class=\"hljs-string\">/</span> <span class=\"hljs-number\">2</span>, <span class=\"hljs-string\">mHeight</span> <span class=\"hljs-string\">/</span> <span class=\"hljs-number\">2</span> <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">(radius</span> <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">h0));</span>\n        <span class=\"hljs-string\">mPath.lineTo(mWidth</span> <span class=\"hljs-string\">/</span> <span class=\"hljs-number\">2</span> <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">w</span>, <span class=\"hljs-string\">mHeight</span> <span class=\"hljs-string\">/</span> <span class=\"hljs-number\">2</span> <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">(radius</span> <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">h1</span> <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">h0));</span>\n        <span class=\"hljs-string\">mPath.lineTo(mWidth</span> <span class=\"hljs-string\">/</span> <span class=\"hljs-number\">2</span> <span class=\"hljs-string\">+</span> <span class=\"hljs-string\">w</span>, <span class=\"hljs-string\">mHeight</span> <span class=\"hljs-string\">/</span> <span class=\"hljs-number\">2</span> <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">(radius</span> <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">h1</span> <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">h0));</span>\n        <span class=\"hljs-string\">canvas.drawPath(mPath</span>, <span class=\"hljs-string\">mPaintTrangel);</span>\n        <span class=\"hljs-string\">mPaintTrangel.setShadowLayer(4</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">-3</span>, <span class=\"hljs-string\">Color.GRAY);</span>\n        <span class=\"hljs-string\">mPath.moveTo(mWidth</span> <span class=\"hljs-string\">/</span> <span class=\"hljs-number\">2</span>, <span class=\"hljs-string\">mHeight</span> <span class=\"hljs-string\">/</span> <span class=\"hljs-number\">2</span> <span class=\"hljs-string\">+</span> <span class=\"hljs-string\">(radius</span> <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">h0));</span>\n        <span class=\"hljs-string\">mPath.lineTo(mWidth</span> <span class=\"hljs-string\">/</span> <span class=\"hljs-number\">2</span> <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">w</span>, <span class=\"hljs-string\">mHeight</span> <span class=\"hljs-string\">/</span> <span class=\"hljs-number\">2</span> <span class=\"hljs-string\">+</span> <span class=\"hljs-string\">(radius</span> <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">h1</span> <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">h0));</span>\n        <span class=\"hljs-string\">mPath.lineTo(mWidth</span> <span class=\"hljs-string\">/</span> <span class=\"hljs-number\">2</span> <span class=\"hljs-string\">+</span> <span class=\"hljs-string\">w</span>, <span class=\"hljs-string\">mHeight</span> <span class=\"hljs-string\">/</span> <span class=\"hljs-number\">2</span> <span class=\"hljs-string\">+</span> <span class=\"hljs-string\">(radius</span> <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">h1</span> <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">h0));</span>\n        <span class=\"hljs-string\">canvas.drawPath(mPath</span>, <span class=\"hljs-string\">mPaintTrangel);*/</span>\n    &#125;</code></pre>\n<p><strong>绘制CircleWaveView中心的文字</strong> 中心文字分为两种情况：当蓝牙未连接时，显示为两行。当蓝牙已连接时显示为一行。绘制思路是先计算出中心基线，然后再来分情况实现。代码如下：</p>\n<pre><code class=\"hljs reasonml\"><span class=\"hljs-comment\">//  绘制圆中的文字</span>\n    <span class=\"hljs-keyword\">private</span> void draw<span class=\"hljs-constructor\">Text(Canvas <span class=\"hljs-params\">canvas</span>)</span> &#123;\n        <span class=\"hljs-keyword\">if</span> (isConnecting) return;\n        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">TextUtils</span>.</span></span>is<span class=\"hljs-constructor\">Empty(<span class=\"hljs-params\">mText</span>)</span>) &#123; <span class=\"hljs-comment\">//   绘制单行文字</span>\n            String text = mContext.get<span class=\"hljs-constructor\">Resources()</span>.get<span class=\"hljs-constructor\">String(R.<span class=\"hljs-params\">string</span>.<span class=\"hljs-params\">ble_not_connect</span>)</span>;\n            canvas.draw<span class=\"hljs-constructor\">Text(<span class=\"hljs-params\">text</span>, <span class=\"hljs-params\">mPieCenterX</span>, <span class=\"hljs-params\">getBaseline</span>(<span class=\"hljs-params\">text</span>)</span>, mPaintText);\n            return;\n        &#125;\n        <span class=\"hljs-keyword\">if</span> (isBluetoothConnect) &#123;   <span class=\"hljs-comment\">//   绘制单行文字</span>\n            canvas.draw<span class=\"hljs-constructor\">Text(<span class=\"hljs-params\">mText</span>, <span class=\"hljs-params\">mPieCenterX</span>, <span class=\"hljs-params\">getBaseline</span>(<span class=\"hljs-params\">mText</span>)</span>, mPaintText);\n        &#125; <span class=\"hljs-keyword\">else</span> &#123;    <span class=\"hljs-comment\">//   绘制两行文字</span>\n            String text = mContext.get<span class=\"hljs-constructor\">Resources()</span>.get<span class=\"hljs-constructor\">String(R.<span class=\"hljs-params\">string</span>.<span class=\"hljs-params\">ble_not_connect</span>)</span>;\n            <span class=\"hljs-built_in\">int</span> baseline = get<span class=\"hljs-constructor\">Baseline(<span class=\"hljs-params\">text</span>)</span>;\n            canvas.draw<span class=\"hljs-constructor\">Text(<span class=\"hljs-params\">text</span>, <span class=\"hljs-params\">mPieCenterX</span>, <span class=\"hljs-params\">baseline</span> - 30, <span class=\"hljs-params\">mPaintText</span>)</span>;\n            mPaintText.set<span class=\"hljs-constructor\">TextSize(DensityUtils.<span class=\"hljs-params\">dp2px</span>(<span class=\"hljs-params\">mContext</span>, 12)</span>);\n            canvas.draw<span class=\"hljs-constructor\">Text(<span class=\"hljs-params\">mText</span>, <span class=\"hljs-params\">mPieCenterX</span>, <span class=\"hljs-params\">baseline</span> + 30, <span class=\"hljs-params\">mPaintText</span>)</span>;\n        &#125;\n    &#125;\n\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-built_in\">int</span> get<span class=\"hljs-constructor\">Baseline(String <span class=\"hljs-params\">text</span>)</span> &#123;\n        mPaintText.set<span class=\"hljs-constructor\">TextSize(<span class=\"hljs-params\">mTextSize</span>)</span>;\n        mPaintText.get<span class=\"hljs-constructor\">TextBounds(<span class=\"hljs-params\">text</span>, 0, <span class=\"hljs-params\">text</span>.<span class=\"hljs-params\">length</span>()</span>, bounds);\n        Paint.FontMetricsInt fontMetricsInt = mPaintText.get<span class=\"hljs-constructor\">FontMetricsInt()</span>;\n        return (get<span class=\"hljs-constructor\">MeasuredHeight()</span> - fontMetricsInt.bottom + fontMetricsInt.top)<span class=\"hljs-operator\"> / </span><span class=\"hljs-number\">2</span>\n                - fontMetricsInt.top;\n    &#125;</code></pre>\n<p><strong>2.关于弹性滑动的实现。</strong> 关于滑动，通常我们会想到用ScrollTo或ScrollBy来实现。但由于这两个方法实现滑动都是瞬间完成的，因此滑动看起来会比较生硬，体验也很不好。因此想到可以使用Scroller来做一个滑动延迟实现带有弹性效果的滑动。由于Scroller本身时无法实现滑动的，因此还必须配合computeScroll方法共同完成。这里我们封装一个smoothScroll方法，提供给LockView调用。具体代码如下：</p>\n<pre><code class=\"hljs reasonml\">public void smooth<span class=\"hljs-constructor\">Scroll(<span class=\"hljs-params\">int</span> <span class=\"hljs-params\">destX</span>, <span class=\"hljs-params\">int</span> <span class=\"hljs-params\">destY</span>)</span> &#123;\n        <span class=\"hljs-built_in\">int</span> scrollY = get<span class=\"hljs-constructor\">ScrollY()</span>;\n        <span class=\"hljs-built_in\">int</span> delta = destY - scrollY;\n        mScroller.start<span class=\"hljs-constructor\">Scroll(<span class=\"hljs-params\">destX</span>, <span class=\"hljs-params\">scrollY</span>, 0, <span class=\"hljs-params\">delta</span>, 400)</span>;\n        invalidate<span class=\"hljs-literal\">()</span>;\n    &#125;\n\n    @Override\n    public void compute<span class=\"hljs-constructor\">Scroll()</span> &#123;\n        <span class=\"hljs-keyword\">if</span> (mScroller.compute<span class=\"hljs-constructor\">ScrollOffset()</span>) &#123;\n            scroll<span class=\"hljs-constructor\">To(<span class=\"hljs-params\">mScroller</span>.<span class=\"hljs-params\">getCurrX</span>()</span>, mScroller.get<span class=\"hljs-constructor\">CurrY()</span>);\n            post<span class=\"hljs-constructor\">Invalidate()</span>;\n        &#125;\n    &#125;</code></pre>\n<p><strong>3.心跳动画的实现以及状态改变的扩散动画。</strong> </p>\n<p>首先来看心跳动画的实现，这里使用属性动画，首先为ValueAnimator设置从0到1再到0的一个数值变化，并且周期时间设置为600毫秒、重复次数设置为ValueAnimator.INFINITE，即为无限次循环。通过ValueAnimator中不断变化的value来计算圆半径的大小，并通过invalidate()方法不断重绘View，从而达到一个心跳动画的效果。代码如下：</p>\n<pre><code class=\"hljs reasonml\"><span class=\"hljs-comment\">//  开始心跳动画</span>\npublic void start<span class=\"hljs-constructor\">Wave()</span> &#123;\n        <span class=\"hljs-keyword\">if</span> (animator != null<span class=\"hljs-operator\"> &amp;&amp; </span>animator.is<span class=\"hljs-constructor\">Running()</span>)\n            animator.<span class=\"hljs-keyword\">end</span><span class=\"hljs-literal\">()</span>;\n        animator = <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">ValueAnimator</span>.</span></span><span class=\"hljs-keyword\">of</span><span class=\"hljs-constructor\">Float(0f, 1f, 0f)</span>;\n        animator.set<span class=\"hljs-constructor\">RepeatCount(ValueAnimator.INFINITE)</span>;\n        animator.set<span class=\"hljs-constructor\">RepeatMode(ValueAnimator.RESTART)</span>;\n        animator.set<span class=\"hljs-constructor\">Duration(600)</span>;\n\n        animator.add<span class=\"hljs-constructor\">UpdateListener(<span class=\"hljs-params\">new</span> ValueAnimator.AnimatorUpdateListener()</span> &#123;\n            @Override\n            public void on<span class=\"hljs-constructor\">AnimationUpdate(ValueAnimator <span class=\"hljs-params\">animation</span>)</span> &#123;\n                <span class=\"hljs-built_in\">int</span> verticalCenter = get<span class=\"hljs-constructor\">Height()</span><span class=\"hljs-operator\"> / </span><span class=\"hljs-number\">2</span>;\n                <span class=\"hljs-built_in\">int</span> horizontalCenter = get<span class=\"hljs-constructor\">Width()</span><span class=\"hljs-operator\"> / </span><span class=\"hljs-number\">2</span>;\n                waveDelta = (<span class=\"hljs-built_in\">int</span>) (<span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">Math</span>.</span></span>min(verticalCenter, horizontalCenter)<span class=\"hljs-operator\"> * </span>(<span class=\"hljs-built_in\">float</span>) animation.get<span class=\"hljs-constructor\">AnimatedValue()</span><span class=\"hljs-operator\"> / </span><span class=\"hljs-number\">16</span>);\n                invalidate<span class=\"hljs-literal\">()</span>;\n            &#125;\n        &#125;);\n\n        animator.start<span class=\"hljs-literal\">()</span>;\n    &#125;\n <span class=\"hljs-comment\">//  停止心跳动画</span>\n public void stop<span class=\"hljs-constructor\">Wave()</span> &#123;\n        <span class=\"hljs-keyword\">if</span> (animator != null<span class=\"hljs-operator\"> &amp;&amp; </span>animator.is<span class=\"hljs-constructor\">Running()</span>)\n            animator.<span class=\"hljs-keyword\">end</span><span class=\"hljs-literal\">()</span>;\n    &#125;</code></pre>\n<p>接下来看状态改变时扩散动画的实现，其实方法和心跳动画一样，都是采用ValueAnimator动态计算绘制圆的半径，不在赘述。参考如下代码：</p>\n<pre><code class=\"hljs reasonml\">public void change<span class=\"hljs-constructor\">LockState(<span class=\"hljs-params\">final</span> <span class=\"hljs-params\">boolean</span> <span class=\"hljs-params\">lock</span>)</span> &#123;\n        stop<span class=\"hljs-constructor\">Wave()</span>;\n        <span class=\"hljs-keyword\">if</span> (this.isLock != lock) &#123;\n            transforming = <span class=\"hljs-literal\">true</span>;\n            ValueAnimator valueAnimator = <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">ValueAnimator</span>.</span></span><span class=\"hljs-keyword\">of</span><span class=\"hljs-constructor\">Float(0f, 0.99f)</span>;\n            valueAnimator.set<span class=\"hljs-constructor\">Duration(500)</span>;\n            valueAnimator.add<span class=\"hljs-constructor\">Listener(<span class=\"hljs-params\">new</span> Animator.AnimatorListener()</span> &#123;\n                @Override\n                public void on<span class=\"hljs-constructor\">AnimationStart(Animator <span class=\"hljs-params\">animation</span>)</span> &#123;\n\n                &#125;\n\n                @Override\n                public void on<span class=\"hljs-constructor\">AnimationEnd(Animator <span class=\"hljs-params\">animation</span>)</span> &#123;\n                    transforming = <span class=\"hljs-literal\">false</span>;\n                    isLock = lock;\n                    invalidate<span class=\"hljs-literal\">()</span>;\n                &#125;\n\n                @Override\n                public void on<span class=\"hljs-constructor\">AnimationCancel(Animator <span class=\"hljs-params\">animation</span>)</span> &#123;\n                    transforming = <span class=\"hljs-literal\">false</span>;\n                &#125;\n\n                @Override\n                public void on<span class=\"hljs-constructor\">AnimationRepeat(Animator <span class=\"hljs-params\">animation</span>)</span> &#123;\n\n                &#125;\n            &#125;);\n            valueAnimator.add<span class=\"hljs-constructor\">UpdateListener(<span class=\"hljs-params\">new</span> ValueAnimator.AnimatorUpdateListener()</span> &#123;\n                @Override\n                public void on<span class=\"hljs-constructor\">AnimationUpdate(ValueAnimator <span class=\"hljs-params\">animation</span>)</span> &#123;\n                    <span class=\"hljs-built_in\">int</span> verticalCenter = get<span class=\"hljs-constructor\">Height()</span><span class=\"hljs-operator\"> / </span><span class=\"hljs-number\">2</span>;\n                    <span class=\"hljs-built_in\">int</span> horizontalCenter = get<span class=\"hljs-constructor\">Width()</span><span class=\"hljs-operator\"> / </span><span class=\"hljs-number\">2</span>;\n                    transformDelta = (<span class=\"hljs-built_in\">int</span>) ((<span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">Math</span>.</span></span>min(verticalCenter, horizontalCenter) - <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">Math</span>.</span></span>min(verticalCenter, horizontalCenter)<span class=\"hljs-operator\"> / </span><span class=\"hljs-number\">6</span>)\n<span class=\"hljs-operator\">                            * </span>(<span class=\"hljs-built_in\">float</span>) animation.get<span class=\"hljs-constructor\">AnimatedValue()</span>);\n                    invalidate<span class=\"hljs-literal\">()</span>;\n                &#125;\n            &#125;);\n            valueAnimator.start<span class=\"hljs-literal\">()</span>;\n        &#125;\n    &#125;</code></pre>\n<p>至此，关于LockView的绘制到这里就完全结束了。回顾一下本篇文章，重讲解了自定义LockView以及弹性滑动实现，然后探讨了关于事件分发的一些知识以及使用属性动画来实现心跳和扩散效果。相信看完本篇文章的小伙伴也会有不小的收获，最后关于源码，已放在文章末尾，欢迎start、forck！</p>\n<p> <a href=\"https://github.com/zhpanvip/CustomView\">源码链接</a></p>\n","site":{"data":{"fluid_config":{"favicon":"/img/favicon.png","apple_touch_icon":"/img/favicon.png","title_join_string":" - ","force_https":false,"highlight":{"enable":true,"style":"Github Gist","bg_color":false,"copy_btn":true},"fun_features":{"typing":{"enable":true,"typeSpeed":70,"cursorChar":"|","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"mouse_click":{"enable":false,"style":"values"}},"dark_mode":{"enable":true,"default":"auto"},"color":{"body_bg_color":"#eee","body_bg_color_dark":"#181c27","navbar_bg_color":"#2f4154","navbar_bg_color_dark":"#1f3144","navbar_text_color":"#fff","navbar_text_color_dark":"#d0d0d0","text_color":"#3c4858","text_color_dark":"#c4c6c9","sec_text_color":"#718096","sec_text_color_dark":"#a7a9ad","post_text_color":"#2c3e50","post_text_color_dark":"#c4c6c9","post_heading_color":"#1a202c","post_heading_color_dark":"#c4c6c9","post_link_color":"#0366d6","post_link_color_dark":"#1589e9","link_hover_color":"#30a9de","link_hover_color_dark":"#30a9de","link_hover_bg_color":"#f8f9fa","link_hover_bg_color_dark":"#364151","board_color":"#fff","board_color_dark":"#252d38"},"font":{"font_size":"16px","font_family":null,"code_font_size":"85%"},"custom_js":null,"custom_css":null,"custom_html":"","web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"tajs":null,"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}},"lazyload":{"enable":true,"onlypost":false},"daovoice":{"enable":false,"appid":""},"aplayer":{"enable":false,"autoplay":false,"loop":"all","order":"random","theme":"#b7daff","songs":[{"name":"name","artist":"artist","url":"/songs/test.mp3","cover":"/img/cover.jpg"},{"name":"name","artist":"artist","url":"https://...url.mp3","cover":"https://...cover.jpg"}]},"version":{"check":false},"navbar":{"blog_title":"zhangpan","ground_glass":{"enable":false,"px":3,"alpha":0.7},"menu":[{"key":"home","link":"/","icon":"iconfont icon-home-fill"},{"key":"archive","link":"/archives/","icon":"iconfont icon-archive-fill"},{"key":"category","link":"/categories/","icon":"iconfont icon-category-fill"},{"key":"tag","link":"/tags/","icon":"iconfont icon-tags-fill"},{"key":"about","link":"/about/","icon":"iconfont icon-user-fill"}]},"search":{"enable":true,"path":"/local-search.xml","generate_path":"/local-search.xml","field":"post","content":true},"scroll_down_arrow":{"enable":true,"banner_height_limit":90,"scroll_after_turning_page":true},"banner_parallax":true,"footer":{"statistics":{"enable":false,"source":"busuanzi","pv_format":"总访问量 {} 次","uv_format":"总访客数 {} 人"},"beian":{"enable":false,"icp_text":"京ICP证123456号","police_text":"京公网安备12345678号","police_code":12345678,"police_icon":"/img/police_beian.png"}},"scroll_top_arrow":{"enable":true},"index":{"banner_img":"/img/default.png","banner_img_height":100,"banner_mask_alpha":0.3,"post_default_img":"","slogan":{"enable":true,"text":"Talk is cheap, show me the code."},"auto_excerpt":{"enable":true},"post_url_target":"_self","post_meta":{"date":true,"category":true,"tag":true}},"page":{"banner_img":"/img/default.png","banner_img_height":60,"banner_mask_alpha":0.3},"post":{"banner_img":"/img/default.png","banner_img_height":70,"banner_mask_alpha":0.3,"meta":{"date":{"enable":true,"format":"LL a"},"wordcount":{"enable":true,"format":"{} 字"},"min2read":{"enable":true,"format":"{} 分钟","words":100},"views":{"enable":false,"source":"busuanzi","format":"{} 次"}},"updated":{"enable":false,"content":"本文最后更新于：","relative":false},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"copyright":{"enable":true,"content":"本博客所有文章除特别声明外，均采用 <a href=\"https://creativecommons.org/licenses/by-sa/4.0/deed.zh\" rel=\"nofollow noopener\">CC BY-SA 4.0 协议</a> ，转载请注明出处！ <h5>开源库推荐</h5> <a href=\"https://github.com/zhpanvip/BannerViewPager\">1.BannerViewPager</a> <p> 一个基于ViewPager2实现的具有强大功能的无限轮播库。支持多种页面切换效果和指示器样式。 </p>\n<a href=\"https://github.com/zhpanvip/viewpagerindicator\">2.ViewPagerIndicator</a> <p> 一个适用于ViewPager和ViewPager2的指示器，支持多种滑块样式及滑动模式 </p>"},"prev_next":{"enable":true},"custom":{"enable":false,"content":"<img src=\"https://octodex.github.com/images/jetpacktocat.png\" class=\"rounded mx-auto d-block mt-5\" style=\"width:150px; height:150px;\">"},"image_zoom":{"enable":true},"footnote":{"enable":true,"header":""},"math":{"enable":false,"specific":false,"engine":"mathjax"},"mermaid":{"enable":false,"specific":false,"options":{"theme":"default"}},"comments":{"enable":true,"type":"utterances"}},"utterances":{"repo":"zhpanvip/utterances-comment","issue_term":"pathname","label":"utterances","theme":"github-light","crossorigin":"anonymous"},"disqus":{"shortname":null,"disqusjs":false,"apikey":null},"gitalk":{"clientID":null,"clientSecret":null,"repo":null,"owner":null,"admin":["name"],"id":"location.pathname","language":"zh-CN","labels":["Gitalk"],"perPage":10,"pagerDirection":"last","distractionFreeMode":false,"createIssueManually":true},"valine":{"appid":"hXIROaIM5y9qnieojJRWP5hS","appkey":"y0f3w3aqd1MF7JL9ma4WECTy","placeholder":"说点什么","path":"window.location.pathname","avatar":"retro","meta":["nick","mail","link"],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"https://zhangpan.site"},"changyan":{"appid":"","appkey":""},"livere":{"uid":""},"archive":{"banner_img":"/img/bg_article.jpg","banner_img_height":60,"banner_mask_alpha":0.3,"subtitle":null},"category":{"banner_img":"/img/bg_default.png","banner_img_height":60,"banner_mask_alpha":0.3,"subtitle":null,"post_limit":10,"order_by":"-length"},"tag":{"banner_img":"/img/bg_label.jpg","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null,"tagcloud":{"min_font":15,"max_font":30,"unit":"px","start_color":"#BBBBEE","end_color":"#337ab7"}},"about":{"banner_img":"/img/bg_default.png","banner_img_height":60,"banner_mask_alpha":0.3,"subtitle":null,"avatar":"/img/avatar.png","name":"myname","introduce":"一句简短的介绍","icons":[{"class":"iconfont icon-github-fill","link":"https://github.com","tip":"GitHub"},{"class":"iconfont icon-douban-fill","link":"https://douban.com","tip":"豆瓣"},{"class":"iconfont icon-wechat-fill","qrcode":"/img/favicon.png"}]},"page404":{"banner_img":"/img/default.png","banner_img_height":85,"banner_mask_alpha":0.3,"subtitle":"Page not found"},"links":{"banner_img":"/img/default.png","banner_img_height":60,"banner_mask_alpha":0.3,"subtitle":null,"items":[{"title":"Fluid Docs","intro":"主题使用指南","link":"https://hexo.fluid-dev.com/docs/","image":"/img/favicon.png"},{"title":"Fluid Repo","intro":"主题 GitHub 仓库","link":"https://github.com/fluid-dev/hexo-theme-fluid","image":"/img/favicon.png"},{"title":"Fluid Example","intro":"主题操作示例","link":"https://hexo.fluid-dev.com/docs/example/","image":"/img/favicon.png"}]}}}},"excerpt":"","more":"<p><strong><em>本文已发表在<a href=\"https://juejin.im/post/5d465e18518825219c280e5c\">掘金</a>，转载请注明出处。</em></strong></p>\n<p>本篇文章我们来实现一个带有弹性滑动效果的自定义View。当然，文章的侧重点是自定义View但也会涉及到View的事件分发以及一些其他方面的知识，例如使用Scroller实现带有阻尼效果的弹性滑动。因此，我相信看完这篇文章你不仅能学到自定义View的相关知识，还会了解到View的事件分发！还是老规矩，看下最终实现效果。<br><img src=\"https://raw.githubusercontent.com/zhpanvip/Resource/master/image/1401.gif\"></p>\n<p> 分析图中效果会发现其核心功能类似于一个简单的下拉刷新、上拉加载的框架，但又有区别。开始前还是先来罗列一下几个核心步骤，如下：<br>      一. 明确需求，确定对外开放的接口<br>      二. 分析滑动效果，初步实现控件布局<br>      三. 关于滑动，不得不说的事件分发<br>      四. 实现自定义CircleWaveView</p>\n<h2 id=\"一-明确需求，确定对外开放接口\"><a href=\"#一-明确需求，确定对外开放接口\" class=\"headerlink\" title=\"一. 明确需求，确定对外开放接口\"></a>一. 明确需求，确定对外开放接口</h2><p>首先应该明确控件的需求，确定有哪些功能，然后做针对性开发。这里先贴出该控件的使用方法，也是为了更好地认识控件的需求。<br><strong>1.布局文件添加</strong></p>\n<pre><code class=\"hljs vim\">&lt;RelativeLayout xmln<span class=\"hljs-variable\">s:android</span>=<span class=\"hljs-string\">&quot;http://schemas.android.com/apk/res/android&quot;</span>\n    xmln<span class=\"hljs-variable\">s:tools</span>=<span class=\"hljs-string\">&quot;http://schemas.android.com/tools&quot;</span>\n    android:layout_width=<span class=\"hljs-string\">&quot;match_parent&quot;</span>\n    android:layout_height=<span class=\"hljs-string\">&quot;match_parent&quot;</span>\n    tool<span class=\"hljs-variable\">s:context</span>=<span class=\"hljs-string\">&quot;.MainActivity&quot;</span>&gt;\n\n    &lt;<span class=\"hljs-keyword\">com</span>.zhpan.lockview.<span class=\"hljs-keyword\">view</span>.LockView\n        android:id=<span class=\"hljs-string\">&quot;@+id/lock_view&quot;</span>\n        android:layout_width=<span class=\"hljs-string\">&quot;wrap_content&quot;</span>\n        android:layout_height=<span class=\"hljs-string\">&quot;wrap_content&quot;</span>\n        android:layout_centerInParent=<span class=\"hljs-string\">&quot;true&quot;</span> /&gt;\n\n&lt;/RelativeLayout&gt;</code></pre>\n<p><strong>2.设置操作的监听事件。</strong>代码如下：</p>\n<pre><code class=\"hljs less\"><span class=\"hljs-selector-tag\">mLockView</span><span class=\"hljs-selector-class\">.setOnLockOperateListener</span>(new OnLockOperateListener() &#123;\n     <span class=\"hljs-variable\">@Override</span>\n     public void onLockPrepared() &#123;<span class=\"hljs-comment\">//  上锁就绪</span>\n         \n     &#125;\n\n     <span class=\"hljs-variable\">@Override</span>\n     public void onUnLockPrepared() &#123;<span class=\"hljs-comment\">//  开锁就绪</span>\n\n     &#125;\n\n     <span class=\"hljs-variable\">@Override</span>\n     public void onLockStart() &#123;<span class=\"hljs-comment\">// 开始上锁</span>\n\n     &#125;\n\n     <span class=\"hljs-variable\">@Override</span>\n     public void onUnlockStart() &#123;<span class=\"hljs-comment\">// 开始开锁</span>\n\n     &#125;\n\n     <span class=\"hljs-variable\">@Override</span>\n     public void onNotPrepared() &#123;<span class=\"hljs-comment\">// 上下滑动距离未达到就绪状态</span>\n\n     &#125;\n &#125;);</code></pre>\n\n<p><strong>3.对外开放接口</strong></p>\n<pre><code class=\"hljs reasonml\"><span class=\"hljs-comment\">// 设置蓝牙是否连接</span>\nmLockView.set<span class=\"hljs-constructor\">BluetoothConnect(<span class=\"hljs-params\">false</span>)</span>;\n<span class=\"hljs-comment\">// 设置上锁状态</span>\nmLockView.set<span class=\"hljs-constructor\">LockState(<span class=\"hljs-params\">isLock</span>)</span>;\n<span class=\"hljs-comment\">// 设置View是否可以滑动</span>\nmLockView.set<span class=\"hljs-constructor\">CanSlide(<span class=\"hljs-params\">true</span>)</span>\n<span class=\"hljs-comment\">// 设置滑动阻尼大小</span>\nmLockView.set<span class=\"hljs-constructor\">Damping(1.7)</span>\n<span class=\"hljs-comment\">// 设置View中心文字</span>\nmLockView.set<span class=\"hljs-constructor\">Text(<span class=\"hljs-string\">&quot;已上锁&quot;</span>)</span>;\n<span class=\"hljs-comment\">// 设置中心大圆的颜色</span>\nmLockView.setCircleColor\n<span class=\"hljs-comment\">// 开启心跳动画</span>\nmLockView.start<span class=\"hljs-constructor\">Wave()</span>;\n<span class=\"hljs-comment\">// 停止心跳动画</span>\nmLockView.stop<span class=\"hljs-constructor\">Wave()</span>;\n<span class=\"hljs-comment\">// 是否正在搜索/连接蓝牙</span>\nmLockView.connecting(<span class=\"hljs-literal\">true</span>);\n\n<span class=\"hljs-comment\">// 点击事件监听（只有在未连接蓝牙时有效）</span>\nmLockView.set<span class=\"hljs-constructor\">OnClickListener(<span class=\"hljs-params\">new</span> View.OnClickListener()</span> &#123;\n         @Override\n         public void on<span class=\"hljs-constructor\">Click(View <span class=\"hljs-params\">v</span>)</span> &#123;\n             \n         &#125;\n     &#125;);</code></pre>\n<p>我们来总结下控件中需要实现的功能：</p>\n<ol>\n<li>控件布局的实现。</li>\n<li>蓝牙未连接时，只能点击而不能滑动。</li>\n<li>点击事件以及连接中动画。</li>\n<li>更改连接状态。</li>\n<li>实现上下弹性滑动，且需要控制滑动边界。</li>\n<li>滑动事件回掉。</li>\n<li>心跳动画实现。</li>\n</ol>\n<p>以上几点就是我们要完成的核心功能，有了需求之后就直接进入主题来实现我们想要的效果吧。</p>\n<h2 id=\"二、分析控件，初步实现控件布局\"><a href=\"#二、分析控件，初步实现控件布局\" class=\"headerlink\" title=\"二、分析控件，初步实现控件布局\"></a>二、分析控件，初步实现控件布局</h2><p>分析上图的效果发现，中间的View是可滑动的，且覆盖在上下小圆点的上面。对于这种效果直接继承View实现起来会不太方便。因此我们可以想到利用自定义ViewGroup来布局页面。这么一来使开发简单了许多。那么接下来先新建一个layout_oval_lock.xml的布局为文件，并采用FrameLayout来布局控件，这样就实现了层次叠加效果，FrameLayout内部是两个自定义View，我们可以暂且搁置不管，后面会讲到如何实现。布局文件如下：</p>\n<pre><code class=\"hljs stylus\">&lt;FrameLayout xmlns:android=<span class=\"hljs-string\">&quot;http://schemas.android.com/apk/res/android&quot;</span>\n    android:layout_width=<span class=\"hljs-string\">&quot;match_parent&quot;</span>\n    android:layout_height=<span class=\"hljs-string\">&quot;match_parent&quot;</span>\n    xmlns:app=<span class=\"hljs-string\">&quot;http://schemas.android.com/apk/res-auto&quot;</span>\n    android:orientation=<span class=\"hljs-string\">&quot;vertical&quot;</span>&gt;\n\n    &lt;com<span class=\"hljs-selector-class\">.zhpan</span><span class=\"hljs-selector-class\">.lockview</span><span class=\"hljs-selector-class\">.view</span>.CircleView\n        android:id=<span class=\"hljs-string\">&quot;@+id/green_cv&quot;</span>\n        android:layout_width=<span class=\"hljs-string\">&quot;15dp&quot;</span>\n        android:layout_height=<span class=\"hljs-string\">&quot;15dp&quot;</span>\n        android:layout_marginTop=<span class=\"hljs-string\">&quot;110dp&quot;</span>\n        app:circle_color=<span class=\"hljs-string\">&quot;@color/green&quot;</span>\n        android:layout_gravity=<span class=\"hljs-string\">&quot;center&quot;</span>/&gt;\n\n    &lt;com<span class=\"hljs-selector-class\">.zhpan</span><span class=\"hljs-selector-class\">.lockview</span><span class=\"hljs-selector-class\">.view</span>.CircleView\n        android:id=<span class=\"hljs-string\">&quot;@+id/red_cv&quot;</span>\n        android:layout_width=<span class=\"hljs-string\">&quot;15dp&quot;</span>\n        android:layout_height=<span class=\"hljs-string\">&quot;15dp&quot;</span>\n        app:circle_color=<span class=\"hljs-string\">&quot;@color/red&quot;</span>\n        android:layout_marginTop=<span class=\"hljs-string\">&quot;-110dp&quot;</span>\n        android:layout_gravity=<span class=\"hljs-string\">&quot;center&quot;</span>/&gt;\n\n    &lt;com<span class=\"hljs-selector-class\">.zhpan</span><span class=\"hljs-selector-class\">.lockview</span><span class=\"hljs-selector-class\">.view</span>.CircleWaveView\n        android:id=<span class=\"hljs-string\">&quot;@+id/circle_wave_view&quot;</span>\n        android:layout_width=<span class=\"hljs-string\">&quot;220dp&quot;</span>\n        android:layout_height=<span class=\"hljs-string\">&quot;300dp&quot;</span>\n        android:layout_gravity=<span class=\"hljs-string\">&quot;center&quot;</span>\n        android:<span class=\"hljs-attribute\">padding</span>=<span class=\"hljs-string\">&quot;20dp&quot;</span>/&gt;\n\n    &lt;ProgressBar\n        android:id=<span class=\"hljs-string\">&quot;@+id/progress&quot;</span>\n        android:layout_width=<span class=\"hljs-string\">&quot;30dp&quot;</span>\n        android:layout_height=<span class=\"hljs-string\">&quot;30dp&quot;</span>\n        android:<span class=\"hljs-attribute\">visibility</span>=<span class=\"hljs-string\">&quot;gone&quot;</span>\n        android:indeterminateTint=<span class=\"hljs-string\">&quot;@color/white&quot;</span>\n        android:layout_gravity=<span class=\"hljs-string\">&quot;center&quot;</span>/&gt;\n&lt;/FrameLayout&gt;</code></pre>\n<p>接下来新建一个LockView类并继承FrameLayout。LockView与 上边layout_oval_lock的布局文件关联，并重写相应的方法。代码如下：</p>\n<pre><code class=\"hljs reasonml\">public <span class=\"hljs-constructor\">LockView(Context <span class=\"hljs-params\">context</span>)</span> &#123;\n        this(context, null);\n    &#125;\n\n    public <span class=\"hljs-constructor\">LockView(Context <span class=\"hljs-params\">context</span>, AttributeSet <span class=\"hljs-params\">attrs</span>)</span> &#123;\n        this(context, attrs, <span class=\"hljs-number\">0</span>);\n    &#125;\n\n    public <span class=\"hljs-constructor\">LockView(Context <span class=\"hljs-params\">context</span>, AttributeSet <span class=\"hljs-params\">attrs</span>, <span class=\"hljs-params\">int</span> <span class=\"hljs-params\">defStyleAttr</span>)</span> &#123;\n        super(context, attrs, defStyleAttr);\n        init(context, attrs);\n    &#125;\n\n    <span class=\"hljs-keyword\">private</span> void init(Context context, AttributeSet attrs) &#123;\n        mTouchSlop = <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">ViewConfiguration</span>.</span></span>get(context).get<span class=\"hljs-constructor\">ScaledTouchSlop()</span>;\n        View view = <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">View</span>.</span></span>inflate(context, <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">R</span>.</span></span>layout.layout_oval_lock, this);\n        mCircleWaveView = (CircleWaveView) view.find<span class=\"hljs-constructor\">ViewById(R.<span class=\"hljs-params\">id</span>.<span class=\"hljs-params\">circle_wave_view</span>)</span>;\n        mCircleView = (CircleView) view.find<span class=\"hljs-constructor\">ViewById(R.<span class=\"hljs-params\">id</span>.<span class=\"hljs-params\">green_cv</span>)</span>;\n        distance = ((LayoutParams) mCircleView.get<span class=\"hljs-constructor\">LayoutParams()</span>).topMargin;\n        mProgressBar = (ProgressBar) view.find<span class=\"hljs-constructor\">ViewById(R.<span class=\"hljs-params\">id</span>.<span class=\"hljs-params\">progress</span>)</span>;\n        mScroller = mCircleWaveView.get<span class=\"hljs-constructor\">Scroller()</span>;\n        mContext = context;\n        mCircleWaveView.set<span class=\"hljs-constructor\">OnClickListener(<span class=\"hljs-params\">new</span> OnClickListener()</span> &#123;\n            @Override\n            public void on<span class=\"hljs-constructor\">Click(View <span class=\"hljs-params\">v</span>)</span> &#123;\n            &#125;\n        &#125;);\n    &#125;\n\n    @Override\n    protected void on<span class=\"hljs-constructor\">Layout(<span class=\"hljs-params\">boolean</span> <span class=\"hljs-params\">changed</span>, <span class=\"hljs-params\">int</span> <span class=\"hljs-params\">l</span>, <span class=\"hljs-params\">int</span> <span class=\"hljs-params\">t</span>, <span class=\"hljs-params\">int</span> <span class=\"hljs-params\">r</span>, <span class=\"hljs-params\">int</span> <span class=\"hljs-params\">b</span>)</span> &#123;\n        View view = get<span class=\"hljs-constructor\">ChildAt(0)</span>;\n        view.layout(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, get<span class=\"hljs-constructor\">MeasuredWidth()</span>, get<span class=\"hljs-constructor\">MeasuredHeight()</span>);\n    &#125;\n\n    @Override\n    protected void on<span class=\"hljs-constructor\">SizeChanged(<span class=\"hljs-params\">int</span> <span class=\"hljs-params\">w</span>, <span class=\"hljs-params\">int</span> <span class=\"hljs-params\">h</span>, <span class=\"hljs-params\">int</span> <span class=\"hljs-params\">oldw</span>, <span class=\"hljs-params\">int</span> <span class=\"hljs-params\">oldh</span>)</span> &#123;\n        super.on<span class=\"hljs-constructor\">SizeChanged(<span class=\"hljs-params\">w</span>, <span class=\"hljs-params\">h</span>, <span class=\"hljs-params\">oldw</span>, <span class=\"hljs-params\">oldh</span>)</span>;\n    &#125;</code></pre>\n<h2 id=\"三-关于滑动，不得不说的事件分发\"><a href=\"#三-关于滑动，不得不说的事件分发\" class=\"headerlink\" title=\"三.关于滑动，不得不说的事件分发\"></a>三.关于滑动，不得不说的事件分发</h2><p>接下来就要来处理中心View的滑动了！说到滑动，避免不了的就应该想到Android中View的事件分发，那么对于滑动事件的处理我们需要重写三个方法。我想很多小伙伴肯定已经想到了！没错，就是事件分发的三个核心方法：dispatchTouchEvent、onInterceptTouchEvent、以及onTouchEvent。我觉得还是先简单来了解一下这三个方法吧，因为它确实挺重要的。</p>\n<ul>\n<li><strong><em>dispatchTouchEvent</em></strong>   顾名思义，这个方法就是用来对事件进行分发的。如果事件传递到了当前View，那么这个方法一定会被调用。它的返回结果受当前View的onTouchEvent或下级View的dispatchTouchEvent方法的影响，表示是否消费当前事件。</li>\n<li><strong><em>onInterceptTouchEvent</em></strong>  这个方法在dispatchTouchEvent方法的内部被调用，用来表示是否拦截某个事件。返回结果表示是否拦截当前事件。需要注意的是View并没有该方法，这个方法仅仅存在于ViewGroup中！如果事件传递到View中，那么会直接调用该View的onTouchEvent方法。</li>\n<li><strong><em>onTouchEvent</em></strong>  这个方法在dispatchTouchEvent方法中调用。用来处理点击事件。返回结果表示是否消费当前事件。View中的onTouchEvent方法默认会消费事件，只有当设置clickable和longClickable为false时则不会消费该事件。</li>\n</ul>\n<p><strong>首先来看LockView中重写的dispatchTouchEvent方法中的代码</strong>：</p>\n<pre><code class=\"hljs aspectj\"><span class=\"hljs-meta\">@Override</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">dispatchTouchEvent</span><span class=\"hljs-params\">(MotionEvent ev)</span> </span>&#123;\n    <span class=\"hljs-keyword\">if</span> (!canSlide)\n        <span class=\"hljs-keyword\">switch</span> (ev.getAction()) &#123;\n            <span class=\"hljs-keyword\">case</span> ACTION_DOWN:\n                timestamp = System.currentTimeMillis();\n                <span class=\"hljs-keyword\">break</span>;\n            <span class=\"hljs-keyword\">case</span> ACTION_UP:\n                <span class=\"hljs-keyword\">if</span> (System.currentTimeMillis() - timestamp &lt; 500) &#123;\n                    performClick();\n                    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">true</span>;\n                &#125;\n                <span class=\"hljs-keyword\">break</span>;\n        &#125;\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">super</span>.<span class=\"hljs-title\">dispatchTouchEvent</span><span class=\"hljs-params\">(ev)</span></span>;\n&#125;</code></pre>\n\n<p>上面提到，只要有事件传递到当前的ViewGroup那么dispatchTouchEvent就会首先被调用！因此在这个方法里先来判断当前是否是可以滑动状态（蓝牙未连接时不可滑动）。如果不可以滑动，那么就去处理点击事件，我们认为ACTION_DOWN和ACTION_UP之间间隔小于500毫秒就是一次点击事件，那么就在此处调用performClick方法并消费掉当前事件，如果间隔大于500毫秒，不认为是点击事件，那么紧接着就去调用父类的dispatchTouchEvent方法。如果当前可以滑动，那么同样调用父类的dispatchTouchEvent方法来处理。</p>\n<p><strong>接下来我们看重写的onInterceptTouchEvent方法</strong></p>\n<pre><code class=\"hljs angelscript\">\n@Override\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-built_in\">bool</span>ean onInterceptTouchEvent(MotionEvent ev) &#123;\n        <span class=\"hljs-built_in\">bool</span>ean <span class=\"hljs-built_in\">int</span>ercepted = <span class=\"hljs-literal\">true</span>;\n        <span class=\"hljs-built_in\">int</span> y = (<span class=\"hljs-built_in\">int</span>) ev.getY();\n        <span class=\"hljs-keyword\">switch</span> (ev.getAction()) &#123;\n            <span class=\"hljs-keyword\">case</span> ACTION_DOWN:\n                <span class=\"hljs-built_in\">int</span>ercepted = <span class=\"hljs-literal\">false</span>;\n                <span class=\"hljs-keyword\">if</span> (!mScroller.isFinished()) &#123;\n                    mScroller.abortAnimation();\n                &#125;\n                <span class=\"hljs-keyword\">break</span>;\n            <span class=\"hljs-keyword\">case</span> MotionEvent.ACTION_MOVE:\n                <span class=\"hljs-keyword\">if</span> (Math.abs(y - mLastY) &gt; mTouchSlop) &#123;\n                    <span class=\"hljs-built_in\">int</span>ercepted = <span class=\"hljs-literal\">true</span>;\n                &#125;\n                <span class=\"hljs-keyword\">break</span>;\n            <span class=\"hljs-keyword\">case</span> MotionEvent.ACTION_UP:\n                <span class=\"hljs-built_in\">int</span>ercepted = <span class=\"hljs-literal\">false</span>;\n                <span class=\"hljs-keyword\">break</span>;\n        &#125;\n        mLastY = y;\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">int</span>ercepted;\n    &#125;</code></pre>\n<p>在这个方法中我们重点来看ACTION_MOVE的时候，在这里先判断了滑动的距离是否大于mTouchSlop，这个值是认为滑动的最小距离，当大于这个值的时候就认为是滑动了。那么看此时intercepted返回了true，表示要拦截这个事件！此处拦截了这个滑动事件会怎么样呢？答案是当前View中的onTouchEvent方法被调用了！现在请将我们的目光聚焦到onTouchEvent方法中，注意前方高能！</p>\n<p><strong>核心中最核心的onTouchEvent方法</strong></p>\n<pre><code class=\"hljs reasonml\">    \n    @Override\n    public boolean on<span class=\"hljs-constructor\">TouchEvent(MotionEvent <span class=\"hljs-params\">event</span>)</span> &#123;\n\n        <span class=\"hljs-built_in\">int</span> y = (<span class=\"hljs-built_in\">int</span>) event.get<span class=\"hljs-constructor\">Y()</span>;\n        <span class=\"hljs-built_in\">int</span> scrollY = mCircleWaveView.get<span class=\"hljs-constructor\">ScrollY()</span>;\n        switch (event.get<span class=\"hljs-constructor\">Action()</span>) &#123;\n            case ACTION_DOWN:\n                <span class=\"hljs-keyword\">if</span> (!mScroller.is<span class=\"hljs-constructor\">Finished()</span>) &#123;\n                    mScroller.abort<span class=\"hljs-constructor\">Animation()</span>;\n                &#125;\n                break;\n            case MotionEvent.ACTION_MOVE:\n                <span class=\"hljs-keyword\">if</span> (!canSlide) &#123;\n                    return super.on<span class=\"hljs-constructor\">TouchEvent(<span class=\"hljs-params\">event</span>)</span>;\n                &#125;\n                <span class=\"hljs-built_in\">int</span> deltaY = (<span class=\"hljs-built_in\">int</span>) ((mLastY - y)<span class=\"hljs-operator\"> / </span>damping);\n                <span class=\"hljs-keyword\">if</span> (mCircleWaveView.get<span class=\"hljs-constructor\">ScrollY()</span> &gt; mTouchSlop) &#123;\n                    mOption = Option.LOCK;\n                &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (mCircleWaveView.get<span class=\"hljs-constructor\">ScrollY()</span> &lt; -mTouchSlop) &#123;\n                    mOption = Option.UNLOCK;\n                &#125;\n                <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">Math</span>.</span></span>abs(scrollY) &gt; (distance - mCircleWaveView.get<span class=\"hljs-constructor\">Radius()</span> + mCircleView.get<span class=\"hljs-constructor\">Radius()</span>)) &#123;\n                    <span class=\"hljs-keyword\">if</span> (mOption != null) &#123;\n                        switch (mOption) &#123;\n                            case LOCK:\n                                <span class=\"hljs-keyword\">if</span> (mOnLockOperateListener != null)\n                                    mOnLockOperateListener.on<span class=\"hljs-constructor\">LockPrepared()</span>;\n                                mCircleWaveView.set<span class=\"hljs-constructor\">LockPrepared(<span class=\"hljs-params\">true</span>)</span>;\n                                break;\n                            case UNLOCK:\n                                <span class=\"hljs-keyword\">if</span> (mOnLockOperateListener != null)\n                                    mOnLockOperateListener.on<span class=\"hljs-constructor\">UnLockPrepared()</span>;\n                                mCircleWaveView.set<span class=\"hljs-constructor\">UnLockPrePared(<span class=\"hljs-params\">true</span>)</span>;\n                                break;\n                        &#125;\n                    &#125;\n                &#125; <span class=\"hljs-keyword\">else</span> &#123;\n                    mCircleWaveView.set<span class=\"hljs-constructor\">UnLockPrePared(<span class=\"hljs-params\">false</span>)</span>;\n                    mCircleWaveView.set<span class=\"hljs-constructor\">LockPrepared(<span class=\"hljs-params\">false</span>)</span>;\n                    mOnLockOperateListener.on<span class=\"hljs-constructor\">NotPrepared()</span>;\n                   <span class=\"hljs-comment\">/* if (isLock()) &#123;</span>\n<span class=\"hljs-comment\">                        mCircleWaveView.setText(mContext.getResources().getString(R.string.device_control_unlock));</span>\n<span class=\"hljs-comment\">                    &#125; else &#123;</span>\n<span class=\"hljs-comment\">                        mCircleWaveView.setText(mContext.getResources().getString(R.string.device_control_lock));</span>\n<span class=\"hljs-comment\">                    &#125;*/</span>\n<span class=\"hljs-comment\">//                    isOperating = false;</span>\n                &#125;\n\n                <span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">                 * 控制滑动边界</span>\n<span class=\"hljs-comment\">                 */</span>\n                <span class=\"hljs-built_in\">int</span> border = (distance - mCircleWaveView.get<span class=\"hljs-constructor\">Radius()</span> + mCircleView.get<span class=\"hljs-constructor\">Radius()</span>) +\n                        <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">DensityUtils</span>.</span></span>dp2px(mContext, <span class=\"hljs-number\">25</span>);<span class=\"hljs-comment\">//  可上下滑动的最大距离</span>\n                <span class=\"hljs-comment\">//  当前上下滑动的距离</span>\n                <span class=\"hljs-built_in\">int</span> slideHeight = deltaY + mCircleWaveView.get<span class=\"hljs-constructor\">ScrollY()</span>;\n                <span class=\"hljs-keyword\">if</span> (slideHeight &gt; border) &#123;\n                    mCircleWaveView.scroll<span class=\"hljs-constructor\">To(0, <span class=\"hljs-params\">border</span>)</span>;\n                    return <span class=\"hljs-literal\">true</span>;\n                &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (slideHeight + border &lt; <span class=\"hljs-number\">0</span>) &#123;\n                    mCircleWaveView.scroll<span class=\"hljs-constructor\">To(0, -<span class=\"hljs-params\">border</span>)</span>;\n                    return <span class=\"hljs-literal\">true</span>;\n                &#125;\n                mCircleWaveView.scroll<span class=\"hljs-constructor\">By(0, <span class=\"hljs-params\">deltaY</span>)</span>;\n                break;\n            case MotionEvent.ACTION_UP:\n                mCircleWaveView.set<span class=\"hljs-constructor\">UnLockPrePared(<span class=\"hljs-params\">false</span>)</span>;\n                mCircleWaveView.set<span class=\"hljs-constructor\">LockPrepared(<span class=\"hljs-params\">false</span>)</span>;\n                scrollY = mCircleWaveView.get<span class=\"hljs-constructor\">ScrollY()</span>;\n                <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">Math</span>.</span></span>abs(scrollY) &gt; (distance - mCircleWaveView.get<span class=\"hljs-constructor\">Radius()</span> + mCircleView.get<span class=\"hljs-constructor\">Radius()</span>)<span class=\"hljs-operator\"> &amp;&amp; </span>mOption != null) &#123;\n                    switch (mOption) &#123;\n                        case LOCK:\n                            <span class=\"hljs-keyword\">if</span> (mOnLockOperateListener != null)\n                                mOnLockOperateListener.on<span class=\"hljs-constructor\">LockStart()</span>;\n                            break;\n                        case UNLOCK:\n                            <span class=\"hljs-keyword\">if</span> (mOnLockOperateListener != null)\n                                mOnLockOperateListener.on<span class=\"hljs-constructor\">UnlockStart()</span>;\n                            break;\n                    &#125;\n                &#125;\n                mCircleWaveView.smooth<span class=\"hljs-constructor\">Scroll(0, 0)</span>;\n                break;\n        &#125;\n        mLastY = y;\n        return super.on<span class=\"hljs-constructor\">TouchEvent(<span class=\"hljs-params\">event</span>)</span>;\n    &#125;\n</code></pre>\n<p>看到这个方法中这么多代码不知道各位是否已经懵逼？（好吧，我承认，这地方代码写的确实比较乱）不过没关系，其实细细分析来还是不难理解的！同样，我们选择比较重要的点来看。首先来看ACTION_MOVE的时候，在这里先判断了是否可以滑动（其实不可以滑动的情况下应该不会走到这个方法，但是为了严谨还是加了判断），如果不能滑动则下边的逻辑全都不会再走了。接下来<br>通过判断滑动的方向来确定是要开锁还是上锁，并根据滑动距离来给出回调处理。即当中心圆CircleWaveView向上或向下滑动并完全覆盖到上/下的小圆点时则会回掉上锁就绪或者开锁就绪（onLockPrepared、onUnLockPrepared）的方法。此时释放CircleWaveView，则会回调开锁或者上锁（onLockStart、onUnlockStart）的方法。如果CircleWaveView在完全覆盖到上/下的小圆点的状态下，再向反方向滑动至未完全覆盖小圆点，此时则会回掉未就绪（onNotPrepared）的方法。下边贴一下回调接口，一共五个方法，如下：</p>\n<pre><code class=\"hljs csharp\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">interface</span>  <span class=\"hljs-title\">OnLockOperateListener</span> &#123;\n   <span class=\"hljs-comment\">// 上锁就绪</span>\n   <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onLockPrepared</span>(<span class=\"hljs-params\"></span>)</span>;\n   <span class=\"hljs-comment\">// 开锁就绪</span>\n   <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onUnLockPrepared</span>(<span class=\"hljs-params\"></span>)</span>;\n   <span class=\"hljs-comment\">// 开始上锁</span>\n   <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onLockStart</span>(<span class=\"hljs-params\"></span>)</span>;\n   <span class=\"hljs-comment\">// 开始开锁</span>\n   <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onUnlockStart</span>(<span class=\"hljs-params\"></span>)</span>;\n   <span class=\"hljs-comment\">// 未就绪</span>\n   <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onNotPrepared</span>(<span class=\"hljs-params\"></span>)</span>;\n&#125;</code></pre>\n<p>接下来是通过一系列计算来控制CircleWaveView的滑动边界。思路大致如此：首先根据CircleWaveView和上下小圆的位置来计算出可上下滑动的最大距离border。然后计算当CircleWaveView滑动的距离超过border时就强制将其滚动到border位置，已达到固定的效果。代码如下：</p>\n<pre><code class=\"hljs reasonml\"><span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">     * 控制滑动边界</span>\n<span class=\"hljs-comment\">     */</span>\n   <span class=\"hljs-built_in\">int</span> border = (distance - mCircleWaveView.get<span class=\"hljs-constructor\">Radius()</span> + mCircleView.get<span class=\"hljs-constructor\">Radius()</span>) +\n                       <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">DensityUtils</span>.</span></span>dp2px(mContext, <span class=\"hljs-number\">25</span>);<span class=\"hljs-comment\">//  可上下滑动的最大距离</span>\n   <span class=\"hljs-built_in\">int</span> deltaY = (<span class=\"hljs-built_in\">int</span>) ((mLastY - y)<span class=\"hljs-operator\"> / </span>damping);\n   <span class=\"hljs-comment\">//  当前上下滑动的距离</span>\n   <span class=\"hljs-built_in\">int</span> slideHeight = deltaY + mCircleWaveView.get<span class=\"hljs-constructor\">ScrollY()</span>;\n   <span class=\"hljs-keyword\">if</span> (slideHeight &gt; border) &#123;\n        mCircleWaveView.scroll<span class=\"hljs-constructor\">To(0, <span class=\"hljs-params\">border</span>)</span>;\n        return <span class=\"hljs-literal\">true</span>;\n       &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (slideHeight + border &lt; <span class=\"hljs-number\">0</span>) &#123;\n         mCircleWaveView.scroll<span class=\"hljs-constructor\">To(0, -<span class=\"hljs-params\">border</span>)</span>;\n         return <span class=\"hljs-literal\">true</span>;\n       &#125;\n   mCircleWaveView.scroll<span class=\"hljs-constructor\">By(0, <span class=\"hljs-params\">deltaY</span>)</span>;</code></pre>\n\n<p>然后是实现CircleWaveView的弹性滑动，这里我们给CircleWaveView加了一个弹性滑动和阻尼效果。弹性滑动是在CircleWaveView中通过Scroller来实现的，CircleWaveView暴漏出来smoothScroll的弹性滑动接口供在LockView中调用。这点我们在后面讲解CircleWaveView时再说。而阻尼滑动则是将原滑动距离除以阻尼系数以减小滑动距离从而产生阻尼效果。<br>最后来看ACTION_UP，同样是根据Y轴滑动距离与滑动方向回掉对应的方法，并将CircleWaveView恢复到原位。代码如下：</p>\n<pre><code class=\"hljs yaml\"><span class=\"hljs-string\">scrollY</span> <span class=\"hljs-string\">=</span> <span class=\"hljs-string\">mCircleWaveView.getScrollY();</span>\n<span class=\"hljs-string\">if</span> <span class=\"hljs-string\">(Math.abs(scrollY)</span> <span class=\"hljs-string\">&gt;</span> <span class=\"hljs-string\">(distance</span> <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">mCircleWaveView.getRadius()</span> <span class=\"hljs-string\">+</span> <span class=\"hljs-string\">mCircleView.getRadius())</span> <span class=\"hljs-string\">&amp;&amp;</span> <span class=\"hljs-string\">mOption</span> <span class=\"hljs-type\">!=</span> <span class=\"hljs-literal\">null</span><span class=\"hljs-string\">)</span> &#123;\n   <span class=\"hljs-string\">switch</span> <span class=\"hljs-string\">(mOption)</span> &#123;\n         <span class=\"hljs-attr\">case LOCK:</span>\n              <span class=\"hljs-string\">if</span> <span class=\"hljs-string\">(mOnLockOperateListener</span> <span class=\"hljs-type\">!=</span> <span class=\"hljs-literal\">null</span><span class=\"hljs-string\">)</span>\n                   <span class=\"hljs-string\">mOnLockOperateListener.onLockStart();</span>\n          <span class=\"hljs-string\">break;</span>\n          <span class=\"hljs-attr\">case UNLOCK:</span>\n              <span class=\"hljs-string\">if</span> <span class=\"hljs-string\">(mOnLockOperateListener</span> <span class=\"hljs-type\">!=</span> <span class=\"hljs-literal\">null</span><span class=\"hljs-string\">)</span>\n                   <span class=\"hljs-string\">mOnLockOperateListener.onUnlockStart();</span>\n          <span class=\"hljs-string\">break;</span>\n    &#125;\n<span class=\"hljs-string\">mCircleWaveView.smoothScroll(0</span>, <span class=\"hljs-number\">0</span><span class=\"hljs-string\">);</span></code></pre>\n\n\n<h2 id=\"四-实现自定义CircleWaveView\"><a href=\"#四-实现自定义CircleWaveView\" class=\"headerlink\" title=\"四. 实现自定义CircleWaveView\"></a>四. 实现自定义CircleWaveView</h2><p>关于自定义CircleWaveView就不具体来讲了，因为关于自定义View都是一样的步骤。这里我们只选取几个重要的地方来说。1.CircleWaveView中内容的绘制。2.关于弹性滑动的实现。3.心跳动画的实现以及状态改变的扩散动画。</p>\n<p><strong>1.CircleWaveView中内容的绘制。</strong></p>\n<p><strong>绘制主体圆。</strong>主要分为几种情况：<br>a.蓝牙未连接，且未能获取到网络数据，背景色为灰色。<br>b.蓝牙未连接，且能获取到网络数据，背景色为淡绿色或淡红色。<br>c.蓝牙已连接，开锁状态为绿色，未开锁状态为红色。<br>d.上拉上锁就绪状态为深红色，下拉开锁就绪状态为深绿色。</p>\n<p>结合以上需求有如下代码：</p>\n<pre><code class=\"hljs reasonml\"><span class=\"hljs-keyword\">private</span> void draw<span class=\"hljs-constructor\">Circle(Canvas <span class=\"hljs-params\">canvas</span>)</span> &#123;\n        mPaint.set<span class=\"hljs-constructor\">Color(<span class=\"hljs-params\">circleColor</span>)</span>;\n        <span class=\"hljs-built_in\">int</span> verticalCenter = get<span class=\"hljs-constructor\">Height()</span><span class=\"hljs-operator\"> / </span><span class=\"hljs-number\">2</span>;\n        <span class=\"hljs-built_in\">int</span> horizontalCenter = get<span class=\"hljs-constructor\">Width()</span><span class=\"hljs-operator\"> / </span><span class=\"hljs-number\">2</span>;\n        <span class=\"hljs-built_in\">int</span> mRadius = <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">Math</span>.</span></span>min(verticalCenter, horizontalCenter) - <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">Math</span>.</span></span>min(verticalCenter, horizontalCenter)<span class=\"hljs-operator\"> / </span><span class=\"hljs-number\">5</span>;\n        radius = <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">Math</span>.</span></span>min(verticalCenter, horizontalCenter) - <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">Math</span>.</span></span>min(verticalCenter, horizontalCenter)<span class=\"hljs-operator\"> / </span><span class=\"hljs-number\">5</span>;\n        <span class=\"hljs-keyword\">if</span> (transforming) &#123;\n            mPaint.set<span class=\"hljs-constructor\">Color(<span class=\"hljs-params\">getResources</span>()</span>.get<span class=\"hljs-constructor\">Color(R.<span class=\"hljs-params\">color</span>.<span class=\"hljs-params\">green</span>)</span>);\n            canvas.draw<span class=\"hljs-constructor\">Circle(<span class=\"hljs-params\">mPieCenterX</span>, <span class=\"hljs-params\">mPieCenterY</span>, <span class=\"hljs-params\">mRadius</span>, <span class=\"hljs-params\">mPaint</span>)</span>;\n            mRadius = isLock ? transformDelta : mRadius - transformDelta;\n            mPaint.set<span class=\"hljs-constructor\">Color(<span class=\"hljs-params\">getResources</span>()</span>.get<span class=\"hljs-constructor\">Color(R.<span class=\"hljs-params\">color</span>.<span class=\"hljs-params\">red</span>)</span>);\n            canvas.draw<span class=\"hljs-constructor\">Circle(<span class=\"hljs-params\">mPieCenterX</span>, <span class=\"hljs-params\">mPieCenterY</span>, <span class=\"hljs-params\">mRadius</span>, <span class=\"hljs-params\">mPaint</span>)</span>;\n        &#125; <span class=\"hljs-keyword\">else</span> &#123;\n            mRadius = mRadius - waveDelta;\n            <span class=\"hljs-keyword\">if</span> (!isBluetoothConnect) &#123;\n                <span class=\"hljs-keyword\">if</span> (isNoNetData) &#123;\n                    mPaint.set<span class=\"hljs-constructor\">Color(<span class=\"hljs-params\">getColor</span>(R.<span class=\"hljs-params\">color</span>.<span class=\"hljs-params\">gray</span>)</span>);\n                &#125; <span class=\"hljs-keyword\">else</span>\n                    mPaint.set<span class=\"hljs-constructor\">Color(<span class=\"hljs-params\">isLock</span> ? <span class=\"hljs-params\">getColor</span>(R.<span class=\"hljs-params\">color</span>.<span class=\"hljs-params\">redLight</span>)</span> : get<span class=\"hljs-constructor\">Color(R.<span class=\"hljs-params\">color</span>.<span class=\"hljs-params\">greenLight</span>)</span>);\n            &#125; <span class=\"hljs-keyword\">else</span> &#123;\n                <span class=\"hljs-keyword\">if</span> (isLockPrepared) &#123;\n                    mPaint.set<span class=\"hljs-constructor\">Color(<span class=\"hljs-params\">getColor</span>(R.<span class=\"hljs-params\">color</span>.<span class=\"hljs-params\">redDark</span>)</span>);\n                &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (isUnLockPrePared) &#123;\n                    mPaint.set<span class=\"hljs-constructor\">Color(<span class=\"hljs-params\">getColor</span>(R.<span class=\"hljs-params\">color</span>.<span class=\"hljs-params\">greenDark</span>)</span>);\n                &#125; <span class=\"hljs-keyword\">else</span> &#123;\n                    mPaint.set<span class=\"hljs-constructor\">Color(<span class=\"hljs-params\">isLock</span> ? <span class=\"hljs-params\">getColor</span>(R.<span class=\"hljs-params\">color</span>.<span class=\"hljs-params\">red</span>)</span> : get<span class=\"hljs-constructor\">Color(R.<span class=\"hljs-params\">color</span>.<span class=\"hljs-params\">green</span>)</span>);\n                &#125;\n            &#125;\n            canvas.draw<span class=\"hljs-constructor\">Circle(<span class=\"hljs-params\">mPieCenterX</span>, <span class=\"hljs-params\">mPieCenterY</span>, <span class=\"hljs-params\">mRadius</span>, <span class=\"hljs-params\">mPaint</span>)</span>;\n        &#125;\n    &#125;</code></pre>\n\n<p><strong>绘制CircleWaveView中上下箭头。</strong>  关于箭头绘制，注释部分是通过Path来绘制的，但是发现效果不太好，绘制三角形圆角比较麻烦，所以后台改为了直接在canvas上绘制Bitmap来实现。代码如下：</p>\n<pre><code class=\"hljs yaml\"><span class=\"hljs-string\">//</span>  <span class=\"hljs-string\">绘制圆中两个三角</span>\n    <span class=\"hljs-string\">private</span> <span class=\"hljs-string\">void</span> <span class=\"hljs-string\">drawTriangle(Canvas</span> <span class=\"hljs-string\">canvas)</span> &#123;\n        <span class=\"hljs-string\">int</span> <span class=\"hljs-string\">left</span> <span class=\"hljs-string\">=</span> <span class=\"hljs-string\">(mWidth</span> <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">arrowUp.getWidth())</span> <span class=\"hljs-string\">/</span> <span class=\"hljs-number\">2</span><span class=\"hljs-string\">;</span>\n        <span class=\"hljs-string\">canvas.drawBitmap(arrowUp</span>, <span class=\"hljs-string\">left</span>, <span class=\"hljs-string\">mHeight</span> <span class=\"hljs-string\">/</span> <span class=\"hljs-number\">2</span> <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">radius</span> <span class=\"hljs-string\">+</span> <span class=\"hljs-string\">dp13</span>, <span class=\"hljs-string\">mPaint);</span>\n        <span class=\"hljs-string\">canvas.drawBitmap(arrowDown</span>, <span class=\"hljs-string\">left</span>, <span class=\"hljs-string\">mHeight</span> <span class=\"hljs-string\">/</span> <span class=\"hljs-number\">2</span> <span class=\"hljs-string\">+</span> <span class=\"hljs-string\">radius</span> <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">dp13</span> <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">arrowDown.getHeight()</span>, <span class=\"hljs-string\">mPaint);</span>\n        <span class=\"hljs-string\">/*int</span> <span class=\"hljs-string\">radius</span> <span class=\"hljs-string\">=</span> <span class=\"hljs-string\">Math.min(mHeight</span>, <span class=\"hljs-string\">mWidth)</span> <span class=\"hljs-string\">/</span> <span class=\"hljs-number\">2</span> <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">Math.min(mHeight</span>, <span class=\"hljs-string\">mWidth)</span> <span class=\"hljs-string\">/</span> <span class=\"hljs-number\">8</span><span class=\"hljs-string\">;</span>\n        <span class=\"hljs-string\">mPaintTrangel.setStyle(Paint.Style.FILL);</span>\n        <span class=\"hljs-string\">mPaintTrangel.setShadowLayer(4</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-string\">Color.GRAY);</span>\n        <span class=\"hljs-string\">//</span>  <span class=\"hljs-string\">三角形顶点到圆边的距离</span>\n        <span class=\"hljs-string\">int</span> <span class=\"hljs-string\">h0</span> <span class=\"hljs-string\">=</span> <span class=\"hljs-string\">DensityUtils.dp2px(mContext</span>, <span class=\"hljs-number\">10</span><span class=\"hljs-string\">);</span>\n        <span class=\"hljs-string\">//</span>  <span class=\"hljs-string\">三角形高</span>\n        <span class=\"hljs-string\">int</span> <span class=\"hljs-string\">h1</span> <span class=\"hljs-string\">=</span> <span class=\"hljs-string\">DensityUtils.dp2px(mContext</span>, <span class=\"hljs-number\">12</span><span class=\"hljs-string\">);</span>\n        <span class=\"hljs-string\">//</span>  <span class=\"hljs-string\">三角形底边长</span>\n        <span class=\"hljs-string\">int</span> <span class=\"hljs-string\">w</span> <span class=\"hljs-string\">=</span> <span class=\"hljs-string\">DensityUtils.dp2px(mContext</span>, <span class=\"hljs-number\">14</span><span class=\"hljs-string\">);</span>\n        <span class=\"hljs-string\">mPaintTrangel.setColor(getResources().getColor(R.color.transparent_33));</span>\n        <span class=\"hljs-string\">mPath.moveTo(mWidth</span> <span class=\"hljs-string\">/</span> <span class=\"hljs-number\">2</span>, <span class=\"hljs-string\">mHeight</span> <span class=\"hljs-string\">/</span> <span class=\"hljs-number\">2</span> <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">(radius</span> <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">h0));</span>\n        <span class=\"hljs-string\">mPath.lineTo(mWidth</span> <span class=\"hljs-string\">/</span> <span class=\"hljs-number\">2</span> <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">w</span>, <span class=\"hljs-string\">mHeight</span> <span class=\"hljs-string\">/</span> <span class=\"hljs-number\">2</span> <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">(radius</span> <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">h1</span> <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">h0));</span>\n        <span class=\"hljs-string\">mPath.lineTo(mWidth</span> <span class=\"hljs-string\">/</span> <span class=\"hljs-number\">2</span> <span class=\"hljs-string\">+</span> <span class=\"hljs-string\">w</span>, <span class=\"hljs-string\">mHeight</span> <span class=\"hljs-string\">/</span> <span class=\"hljs-number\">2</span> <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">(radius</span> <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">h1</span> <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">h0));</span>\n        <span class=\"hljs-string\">canvas.drawPath(mPath</span>, <span class=\"hljs-string\">mPaintTrangel);</span>\n        <span class=\"hljs-string\">mPaintTrangel.setShadowLayer(4</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">-3</span>, <span class=\"hljs-string\">Color.GRAY);</span>\n        <span class=\"hljs-string\">mPath.moveTo(mWidth</span> <span class=\"hljs-string\">/</span> <span class=\"hljs-number\">2</span>, <span class=\"hljs-string\">mHeight</span> <span class=\"hljs-string\">/</span> <span class=\"hljs-number\">2</span> <span class=\"hljs-string\">+</span> <span class=\"hljs-string\">(radius</span> <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">h0));</span>\n        <span class=\"hljs-string\">mPath.lineTo(mWidth</span> <span class=\"hljs-string\">/</span> <span class=\"hljs-number\">2</span> <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">w</span>, <span class=\"hljs-string\">mHeight</span> <span class=\"hljs-string\">/</span> <span class=\"hljs-number\">2</span> <span class=\"hljs-string\">+</span> <span class=\"hljs-string\">(radius</span> <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">h1</span> <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">h0));</span>\n        <span class=\"hljs-string\">mPath.lineTo(mWidth</span> <span class=\"hljs-string\">/</span> <span class=\"hljs-number\">2</span> <span class=\"hljs-string\">+</span> <span class=\"hljs-string\">w</span>, <span class=\"hljs-string\">mHeight</span> <span class=\"hljs-string\">/</span> <span class=\"hljs-number\">2</span> <span class=\"hljs-string\">+</span> <span class=\"hljs-string\">(radius</span> <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">h1</span> <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">h0));</span>\n        <span class=\"hljs-string\">canvas.drawPath(mPath</span>, <span class=\"hljs-string\">mPaintTrangel);*/</span>\n    &#125;</code></pre>\n<p><strong>绘制CircleWaveView中心的文字</strong> 中心文字分为两种情况：当蓝牙未连接时，显示为两行。当蓝牙已连接时显示为一行。绘制思路是先计算出中心基线，然后再来分情况实现。代码如下：</p>\n<pre><code class=\"hljs reasonml\"><span class=\"hljs-comment\">//  绘制圆中的文字</span>\n    <span class=\"hljs-keyword\">private</span> void draw<span class=\"hljs-constructor\">Text(Canvas <span class=\"hljs-params\">canvas</span>)</span> &#123;\n        <span class=\"hljs-keyword\">if</span> (isConnecting) return;\n        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">TextUtils</span>.</span></span>is<span class=\"hljs-constructor\">Empty(<span class=\"hljs-params\">mText</span>)</span>) &#123; <span class=\"hljs-comment\">//   绘制单行文字</span>\n            String text = mContext.get<span class=\"hljs-constructor\">Resources()</span>.get<span class=\"hljs-constructor\">String(R.<span class=\"hljs-params\">string</span>.<span class=\"hljs-params\">ble_not_connect</span>)</span>;\n            canvas.draw<span class=\"hljs-constructor\">Text(<span class=\"hljs-params\">text</span>, <span class=\"hljs-params\">mPieCenterX</span>, <span class=\"hljs-params\">getBaseline</span>(<span class=\"hljs-params\">text</span>)</span>, mPaintText);\n            return;\n        &#125;\n        <span class=\"hljs-keyword\">if</span> (isBluetoothConnect) &#123;   <span class=\"hljs-comment\">//   绘制单行文字</span>\n            canvas.draw<span class=\"hljs-constructor\">Text(<span class=\"hljs-params\">mText</span>, <span class=\"hljs-params\">mPieCenterX</span>, <span class=\"hljs-params\">getBaseline</span>(<span class=\"hljs-params\">mText</span>)</span>, mPaintText);\n        &#125; <span class=\"hljs-keyword\">else</span> &#123;    <span class=\"hljs-comment\">//   绘制两行文字</span>\n            String text = mContext.get<span class=\"hljs-constructor\">Resources()</span>.get<span class=\"hljs-constructor\">String(R.<span class=\"hljs-params\">string</span>.<span class=\"hljs-params\">ble_not_connect</span>)</span>;\n            <span class=\"hljs-built_in\">int</span> baseline = get<span class=\"hljs-constructor\">Baseline(<span class=\"hljs-params\">text</span>)</span>;\n            canvas.draw<span class=\"hljs-constructor\">Text(<span class=\"hljs-params\">text</span>, <span class=\"hljs-params\">mPieCenterX</span>, <span class=\"hljs-params\">baseline</span> - 30, <span class=\"hljs-params\">mPaintText</span>)</span>;\n            mPaintText.set<span class=\"hljs-constructor\">TextSize(DensityUtils.<span class=\"hljs-params\">dp2px</span>(<span class=\"hljs-params\">mContext</span>, 12)</span>);\n            canvas.draw<span class=\"hljs-constructor\">Text(<span class=\"hljs-params\">mText</span>, <span class=\"hljs-params\">mPieCenterX</span>, <span class=\"hljs-params\">baseline</span> + 30, <span class=\"hljs-params\">mPaintText</span>)</span>;\n        &#125;\n    &#125;\n\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-built_in\">int</span> get<span class=\"hljs-constructor\">Baseline(String <span class=\"hljs-params\">text</span>)</span> &#123;\n        mPaintText.set<span class=\"hljs-constructor\">TextSize(<span class=\"hljs-params\">mTextSize</span>)</span>;\n        mPaintText.get<span class=\"hljs-constructor\">TextBounds(<span class=\"hljs-params\">text</span>, 0, <span class=\"hljs-params\">text</span>.<span class=\"hljs-params\">length</span>()</span>, bounds);\n        Paint.FontMetricsInt fontMetricsInt = mPaintText.get<span class=\"hljs-constructor\">FontMetricsInt()</span>;\n        return (get<span class=\"hljs-constructor\">MeasuredHeight()</span> - fontMetricsInt.bottom + fontMetricsInt.top)<span class=\"hljs-operator\"> / </span><span class=\"hljs-number\">2</span>\n                - fontMetricsInt.top;\n    &#125;</code></pre>\n<p><strong>2.关于弹性滑动的实现。</strong> 关于滑动，通常我们会想到用ScrollTo或ScrollBy来实现。但由于这两个方法实现滑动都是瞬间完成的，因此滑动看起来会比较生硬，体验也很不好。因此想到可以使用Scroller来做一个滑动延迟实现带有弹性效果的滑动。由于Scroller本身时无法实现滑动的，因此还必须配合computeScroll方法共同完成。这里我们封装一个smoothScroll方法，提供给LockView调用。具体代码如下：</p>\n<pre><code class=\"hljs reasonml\">public void smooth<span class=\"hljs-constructor\">Scroll(<span class=\"hljs-params\">int</span> <span class=\"hljs-params\">destX</span>, <span class=\"hljs-params\">int</span> <span class=\"hljs-params\">destY</span>)</span> &#123;\n        <span class=\"hljs-built_in\">int</span> scrollY = get<span class=\"hljs-constructor\">ScrollY()</span>;\n        <span class=\"hljs-built_in\">int</span> delta = destY - scrollY;\n        mScroller.start<span class=\"hljs-constructor\">Scroll(<span class=\"hljs-params\">destX</span>, <span class=\"hljs-params\">scrollY</span>, 0, <span class=\"hljs-params\">delta</span>, 400)</span>;\n        invalidate<span class=\"hljs-literal\">()</span>;\n    &#125;\n\n    @Override\n    public void compute<span class=\"hljs-constructor\">Scroll()</span> &#123;\n        <span class=\"hljs-keyword\">if</span> (mScroller.compute<span class=\"hljs-constructor\">ScrollOffset()</span>) &#123;\n            scroll<span class=\"hljs-constructor\">To(<span class=\"hljs-params\">mScroller</span>.<span class=\"hljs-params\">getCurrX</span>()</span>, mScroller.get<span class=\"hljs-constructor\">CurrY()</span>);\n            post<span class=\"hljs-constructor\">Invalidate()</span>;\n        &#125;\n    &#125;</code></pre>\n<p><strong>3.心跳动画的实现以及状态改变的扩散动画。</strong> </p>\n<p>首先来看心跳动画的实现，这里使用属性动画，首先为ValueAnimator设置从0到1再到0的一个数值变化，并且周期时间设置为600毫秒、重复次数设置为ValueAnimator.INFINITE，即为无限次循环。通过ValueAnimator中不断变化的value来计算圆半径的大小，并通过invalidate()方法不断重绘View，从而达到一个心跳动画的效果。代码如下：</p>\n<pre><code class=\"hljs reasonml\"><span class=\"hljs-comment\">//  开始心跳动画</span>\npublic void start<span class=\"hljs-constructor\">Wave()</span> &#123;\n        <span class=\"hljs-keyword\">if</span> (animator != null<span class=\"hljs-operator\"> &amp;&amp; </span>animator.is<span class=\"hljs-constructor\">Running()</span>)\n            animator.<span class=\"hljs-keyword\">end</span><span class=\"hljs-literal\">()</span>;\n        animator = <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">ValueAnimator</span>.</span></span><span class=\"hljs-keyword\">of</span><span class=\"hljs-constructor\">Float(0f, 1f, 0f)</span>;\n        animator.set<span class=\"hljs-constructor\">RepeatCount(ValueAnimator.INFINITE)</span>;\n        animator.set<span class=\"hljs-constructor\">RepeatMode(ValueAnimator.RESTART)</span>;\n        animator.set<span class=\"hljs-constructor\">Duration(600)</span>;\n\n        animator.add<span class=\"hljs-constructor\">UpdateListener(<span class=\"hljs-params\">new</span> ValueAnimator.AnimatorUpdateListener()</span> &#123;\n            @Override\n            public void on<span class=\"hljs-constructor\">AnimationUpdate(ValueAnimator <span class=\"hljs-params\">animation</span>)</span> &#123;\n                <span class=\"hljs-built_in\">int</span> verticalCenter = get<span class=\"hljs-constructor\">Height()</span><span class=\"hljs-operator\"> / </span><span class=\"hljs-number\">2</span>;\n                <span class=\"hljs-built_in\">int</span> horizontalCenter = get<span class=\"hljs-constructor\">Width()</span><span class=\"hljs-operator\"> / </span><span class=\"hljs-number\">2</span>;\n                waveDelta = (<span class=\"hljs-built_in\">int</span>) (<span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">Math</span>.</span></span>min(verticalCenter, horizontalCenter)<span class=\"hljs-operator\"> * </span>(<span class=\"hljs-built_in\">float</span>) animation.get<span class=\"hljs-constructor\">AnimatedValue()</span><span class=\"hljs-operator\"> / </span><span class=\"hljs-number\">16</span>);\n                invalidate<span class=\"hljs-literal\">()</span>;\n            &#125;\n        &#125;);\n\n        animator.start<span class=\"hljs-literal\">()</span>;\n    &#125;\n <span class=\"hljs-comment\">//  停止心跳动画</span>\n public void stop<span class=\"hljs-constructor\">Wave()</span> &#123;\n        <span class=\"hljs-keyword\">if</span> (animator != null<span class=\"hljs-operator\"> &amp;&amp; </span>animator.is<span class=\"hljs-constructor\">Running()</span>)\n            animator.<span class=\"hljs-keyword\">end</span><span class=\"hljs-literal\">()</span>;\n    &#125;</code></pre>\n<p>接下来看状态改变时扩散动画的实现，其实方法和心跳动画一样，都是采用ValueAnimator动态计算绘制圆的半径，不在赘述。参考如下代码：</p>\n<pre><code class=\"hljs reasonml\">public void change<span class=\"hljs-constructor\">LockState(<span class=\"hljs-params\">final</span> <span class=\"hljs-params\">boolean</span> <span class=\"hljs-params\">lock</span>)</span> &#123;\n        stop<span class=\"hljs-constructor\">Wave()</span>;\n        <span class=\"hljs-keyword\">if</span> (this.isLock != lock) &#123;\n            transforming = <span class=\"hljs-literal\">true</span>;\n            ValueAnimator valueAnimator = <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">ValueAnimator</span>.</span></span><span class=\"hljs-keyword\">of</span><span class=\"hljs-constructor\">Float(0f, 0.99f)</span>;\n            valueAnimator.set<span class=\"hljs-constructor\">Duration(500)</span>;\n            valueAnimator.add<span class=\"hljs-constructor\">Listener(<span class=\"hljs-params\">new</span> Animator.AnimatorListener()</span> &#123;\n                @Override\n                public void on<span class=\"hljs-constructor\">AnimationStart(Animator <span class=\"hljs-params\">animation</span>)</span> &#123;\n\n                &#125;\n\n                @Override\n                public void on<span class=\"hljs-constructor\">AnimationEnd(Animator <span class=\"hljs-params\">animation</span>)</span> &#123;\n                    transforming = <span class=\"hljs-literal\">false</span>;\n                    isLock = lock;\n                    invalidate<span class=\"hljs-literal\">()</span>;\n                &#125;\n\n                @Override\n                public void on<span class=\"hljs-constructor\">AnimationCancel(Animator <span class=\"hljs-params\">animation</span>)</span> &#123;\n                    transforming = <span class=\"hljs-literal\">false</span>;\n                &#125;\n\n                @Override\n                public void on<span class=\"hljs-constructor\">AnimationRepeat(Animator <span class=\"hljs-params\">animation</span>)</span> &#123;\n\n                &#125;\n            &#125;);\n            valueAnimator.add<span class=\"hljs-constructor\">UpdateListener(<span class=\"hljs-params\">new</span> ValueAnimator.AnimatorUpdateListener()</span> &#123;\n                @Override\n                public void on<span class=\"hljs-constructor\">AnimationUpdate(ValueAnimator <span class=\"hljs-params\">animation</span>)</span> &#123;\n                    <span class=\"hljs-built_in\">int</span> verticalCenter = get<span class=\"hljs-constructor\">Height()</span><span class=\"hljs-operator\"> / </span><span class=\"hljs-number\">2</span>;\n                    <span class=\"hljs-built_in\">int</span> horizontalCenter = get<span class=\"hljs-constructor\">Width()</span><span class=\"hljs-operator\"> / </span><span class=\"hljs-number\">2</span>;\n                    transformDelta = (<span class=\"hljs-built_in\">int</span>) ((<span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">Math</span>.</span></span>min(verticalCenter, horizontalCenter) - <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">Math</span>.</span></span>min(verticalCenter, horizontalCenter)<span class=\"hljs-operator\"> / </span><span class=\"hljs-number\">6</span>)\n<span class=\"hljs-operator\">                            * </span>(<span class=\"hljs-built_in\">float</span>) animation.get<span class=\"hljs-constructor\">AnimatedValue()</span>);\n                    invalidate<span class=\"hljs-literal\">()</span>;\n                &#125;\n            &#125;);\n            valueAnimator.start<span class=\"hljs-literal\">()</span>;\n        &#125;\n    &#125;</code></pre>\n<p>至此，关于LockView的绘制到这里就完全结束了。回顾一下本篇文章，重讲解了自定义LockView以及弹性滑动实现，然后探讨了关于事件分发的一些知识以及使用属性动画来实现心跳和扩散效果。相信看完本篇文章的小伙伴也会有不小的收获，最后关于源码，已放在文章末尾，欢迎start、forck！</p>\n<p> <a href=\"https://github.com/zhpanvip/CustomView\">源码链接</a></p>\n"},{"layout":"w","title":"基于Arouter的路由实现方案","date":"2018-07-25T16:39:03.000Z","_content":"这本是一篇应该写在去年的文章，但仅仅因为...懒，这篇文章在草稿箱里静静的躺了一年多，被无限期推迟到了现在。最近刚好完成了公司项目的路由改造，借此机会来对这篇文章做一个了结。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190918012522155.png)\n\n# 一、为什么要在项目中引入路由？\n\n在开始之前我们先来思考一下这个问题。为什么要在项目中引入路由？相信大家的答案可能会有所不同，但是应该也不外乎以下几点：\n\n## 1.为了实现项目组件化\n\n想必很多开发者引入路由的目的都是因为要实现项目组件化。我们知道，组件化的项目各个业务模块之间没有相互的依赖关系。不同业务模块之间的通信最好的解决方案就是支持页面路由。\n\n## 2.方便APP内部跳转\n\n可能有些小伙伴会有疑问，App内部直接通过Intent跳转不是很好吗，为什么要多此一举引入路由呢？当然，通常情况下通过Intent跳转也无伤大雅。但是在某些情况下，比如像下图这样的一个页面：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2019091700111637.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwNTIxNTcz,size_16,color_FFFFFF,t_70)\n这是一个典型的多Type的RecyclerView页面，这个页面中所有的数据都是从服务器获取的，在引入路由之前所有的点击跳转事件都需要后台给我们一个type,我们根据type判断需要向哪一个Activity跳转，并且需要通过Intent携带目的页面所需要的参数。显然这样写会使我们代码变得非常臃肿，代码之间的耦合度也非常高。然而在引入路由之后一切都变得不一样了。我们只需要后台返回目的页面所对应的URL，并在URL上拼接页面跳转所需要的参数，此时前台只需要拿到URL，然后通过路由即可到达对应的页面。这样以来使我们的代码变得简洁明了，并且保证了代码的低耦合。\n\n## 3.方便APP外部跳转\n\n通常可以看到很多应用支持从浏览器唤醒App并跳转到对应的页面。做到比较好的如知乎，体验过知乎的小伙伴应该知道，知乎可以从浏览器唤醒App并且直接在App中打开当前在浏览器中浏览的内容。我们知道，从外部唤起App需要给Activity添加Schema。而如果App内部有许多Activity需要支持外部唤起，我们不可能为这些Activity都添加Schema。那么此时我们就可以单独设置一个支持Schema的Activity，浏览器可以通过Schema唤起这个Activity。而在这个Activity中会接收浏览器传过来的URL，然后根据URL进行路由分发，通过URL路由到对应的页面即可。\n\n# 二 、ARouter的使用\n其实很不想在这篇文章中长篇大论如何使用[ARouter](https://github.com/alibaba/ARouter)，因为[ARouter的官方文档](https://github.com/alibaba/ARouter/blob/master/README_CN.md)上已经非常详细的告诉了开发者如何去使用，只要仔细的阅读ARouter的文档基本上绝大部分问题都可以得到解决。但是为了照顾没有使用过ARouter的小伙伴，这里还是再啰嗦一下。如果你对ARouter的使用已经非常熟悉了那么你可以忽略此章节，直接到下一章了。\n\n## 1.添加依赖和配置\n\n```\nandroid {\n    defaultConfig {\n        ...\n        javaCompileOptions {\n            annotationProcessorOptions {\n                arguments = [AROUTER_MODULE_NAME: project.getName()]\n            }\n        }\n    }\n}\n\ndependencies {\n    // 替换成最新版本, 需要注意的是api\n    // 要与compiler匹配使用，均使用最新版可以保证兼容\n    implementation 'com.alibaba:arouter-api:x.x.x'\n    annotationProcessor 'com.alibaba:arouter-compiler:x.x.x'\n    ...\n}\n```\n这里需要注意，如果你的项目有多个业务模块，那么每个模块都需要在gradle中添加以上配置。\n\n## 2.初始化SDK\n\n```\nif (isDebug()) {           // 这两行必须写在init之前，否则这些配置在init过程中将无效\n    ARouter.openLog();     // 打印日志\n    ARouter.openDebug();   // 开启调试模式(如果在InstantRun模式下运行，必须开启调试模式！线上版本需要关闭,否则有安全风险)\n}\nARouter.init(mApplication); // 尽可能早，推荐在Application中初始化\n```\n\n## 3.添加注解\n\n```\n// 在支持路由的页面上添加注解(必选)\n// 这里的路径需要注意的是至少需要有两级，/xx/xx\n@Route(path = \"/test/activity\")\npublic class YourActivity extend Activity {\n    ...\n}\n```\n\n## 4.发起路由操作\n\n```\n// 1. 应用内简单的跳转(通过URL跳转在'进阶用法'中)\nARouter.getInstance().build(\"/test/activity\").navigation();\n\n// 2. 跳转并携带参数\nARouter.getInstance().build(\"/test/1\")\n            .withLong(\"key1\", 666L)\n            .withString(\"key3\", \"888\")\n            .withObject(\"key4\", new Test(\"Jack\", \"Rose\"))\n            .navigation();\n```\n很多情况下需要通过URL跳转，ARouter支持直接通过URL跳转：\n\n```\n Uri uri= Uri.parse(url);\n ARouter.getInstance().build(uri).navigation();\n```\n\n## 5.路由解析参数\n\n```\n// 为每一个参数声明一个字段，并使用 @Autowired 标注\n// URL中不能传递Parcelable类型数据，通过ARouter api可以传递Parcelable对象\n@Route(path = \"/test/activity\")\npublic class Test1Activity extends Activity {\n    @Autowired\n    public String name;\n    @Autowired\n    int age;\n    \n    // 通过name来映射URL中的不同参数\n    @Autowired(name = \"girl\") \n    boolean boy;\n    \n    // 支持解析自定义对象，URL中使用json传递\n    @Autowired\n    TestObj obj;      \n    \n    // 使用 withObject 传递 List 和 Map 的实现了\n    // Serializable 接口的实现类(ArrayList/HashMap)\n    // 的时候，接收该对象的地方不能标注具体的实现类类型\n    // 应仅标注为 List 或 Map，否则会影响序列化中类型\n    // 的判断, 其他类似情况需要同样处理        \n    @Autowired\n    List<TestObj> list;\n    @Autowired\n    Map<String, List<TestObj>> map;\n    \n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    ARouter.getInstance().inject(this);\n\n    // ARouter会自动对字段进行赋值，无需主动获取\n    Log.d(\"param\", name + age + boy);\n    }\n}\n\n\n// 如果需要传递自定义对象，新建一个类（并非自定义对象类），然后实现 SerializationService,并使用@Route注解标注(方便用户自行选择序列化方式)，例如：\n@Route(path = \"/yourservicegroupname/json\")\npublic class JsonServiceImpl implements SerializationService {\n    @Override\n    public void init(Context context) {\n\n    }\n\n    @Override\n    public <T> T json2Object(String text, Class<T> clazz) {\n        return JSON.parseObject(text, clazz);\n    }\n\n    @Override\n    public String object2Json(Object instance) {\n        return JSON.toJSONString(instance);\n    }\n}\n```\n除了使用@Autowired注解注入参数外，还可以与普通页面跳转一样通过getIntent()获取参数。\n\n以上就是ARouter的一些基本用法，了解这些基本用法之后并不等于已经掌握了ARouter。因为当你实际用到项目中的时候可能会面临诸多问题。\n\n# 三 、ARouter的采坑之路\n如果你只是简单的写一个ARouter使用的Demo，那么可能上一章的内容已经足够了。但是当你在项目中引入ARouter后各种各样的问题便会接踵而至。\n\n## 1.使用ARouter实现登录拦截\n这是在项目中引入ARouter后面临的第一个问题。通常情况下，大部分App不登录便可以进入主页面，在跳转需要用户权限的页面时会首先跳转到登录页面引导用户登录。我相信大部分的开发在最初时候都写过类似这样的代码：\n\n```\n if (isLogin) {\n     goToDestination();\n  } else {\n     goToLogin();\n  }\n```\n在每次跳转页面的时候都需要进行是否登录的判断，这样的代码显然有很大的弊端。而ARouter为我们提供了面向切面的登录拦截功能，ARouter的文档上给了我们一个例子：\n\n```\n// 比较经典的应用就是在跳转过程中处理登陆事件，这样就不需要在目标页重复做登陆检查\n// 拦截器会在跳转之间执行，多个拦截器会按优先级顺序依次执行\n@Interceptor(priority = 8, name = \"测试用拦截器\")\npublic class TestInterceptor implements IInterceptor {\n    @Override\n    public void process(Postcard postcard, InterceptorCallback callback) {\n    ...\n    callback.onContinue(postcard);  // 处理完成，交还控制权\n    // callback.onInterrupt(new RuntimeException(\"我觉得有点异常\"));      // 觉得有问题，中断路由流程\n\n    // 以上两种至少需要调用其中一种，否则不会继续路由\n    }\n\n    @Override\n    public void init(Context context) {\n    // 拦截器的初始化，会在sdk初始化的时候调用该方法，仅会调用一次\n    }\n}\n```\n如果你按着官方文档上这样写，那么你大概率会碰到很多问题。列举如下：\n**如何处理有些页面需要登录拦截，有些页面不需要登录拦截？**\n如果你添加了拦截器，那么在每次路由跳转时都会优先走到拦截器中，在拦截器的process()方法中你可以通过判断当前是否登录来决定是否继续该路由操作，如果已经登录，那么直接通过 callback.onContinue(postcard)继续当前路由，而如果没有登录，那么就将目的页面修改为登录页。但是，不要忘了，添加拦截器后所有的路由操作都会优先走到这里，而我们的需求是只有需要用户权限的时候才需要跳转到登录页，否则即使没有登录依然可以跳转到目的页。此时我们应该怎么办？\n如果你仔细的看了ARouter的开发文档，你可能注意到在@Route的注解有一个int类型的extras参数。如此我们便可以通过这个参数来对Activity进行标记是否需要登录：\n\n```\n@Route(path = PATH_TEST, extras = IGNORE_LOGIN)\npublic class TestActivity extends BaseTitleCompatActivity {}\n```\n接下来，在拦截器中可以拿到extras参数，以此来确定该页面是否需要登录：\n\n```\nif(UserInfoTools.isLogin() || IGNORE_LOGIN == postcard.getExtra()) {  //  已经登录或者不需要拦截的情况\n\t //  继续当前路由\n      callback.onContinue(postcard);\n } else {\t// 未登录且需要登录的情况\n    //\t路由到登录页面\n    ARouter.getInstance().build(RoutingTable.PATH_GUEST_LOGIN).navigation();\n    ...\n  }\n```\n到这里这个问题解决了，但是当你兴致勃勃的运行起来App,在未登录的情况下点击跳转到需要用户权限的页面，你憧憬着跳转页面会被拦截到登录页，但是你又被无情的事实打脸了。竟然页面毫无反应？于是你断点、打Log发现ARouter.getInstance().build(RoutingTable.PATH_GUEST_LOGIN).navigation()这句代码确实执行了，但是为什么没有跳转到登录页？于是你苦思冥想，突然灵光一闪，哇！是因为这一句路由也会走到了拦截器里，如此岂不成了一个死循环。于是你Google如何解决，发现原来需要调用greenChannel()来避免出现死循环。于是有了如下代码：\n\n```\nif(UserInfoTools.isLogin() || IGNORE_LOGIN == postcard.getExtra()) {  //  已经登录或者不需要拦截的情况\n\t //  继续当前路由\n      callback.onContinue(postcard);\n } else {\t// 未登录且需要登录的情况\n    //\t路由到登录页面\n   ARouter.getInstance().build(RoutingTable.PATH_GUEST_LOGIN).greenChannel().navigation();\n    ...\n  }\n```\n修改之后你怀着和刚才一样的心情兴致勃勃的运行起来App,心想，这次一定没问题。好！点击按钮....竟然成功跳转到了登录页面。于是你兴奋起来，疯狂的点击这些页面，发现都没问题。可是...当你点了几次之后突然发现，页面跳转无效了！！你简直不敢相信自己的眼睛，刚才明明是好好的...于是你在此陷入了沉思。\n好吧，这次直接公布答案了，那是因为你需要将原来的路由打断，而之所以前几次有效大概猜测是因为greenChannel()去开启了多个channel，而ARouter的channel是有限的，因此在点击几次之后路由再次失效了。于是修改后代码如下：\n\n```\nif(UserInfoTools.isLogin() || IGNORE_LOGIN == postcard.getExtra()) {  //  已经登录或者不需要拦截的情况\n\t //  继续当前路由\n      callback.onContinue(postcard);\n } else {\t// 未登录且需要登录的情况\n    //\t路由到登录页面\n   ARouter.getInstance().build(RoutingTable.PATH_GUEST_LOGIN).greenChannel().navigation();\n   callback.onInterrupt(null);\n  }\n```\n关于登录拦截看似简单，实则使用时候竟然会碰到这么多问题！相信第一次使用时都会被虐的掉眼泪。\n\n## 2.处理一个Activity对应多个路径的情况\n在某些情况可能出现一个页面对应多个路径的情况。出现这种情况的原因可能是前期路由没有规划好，导致后边版本的路由路径做了修改。从而出现了一个Activity对应多个页面的情况。为了兼容旧版路由，我们不得不处理这种情况。但是，Route的注解中path是唯一的，并不能通过@Route注解解决一个Activity对应多个路径的情况。此时就需要用到ARouter的重写URL的功能。只需要实现PathReplaceService 接口，在重写的方法中对URI或者Path进行替换即可，注意，这个类一定要加@Route注解。代码参考如下：\n\n```\n@Route(path = \"/lost/service\")\npublic class ARouterLostReplaceService implements PathReplaceService {\n    @Override\n    public String forString(String path) {\t//\t对于path处理与uri类似\n        return path;\n    }\n\n    @Override\n    public Uri forUri(Uri uri) {\t\n        String path = uri.getPath();\n        if(PATH_LOST1.equals(path)) {\n            uri = replaceUriPath(uri, PATH_REAL1);\n        } else if(PATH_LOST2.equals(path)) {\n            uri = replaceUriPath(uri, PATH_REAL2);\n        }\n        return uri;\n    }\n\n    @Override\n    public void init(Context context) {\n\n    }\n\n    /**\n     * 替换URI中的path\n     * \n     * @param uri 被替换的uri\n     * @param path 要替换的path\n     * @return 替换后的uri\n     */\n    private Uri replaceUriPath(Uri uri, String path) {\n        StringBuilder resultUrl = new StringBuilder(uri.getScheme() + \"://\" + uri.getHost() + path);\n        String[] split = uri.toString().split(\"\\\\?\");\n        if(split.length >= 2) {\n            resultUrl.append(\"?\").append(split[1]);\n        }\n        return Uri.parse(resultUrl.toString());\n    }\n}\n```\n\n## 3.ARouter全局降级策略\n在路由跳转时可能会出现找不到Path对应页面的情况，对于这种情况可以通过实现DegradeService 接口来处理，同样这个类也必须要添加@Route注解。这样当路由跳转时找不到路径就会走到这个类的onLost方法中，此时就可以在这个方法中来做相应的处理了。\n\n```\n// 实现DegradeService接口，并加上一个Path内容任意的注解即可\n@Route(path = \"/lost/path\")\npublic class DegradeServiceImpl implements DegradeService {\n\t@Override\n\tpublic void onLost(Context context, Postcard postcard) {\n\t    //  可以在此处统一处理，比如跳转到首页\n\t}\n\n\t@Override\n\tpublic void init(Context context) {\n\n\t}\n}\n```\n\n# 四、通过浏览器跳转到App对应页面\n\n\n## 1.Schema协议\n很多人对于Schema协议比较陌生，但是如果说URL大家一定都非常熟悉。其实URL就是一种Schema协议。Schema协议通常由四部分组成：\n\n```\n [scheme]://[host]/[path]?[query]\n scheme：表示协议名称\n host：Schema所作用的地址域\n path：Schema指定的路径\n query：携带的参数\n```\n拿百度搜索的URL来举例子：https://www.baidu.com/s?wd=要搜索的关键字。这个URL与Schema协议的对应关系如下\n\n>\n> schema:：https\n> host： www.baidu.com\n> path： /s\n> query：wd=要搜索的关键字\n> \n了解了Schema协议后，其实我们完全可以按照Schema协议的格式来自定义一个Schema链接，如下：\n\n> myApp://www.myApp.com/main/home?id=1\n> \n> 我们自己定义的Schema链接的对应关系为：\n>  schema:：myApp\n> host：www.myApp.com\n> path：/main/home\n> query：id=1\n\n\n## 2.通过Schema链接打开Activity\n通过浏览器打开App其实就是通过Schema链接来实现的。我们就以上一节中自定义的Schema链接为例来实现浏览器打开App。首先在项目中添加一个RouterActivity，RouterActivity在AndroidManifest中的配置如下：\n\n```\n<activity\n      android:name=\".activity.RouterActivity\"\n      android:configChanges=\"orientation|keyboardHidden|screenSize\"\n      android:screenOrientation=\"portrait\">\n      <intent-filter>\n          <action android:name=\"android.intent.action.VIEW\" />\n          <category android:name=\"android.intent.category.DEFAULT\" />\n           <category android:name=\"android.intent.category.BROWSABLE\" />\n           <data android:scheme=\"myApp\" />\n      </intent-filter>\n</activity>\n```\n我们在AndroidManifest中为RouterActivity添加了schema，此时在HTML中写入以下代码：\n\n```\n<a href=\"myApp://www.myApp.com/main/home?id=1\">打开APP</a>\n```\n通过点击HTML页面的\"打开App\"便可启动RouterActivity。并且RouterActivity启动后可以通过Intent获取到启动的URI。代码如下：\n\n```\n   #RouterActivity\n  \n\t@Override\n    protected void onCreate(Bundle data) {\n        super.onCreate(data);\n        Uri launchUri = getIntent().getData();\n        dispatchRouterUri(launchUri);\n    }\n```\n至此，我们已经可以通过App来打开项目的RouterActivity。\n\n## 3.通过路由跳转到目的页面\n上一节中我们通过HTML打开了RouterActivity，并在RouterActivity中拿到了跳转的URI，那么接下来我们便可以根据URI的信息打开对应的页面了。但是在开启路由跳转之前为了保险起见需要对URI进行一些校验。详细代码如下：\n\n```\nprivate void dispatchRouterUri(Uri launchUri) {\n        if(RoutingTable.isValidRouterUri(launchUri)) {  //\t判断是否是合法的URI，这里只有URI携带了Path才算合法\n            if(App.isRootActivityLaunched()) { // app已启动\n                if(RoutingTable.isWxUri(launchUri)) { //\t如果是微信的URI那么目的地是要跳转到小程序的（此处为项目中的需求）\n                    RoutingTable.openMiniProgram(this, launchUri);\n                    finish();\n                    return;\n                }\n                //\t通过ARouter路由到目的页面\n               ARouter.getInstance().build(launchUri).navigation();\n            } else {  // app未启动, 保存router uri, 幷尝试启动app\n               SharedPreferUtil.put(Constants.ROUTER_URI, launchUri.toString());\n               launchApp();\n            }\n        } else {  //\t 走到此处可能是因为URI没有携带Path，即并非要跳转目的页面，而是要启动APP  。因此直接启动App即可\n            launchApp();\n        }\n        finish();\n    }\n```\n上面代码中，我们对URI做了一系列校验，根据不同的URI做不同的处理。同时我们应该也注意到了，如果APP已经启动了，那么就可以直接跳转对应的页面了，而如果App没有启动，那么则是先将URI保存到了SharedPreference中，接着启动了App。那么此时App启动后会在MainActivity中读取SharedPreference中的配置，如果读取到URI的信息，那么就先将此数据从SharedPreference中移除，然后通过ARouter跳转到URI指定的页面去。MainActivity中的部分代码如下：\n\n```\n#MainActivity\n\nprivate void resumeRoute() {\n        // Continue for interrupted router uri\n        String interruptedLaunchUriString =\n                Configuration.get(Constants.INTERRUPTED_ROUTER_URI, null);\n         //\t移除SharedPreference中的URI，避免下次打开MainActivity错误跳转\n        SharedPreferUtil.remove(Constants.ROUTER_URI);\n        Uri launchUri = null;\n        if(interruptedLaunchUriString != null) { // Activity未启动的情况下 通过外部Scheme跳转非MainActivity\n            launchUri = Uri.parse(interruptedLaunchUriString);\n        }\n\n        if(launchUri == null) {\n            return;\n        }\n\t\t//\t通过路由跳转到URI对应的页面\n        ARouter.getInstance().build(launchUri).navigation();\n    }\n```\n关于ARouter的路由方案所涉及的内容至此已经全部讲完了。","source":"_posts/15.基于Arouter的路由实现方案.md","raw":"---\nlayout: w\ntitle: 基于Arouter的路由实现方案\ndate: 2018-07-26 00:39:03\ntags: \n- Arouter\n---\n这本是一篇应该写在去年的文章，但仅仅因为...懒，这篇文章在草稿箱里静静的躺了一年多，被无限期推迟到了现在。最近刚好完成了公司项目的路由改造，借此机会来对这篇文章做一个了结。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190918012522155.png)\n\n# 一、为什么要在项目中引入路由？\n\n在开始之前我们先来思考一下这个问题。为什么要在项目中引入路由？相信大家的答案可能会有所不同，但是应该也不外乎以下几点：\n\n## 1.为了实现项目组件化\n\n想必很多开发者引入路由的目的都是因为要实现项目组件化。我们知道，组件化的项目各个业务模块之间没有相互的依赖关系。不同业务模块之间的通信最好的解决方案就是支持页面路由。\n\n## 2.方便APP内部跳转\n\n可能有些小伙伴会有疑问，App内部直接通过Intent跳转不是很好吗，为什么要多此一举引入路由呢？当然，通常情况下通过Intent跳转也无伤大雅。但是在某些情况下，比如像下图这样的一个页面：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2019091700111637.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwNTIxNTcz,size_16,color_FFFFFF,t_70)\n这是一个典型的多Type的RecyclerView页面，这个页面中所有的数据都是从服务器获取的，在引入路由之前所有的点击跳转事件都需要后台给我们一个type,我们根据type判断需要向哪一个Activity跳转，并且需要通过Intent携带目的页面所需要的参数。显然这样写会使我们代码变得非常臃肿，代码之间的耦合度也非常高。然而在引入路由之后一切都变得不一样了。我们只需要后台返回目的页面所对应的URL，并在URL上拼接页面跳转所需要的参数，此时前台只需要拿到URL，然后通过路由即可到达对应的页面。这样以来使我们的代码变得简洁明了，并且保证了代码的低耦合。\n\n## 3.方便APP外部跳转\n\n通常可以看到很多应用支持从浏览器唤醒App并跳转到对应的页面。做到比较好的如知乎，体验过知乎的小伙伴应该知道，知乎可以从浏览器唤醒App并且直接在App中打开当前在浏览器中浏览的内容。我们知道，从外部唤起App需要给Activity添加Schema。而如果App内部有许多Activity需要支持外部唤起，我们不可能为这些Activity都添加Schema。那么此时我们就可以单独设置一个支持Schema的Activity，浏览器可以通过Schema唤起这个Activity。而在这个Activity中会接收浏览器传过来的URL，然后根据URL进行路由分发，通过URL路由到对应的页面即可。\n\n# 二 、ARouter的使用\n其实很不想在这篇文章中长篇大论如何使用[ARouter](https://github.com/alibaba/ARouter)，因为[ARouter的官方文档](https://github.com/alibaba/ARouter/blob/master/README_CN.md)上已经非常详细的告诉了开发者如何去使用，只要仔细的阅读ARouter的文档基本上绝大部分问题都可以得到解决。但是为了照顾没有使用过ARouter的小伙伴，这里还是再啰嗦一下。如果你对ARouter的使用已经非常熟悉了那么你可以忽略此章节，直接到下一章了。\n\n## 1.添加依赖和配置\n\n```\nandroid {\n    defaultConfig {\n        ...\n        javaCompileOptions {\n            annotationProcessorOptions {\n                arguments = [AROUTER_MODULE_NAME: project.getName()]\n            }\n        }\n    }\n}\n\ndependencies {\n    // 替换成最新版本, 需要注意的是api\n    // 要与compiler匹配使用，均使用最新版可以保证兼容\n    implementation 'com.alibaba:arouter-api:x.x.x'\n    annotationProcessor 'com.alibaba:arouter-compiler:x.x.x'\n    ...\n}\n```\n这里需要注意，如果你的项目有多个业务模块，那么每个模块都需要在gradle中添加以上配置。\n\n## 2.初始化SDK\n\n```\nif (isDebug()) {           // 这两行必须写在init之前，否则这些配置在init过程中将无效\n    ARouter.openLog();     // 打印日志\n    ARouter.openDebug();   // 开启调试模式(如果在InstantRun模式下运行，必须开启调试模式！线上版本需要关闭,否则有安全风险)\n}\nARouter.init(mApplication); // 尽可能早，推荐在Application中初始化\n```\n\n## 3.添加注解\n\n```\n// 在支持路由的页面上添加注解(必选)\n// 这里的路径需要注意的是至少需要有两级，/xx/xx\n@Route(path = \"/test/activity\")\npublic class YourActivity extend Activity {\n    ...\n}\n```\n\n## 4.发起路由操作\n\n```\n// 1. 应用内简单的跳转(通过URL跳转在'进阶用法'中)\nARouter.getInstance().build(\"/test/activity\").navigation();\n\n// 2. 跳转并携带参数\nARouter.getInstance().build(\"/test/1\")\n            .withLong(\"key1\", 666L)\n            .withString(\"key3\", \"888\")\n            .withObject(\"key4\", new Test(\"Jack\", \"Rose\"))\n            .navigation();\n```\n很多情况下需要通过URL跳转，ARouter支持直接通过URL跳转：\n\n```\n Uri uri= Uri.parse(url);\n ARouter.getInstance().build(uri).navigation();\n```\n\n## 5.路由解析参数\n\n```\n// 为每一个参数声明一个字段，并使用 @Autowired 标注\n// URL中不能传递Parcelable类型数据，通过ARouter api可以传递Parcelable对象\n@Route(path = \"/test/activity\")\npublic class Test1Activity extends Activity {\n    @Autowired\n    public String name;\n    @Autowired\n    int age;\n    \n    // 通过name来映射URL中的不同参数\n    @Autowired(name = \"girl\") \n    boolean boy;\n    \n    // 支持解析自定义对象，URL中使用json传递\n    @Autowired\n    TestObj obj;      \n    \n    // 使用 withObject 传递 List 和 Map 的实现了\n    // Serializable 接口的实现类(ArrayList/HashMap)\n    // 的时候，接收该对象的地方不能标注具体的实现类类型\n    // 应仅标注为 List 或 Map，否则会影响序列化中类型\n    // 的判断, 其他类似情况需要同样处理        \n    @Autowired\n    List<TestObj> list;\n    @Autowired\n    Map<String, List<TestObj>> map;\n    \n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    ARouter.getInstance().inject(this);\n\n    // ARouter会自动对字段进行赋值，无需主动获取\n    Log.d(\"param\", name + age + boy);\n    }\n}\n\n\n// 如果需要传递自定义对象，新建一个类（并非自定义对象类），然后实现 SerializationService,并使用@Route注解标注(方便用户自行选择序列化方式)，例如：\n@Route(path = \"/yourservicegroupname/json\")\npublic class JsonServiceImpl implements SerializationService {\n    @Override\n    public void init(Context context) {\n\n    }\n\n    @Override\n    public <T> T json2Object(String text, Class<T> clazz) {\n        return JSON.parseObject(text, clazz);\n    }\n\n    @Override\n    public String object2Json(Object instance) {\n        return JSON.toJSONString(instance);\n    }\n}\n```\n除了使用@Autowired注解注入参数外，还可以与普通页面跳转一样通过getIntent()获取参数。\n\n以上就是ARouter的一些基本用法，了解这些基本用法之后并不等于已经掌握了ARouter。因为当你实际用到项目中的时候可能会面临诸多问题。\n\n# 三 、ARouter的采坑之路\n如果你只是简单的写一个ARouter使用的Demo，那么可能上一章的内容已经足够了。但是当你在项目中引入ARouter后各种各样的问题便会接踵而至。\n\n## 1.使用ARouter实现登录拦截\n这是在项目中引入ARouter后面临的第一个问题。通常情况下，大部分App不登录便可以进入主页面，在跳转需要用户权限的页面时会首先跳转到登录页面引导用户登录。我相信大部分的开发在最初时候都写过类似这样的代码：\n\n```\n if (isLogin) {\n     goToDestination();\n  } else {\n     goToLogin();\n  }\n```\n在每次跳转页面的时候都需要进行是否登录的判断，这样的代码显然有很大的弊端。而ARouter为我们提供了面向切面的登录拦截功能，ARouter的文档上给了我们一个例子：\n\n```\n// 比较经典的应用就是在跳转过程中处理登陆事件，这样就不需要在目标页重复做登陆检查\n// 拦截器会在跳转之间执行，多个拦截器会按优先级顺序依次执行\n@Interceptor(priority = 8, name = \"测试用拦截器\")\npublic class TestInterceptor implements IInterceptor {\n    @Override\n    public void process(Postcard postcard, InterceptorCallback callback) {\n    ...\n    callback.onContinue(postcard);  // 处理完成，交还控制权\n    // callback.onInterrupt(new RuntimeException(\"我觉得有点异常\"));      // 觉得有问题，中断路由流程\n\n    // 以上两种至少需要调用其中一种，否则不会继续路由\n    }\n\n    @Override\n    public void init(Context context) {\n    // 拦截器的初始化，会在sdk初始化的时候调用该方法，仅会调用一次\n    }\n}\n```\n如果你按着官方文档上这样写，那么你大概率会碰到很多问题。列举如下：\n**如何处理有些页面需要登录拦截，有些页面不需要登录拦截？**\n如果你添加了拦截器，那么在每次路由跳转时都会优先走到拦截器中，在拦截器的process()方法中你可以通过判断当前是否登录来决定是否继续该路由操作，如果已经登录，那么直接通过 callback.onContinue(postcard)继续当前路由，而如果没有登录，那么就将目的页面修改为登录页。但是，不要忘了，添加拦截器后所有的路由操作都会优先走到这里，而我们的需求是只有需要用户权限的时候才需要跳转到登录页，否则即使没有登录依然可以跳转到目的页。此时我们应该怎么办？\n如果你仔细的看了ARouter的开发文档，你可能注意到在@Route的注解有一个int类型的extras参数。如此我们便可以通过这个参数来对Activity进行标记是否需要登录：\n\n```\n@Route(path = PATH_TEST, extras = IGNORE_LOGIN)\npublic class TestActivity extends BaseTitleCompatActivity {}\n```\n接下来，在拦截器中可以拿到extras参数，以此来确定该页面是否需要登录：\n\n```\nif(UserInfoTools.isLogin() || IGNORE_LOGIN == postcard.getExtra()) {  //  已经登录或者不需要拦截的情况\n\t //  继续当前路由\n      callback.onContinue(postcard);\n } else {\t// 未登录且需要登录的情况\n    //\t路由到登录页面\n    ARouter.getInstance().build(RoutingTable.PATH_GUEST_LOGIN).navigation();\n    ...\n  }\n```\n到这里这个问题解决了，但是当你兴致勃勃的运行起来App,在未登录的情况下点击跳转到需要用户权限的页面，你憧憬着跳转页面会被拦截到登录页，但是你又被无情的事实打脸了。竟然页面毫无反应？于是你断点、打Log发现ARouter.getInstance().build(RoutingTable.PATH_GUEST_LOGIN).navigation()这句代码确实执行了，但是为什么没有跳转到登录页？于是你苦思冥想，突然灵光一闪，哇！是因为这一句路由也会走到了拦截器里，如此岂不成了一个死循环。于是你Google如何解决，发现原来需要调用greenChannel()来避免出现死循环。于是有了如下代码：\n\n```\nif(UserInfoTools.isLogin() || IGNORE_LOGIN == postcard.getExtra()) {  //  已经登录或者不需要拦截的情况\n\t //  继续当前路由\n      callback.onContinue(postcard);\n } else {\t// 未登录且需要登录的情况\n    //\t路由到登录页面\n   ARouter.getInstance().build(RoutingTable.PATH_GUEST_LOGIN).greenChannel().navigation();\n    ...\n  }\n```\n修改之后你怀着和刚才一样的心情兴致勃勃的运行起来App,心想，这次一定没问题。好！点击按钮....竟然成功跳转到了登录页面。于是你兴奋起来，疯狂的点击这些页面，发现都没问题。可是...当你点了几次之后突然发现，页面跳转无效了！！你简直不敢相信自己的眼睛，刚才明明是好好的...于是你在此陷入了沉思。\n好吧，这次直接公布答案了，那是因为你需要将原来的路由打断，而之所以前几次有效大概猜测是因为greenChannel()去开启了多个channel，而ARouter的channel是有限的，因此在点击几次之后路由再次失效了。于是修改后代码如下：\n\n```\nif(UserInfoTools.isLogin() || IGNORE_LOGIN == postcard.getExtra()) {  //  已经登录或者不需要拦截的情况\n\t //  继续当前路由\n      callback.onContinue(postcard);\n } else {\t// 未登录且需要登录的情况\n    //\t路由到登录页面\n   ARouter.getInstance().build(RoutingTable.PATH_GUEST_LOGIN).greenChannel().navigation();\n   callback.onInterrupt(null);\n  }\n```\n关于登录拦截看似简单，实则使用时候竟然会碰到这么多问题！相信第一次使用时都会被虐的掉眼泪。\n\n## 2.处理一个Activity对应多个路径的情况\n在某些情况可能出现一个页面对应多个路径的情况。出现这种情况的原因可能是前期路由没有规划好，导致后边版本的路由路径做了修改。从而出现了一个Activity对应多个页面的情况。为了兼容旧版路由，我们不得不处理这种情况。但是，Route的注解中path是唯一的，并不能通过@Route注解解决一个Activity对应多个路径的情况。此时就需要用到ARouter的重写URL的功能。只需要实现PathReplaceService 接口，在重写的方法中对URI或者Path进行替换即可，注意，这个类一定要加@Route注解。代码参考如下：\n\n```\n@Route(path = \"/lost/service\")\npublic class ARouterLostReplaceService implements PathReplaceService {\n    @Override\n    public String forString(String path) {\t//\t对于path处理与uri类似\n        return path;\n    }\n\n    @Override\n    public Uri forUri(Uri uri) {\t\n        String path = uri.getPath();\n        if(PATH_LOST1.equals(path)) {\n            uri = replaceUriPath(uri, PATH_REAL1);\n        } else if(PATH_LOST2.equals(path)) {\n            uri = replaceUriPath(uri, PATH_REAL2);\n        }\n        return uri;\n    }\n\n    @Override\n    public void init(Context context) {\n\n    }\n\n    /**\n     * 替换URI中的path\n     * \n     * @param uri 被替换的uri\n     * @param path 要替换的path\n     * @return 替换后的uri\n     */\n    private Uri replaceUriPath(Uri uri, String path) {\n        StringBuilder resultUrl = new StringBuilder(uri.getScheme() + \"://\" + uri.getHost() + path);\n        String[] split = uri.toString().split(\"\\\\?\");\n        if(split.length >= 2) {\n            resultUrl.append(\"?\").append(split[1]);\n        }\n        return Uri.parse(resultUrl.toString());\n    }\n}\n```\n\n## 3.ARouter全局降级策略\n在路由跳转时可能会出现找不到Path对应页面的情况，对于这种情况可以通过实现DegradeService 接口来处理，同样这个类也必须要添加@Route注解。这样当路由跳转时找不到路径就会走到这个类的onLost方法中，此时就可以在这个方法中来做相应的处理了。\n\n```\n// 实现DegradeService接口，并加上一个Path内容任意的注解即可\n@Route(path = \"/lost/path\")\npublic class DegradeServiceImpl implements DegradeService {\n\t@Override\n\tpublic void onLost(Context context, Postcard postcard) {\n\t    //  可以在此处统一处理，比如跳转到首页\n\t}\n\n\t@Override\n\tpublic void init(Context context) {\n\n\t}\n}\n```\n\n# 四、通过浏览器跳转到App对应页面\n\n\n## 1.Schema协议\n很多人对于Schema协议比较陌生，但是如果说URL大家一定都非常熟悉。其实URL就是一种Schema协议。Schema协议通常由四部分组成：\n\n```\n [scheme]://[host]/[path]?[query]\n scheme：表示协议名称\n host：Schema所作用的地址域\n path：Schema指定的路径\n query：携带的参数\n```\n拿百度搜索的URL来举例子：https://www.baidu.com/s?wd=要搜索的关键字。这个URL与Schema协议的对应关系如下\n\n>\n> schema:：https\n> host： www.baidu.com\n> path： /s\n> query：wd=要搜索的关键字\n> \n了解了Schema协议后，其实我们完全可以按照Schema协议的格式来自定义一个Schema链接，如下：\n\n> myApp://www.myApp.com/main/home?id=1\n> \n> 我们自己定义的Schema链接的对应关系为：\n>  schema:：myApp\n> host：www.myApp.com\n> path：/main/home\n> query：id=1\n\n\n## 2.通过Schema链接打开Activity\n通过浏览器打开App其实就是通过Schema链接来实现的。我们就以上一节中自定义的Schema链接为例来实现浏览器打开App。首先在项目中添加一个RouterActivity，RouterActivity在AndroidManifest中的配置如下：\n\n```\n<activity\n      android:name=\".activity.RouterActivity\"\n      android:configChanges=\"orientation|keyboardHidden|screenSize\"\n      android:screenOrientation=\"portrait\">\n      <intent-filter>\n          <action android:name=\"android.intent.action.VIEW\" />\n          <category android:name=\"android.intent.category.DEFAULT\" />\n           <category android:name=\"android.intent.category.BROWSABLE\" />\n           <data android:scheme=\"myApp\" />\n      </intent-filter>\n</activity>\n```\n我们在AndroidManifest中为RouterActivity添加了schema，此时在HTML中写入以下代码：\n\n```\n<a href=\"myApp://www.myApp.com/main/home?id=1\">打开APP</a>\n```\n通过点击HTML页面的\"打开App\"便可启动RouterActivity。并且RouterActivity启动后可以通过Intent获取到启动的URI。代码如下：\n\n```\n   #RouterActivity\n  \n\t@Override\n    protected void onCreate(Bundle data) {\n        super.onCreate(data);\n        Uri launchUri = getIntent().getData();\n        dispatchRouterUri(launchUri);\n    }\n```\n至此，我们已经可以通过App来打开项目的RouterActivity。\n\n## 3.通过路由跳转到目的页面\n上一节中我们通过HTML打开了RouterActivity，并在RouterActivity中拿到了跳转的URI，那么接下来我们便可以根据URI的信息打开对应的页面了。但是在开启路由跳转之前为了保险起见需要对URI进行一些校验。详细代码如下：\n\n```\nprivate void dispatchRouterUri(Uri launchUri) {\n        if(RoutingTable.isValidRouterUri(launchUri)) {  //\t判断是否是合法的URI，这里只有URI携带了Path才算合法\n            if(App.isRootActivityLaunched()) { // app已启动\n                if(RoutingTable.isWxUri(launchUri)) { //\t如果是微信的URI那么目的地是要跳转到小程序的（此处为项目中的需求）\n                    RoutingTable.openMiniProgram(this, launchUri);\n                    finish();\n                    return;\n                }\n                //\t通过ARouter路由到目的页面\n               ARouter.getInstance().build(launchUri).navigation();\n            } else {  // app未启动, 保存router uri, 幷尝试启动app\n               SharedPreferUtil.put(Constants.ROUTER_URI, launchUri.toString());\n               launchApp();\n            }\n        } else {  //\t 走到此处可能是因为URI没有携带Path，即并非要跳转目的页面，而是要启动APP  。因此直接启动App即可\n            launchApp();\n        }\n        finish();\n    }\n```\n上面代码中，我们对URI做了一系列校验，根据不同的URI做不同的处理。同时我们应该也注意到了，如果APP已经启动了，那么就可以直接跳转对应的页面了，而如果App没有启动，那么则是先将URI保存到了SharedPreference中，接着启动了App。那么此时App启动后会在MainActivity中读取SharedPreference中的配置，如果读取到URI的信息，那么就先将此数据从SharedPreference中移除，然后通过ARouter跳转到URI指定的页面去。MainActivity中的部分代码如下：\n\n```\n#MainActivity\n\nprivate void resumeRoute() {\n        // Continue for interrupted router uri\n        String interruptedLaunchUriString =\n                Configuration.get(Constants.INTERRUPTED_ROUTER_URI, null);\n         //\t移除SharedPreference中的URI，避免下次打开MainActivity错误跳转\n        SharedPreferUtil.remove(Constants.ROUTER_URI);\n        Uri launchUri = null;\n        if(interruptedLaunchUriString != null) { // Activity未启动的情况下 通过外部Scheme跳转非MainActivity\n            launchUri = Uri.parse(interruptedLaunchUriString);\n        }\n\n        if(launchUri == null) {\n            return;\n        }\n\t\t//\t通过路由跳转到URI对应的页面\n        ARouter.getInstance().build(launchUri).navigation();\n    }\n```\n关于ARouter的路由方案所涉及的内容至此已经全部讲完了。","slug":"15.基于Arouter的路由实现方案","published":1,"updated":"2020-08-29T01:51:06.939Z","comments":1,"photos":[],"link":"","_id":"ckegm5nsl0016dwozehrl6v2k","content":"<p>这本是一篇应该写在去年的文章，但仅仅因为…懒，这篇文章在草稿箱里静静的躺了一年多，被无限期推迟到了现在。最近刚好完成了公司项目的路由改造，借此机会来对这篇文章做一个了结。<br><img src=\"https://img-blog.csdnimg.cn/20190918012522155.png\" alt=\"在这里插入图片描述\"></p>\n<h1 id=\"一、为什么要在项目中引入路由？\"><a href=\"#一、为什么要在项目中引入路由？\" class=\"headerlink\" title=\"一、为什么要在项目中引入路由？\"></a>一、为什么要在项目中引入路由？</h1><p>在开始之前我们先来思考一下这个问题。为什么要在项目中引入路由？相信大家的答案可能会有所不同，但是应该也不外乎以下几点：</p>\n<h2 id=\"1-为了实现项目组件化\"><a href=\"#1-为了实现项目组件化\" class=\"headerlink\" title=\"1.为了实现项目组件化\"></a>1.为了实现项目组件化</h2><p>想必很多开发者引入路由的目的都是因为要实现项目组件化。我们知道，组件化的项目各个业务模块之间没有相互的依赖关系。不同业务模块之间的通信最好的解决方案就是支持页面路由。</p>\n<h2 id=\"2-方便APP内部跳转\"><a href=\"#2-方便APP内部跳转\" class=\"headerlink\" title=\"2.方便APP内部跳转\"></a>2.方便APP内部跳转</h2><p>可能有些小伙伴会有疑问，App内部直接通过Intent跳转不是很好吗，为什么要多此一举引入路由呢？当然，通常情况下通过Intent跳转也无伤大雅。但是在某些情况下，比如像下图这样的一个页面：<br><img src=\"https://img-blog.csdnimg.cn/2019091700111637.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwNTIxNTcz,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>这是一个典型的多Type的RecyclerView页面，这个页面中所有的数据都是从服务器获取的，在引入路由之前所有的点击跳转事件都需要后台给我们一个type,我们根据type判断需要向哪一个Activity跳转，并且需要通过Intent携带目的页面所需要的参数。显然这样写会使我们代码变得非常臃肿，代码之间的耦合度也非常高。然而在引入路由之后一切都变得不一样了。我们只需要后台返回目的页面所对应的URL，并在URL上拼接页面跳转所需要的参数，此时前台只需要拿到URL，然后通过路由即可到达对应的页面。这样以来使我们的代码变得简洁明了，并且保证了代码的低耦合。</p>\n<h2 id=\"3-方便APP外部跳转\"><a href=\"#3-方便APP外部跳转\" class=\"headerlink\" title=\"3.方便APP外部跳转\"></a>3.方便APP外部跳转</h2><p>通常可以看到很多应用支持从浏览器唤醒App并跳转到对应的页面。做到比较好的如知乎，体验过知乎的小伙伴应该知道，知乎可以从浏览器唤醒App并且直接在App中打开当前在浏览器中浏览的内容。我们知道，从外部唤起App需要给Activity添加Schema。而如果App内部有许多Activity需要支持外部唤起，我们不可能为这些Activity都添加Schema。那么此时我们就可以单独设置一个支持Schema的Activity，浏览器可以通过Schema唤起这个Activity。而在这个Activity中会接收浏览器传过来的URL，然后根据URL进行路由分发，通过URL路由到对应的页面即可。</p>\n<h1 id=\"二-、ARouter的使用\"><a href=\"#二-、ARouter的使用\" class=\"headerlink\" title=\"二 、ARouter的使用\"></a>二 、ARouter的使用</h1><p>其实很不想在这篇文章中长篇大论如何使用<a href=\"https://github.com/alibaba/ARouter\">ARouter</a>，因为<a href=\"https://github.com/alibaba/ARouter/blob/master/README_CN.md\">ARouter的官方文档</a>上已经非常详细的告诉了开发者如何去使用，只要仔细的阅读ARouter的文档基本上绝大部分问题都可以得到解决。但是为了照顾没有使用过ARouter的小伙伴，这里还是再啰嗦一下。如果你对ARouter的使用已经非常熟悉了那么你可以忽略此章节，直接到下一章了。</p>\n<h2 id=\"1-添加依赖和配置\"><a href=\"#1-添加依赖和配置\" class=\"headerlink\" title=\"1.添加依赖和配置\"></a>1.添加依赖和配置</h2><pre><code class=\"hljs properties\"><span class=\"hljs-attr\">android</span> <span class=\"hljs-string\">&#123;</span>\n    <span class=\"hljs-attr\">defaultConfig</span> <span class=\"hljs-string\">&#123;</span>\n        <span class=\"hljs-attr\">...</span>\n        <span class=\"hljs-attr\">javaCompileOptions</span> <span class=\"hljs-string\">&#123;</span>\n            <span class=\"hljs-attr\">annotationProcessorOptions</span> <span class=\"hljs-string\">&#123;</span>\n                <span class=\"hljs-attr\">arguments</span> = <span class=\"hljs-string\">[AROUTER_MODULE_NAME: project.getName()]</span>\n            <span class=\"hljs-attr\">&#125;</span>\n        <span class=\"hljs-attr\">&#125;</span>\n    <span class=\"hljs-attr\">&#125;</span>\n<span class=\"hljs-attr\">&#125;</span>\n\n<span class=\"hljs-attr\">dependencies</span> <span class=\"hljs-string\">&#123;</span>\n    <span class=\"hljs-meta\">//</span> <span class=\"hljs-string\">替换成最新版本, 需要注意的是api</span>\n    <span class=\"hljs-meta\">//</span> <span class=\"hljs-string\">要与compiler匹配使用，均使用最新版可以保证兼容</span>\n    <span class=\"hljs-attr\">implementation</span> <span class=\"hljs-string\">&#x27;com.alibaba:arouter-api:x.x.x&#x27;</span>\n    <span class=\"hljs-attr\">annotationProcessor</span> <span class=\"hljs-string\">&#x27;com.alibaba:arouter-compiler:x.x.x&#x27;</span>\n    <span class=\"hljs-attr\">...</span>\n<span class=\"hljs-attr\">&#125;</span></code></pre>\n<p>这里需要注意，如果你的项目有多个业务模块，那么每个模块都需要在gradle中添加以上配置。</p>\n<h2 id=\"2-初始化SDK\"><a href=\"#2-初始化SDK\" class=\"headerlink\" title=\"2.初始化SDK\"></a>2.初始化SDK</h2><pre><code class=\"hljs reasonml\"><span class=\"hljs-keyword\">if</span> (is<span class=\"hljs-constructor\">Debug()</span>) &#123;           <span class=\"hljs-comment\">// 这两行必须写在init之前，否则这些配置在init过程中将无效</span>\n    <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">ARouter</span>.</span></span><span class=\"hljs-keyword\">open</span><span class=\"hljs-constructor\">Log()</span>;     <span class=\"hljs-comment\">// 打印日志</span>\n    <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">ARouter</span>.</span></span><span class=\"hljs-keyword\">open</span><span class=\"hljs-constructor\">Debug()</span>;   <span class=\"hljs-comment\">// 开启调试模式(如果在InstantRun模式下运行，必须开启调试模式！线上版本需要关闭,否则有安全风险)</span>\n&#125;\n<span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">ARouter</span>.</span></span>init(mApplication); <span class=\"hljs-comment\">// 尽可能早，推荐在Application中初始化</span></code></pre>\n\n<h2 id=\"3-添加注解\"><a href=\"#3-添加注解\" class=\"headerlink\" title=\"3.添加注解\"></a>3.添加注解</h2><pre><code class=\"hljs angelscript\"><span class=\"hljs-comment\">// 在支持路由的页面上添加注解(必选)</span>\n<span class=\"hljs-comment\">// 这里的路径需要注意的是至少需要有两级，/xx/xx</span>\n@Route(path = <span class=\"hljs-string\">&quot;/test/activity&quot;</span>)\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-symbol\">YourActivity</span> <span class=\"hljs-symbol\">extend</span> <span class=\"hljs-symbol\">Activity</span> &#123;\n    ...\n&#125;</code></pre>\n\n<h2 id=\"4-发起路由操作\"><a href=\"#4-发起路由操作\" class=\"headerlink\" title=\"4.发起路由操作\"></a>4.发起路由操作</h2><pre><code class=\"hljs reasonml\"><span class=\"hljs-comment\">// 1. 应用内简单的跳转(通过URL跳转在&#x27;进阶用法&#x27;中)</span>\n<span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">ARouter</span>.</span></span>get<span class=\"hljs-constructor\">Instance()</span>.build(<span class=\"hljs-string\">&quot;/test/activity&quot;</span>).navigation<span class=\"hljs-literal\">()</span>;\n\n<span class=\"hljs-comment\">// 2. 跳转并携带参数</span>\n<span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">ARouter</span>.</span></span>get<span class=\"hljs-constructor\">Instance()</span>.build(<span class=\"hljs-string\">&quot;/test/1&quot;</span>)\n            .<span class=\"hljs-keyword\">with</span><span class=\"hljs-constructor\">Long(<span class=\"hljs-string\">&quot;key1&quot;</span>, 666L)</span>\n            .<span class=\"hljs-keyword\">with</span><span class=\"hljs-constructor\">String(<span class=\"hljs-string\">&quot;key3&quot;</span>, <span class=\"hljs-string\">&quot;888&quot;</span>)</span>\n            .<span class=\"hljs-keyword\">with</span><span class=\"hljs-constructor\">Object(<span class=\"hljs-string\">&quot;key4&quot;</span>, <span class=\"hljs-params\">new</span> Test(<span class=\"hljs-string\">&quot;Jack&quot;</span>, <span class=\"hljs-string\">&quot;Rose&quot;</span>)</span>)\n            .navigation<span class=\"hljs-literal\">()</span>;</code></pre>\n<p>很多情况下需要通过URL跳转，ARouter支持直接通过URL跳转：</p>\n<pre><code class=\"hljs reasonml\">Uri uri= <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">Uri</span>.</span></span>parse(url);\n<span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">ARouter</span>.</span></span>get<span class=\"hljs-constructor\">Instance()</span>.build(uri).navigation<span class=\"hljs-literal\">()</span>;</code></pre>\n\n<h2 id=\"5-路由解析参数\"><a href=\"#5-路由解析参数\" class=\"headerlink\" title=\"5.路由解析参数\"></a>5.路由解析参数</h2><pre><code class=\"hljs aspectj\"><span class=\"hljs-comment\">// 为每一个参数声明一个字段，并使用 @Autowired 标注</span>\n<span class=\"hljs-comment\">// URL中不能传递Parcelable类型数据，通过ARouter api可以传递Parcelable对象</span>\n<span class=\"hljs-meta\">@Route</span>(path = <span class=\"hljs-string\">&quot;/test/activity&quot;</span>)\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Test1Activity</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Activity</span> </span>&#123;\n    <span class=\"hljs-meta\">@Autowired</span>\n    <span class=\"hljs-keyword\">public</span> String name;\n    <span class=\"hljs-meta\">@Autowired</span>\n    <span class=\"hljs-keyword\">int</span> age;\n    \n    <span class=\"hljs-comment\">// 通过name来映射URL中的不同参数</span>\n    <span class=\"hljs-meta\">@Autowired</span>(name = <span class=\"hljs-string\">&quot;girl&quot;</span>) \n    <span class=\"hljs-keyword\">boolean</span> boy;\n    \n    <span class=\"hljs-comment\">// 支持解析自定义对象，URL中使用json传递</span>\n    <span class=\"hljs-meta\">@Autowired</span>\n    TestObj obj;      \n    \n    <span class=\"hljs-comment\">// 使用 withObject 传递 List 和 Map 的实现了</span>\n    <span class=\"hljs-comment\">// Serializable 接口的实现类(ArrayList/HashMap)</span>\n    <span class=\"hljs-comment\">// 的时候，接收该对象的地方不能标注具体的实现类类型</span>\n    <span class=\"hljs-comment\">// 应仅标注为 List 或 Map，否则会影响序列化中类型</span>\n    <span class=\"hljs-comment\">// 的判断, 其他类似情况需要同样处理        </span>\n    <span class=\"hljs-meta\">@Autowired</span>\n    List&lt;TestObj&gt; list;\n    <span class=\"hljs-meta\">@Autowired</span>\n    Map&lt;String, List&lt;TestObj&gt;&gt; map;\n    \n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-keyword\">protected</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onCreate</span><span class=\"hljs-params\">(Bundle savedInstanceState)</span> </span>&#123;\n    <span class=\"hljs-keyword\">super</span>.onCreate(savedInstanceState);\n    ARouter.getInstance().inject(<span class=\"hljs-keyword\">this</span>);\n\n    <span class=\"hljs-comment\">// ARouter会自动对字段进行赋值，无需主动获取</span>\n    Log.d(<span class=\"hljs-string\">&quot;param&quot;</span>, name + age + boy);\n    &#125;\n&#125;\n\n\n<span class=\"hljs-comment\">// 如果需要传递自定义对象，新建一个类（并非自定义对象类），然后实现 SerializationService,并使用@Route注解标注(方便用户自行选择序列化方式)，例如：</span>\n<span class=\"hljs-meta\">@Route</span>(path = <span class=\"hljs-string\">&quot;/yourservicegroupname/json&quot;</span>)\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">JsonServiceImpl</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">SerializationService</span> </span>&#123;\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">init</span><span class=\"hljs-params\">(Context context)</span> </span>&#123;\n\n    &#125;\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-keyword\">public</span> &lt;T&gt; <span class=\"hljs-function\">T <span class=\"hljs-title\">json2Object</span><span class=\"hljs-params\">(String text, Class&lt;T&gt; clazz)</span> </span>&#123;\n        <span class=\"hljs-function\"><span class=\"hljs-keyword\">return</span> JSON.<span class=\"hljs-title\">parseObject</span><span class=\"hljs-params\">(text, clazz)</span></span>;\n    &#125;\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-function\">String <span class=\"hljs-title\">object2Json</span><span class=\"hljs-params\">(Object instance)</span> </span>&#123;\n        <span class=\"hljs-function\"><span class=\"hljs-keyword\">return</span> JSON.<span class=\"hljs-title\">toJSONString</span><span class=\"hljs-params\">(instance)</span></span>;\n    &#125;\n&#125;</code></pre>\n<p>除了使用@Autowired注解注入参数外，还可以与普通页面跳转一样通过getIntent()获取参数。</p>\n<p>以上就是ARouter的一些基本用法，了解这些基本用法之后并不等于已经掌握了ARouter。因为当你实际用到项目中的时候可能会面临诸多问题。</p>\n<h1 id=\"三-、ARouter的采坑之路\"><a href=\"#三-、ARouter的采坑之路\" class=\"headerlink\" title=\"三 、ARouter的采坑之路\"></a>三 、ARouter的采坑之路</h1><p>如果你只是简单的写一个ARouter使用的Demo，那么可能上一章的内容已经足够了。但是当你在项目中引入ARouter后各种各样的问题便会接踵而至。</p>\n<h2 id=\"1-使用ARouter实现登录拦截\"><a href=\"#1-使用ARouter实现登录拦截\" class=\"headerlink\" title=\"1.使用ARouter实现登录拦截\"></a>1.使用ARouter实现登录拦截</h2><p>这是在项目中引入ARouter后面临的第一个问题。通常情况下，大部分App不登录便可以进入主页面，在跳转需要用户权限的页面时会首先跳转到登录页面引导用户登录。我相信大部分的开发在最初时候都写过类似这样的代码：</p>\n<pre><code class=\"hljs isbl\"><span class=\"hljs-variable\"><span class=\"hljs-keyword\">if</span></span> (<span class=\"hljs-variable\">isLogin</span>) &#123;\n    <span class=\"hljs-function\"><span class=\"hljs-title\">goToDestination</span>();</span>\n<span class=\"hljs-function\"> &#125; <span class=\"hljs-variable\"><span class=\"hljs-keyword\">else</span></span> &#123;</span>\n<span class=\"hljs-function\">    <span class=\"hljs-title\">goToLogin</span>();</span>\n<span class=\"hljs-function\"> &#125;</span></code></pre>\n<p>在每次跳转页面的时候都需要进行是否登录的判断，这样的代码显然有很大的弊端。而ARouter为我们提供了面向切面的登录拦截功能，ARouter的文档上给了我们一个例子：</p>\n<pre><code class=\"hljs less\"><span class=\"hljs-comment\">// 比较经典的应用就是在跳转过程中处理登陆事件，这样就不需要在目标页重复做登陆检查</span>\n<span class=\"hljs-comment\">// 拦截器会在跳转之间执行，多个拦截器会按优先级顺序依次执行</span>\n<span class=\"hljs-variable\">@Interceptor</span>(priority = <span class=\"hljs-number\">8</span>, name = <span class=\"hljs-string\">&quot;测试用拦截器&quot;</span>)\npublic class TestInterceptor implements IInterceptor &#123;\n    <span class=\"hljs-variable\">@Override</span>\n    public void process(Postcard postcard, InterceptorCallback callback) &#123;\n    ...\n    <span class=\"hljs-selector-tag\">callback</span><span class=\"hljs-selector-class\">.onContinue</span>(postcard);  <span class=\"hljs-comment\">// 处理完成，交还控制权</span>\n    <span class=\"hljs-comment\">// callback.onInterrupt(new RuntimeException(&quot;我觉得有点异常&quot;));      // 觉得有问题，中断路由流程</span>\n\n    <span class=\"hljs-comment\">// 以上两种至少需要调用其中一种，否则不会继续路由</span>\n    &#125;\n\n    <span class=\"hljs-variable\">@Override</span>\n    public void init(Context context) &#123;\n    <span class=\"hljs-comment\">// 拦截器的初始化，会在sdk初始化的时候调用该方法，仅会调用一次</span>\n    &#125;\n&#125;</code></pre>\n<p>如果你按着官方文档上这样写，那么你大概率会碰到很多问题。列举如下：<br><strong>如何处理有些页面需要登录拦截，有些页面不需要登录拦截？</strong><br>如果你添加了拦截器，那么在每次路由跳转时都会优先走到拦截器中，在拦截器的process()方法中你可以通过判断当前是否登录来决定是否继续该路由操作，如果已经登录，那么直接通过 callback.onContinue(postcard)继续当前路由，而如果没有登录，那么就将目的页面修改为登录页。但是，不要忘了，添加拦截器后所有的路由操作都会优先走到这里，而我们的需求是只有需要用户权限的时候才需要跳转到登录页，否则即使没有登录依然可以跳转到目的页。此时我们应该怎么办？<br>如果你仔细的看了ARouter的开发文档，你可能注意到在@Route的注解有一个int类型的extras参数。如此我们便可以通过这个参数来对Activity进行标记是否需要登录：</p>\n<pre><code class=\"hljs scala\"><span class=\"hljs-meta\">@Route</span>(path = <span class=\"hljs-type\">PATH_TEST</span>, extras = <span class=\"hljs-type\">IGNORE_LOGIN</span>)\npublic <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">TestActivity</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">BaseTitleCompatActivity</span> </span>&#123;&#125;</code></pre>\n<p>接下来，在拦截器中可以拿到extras参数，以此来确定该页面是否需要登录：</p>\n<pre><code class=\"hljs reasonml\"><span class=\"hljs-keyword\">if</span>(<span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">UserInfoTools</span>.</span></span>is<span class=\"hljs-constructor\">Login()</span><span class=\"hljs-operator\"> || </span>IGNORE_LOGIN<span class=\"hljs-operator\"> == </span>postcard.get<span class=\"hljs-constructor\">Extra()</span>) &#123;  <span class=\"hljs-comment\">//  已经登录或者不需要拦截的情况</span>\n\t <span class=\"hljs-comment\">//  继续当前路由</span>\n      callback.on<span class=\"hljs-constructor\">Continue(<span class=\"hljs-params\">postcard</span>)</span>;\n &#125; <span class=\"hljs-keyword\">else</span> &#123;\t<span class=\"hljs-comment\">// 未登录且需要登录的情况</span>\n    <span class=\"hljs-comment\">//\t路由到登录页面</span>\n    <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">ARouter</span>.</span></span>get<span class=\"hljs-constructor\">Instance()</span>.build(RoutingTable.PATH_GUEST_LOGIN).navigation<span class=\"hljs-literal\">()</span>;\n    ...\n  &#125;</code></pre>\n<p>到这里这个问题解决了，但是当你兴致勃勃的运行起来App,在未登录的情况下点击跳转到需要用户权限的页面，你憧憬着跳转页面会被拦截到登录页，但是你又被无情的事实打脸了。竟然页面毫无反应？于是你断点、打Log发现ARouter.getInstance().build(RoutingTable.PATH_GUEST_LOGIN).navigation()这句代码确实执行了，但是为什么没有跳转到登录页？于是你苦思冥想，突然灵光一闪，哇！是因为这一句路由也会走到了拦截器里，如此岂不成了一个死循环。于是你Google如何解决，发现原来需要调用greenChannel()来避免出现死循环。于是有了如下代码：</p>\n<pre><code class=\"hljs reasonml\"><span class=\"hljs-keyword\">if</span>(<span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">UserInfoTools</span>.</span></span>is<span class=\"hljs-constructor\">Login()</span><span class=\"hljs-operator\"> || </span>IGNORE_LOGIN<span class=\"hljs-operator\"> == </span>postcard.get<span class=\"hljs-constructor\">Extra()</span>) &#123;  <span class=\"hljs-comment\">//  已经登录或者不需要拦截的情况</span>\n\t <span class=\"hljs-comment\">//  继续当前路由</span>\n      callback.on<span class=\"hljs-constructor\">Continue(<span class=\"hljs-params\">postcard</span>)</span>;\n &#125; <span class=\"hljs-keyword\">else</span> &#123;\t<span class=\"hljs-comment\">// 未登录且需要登录的情况</span>\n    <span class=\"hljs-comment\">//\t路由到登录页面</span>\n   <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">ARouter</span>.</span></span>get<span class=\"hljs-constructor\">Instance()</span>.build(RoutingTable.PATH_GUEST_LOGIN).green<span class=\"hljs-constructor\">Channel()</span>.navigation<span class=\"hljs-literal\">()</span>;\n    ...\n  &#125;</code></pre>\n<p>修改之后你怀着和刚才一样的心情兴致勃勃的运行起来App,心想，这次一定没问题。好！点击按钮….竟然成功跳转到了登录页面。于是你兴奋起来，疯狂的点击这些页面，发现都没问题。可是…当你点了几次之后突然发现，页面跳转无效了！！你简直不敢相信自己的眼睛，刚才明明是好好的…于是你在此陷入了沉思。<br>好吧，这次直接公布答案了，那是因为你需要将原来的路由打断，而之所以前几次有效大概猜测是因为greenChannel()去开启了多个channel，而ARouter的channel是有限的，因此在点击几次之后路由再次失效了。于是修改后代码如下：</p>\n<pre><code class=\"hljs reasonml\"><span class=\"hljs-keyword\">if</span>(<span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">UserInfoTools</span>.</span></span>is<span class=\"hljs-constructor\">Login()</span><span class=\"hljs-operator\"> || </span>IGNORE_LOGIN<span class=\"hljs-operator\"> == </span>postcard.get<span class=\"hljs-constructor\">Extra()</span>) &#123;  <span class=\"hljs-comment\">//  已经登录或者不需要拦截的情况</span>\n\t <span class=\"hljs-comment\">//  继续当前路由</span>\n      callback.on<span class=\"hljs-constructor\">Continue(<span class=\"hljs-params\">postcard</span>)</span>;\n &#125; <span class=\"hljs-keyword\">else</span> &#123;\t<span class=\"hljs-comment\">// 未登录且需要登录的情况</span>\n    <span class=\"hljs-comment\">//\t路由到登录页面</span>\n   <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">ARouter</span>.</span></span>get<span class=\"hljs-constructor\">Instance()</span>.build(RoutingTable.PATH_GUEST_LOGIN).green<span class=\"hljs-constructor\">Channel()</span>.navigation<span class=\"hljs-literal\">()</span>;\n   callback.on<span class=\"hljs-constructor\">Interrupt(<span class=\"hljs-params\">null</span>)</span>;\n  &#125;</code></pre>\n<p>关于登录拦截看似简单，实则使用时候竟然会碰到这么多问题！相信第一次使用时都会被虐的掉眼泪。</p>\n<h2 id=\"2-处理一个Activity对应多个路径的情况\"><a href=\"#2-处理一个Activity对应多个路径的情况\" class=\"headerlink\" title=\"2.处理一个Activity对应多个路径的情况\"></a>2.处理一个Activity对应多个路径的情况</h2><p>在某些情况可能出现一个页面对应多个路径的情况。出现这种情况的原因可能是前期路由没有规划好，导致后边版本的路由路径做了修改。从而出现了一个Activity对应多个页面的情况。为了兼容旧版路由，我们不得不处理这种情况。但是，Route的注解中path是唯一的，并不能通过@Route注解解决一个Activity对应多个路径的情况。此时就需要用到ARouter的重写URL的功能。只需要实现PathReplaceService 接口，在重写的方法中对URI或者Path进行替换即可，注意，这个类一定要加@Route注解。代码参考如下：</p>\n<pre><code class=\"hljs reasonml\">@<span class=\"hljs-constructor\">Route(<span class=\"hljs-params\">path</span> = <span class=\"hljs-string\">&quot;/lost/service&quot;</span>)</span>\npublic <span class=\"hljs-keyword\">class</span> ARouterLostReplaceService implements PathReplaceService &#123;\n    @Override\n    public String <span class=\"hljs-keyword\">for</span><span class=\"hljs-constructor\">String(String <span class=\"hljs-params\">path</span>)</span> &#123;\t<span class=\"hljs-comment\">//\t对于path处理与uri类似</span>\n        return path;\n    &#125;\n\n    @Override\n    public Uri <span class=\"hljs-keyword\">for</span><span class=\"hljs-constructor\">Uri(Uri <span class=\"hljs-params\">uri</span>)</span> &#123;\t\n        String path = uri.get<span class=\"hljs-constructor\">Path()</span>;\n        <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">PATH_LOST1</span>.</span></span>equals(path)) &#123;\n            uri = replace<span class=\"hljs-constructor\">UriPath(<span class=\"hljs-params\">uri</span>, PATH_REAL1)</span>;\n        &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">PATH_LOST2</span>.</span></span>equals(path)) &#123;\n            uri = replace<span class=\"hljs-constructor\">UriPath(<span class=\"hljs-params\">uri</span>, PATH_REAL2)</span>;\n        &#125;\n        return uri;\n    &#125;\n\n    @Override\n    public void init(Context context) &#123;\n\n    &#125;\n\n    <span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">     * 替换URI中的path</span>\n<span class=\"hljs-comment\">     * </span>\n<span class=\"hljs-comment\">     * @param uri 被替换的uri</span>\n<span class=\"hljs-comment\">     * @param path 要替换的path</span>\n<span class=\"hljs-comment\">     * @return 替换后的uri</span>\n<span class=\"hljs-comment\">     */</span>\n    <span class=\"hljs-keyword\">private</span> Uri replace<span class=\"hljs-constructor\">UriPath(Uri <span class=\"hljs-params\">uri</span>, String <span class=\"hljs-params\">path</span>)</span> &#123;\n        StringBuilder resultUrl = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-constructor\">StringBuilder(<span class=\"hljs-params\">uri</span>.<span class=\"hljs-params\">getScheme</span>()</span> + <span class=\"hljs-string\">&quot;://&quot;</span> + uri.get<span class=\"hljs-constructor\">Host()</span> + path);\n        String<span class=\"hljs-literal\">[]</span> split = uri.<span class=\"hljs-keyword\">to</span><span class=\"hljs-constructor\">String()</span>.split(<span class=\"hljs-string\">&quot;\\\\?&quot;</span>);\n        <span class=\"hljs-keyword\">if</span>(split.length &gt;= <span class=\"hljs-number\">2</span>) &#123;\n            resultUrl.append(<span class=\"hljs-string\">&quot;?&quot;</span>).append(split<span class=\"hljs-literal\">[<span class=\"hljs-number\">1</span>]</span>);\n        &#125;\n        return <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">Uri</span>.</span></span>parse(resultUrl.<span class=\"hljs-keyword\">to</span><span class=\"hljs-constructor\">String()</span>);\n    &#125;\n&#125;</code></pre>\n\n<h2 id=\"3-ARouter全局降级策略\"><a href=\"#3-ARouter全局降级策略\" class=\"headerlink\" title=\"3.ARouter全局降级策略\"></a>3.ARouter全局降级策略</h2><p>在路由跳转时可能会出现找不到Path对应页面的情况，对于这种情况可以通过实现DegradeService 接口来处理，同样这个类也必须要添加@Route注解。这样当路由跳转时找不到路径就会走到这个类的onLost方法中，此时就可以在这个方法中来做相应的处理了。</p>\n<pre><code class=\"hljs less\"><span class=\"hljs-comment\">// 实现DegradeService接口，并加上一个Path内容任意的注解即可</span>\n<span class=\"hljs-variable\">@Route</span>(path = <span class=\"hljs-string\">&quot;/lost/path&quot;</span>)\npublic class DegradeServiceImpl implements DegradeService &#123;\n\t<span class=\"hljs-variable\">@Override</span>\n\tpublic void onLost(Context context, Postcard postcard) &#123;\n\t    <span class=\"hljs-comment\">//  可以在此处统一处理，比如跳转到首页</span>\n\t&#125;\n\n\t<span class=\"hljs-variable\">@Override</span>\n\tpublic void init(Context context) &#123;\n\n\t&#125;\n&#125;</code></pre>\n\n<h1 id=\"四、通过浏览器跳转到App对应页面\"><a href=\"#四、通过浏览器跳转到App对应页面\" class=\"headerlink\" title=\"四、通过浏览器跳转到App对应页面\"></a>四、通过浏览器跳转到App对应页面</h1><h2 id=\"1-Schema协议\"><a href=\"#1-Schema协议\" class=\"headerlink\" title=\"1.Schema协议\"></a>1.Schema协议</h2><p>很多人对于Schema协议比较陌生，但是如果说URL大家一定都非常熟悉。其实URL就是一种Schema协议。Schema协议通常由四部分组成：</p>\n<pre><code class=\"hljs inform7\"><span class=\"hljs-comment\">[scheme]</span>://<span class=\"hljs-comment\">[host]</span>/<span class=\"hljs-comment\">[path]</span>?<span class=\"hljs-comment\">[query]</span>\nscheme：表示协议名称\nhost：Schema所作用的地址域\npath：Schema指定的路径\nquery：携带的参数</code></pre>\n<p>拿百度搜索的URL来举例子：<a href=\"https://www.baidu.com/s?wd=%E8%A6%81%E6%90%9C%E7%B4%A2%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97%E3%80%82%E8%BF%99%E4%B8%AAURL%E4%B8%8ESchema%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB%E5%A6%82%E4%B8%8B\">https://www.baidu.com/s?wd=要搜索的关键字。这个URL与Schema协议的对应关系如下</a></p>\n<blockquote>\n<p>schema:：https<br>host： <a href=\"http://www.baidu.com/\">www.baidu.com</a><br>path： /s<br>query：wd=要搜索的关键字</p>\n</blockquote>\n<p>了解了Schema协议后，其实我们完全可以按照Schema协议的格式来自定义一个Schema链接，如下：</p>\n<blockquote>\n<p>myApp://<a href=\"http://www.myapp.com/main/home?id=1\">www.myApp.com/main/home?id=1</a></p>\n<p>我们自己定义的Schema链接的对应关系为：<br> schema:：myApp<br>host：<a href=\"http://www.myapp.com/\">www.myApp.com</a><br>path：/main/home<br>query：id=1</p>\n</blockquote>\n<h2 id=\"2-通过Schema链接打开Activity\"><a href=\"#2-通过Schema链接打开Activity\" class=\"headerlink\" title=\"2.通过Schema链接打开Activity\"></a>2.通过Schema链接打开Activity</h2><p>通过浏览器打开App其实就是通过Schema链接来实现的。我们就以上一节中自定义的Schema链接为例来实现浏览器打开App。首先在项目中添加一个RouterActivity，RouterActivity在AndroidManifest中的配置如下：</p>\n<pre><code class=\"hljs xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">activity</span></span>\n<span class=\"hljs-tag\">      <span class=\"hljs-attr\">android:name</span>=<span class=\"hljs-string\">&quot;.activity.RouterActivity&quot;</span></span>\n<span class=\"hljs-tag\">      <span class=\"hljs-attr\">android:configChanges</span>=<span class=\"hljs-string\">&quot;orientation|keyboardHidden|screenSize&quot;</span></span>\n<span class=\"hljs-tag\">      <span class=\"hljs-attr\">android:screenOrientation</span>=<span class=\"hljs-string\">&quot;portrait&quot;</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">intent-filter</span>&gt;</span>\n          <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">action</span> <span class=\"hljs-attr\">android:name</span>=<span class=\"hljs-string\">&quot;android.intent.action.VIEW&quot;</span> /&gt;</span>\n          <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">category</span> <span class=\"hljs-attr\">android:name</span>=<span class=\"hljs-string\">&quot;android.intent.category.DEFAULT&quot;</span> /&gt;</span>\n           <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">category</span> <span class=\"hljs-attr\">android:name</span>=<span class=\"hljs-string\">&quot;android.intent.category.BROWSABLE&quot;</span> /&gt;</span>\n           <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">data</span> <span class=\"hljs-attr\">android:scheme</span>=<span class=\"hljs-string\">&quot;myApp&quot;</span> /&gt;</span>\n      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">intent-filter</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">activity</span>&gt;</span></code></pre>\n<p>我们在AndroidManifest中为RouterActivity添加了schema，此时在HTML中写入以下代码：</p>\n<pre><code class=\"hljs xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">&quot;myApp://www.myApp.com/main/home?id=1&quot;</span>&gt;</span>打开APP<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span></code></pre>\n<p>通过点击HTML页面的”打开App”便可启动RouterActivity。并且RouterActivity启动后可以通过Intent获取到启动的URI。代码如下：</p>\n<pre><code class=\"hljs reasonml\">  #RouterActivity\n \n@Override\n   protected void on<span class=\"hljs-constructor\">Create(Bundle <span class=\"hljs-params\">data</span>)</span> &#123;\n       super.on<span class=\"hljs-constructor\">Create(<span class=\"hljs-params\">data</span>)</span>;\n       Uri launchUri = get<span class=\"hljs-constructor\">Intent()</span>.get<span class=\"hljs-constructor\">Data()</span>;\n       dispatch<span class=\"hljs-constructor\">RouterUri(<span class=\"hljs-params\">launchUri</span>)</span>;\n   &#125;</code></pre>\n<p>至此，我们已经可以通过App来打开项目的RouterActivity。</p>\n<h2 id=\"3-通过路由跳转到目的页面\"><a href=\"#3-通过路由跳转到目的页面\" class=\"headerlink\" title=\"3.通过路由跳转到目的页面\"></a>3.通过路由跳转到目的页面</h2><p>上一节中我们通过HTML打开了RouterActivity，并在RouterActivity中拿到了跳转的URI，那么接下来我们便可以根据URI的信息打开对应的页面了。但是在开启路由跳转之前为了保险起见需要对URI进行一些校验。详细代码如下：</p>\n<pre><code class=\"hljs reasonml\"><span class=\"hljs-keyword\">private</span> void dispatch<span class=\"hljs-constructor\">RouterUri(Uri <span class=\"hljs-params\">launchUri</span>)</span> &#123;\n        <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">RoutingTable</span>.</span></span>is<span class=\"hljs-constructor\">ValidRouterUri(<span class=\"hljs-params\">launchUri</span>)</span>) &#123;  <span class=\"hljs-comment\">//\t判断是否是合法的URI，这里只有URI携带了Path才算合法</span>\n            <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">App</span>.</span></span>is<span class=\"hljs-constructor\">RootActivityLaunched()</span>) &#123; <span class=\"hljs-comment\">// app已启动</span>\n                <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">RoutingTable</span>.</span></span>is<span class=\"hljs-constructor\">WxUri(<span class=\"hljs-params\">launchUri</span>)</span>) &#123; <span class=\"hljs-comment\">//\t如果是微信的URI那么目的地是要跳转到小程序的（此处为项目中的需求）</span>\n                    <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">RoutingTable</span>.</span></span><span class=\"hljs-keyword\">open</span><span class=\"hljs-constructor\">MiniProgram(<span class=\"hljs-params\">this</span>, <span class=\"hljs-params\">launchUri</span>)</span>;\n                    finish<span class=\"hljs-literal\">()</span>;\n                    return;\n                &#125;\n                <span class=\"hljs-comment\">//\t通过ARouter路由到目的页面</span>\n               <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">ARouter</span>.</span></span>get<span class=\"hljs-constructor\">Instance()</span>.build(launchUri).navigation<span class=\"hljs-literal\">()</span>;\n            &#125; <span class=\"hljs-keyword\">else</span> &#123;  <span class=\"hljs-comment\">// app未启动, 保存router uri, 幷尝试启动app</span>\n               <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">SharedPreferUtil</span>.</span></span>put(Constants.ROUTER_URI, launchUri.<span class=\"hljs-keyword\">to</span><span class=\"hljs-constructor\">String()</span>);\n               launch<span class=\"hljs-constructor\">App()</span>;\n            &#125;\n        &#125; <span class=\"hljs-keyword\">else</span> &#123;  <span class=\"hljs-comment\">//\t 走到此处可能是因为URI没有携带Path，即并非要跳转目的页面，而是要启动APP  。因此直接启动App即可</span>\n            launch<span class=\"hljs-constructor\">App()</span>;\n        &#125;\n        finish<span class=\"hljs-literal\">()</span>;\n    &#125;</code></pre>\n<p>上面代码中，我们对URI做了一系列校验，根据不同的URI做不同的处理。同时我们应该也注意到了，如果APP已经启动了，那么就可以直接跳转对应的页面了，而如果App没有启动，那么则是先将URI保存到了SharedPreference中，接着启动了App。那么此时App启动后会在MainActivity中读取SharedPreference中的配置，如果读取到URI的信息，那么就先将此数据从SharedPreference中移除，然后通过ARouter跳转到URI指定的页面去。MainActivity中的部分代码如下：</p>\n<pre><code class=\"hljs csharp\"><span class=\"hljs-meta\">#MainActivity</span>\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">resumeRoute</span>(<span class=\"hljs-params\"></span>)</span> &#123;\n        <span class=\"hljs-comment\">// Continue for interrupted router uri</span>\n        String interruptedLaunchUriString =\n                Configuration.<span class=\"hljs-keyword\">get</span>(Constants.INTERRUPTED_ROUTER_URI, <span class=\"hljs-literal\">null</span>);\n         <span class=\"hljs-comment\">//\t移除SharedPreference中的URI，避免下次打开MainActivity错误跳转</span>\n        SharedPreferUtil.<span class=\"hljs-keyword\">remove</span>(Constants.ROUTER_URI);\n        Uri launchUri = <span class=\"hljs-literal\">null</span>;\n        <span class=\"hljs-keyword\">if</span>(interruptedLaunchUriString != <span class=\"hljs-literal\">null</span>) &#123; <span class=\"hljs-comment\">// Activity未启动的情况下 通过外部Scheme跳转非MainActivity</span>\n            launchUri = Uri.parse(interruptedLaunchUriString);\n        &#125;\n\n        <span class=\"hljs-keyword\">if</span>(launchUri == <span class=\"hljs-literal\">null</span>) &#123;\n            <span class=\"hljs-keyword\">return</span>;\n        &#125;\n\t\t<span class=\"hljs-comment\">//\t通过路由跳转到URI对应的页面</span>\n        ARouter.getInstance().build(launchUri).navigation();\n    &#125;</code></pre>\n<p>关于ARouter的路由方案所涉及的内容至此已经全部讲完了。</p>\n","site":{"data":{"fluid_config":{"favicon":"/img/favicon.png","apple_touch_icon":"/img/favicon.png","title_join_string":" - ","force_https":false,"highlight":{"enable":true,"style":"Github Gist","bg_color":false,"copy_btn":true},"fun_features":{"typing":{"enable":true,"typeSpeed":70,"cursorChar":"|","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"mouse_click":{"enable":false,"style":"values"}},"dark_mode":{"enable":true,"default":"auto"},"color":{"body_bg_color":"#eee","body_bg_color_dark":"#181c27","navbar_bg_color":"#2f4154","navbar_bg_color_dark":"#1f3144","navbar_text_color":"#fff","navbar_text_color_dark":"#d0d0d0","text_color":"#3c4858","text_color_dark":"#c4c6c9","sec_text_color":"#718096","sec_text_color_dark":"#a7a9ad","post_text_color":"#2c3e50","post_text_color_dark":"#c4c6c9","post_heading_color":"#1a202c","post_heading_color_dark":"#c4c6c9","post_link_color":"#0366d6","post_link_color_dark":"#1589e9","link_hover_color":"#30a9de","link_hover_color_dark":"#30a9de","link_hover_bg_color":"#f8f9fa","link_hover_bg_color_dark":"#364151","board_color":"#fff","board_color_dark":"#252d38"},"font":{"font_size":"16px","font_family":null,"code_font_size":"85%"},"custom_js":null,"custom_css":null,"custom_html":"","web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"tajs":null,"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}},"lazyload":{"enable":true,"onlypost":false},"daovoice":{"enable":false,"appid":""},"aplayer":{"enable":false,"autoplay":false,"loop":"all","order":"random","theme":"#b7daff","songs":[{"name":"name","artist":"artist","url":"/songs/test.mp3","cover":"/img/cover.jpg"},{"name":"name","artist":"artist","url":"https://...url.mp3","cover":"https://...cover.jpg"}]},"version":{"check":false},"navbar":{"blog_title":"zhangpan","ground_glass":{"enable":false,"px":3,"alpha":0.7},"menu":[{"key":"home","link":"/","icon":"iconfont icon-home-fill"},{"key":"archive","link":"/archives/","icon":"iconfont icon-archive-fill"},{"key":"category","link":"/categories/","icon":"iconfont icon-category-fill"},{"key":"tag","link":"/tags/","icon":"iconfont icon-tags-fill"},{"key":"about","link":"/about/","icon":"iconfont icon-user-fill"}]},"search":{"enable":true,"path":"/local-search.xml","generate_path":"/local-search.xml","field":"post","content":true},"scroll_down_arrow":{"enable":true,"banner_height_limit":90,"scroll_after_turning_page":true},"banner_parallax":true,"footer":{"statistics":{"enable":false,"source":"busuanzi","pv_format":"总访问量 {} 次","uv_format":"总访客数 {} 人"},"beian":{"enable":false,"icp_text":"京ICP证123456号","police_text":"京公网安备12345678号","police_code":12345678,"police_icon":"/img/police_beian.png"}},"scroll_top_arrow":{"enable":true},"index":{"banner_img":"/img/default.png","banner_img_height":100,"banner_mask_alpha":0.3,"post_default_img":"","slogan":{"enable":true,"text":"Talk is cheap, show me the code."},"auto_excerpt":{"enable":true},"post_url_target":"_self","post_meta":{"date":true,"category":true,"tag":true}},"page":{"banner_img":"/img/default.png","banner_img_height":60,"banner_mask_alpha":0.3},"post":{"banner_img":"/img/default.png","banner_img_height":70,"banner_mask_alpha":0.3,"meta":{"date":{"enable":true,"format":"LL a"},"wordcount":{"enable":true,"format":"{} 字"},"min2read":{"enable":true,"format":"{} 分钟","words":100},"views":{"enable":false,"source":"busuanzi","format":"{} 次"}},"updated":{"enable":false,"content":"本文最后更新于：","relative":false},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"copyright":{"enable":true,"content":"本博客所有文章除特别声明外，均采用 <a href=\"https://creativecommons.org/licenses/by-sa/4.0/deed.zh\" rel=\"nofollow noopener\">CC BY-SA 4.0 协议</a> ，转载请注明出处！ <h5>开源库推荐</h5> <a href=\"https://github.com/zhpanvip/BannerViewPager\">1.BannerViewPager</a> <p> 一个基于ViewPager2实现的具有强大功能的无限轮播库。支持多种页面切换效果和指示器样式。 </p>\n<a href=\"https://github.com/zhpanvip/viewpagerindicator\">2.ViewPagerIndicator</a> <p> 一个适用于ViewPager和ViewPager2的指示器，支持多种滑块样式及滑动模式 </p>"},"prev_next":{"enable":true},"custom":{"enable":false,"content":"<img src=\"https://octodex.github.com/images/jetpacktocat.png\" class=\"rounded mx-auto d-block mt-5\" style=\"width:150px; height:150px;\">"},"image_zoom":{"enable":true},"footnote":{"enable":true,"header":""},"math":{"enable":false,"specific":false,"engine":"mathjax"},"mermaid":{"enable":false,"specific":false,"options":{"theme":"default"}},"comments":{"enable":true,"type":"utterances"}},"utterances":{"repo":"zhpanvip/utterances-comment","issue_term":"pathname","label":"utterances","theme":"github-light","crossorigin":"anonymous"},"disqus":{"shortname":null,"disqusjs":false,"apikey":null},"gitalk":{"clientID":null,"clientSecret":null,"repo":null,"owner":null,"admin":["name"],"id":"location.pathname","language":"zh-CN","labels":["Gitalk"],"perPage":10,"pagerDirection":"last","distractionFreeMode":false,"createIssueManually":true},"valine":{"appid":"hXIROaIM5y9qnieojJRWP5hS","appkey":"y0f3w3aqd1MF7JL9ma4WECTy","placeholder":"说点什么","path":"window.location.pathname","avatar":"retro","meta":["nick","mail","link"],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"https://zhangpan.site"},"changyan":{"appid":"","appkey":""},"livere":{"uid":""},"archive":{"banner_img":"/img/bg_article.jpg","banner_img_height":60,"banner_mask_alpha":0.3,"subtitle":null},"category":{"banner_img":"/img/bg_default.png","banner_img_height":60,"banner_mask_alpha":0.3,"subtitle":null,"post_limit":10,"order_by":"-length"},"tag":{"banner_img":"/img/bg_label.jpg","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null,"tagcloud":{"min_font":15,"max_font":30,"unit":"px","start_color":"#BBBBEE","end_color":"#337ab7"}},"about":{"banner_img":"/img/bg_default.png","banner_img_height":60,"banner_mask_alpha":0.3,"subtitle":null,"avatar":"/img/avatar.png","name":"myname","introduce":"一句简短的介绍","icons":[{"class":"iconfont icon-github-fill","link":"https://github.com","tip":"GitHub"},{"class":"iconfont icon-douban-fill","link":"https://douban.com","tip":"豆瓣"},{"class":"iconfont icon-wechat-fill","qrcode":"/img/favicon.png"}]},"page404":{"banner_img":"/img/default.png","banner_img_height":85,"banner_mask_alpha":0.3,"subtitle":"Page not found"},"links":{"banner_img":"/img/default.png","banner_img_height":60,"banner_mask_alpha":0.3,"subtitle":null,"items":[{"title":"Fluid Docs","intro":"主题使用指南","link":"https://hexo.fluid-dev.com/docs/","image":"/img/favicon.png"},{"title":"Fluid Repo","intro":"主题 GitHub 仓库","link":"https://github.com/fluid-dev/hexo-theme-fluid","image":"/img/favicon.png"},{"title":"Fluid Example","intro":"主题操作示例","link":"https://hexo.fluid-dev.com/docs/example/","image":"/img/favicon.png"}]}}}},"excerpt":"","more":"<p>这本是一篇应该写在去年的文章，但仅仅因为…懒，这篇文章在草稿箱里静静的躺了一年多，被无限期推迟到了现在。最近刚好完成了公司项目的路由改造，借此机会来对这篇文章做一个了结。<br><img src=\"https://img-blog.csdnimg.cn/20190918012522155.png\" alt=\"在这里插入图片描述\"></p>\n<h1 id=\"一、为什么要在项目中引入路由？\"><a href=\"#一、为什么要在项目中引入路由？\" class=\"headerlink\" title=\"一、为什么要在项目中引入路由？\"></a>一、为什么要在项目中引入路由？</h1><p>在开始之前我们先来思考一下这个问题。为什么要在项目中引入路由？相信大家的答案可能会有所不同，但是应该也不外乎以下几点：</p>\n<h2 id=\"1-为了实现项目组件化\"><a href=\"#1-为了实现项目组件化\" class=\"headerlink\" title=\"1.为了实现项目组件化\"></a>1.为了实现项目组件化</h2><p>想必很多开发者引入路由的目的都是因为要实现项目组件化。我们知道，组件化的项目各个业务模块之间没有相互的依赖关系。不同业务模块之间的通信最好的解决方案就是支持页面路由。</p>\n<h2 id=\"2-方便APP内部跳转\"><a href=\"#2-方便APP内部跳转\" class=\"headerlink\" title=\"2.方便APP内部跳转\"></a>2.方便APP内部跳转</h2><p>可能有些小伙伴会有疑问，App内部直接通过Intent跳转不是很好吗，为什么要多此一举引入路由呢？当然，通常情况下通过Intent跳转也无伤大雅。但是在某些情况下，比如像下图这样的一个页面：<br><img src=\"https://img-blog.csdnimg.cn/2019091700111637.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwNTIxNTcz,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>这是一个典型的多Type的RecyclerView页面，这个页面中所有的数据都是从服务器获取的，在引入路由之前所有的点击跳转事件都需要后台给我们一个type,我们根据type判断需要向哪一个Activity跳转，并且需要通过Intent携带目的页面所需要的参数。显然这样写会使我们代码变得非常臃肿，代码之间的耦合度也非常高。然而在引入路由之后一切都变得不一样了。我们只需要后台返回目的页面所对应的URL，并在URL上拼接页面跳转所需要的参数，此时前台只需要拿到URL，然后通过路由即可到达对应的页面。这样以来使我们的代码变得简洁明了，并且保证了代码的低耦合。</p>\n<h2 id=\"3-方便APP外部跳转\"><a href=\"#3-方便APP外部跳转\" class=\"headerlink\" title=\"3.方便APP外部跳转\"></a>3.方便APP外部跳转</h2><p>通常可以看到很多应用支持从浏览器唤醒App并跳转到对应的页面。做到比较好的如知乎，体验过知乎的小伙伴应该知道，知乎可以从浏览器唤醒App并且直接在App中打开当前在浏览器中浏览的内容。我们知道，从外部唤起App需要给Activity添加Schema。而如果App内部有许多Activity需要支持外部唤起，我们不可能为这些Activity都添加Schema。那么此时我们就可以单独设置一个支持Schema的Activity，浏览器可以通过Schema唤起这个Activity。而在这个Activity中会接收浏览器传过来的URL，然后根据URL进行路由分发，通过URL路由到对应的页面即可。</p>\n<h1 id=\"二-、ARouter的使用\"><a href=\"#二-、ARouter的使用\" class=\"headerlink\" title=\"二 、ARouter的使用\"></a>二 、ARouter的使用</h1><p>其实很不想在这篇文章中长篇大论如何使用<a href=\"https://github.com/alibaba/ARouter\">ARouter</a>，因为<a href=\"https://github.com/alibaba/ARouter/blob/master/README_CN.md\">ARouter的官方文档</a>上已经非常详细的告诉了开发者如何去使用，只要仔细的阅读ARouter的文档基本上绝大部分问题都可以得到解决。但是为了照顾没有使用过ARouter的小伙伴，这里还是再啰嗦一下。如果你对ARouter的使用已经非常熟悉了那么你可以忽略此章节，直接到下一章了。</p>\n<h2 id=\"1-添加依赖和配置\"><a href=\"#1-添加依赖和配置\" class=\"headerlink\" title=\"1.添加依赖和配置\"></a>1.添加依赖和配置</h2><pre><code class=\"hljs properties\"><span class=\"hljs-attr\">android</span> <span class=\"hljs-string\">&#123;</span>\n    <span class=\"hljs-attr\">defaultConfig</span> <span class=\"hljs-string\">&#123;</span>\n        <span class=\"hljs-attr\">...</span>\n        <span class=\"hljs-attr\">javaCompileOptions</span> <span class=\"hljs-string\">&#123;</span>\n            <span class=\"hljs-attr\">annotationProcessorOptions</span> <span class=\"hljs-string\">&#123;</span>\n                <span class=\"hljs-attr\">arguments</span> = <span class=\"hljs-string\">[AROUTER_MODULE_NAME: project.getName()]</span>\n            <span class=\"hljs-attr\">&#125;</span>\n        <span class=\"hljs-attr\">&#125;</span>\n    <span class=\"hljs-attr\">&#125;</span>\n<span class=\"hljs-attr\">&#125;</span>\n\n<span class=\"hljs-attr\">dependencies</span> <span class=\"hljs-string\">&#123;</span>\n    <span class=\"hljs-meta\">//</span> <span class=\"hljs-string\">替换成最新版本, 需要注意的是api</span>\n    <span class=\"hljs-meta\">//</span> <span class=\"hljs-string\">要与compiler匹配使用，均使用最新版可以保证兼容</span>\n    <span class=\"hljs-attr\">implementation</span> <span class=\"hljs-string\">&#x27;com.alibaba:arouter-api:x.x.x&#x27;</span>\n    <span class=\"hljs-attr\">annotationProcessor</span> <span class=\"hljs-string\">&#x27;com.alibaba:arouter-compiler:x.x.x&#x27;</span>\n    <span class=\"hljs-attr\">...</span>\n<span class=\"hljs-attr\">&#125;</span></code></pre>\n<p>这里需要注意，如果你的项目有多个业务模块，那么每个模块都需要在gradle中添加以上配置。</p>\n<h2 id=\"2-初始化SDK\"><a href=\"#2-初始化SDK\" class=\"headerlink\" title=\"2.初始化SDK\"></a>2.初始化SDK</h2><pre><code class=\"hljs reasonml\"><span class=\"hljs-keyword\">if</span> (is<span class=\"hljs-constructor\">Debug()</span>) &#123;           <span class=\"hljs-comment\">// 这两行必须写在init之前，否则这些配置在init过程中将无效</span>\n    <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">ARouter</span>.</span></span><span class=\"hljs-keyword\">open</span><span class=\"hljs-constructor\">Log()</span>;     <span class=\"hljs-comment\">// 打印日志</span>\n    <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">ARouter</span>.</span></span><span class=\"hljs-keyword\">open</span><span class=\"hljs-constructor\">Debug()</span>;   <span class=\"hljs-comment\">// 开启调试模式(如果在InstantRun模式下运行，必须开启调试模式！线上版本需要关闭,否则有安全风险)</span>\n&#125;\n<span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">ARouter</span>.</span></span>init(mApplication); <span class=\"hljs-comment\">// 尽可能早，推荐在Application中初始化</span></code></pre>\n\n<h2 id=\"3-添加注解\"><a href=\"#3-添加注解\" class=\"headerlink\" title=\"3.添加注解\"></a>3.添加注解</h2><pre><code class=\"hljs angelscript\"><span class=\"hljs-comment\">// 在支持路由的页面上添加注解(必选)</span>\n<span class=\"hljs-comment\">// 这里的路径需要注意的是至少需要有两级，/xx/xx</span>\n@Route(path = <span class=\"hljs-string\">&quot;/test/activity&quot;</span>)\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-symbol\">YourActivity</span> <span class=\"hljs-symbol\">extend</span> <span class=\"hljs-symbol\">Activity</span> &#123;\n    ...\n&#125;</code></pre>\n\n<h2 id=\"4-发起路由操作\"><a href=\"#4-发起路由操作\" class=\"headerlink\" title=\"4.发起路由操作\"></a>4.发起路由操作</h2><pre><code class=\"hljs reasonml\"><span class=\"hljs-comment\">// 1. 应用内简单的跳转(通过URL跳转在&#x27;进阶用法&#x27;中)</span>\n<span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">ARouter</span>.</span></span>get<span class=\"hljs-constructor\">Instance()</span>.build(<span class=\"hljs-string\">&quot;/test/activity&quot;</span>).navigation<span class=\"hljs-literal\">()</span>;\n\n<span class=\"hljs-comment\">// 2. 跳转并携带参数</span>\n<span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">ARouter</span>.</span></span>get<span class=\"hljs-constructor\">Instance()</span>.build(<span class=\"hljs-string\">&quot;/test/1&quot;</span>)\n            .<span class=\"hljs-keyword\">with</span><span class=\"hljs-constructor\">Long(<span class=\"hljs-string\">&quot;key1&quot;</span>, 666L)</span>\n            .<span class=\"hljs-keyword\">with</span><span class=\"hljs-constructor\">String(<span class=\"hljs-string\">&quot;key3&quot;</span>, <span class=\"hljs-string\">&quot;888&quot;</span>)</span>\n            .<span class=\"hljs-keyword\">with</span><span class=\"hljs-constructor\">Object(<span class=\"hljs-string\">&quot;key4&quot;</span>, <span class=\"hljs-params\">new</span> Test(<span class=\"hljs-string\">&quot;Jack&quot;</span>, <span class=\"hljs-string\">&quot;Rose&quot;</span>)</span>)\n            .navigation<span class=\"hljs-literal\">()</span>;</code></pre>\n<p>很多情况下需要通过URL跳转，ARouter支持直接通过URL跳转：</p>\n<pre><code class=\"hljs reasonml\">Uri uri= <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">Uri</span>.</span></span>parse(url);\n<span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">ARouter</span>.</span></span>get<span class=\"hljs-constructor\">Instance()</span>.build(uri).navigation<span class=\"hljs-literal\">()</span>;</code></pre>\n\n<h2 id=\"5-路由解析参数\"><a href=\"#5-路由解析参数\" class=\"headerlink\" title=\"5.路由解析参数\"></a>5.路由解析参数</h2><pre><code class=\"hljs aspectj\"><span class=\"hljs-comment\">// 为每一个参数声明一个字段，并使用 @Autowired 标注</span>\n<span class=\"hljs-comment\">// URL中不能传递Parcelable类型数据，通过ARouter api可以传递Parcelable对象</span>\n<span class=\"hljs-meta\">@Route</span>(path = <span class=\"hljs-string\">&quot;/test/activity&quot;</span>)\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Test1Activity</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Activity</span> </span>&#123;\n    <span class=\"hljs-meta\">@Autowired</span>\n    <span class=\"hljs-keyword\">public</span> String name;\n    <span class=\"hljs-meta\">@Autowired</span>\n    <span class=\"hljs-keyword\">int</span> age;\n    \n    <span class=\"hljs-comment\">// 通过name来映射URL中的不同参数</span>\n    <span class=\"hljs-meta\">@Autowired</span>(name = <span class=\"hljs-string\">&quot;girl&quot;</span>) \n    <span class=\"hljs-keyword\">boolean</span> boy;\n    \n    <span class=\"hljs-comment\">// 支持解析自定义对象，URL中使用json传递</span>\n    <span class=\"hljs-meta\">@Autowired</span>\n    TestObj obj;      \n    \n    <span class=\"hljs-comment\">// 使用 withObject 传递 List 和 Map 的实现了</span>\n    <span class=\"hljs-comment\">// Serializable 接口的实现类(ArrayList/HashMap)</span>\n    <span class=\"hljs-comment\">// 的时候，接收该对象的地方不能标注具体的实现类类型</span>\n    <span class=\"hljs-comment\">// 应仅标注为 List 或 Map，否则会影响序列化中类型</span>\n    <span class=\"hljs-comment\">// 的判断, 其他类似情况需要同样处理        </span>\n    <span class=\"hljs-meta\">@Autowired</span>\n    List&lt;TestObj&gt; list;\n    <span class=\"hljs-meta\">@Autowired</span>\n    Map&lt;String, List&lt;TestObj&gt;&gt; map;\n    \n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-keyword\">protected</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onCreate</span><span class=\"hljs-params\">(Bundle savedInstanceState)</span> </span>&#123;\n    <span class=\"hljs-keyword\">super</span>.onCreate(savedInstanceState);\n    ARouter.getInstance().inject(<span class=\"hljs-keyword\">this</span>);\n\n    <span class=\"hljs-comment\">// ARouter会自动对字段进行赋值，无需主动获取</span>\n    Log.d(<span class=\"hljs-string\">&quot;param&quot;</span>, name + age + boy);\n    &#125;\n&#125;\n\n\n<span class=\"hljs-comment\">// 如果需要传递自定义对象，新建一个类（并非自定义对象类），然后实现 SerializationService,并使用@Route注解标注(方便用户自行选择序列化方式)，例如：</span>\n<span class=\"hljs-meta\">@Route</span>(path = <span class=\"hljs-string\">&quot;/yourservicegroupname/json&quot;</span>)\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">JsonServiceImpl</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">SerializationService</span> </span>&#123;\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">init</span><span class=\"hljs-params\">(Context context)</span> </span>&#123;\n\n    &#125;\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-keyword\">public</span> &lt;T&gt; <span class=\"hljs-function\">T <span class=\"hljs-title\">json2Object</span><span class=\"hljs-params\">(String text, Class&lt;T&gt; clazz)</span> </span>&#123;\n        <span class=\"hljs-function\"><span class=\"hljs-keyword\">return</span> JSON.<span class=\"hljs-title\">parseObject</span><span class=\"hljs-params\">(text, clazz)</span></span>;\n    &#125;\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-function\">String <span class=\"hljs-title\">object2Json</span><span class=\"hljs-params\">(Object instance)</span> </span>&#123;\n        <span class=\"hljs-function\"><span class=\"hljs-keyword\">return</span> JSON.<span class=\"hljs-title\">toJSONString</span><span class=\"hljs-params\">(instance)</span></span>;\n    &#125;\n&#125;</code></pre>\n<p>除了使用@Autowired注解注入参数外，还可以与普通页面跳转一样通过getIntent()获取参数。</p>\n<p>以上就是ARouter的一些基本用法，了解这些基本用法之后并不等于已经掌握了ARouter。因为当你实际用到项目中的时候可能会面临诸多问题。</p>\n<h1 id=\"三-、ARouter的采坑之路\"><a href=\"#三-、ARouter的采坑之路\" class=\"headerlink\" title=\"三 、ARouter的采坑之路\"></a>三 、ARouter的采坑之路</h1><p>如果你只是简单的写一个ARouter使用的Demo，那么可能上一章的内容已经足够了。但是当你在项目中引入ARouter后各种各样的问题便会接踵而至。</p>\n<h2 id=\"1-使用ARouter实现登录拦截\"><a href=\"#1-使用ARouter实现登录拦截\" class=\"headerlink\" title=\"1.使用ARouter实现登录拦截\"></a>1.使用ARouter实现登录拦截</h2><p>这是在项目中引入ARouter后面临的第一个问题。通常情况下，大部分App不登录便可以进入主页面，在跳转需要用户权限的页面时会首先跳转到登录页面引导用户登录。我相信大部分的开发在最初时候都写过类似这样的代码：</p>\n<pre><code class=\"hljs isbl\"><span class=\"hljs-variable\"><span class=\"hljs-keyword\">if</span></span> (<span class=\"hljs-variable\">isLogin</span>) &#123;\n    <span class=\"hljs-function\"><span class=\"hljs-title\">goToDestination</span>();</span>\n<span class=\"hljs-function\"> &#125; <span class=\"hljs-variable\"><span class=\"hljs-keyword\">else</span></span> &#123;</span>\n<span class=\"hljs-function\">    <span class=\"hljs-title\">goToLogin</span>();</span>\n<span class=\"hljs-function\"> &#125;</span></code></pre>\n<p>在每次跳转页面的时候都需要进行是否登录的判断，这样的代码显然有很大的弊端。而ARouter为我们提供了面向切面的登录拦截功能，ARouter的文档上给了我们一个例子：</p>\n<pre><code class=\"hljs less\"><span class=\"hljs-comment\">// 比较经典的应用就是在跳转过程中处理登陆事件，这样就不需要在目标页重复做登陆检查</span>\n<span class=\"hljs-comment\">// 拦截器会在跳转之间执行，多个拦截器会按优先级顺序依次执行</span>\n<span class=\"hljs-variable\">@Interceptor</span>(priority = <span class=\"hljs-number\">8</span>, name = <span class=\"hljs-string\">&quot;测试用拦截器&quot;</span>)\npublic class TestInterceptor implements IInterceptor &#123;\n    <span class=\"hljs-variable\">@Override</span>\n    public void process(Postcard postcard, InterceptorCallback callback) &#123;\n    ...\n    <span class=\"hljs-selector-tag\">callback</span><span class=\"hljs-selector-class\">.onContinue</span>(postcard);  <span class=\"hljs-comment\">// 处理完成，交还控制权</span>\n    <span class=\"hljs-comment\">// callback.onInterrupt(new RuntimeException(&quot;我觉得有点异常&quot;));      // 觉得有问题，中断路由流程</span>\n\n    <span class=\"hljs-comment\">// 以上两种至少需要调用其中一种，否则不会继续路由</span>\n    &#125;\n\n    <span class=\"hljs-variable\">@Override</span>\n    public void init(Context context) &#123;\n    <span class=\"hljs-comment\">// 拦截器的初始化，会在sdk初始化的时候调用该方法，仅会调用一次</span>\n    &#125;\n&#125;</code></pre>\n<p>如果你按着官方文档上这样写，那么你大概率会碰到很多问题。列举如下：<br><strong>如何处理有些页面需要登录拦截，有些页面不需要登录拦截？</strong><br>如果你添加了拦截器，那么在每次路由跳转时都会优先走到拦截器中，在拦截器的process()方法中你可以通过判断当前是否登录来决定是否继续该路由操作，如果已经登录，那么直接通过 callback.onContinue(postcard)继续当前路由，而如果没有登录，那么就将目的页面修改为登录页。但是，不要忘了，添加拦截器后所有的路由操作都会优先走到这里，而我们的需求是只有需要用户权限的时候才需要跳转到登录页，否则即使没有登录依然可以跳转到目的页。此时我们应该怎么办？<br>如果你仔细的看了ARouter的开发文档，你可能注意到在@Route的注解有一个int类型的extras参数。如此我们便可以通过这个参数来对Activity进行标记是否需要登录：</p>\n<pre><code class=\"hljs scala\"><span class=\"hljs-meta\">@Route</span>(path = <span class=\"hljs-type\">PATH_TEST</span>, extras = <span class=\"hljs-type\">IGNORE_LOGIN</span>)\npublic <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">TestActivity</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">BaseTitleCompatActivity</span> </span>&#123;&#125;</code></pre>\n<p>接下来，在拦截器中可以拿到extras参数，以此来确定该页面是否需要登录：</p>\n<pre><code class=\"hljs reasonml\"><span class=\"hljs-keyword\">if</span>(<span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">UserInfoTools</span>.</span></span>is<span class=\"hljs-constructor\">Login()</span><span class=\"hljs-operator\"> || </span>IGNORE_LOGIN<span class=\"hljs-operator\"> == </span>postcard.get<span class=\"hljs-constructor\">Extra()</span>) &#123;  <span class=\"hljs-comment\">//  已经登录或者不需要拦截的情况</span>\n\t <span class=\"hljs-comment\">//  继续当前路由</span>\n      callback.on<span class=\"hljs-constructor\">Continue(<span class=\"hljs-params\">postcard</span>)</span>;\n &#125; <span class=\"hljs-keyword\">else</span> &#123;\t<span class=\"hljs-comment\">// 未登录且需要登录的情况</span>\n    <span class=\"hljs-comment\">//\t路由到登录页面</span>\n    <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">ARouter</span>.</span></span>get<span class=\"hljs-constructor\">Instance()</span>.build(RoutingTable.PATH_GUEST_LOGIN).navigation<span class=\"hljs-literal\">()</span>;\n    ...\n  &#125;</code></pre>\n<p>到这里这个问题解决了，但是当你兴致勃勃的运行起来App,在未登录的情况下点击跳转到需要用户权限的页面，你憧憬着跳转页面会被拦截到登录页，但是你又被无情的事实打脸了。竟然页面毫无反应？于是你断点、打Log发现ARouter.getInstance().build(RoutingTable.PATH_GUEST_LOGIN).navigation()这句代码确实执行了，但是为什么没有跳转到登录页？于是你苦思冥想，突然灵光一闪，哇！是因为这一句路由也会走到了拦截器里，如此岂不成了一个死循环。于是你Google如何解决，发现原来需要调用greenChannel()来避免出现死循环。于是有了如下代码：</p>\n<pre><code class=\"hljs reasonml\"><span class=\"hljs-keyword\">if</span>(<span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">UserInfoTools</span>.</span></span>is<span class=\"hljs-constructor\">Login()</span><span class=\"hljs-operator\"> || </span>IGNORE_LOGIN<span class=\"hljs-operator\"> == </span>postcard.get<span class=\"hljs-constructor\">Extra()</span>) &#123;  <span class=\"hljs-comment\">//  已经登录或者不需要拦截的情况</span>\n\t <span class=\"hljs-comment\">//  继续当前路由</span>\n      callback.on<span class=\"hljs-constructor\">Continue(<span class=\"hljs-params\">postcard</span>)</span>;\n &#125; <span class=\"hljs-keyword\">else</span> &#123;\t<span class=\"hljs-comment\">// 未登录且需要登录的情况</span>\n    <span class=\"hljs-comment\">//\t路由到登录页面</span>\n   <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">ARouter</span>.</span></span>get<span class=\"hljs-constructor\">Instance()</span>.build(RoutingTable.PATH_GUEST_LOGIN).green<span class=\"hljs-constructor\">Channel()</span>.navigation<span class=\"hljs-literal\">()</span>;\n    ...\n  &#125;</code></pre>\n<p>修改之后你怀着和刚才一样的心情兴致勃勃的运行起来App,心想，这次一定没问题。好！点击按钮….竟然成功跳转到了登录页面。于是你兴奋起来，疯狂的点击这些页面，发现都没问题。可是…当你点了几次之后突然发现，页面跳转无效了！！你简直不敢相信自己的眼睛，刚才明明是好好的…于是你在此陷入了沉思。<br>好吧，这次直接公布答案了，那是因为你需要将原来的路由打断，而之所以前几次有效大概猜测是因为greenChannel()去开启了多个channel，而ARouter的channel是有限的，因此在点击几次之后路由再次失效了。于是修改后代码如下：</p>\n<pre><code class=\"hljs reasonml\"><span class=\"hljs-keyword\">if</span>(<span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">UserInfoTools</span>.</span></span>is<span class=\"hljs-constructor\">Login()</span><span class=\"hljs-operator\"> || </span>IGNORE_LOGIN<span class=\"hljs-operator\"> == </span>postcard.get<span class=\"hljs-constructor\">Extra()</span>) &#123;  <span class=\"hljs-comment\">//  已经登录或者不需要拦截的情况</span>\n\t <span class=\"hljs-comment\">//  继续当前路由</span>\n      callback.on<span class=\"hljs-constructor\">Continue(<span class=\"hljs-params\">postcard</span>)</span>;\n &#125; <span class=\"hljs-keyword\">else</span> &#123;\t<span class=\"hljs-comment\">// 未登录且需要登录的情况</span>\n    <span class=\"hljs-comment\">//\t路由到登录页面</span>\n   <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">ARouter</span>.</span></span>get<span class=\"hljs-constructor\">Instance()</span>.build(RoutingTable.PATH_GUEST_LOGIN).green<span class=\"hljs-constructor\">Channel()</span>.navigation<span class=\"hljs-literal\">()</span>;\n   callback.on<span class=\"hljs-constructor\">Interrupt(<span class=\"hljs-params\">null</span>)</span>;\n  &#125;</code></pre>\n<p>关于登录拦截看似简单，实则使用时候竟然会碰到这么多问题！相信第一次使用时都会被虐的掉眼泪。</p>\n<h2 id=\"2-处理一个Activity对应多个路径的情况\"><a href=\"#2-处理一个Activity对应多个路径的情况\" class=\"headerlink\" title=\"2.处理一个Activity对应多个路径的情况\"></a>2.处理一个Activity对应多个路径的情况</h2><p>在某些情况可能出现一个页面对应多个路径的情况。出现这种情况的原因可能是前期路由没有规划好，导致后边版本的路由路径做了修改。从而出现了一个Activity对应多个页面的情况。为了兼容旧版路由，我们不得不处理这种情况。但是，Route的注解中path是唯一的，并不能通过@Route注解解决一个Activity对应多个路径的情况。此时就需要用到ARouter的重写URL的功能。只需要实现PathReplaceService 接口，在重写的方法中对URI或者Path进行替换即可，注意，这个类一定要加@Route注解。代码参考如下：</p>\n<pre><code class=\"hljs reasonml\">@<span class=\"hljs-constructor\">Route(<span class=\"hljs-params\">path</span> = <span class=\"hljs-string\">&quot;/lost/service&quot;</span>)</span>\npublic <span class=\"hljs-keyword\">class</span> ARouterLostReplaceService implements PathReplaceService &#123;\n    @Override\n    public String <span class=\"hljs-keyword\">for</span><span class=\"hljs-constructor\">String(String <span class=\"hljs-params\">path</span>)</span> &#123;\t<span class=\"hljs-comment\">//\t对于path处理与uri类似</span>\n        return path;\n    &#125;\n\n    @Override\n    public Uri <span class=\"hljs-keyword\">for</span><span class=\"hljs-constructor\">Uri(Uri <span class=\"hljs-params\">uri</span>)</span> &#123;\t\n        String path = uri.get<span class=\"hljs-constructor\">Path()</span>;\n        <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">PATH_LOST1</span>.</span></span>equals(path)) &#123;\n            uri = replace<span class=\"hljs-constructor\">UriPath(<span class=\"hljs-params\">uri</span>, PATH_REAL1)</span>;\n        &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">PATH_LOST2</span>.</span></span>equals(path)) &#123;\n            uri = replace<span class=\"hljs-constructor\">UriPath(<span class=\"hljs-params\">uri</span>, PATH_REAL2)</span>;\n        &#125;\n        return uri;\n    &#125;\n\n    @Override\n    public void init(Context context) &#123;\n\n    &#125;\n\n    <span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">     * 替换URI中的path</span>\n<span class=\"hljs-comment\">     * </span>\n<span class=\"hljs-comment\">     * @param uri 被替换的uri</span>\n<span class=\"hljs-comment\">     * @param path 要替换的path</span>\n<span class=\"hljs-comment\">     * @return 替换后的uri</span>\n<span class=\"hljs-comment\">     */</span>\n    <span class=\"hljs-keyword\">private</span> Uri replace<span class=\"hljs-constructor\">UriPath(Uri <span class=\"hljs-params\">uri</span>, String <span class=\"hljs-params\">path</span>)</span> &#123;\n        StringBuilder resultUrl = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-constructor\">StringBuilder(<span class=\"hljs-params\">uri</span>.<span class=\"hljs-params\">getScheme</span>()</span> + <span class=\"hljs-string\">&quot;://&quot;</span> + uri.get<span class=\"hljs-constructor\">Host()</span> + path);\n        String<span class=\"hljs-literal\">[]</span> split = uri.<span class=\"hljs-keyword\">to</span><span class=\"hljs-constructor\">String()</span>.split(<span class=\"hljs-string\">&quot;\\\\?&quot;</span>);\n        <span class=\"hljs-keyword\">if</span>(split.length &gt;= <span class=\"hljs-number\">2</span>) &#123;\n            resultUrl.append(<span class=\"hljs-string\">&quot;?&quot;</span>).append(split<span class=\"hljs-literal\">[<span class=\"hljs-number\">1</span>]</span>);\n        &#125;\n        return <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">Uri</span>.</span></span>parse(resultUrl.<span class=\"hljs-keyword\">to</span><span class=\"hljs-constructor\">String()</span>);\n    &#125;\n&#125;</code></pre>\n\n<h2 id=\"3-ARouter全局降级策略\"><a href=\"#3-ARouter全局降级策略\" class=\"headerlink\" title=\"3.ARouter全局降级策略\"></a>3.ARouter全局降级策略</h2><p>在路由跳转时可能会出现找不到Path对应页面的情况，对于这种情况可以通过实现DegradeService 接口来处理，同样这个类也必须要添加@Route注解。这样当路由跳转时找不到路径就会走到这个类的onLost方法中，此时就可以在这个方法中来做相应的处理了。</p>\n<pre><code class=\"hljs less\"><span class=\"hljs-comment\">// 实现DegradeService接口，并加上一个Path内容任意的注解即可</span>\n<span class=\"hljs-variable\">@Route</span>(path = <span class=\"hljs-string\">&quot;/lost/path&quot;</span>)\npublic class DegradeServiceImpl implements DegradeService &#123;\n\t<span class=\"hljs-variable\">@Override</span>\n\tpublic void onLost(Context context, Postcard postcard) &#123;\n\t    <span class=\"hljs-comment\">//  可以在此处统一处理，比如跳转到首页</span>\n\t&#125;\n\n\t<span class=\"hljs-variable\">@Override</span>\n\tpublic void init(Context context) &#123;\n\n\t&#125;\n&#125;</code></pre>\n\n<h1 id=\"四、通过浏览器跳转到App对应页面\"><a href=\"#四、通过浏览器跳转到App对应页面\" class=\"headerlink\" title=\"四、通过浏览器跳转到App对应页面\"></a>四、通过浏览器跳转到App对应页面</h1><h2 id=\"1-Schema协议\"><a href=\"#1-Schema协议\" class=\"headerlink\" title=\"1.Schema协议\"></a>1.Schema协议</h2><p>很多人对于Schema协议比较陌生，但是如果说URL大家一定都非常熟悉。其实URL就是一种Schema协议。Schema协议通常由四部分组成：</p>\n<pre><code class=\"hljs inform7\"><span class=\"hljs-comment\">[scheme]</span>://<span class=\"hljs-comment\">[host]</span>/<span class=\"hljs-comment\">[path]</span>?<span class=\"hljs-comment\">[query]</span>\nscheme：表示协议名称\nhost：Schema所作用的地址域\npath：Schema指定的路径\nquery：携带的参数</code></pre>\n<p>拿百度搜索的URL来举例子：<a href=\"https://www.baidu.com/s?wd=%E8%A6%81%E6%90%9C%E7%B4%A2%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97%E3%80%82%E8%BF%99%E4%B8%AAURL%E4%B8%8ESchema%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB%E5%A6%82%E4%B8%8B\">https://www.baidu.com/s?wd=要搜索的关键字。这个URL与Schema协议的对应关系如下</a></p>\n<blockquote>\n<p>schema:：https<br>host： <a href=\"http://www.baidu.com/\">www.baidu.com</a><br>path： /s<br>query：wd=要搜索的关键字</p>\n</blockquote>\n<p>了解了Schema协议后，其实我们完全可以按照Schema协议的格式来自定义一个Schema链接，如下：</p>\n<blockquote>\n<p>myApp://<a href=\"http://www.myapp.com/main/home?id=1\">www.myApp.com/main/home?id=1</a></p>\n<p>我们自己定义的Schema链接的对应关系为：<br> schema:：myApp<br>host：<a href=\"http://www.myapp.com/\">www.myApp.com</a><br>path：/main/home<br>query：id=1</p>\n</blockquote>\n<h2 id=\"2-通过Schema链接打开Activity\"><a href=\"#2-通过Schema链接打开Activity\" class=\"headerlink\" title=\"2.通过Schema链接打开Activity\"></a>2.通过Schema链接打开Activity</h2><p>通过浏览器打开App其实就是通过Schema链接来实现的。我们就以上一节中自定义的Schema链接为例来实现浏览器打开App。首先在项目中添加一个RouterActivity，RouterActivity在AndroidManifest中的配置如下：</p>\n<pre><code class=\"hljs xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">activity</span></span>\n<span class=\"hljs-tag\">      <span class=\"hljs-attr\">android:name</span>=<span class=\"hljs-string\">&quot;.activity.RouterActivity&quot;</span></span>\n<span class=\"hljs-tag\">      <span class=\"hljs-attr\">android:configChanges</span>=<span class=\"hljs-string\">&quot;orientation|keyboardHidden|screenSize&quot;</span></span>\n<span class=\"hljs-tag\">      <span class=\"hljs-attr\">android:screenOrientation</span>=<span class=\"hljs-string\">&quot;portrait&quot;</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">intent-filter</span>&gt;</span>\n          <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">action</span> <span class=\"hljs-attr\">android:name</span>=<span class=\"hljs-string\">&quot;android.intent.action.VIEW&quot;</span> /&gt;</span>\n          <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">category</span> <span class=\"hljs-attr\">android:name</span>=<span class=\"hljs-string\">&quot;android.intent.category.DEFAULT&quot;</span> /&gt;</span>\n           <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">category</span> <span class=\"hljs-attr\">android:name</span>=<span class=\"hljs-string\">&quot;android.intent.category.BROWSABLE&quot;</span> /&gt;</span>\n           <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">data</span> <span class=\"hljs-attr\">android:scheme</span>=<span class=\"hljs-string\">&quot;myApp&quot;</span> /&gt;</span>\n      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">intent-filter</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">activity</span>&gt;</span></code></pre>\n<p>我们在AndroidManifest中为RouterActivity添加了schema，此时在HTML中写入以下代码：</p>\n<pre><code class=\"hljs xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">&quot;myApp://www.myApp.com/main/home?id=1&quot;</span>&gt;</span>打开APP<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span></code></pre>\n<p>通过点击HTML页面的”打开App”便可启动RouterActivity。并且RouterActivity启动后可以通过Intent获取到启动的URI。代码如下：</p>\n<pre><code class=\"hljs reasonml\">  #RouterActivity\n \n@Override\n   protected void on<span class=\"hljs-constructor\">Create(Bundle <span class=\"hljs-params\">data</span>)</span> &#123;\n       super.on<span class=\"hljs-constructor\">Create(<span class=\"hljs-params\">data</span>)</span>;\n       Uri launchUri = get<span class=\"hljs-constructor\">Intent()</span>.get<span class=\"hljs-constructor\">Data()</span>;\n       dispatch<span class=\"hljs-constructor\">RouterUri(<span class=\"hljs-params\">launchUri</span>)</span>;\n   &#125;</code></pre>\n<p>至此，我们已经可以通过App来打开项目的RouterActivity。</p>\n<h2 id=\"3-通过路由跳转到目的页面\"><a href=\"#3-通过路由跳转到目的页面\" class=\"headerlink\" title=\"3.通过路由跳转到目的页面\"></a>3.通过路由跳转到目的页面</h2><p>上一节中我们通过HTML打开了RouterActivity，并在RouterActivity中拿到了跳转的URI，那么接下来我们便可以根据URI的信息打开对应的页面了。但是在开启路由跳转之前为了保险起见需要对URI进行一些校验。详细代码如下：</p>\n<pre><code class=\"hljs reasonml\"><span class=\"hljs-keyword\">private</span> void dispatch<span class=\"hljs-constructor\">RouterUri(Uri <span class=\"hljs-params\">launchUri</span>)</span> &#123;\n        <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">RoutingTable</span>.</span></span>is<span class=\"hljs-constructor\">ValidRouterUri(<span class=\"hljs-params\">launchUri</span>)</span>) &#123;  <span class=\"hljs-comment\">//\t判断是否是合法的URI，这里只有URI携带了Path才算合法</span>\n            <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">App</span>.</span></span>is<span class=\"hljs-constructor\">RootActivityLaunched()</span>) &#123; <span class=\"hljs-comment\">// app已启动</span>\n                <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">RoutingTable</span>.</span></span>is<span class=\"hljs-constructor\">WxUri(<span class=\"hljs-params\">launchUri</span>)</span>) &#123; <span class=\"hljs-comment\">//\t如果是微信的URI那么目的地是要跳转到小程序的（此处为项目中的需求）</span>\n                    <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">RoutingTable</span>.</span></span><span class=\"hljs-keyword\">open</span><span class=\"hljs-constructor\">MiniProgram(<span class=\"hljs-params\">this</span>, <span class=\"hljs-params\">launchUri</span>)</span>;\n                    finish<span class=\"hljs-literal\">()</span>;\n                    return;\n                &#125;\n                <span class=\"hljs-comment\">//\t通过ARouter路由到目的页面</span>\n               <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">ARouter</span>.</span></span>get<span class=\"hljs-constructor\">Instance()</span>.build(launchUri).navigation<span class=\"hljs-literal\">()</span>;\n            &#125; <span class=\"hljs-keyword\">else</span> &#123;  <span class=\"hljs-comment\">// app未启动, 保存router uri, 幷尝试启动app</span>\n               <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">SharedPreferUtil</span>.</span></span>put(Constants.ROUTER_URI, launchUri.<span class=\"hljs-keyword\">to</span><span class=\"hljs-constructor\">String()</span>);\n               launch<span class=\"hljs-constructor\">App()</span>;\n            &#125;\n        &#125; <span class=\"hljs-keyword\">else</span> &#123;  <span class=\"hljs-comment\">//\t 走到此处可能是因为URI没有携带Path，即并非要跳转目的页面，而是要启动APP  。因此直接启动App即可</span>\n            launch<span class=\"hljs-constructor\">App()</span>;\n        &#125;\n        finish<span class=\"hljs-literal\">()</span>;\n    &#125;</code></pre>\n<p>上面代码中，我们对URI做了一系列校验，根据不同的URI做不同的处理。同时我们应该也注意到了，如果APP已经启动了，那么就可以直接跳转对应的页面了，而如果App没有启动，那么则是先将URI保存到了SharedPreference中，接着启动了App。那么此时App启动后会在MainActivity中读取SharedPreference中的配置，如果读取到URI的信息，那么就先将此数据从SharedPreference中移除，然后通过ARouter跳转到URI指定的页面去。MainActivity中的部分代码如下：</p>\n<pre><code class=\"hljs csharp\"><span class=\"hljs-meta\">#MainActivity</span>\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">resumeRoute</span>(<span class=\"hljs-params\"></span>)</span> &#123;\n        <span class=\"hljs-comment\">// Continue for interrupted router uri</span>\n        String interruptedLaunchUriString =\n                Configuration.<span class=\"hljs-keyword\">get</span>(Constants.INTERRUPTED_ROUTER_URI, <span class=\"hljs-literal\">null</span>);\n         <span class=\"hljs-comment\">//\t移除SharedPreference中的URI，避免下次打开MainActivity错误跳转</span>\n        SharedPreferUtil.<span class=\"hljs-keyword\">remove</span>(Constants.ROUTER_URI);\n        Uri launchUri = <span class=\"hljs-literal\">null</span>;\n        <span class=\"hljs-keyword\">if</span>(interruptedLaunchUriString != <span class=\"hljs-literal\">null</span>) &#123; <span class=\"hljs-comment\">// Activity未启动的情况下 通过外部Scheme跳转非MainActivity</span>\n            launchUri = Uri.parse(interruptedLaunchUriString);\n        &#125;\n\n        <span class=\"hljs-keyword\">if</span>(launchUri == <span class=\"hljs-literal\">null</span>) &#123;\n            <span class=\"hljs-keyword\">return</span>;\n        &#125;\n\t\t<span class=\"hljs-comment\">//\t通过路由跳转到URI对应的页面</span>\n        ARouter.getInstance().build(launchUri).navigation();\n    &#125;</code></pre>\n<p>关于ARouter的路由方案所涉及的内容至此已经全部讲完了。</p>\n"},{"title":"Java编译时注解处理器","date":"2018-09-10T15:42:21.000Z","_content":"\n**本文同步发布在[掘金](https://juejin.im/post/5d603d026fb9a06afa3291b9),未经本人允许不得转载**\n\n上篇文章我们使用注解+反射实现了一个仿ButterKnife功能的示例。考虑到反射是在运行时完成的，多少会影响程序性能。因此，ButterKnife本身并非基于注解+反射来实现的，而是用APT技术在编译时处理的。APT什么呢？接下来一起来看。\n\n一、APT简介\n--------------------------\n\n**1.什么是APT？**\nAPT即为Annotation Processing Tool，它是javac的一个工具，中文意思为编译时注解处理器。APT可以用来在编译时扫描和处理注解。通过APT可以获取到注解和被注解对象的相关信息，在拿到这些信息后我们可以根据需求来自动的生成一些代码，省去了手动编写。注意，获取注解及生成代码都是在代码编译时候完成的，相比反射在运行时处理注解大大提高了程序性能。APT的核心是AbstractProcessor类，关于AbstractProcessor类后面会做详细说明。\n**2.哪里用到了APT？**\nAPT技术被广泛的运用在Java框架中，包括Android项以及Java后台项目，除了上面我们提到的ButterKnife之外，像EventBus 、Dagger2以及阿里的ARouter路由框架等都运用到APT技术，因此要想了解以、探究这些第三方框架的实现原理，APT就是我们必须要掌握的。\n \n**3.如何在Android Studio中构建一个APT项目?**\nAPT项目需要由至少两个Java Library模块组成，不知道什么是Java Library？没关系，手把手来叫你如何创建一个Java Library。\n![](https://raw.githubusercontent.com/zhpanvip/Resource/master/image/1601.jfif)\n\n首先，新建一个Android项目，然后File-->New-->New Module,打开如上图所示的面板，选择Java Library即可。刚才说到一个APT项目至少应该由两个Java Library模块。那么这两个模块分别是什么作用呢？\n1.首先需要一个Annotation模块，这个用来存放自定义的注解。\n2. 另外需要一个Compiler模块，这个模块依赖Annotation模块。\n3.项目的App模块和其它的业务模块都需要依赖Annotation模块，同时需要通过annotationProcessor依赖Compiler模块。\napp模块的gradle中依赖关系如下：\n```\nimplementation project(':annotation')\nannotationProcessor project(':factory-compiler')\n```\nAPT项目的模块的结构图如下所示：\n![](https://raw.githubusercontent.com/zhpanvip/Resource/master/image/1602.jfif)\n\n\n> 为什么要强调上述两个模块一定要是Java Library？如果创建Android Library模块你会发现不能找到AbstractProcessor这个类，这是因为Android平台是基于OpenJDK的，而OpenJDK中不包含APT的相关代码。因此，在使用APT时，必须在Java Library中进行。\n\n\n二、从一个例子开始认识APT\n------------------------\n在学习Java基础的时候想必大家都写过简单工厂模式的例子，回想一下什么是简单工厂模式。接下来引入一个工厂模式的例子，首先定义一个形状的接口IShape，并为其添加 draw()方法：\n\n```\npublic interface IShape {\n\tvoid draw();\n}\n```\n接下来定义几个形状实现IShape接口,并重写draw()方法：\n\n```\npublic class Rectangle implements IShape {\n\t@Override\n\tpublic void draw() {\n\t\tSystem.out.println(\"Draw a Rectangle\");\n\t}\n}\n\npublic class Triangle implements IShape {\n\t@Override\n\tpublic void draw() {\n\t\tSystem.out.println(\"Draw a Triangle\");\n\t}\n}\n\npublic class Circle implements IShape {  \n    @Override\n    public void draw() {   \n        System.out.println(\"Draw a circle\");\n    }\n}\n```\n接下来我们需要一个工厂类，这个类接收一个参数，根据我们传入的参数创建出对应的形状，代码如下：\n\n```\npublic class ShapeFactory {\n  public Shape create(String id) {\n    if (id == null) {\n      throw new IllegalArgumentException(\"id is null!\");\n    }\n    if (\"Circle\".equals(id)) {\n      return new Circle();\n    }\n    if (\"Rectangle\".equals(id)) {\n      return new Rectangle();\n    }\n    if (\"Triangle\".equals(id)) {\n      return new Triangle();\n    }\n    throw new IllegalArgumentException(\"Unknown id = \" + id);\n  }\n}\n```\n以上就是一个简单工厂模式的示例代码，想必大家都能够理解。\n\n那么，现在问题来了，在项目开发过程中，我们随时可能会添加一个新的形状。此时就不得不修改工厂类来适配新添加的形状了。试想一下，每添加一个形状类都需要我们手动去更新Factory类，是不是影响了我们的开发效率？如果这个Factory类能够根据我们添加新的形状来同步更新Factory代码，岂不是就省了我们很多时间了吗？\n\n应该怎么做才能满足上述需求呢？在第一节中已经提到了使用APT可以帮助我们自动生成代码。那么这个工厂类是不是可以使用APT技术来自动生成呢？我们唯一要做的事情就是新添加的形状类上加上一个注解，注解处理器就会在编译时根据注解信息自动生成ShapeFactory类的代码了，美哉，美哉！理想很丰满，但是，现实很骨感。虽然已经明确了要做什么，但是想要注解处理器帮我们生成代码，却还有很长的路要走。不过，不当紧，接下来我们将一步步实现注解处理器并让其自动生成Factory类。\n\n## 三、使用APT处理注解\n**1.定义Factory注解**\n首先在annotation模块下添加一个Factory的注解，Factory注解的Target为ElementType，表示它可以注解类、接口或者枚举。Retention指定为RetentionPolicy.CLASS，表示该在字节码中有效。Factory注解添加两个成员，一个Class类型的type，用来表示注解的类的类型，相同的类型表示属于同一个工厂。令需一个String类型的id,用来表示注解的类的名称。Factory注解代码如下：\n\n```\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.CLASS)\npublic @interface Factory {\n\n    Class type();\n\n    String id();\n}\n```\n接下来我们用@Factory去注解形状类，如下：\n\n```\n@Factory(id = \"Rectangle\", type = IShape.class)\npublic class Rectangle implements IShape {\n\t@Override\n\tpublic void draw() {\n\t\tSystem.out.println(\"Draw a Rectangle\");\n\t}\n}\n... 其他形状类代码类似不再贴出\n```\n\n**2.认识AbstractProcessor **\n\n接下来，就到了我们本篇文章所要讲的核心了。没错，就是AbstractProcessor！我们先在factory-compiler模块下创建一个FactoryProcessor类继承AbstractProcessor ，并重写相应的方法，代码如下：\n\n```\n@AutoService(Processor.class)\npublic class FactoryProcessor extends AbstractProcessor {\n \t @Override\n    public synchronized void init(ProcessingEnvironment processingEnvironment) {\n        super.init(processingEnvironment);\n    }\n\n    @Override\n    public Set<String> getSupportedAnnotationTypes() {\n        return super.getSupportedAnnotationTypes();\n    }\n\n    @Override\n    public boolean process(Set<? extends TypeElement> set, RoundEnvironment roundEnvironment) {\n        return false;\n    }\n\n    @Override\n    public SourceVersion getSupportedSourceVersion() {\n        return super.getSupportedSourceVersion();\n    }\n}\n```\n可以看到，在这个类上添加了@AutoService注解，它的作用是用来生成META-INF/services/javax.annotation.processing.Processor文件的，也就是我们在使用注解处理器的时候需要手动添加META-INF/services/javax.annotation.processing.Processor，而有了@AutoService后它会自动帮我们生成。[AutoService](https://github.com/google/auto/tree/master/service)是Google开发的一个库，使用时需要在factory-compiler中添加依赖，如下：\n\n```\nimplementation 'com.google.auto.service:auto-service:1.0-rc4'\n```\n\n接下来我们将目光移到FactoryProcessor类内部，可以看到在这个类中重写了四个方法，我们由易到难依次来看：\n***(1) public SourceVersion getSupportedSourceVersion()*** \n这个方法非常简单，只有一个返回值，用来指定当前正在使用的Java版本，通常return SourceVersion.latestSupported()即可。\n\n ***(2) public Set\\<String\\> getSupportedAnnotationTypes()*** \n 这个方法的返回值是一个Set集合，集合中指要处理的注解类型的名称(这里必须是完整的包名+类名，例如com.example.annotation.Factory)。由于在本例中只需要处理@Factory注解，因此Set集合中只需要添加@Factory的名称即可。\n\n ***(3) public synchronized void init(ProcessingEnvironment processingEnvironment)*** \n这个方法用于初始化处理器，方法中有一个ProcessingEnvironment类型的参数，ProcessingEnvironment是一个注解处理工具的集合。它包含了众多工具类。例如：\nFiler可以用来编写新文件；\nMessager可以用来打印错误信息；\nElements是一个可以处理Element的工具类。\n\n***在这里我们有必要认识一下什么是Element*** \n在Java语言中，Element是一个接口，表示一个程序元素，它可以指代包、类、方法或者一个变量。Element已知的子接口有如下几种：\n\n> PackageElement  表示一个包程序元素。提供对有关包及其成员的信息的访问。\n> ExecutableElement  表示某个类或接口的方法、构造方法或初始化程序（静态或实例），包括注释类型元素。\n> TypeElement  表示一个类或接口程序元素。提供对有关类型及其成员的信息的访问。注意，枚举类型是一种类，而注解类型是一种接口。\n> VariableElement  表示一个字段、enum 常量、方法或构造方法参数、局部变量或异常参数。\n\n接下来，我希望大家先来理解一个新的概念，**即抛弃我们现有对Java类的理解，把Java类看作是一个结构化的文件**。什么意思？就是把Java类看作一个类似XML或者JSON一样的东西。有了这个概念之后我们就可以很容易的理解什么是Element了。带着这个概念来看下面的代码：\n\n```\npackage com.zhpan.mannotation.factory;  //    PackageElement\n\npublic class Circle {  //  TypeElement\n\n    private int i; //   VariableElement\n    private Triangle triangle;  //  VariableElement\n\n    public Circle() {} //    ExecuteableElement\n\n    public void draw(   //  ExecuteableElement\n                        String s)   //  VariableElement\n    {\n        System.out.println(s);\n    }\n\n    @Override\n    public void draw() {    //  ExecuteableElement\n        System.out.println(\"Draw a circle\");\n    }\n}\n```\n现在明白了吗？不同类型Element其实就是映射了Java中不同的类元素！知晓这个概念后将对理解后边的代码有很大的帮助。\n\n\n ***(4) public boolean process(Set<? extends TypeElement> set, RoundEnvironment roundEnvironment)*** \n 终于，到了FactoryProcessor类中最后一个也是最重要的一个方法了。先看这个方法的返回值，是一个boolean类型，返回值表示注解是否由当前Processor 处理。如果返回 true，则这些注解由此注解来处理，后续其它的 Processor 无需再处理它们；如果返回 false，则这些注解未在此Processor中处理并，那么后续 Processor 可以继续处理它们。\n 在这个方法的方法体中，我们可以校验被注解的对象是否合法、可以编写处理注解的代码，以及自动生成需要的java文件等。因此说这个方法是AbstractProcessor 中的最重要的一个方法。我们要处理的大部分逻辑都是在这个方法中完成。\n\n了解上述四个方法之后我们便可以初步的来编写FactoryProcessor类的代码了，如下：\n\n```\n@AutoService(Processor.class)\npublic class FactoryProcessor extends AbstractProcessor {\n        private Types mTypeUtils;\n\t    private Messager mMessager;\n\t    private Filer mFiler;\n\t    private Elements mElementUtils;\n\t    private Map<String, FactoryGroupedClasses> factoryClasses = new LinkedHashMap<>();\n\n \t @Override\n    public synchronized void init(ProcessingEnvironment processingEnvironment) {\n        super.init(processingEnvironment);\n \n\t\tmTypeUtils = processingEnvironment.getTypeUtils();\n        mMessager = processingEnvironment.getMessager();\n        mFiler = processingEnvironment.getFiler();\n        mElementUtils = processingEnvironment.getElementUtils();\n    }\n\n    @Override\n    public Set<String> getSupportedAnnotationTypes() {\n        Set<String> annotations = new LinkedHashSet<>();\n        annotations.add(Factory.class.getCanonicalName());\n        return annotations;\n    }\n\n    @Override\n    public boolean process(Set<? extends TypeElement> set, RoundEnvironment roundEnvironment) {\n\n\t\t   //\t扫描所有被@Factory注解的元素\n\t   for (Element annotatedElement : roundEnv.getElementsAnnotatedWith(Factory.class)) {\n\n\t\t}\n\n        return false;\n    }\n\n    @Override\n    public SourceVersion getSupportedSourceVersion() {\n        return SourceVersion.latestSupported();\n    }\n}\n```\n\n上述FactoryProcessor 代码中在process方法中通过roundEnv.getElementsAnnotatedWith(Factory.class)方法已经拿到了被注解的元素的集合。正常情况下，这个集合中应该包含的是所有被Factory注解的Shape类的元素，也就是一个TypeElement。但在编写程序代码时可能有新来的同事不太了解@Factory的用途而误把@Factory用在接口或者抽象类上，这是不符合我们的标准的。因此，需要在process方法中判断被@Factory注解的元素是否是一个类，如果不是一个类元素，那么就抛出异常，终止编译。代码如下：\n\n```\n@Override\npublic boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {\n\t //  通过RoundEnvironment获取到所有被@Factory注解的对象\n    for (Element annotatedElement : roundEnv.getElementsAnnotatedWith(Factory.class)) {\n\t\tif (annotatedElement.getKind() != ElementKind.CLASS) {\n\t\t\t throw new ProcessingException(annotatedElement, \"Only classes can be annotated with @%s\",\n                    Factory.class.getSimpleName());\n\t         }\n\t         TypeElement typeElement = (TypeElement) annotatedElement;\n\t         FactoryAnnotatedClass annotatedClass = new FactoryAnnotatedClass(typeElement);\n\t\t\t\t...\n        }\n        return true;\n}\n```\n基于面向对象的思想，我们可以将annotatedElement中包含的信息封装成一个对象，方便后续使用，因此，另外可以另外声明一个FactoryAnnotatedClass来解析并存放annotatedElement的相关信息。FactoryAnnotatedClass代码如下：\n\n```\npublic class FactoryAnnotatedClass {\n    private TypeElement mAnnotatedClassElement;\n    private String mQualifiedSuperClassName;\n    private String mSimpleTypeName;\n    private String mId;\n\n    public FactoryAnnotatedClass(TypeElement classElement) {\n        this.mAnnotatedClassElement = classElement;\n        Factory annotation = classElement.getAnnotation(Factory.class);\n        mId = annotation.id();\n        if (mId.length() == 0) {\n            throw new IllegalArgumentException(\n                    String.format(\"id() in @%s for class %s is null or empty! that's not allowed\",\n                            Factory.class.getSimpleName(), classElement.getQualifiedName().toString()));\n        }\n        \n        // Get the full QualifiedTypeName\n        try {  // 该类已经被编译\n            Class<?> clazz = annotation.type();\n            mQualifiedSuperClassName = clazz.getCanonicalName();\n            mSimpleTypeName = clazz.getSimpleName();\n        } catch (MirroredTypeException mte) {// 该类未被编译\n            DeclaredType classTypeMirror = (DeclaredType) mte.getTypeMirror();\n            TypeElement classTypeElement = (TypeElement) classTypeMirror.asElement();\n            mQualifiedSuperClassName = classTypeElement.getQualifiedName().toString();\n            mSimpleTypeName = classTypeElement.getSimpleName().toString();\n        }\n    }\n\n    // ...省去getter\n}\n```\n为了生成合乎要求的ShapeFactory类，在生成ShapeFactory代码前需要对被Factory注解的元素进行一系列的校验，只有通过校验，符合要求了才可以生成ShapeFactory代码。根据需求，我们列出如下规则：\n> 1.只有类才能被@Factory注解。因为在ShapeFactory中我们需要实例化Shape对象，虽然@Factory注解声明了Target为ElementType.TYPE，但接口和枚举并不符合我们的要求。\n> 2.被@Factory注解的类中需要有public的构造方法，这样才能实例化对象。\n> 3.被注解的类必须是type指定的类的子类\n> 4.id需要为String类型，并且需要在相同type组中唯一\n> 5.具有相同type的注解类会被生成在同一个工厂类中\n\n根据上面的规则，我们来一步步完成校验，如下代码：\n```\n\nprivate void checkValidClass(FactoryAnnotatedClass item) throws ProcessingException {\n\n        TypeElement classElement = item.getTypeElement();\n\n        if (!classElement.getModifiers().contains(Modifier.PUBLIC)) {\n            throw new ProcessingException(classElement, \"The class %s is not public.\",\n                    classElement.getQualifiedName().toString());\n        }\n\n        // 如果是抽象方法则抛出异常终止编译\n        if (classElement.getModifiers().contains(Modifier.ABSTRACT)) {\n            throw new ProcessingException(classElement,\n                    \"The class %s is abstract. You can't annotate abstract classes with @%\",\n                    classElement.getQualifiedName().toString(), Factory.class.getSimpleName());\n        }\n\n        // 这个类必须是在@Factory.type()中指定的类的子类，否则抛出异常终止编译\n        TypeElement superClassElement = mElementUtils.getTypeElement(item.getQualifiedFactoryGroupName());\n        if (superClassElement.getKind() == ElementKind.INTERFACE) {\n            // 检查被注解类是否实现或继承了@Factory.type()所指定的类型，此处均为IShape\n            if (!classElement.getInterfaces().contains(superClassElement.asType())) {\n                throw new ProcessingException(classElement,\n                        \"The class %s annotated with @%s must implement the interface %s\",\n                        classElement.getQualifiedName().toString(), Factory.class.getSimpleName(),\n                        item.getQualifiedFactoryGroupName());\n            }\n        } else {\n            TypeElement currentClass = classElement;\n            while (true) {\n                TypeMirror superClassType = currentClass.getSuperclass();\n\n                if (superClassType.getKind() == TypeKind.NONE) {\n                    // 向上遍历父类，直到Object也没获取到所需父类，终止编译抛出异常\n                    throw new ProcessingException(classElement,\n                            \"The class %s annotated with @%s must inherit from %s\",\n                            classElement.getQualifiedName().toString(), Factory.class.getSimpleName(),\n                            item.getQualifiedFactoryGroupName());\n                }\n\n                if (superClassType.toString().equals(item.getQualifiedFactoryGroupName())) {\n                    // 校验通过，终止遍历\n                    break;\n                }\n                currentClass = (TypeElement) mTypeUtils.asElement(superClassType);\n            }\n        }\n\n        // 检查是否由public的无参构造方法\n        for (Element enclosed : classElement.getEnclosedElements()) {\n            if (enclosed.getKind() == ElementKind.CONSTRUCTOR) {\n                ExecutableElement constructorElement = (ExecutableElement) enclosed;\n                if (constructorElement.getParameters().size() == 0 &&\n                        constructorElement.getModifiers().contains(Modifier.PUBLIC)) {\n                    // 存在public的无参构造方法，检查结束\n                    return;\n                }\n            }\n        }\n\n        // 为检测到public的无参构造方法，抛出异常，终止编译\n        throw new ProcessingException(classElement,\n                \"The class %s must provide an public empty default constructor\",\n                classElement.getQualifiedName().toString());\n    }\n```\n如果通过上述校验，那么说明被@Factory注解的类是符合我们的要求的，接下来就可以处理注解信息来生成所需代码了。但是本着面向对象的思想，我们还需声明FactoryGroupedClasses来存放FactoryAnnotatedClass，并且在这个类中完成了ShapeFactory类的代码生成。FactoryGroupedClasses 代码如下：\n\n```\npublic class FactoryGroupedClasses {\n\n    private static final String SUFFIX = \"Factory\";\n    private String qualifiedClassName;\n\n    private Map<String, FactoryAnnotatedClass> itemsMap = new LinkedHashMap<>();\n\n    public FactoryGroupedClasses(String qualifiedClassName) {\n        this.qualifiedClassName = qualifiedClassName;\n    }\n\n    public void add(FactoryAnnotatedClass toInsert) {\n        FactoryAnnotatedClass factoryAnnotatedClass = itemsMap.get(toInsert.getId());\n        if (factoryAnnotatedClass != null) {\n            throw new IdAlreadyUsedException(factoryAnnotatedClass);\n        }\n        itemsMap.put(toInsert.getId(), toInsert);\n    }\n\n  public void generateCode(Elements elementUtils, Filer filer) throws IOException {\n        //  Generate java file\n        ...\n    }\n}\n```\n接下来将所有的FactoryGroupedClasses都添加到集合中去\n\n```\n   private Map<String, FactoryGroupedClasses> factoryClasses = new LinkedHashMap<>();\n\n\t// \t...\n\tFactoryGroupedClasses factoryClass = factoryClasses.get(annotatedClass.getQualifiedFactoryGroupName());\n    if (factoryClass == null) {\n            String qualifiedGroupName = annotatedClass.getQualifiedFactoryGroupName();\n            factoryClass = new FactoryGroupedClasses(qualifiedGroupName);\n            factoryClasses.put(qualifiedGroupName, factoryClass);\n      }\n\tfactoryClass.add(annotatedClass);\n\t// ...\n```\nOK!到目前为止，所有的准备工作都已经完成了。接下来就是根据注解信息来生成ShapeFactory类了，有没有很兴奋？遍历factoryClasses集合,并调用FactoryGroupedClasses类的generateCode()方法来生成代码了：\n\n```\nfor (FactoryGroupedClasses factoryClass : factoryClasses.values()) {\n          factoryClass.generateCode(mElementUtils, mFiler);\n     }\n```\n可是，当我们去掉用generateCode(mElementUtils, mFiler)方法的时候.....纳尼？还是一个空方法，我们还没由实现呢！笑哭?...\n\n四、认识JavaPoet并用其生成ShapeFactory类\n--------------\n到此为止，我们唯一剩余的需求就是生成ShapeFactory类了。上一节中我们在FactoryProcessor类的init(ProcessingEnvironment processingEnvironment)方法中通过processingEnvironment拿到了Filer，并且我们也提到通过Filer可以用来编写文件，即可以通过Filer来生成我们所需要的ShapeFactory类。但是，直接使用Filer需要我们手动拼接类的代码，很可能一不小心写错了一个字母就致使所生成的类是无效的。因此，我们需要来认识一下[JavaPoet](https://github.com/square/javapoet)这个库。 JavaPoet是square公司的一个开源框架[JavaPoet](https://github.com/square/javapoet)，由Jake Wharton大神所编写。JavaPoet可以用对象的方式来帮助我们生成类代码，也就是我们能只要把要生成的类文件包装成一个对象，JavaPoet便可以自动帮我们生成类文件了。关于这个库的使用就不详细在这里讲解了，有需要了解的可以到github查看，使用起来很简单。\n\n好了，步入正题，使用JavaPoet构建并自动生成ShapeFactory类的代码如下：\n```\npublic void generateCode(Elements elementUtils, Filer filer) throws IOException {\n        TypeElement superClassName = elementUtils.getTypeElement(qualifiedClassName);\n        String factoryClassName = superClassName.getSimpleName() + SUFFIX;\n        String qualifiedFactoryClassName = qualifiedClassName + SUFFIX;\n        PackageElement pkg = elementUtils.getPackageOf(superClassName);\n        String packageName = pkg.isUnnamed() ? null : pkg.getQualifiedName().toString();\n\n        MethodSpec.Builder method = MethodSpec.methodBuilder(\"create\")\n                .addModifiers(Modifier.PUBLIC)\n                .addParameter(String.class, \"id\")\n                .returns(TypeName.get(superClassName.asType()));\n        method.beginControlFlow(\"if (id == null)\")\n                .addStatement(\"throw new IllegalArgumentException($S)\", \"id is null!\")\n                .endControlFlow();\n\n        for (FactoryAnnotatedClass item : itemsMap.values()) {\n            method.beginControlFlow(\"if ($S.equals(id))\", item.getId())\n                    .addStatement(\"return new $L()\", item.getTypeElement().getQualifiedName().toString())\n                    .endControlFlow();\n        }\n\n        method.addStatement(\"throw new IllegalArgumentException($S + id)\", \"Unknown id = \");\n\n        TypeSpec typeSpec = TypeSpec\n                .classBuilder(factoryClassName)\n                .addModifiers(Modifier.PUBLIC)\n                .addMethod(method.build())\n                .build();\n\n        JavaFile.builder(packageName, typeSpec).build().writeTo(filer);\n    }\n```\n\n好了，现在项目已经可以帮我们自动来生成需要的Java文件啦。接下来验证一下，Build一下项目，切换到project模式下，在app-->build-->generated-->source-->apt-->debug-->(package)-->factory下面就可以看到ShapeFactory类，如下图：\n![](https://raw.githubusercontent.com/zhpanvip/Resource/master/image/1603.jfif)\n\n这个类并非是我们自己编写的，而是通过使用APT的一系列骚操作自动生成的。现在可以再添加一个形状类实现IShape并附加@Factory注解，再次编译后都自动会生成到ShapeFactory中！\n\n到此为止，本篇文章就告一段落了。相信看完本篇文章一定大有所获，因为掌握了APT技术之后，再去研究使用APT的第三方框架源码，一定会游刃有余，事半功倍。\n\n由于本篇文章结构比较复杂且代码也较多，项目的源码已经放在文章末尾，可作参考。\n\n[源码下载](https://github.com/zhpanvip/MAnnotation)\n\n**参考资料**\n\n[Java注解处理器](https://www.race604.com/annotation-processing/)\n\n[JDK文档AbstractProcessor](http://www.cjsdn.net/Doc/JDK60/javax/annotation/processing/AbstractProcessor.html)\n\n","source":"_posts/17.Java编译时注解处理器.md","raw":"---\ntitle: Java编译时注解处理器\ndate: 2018-09-10 23:42:21\ntags: \n- Annotation\n- APT\n---\n\n**本文同步发布在[掘金](https://juejin.im/post/5d603d026fb9a06afa3291b9),未经本人允许不得转载**\n\n上篇文章我们使用注解+反射实现了一个仿ButterKnife功能的示例。考虑到反射是在运行时完成的，多少会影响程序性能。因此，ButterKnife本身并非基于注解+反射来实现的，而是用APT技术在编译时处理的。APT什么呢？接下来一起来看。\n\n一、APT简介\n--------------------------\n\n**1.什么是APT？**\nAPT即为Annotation Processing Tool，它是javac的一个工具，中文意思为编译时注解处理器。APT可以用来在编译时扫描和处理注解。通过APT可以获取到注解和被注解对象的相关信息，在拿到这些信息后我们可以根据需求来自动的生成一些代码，省去了手动编写。注意，获取注解及生成代码都是在代码编译时候完成的，相比反射在运行时处理注解大大提高了程序性能。APT的核心是AbstractProcessor类，关于AbstractProcessor类后面会做详细说明。\n**2.哪里用到了APT？**\nAPT技术被广泛的运用在Java框架中，包括Android项以及Java后台项目，除了上面我们提到的ButterKnife之外，像EventBus 、Dagger2以及阿里的ARouter路由框架等都运用到APT技术，因此要想了解以、探究这些第三方框架的实现原理，APT就是我们必须要掌握的。\n \n**3.如何在Android Studio中构建一个APT项目?**\nAPT项目需要由至少两个Java Library模块组成，不知道什么是Java Library？没关系，手把手来叫你如何创建一个Java Library。\n![](https://raw.githubusercontent.com/zhpanvip/Resource/master/image/1601.jfif)\n\n首先，新建一个Android项目，然后File-->New-->New Module,打开如上图所示的面板，选择Java Library即可。刚才说到一个APT项目至少应该由两个Java Library模块。那么这两个模块分别是什么作用呢？\n1.首先需要一个Annotation模块，这个用来存放自定义的注解。\n2. 另外需要一个Compiler模块，这个模块依赖Annotation模块。\n3.项目的App模块和其它的业务模块都需要依赖Annotation模块，同时需要通过annotationProcessor依赖Compiler模块。\napp模块的gradle中依赖关系如下：\n```\nimplementation project(':annotation')\nannotationProcessor project(':factory-compiler')\n```\nAPT项目的模块的结构图如下所示：\n![](https://raw.githubusercontent.com/zhpanvip/Resource/master/image/1602.jfif)\n\n\n> 为什么要强调上述两个模块一定要是Java Library？如果创建Android Library模块你会发现不能找到AbstractProcessor这个类，这是因为Android平台是基于OpenJDK的，而OpenJDK中不包含APT的相关代码。因此，在使用APT时，必须在Java Library中进行。\n\n\n二、从一个例子开始认识APT\n------------------------\n在学习Java基础的时候想必大家都写过简单工厂模式的例子，回想一下什么是简单工厂模式。接下来引入一个工厂模式的例子，首先定义一个形状的接口IShape，并为其添加 draw()方法：\n\n```\npublic interface IShape {\n\tvoid draw();\n}\n```\n接下来定义几个形状实现IShape接口,并重写draw()方法：\n\n```\npublic class Rectangle implements IShape {\n\t@Override\n\tpublic void draw() {\n\t\tSystem.out.println(\"Draw a Rectangle\");\n\t}\n}\n\npublic class Triangle implements IShape {\n\t@Override\n\tpublic void draw() {\n\t\tSystem.out.println(\"Draw a Triangle\");\n\t}\n}\n\npublic class Circle implements IShape {  \n    @Override\n    public void draw() {   \n        System.out.println(\"Draw a circle\");\n    }\n}\n```\n接下来我们需要一个工厂类，这个类接收一个参数，根据我们传入的参数创建出对应的形状，代码如下：\n\n```\npublic class ShapeFactory {\n  public Shape create(String id) {\n    if (id == null) {\n      throw new IllegalArgumentException(\"id is null!\");\n    }\n    if (\"Circle\".equals(id)) {\n      return new Circle();\n    }\n    if (\"Rectangle\".equals(id)) {\n      return new Rectangle();\n    }\n    if (\"Triangle\".equals(id)) {\n      return new Triangle();\n    }\n    throw new IllegalArgumentException(\"Unknown id = \" + id);\n  }\n}\n```\n以上就是一个简单工厂模式的示例代码，想必大家都能够理解。\n\n那么，现在问题来了，在项目开发过程中，我们随时可能会添加一个新的形状。此时就不得不修改工厂类来适配新添加的形状了。试想一下，每添加一个形状类都需要我们手动去更新Factory类，是不是影响了我们的开发效率？如果这个Factory类能够根据我们添加新的形状来同步更新Factory代码，岂不是就省了我们很多时间了吗？\n\n应该怎么做才能满足上述需求呢？在第一节中已经提到了使用APT可以帮助我们自动生成代码。那么这个工厂类是不是可以使用APT技术来自动生成呢？我们唯一要做的事情就是新添加的形状类上加上一个注解，注解处理器就会在编译时根据注解信息自动生成ShapeFactory类的代码了，美哉，美哉！理想很丰满，但是，现实很骨感。虽然已经明确了要做什么，但是想要注解处理器帮我们生成代码，却还有很长的路要走。不过，不当紧，接下来我们将一步步实现注解处理器并让其自动生成Factory类。\n\n## 三、使用APT处理注解\n**1.定义Factory注解**\n首先在annotation模块下添加一个Factory的注解，Factory注解的Target为ElementType，表示它可以注解类、接口或者枚举。Retention指定为RetentionPolicy.CLASS，表示该在字节码中有效。Factory注解添加两个成员，一个Class类型的type，用来表示注解的类的类型，相同的类型表示属于同一个工厂。令需一个String类型的id,用来表示注解的类的名称。Factory注解代码如下：\n\n```\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.CLASS)\npublic @interface Factory {\n\n    Class type();\n\n    String id();\n}\n```\n接下来我们用@Factory去注解形状类，如下：\n\n```\n@Factory(id = \"Rectangle\", type = IShape.class)\npublic class Rectangle implements IShape {\n\t@Override\n\tpublic void draw() {\n\t\tSystem.out.println(\"Draw a Rectangle\");\n\t}\n}\n... 其他形状类代码类似不再贴出\n```\n\n**2.认识AbstractProcessor **\n\n接下来，就到了我们本篇文章所要讲的核心了。没错，就是AbstractProcessor！我们先在factory-compiler模块下创建一个FactoryProcessor类继承AbstractProcessor ，并重写相应的方法，代码如下：\n\n```\n@AutoService(Processor.class)\npublic class FactoryProcessor extends AbstractProcessor {\n \t @Override\n    public synchronized void init(ProcessingEnvironment processingEnvironment) {\n        super.init(processingEnvironment);\n    }\n\n    @Override\n    public Set<String> getSupportedAnnotationTypes() {\n        return super.getSupportedAnnotationTypes();\n    }\n\n    @Override\n    public boolean process(Set<? extends TypeElement> set, RoundEnvironment roundEnvironment) {\n        return false;\n    }\n\n    @Override\n    public SourceVersion getSupportedSourceVersion() {\n        return super.getSupportedSourceVersion();\n    }\n}\n```\n可以看到，在这个类上添加了@AutoService注解，它的作用是用来生成META-INF/services/javax.annotation.processing.Processor文件的，也就是我们在使用注解处理器的时候需要手动添加META-INF/services/javax.annotation.processing.Processor，而有了@AutoService后它会自动帮我们生成。[AutoService](https://github.com/google/auto/tree/master/service)是Google开发的一个库，使用时需要在factory-compiler中添加依赖，如下：\n\n```\nimplementation 'com.google.auto.service:auto-service:1.0-rc4'\n```\n\n接下来我们将目光移到FactoryProcessor类内部，可以看到在这个类中重写了四个方法，我们由易到难依次来看：\n***(1) public SourceVersion getSupportedSourceVersion()*** \n这个方法非常简单，只有一个返回值，用来指定当前正在使用的Java版本，通常return SourceVersion.latestSupported()即可。\n\n ***(2) public Set\\<String\\> getSupportedAnnotationTypes()*** \n 这个方法的返回值是一个Set集合，集合中指要处理的注解类型的名称(这里必须是完整的包名+类名，例如com.example.annotation.Factory)。由于在本例中只需要处理@Factory注解，因此Set集合中只需要添加@Factory的名称即可。\n\n ***(3) public synchronized void init(ProcessingEnvironment processingEnvironment)*** \n这个方法用于初始化处理器，方法中有一个ProcessingEnvironment类型的参数，ProcessingEnvironment是一个注解处理工具的集合。它包含了众多工具类。例如：\nFiler可以用来编写新文件；\nMessager可以用来打印错误信息；\nElements是一个可以处理Element的工具类。\n\n***在这里我们有必要认识一下什么是Element*** \n在Java语言中，Element是一个接口，表示一个程序元素，它可以指代包、类、方法或者一个变量。Element已知的子接口有如下几种：\n\n> PackageElement  表示一个包程序元素。提供对有关包及其成员的信息的访问。\n> ExecutableElement  表示某个类或接口的方法、构造方法或初始化程序（静态或实例），包括注释类型元素。\n> TypeElement  表示一个类或接口程序元素。提供对有关类型及其成员的信息的访问。注意，枚举类型是一种类，而注解类型是一种接口。\n> VariableElement  表示一个字段、enum 常量、方法或构造方法参数、局部变量或异常参数。\n\n接下来，我希望大家先来理解一个新的概念，**即抛弃我们现有对Java类的理解，把Java类看作是一个结构化的文件**。什么意思？就是把Java类看作一个类似XML或者JSON一样的东西。有了这个概念之后我们就可以很容易的理解什么是Element了。带着这个概念来看下面的代码：\n\n```\npackage com.zhpan.mannotation.factory;  //    PackageElement\n\npublic class Circle {  //  TypeElement\n\n    private int i; //   VariableElement\n    private Triangle triangle;  //  VariableElement\n\n    public Circle() {} //    ExecuteableElement\n\n    public void draw(   //  ExecuteableElement\n                        String s)   //  VariableElement\n    {\n        System.out.println(s);\n    }\n\n    @Override\n    public void draw() {    //  ExecuteableElement\n        System.out.println(\"Draw a circle\");\n    }\n}\n```\n现在明白了吗？不同类型Element其实就是映射了Java中不同的类元素！知晓这个概念后将对理解后边的代码有很大的帮助。\n\n\n ***(4) public boolean process(Set<? extends TypeElement> set, RoundEnvironment roundEnvironment)*** \n 终于，到了FactoryProcessor类中最后一个也是最重要的一个方法了。先看这个方法的返回值，是一个boolean类型，返回值表示注解是否由当前Processor 处理。如果返回 true，则这些注解由此注解来处理，后续其它的 Processor 无需再处理它们；如果返回 false，则这些注解未在此Processor中处理并，那么后续 Processor 可以继续处理它们。\n 在这个方法的方法体中，我们可以校验被注解的对象是否合法、可以编写处理注解的代码，以及自动生成需要的java文件等。因此说这个方法是AbstractProcessor 中的最重要的一个方法。我们要处理的大部分逻辑都是在这个方法中完成。\n\n了解上述四个方法之后我们便可以初步的来编写FactoryProcessor类的代码了，如下：\n\n```\n@AutoService(Processor.class)\npublic class FactoryProcessor extends AbstractProcessor {\n        private Types mTypeUtils;\n\t    private Messager mMessager;\n\t    private Filer mFiler;\n\t    private Elements mElementUtils;\n\t    private Map<String, FactoryGroupedClasses> factoryClasses = new LinkedHashMap<>();\n\n \t @Override\n    public synchronized void init(ProcessingEnvironment processingEnvironment) {\n        super.init(processingEnvironment);\n \n\t\tmTypeUtils = processingEnvironment.getTypeUtils();\n        mMessager = processingEnvironment.getMessager();\n        mFiler = processingEnvironment.getFiler();\n        mElementUtils = processingEnvironment.getElementUtils();\n    }\n\n    @Override\n    public Set<String> getSupportedAnnotationTypes() {\n        Set<String> annotations = new LinkedHashSet<>();\n        annotations.add(Factory.class.getCanonicalName());\n        return annotations;\n    }\n\n    @Override\n    public boolean process(Set<? extends TypeElement> set, RoundEnvironment roundEnvironment) {\n\n\t\t   //\t扫描所有被@Factory注解的元素\n\t   for (Element annotatedElement : roundEnv.getElementsAnnotatedWith(Factory.class)) {\n\n\t\t}\n\n        return false;\n    }\n\n    @Override\n    public SourceVersion getSupportedSourceVersion() {\n        return SourceVersion.latestSupported();\n    }\n}\n```\n\n上述FactoryProcessor 代码中在process方法中通过roundEnv.getElementsAnnotatedWith(Factory.class)方法已经拿到了被注解的元素的集合。正常情况下，这个集合中应该包含的是所有被Factory注解的Shape类的元素，也就是一个TypeElement。但在编写程序代码时可能有新来的同事不太了解@Factory的用途而误把@Factory用在接口或者抽象类上，这是不符合我们的标准的。因此，需要在process方法中判断被@Factory注解的元素是否是一个类，如果不是一个类元素，那么就抛出异常，终止编译。代码如下：\n\n```\n@Override\npublic boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {\n\t //  通过RoundEnvironment获取到所有被@Factory注解的对象\n    for (Element annotatedElement : roundEnv.getElementsAnnotatedWith(Factory.class)) {\n\t\tif (annotatedElement.getKind() != ElementKind.CLASS) {\n\t\t\t throw new ProcessingException(annotatedElement, \"Only classes can be annotated with @%s\",\n                    Factory.class.getSimpleName());\n\t         }\n\t         TypeElement typeElement = (TypeElement) annotatedElement;\n\t         FactoryAnnotatedClass annotatedClass = new FactoryAnnotatedClass(typeElement);\n\t\t\t\t...\n        }\n        return true;\n}\n```\n基于面向对象的思想，我们可以将annotatedElement中包含的信息封装成一个对象，方便后续使用，因此，另外可以另外声明一个FactoryAnnotatedClass来解析并存放annotatedElement的相关信息。FactoryAnnotatedClass代码如下：\n\n```\npublic class FactoryAnnotatedClass {\n    private TypeElement mAnnotatedClassElement;\n    private String mQualifiedSuperClassName;\n    private String mSimpleTypeName;\n    private String mId;\n\n    public FactoryAnnotatedClass(TypeElement classElement) {\n        this.mAnnotatedClassElement = classElement;\n        Factory annotation = classElement.getAnnotation(Factory.class);\n        mId = annotation.id();\n        if (mId.length() == 0) {\n            throw new IllegalArgumentException(\n                    String.format(\"id() in @%s for class %s is null or empty! that's not allowed\",\n                            Factory.class.getSimpleName(), classElement.getQualifiedName().toString()));\n        }\n        \n        // Get the full QualifiedTypeName\n        try {  // 该类已经被编译\n            Class<?> clazz = annotation.type();\n            mQualifiedSuperClassName = clazz.getCanonicalName();\n            mSimpleTypeName = clazz.getSimpleName();\n        } catch (MirroredTypeException mte) {// 该类未被编译\n            DeclaredType classTypeMirror = (DeclaredType) mte.getTypeMirror();\n            TypeElement classTypeElement = (TypeElement) classTypeMirror.asElement();\n            mQualifiedSuperClassName = classTypeElement.getQualifiedName().toString();\n            mSimpleTypeName = classTypeElement.getSimpleName().toString();\n        }\n    }\n\n    // ...省去getter\n}\n```\n为了生成合乎要求的ShapeFactory类，在生成ShapeFactory代码前需要对被Factory注解的元素进行一系列的校验，只有通过校验，符合要求了才可以生成ShapeFactory代码。根据需求，我们列出如下规则：\n> 1.只有类才能被@Factory注解。因为在ShapeFactory中我们需要实例化Shape对象，虽然@Factory注解声明了Target为ElementType.TYPE，但接口和枚举并不符合我们的要求。\n> 2.被@Factory注解的类中需要有public的构造方法，这样才能实例化对象。\n> 3.被注解的类必须是type指定的类的子类\n> 4.id需要为String类型，并且需要在相同type组中唯一\n> 5.具有相同type的注解类会被生成在同一个工厂类中\n\n根据上面的规则，我们来一步步完成校验，如下代码：\n```\n\nprivate void checkValidClass(FactoryAnnotatedClass item) throws ProcessingException {\n\n        TypeElement classElement = item.getTypeElement();\n\n        if (!classElement.getModifiers().contains(Modifier.PUBLIC)) {\n            throw new ProcessingException(classElement, \"The class %s is not public.\",\n                    classElement.getQualifiedName().toString());\n        }\n\n        // 如果是抽象方法则抛出异常终止编译\n        if (classElement.getModifiers().contains(Modifier.ABSTRACT)) {\n            throw new ProcessingException(classElement,\n                    \"The class %s is abstract. You can't annotate abstract classes with @%\",\n                    classElement.getQualifiedName().toString(), Factory.class.getSimpleName());\n        }\n\n        // 这个类必须是在@Factory.type()中指定的类的子类，否则抛出异常终止编译\n        TypeElement superClassElement = mElementUtils.getTypeElement(item.getQualifiedFactoryGroupName());\n        if (superClassElement.getKind() == ElementKind.INTERFACE) {\n            // 检查被注解类是否实现或继承了@Factory.type()所指定的类型，此处均为IShape\n            if (!classElement.getInterfaces().contains(superClassElement.asType())) {\n                throw new ProcessingException(classElement,\n                        \"The class %s annotated with @%s must implement the interface %s\",\n                        classElement.getQualifiedName().toString(), Factory.class.getSimpleName(),\n                        item.getQualifiedFactoryGroupName());\n            }\n        } else {\n            TypeElement currentClass = classElement;\n            while (true) {\n                TypeMirror superClassType = currentClass.getSuperclass();\n\n                if (superClassType.getKind() == TypeKind.NONE) {\n                    // 向上遍历父类，直到Object也没获取到所需父类，终止编译抛出异常\n                    throw new ProcessingException(classElement,\n                            \"The class %s annotated with @%s must inherit from %s\",\n                            classElement.getQualifiedName().toString(), Factory.class.getSimpleName(),\n                            item.getQualifiedFactoryGroupName());\n                }\n\n                if (superClassType.toString().equals(item.getQualifiedFactoryGroupName())) {\n                    // 校验通过，终止遍历\n                    break;\n                }\n                currentClass = (TypeElement) mTypeUtils.asElement(superClassType);\n            }\n        }\n\n        // 检查是否由public的无参构造方法\n        for (Element enclosed : classElement.getEnclosedElements()) {\n            if (enclosed.getKind() == ElementKind.CONSTRUCTOR) {\n                ExecutableElement constructorElement = (ExecutableElement) enclosed;\n                if (constructorElement.getParameters().size() == 0 &&\n                        constructorElement.getModifiers().contains(Modifier.PUBLIC)) {\n                    // 存在public的无参构造方法，检查结束\n                    return;\n                }\n            }\n        }\n\n        // 为检测到public的无参构造方法，抛出异常，终止编译\n        throw new ProcessingException(classElement,\n                \"The class %s must provide an public empty default constructor\",\n                classElement.getQualifiedName().toString());\n    }\n```\n如果通过上述校验，那么说明被@Factory注解的类是符合我们的要求的，接下来就可以处理注解信息来生成所需代码了。但是本着面向对象的思想，我们还需声明FactoryGroupedClasses来存放FactoryAnnotatedClass，并且在这个类中完成了ShapeFactory类的代码生成。FactoryGroupedClasses 代码如下：\n\n```\npublic class FactoryGroupedClasses {\n\n    private static final String SUFFIX = \"Factory\";\n    private String qualifiedClassName;\n\n    private Map<String, FactoryAnnotatedClass> itemsMap = new LinkedHashMap<>();\n\n    public FactoryGroupedClasses(String qualifiedClassName) {\n        this.qualifiedClassName = qualifiedClassName;\n    }\n\n    public void add(FactoryAnnotatedClass toInsert) {\n        FactoryAnnotatedClass factoryAnnotatedClass = itemsMap.get(toInsert.getId());\n        if (factoryAnnotatedClass != null) {\n            throw new IdAlreadyUsedException(factoryAnnotatedClass);\n        }\n        itemsMap.put(toInsert.getId(), toInsert);\n    }\n\n  public void generateCode(Elements elementUtils, Filer filer) throws IOException {\n        //  Generate java file\n        ...\n    }\n}\n```\n接下来将所有的FactoryGroupedClasses都添加到集合中去\n\n```\n   private Map<String, FactoryGroupedClasses> factoryClasses = new LinkedHashMap<>();\n\n\t// \t...\n\tFactoryGroupedClasses factoryClass = factoryClasses.get(annotatedClass.getQualifiedFactoryGroupName());\n    if (factoryClass == null) {\n            String qualifiedGroupName = annotatedClass.getQualifiedFactoryGroupName();\n            factoryClass = new FactoryGroupedClasses(qualifiedGroupName);\n            factoryClasses.put(qualifiedGroupName, factoryClass);\n      }\n\tfactoryClass.add(annotatedClass);\n\t// ...\n```\nOK!到目前为止，所有的准备工作都已经完成了。接下来就是根据注解信息来生成ShapeFactory类了，有没有很兴奋？遍历factoryClasses集合,并调用FactoryGroupedClasses类的generateCode()方法来生成代码了：\n\n```\nfor (FactoryGroupedClasses factoryClass : factoryClasses.values()) {\n          factoryClass.generateCode(mElementUtils, mFiler);\n     }\n```\n可是，当我们去掉用generateCode(mElementUtils, mFiler)方法的时候.....纳尼？还是一个空方法，我们还没由实现呢！笑哭?...\n\n四、认识JavaPoet并用其生成ShapeFactory类\n--------------\n到此为止，我们唯一剩余的需求就是生成ShapeFactory类了。上一节中我们在FactoryProcessor类的init(ProcessingEnvironment processingEnvironment)方法中通过processingEnvironment拿到了Filer，并且我们也提到通过Filer可以用来编写文件，即可以通过Filer来生成我们所需要的ShapeFactory类。但是，直接使用Filer需要我们手动拼接类的代码，很可能一不小心写错了一个字母就致使所生成的类是无效的。因此，我们需要来认识一下[JavaPoet](https://github.com/square/javapoet)这个库。 JavaPoet是square公司的一个开源框架[JavaPoet](https://github.com/square/javapoet)，由Jake Wharton大神所编写。JavaPoet可以用对象的方式来帮助我们生成类代码，也就是我们能只要把要生成的类文件包装成一个对象，JavaPoet便可以自动帮我们生成类文件了。关于这个库的使用就不详细在这里讲解了，有需要了解的可以到github查看，使用起来很简单。\n\n好了，步入正题，使用JavaPoet构建并自动生成ShapeFactory类的代码如下：\n```\npublic void generateCode(Elements elementUtils, Filer filer) throws IOException {\n        TypeElement superClassName = elementUtils.getTypeElement(qualifiedClassName);\n        String factoryClassName = superClassName.getSimpleName() + SUFFIX;\n        String qualifiedFactoryClassName = qualifiedClassName + SUFFIX;\n        PackageElement pkg = elementUtils.getPackageOf(superClassName);\n        String packageName = pkg.isUnnamed() ? null : pkg.getQualifiedName().toString();\n\n        MethodSpec.Builder method = MethodSpec.methodBuilder(\"create\")\n                .addModifiers(Modifier.PUBLIC)\n                .addParameter(String.class, \"id\")\n                .returns(TypeName.get(superClassName.asType()));\n        method.beginControlFlow(\"if (id == null)\")\n                .addStatement(\"throw new IllegalArgumentException($S)\", \"id is null!\")\n                .endControlFlow();\n\n        for (FactoryAnnotatedClass item : itemsMap.values()) {\n            method.beginControlFlow(\"if ($S.equals(id))\", item.getId())\n                    .addStatement(\"return new $L()\", item.getTypeElement().getQualifiedName().toString())\n                    .endControlFlow();\n        }\n\n        method.addStatement(\"throw new IllegalArgumentException($S + id)\", \"Unknown id = \");\n\n        TypeSpec typeSpec = TypeSpec\n                .classBuilder(factoryClassName)\n                .addModifiers(Modifier.PUBLIC)\n                .addMethod(method.build())\n                .build();\n\n        JavaFile.builder(packageName, typeSpec).build().writeTo(filer);\n    }\n```\n\n好了，现在项目已经可以帮我们自动来生成需要的Java文件啦。接下来验证一下，Build一下项目，切换到project模式下，在app-->build-->generated-->source-->apt-->debug-->(package)-->factory下面就可以看到ShapeFactory类，如下图：\n![](https://raw.githubusercontent.com/zhpanvip/Resource/master/image/1603.jfif)\n\n这个类并非是我们自己编写的，而是通过使用APT的一系列骚操作自动生成的。现在可以再添加一个形状类实现IShape并附加@Factory注解，再次编译后都自动会生成到ShapeFactory中！\n\n到此为止，本篇文章就告一段落了。相信看完本篇文章一定大有所获，因为掌握了APT技术之后，再去研究使用APT的第三方框架源码，一定会游刃有余，事半功倍。\n\n由于本篇文章结构比较复杂且代码也较多，项目的源码已经放在文章末尾，可作参考。\n\n[源码下载](https://github.com/zhpanvip/MAnnotation)\n\n**参考资料**\n\n[Java注解处理器](https://www.race604.com/annotation-processing/)\n\n[JDK文档AbstractProcessor](http://www.cjsdn.net/Doc/JDK60/javax/annotation/processing/AbstractProcessor.html)\n\n","slug":"17.Java编译时注解处理器","published":1,"updated":"2020-08-29T18:01:26.715Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckegm5nsm0018dwozgz0lan2h","content":"<p><strong>本文同步发布在<a href=\"https://juejin.im/post/5d603d026fb9a06afa3291b9\">掘金</a>,未经本人允许不得转载</strong></p>\n<p>上篇文章我们使用注解+反射实现了一个仿ButterKnife功能的示例。考虑到反射是在运行时完成的，多少会影响程序性能。因此，ButterKnife本身并非基于注解+反射来实现的，而是用APT技术在编译时处理的。APT什么呢？接下来一起来看。</p>\n<h2 id=\"一、APT简介\"><a href=\"#一、APT简介\" class=\"headerlink\" title=\"一、APT简介\"></a>一、APT简介</h2><p><strong>1.什么是APT？</strong><br>APT即为Annotation Processing Tool，它是javac的一个工具，中文意思为编译时注解处理器。APT可以用来在编译时扫描和处理注解。通过APT可以获取到注解和被注解对象的相关信息，在拿到这些信息后我们可以根据需求来自动的生成一些代码，省去了手动编写。注意，获取注解及生成代码都是在代码编译时候完成的，相比反射在运行时处理注解大大提高了程序性能。APT的核心是AbstractProcessor类，关于AbstractProcessor类后面会做详细说明。<br><strong>2.哪里用到了APT？</strong><br>APT技术被广泛的运用在Java框架中，包括Android项以及Java后台项目，除了上面我们提到的ButterKnife之外，像EventBus 、Dagger2以及阿里的ARouter路由框架等都运用到APT技术，因此要想了解以、探究这些第三方框架的实现原理，APT就是我们必须要掌握的。</p>\n<p><strong>3.如何在Android Studio中构建一个APT项目?</strong><br>APT项目需要由至少两个Java Library模块组成，不知道什么是Java Library？没关系，手把手来叫你如何创建一个Java Library。<br><img src=\"https://raw.githubusercontent.com/zhpanvip/Resource/master/image/1601.jfif\"></p>\n<p>首先，新建一个Android项目，然后File–&gt;New–&gt;New Module,打开如上图所示的面板，选择Java Library即可。刚才说到一个APT项目至少应该由两个Java Library模块。那么这两个模块分别是什么作用呢？<br>1.首先需要一个Annotation模块，这个用来存放自定义的注解。<br>2. 另外需要一个Compiler模块，这个模块依赖Annotation模块。<br>3.项目的App模块和其它的业务模块都需要依赖Annotation模块，同时需要通过annotationProcessor依赖Compiler模块。<br>app模块的gradle中依赖关系如下：</p>\n<pre><code class=\"hljs isbl\"><span class=\"hljs-variable\">implementation</span> <span class=\"hljs-function\"><span class=\"hljs-title\">project</span>(<span class=\"hljs-string\">&#x27;:annotation&#x27;</span>)</span>\n<span class=\"hljs-variable\">annotationProcessor</span> <span class=\"hljs-function\"><span class=\"hljs-title\">project</span>(<span class=\"hljs-string\">&#x27;:factory-compiler&#x27;</span>)</span></code></pre>\n<p>APT项目的模块的结构图如下所示：<br><img src=\"https://raw.githubusercontent.com/zhpanvip/Resource/master/image/1602.jfif\"></p>\n<blockquote>\n<p>为什么要强调上述两个模块一定要是Java Library？如果创建Android Library模块你会发现不能找到AbstractProcessor这个类，这是因为Android平台是基于OpenJDK的，而OpenJDK中不包含APT的相关代码。因此，在使用APT时，必须在Java Library中进行。</p>\n</blockquote>\n<h2 id=\"二、从一个例子开始认识APT\"><a href=\"#二、从一个例子开始认识APT\" class=\"headerlink\" title=\"二、从一个例子开始认识APT\"></a>二、从一个例子开始认识APT</h2><p>在学习Java基础的时候想必大家都写过简单工厂模式的例子，回想一下什么是简单工厂模式。接下来引入一个工厂模式的例子，首先定义一个形状的接口IShape，并为其添加 draw()方法：</p>\n<pre><code class=\"hljs routeros\">public<span class=\"hljs-built_in\"> interface </span>IShape &#123;\n\tvoid draw();\n&#125;</code></pre>\n<p>接下来定义几个形状实现IShape接口,并重写draw()方法：</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Rectangle</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">IShape</span> </span>&#123;\n\t<span class=\"hljs-meta\">@Override</span>\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">draw</span><span class=\"hljs-params\">()</span> </span>&#123;\n\t\tSystem.out.println(<span class=\"hljs-string\">&quot;Draw a Rectangle&quot;</span>);\n\t&#125;\n&#125;\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Triangle</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">IShape</span> </span>&#123;\n\t<span class=\"hljs-meta\">@Override</span>\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">draw</span><span class=\"hljs-params\">()</span> </span>&#123;\n\t\tSystem.out.println(<span class=\"hljs-string\">&quot;Draw a Triangle&quot;</span>);\n\t&#125;\n&#125;\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Circle</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">IShape</span> </span>&#123;  \n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">draw</span><span class=\"hljs-params\">()</span> </span>&#123;   \n        System.out.println(<span class=\"hljs-string\">&quot;Draw a circle&quot;</span>);\n    &#125;\n&#125;</code></pre>\n<p>接下来我们需要一个工厂类，这个类接收一个参数，根据我们传入的参数创建出对应的形状，代码如下：</p>\n<pre><code class=\"hljs haxe\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ShapeFactory</span> </span>&#123;\n  <span class=\"hljs-keyword\">public</span> Shape create(<span class=\"hljs-keyword\">String</span> id) &#123;\n    <span class=\"hljs-keyword\">if</span> (id == <span class=\"hljs-literal\">null</span>) &#123;\n      <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">IllegalArgumentException</span>(<span class=\"hljs-string\">&quot;id is null!&quot;</span>);\n    &#125;\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-string\">&quot;Circle&quot;</span>.equals(id)) &#123;\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">Circle</span>();\n    &#125;\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-string\">&quot;Rectangle&quot;</span>.equals(id)) &#123;\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">Rectangle</span>();\n    &#125;\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-string\">&quot;Triangle&quot;</span>.equals(id)) &#123;\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">Triangle</span>();\n    &#125;\n    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">IllegalArgumentException</span>(<span class=\"hljs-string\">&quot;Unknown id = &quot;</span> + id);\n  &#125;\n&#125;</code></pre>\n<p>以上就是一个简单工厂模式的示例代码，想必大家都能够理解。</p>\n<p>那么，现在问题来了，在项目开发过程中，我们随时可能会添加一个新的形状。此时就不得不修改工厂类来适配新添加的形状了。试想一下，每添加一个形状类都需要我们手动去更新Factory类，是不是影响了我们的开发效率？如果这个Factory类能够根据我们添加新的形状来同步更新Factory代码，岂不是就省了我们很多时间了吗？</p>\n<p>应该怎么做才能满足上述需求呢？在第一节中已经提到了使用APT可以帮助我们自动生成代码。那么这个工厂类是不是可以使用APT技术来自动生成呢？我们唯一要做的事情就是新添加的形状类上加上一个注解，注解处理器就会在编译时根据注解信息自动生成ShapeFactory类的代码了，美哉，美哉！理想很丰满，但是，现实很骨感。虽然已经明确了要做什么，但是想要注解处理器帮我们生成代码，却还有很长的路要走。不过，不当紧，接下来我们将一步步实现注解处理器并让其自动生成Factory类。</p>\n<h2 id=\"三、使用APT处理注解\"><a href=\"#三、使用APT处理注解\" class=\"headerlink\" title=\"三、使用APT处理注解\"></a>三、使用APT处理注解</h2><p><strong>1.定义Factory注解</strong><br>首先在annotation模块下添加一个Factory的注解，Factory注解的Target为ElementType，表示它可以注解类、接口或者枚举。Retention指定为RetentionPolicy.CLASS，表示该在字节码中有效。Factory注解添加两个成员，一个Class类型的type，用来表示注解的类的类型，相同的类型表示属于同一个工厂。令需一个String类型的id,用来表示注解的类的名称。Factory注解代码如下：</p>\n<pre><code class=\"hljs less\"><span class=\"hljs-variable\">@Target</span>(ElementType.TYPE)\n<span class=\"hljs-variable\">@Retention</span>(RetentionPolicy.CLASS)\npublic <span class=\"hljs-variable\">@interface</span> Factory &#123;\n\n    <span class=\"hljs-selector-tag\">Class</span> <span class=\"hljs-selector-tag\">type</span>();\n\n    <span class=\"hljs-selector-tag\">String</span> <span class=\"hljs-selector-tag\">id</span>();\n&#125;</code></pre>\n<p>接下来我们用@Factory去注解形状类，如下：</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-meta\">@Factory(id = &quot;Rectangle&quot;, type = IShape.class)</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Rectangle</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">IShape</span> </span>&#123;\n\t<span class=\"hljs-meta\">@Override</span>\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">draw</span><span class=\"hljs-params\">()</span> </span>&#123;\n\t\tSystem.out.println(<span class=\"hljs-string\">&quot;Draw a Rectangle&quot;</span>);\n\t&#125;\n&#125;\n... 其他形状类代码类似不再贴出</code></pre>\n\n<p>**2.认识AbstractProcessor **</p>\n<p>接下来，就到了我们本篇文章所要讲的核心了。没错，就是AbstractProcessor！我们先在factory-compiler模块下创建一个FactoryProcessor类继承AbstractProcessor ，并重写相应的方法，代码如下：</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-meta\">@AutoService(Processor.class)</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">FactoryProcessor</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">AbstractProcessor</span> </span>&#123;\n \t <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">synchronized</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">init</span><span class=\"hljs-params\">(ProcessingEnvironment processingEnvironment)</span> </span>&#123;\n        <span class=\"hljs-keyword\">super</span>.init(processingEnvironment);\n    &#125;\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> Set&lt;String&gt; <span class=\"hljs-title\">getSupportedAnnotationTypes</span><span class=\"hljs-params\">()</span> </span>&#123;\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">super</span>.getSupportedAnnotationTypes();\n    &#125;\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">process</span><span class=\"hljs-params\">(Set&lt;? extends TypeElement&gt; set, RoundEnvironment roundEnvironment)</span> </span>&#123;\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>;\n    &#125;\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> SourceVersion <span class=\"hljs-title\">getSupportedSourceVersion</span><span class=\"hljs-params\">()</span> </span>&#123;\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">super</span>.getSupportedSourceVersion();\n    &#125;\n&#125;</code></pre>\n<p>可以看到，在这个类上添加了@AutoService注解，它的作用是用来生成META-INF/services/javax.annotation.processing.Processor文件的，也就是我们在使用注解处理器的时候需要手动添加META-INF/services/javax.annotation.processing.Processor，而有了@AutoService后它会自动帮我们生成。<a href=\"https://github.com/google/auto/tree/master/service\">AutoService</a>是Google开发的一个库，使用时需要在factory-compiler中添加依赖，如下：</p>\n<pre><code class=\"hljs apache\"><span class=\"hljs-attribute\">implementation</span> &#x27;com.google.auto.service:auto-service:<span class=\"hljs-number\">1</span>.<span class=\"hljs-number\">0</span>-rc<span class=\"hljs-number\">4</span>&#x27;</code></pre>\n\n<p>接下来我们将目光移到FactoryProcessor类内部，可以看到在这个类中重写了四个方法，我们由易到难依次来看：<br>**<em>(1) public SourceVersion getSupportedSourceVersion()**</em><br>这个方法非常简单，只有一个返回值，用来指定当前正在使用的Java版本，通常return SourceVersion.latestSupported()即可。</p>\n<p> <strong><em>(2) public Set&lt;String&gt; getSupportedAnnotationTypes()</em></strong><br> 这个方法的返回值是一个Set集合，集合中指要处理的注解类型的名称(这里必须是完整的包名+类名，例如com.example.annotation.Factory)。由于在本例中只需要处理@Factory注解，因此Set集合中只需要添加@Factory的名称即可。</p>\n<p> <strong><em>(3) public synchronized void init(ProcessingEnvironment processingEnvironment)</em></strong><br>这个方法用于初始化处理器，方法中有一个ProcessingEnvironment类型的参数，ProcessingEnvironment是一个注解处理工具的集合。它包含了众多工具类。例如：<br>Filer可以用来编写新文件；<br>Messager可以用来打印错误信息；<br>Elements是一个可以处理Element的工具类。</p>\n<p><strong><em>在这里我们有必要认识一下什么是Element</em></strong><br>在Java语言中，Element是一个接口，表示一个程序元素，它可以指代包、类、方法或者一个变量。Element已知的子接口有如下几种：</p>\n<blockquote>\n<p>PackageElement  表示一个包程序元素。提供对有关包及其成员的信息的访问。<br>ExecutableElement  表示某个类或接口的方法、构造方法或初始化程序（静态或实例），包括注释类型元素。<br>TypeElement  表示一个类或接口程序元素。提供对有关类型及其成员的信息的访问。注意，枚举类型是一种类，而注解类型是一种接口。<br>VariableElement  表示一个字段、enum 常量、方法或构造方法参数、局部变量或异常参数。</p>\n</blockquote>\n<p>接下来，我希望大家先来理解一个新的概念，<strong>即抛弃我们现有对Java类的理解，把Java类看作是一个结构化的文件</strong>。什么意思？就是把Java类看作一个类似XML或者JSON一样的东西。有了这个概念之后我们就可以很容易的理解什么是Element了。带着这个概念来看下面的代码：</p>\n<pre><code class=\"hljs arduino\">package com.zhpan.mannotation.factory;  <span class=\"hljs-comment\">//    PackageElement</span>\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Circle</span> &#123;</span>  <span class=\"hljs-comment\">//  TypeElement</span>\n\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">int</span> i; <span class=\"hljs-comment\">//   VariableElement</span>\n    <span class=\"hljs-keyword\">private</span> Triangle triangle;  <span class=\"hljs-comment\">//  VariableElement</span>\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">Circle</span><span class=\"hljs-params\">()</span> </span>&#123;&#125; <span class=\"hljs-comment\">//    ExecuteableElement</span>\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">draw</span><span class=\"hljs-params\">(   <span class=\"hljs-comment\">//  ExecuteableElement</span></span></span>\n<span class=\"hljs-function\"><span class=\"hljs-params\">                        <span class=\"hljs-keyword\">String</span> s)</span>   <span class=\"hljs-comment\">//  VariableElement</span></span>\n<span class=\"hljs-function\">    </span>&#123;\n        System.out.<span class=\"hljs-built_in\">println</span>(s);\n    &#125;\n\n    @Override\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">draw</span><span class=\"hljs-params\">()</span> </span>&#123;    <span class=\"hljs-comment\">//  ExecuteableElement</span>\n        System.out.<span class=\"hljs-built_in\">println</span>(<span class=\"hljs-string\">&quot;Draw a circle&quot;</span>);\n    &#125;\n&#125;</code></pre>\n<p>现在明白了吗？不同类型Element其实就是映射了Java中不同的类元素！知晓这个概念后将对理解后边的代码有很大的帮助。</p>\n<p> <strong><em>(4) public boolean process(Set&lt;? extends TypeElement&gt; set, RoundEnvironment roundEnvironment)</em></strong><br> 终于，到了FactoryProcessor类中最后一个也是最重要的一个方法了。先看这个方法的返回值，是一个boolean类型，返回值表示注解是否由当前Processor 处理。如果返回 true，则这些注解由此注解来处理，后续其它的 Processor 无需再处理它们；如果返回 false，则这些注解未在此Processor中处理并，那么后续 Processor 可以继续处理它们。<br> 在这个方法的方法体中，我们可以校验被注解的对象是否合法、可以编写处理注解的代码，以及自动生成需要的java文件等。因此说这个方法是AbstractProcessor 中的最重要的一个方法。我们要处理的大部分逻辑都是在这个方法中完成。</p>\n<p>了解上述四个方法之后我们便可以初步的来编写FactoryProcessor类的代码了，如下：</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-meta\">@AutoService(Processor.class)</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">FactoryProcessor</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">AbstractProcessor</span> </span>&#123;\n        <span class=\"hljs-keyword\">private</span> Types mTypeUtils;\n\t    <span class=\"hljs-keyword\">private</span> Messager mMessager;\n\t    <span class=\"hljs-keyword\">private</span> Filer mFiler;\n\t    <span class=\"hljs-keyword\">private</span> Elements mElementUtils;\n\t    <span class=\"hljs-keyword\">private</span> Map&lt;String, FactoryGroupedClasses&gt; factoryClasses = <span class=\"hljs-keyword\">new</span> LinkedHashMap&lt;&gt;();\n\n \t <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">synchronized</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">init</span><span class=\"hljs-params\">(ProcessingEnvironment processingEnvironment)</span> </span>&#123;\n        <span class=\"hljs-keyword\">super</span>.init(processingEnvironment);\n \n\t\tmTypeUtils = processingEnvironment.getTypeUtils();\n        mMessager = processingEnvironment.getMessager();\n        mFiler = processingEnvironment.getFiler();\n        mElementUtils = processingEnvironment.getElementUtils();\n    &#125;\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> Set&lt;String&gt; <span class=\"hljs-title\">getSupportedAnnotationTypes</span><span class=\"hljs-params\">()</span> </span>&#123;\n        Set&lt;String&gt; annotations = <span class=\"hljs-keyword\">new</span> LinkedHashSet&lt;&gt;();\n        annotations.add(Factory.class.getCanonicalName());\n        <span class=\"hljs-keyword\">return</span> annotations;\n    &#125;\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">process</span><span class=\"hljs-params\">(Set&lt;? extends TypeElement&gt; set, RoundEnvironment roundEnvironment)</span> </span>&#123;\n\n\t\t   <span class=\"hljs-comment\">//\t扫描所有被@Factory注解的元素</span>\n\t   <span class=\"hljs-keyword\">for</span> (Element annotatedElement : roundEnv.getElementsAnnotatedWith(Factory.class)) &#123;\n\n\t\t&#125;\n\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>;\n    &#125;\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> SourceVersion <span class=\"hljs-title\">getSupportedSourceVersion</span><span class=\"hljs-params\">()</span> </span>&#123;\n        <span class=\"hljs-keyword\">return</span> SourceVersion.latestSupported();\n    &#125;\n&#125;</code></pre>\n\n<p>上述FactoryProcessor 代码中在process方法中通过roundEnv.getElementsAnnotatedWith(Factory.class)方法已经拿到了被注解的元素的集合。正常情况下，这个集合中应该包含的是所有被Factory注解的Shape类的元素，也就是一个TypeElement。但在编写程序代码时可能有新来的同事不太了解@Factory的用途而误把@Factory用在接口或者抽象类上，这是不符合我们的标准的。因此，需要在process方法中判断被@Factory注解的元素是否是一个类，如果不是一个类元素，那么就抛出异常，终止编译。代码如下：</p>\n<pre><code class=\"hljs php\">@Override\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">boolean</span> process(Set<span class=\"hljs-meta\">&lt;?</span> <span class=\"hljs-keyword\">extends</span> TypeElement&gt; annotations, RoundEnvironment roundEnv) &#123;\n\t <span class=\"hljs-comment\">//  通过RoundEnvironment获取到所有被@Factory注解的对象</span>\n    <span class=\"hljs-keyword\">for</span> (Element annotatedElement : roundEnv.getElementsAnnotatedWith(Factory.<span class=\"hljs-keyword\">class</span>)) &#123;\n\t\t<span class=\"hljs-keyword\">if</span> (annotatedElement.getKind() != ElementKind.<span class=\"hljs-keyword\">CLASS</span>) &#123;\n\t\t\t <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> ProcessingException(annotatedElement, <span class=\"hljs-string\">&quot;Only classes can be annotated with @%s&quot;</span>,\n                    Factory.<span class=\"hljs-keyword\">class</span>.getSimpleName());\n\t         &#125;\n\t         TypeElement typeElement = (TypeElement) annotatedElement;\n\t         FactoryAnnotatedClass annotatedClass = <span class=\"hljs-keyword\">new</span> FactoryAnnotatedClass(typeElement);\n\t\t\t\t...\n        &#125;\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\n&#125;</code></pre>\n<p>基于面向对象的思想，我们可以将annotatedElement中包含的信息封装成一个对象，方便后续使用，因此，另外可以另外声明一个FactoryAnnotatedClass来解析并存放annotatedElement的相关信息。FactoryAnnotatedClass代码如下：</p>\n<pre><code class=\"hljs arduino\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">FactoryAnnotatedClass</span> &#123;</span>\n    <span class=\"hljs-keyword\">private</span> TypeElement mAnnotatedClassElement;\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">String</span> mQualifiedSuperClassName;\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">String</span> mSimpleTypeName;\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">String</span> mId;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">FactoryAnnotatedClass</span><span class=\"hljs-params\">(TypeElement classElement)</span> </span>&#123;\n        <span class=\"hljs-keyword\">this</span>.mAnnotatedClassElement = classElement;\n        Factory annotation = classElement.getAnnotation(Factory.class);\n        mId = annotation.id();\n        <span class=\"hljs-keyword\">if</span> (mId.length() == <span class=\"hljs-number\">0</span>) &#123;\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> IllegalArgumentException(\n                    <span class=\"hljs-keyword\">String</span>.format(<span class=\"hljs-string\">&quot;id() in @%s for class %s is null or empty! that&#x27;s not allowed&quot;</span>,\n                            Factory.class.getSimpleName(), classElement.getQualifiedName().toString()));\n        &#125;\n        \n        <span class=\"hljs-comment\">// Get the full QualifiedTypeName</span>\n        <span class=\"hljs-keyword\">try</span> &#123;  <span class=\"hljs-comment\">// 该类已经被编译</span>\n            Class&lt;?&gt; clazz = annotation.type();\n            mQualifiedSuperClassName = clazz.getCanonicalName();\n            mSimpleTypeName = clazz.getSimpleName();\n        &#125; <span class=\"hljs-keyword\">catch</span> (MirroredTypeException mte) &#123;<span class=\"hljs-comment\">// 该类未被编译</span>\n            DeclaredType classTypeMirror = (DeclaredType) mte.getTypeMirror();\n            TypeElement classTypeElement = (TypeElement) classTypeMirror.asElement();\n            mQualifiedSuperClassName = classTypeElement.getQualifiedName().toString();\n            mSimpleTypeName = classTypeElement.getSimpleName().toString();\n        &#125;\n    &#125;\n\n    <span class=\"hljs-comment\">// ...省去getter</span>\n&#125;</code></pre>\n<p>为了生成合乎要求的ShapeFactory类，在生成ShapeFactory代码前需要对被Factory注解的元素进行一系列的校验，只有通过校验，符合要求了才可以生成ShapeFactory代码。根据需求，我们列出如下规则：</p>\n<blockquote>\n<p>1.只有类才能被@Factory注解。因为在ShapeFactory中我们需要实例化Shape对象，虽然@Factory注解声明了Target为ElementType.TYPE，但接口和枚举并不符合我们的要求。<br>2.被@Factory注解的类中需要有public的构造方法，这样才能实例化对象。<br>3.被注解的类必须是type指定的类的子类<br>4.id需要为String类型，并且需要在相同type组中唯一<br>5.具有相同type的注解类会被生成在同一个工厂类中</p>\n</blockquote>\n<p>根据上面的规则，我们来一步步完成校验，如下代码：</p>\n<pre><code class=\"hljs gradle\">\n<span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> checkValidClass(FactoryAnnotatedClass item) <span class=\"hljs-keyword\">throws</span> ProcessingException &#123;\n\n        TypeElement classElement = item.getTypeElement();\n\n        <span class=\"hljs-keyword\">if</span> (!classElement.getModifiers().contains(Modifier.<span class=\"hljs-keyword\">PUBLIC</span>)) &#123;\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> ProcessingException(classElement, <span class=\"hljs-string\">&quot;The class %s is not public.&quot;</span>,\n                    classElement.getQualifiedName().toString());\n        &#125;\n\n        <span class=\"hljs-comment\">// 如果是抽象方法则抛出异常终止编译</span>\n        <span class=\"hljs-keyword\">if</span> (classElement.getModifiers().contains(Modifier.<span class=\"hljs-keyword\">ABSTRACT</span>)) &#123;\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> ProcessingException(classElement,\n                    <span class=\"hljs-string\">&quot;The class %s is abstract. You can&#x27;t annotate abstract classes with @%&quot;</span>,\n                    classElement.getQualifiedName().toString(), Factory.<span class=\"hljs-keyword\">class</span>.getSimpleName());\n        &#125;\n\n        <span class=\"hljs-comment\">// 这个类必须是在@Factory.type()中指定的类的子类，否则抛出异常终止编译</span>\n        TypeElement superClassElement = mElementUtils.getTypeElement(item.getQualifiedFactoryGroupName());\n        <span class=\"hljs-keyword\">if</span> (superClassElement.getKind() == ElementKind.<span class=\"hljs-keyword\">INTERFACE</span>) &#123;\n            <span class=\"hljs-comment\">// 检查被注解类是否实现或继承了@Factory.type()所指定的类型，此处均为IShape</span>\n            <span class=\"hljs-keyword\">if</span> (!classElement.getInterfaces().contains(superClassElement.asType())) &#123;\n                <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> ProcessingException(classElement,\n                        <span class=\"hljs-string\">&quot;The class %s annotated with @%s must implement the interface %s&quot;</span>,\n                        classElement.getQualifiedName().toString(), Factory.<span class=\"hljs-keyword\">class</span>.getSimpleName(),\n                        item.getQualifiedFactoryGroupName());\n            &#125;\n        &#125; <span class=\"hljs-keyword\">else</span> &#123;\n            TypeElement currentClass = classElement;\n            <span class=\"hljs-keyword\">while</span> (<span class=\"hljs-keyword\">true</span>) &#123;\n                TypeMirror superClassType = currentClass.getSuperclass();\n\n                <span class=\"hljs-keyword\">if</span> (superClassType.getKind() == TypeKind.NONE) &#123;\n                    <span class=\"hljs-comment\">// 向上遍历父类，直到Object也没获取到所需父类，终止编译抛出异常</span>\n                    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> ProcessingException(classElement,\n                            <span class=\"hljs-string\">&quot;The class %s annotated with @%s must inherit from %s&quot;</span>,\n                            classElement.getQualifiedName().toString(), Factory.<span class=\"hljs-keyword\">class</span>.getSimpleName(),\n                            item.getQualifiedFactoryGroupName());\n                &#125;\n\n                <span class=\"hljs-keyword\">if</span> (superClassType.toString().equals(item.getQualifiedFactoryGroupName())) &#123;\n                    <span class=\"hljs-comment\">// 校验通过，终止遍历</span>\n                    <span class=\"hljs-keyword\">break</span>;\n                &#125;\n                currentClass = (TypeElement) mTypeUtils.asElement(superClassType);\n            &#125;\n        &#125;\n\n        <span class=\"hljs-comment\">// 检查是否由public的无参构造方法</span>\n        <span class=\"hljs-keyword\">for</span> (Element enclosed : classElement.getEnclosedElements()) &#123;\n            <span class=\"hljs-keyword\">if</span> (enclosed.getKind() == ElementKind.CONSTRUCTOR) &#123;\n                ExecutableElement constructorElement = (ExecutableElement) enclosed;\n                <span class=\"hljs-keyword\">if</span> (constructorElement.getParameters().<span class=\"hljs-keyword\">size</span>() == <span class=\"hljs-number\">0</span> &amp;&amp;\n                        constructorElement.getModifiers().contains(Modifier.<span class=\"hljs-keyword\">PUBLIC</span>)) &#123;\n                    <span class=\"hljs-comment\">// 存在public的无参构造方法，检查结束</span>\n                    <span class=\"hljs-keyword\">return</span>;\n                &#125;\n            &#125;\n        &#125;\n\n        <span class=\"hljs-comment\">// 为检测到public的无参构造方法，抛出异常，终止编译</span>\n        <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> ProcessingException(classElement,\n                <span class=\"hljs-string\">&quot;The class %s must provide an public empty default constructor&quot;</span>,\n                classElement.getQualifiedName().toString());\n    &#125;</code></pre>\n<p>如果通过上述校验，那么说明被@Factory注解的类是符合我们的要求的，接下来就可以处理注解信息来生成所需代码了。但是本着面向对象的思想，我们还需声明FactoryGroupedClasses来存放FactoryAnnotatedClass，并且在这个类中完成了ShapeFactory类的代码生成。FactoryGroupedClasses 代码如下：</p>\n<pre><code class=\"hljs arduino\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">FactoryGroupedClasses</span> &#123;</span>\n\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">String</span> SUFFIX = <span class=\"hljs-string\">&quot;Factory&quot;</span>;\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">String</span> qualifiedClassName;\n\n    <span class=\"hljs-keyword\">private</span> Map&lt;<span class=\"hljs-keyword\">String</span>, FactoryAnnotatedClass&gt; itemsMap = <span class=\"hljs-keyword\">new</span> LinkedHashMap&lt;&gt;();\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">FactoryGroupedClasses</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">String</span> qualifiedClassName)</span> </span>&#123;\n        <span class=\"hljs-keyword\">this</span>.qualifiedClassName = qualifiedClassName;\n    &#125;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">add</span><span class=\"hljs-params\">(FactoryAnnotatedClass toInsert)</span> </span>&#123;\n        FactoryAnnotatedClass factoryAnnotatedClass = itemsMap.<span class=\"hljs-built_in\">get</span>(toInsert.getId());\n        <span class=\"hljs-keyword\">if</span> (factoryAnnotatedClass != null) &#123;\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> IdAlreadyUsedException(factoryAnnotatedClass);\n        &#125;\n        itemsMap.<span class=\"hljs-built_in\">put</span>(toInsert.getId(), toInsert);\n    &#125;\n\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">generateCode</span><span class=\"hljs-params\">(Elements elementUtils, Filer filer)</span> throws IOException </span>&#123;\n        <span class=\"hljs-comment\">//  Generate java file</span>\n        ...\n    &#125;\n&#125;</code></pre>\n<p>接下来将所有的FactoryGroupedClasses都添加到集合中去</p>\n<pre><code class=\"hljs haxe\">  <span class=\"hljs-keyword\">private</span> Map&lt;<span class=\"hljs-keyword\">String</span>, FactoryGroupedClasses&gt; factoryClasses = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">LinkedHashMap</span>&lt;&gt;();\n\n<span class=\"hljs-comment\">// \t...</span>\nFactoryGroupedClasses factoryClass = factoryClasses.<span class=\"hljs-keyword\">get</span>(annotatedClass.getQualifiedFactoryGroupName());\n   <span class=\"hljs-keyword\">if</span> (factoryClass == <span class=\"hljs-literal\">null</span>) &#123;\n           <span class=\"hljs-keyword\">String</span> qualifiedGroupName = annotatedClass.getQualifiedFactoryGroupName();\n           factoryClass = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">FactoryGroupedClasses</span>(qualifiedGroupName);\n           factoryClasses.put(qualifiedGroupName, factoryClass);\n     &#125;\nfactoryClass.add(annotatedClass);\n<span class=\"hljs-comment\">// ...</span></code></pre>\n<p>OK!到目前为止，所有的准备工作都已经完成了。接下来就是根据注解信息来生成ShapeFactory类了，有没有很兴奋？遍历factoryClasses集合,并调用FactoryGroupedClasses类的generateCode()方法来生成代码了：</p>\n<pre><code class=\"hljs less\"><span class=\"hljs-selector-tag\">for</span> (FactoryGroupedClasses <span class=\"hljs-attribute\">factoryClass </span>: factoryClasses.values()) &#123;\n          <span class=\"hljs-selector-tag\">factoryClass</span><span class=\"hljs-selector-class\">.generateCode</span>(mElementUtils, mFiler);\n     &#125;</code></pre>\n<p>可是，当我们去掉用generateCode(mElementUtils, mFiler)方法的时候…..纳尼？还是一个空方法，我们还没由实现呢！笑哭?…</p>\n<h2 id=\"四、认识JavaPoet并用其生成ShapeFactory类\"><a href=\"#四、认识JavaPoet并用其生成ShapeFactory类\" class=\"headerlink\" title=\"四、认识JavaPoet并用其生成ShapeFactory类\"></a>四、认识JavaPoet并用其生成ShapeFactory类</h2><p>到此为止，我们唯一剩余的需求就是生成ShapeFactory类了。上一节中我们在FactoryProcessor类的init(ProcessingEnvironment processingEnvironment)方法中通过processingEnvironment拿到了Filer，并且我们也提到通过Filer可以用来编写文件，即可以通过Filer来生成我们所需要的ShapeFactory类。但是，直接使用Filer需要我们手动拼接类的代码，很可能一不小心写错了一个字母就致使所生成的类是无效的。因此，我们需要来认识一下<a href=\"https://github.com/square/javapoet\">JavaPoet</a>这个库。 JavaPoet是square公司的一个开源框架<a href=\"https://github.com/square/javapoet\">JavaPoet</a>，由Jake Wharton大神所编写。JavaPoet可以用对象的方式来帮助我们生成类代码，也就是我们能只要把要生成的类文件包装成一个对象，JavaPoet便可以自动帮我们生成类文件了。关于这个库的使用就不详细在这里讲解了，有需要了解的可以到github查看，使用起来很简单。</p>\n<p>好了，步入正题，使用JavaPoet构建并自动生成ShapeFactory类的代码如下：</p>\n<pre><code class=\"hljs reasonml\">public void generate<span class=\"hljs-constructor\">Code(Elements <span class=\"hljs-params\">elementUtils</span>, Filer <span class=\"hljs-params\">filer</span>)</span> throws IOException &#123;\n        TypeElement superClassName = elementUtils.get<span class=\"hljs-constructor\">TypeElement(<span class=\"hljs-params\">qualifiedClassName</span>)</span>;\n        String factoryClassName = superClassName.get<span class=\"hljs-constructor\">SimpleName()</span> + SUFFIX;\n        String qualifiedFactoryClassName = qualifiedClassName + SUFFIX;\n        PackageElement pkg = elementUtils.get<span class=\"hljs-constructor\">PackageOf(<span class=\"hljs-params\">superClassName</span>)</span>;\n        String packageName = pkg.is<span class=\"hljs-constructor\">Unnamed()</span> ? null : pkg.get<span class=\"hljs-constructor\">QualifiedName()</span>.<span class=\"hljs-keyword\">to</span><span class=\"hljs-constructor\">String()</span>;\n\n        MethodSpec.Builder <span class=\"hljs-keyword\">method</span> = <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">MethodSpec</span>.</span></span><span class=\"hljs-keyword\">method</span><span class=\"hljs-constructor\">Builder(<span class=\"hljs-string\">&quot;create&quot;</span>)</span>\n                .add<span class=\"hljs-constructor\">Modifiers(Modifier.PUBLIC)</span>\n                .add<span class=\"hljs-constructor\">Parameter(String.<span class=\"hljs-params\">class</span>, <span class=\"hljs-string\">&quot;id&quot;</span>)</span>\n                .returns(<span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">TypeName</span>.</span></span>get(superClassName.<span class=\"hljs-keyword\">as</span><span class=\"hljs-constructor\">Type()</span>));\n        <span class=\"hljs-keyword\">method</span>.<span class=\"hljs-keyword\">begin</span><span class=\"hljs-constructor\">ControlFlow(<span class=\"hljs-string\">&quot;if (id == null)&quot;</span>)</span>\n                .add<span class=\"hljs-constructor\">Statement(<span class=\"hljs-string\">&quot;throw new IllegalArgumentException($S)&quot;</span>, <span class=\"hljs-string\">&quot;id is null!&quot;</span>)</span>\n                .<span class=\"hljs-keyword\">end</span><span class=\"hljs-constructor\">ControlFlow()</span>;\n\n        <span class=\"hljs-keyword\">for</span> (FactoryAnnotatedClass item : itemsMap.values<span class=\"hljs-literal\">()</span>) &#123;\n            <span class=\"hljs-keyword\">method</span>.<span class=\"hljs-keyword\">begin</span><span class=\"hljs-constructor\">ControlFlow(<span class=\"hljs-string\">&quot;if ($S.equals(id))&quot;</span>, <span class=\"hljs-params\">item</span>.<span class=\"hljs-params\">getId</span>()</span>)\n                    .add<span class=\"hljs-constructor\">Statement(<span class=\"hljs-string\">&quot;return new $L()&quot;</span>, <span class=\"hljs-params\">item</span>.<span class=\"hljs-params\">getTypeElement</span>()</span>.get<span class=\"hljs-constructor\">QualifiedName()</span>.<span class=\"hljs-keyword\">to</span><span class=\"hljs-constructor\">String()</span>)\n                    .<span class=\"hljs-keyword\">end</span><span class=\"hljs-constructor\">ControlFlow()</span>;\n        &#125;\n\n        <span class=\"hljs-keyword\">method</span>.add<span class=\"hljs-constructor\">Statement(<span class=\"hljs-string\">&quot;throw new IllegalArgumentException($S + id)&quot;</span>, <span class=\"hljs-string\">&quot;Unknown id = &quot;</span>)</span>;\n\n        TypeSpec typeSpec = TypeSpec\n                .<span class=\"hljs-keyword\">class</span><span class=\"hljs-constructor\">Builder(<span class=\"hljs-params\">factoryClassName</span>)</span>\n                .add<span class=\"hljs-constructor\">Modifiers(Modifier.PUBLIC)</span>\n                .add<span class=\"hljs-constructor\">Method(<span class=\"hljs-params\">method</span>.<span class=\"hljs-params\">build</span>()</span>)\n                .build<span class=\"hljs-literal\">()</span>;\n\n        <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">JavaFile</span>.</span></span>builder(packageName, typeSpec).build<span class=\"hljs-literal\">()</span>.write<span class=\"hljs-constructor\">To(<span class=\"hljs-params\">filer</span>)</span>;\n    &#125;</code></pre>\n\n<p>好了，现在项目已经可以帮我们自动来生成需要的Java文件啦。接下来验证一下，Build一下项目，切换到project模式下，在app–&gt;build–&gt;generated–&gt;source–&gt;apt–&gt;debug–&gt;(package)–&gt;factory下面就可以看到ShapeFactory类，如下图：<br><img src=\"https://raw.githubusercontent.com/zhpanvip/Resource/master/image/1603.jfif\"></p>\n<p>这个类并非是我们自己编写的，而是通过使用APT的一系列骚操作自动生成的。现在可以再添加一个形状类实现IShape并附加@Factory注解，再次编译后都自动会生成到ShapeFactory中！</p>\n<p>到此为止，本篇文章就告一段落了。相信看完本篇文章一定大有所获，因为掌握了APT技术之后，再去研究使用APT的第三方框架源码，一定会游刃有余，事半功倍。</p>\n<p>由于本篇文章结构比较复杂且代码也较多，项目的源码已经放在文章末尾，可作参考。</p>\n<p><a href=\"https://github.com/zhpanvip/MAnnotation\">源码下载</a></p>\n<p><strong>参考资料</strong></p>\n<p><a href=\"https://www.race604.com/annotation-processing/\">Java注解处理器</a></p>\n<p><a href=\"http://www.cjsdn.net/Doc/JDK60/javax/annotation/processing/AbstractProcessor.html\">JDK文档AbstractProcessor</a></p>\n","site":{"data":{"fluid_config":{"favicon":"/img/favicon.png","apple_touch_icon":"/img/favicon.png","title_join_string":" - ","force_https":false,"highlight":{"enable":true,"style":"Github Gist","bg_color":false,"copy_btn":true},"fun_features":{"typing":{"enable":true,"typeSpeed":70,"cursorChar":"|","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"mouse_click":{"enable":false,"style":"values"}},"dark_mode":{"enable":true,"default":"auto"},"color":{"body_bg_color":"#eee","body_bg_color_dark":"#181c27","navbar_bg_color":"#2f4154","navbar_bg_color_dark":"#1f3144","navbar_text_color":"#fff","navbar_text_color_dark":"#d0d0d0","text_color":"#3c4858","text_color_dark":"#c4c6c9","sec_text_color":"#718096","sec_text_color_dark":"#a7a9ad","post_text_color":"#2c3e50","post_text_color_dark":"#c4c6c9","post_heading_color":"#1a202c","post_heading_color_dark":"#c4c6c9","post_link_color":"#0366d6","post_link_color_dark":"#1589e9","link_hover_color":"#30a9de","link_hover_color_dark":"#30a9de","link_hover_bg_color":"#f8f9fa","link_hover_bg_color_dark":"#364151","board_color":"#fff","board_color_dark":"#252d38"},"font":{"font_size":"16px","font_family":null,"code_font_size":"85%"},"custom_js":null,"custom_css":null,"custom_html":"","web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"tajs":null,"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}},"lazyload":{"enable":true,"onlypost":false},"daovoice":{"enable":false,"appid":""},"aplayer":{"enable":false,"autoplay":false,"loop":"all","order":"random","theme":"#b7daff","songs":[{"name":"name","artist":"artist","url":"/songs/test.mp3","cover":"/img/cover.jpg"},{"name":"name","artist":"artist","url":"https://...url.mp3","cover":"https://...cover.jpg"}]},"version":{"check":false},"navbar":{"blog_title":"zhangpan","ground_glass":{"enable":false,"px":3,"alpha":0.7},"menu":[{"key":"home","link":"/","icon":"iconfont icon-home-fill"},{"key":"archive","link":"/archives/","icon":"iconfont icon-archive-fill"},{"key":"category","link":"/categories/","icon":"iconfont icon-category-fill"},{"key":"tag","link":"/tags/","icon":"iconfont icon-tags-fill"},{"key":"about","link":"/about/","icon":"iconfont icon-user-fill"}]},"search":{"enable":true,"path":"/local-search.xml","generate_path":"/local-search.xml","field":"post","content":true},"scroll_down_arrow":{"enable":true,"banner_height_limit":90,"scroll_after_turning_page":true},"banner_parallax":true,"footer":{"statistics":{"enable":false,"source":"busuanzi","pv_format":"总访问量 {} 次","uv_format":"总访客数 {} 人"},"beian":{"enable":false,"icp_text":"京ICP证123456号","police_text":"京公网安备12345678号","police_code":12345678,"police_icon":"/img/police_beian.png"}},"scroll_top_arrow":{"enable":true},"index":{"banner_img":"/img/default.png","banner_img_height":100,"banner_mask_alpha":0.3,"post_default_img":"","slogan":{"enable":true,"text":"Talk is cheap, show me the code."},"auto_excerpt":{"enable":true},"post_url_target":"_self","post_meta":{"date":true,"category":true,"tag":true}},"page":{"banner_img":"/img/default.png","banner_img_height":60,"banner_mask_alpha":0.3},"post":{"banner_img":"/img/default.png","banner_img_height":70,"banner_mask_alpha":0.3,"meta":{"date":{"enable":true,"format":"LL a"},"wordcount":{"enable":true,"format":"{} 字"},"min2read":{"enable":true,"format":"{} 分钟","words":100},"views":{"enable":false,"source":"busuanzi","format":"{} 次"}},"updated":{"enable":false,"content":"本文最后更新于：","relative":false},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"copyright":{"enable":true,"content":"本博客所有文章除特别声明外，均采用 <a href=\"https://creativecommons.org/licenses/by-sa/4.0/deed.zh\" rel=\"nofollow noopener\">CC BY-SA 4.0 协议</a> ，转载请注明出处！ <h5>开源库推荐</h5> <a href=\"https://github.com/zhpanvip/BannerViewPager\">1.BannerViewPager</a> <p> 一个基于ViewPager2实现的具有强大功能的无限轮播库。支持多种页面切换效果和指示器样式。 </p>\n<a href=\"https://github.com/zhpanvip/viewpagerindicator\">2.ViewPagerIndicator</a> <p> 一个适用于ViewPager和ViewPager2的指示器，支持多种滑块样式及滑动模式 </p>"},"prev_next":{"enable":true},"custom":{"enable":false,"content":"<img src=\"https://octodex.github.com/images/jetpacktocat.png\" class=\"rounded mx-auto d-block mt-5\" style=\"width:150px; height:150px;\">"},"image_zoom":{"enable":true},"footnote":{"enable":true,"header":""},"math":{"enable":false,"specific":false,"engine":"mathjax"},"mermaid":{"enable":false,"specific":false,"options":{"theme":"default"}},"comments":{"enable":true,"type":"utterances"}},"utterances":{"repo":"zhpanvip/utterances-comment","issue_term":"pathname","label":"utterances","theme":"github-light","crossorigin":"anonymous"},"disqus":{"shortname":null,"disqusjs":false,"apikey":null},"gitalk":{"clientID":null,"clientSecret":null,"repo":null,"owner":null,"admin":["name"],"id":"location.pathname","language":"zh-CN","labels":["Gitalk"],"perPage":10,"pagerDirection":"last","distractionFreeMode":false,"createIssueManually":true},"valine":{"appid":"hXIROaIM5y9qnieojJRWP5hS","appkey":"y0f3w3aqd1MF7JL9ma4WECTy","placeholder":"说点什么","path":"window.location.pathname","avatar":"retro","meta":["nick","mail","link"],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"https://zhangpan.site"},"changyan":{"appid":"","appkey":""},"livere":{"uid":""},"archive":{"banner_img":"/img/bg_article.jpg","banner_img_height":60,"banner_mask_alpha":0.3,"subtitle":null},"category":{"banner_img":"/img/bg_default.png","banner_img_height":60,"banner_mask_alpha":0.3,"subtitle":null,"post_limit":10,"order_by":"-length"},"tag":{"banner_img":"/img/bg_label.jpg","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null,"tagcloud":{"min_font":15,"max_font":30,"unit":"px","start_color":"#BBBBEE","end_color":"#337ab7"}},"about":{"banner_img":"/img/bg_default.png","banner_img_height":60,"banner_mask_alpha":0.3,"subtitle":null,"avatar":"/img/avatar.png","name":"myname","introduce":"一句简短的介绍","icons":[{"class":"iconfont icon-github-fill","link":"https://github.com","tip":"GitHub"},{"class":"iconfont icon-douban-fill","link":"https://douban.com","tip":"豆瓣"},{"class":"iconfont icon-wechat-fill","qrcode":"/img/favicon.png"}]},"page404":{"banner_img":"/img/default.png","banner_img_height":85,"banner_mask_alpha":0.3,"subtitle":"Page not found"},"links":{"banner_img":"/img/default.png","banner_img_height":60,"banner_mask_alpha":0.3,"subtitle":null,"items":[{"title":"Fluid Docs","intro":"主题使用指南","link":"https://hexo.fluid-dev.com/docs/","image":"/img/favicon.png"},{"title":"Fluid Repo","intro":"主题 GitHub 仓库","link":"https://github.com/fluid-dev/hexo-theme-fluid","image":"/img/favicon.png"},{"title":"Fluid Example","intro":"主题操作示例","link":"https://hexo.fluid-dev.com/docs/example/","image":"/img/favicon.png"}]}}}},"excerpt":"","more":"<p><strong>本文同步发布在<a href=\"https://juejin.im/post/5d603d026fb9a06afa3291b9\">掘金</a>,未经本人允许不得转载</strong></p>\n<p>上篇文章我们使用注解+反射实现了一个仿ButterKnife功能的示例。考虑到反射是在运行时完成的，多少会影响程序性能。因此，ButterKnife本身并非基于注解+反射来实现的，而是用APT技术在编译时处理的。APT什么呢？接下来一起来看。</p>\n<h2 id=\"一、APT简介\"><a href=\"#一、APT简介\" class=\"headerlink\" title=\"一、APT简介\"></a>一、APT简介</h2><p><strong>1.什么是APT？</strong><br>APT即为Annotation Processing Tool，它是javac的一个工具，中文意思为编译时注解处理器。APT可以用来在编译时扫描和处理注解。通过APT可以获取到注解和被注解对象的相关信息，在拿到这些信息后我们可以根据需求来自动的生成一些代码，省去了手动编写。注意，获取注解及生成代码都是在代码编译时候完成的，相比反射在运行时处理注解大大提高了程序性能。APT的核心是AbstractProcessor类，关于AbstractProcessor类后面会做详细说明。<br><strong>2.哪里用到了APT？</strong><br>APT技术被广泛的运用在Java框架中，包括Android项以及Java后台项目，除了上面我们提到的ButterKnife之外，像EventBus 、Dagger2以及阿里的ARouter路由框架等都运用到APT技术，因此要想了解以、探究这些第三方框架的实现原理，APT就是我们必须要掌握的。</p>\n<p><strong>3.如何在Android Studio中构建一个APT项目?</strong><br>APT项目需要由至少两个Java Library模块组成，不知道什么是Java Library？没关系，手把手来叫你如何创建一个Java Library。<br><img src=\"https://raw.githubusercontent.com/zhpanvip/Resource/master/image/1601.jfif\"></p>\n<p>首先，新建一个Android项目，然后File–&gt;New–&gt;New Module,打开如上图所示的面板，选择Java Library即可。刚才说到一个APT项目至少应该由两个Java Library模块。那么这两个模块分别是什么作用呢？<br>1.首先需要一个Annotation模块，这个用来存放自定义的注解。<br>2. 另外需要一个Compiler模块，这个模块依赖Annotation模块。<br>3.项目的App模块和其它的业务模块都需要依赖Annotation模块，同时需要通过annotationProcessor依赖Compiler模块。<br>app模块的gradle中依赖关系如下：</p>\n<pre><code class=\"hljs isbl\"><span class=\"hljs-variable\">implementation</span> <span class=\"hljs-function\"><span class=\"hljs-title\">project</span>(<span class=\"hljs-string\">&#x27;:annotation&#x27;</span>)</span>\n<span class=\"hljs-variable\">annotationProcessor</span> <span class=\"hljs-function\"><span class=\"hljs-title\">project</span>(<span class=\"hljs-string\">&#x27;:factory-compiler&#x27;</span>)</span></code></pre>\n<p>APT项目的模块的结构图如下所示：<br><img src=\"https://raw.githubusercontent.com/zhpanvip/Resource/master/image/1602.jfif\"></p>\n<blockquote>\n<p>为什么要强调上述两个模块一定要是Java Library？如果创建Android Library模块你会发现不能找到AbstractProcessor这个类，这是因为Android平台是基于OpenJDK的，而OpenJDK中不包含APT的相关代码。因此，在使用APT时，必须在Java Library中进行。</p>\n</blockquote>\n<h2 id=\"二、从一个例子开始认识APT\"><a href=\"#二、从一个例子开始认识APT\" class=\"headerlink\" title=\"二、从一个例子开始认识APT\"></a>二、从一个例子开始认识APT</h2><p>在学习Java基础的时候想必大家都写过简单工厂模式的例子，回想一下什么是简单工厂模式。接下来引入一个工厂模式的例子，首先定义一个形状的接口IShape，并为其添加 draw()方法：</p>\n<pre><code class=\"hljs routeros\">public<span class=\"hljs-built_in\"> interface </span>IShape &#123;\n\tvoid draw();\n&#125;</code></pre>\n<p>接下来定义几个形状实现IShape接口,并重写draw()方法：</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Rectangle</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">IShape</span> </span>&#123;\n\t<span class=\"hljs-meta\">@Override</span>\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">draw</span><span class=\"hljs-params\">()</span> </span>&#123;\n\t\tSystem.out.println(<span class=\"hljs-string\">&quot;Draw a Rectangle&quot;</span>);\n\t&#125;\n&#125;\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Triangle</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">IShape</span> </span>&#123;\n\t<span class=\"hljs-meta\">@Override</span>\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">draw</span><span class=\"hljs-params\">()</span> </span>&#123;\n\t\tSystem.out.println(<span class=\"hljs-string\">&quot;Draw a Triangle&quot;</span>);\n\t&#125;\n&#125;\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Circle</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">IShape</span> </span>&#123;  \n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">draw</span><span class=\"hljs-params\">()</span> </span>&#123;   \n        System.out.println(<span class=\"hljs-string\">&quot;Draw a circle&quot;</span>);\n    &#125;\n&#125;</code></pre>\n<p>接下来我们需要一个工厂类，这个类接收一个参数，根据我们传入的参数创建出对应的形状，代码如下：</p>\n<pre><code class=\"hljs haxe\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ShapeFactory</span> </span>&#123;\n  <span class=\"hljs-keyword\">public</span> Shape create(<span class=\"hljs-keyword\">String</span> id) &#123;\n    <span class=\"hljs-keyword\">if</span> (id == <span class=\"hljs-literal\">null</span>) &#123;\n      <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">IllegalArgumentException</span>(<span class=\"hljs-string\">&quot;id is null!&quot;</span>);\n    &#125;\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-string\">&quot;Circle&quot;</span>.equals(id)) &#123;\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">Circle</span>();\n    &#125;\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-string\">&quot;Rectangle&quot;</span>.equals(id)) &#123;\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">Rectangle</span>();\n    &#125;\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-string\">&quot;Triangle&quot;</span>.equals(id)) &#123;\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">Triangle</span>();\n    &#125;\n    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">IllegalArgumentException</span>(<span class=\"hljs-string\">&quot;Unknown id = &quot;</span> + id);\n  &#125;\n&#125;</code></pre>\n<p>以上就是一个简单工厂模式的示例代码，想必大家都能够理解。</p>\n<p>那么，现在问题来了，在项目开发过程中，我们随时可能会添加一个新的形状。此时就不得不修改工厂类来适配新添加的形状了。试想一下，每添加一个形状类都需要我们手动去更新Factory类，是不是影响了我们的开发效率？如果这个Factory类能够根据我们添加新的形状来同步更新Factory代码，岂不是就省了我们很多时间了吗？</p>\n<p>应该怎么做才能满足上述需求呢？在第一节中已经提到了使用APT可以帮助我们自动生成代码。那么这个工厂类是不是可以使用APT技术来自动生成呢？我们唯一要做的事情就是新添加的形状类上加上一个注解，注解处理器就会在编译时根据注解信息自动生成ShapeFactory类的代码了，美哉，美哉！理想很丰满，但是，现实很骨感。虽然已经明确了要做什么，但是想要注解处理器帮我们生成代码，却还有很长的路要走。不过，不当紧，接下来我们将一步步实现注解处理器并让其自动生成Factory类。</p>\n<h2 id=\"三、使用APT处理注解\"><a href=\"#三、使用APT处理注解\" class=\"headerlink\" title=\"三、使用APT处理注解\"></a>三、使用APT处理注解</h2><p><strong>1.定义Factory注解</strong><br>首先在annotation模块下添加一个Factory的注解，Factory注解的Target为ElementType，表示它可以注解类、接口或者枚举。Retention指定为RetentionPolicy.CLASS，表示该在字节码中有效。Factory注解添加两个成员，一个Class类型的type，用来表示注解的类的类型，相同的类型表示属于同一个工厂。令需一个String类型的id,用来表示注解的类的名称。Factory注解代码如下：</p>\n<pre><code class=\"hljs less\"><span class=\"hljs-variable\">@Target</span>(ElementType.TYPE)\n<span class=\"hljs-variable\">@Retention</span>(RetentionPolicy.CLASS)\npublic <span class=\"hljs-variable\">@interface</span> Factory &#123;\n\n    <span class=\"hljs-selector-tag\">Class</span> <span class=\"hljs-selector-tag\">type</span>();\n\n    <span class=\"hljs-selector-tag\">String</span> <span class=\"hljs-selector-tag\">id</span>();\n&#125;</code></pre>\n<p>接下来我们用@Factory去注解形状类，如下：</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-meta\">@Factory(id = &quot;Rectangle&quot;, type = IShape.class)</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Rectangle</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">IShape</span> </span>&#123;\n\t<span class=\"hljs-meta\">@Override</span>\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">draw</span><span class=\"hljs-params\">()</span> </span>&#123;\n\t\tSystem.out.println(<span class=\"hljs-string\">&quot;Draw a Rectangle&quot;</span>);\n\t&#125;\n&#125;\n... 其他形状类代码类似不再贴出</code></pre>\n\n<p>**2.认识AbstractProcessor **</p>\n<p>接下来，就到了我们本篇文章所要讲的核心了。没错，就是AbstractProcessor！我们先在factory-compiler模块下创建一个FactoryProcessor类继承AbstractProcessor ，并重写相应的方法，代码如下：</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-meta\">@AutoService(Processor.class)</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">FactoryProcessor</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">AbstractProcessor</span> </span>&#123;\n \t <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">synchronized</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">init</span><span class=\"hljs-params\">(ProcessingEnvironment processingEnvironment)</span> </span>&#123;\n        <span class=\"hljs-keyword\">super</span>.init(processingEnvironment);\n    &#125;\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> Set&lt;String&gt; <span class=\"hljs-title\">getSupportedAnnotationTypes</span><span class=\"hljs-params\">()</span> </span>&#123;\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">super</span>.getSupportedAnnotationTypes();\n    &#125;\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">process</span><span class=\"hljs-params\">(Set&lt;? extends TypeElement&gt; set, RoundEnvironment roundEnvironment)</span> </span>&#123;\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>;\n    &#125;\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> SourceVersion <span class=\"hljs-title\">getSupportedSourceVersion</span><span class=\"hljs-params\">()</span> </span>&#123;\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">super</span>.getSupportedSourceVersion();\n    &#125;\n&#125;</code></pre>\n<p>可以看到，在这个类上添加了@AutoService注解，它的作用是用来生成META-INF/services/javax.annotation.processing.Processor文件的，也就是我们在使用注解处理器的时候需要手动添加META-INF/services/javax.annotation.processing.Processor，而有了@AutoService后它会自动帮我们生成。<a href=\"https://github.com/google/auto/tree/master/service\">AutoService</a>是Google开发的一个库，使用时需要在factory-compiler中添加依赖，如下：</p>\n<pre><code class=\"hljs apache\"><span class=\"hljs-attribute\">implementation</span> &#x27;com.google.auto.service:auto-service:<span class=\"hljs-number\">1</span>.<span class=\"hljs-number\">0</span>-rc<span class=\"hljs-number\">4</span>&#x27;</code></pre>\n\n<p>接下来我们将目光移到FactoryProcessor类内部，可以看到在这个类中重写了四个方法，我们由易到难依次来看：<br>**<em>(1) public SourceVersion getSupportedSourceVersion()**</em><br>这个方法非常简单，只有一个返回值，用来指定当前正在使用的Java版本，通常return SourceVersion.latestSupported()即可。</p>\n<p> <strong><em>(2) public Set&lt;String&gt; getSupportedAnnotationTypes()</em></strong><br> 这个方法的返回值是一个Set集合，集合中指要处理的注解类型的名称(这里必须是完整的包名+类名，例如com.example.annotation.Factory)。由于在本例中只需要处理@Factory注解，因此Set集合中只需要添加@Factory的名称即可。</p>\n<p> <strong><em>(3) public synchronized void init(ProcessingEnvironment processingEnvironment)</em></strong><br>这个方法用于初始化处理器，方法中有一个ProcessingEnvironment类型的参数，ProcessingEnvironment是一个注解处理工具的集合。它包含了众多工具类。例如：<br>Filer可以用来编写新文件；<br>Messager可以用来打印错误信息；<br>Elements是一个可以处理Element的工具类。</p>\n<p><strong><em>在这里我们有必要认识一下什么是Element</em></strong><br>在Java语言中，Element是一个接口，表示一个程序元素，它可以指代包、类、方法或者一个变量。Element已知的子接口有如下几种：</p>\n<blockquote>\n<p>PackageElement  表示一个包程序元素。提供对有关包及其成员的信息的访问。<br>ExecutableElement  表示某个类或接口的方法、构造方法或初始化程序（静态或实例），包括注释类型元素。<br>TypeElement  表示一个类或接口程序元素。提供对有关类型及其成员的信息的访问。注意，枚举类型是一种类，而注解类型是一种接口。<br>VariableElement  表示一个字段、enum 常量、方法或构造方法参数、局部变量或异常参数。</p>\n</blockquote>\n<p>接下来，我希望大家先来理解一个新的概念，<strong>即抛弃我们现有对Java类的理解，把Java类看作是一个结构化的文件</strong>。什么意思？就是把Java类看作一个类似XML或者JSON一样的东西。有了这个概念之后我们就可以很容易的理解什么是Element了。带着这个概念来看下面的代码：</p>\n<pre><code class=\"hljs arduino\">package com.zhpan.mannotation.factory;  <span class=\"hljs-comment\">//    PackageElement</span>\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Circle</span> &#123;</span>  <span class=\"hljs-comment\">//  TypeElement</span>\n\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">int</span> i; <span class=\"hljs-comment\">//   VariableElement</span>\n    <span class=\"hljs-keyword\">private</span> Triangle triangle;  <span class=\"hljs-comment\">//  VariableElement</span>\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">Circle</span><span class=\"hljs-params\">()</span> </span>&#123;&#125; <span class=\"hljs-comment\">//    ExecuteableElement</span>\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">draw</span><span class=\"hljs-params\">(   <span class=\"hljs-comment\">//  ExecuteableElement</span></span></span>\n<span class=\"hljs-function\"><span class=\"hljs-params\">                        <span class=\"hljs-keyword\">String</span> s)</span>   <span class=\"hljs-comment\">//  VariableElement</span></span>\n<span class=\"hljs-function\">    </span>&#123;\n        System.out.<span class=\"hljs-built_in\">println</span>(s);\n    &#125;\n\n    @Override\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">draw</span><span class=\"hljs-params\">()</span> </span>&#123;    <span class=\"hljs-comment\">//  ExecuteableElement</span>\n        System.out.<span class=\"hljs-built_in\">println</span>(<span class=\"hljs-string\">&quot;Draw a circle&quot;</span>);\n    &#125;\n&#125;</code></pre>\n<p>现在明白了吗？不同类型Element其实就是映射了Java中不同的类元素！知晓这个概念后将对理解后边的代码有很大的帮助。</p>\n<p> <strong><em>(4) public boolean process(Set&lt;? extends TypeElement&gt; set, RoundEnvironment roundEnvironment)</em></strong><br> 终于，到了FactoryProcessor类中最后一个也是最重要的一个方法了。先看这个方法的返回值，是一个boolean类型，返回值表示注解是否由当前Processor 处理。如果返回 true，则这些注解由此注解来处理，后续其它的 Processor 无需再处理它们；如果返回 false，则这些注解未在此Processor中处理并，那么后续 Processor 可以继续处理它们。<br> 在这个方法的方法体中，我们可以校验被注解的对象是否合法、可以编写处理注解的代码，以及自动生成需要的java文件等。因此说这个方法是AbstractProcessor 中的最重要的一个方法。我们要处理的大部分逻辑都是在这个方法中完成。</p>\n<p>了解上述四个方法之后我们便可以初步的来编写FactoryProcessor类的代码了，如下：</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-meta\">@AutoService(Processor.class)</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">FactoryProcessor</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">AbstractProcessor</span> </span>&#123;\n        <span class=\"hljs-keyword\">private</span> Types mTypeUtils;\n\t    <span class=\"hljs-keyword\">private</span> Messager mMessager;\n\t    <span class=\"hljs-keyword\">private</span> Filer mFiler;\n\t    <span class=\"hljs-keyword\">private</span> Elements mElementUtils;\n\t    <span class=\"hljs-keyword\">private</span> Map&lt;String, FactoryGroupedClasses&gt; factoryClasses = <span class=\"hljs-keyword\">new</span> LinkedHashMap&lt;&gt;();\n\n \t <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">synchronized</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">init</span><span class=\"hljs-params\">(ProcessingEnvironment processingEnvironment)</span> </span>&#123;\n        <span class=\"hljs-keyword\">super</span>.init(processingEnvironment);\n \n\t\tmTypeUtils = processingEnvironment.getTypeUtils();\n        mMessager = processingEnvironment.getMessager();\n        mFiler = processingEnvironment.getFiler();\n        mElementUtils = processingEnvironment.getElementUtils();\n    &#125;\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> Set&lt;String&gt; <span class=\"hljs-title\">getSupportedAnnotationTypes</span><span class=\"hljs-params\">()</span> </span>&#123;\n        Set&lt;String&gt; annotations = <span class=\"hljs-keyword\">new</span> LinkedHashSet&lt;&gt;();\n        annotations.add(Factory.class.getCanonicalName());\n        <span class=\"hljs-keyword\">return</span> annotations;\n    &#125;\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">process</span><span class=\"hljs-params\">(Set&lt;? extends TypeElement&gt; set, RoundEnvironment roundEnvironment)</span> </span>&#123;\n\n\t\t   <span class=\"hljs-comment\">//\t扫描所有被@Factory注解的元素</span>\n\t   <span class=\"hljs-keyword\">for</span> (Element annotatedElement : roundEnv.getElementsAnnotatedWith(Factory.class)) &#123;\n\n\t\t&#125;\n\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>;\n    &#125;\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> SourceVersion <span class=\"hljs-title\">getSupportedSourceVersion</span><span class=\"hljs-params\">()</span> </span>&#123;\n        <span class=\"hljs-keyword\">return</span> SourceVersion.latestSupported();\n    &#125;\n&#125;</code></pre>\n\n<p>上述FactoryProcessor 代码中在process方法中通过roundEnv.getElementsAnnotatedWith(Factory.class)方法已经拿到了被注解的元素的集合。正常情况下，这个集合中应该包含的是所有被Factory注解的Shape类的元素，也就是一个TypeElement。但在编写程序代码时可能有新来的同事不太了解@Factory的用途而误把@Factory用在接口或者抽象类上，这是不符合我们的标准的。因此，需要在process方法中判断被@Factory注解的元素是否是一个类，如果不是一个类元素，那么就抛出异常，终止编译。代码如下：</p>\n<pre><code class=\"hljs php\">@Override\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">boolean</span> process(Set<span class=\"hljs-meta\">&lt;?</span> <span class=\"hljs-keyword\">extends</span> TypeElement&gt; annotations, RoundEnvironment roundEnv) &#123;\n\t <span class=\"hljs-comment\">//  通过RoundEnvironment获取到所有被@Factory注解的对象</span>\n    <span class=\"hljs-keyword\">for</span> (Element annotatedElement : roundEnv.getElementsAnnotatedWith(Factory.<span class=\"hljs-keyword\">class</span>)) &#123;\n\t\t<span class=\"hljs-keyword\">if</span> (annotatedElement.getKind() != ElementKind.<span class=\"hljs-keyword\">CLASS</span>) &#123;\n\t\t\t <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> ProcessingException(annotatedElement, <span class=\"hljs-string\">&quot;Only classes can be annotated with @%s&quot;</span>,\n                    Factory.<span class=\"hljs-keyword\">class</span>.getSimpleName());\n\t         &#125;\n\t         TypeElement typeElement = (TypeElement) annotatedElement;\n\t         FactoryAnnotatedClass annotatedClass = <span class=\"hljs-keyword\">new</span> FactoryAnnotatedClass(typeElement);\n\t\t\t\t...\n        &#125;\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\n&#125;</code></pre>\n<p>基于面向对象的思想，我们可以将annotatedElement中包含的信息封装成一个对象，方便后续使用，因此，另外可以另外声明一个FactoryAnnotatedClass来解析并存放annotatedElement的相关信息。FactoryAnnotatedClass代码如下：</p>\n<pre><code class=\"hljs arduino\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">FactoryAnnotatedClass</span> &#123;</span>\n    <span class=\"hljs-keyword\">private</span> TypeElement mAnnotatedClassElement;\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">String</span> mQualifiedSuperClassName;\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">String</span> mSimpleTypeName;\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">String</span> mId;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">FactoryAnnotatedClass</span><span class=\"hljs-params\">(TypeElement classElement)</span> </span>&#123;\n        <span class=\"hljs-keyword\">this</span>.mAnnotatedClassElement = classElement;\n        Factory annotation = classElement.getAnnotation(Factory.class);\n        mId = annotation.id();\n        <span class=\"hljs-keyword\">if</span> (mId.length() == <span class=\"hljs-number\">0</span>) &#123;\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> IllegalArgumentException(\n                    <span class=\"hljs-keyword\">String</span>.format(<span class=\"hljs-string\">&quot;id() in @%s for class %s is null or empty! that&#x27;s not allowed&quot;</span>,\n                            Factory.class.getSimpleName(), classElement.getQualifiedName().toString()));\n        &#125;\n        \n        <span class=\"hljs-comment\">// Get the full QualifiedTypeName</span>\n        <span class=\"hljs-keyword\">try</span> &#123;  <span class=\"hljs-comment\">// 该类已经被编译</span>\n            Class&lt;?&gt; clazz = annotation.type();\n            mQualifiedSuperClassName = clazz.getCanonicalName();\n            mSimpleTypeName = clazz.getSimpleName();\n        &#125; <span class=\"hljs-keyword\">catch</span> (MirroredTypeException mte) &#123;<span class=\"hljs-comment\">// 该类未被编译</span>\n            DeclaredType classTypeMirror = (DeclaredType) mte.getTypeMirror();\n            TypeElement classTypeElement = (TypeElement) classTypeMirror.asElement();\n            mQualifiedSuperClassName = classTypeElement.getQualifiedName().toString();\n            mSimpleTypeName = classTypeElement.getSimpleName().toString();\n        &#125;\n    &#125;\n\n    <span class=\"hljs-comment\">// ...省去getter</span>\n&#125;</code></pre>\n<p>为了生成合乎要求的ShapeFactory类，在生成ShapeFactory代码前需要对被Factory注解的元素进行一系列的校验，只有通过校验，符合要求了才可以生成ShapeFactory代码。根据需求，我们列出如下规则：</p>\n<blockquote>\n<p>1.只有类才能被@Factory注解。因为在ShapeFactory中我们需要实例化Shape对象，虽然@Factory注解声明了Target为ElementType.TYPE，但接口和枚举并不符合我们的要求。<br>2.被@Factory注解的类中需要有public的构造方法，这样才能实例化对象。<br>3.被注解的类必须是type指定的类的子类<br>4.id需要为String类型，并且需要在相同type组中唯一<br>5.具有相同type的注解类会被生成在同一个工厂类中</p>\n</blockquote>\n<p>根据上面的规则，我们来一步步完成校验，如下代码：</p>\n<pre><code class=\"hljs gradle\">\n<span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> checkValidClass(FactoryAnnotatedClass item) <span class=\"hljs-keyword\">throws</span> ProcessingException &#123;\n\n        TypeElement classElement = item.getTypeElement();\n\n        <span class=\"hljs-keyword\">if</span> (!classElement.getModifiers().contains(Modifier.<span class=\"hljs-keyword\">PUBLIC</span>)) &#123;\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> ProcessingException(classElement, <span class=\"hljs-string\">&quot;The class %s is not public.&quot;</span>,\n                    classElement.getQualifiedName().toString());\n        &#125;\n\n        <span class=\"hljs-comment\">// 如果是抽象方法则抛出异常终止编译</span>\n        <span class=\"hljs-keyword\">if</span> (classElement.getModifiers().contains(Modifier.<span class=\"hljs-keyword\">ABSTRACT</span>)) &#123;\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> ProcessingException(classElement,\n                    <span class=\"hljs-string\">&quot;The class %s is abstract. You can&#x27;t annotate abstract classes with @%&quot;</span>,\n                    classElement.getQualifiedName().toString(), Factory.<span class=\"hljs-keyword\">class</span>.getSimpleName());\n        &#125;\n\n        <span class=\"hljs-comment\">// 这个类必须是在@Factory.type()中指定的类的子类，否则抛出异常终止编译</span>\n        TypeElement superClassElement = mElementUtils.getTypeElement(item.getQualifiedFactoryGroupName());\n        <span class=\"hljs-keyword\">if</span> (superClassElement.getKind() == ElementKind.<span class=\"hljs-keyword\">INTERFACE</span>) &#123;\n            <span class=\"hljs-comment\">// 检查被注解类是否实现或继承了@Factory.type()所指定的类型，此处均为IShape</span>\n            <span class=\"hljs-keyword\">if</span> (!classElement.getInterfaces().contains(superClassElement.asType())) &#123;\n                <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> ProcessingException(classElement,\n                        <span class=\"hljs-string\">&quot;The class %s annotated with @%s must implement the interface %s&quot;</span>,\n                        classElement.getQualifiedName().toString(), Factory.<span class=\"hljs-keyword\">class</span>.getSimpleName(),\n                        item.getQualifiedFactoryGroupName());\n            &#125;\n        &#125; <span class=\"hljs-keyword\">else</span> &#123;\n            TypeElement currentClass = classElement;\n            <span class=\"hljs-keyword\">while</span> (<span class=\"hljs-keyword\">true</span>) &#123;\n                TypeMirror superClassType = currentClass.getSuperclass();\n\n                <span class=\"hljs-keyword\">if</span> (superClassType.getKind() == TypeKind.NONE) &#123;\n                    <span class=\"hljs-comment\">// 向上遍历父类，直到Object也没获取到所需父类，终止编译抛出异常</span>\n                    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> ProcessingException(classElement,\n                            <span class=\"hljs-string\">&quot;The class %s annotated with @%s must inherit from %s&quot;</span>,\n                            classElement.getQualifiedName().toString(), Factory.<span class=\"hljs-keyword\">class</span>.getSimpleName(),\n                            item.getQualifiedFactoryGroupName());\n                &#125;\n\n                <span class=\"hljs-keyword\">if</span> (superClassType.toString().equals(item.getQualifiedFactoryGroupName())) &#123;\n                    <span class=\"hljs-comment\">// 校验通过，终止遍历</span>\n                    <span class=\"hljs-keyword\">break</span>;\n                &#125;\n                currentClass = (TypeElement) mTypeUtils.asElement(superClassType);\n            &#125;\n        &#125;\n\n        <span class=\"hljs-comment\">// 检查是否由public的无参构造方法</span>\n        <span class=\"hljs-keyword\">for</span> (Element enclosed : classElement.getEnclosedElements()) &#123;\n            <span class=\"hljs-keyword\">if</span> (enclosed.getKind() == ElementKind.CONSTRUCTOR) &#123;\n                ExecutableElement constructorElement = (ExecutableElement) enclosed;\n                <span class=\"hljs-keyword\">if</span> (constructorElement.getParameters().<span class=\"hljs-keyword\">size</span>() == <span class=\"hljs-number\">0</span> &amp;&amp;\n                        constructorElement.getModifiers().contains(Modifier.<span class=\"hljs-keyword\">PUBLIC</span>)) &#123;\n                    <span class=\"hljs-comment\">// 存在public的无参构造方法，检查结束</span>\n                    <span class=\"hljs-keyword\">return</span>;\n                &#125;\n            &#125;\n        &#125;\n\n        <span class=\"hljs-comment\">// 为检测到public的无参构造方法，抛出异常，终止编译</span>\n        <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> ProcessingException(classElement,\n                <span class=\"hljs-string\">&quot;The class %s must provide an public empty default constructor&quot;</span>,\n                classElement.getQualifiedName().toString());\n    &#125;</code></pre>\n<p>如果通过上述校验，那么说明被@Factory注解的类是符合我们的要求的，接下来就可以处理注解信息来生成所需代码了。但是本着面向对象的思想，我们还需声明FactoryGroupedClasses来存放FactoryAnnotatedClass，并且在这个类中完成了ShapeFactory类的代码生成。FactoryGroupedClasses 代码如下：</p>\n<pre><code class=\"hljs arduino\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">FactoryGroupedClasses</span> &#123;</span>\n\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">String</span> SUFFIX = <span class=\"hljs-string\">&quot;Factory&quot;</span>;\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">String</span> qualifiedClassName;\n\n    <span class=\"hljs-keyword\">private</span> Map&lt;<span class=\"hljs-keyword\">String</span>, FactoryAnnotatedClass&gt; itemsMap = <span class=\"hljs-keyword\">new</span> LinkedHashMap&lt;&gt;();\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">FactoryGroupedClasses</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">String</span> qualifiedClassName)</span> </span>&#123;\n        <span class=\"hljs-keyword\">this</span>.qualifiedClassName = qualifiedClassName;\n    &#125;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">add</span><span class=\"hljs-params\">(FactoryAnnotatedClass toInsert)</span> </span>&#123;\n        FactoryAnnotatedClass factoryAnnotatedClass = itemsMap.<span class=\"hljs-built_in\">get</span>(toInsert.getId());\n        <span class=\"hljs-keyword\">if</span> (factoryAnnotatedClass != null) &#123;\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> IdAlreadyUsedException(factoryAnnotatedClass);\n        &#125;\n        itemsMap.<span class=\"hljs-built_in\">put</span>(toInsert.getId(), toInsert);\n    &#125;\n\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">generateCode</span><span class=\"hljs-params\">(Elements elementUtils, Filer filer)</span> throws IOException </span>&#123;\n        <span class=\"hljs-comment\">//  Generate java file</span>\n        ...\n    &#125;\n&#125;</code></pre>\n<p>接下来将所有的FactoryGroupedClasses都添加到集合中去</p>\n<pre><code class=\"hljs haxe\">  <span class=\"hljs-keyword\">private</span> Map&lt;<span class=\"hljs-keyword\">String</span>, FactoryGroupedClasses&gt; factoryClasses = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">LinkedHashMap</span>&lt;&gt;();\n\n<span class=\"hljs-comment\">// \t...</span>\nFactoryGroupedClasses factoryClass = factoryClasses.<span class=\"hljs-keyword\">get</span>(annotatedClass.getQualifiedFactoryGroupName());\n   <span class=\"hljs-keyword\">if</span> (factoryClass == <span class=\"hljs-literal\">null</span>) &#123;\n           <span class=\"hljs-keyword\">String</span> qualifiedGroupName = annotatedClass.getQualifiedFactoryGroupName();\n           factoryClass = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">FactoryGroupedClasses</span>(qualifiedGroupName);\n           factoryClasses.put(qualifiedGroupName, factoryClass);\n     &#125;\nfactoryClass.add(annotatedClass);\n<span class=\"hljs-comment\">// ...</span></code></pre>\n<p>OK!到目前为止，所有的准备工作都已经完成了。接下来就是根据注解信息来生成ShapeFactory类了，有没有很兴奋？遍历factoryClasses集合,并调用FactoryGroupedClasses类的generateCode()方法来生成代码了：</p>\n<pre><code class=\"hljs less\"><span class=\"hljs-selector-tag\">for</span> (FactoryGroupedClasses <span class=\"hljs-attribute\">factoryClass </span>: factoryClasses.values()) &#123;\n          <span class=\"hljs-selector-tag\">factoryClass</span><span class=\"hljs-selector-class\">.generateCode</span>(mElementUtils, mFiler);\n     &#125;</code></pre>\n<p>可是，当我们去掉用generateCode(mElementUtils, mFiler)方法的时候…..纳尼？还是一个空方法，我们还没由实现呢！笑哭?…</p>\n<h2 id=\"四、认识JavaPoet并用其生成ShapeFactory类\"><a href=\"#四、认识JavaPoet并用其生成ShapeFactory类\" class=\"headerlink\" title=\"四、认识JavaPoet并用其生成ShapeFactory类\"></a>四、认识JavaPoet并用其生成ShapeFactory类</h2><p>到此为止，我们唯一剩余的需求就是生成ShapeFactory类了。上一节中我们在FactoryProcessor类的init(ProcessingEnvironment processingEnvironment)方法中通过processingEnvironment拿到了Filer，并且我们也提到通过Filer可以用来编写文件，即可以通过Filer来生成我们所需要的ShapeFactory类。但是，直接使用Filer需要我们手动拼接类的代码，很可能一不小心写错了一个字母就致使所生成的类是无效的。因此，我们需要来认识一下<a href=\"https://github.com/square/javapoet\">JavaPoet</a>这个库。 JavaPoet是square公司的一个开源框架<a href=\"https://github.com/square/javapoet\">JavaPoet</a>，由Jake Wharton大神所编写。JavaPoet可以用对象的方式来帮助我们生成类代码，也就是我们能只要把要生成的类文件包装成一个对象，JavaPoet便可以自动帮我们生成类文件了。关于这个库的使用就不详细在这里讲解了，有需要了解的可以到github查看，使用起来很简单。</p>\n<p>好了，步入正题，使用JavaPoet构建并自动生成ShapeFactory类的代码如下：</p>\n<pre><code class=\"hljs reasonml\">public void generate<span class=\"hljs-constructor\">Code(Elements <span class=\"hljs-params\">elementUtils</span>, Filer <span class=\"hljs-params\">filer</span>)</span> throws IOException &#123;\n        TypeElement superClassName = elementUtils.get<span class=\"hljs-constructor\">TypeElement(<span class=\"hljs-params\">qualifiedClassName</span>)</span>;\n        String factoryClassName = superClassName.get<span class=\"hljs-constructor\">SimpleName()</span> + SUFFIX;\n        String qualifiedFactoryClassName = qualifiedClassName + SUFFIX;\n        PackageElement pkg = elementUtils.get<span class=\"hljs-constructor\">PackageOf(<span class=\"hljs-params\">superClassName</span>)</span>;\n        String packageName = pkg.is<span class=\"hljs-constructor\">Unnamed()</span> ? null : pkg.get<span class=\"hljs-constructor\">QualifiedName()</span>.<span class=\"hljs-keyword\">to</span><span class=\"hljs-constructor\">String()</span>;\n\n        MethodSpec.Builder <span class=\"hljs-keyword\">method</span> = <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">MethodSpec</span>.</span></span><span class=\"hljs-keyword\">method</span><span class=\"hljs-constructor\">Builder(<span class=\"hljs-string\">&quot;create&quot;</span>)</span>\n                .add<span class=\"hljs-constructor\">Modifiers(Modifier.PUBLIC)</span>\n                .add<span class=\"hljs-constructor\">Parameter(String.<span class=\"hljs-params\">class</span>, <span class=\"hljs-string\">&quot;id&quot;</span>)</span>\n                .returns(<span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">TypeName</span>.</span></span>get(superClassName.<span class=\"hljs-keyword\">as</span><span class=\"hljs-constructor\">Type()</span>));\n        <span class=\"hljs-keyword\">method</span>.<span class=\"hljs-keyword\">begin</span><span class=\"hljs-constructor\">ControlFlow(<span class=\"hljs-string\">&quot;if (id == null)&quot;</span>)</span>\n                .add<span class=\"hljs-constructor\">Statement(<span class=\"hljs-string\">&quot;throw new IllegalArgumentException($S)&quot;</span>, <span class=\"hljs-string\">&quot;id is null!&quot;</span>)</span>\n                .<span class=\"hljs-keyword\">end</span><span class=\"hljs-constructor\">ControlFlow()</span>;\n\n        <span class=\"hljs-keyword\">for</span> (FactoryAnnotatedClass item : itemsMap.values<span class=\"hljs-literal\">()</span>) &#123;\n            <span class=\"hljs-keyword\">method</span>.<span class=\"hljs-keyword\">begin</span><span class=\"hljs-constructor\">ControlFlow(<span class=\"hljs-string\">&quot;if ($S.equals(id))&quot;</span>, <span class=\"hljs-params\">item</span>.<span class=\"hljs-params\">getId</span>()</span>)\n                    .add<span class=\"hljs-constructor\">Statement(<span class=\"hljs-string\">&quot;return new $L()&quot;</span>, <span class=\"hljs-params\">item</span>.<span class=\"hljs-params\">getTypeElement</span>()</span>.get<span class=\"hljs-constructor\">QualifiedName()</span>.<span class=\"hljs-keyword\">to</span><span class=\"hljs-constructor\">String()</span>)\n                    .<span class=\"hljs-keyword\">end</span><span class=\"hljs-constructor\">ControlFlow()</span>;\n        &#125;\n\n        <span class=\"hljs-keyword\">method</span>.add<span class=\"hljs-constructor\">Statement(<span class=\"hljs-string\">&quot;throw new IllegalArgumentException($S + id)&quot;</span>, <span class=\"hljs-string\">&quot;Unknown id = &quot;</span>)</span>;\n\n        TypeSpec typeSpec = TypeSpec\n                .<span class=\"hljs-keyword\">class</span><span class=\"hljs-constructor\">Builder(<span class=\"hljs-params\">factoryClassName</span>)</span>\n                .add<span class=\"hljs-constructor\">Modifiers(Modifier.PUBLIC)</span>\n                .add<span class=\"hljs-constructor\">Method(<span class=\"hljs-params\">method</span>.<span class=\"hljs-params\">build</span>()</span>)\n                .build<span class=\"hljs-literal\">()</span>;\n\n        <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">JavaFile</span>.</span></span>builder(packageName, typeSpec).build<span class=\"hljs-literal\">()</span>.write<span class=\"hljs-constructor\">To(<span class=\"hljs-params\">filer</span>)</span>;\n    &#125;</code></pre>\n\n<p>好了，现在项目已经可以帮我们自动来生成需要的Java文件啦。接下来验证一下，Build一下项目，切换到project模式下，在app–&gt;build–&gt;generated–&gt;source–&gt;apt–&gt;debug–&gt;(package)–&gt;factory下面就可以看到ShapeFactory类，如下图：<br><img src=\"https://raw.githubusercontent.com/zhpanvip/Resource/master/image/1603.jfif\"></p>\n<p>这个类并非是我们自己编写的，而是通过使用APT的一系列骚操作自动生成的。现在可以再添加一个形状类实现IShape并附加@Factory注解，再次编译后都自动会生成到ShapeFactory中！</p>\n<p>到此为止，本篇文章就告一段落了。相信看完本篇文章一定大有所获，因为掌握了APT技术之后，再去研究使用APT的第三方框架源码，一定会游刃有余，事半功倍。</p>\n<p>由于本篇文章结构比较复杂且代码也较多，项目的源码已经放在文章末尾，可作参考。</p>\n<p><a href=\"https://github.com/zhpanvip/MAnnotation\">源码下载</a></p>\n<p><strong>参考资料</strong></p>\n<p><a href=\"https://www.race604.com/annotation-processing/\">Java注解处理器</a></p>\n<p><a href=\"http://www.cjsdn.net/Doc/JDK60/javax/annotation/processing/AbstractProcessor.html\">JDK文档AbstractProcessor</a></p>\n"},{"title":"打造一个丝滑般自动轮播无限循环Android库(一)","date":"2019-09-01T14:14:13.000Z","_content":"\n本文同步发布在[掘金](https://juejin.im/post/5d6bce24f265da03db0790d1)，如需转载请注明出处。\n\n\nBannerViewPager系列文章共三篇，此文为第一篇，另外两篇参看下面链接：\n\n\n[BannerViewPager源码剖析](https://blog.csdn.net/qq_20521573/article/details/100609592)\n\n[剖析BannerViewPager中Indicator的设计思想](https://blog.csdn.net/qq_20521573/article/details/103216593)\n\n\n\n最近公司项目在升级AndroidX，由于项目中用到的一些比较老的库都已停止更新维护，因此需要将这些库替换掉，其中就包括自动轮播的Banner库。恰逢笔者在之前写过一个轮播图，因此就在此基础上重构，打造出了一个全新的支持多种样式的轮播库---[BannerViewPager](https://github.com/zhpanvip/BannerViewPager/tree/master)。个人觉得[BannerViewPager](https://github.com/zhpanvip/BannerViewPager/tree/master)要优于其它开源的Banner库，不仅仅是因为它拥有简洁高效的代码，更是因为它高度的可定制性。[BannerViewPager](https://github.com/zhpanvip/BannerViewPager/tree/master)不仅支持任意的页面布局，而且可以支持任意的Indicator样式。甚至连Indicator的位置都可以做到任意摆放。是的，就是这么随心所欲。无图言叼，还是先通过图片和代码一览BannerViewPager的功能吧(多图预警)。\n\n# 一、BannerViewPager效果预览及API介绍\n由于GIF图片质量问题，下面的预览图并不清晰，大家可以点击下面链接或者扫描二维码下载Apk体验。Apk存放在github上，下载速度可能会比较慢。\n\n [点击或扫描二维码下载apk](https://github.com/zhpanvip/BannerViewPager/raw/master/download/app.apk)\n\n![](https://raw.githubusercontent.com/zhpanvip/Resource/master/image/banner/qrcode.png)\n\n## 1.setIndicatorStyle（开局就放王炸？）\nBannerViewPager目前内置了CIRCLE和DASH两种样式的指示器,通过setIndicatorStyle(int)一行代码就可以切换指示器的样式。当然，如果内置样式不满足你的需求。BannerViewPager还提供了自定义指示器的功能。只要继承BaseIndicatorView或者实现IIndicator接口，并重写相应方法，就可以通过自定义View为所欲为的打造任意的Indicator了。如下图【自定义】就是自己实现的指示器样式。\n\n| CIRCLE | DASH | 自定义 |\n|--|--|--|\n|![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMS8xNi8xNmU3NGNhODFlOWM4OGI5?x-oss-process=image/format,png)|![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMS8xNi8xNmU3NGNiNGU3M2YyM2U3?x-oss-process=image/format,png)|![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMS8xNi8xNmU3NGNjMjE2OWNiOTBi?x-oss-process=image/format,png)|\n\n下面通过代码演示如何切换指示器：\n```\nmViewPager.setIndicatorStyle(IndicatorStyle.DASH)\n          .setIndicatorHeight(BannerUtils.dp2px(3f))\n          .setIndicatorWidth(BannerUtils.dp2px(3), BannerUtils.dp2px(10))\n          .setHolderCreator(() -> new ImageResourceViewHolder(0))\n          .create(mDrawableList)\n```\n通过5行代码就轻松的实现了上图【Dash】仿支付宝的Indicator样式（大家可以留意一下支付宝的轮播Indicator，挺有意思）。\n\n关于自定义IndicatorView将会放在后边章节详细讲解。\n\n\n## 2.setPageStyle\n\n通过setPageStyle(int)一行代码开启一屏三页模式，一屏三页模式下目前有三种样式，分别如下图所示：\n\n| MULTI_PAGE |MULTI_PAGE_SCALE | MULTI_PAGE_OVERLAP |\n|--|--|--|\n|![MULTI_PAGE ](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMS8xNS8xNmU2ZjNjMTdhZDcyMGMx?x-oss-process=image/format,png)|![MULTI_PAGE_SCALE ](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMS8xNS8xNmU2ZjNjMTdiODNhOTQ4?x-oss-process=image/format,png)|![MULTI_PAGE_OVERLAP ](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMS8xNS8xNmU2ZjNjMTdjM2QwOWVh?x-oss-process=image/format,png)|\n代码演示：\n```\n    mViewPager.setPageStyle(PageStyle.MULTI_PAGE)\n              .setPageMargin(BannerUtils.dp2px(10))\n              .setRevealWidth(BannerUtils.dp2px(10))\n              .setHolderCreator(() -> new ImageResourceViewHolder(BannerUtils.dp2px(5)))\n              .create(mDrawableList);\n```\n同样通过短短5行代码就实现了上图【MULTI_PAGE】的效果，简单好用！\n\n## 3.如何实现指示器位置任意摆放？\n我们看到上面图表中MULTI_PAGE_OVERLAP模式下指示器显示到了Banner的下边。这种效果该怎么实现呢？其实BannerViewPager是支持把Indicator摆放在任意位置的。之所以能如此强大是因为我们通过自定义指示器替换了内置的IndicatorView，也就是说此时的IndicatorView已经脱离了BannerViewPager,也就理所当然的可以放在任意位置了。接下来通过代码来看下如何实现：\n\n### (1)Xml布局文件如下\n```\n<RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n\n    <com.zhpan.bannerview.BannerViewPager\n        android:id=\"@+id/banner_view\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"180dp\"\n        android:layout_marginTop=\"20dp\"\n        app:bvp_page_style=\"multi_page\" />\n\n    <com.zhpan.bannerview.indicator.CircleIndicatorView\n        android:id=\"@+id/indicator_view\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:layout_below=\"@id/banner_view\"\n        android:layout_centerHorizontal=\"true\"\n        android:layout_marginTop=\"10dp\" />\n </RelativeLayout>\n\n```\n### (2)通过setIndicatorView(IIndicator)替换内部指示器\n\n```\n        CircleIndicatorView indicatorView = findViewById(R.id.indicator_view);\n \tmViewPager.setIndicatorView(indicatorView)\n                  .setIndicatorColor(Color.parseColor(\"#888888\"),\n                       Color.parseColor(\"#118EEA\"))\n                  .setHolderCreator(() -> new ImageResourceViewHolder(BannerUtils.dp2px(5)))\n                  .create(mDrawableList);\n```\nCircleIndicatorView是什么？其实他就是内置在BannerViewPager中的指示器，现在你只需要把它同BannerViewPager放在同一个布局文件中就可以了。又是仅仅通过一行代码就完成了对内部指示器的替换，不知道你看完之后是否会拍案叫绝，竟然如此简单！\n\n## 4.setIndicatorSlideMode\n我们应该见过很多App轮播图的指示器都会跟随页面一起滑动。BannerViewPager自然也不会少了这个功能。通过setIndicatorSlideMode(int)一行代码就可以轻松切换到下图（SMOOTH）的效果。\n\n| NORMAL | SMOOTH |\n|--|--|\n|![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMS8xNS8xNmU2ZjNjMWIwM2U5NWE5?x-oss-process=image/format,png)|![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMS8xNS8xNmU2ZjNjMWI0MGMwMzAz?x-oss-process=image/format,png)|\n\n代码实现仍然非常简单，使用BannerViewPager你只需要记住一个核心--Only One Line！所以演示代码不再贴出你应该不会揍我吧？\n\n![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMS8xNi8xNmU3NGE4NThhY2ZmZTg2?x-oss-process=image/format,png)\n\n## 5.setPageTransformerStyle\n\n关于Transform更好的方式应该是留给开发者自己去实现，因此BannerViewPager中目前仅内置了四种常用Transform样式，如果不能满足需求，可以通过BannerViewPager的setPageTransformer(ViewPager.PageTransformer transformer)设置自定义的Transform。四种内置Transform样式如下：\n\n| STACK | ACCORDION  | DEPTH | ROTATE  |  \n|--|--|--|--|\n|![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMS8xNy8xNmU3OTkyZGZmMTA5MWYz?x-oss-process=image/format,png)|![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMS8xNy8xNmU3OTkzNjI4NGU2MThm?x-oss-process=image/format,png)|![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMS8xNy8xNmU3OTk0MzBhYThmYTFl?x-oss-process=image/format,png)|![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMS8xNy8xNmU3OTk0YmQ2MzlmYjAw?x-oss-process=image/format,png)|\n\n当然，BannerViewPager的功能并不仅仅局限于此，更多功能就不再演示，可以看下面所有开放的API接口。\n\n\n## 6.BannerViewPager开放的API\n\nBannerViewPager开放了众多API,以供满足不同的需求，具体如下表：\n\n| 方法名 | 方法描述 | 说明 |\n|--|--|--|\n| BannerViewPager<T, VH> setCanLoop(boolean canLoop) | 是否开启循环 | 默认值true|\n| BannerViewPager<T, VH> setAutoPlay(boolean autoPlay) | 是否开启自动轮播 | 默认值true|\n| BannerViewPager<T, VH> setInterval(int interval) | 自动轮播时间间隔 |单位毫秒，默认值3000  |\n| BannerViewPager<T, VH> setScrollDuration(int scrollDuration) | 设置页面滚动时间 | 设置页面滚动时间 |单位毫秒，默认值800  |\n| BannerViewPager<T, VH> setRoundCorner(int radius) | 设置圆角 |默认无圆角 需要SDK_INT>=LOLLIPOP(API 21)  |\n| BannerViewPager<T, VH> setOnPageClickListener(OnPageClickListener onPageClickListener) | 设置页面点击事件 |  |\n| BannerViewPager<T, VH> setHolderCreator(HolderCreator\\<VH> holderCreator) |设置HolderCreator  |必须设置HolderCreator，否则会抛出NullPointerException|\n| BannerViewPager<T, VH> setIndicatorVisibility(@Visibility int visibility) | indicator vibility |默认值VISIBLE 2.4.2 新增|\n| BannerViewPager<T, VH> setIndicatorStyle(int indicatorStyle) | 设置指示器样式 | 可选枚举(CIRCLE, DASH) 默认CIRCLE  |\n| BannerViewPager<T, VH> setIndicatorGravity(int gravity) | 指示器位置 |可选值(CENTER、START、END)默认值CENTER |\n| BannerViewPager<T, VH> setIndicatorColor(int normalColor,int checkedColor) | 指示器圆点颜色 |normalColor：未选中时颜色默认\"#8C6C6D72\"， checkedColor：选中时颜色 默认\"#8C18171C\" |\n| BannerViewPager<T, VH> setIndicatorSlideMode(int slideMode)  | 设置Indicator滑动模式 | 可选（NORMAL、SMOOTH），默认值SMOOTH  |\n| BannerViewPager<T, VH> setIndicatorRadius(int radius) | 设置指示器圆点半径 | 默认值4dp|\n| BannerViewPager<T, VH> setIndicatorRadius(int normalRadius,int checkRadius)  |设置指示器圆点半径  |  normalRadius:未选中时半径  checkedRadius:选中时的半径,默认值4dp |\n| BannerViewPager<T, VH> setIndicatorWidth(int indicatorWidth) | 设置指示器宽度，如果是圆形指示器，则为直径 |  默认值8dp|\n| BannerViewPager<T, VH> setIndicatorWidth(int normalWidth, int checkWidth) | 设置指示器宽度，如果是圆形指示器，则为直径 | 默认值8dp |\n| BannerViewPager<T, VH> setIndicatorHeight(int indicatorHeight) | 设置指示器高度，仅在Indicator样式为DASH时有效 | 默认值normalIndicatorWidth/2 |\n| BannerViewPager<T, VH> setIndicatorGap(int indicatorMargin) | 指示器圆点间距| 默认值为指示器宽度（或者是圆的直径）|\n| BannerViewPager<T, VH> setIndicatorView(IIndicator indicatorView) | 设置自定义指示器| |\n| BannerViewPager<T, VH> setPageTransformerStyle(int style) | 设置页面Transformer内置样式 |  |\n| BannerViewPager<T, VH> setCurrentItem(int item) | Set the currently selected page. | 2.3.5新增 |\n| void getCurrentItem() | 获取当前position | 2.3.5新增 |\n| BannerViewPager<T, VH> setPageStyle(PageStyle pageStyle) | 设置页面样式 | 2.4.0新增 可选（MULTI_PAGE、NORMAL）MULTI_PAGE：一屏多页样式 |\n| BannerViewPager<T, VH> setPageMargin(int pageMargin) | 设置页面间隔 | 2.4.0新增 |\n| BannerViewPager<T, VH> setIndicatorMargin(int left, int top, int right, int bottom) | 设置Indicator边距 | 2.4.1新增 |\n| BannerViewPager<T, VH> setOnPageChangeListener(OnPageChangeListener l) | 页面改变的监听事件 | 2.4.3新增 |\n| void startLoop() |开启自动轮播 | 初始化BannerViewPager时不必调用该方法,设置setAutoPlay后会调用startLoop() |\n| void stopLoop() | 停止自动轮播 | 如果开启自动轮播，为避免内存泄漏需要在onStop()或onDestroy中调用此方法 |\n| List\\<T> getList() | 获取Banner中的集合数据 |  |\n| void create(List<T> list) |初始化并构造BannerViewPager  |必须调用，否则前面设置的参数无效  |\n\n## 7.BannerViewPager支持的attrs\n你也可以通过xml来设置BannerViewPager，xml支持的attrs如下:\n| Attributes | format | description |\n|--|--|--|\n| bvp_interval | integer | 自动轮播时间间隔 |\n| bvp_scroll_duration | integer | 页面切换时滑动时间|\n| bvp_can_loop | boolean| 是否循环 |\n| bvp_auto_play | boolean | 是否自动播放  |\n| bvp_indicator_checked_color | color | indicator选中时颜色 |\n| bvp_indicator_normal_color | color | indicator未选中时颜色 |\n| bvp_indicator_radius | dimension | indicator圆点半径或者Dash模式的1/2宽度  |\n| bvp_round_corner| dimension  | Banner圆角大小 |\n| bvp_page_margin | dimension | 页面item间距 |\n| bvp_reveal_width | dimension | 一屏多页模式下两边item漏出的宽度 |\n| bvp_indicator_style | enum | indicator样式(circle/dash)  |\n| bvp_indicator_slide_mode | enum | indicator滑动模式(normal/smooth) |\n| bvp_indicator_gravity | enum | indicator位置(center/start/end) |\n| bvp_page_style | enum | page样式(normal/multi_page/multi_page_overlap/multi_page_scale) |\n| bvp_transformer_style | enum | transform样式(normal/depth/stack/accordion) |\n| bvp_indicator_visibility| enum | indicator visibility(visible/gone/invisible) |\n\n\n# 二、BannerViewPager详细使用说明\n  \n\n## 1.gradle中添加依赖\n\n如果您已迁移到AndroidX请使用latestVersion(>=2.4.3.1)\n```\nimplementation 'com.zhpan.library:bannerview:latestVersion'\n\n```\n如果未迁移到AndroidX请使用（非Androidx的包托管在JCenter上）：\n```\nimplementation 'com.zhpan.library:bannerview:2.4.3.1'\n```\n\n## 2. 在xml文件中添加如下代码：\n\n```\n    <com.zhpan.bannerview.BannerViewPager\n            android:id=\"@+id/banner_view\"\n            android:layout_width=\"match_parent\"\n            android:layout_margin=\"10dp\"\n            android:layout_height=\"160dp\" />\n```\n## 3.Banner的Item页面布局\n\n```\n<RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"wrap_content\">\n\n    <ImageView\n        android:id=\"@+id/banner_image\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"match_parent\"\n        android:scaleType=\"centerCrop\" />\n\n    <LinearLayout\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\"\n        android:layout_alignParentBottom=\"true\"\n        android:background=\"#66000000\"\n        android:gravity=\"center_vertical\">\n\n        <TextView\n            android:id=\"@+id/tv_describe\"\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"match_parent\"\n            android:layout_gravity=\"center_vertical\"\n            android:layout_marginStart=\"15dp\"\n            android:gravity=\"center_vertical\"\n            android:paddingTop=\"5dp\"\n            android:paddingBottom=\"5dp\"\n            android:textColor=\"#FFFFFF\"\n            android:textSize=\"16sp\" />\n    </LinearLayout>\n\n</RelativeLayout>\n```\n\n## 4.自定义ViewHolder\n\n```\npublic class NetViewHolder implements ViewHolder<BannerData> {\n    private ImageView mImageView;\n    private TextView mTextView;\n\n    @Override\n    public View createView(ViewGroup viewGroup, Context context, int position) {\n        View view = LayoutInflater.from(context).inflate(R.layout.item_net, viewGroup, false);\n        mImageView = view.findViewById(R.id.banner_image);\n        mTextView = view.findViewById(R.id.tv_describe);\n        return view;\n    }\n\n    @Override\n    public void onBind(Context context, BannerData data, int position, int size) {\n        ImageLoaderOptions options = new ImageLoaderOptions.Builder().into(mImageView).load(data.getImagePath()).placeHolder(R.drawable.placeholder).build();\n        ImageLoaderManager.getInstance().loadImage(options);\n        mTextView.setText(data.getTitle());\n    }\n}\n```\n\n## 5.BannerViewPager参数配置\n\n```\n    private BannerViewPager<BannerData, NetViewHolder> mBannerViewPager;\n\tprivate void initViewPager() {\n             mBannerViewPager = findViewById(R.id.banner_view);\n             mBannerViewPager.showIndicator(true)\n                .setInterval(3000)\n                .setCanLoop(false)\n                .setAutoPlay(true)\n                .setRoundCorner(DpUtils.dp2px(7))\n                .setIndicatorColor(Color.parseColor(\"#935656\"), Color.parseColor(\"#FF4C39\"))\n                .setIndicatorGravity(BannerViewPager.END)\n                .setScrollDuration(1000).setHolderCreator(NetViewHolder::new)\n                .setOnPageClickListener(position -> {\n                    BannerData bannerData = mBannerViewPager.getList().get(position);\n                    Toast.makeText(NetworkBannerActivity.this,\n                            \"点击了图片\" + position + \" \" + bannerData.getDesc(), Toast.LENGTH_SHORT).show();\n\n                }).create(mList);\n        }\n```\n\n### 6.开启与停止轮播\n\n***2.5.0之后版本无需自行在Activity或Fragment中管理stopLoop和startLoop方法，但这两个方法依旧保留对外开发***\n\n~~如果开启了自动轮播功能，请务必在onDestroy中停止轮播，以免出现内存泄漏。~~\n\n```\n\t@Override\n    protected void onDestroy() {\n        super.onDestroy();\n        if (mBannerViewPager != null)\n    \t\tmViewpager.stopLoop();\n    }\n```\n~~为了节省性能也可以在onStop中停止轮播，在onResume中开启轮播：~~\n\n```\n    @Override\n    protected void onStop() {\n        super.onStop();\n        if (mBannerViewPager != null)\n            mBannerViewPager.stopLoop();\n    }\n\n    @Override\n    protected void onResume() {\n        super.onResume();\n        if (mBannerViewPager != null)\n            mBannerViewPager.startLoop();\n    }\n```\n\n# 三、高级功能---自定义IndicatorView\n因为指示器的样式千变万化,BannerViewPager中不可能内置所有的样式，因此我将定义权限交给了开发者自己来实现，这样就可以满足所有开发者的需求了。但是自定义IndicatorView需要有一定的自定义View基础，尽管我已经在BaseIndicatorView中处理了许多逻辑，但是还是要开发者根据自身需求进行Indicator的绘制。好了，下面就让我们来看看如何实现自定义IndicatorView吧。\n\n关于自定义IndicatorView其实我们在第一节中讲解Indicator摆放位置时已经提到了，就是通过setIndicator(IIndicator)来替换内部的指示器。当然，这个方法接收的参数不仅仅是内置的两个IndicatorView，它还可以是我们自己实现的Indicator。前提只需要继承BaseIndicatorView或者继承View并实现IIndicator，然后根据需求绘制即可。\n\n### (1)认识BaseIndicatorView\n\nBaseIndicatorView是BannerViewPager库中的一个类，它继承自View并实现了IIndicator接口。在这个类中存储了BannerViewPager的许多参数信息，比如页面个数(pageSize)、页面滑动进度(slideProgress)以及当前页面位置(currentPosition)等，这些都是在绘制IndicatorView时会用到的信息。有了这些参数之后我们就可以比较轻松的去绘制指示器了。如果你觉得我这些数据计算的不够精确或者计算存在错误，那么你大可以自己实现IIndicator接口自行计算。本文我会通过继承BaseIndicatorView的方式来实现一个自定义指示器的例子。\n你可以点击链接查看[BaseIndicatorView](https://github.com/zhpanvip/BannerViewPager/blob/master/bannerview/src/main/java/com/zhpan/bannerview/indicator/BaseIndicatorView.java)的完整代码。\n\n### (2)开启自定义IndicatorView之路\n\n好了，接下来我们就来完成一个如下图所示的自定义IndicatorView吧！\n\n![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMS8xNi8xNmU3NDdhMGJmZDc3MGE1?x-oss-process=image/format,png)\n\n \n**新建一个FigureIndicatorView类并继承BaseIndicatorView**\n\n```\npublic class FigureIndicatorView extends BaseIndicatorView {\n\n    private int radius = DpUtils.dp2px(20);\n\n    private int backgroundColor = Color.parseColor(\"#88FF5252\");\n\n    private int textColor = Color.WHITE;\n\n    private int textSize=DpUtils.dp2px(13);\n\n    // ...省略无关代码\n\n    @Override\n    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n        super.onMeasure(widthMeasureSpec, heightMeasureSpec);\n        setMeasuredDimension(2 * radius, 2 * radius);\n    }\n\n    @Override\n    protected void onDraw(Canvas canvas) {\n        super.onDraw(canvas);\n        mPaint.setColor(backgroundColor);\n        canvas.drawCircle(getWidth() / 2, getHeight() / 2, radius, mPaint);\n        mPaint.setColor(textColor);\n        mPaint.setTextSize(textSize);\n        String text = currentPosition + 1 + \"/\" + pageSize;\n        int textWidth = (int) mPaint.measureText(text);\n        Paint.FontMetricsInt fontMetricsInt = mPaint.getFontMetricsInt();\n        int baseline = (getMeasuredHeight() - fontMetricsInt.bottom + fontMetricsInt.top) / 2 - fontMetricsInt.top;\n        canvas.drawText(text, (getWidth() - textWidth) / 2, baseline, mPaint);\n    }\n\n    public void setRadius(int radius) {\n        this.radius = radius;\n    }\n\n    @Override\n    public void setBackgroundColor(@ColorInt int backgroundColor) {\n        this.backgroundColor = backgroundColor;\n    }\n\n    public void setTextSize(int textSize) {\n        this.textSize = textSize;\n    }\n    // ...省略无关代码\n}\n```\n有自定义View基础的同学应该能很轻松的看懂上边的代码。首先通过onMeasure()方法测量了View的大小，接下来就是在onDraw方法中绘制圆和文字了。很容易就实现了一个自定义的IndicatorView。当然，这个例子本身就比较简单。如果你需要绘制比较复杂且带有动画的Indicator，可以参考源码中的CircleIndicatorView和DashIndicatorView，或许它能给你一些灵感。\n### (3)设置自定义指示器\n接下来就将我们自己绘制的指示器设置到BannerViewPager中吧！\n```\n    FigureIndicatorView indicatorView = new FigureIndicatorView(mContext);\n    indicatorView.setRadius(BannerUtils.dp2px(18));\n    indicatorView.setTextSize(BannerUtils.dp2px(13));\n    indicatorView.setBackgroundColor(Color.parseColor(\"#aa118EEA\"));\n    \n    mViewPager.setIndicatorGravity(IndicatorGravity.END)\n              .setIndicatorView(indicatorView)\n              .setHolderCreator(() -> new ImageResourceViewHolder(0))\n              .create(mDrawableList);    \n        \n```\n依然如此潇洒自然！好了，关于BannerViewPager的介绍今天就讲解到这里了。接下来的一篇文章将会对BannerViewPager的源码进行剖析，了解下它是如何通过简单的Api实现来实现复杂的功能的。\n\n都看到这里了，确定不到GitHub点个星再走？源码已放到文章末尾。如果有好的Idea也欢迎Pull Request。\n\n[《BannerViewPager源码解析》](https://juejin.im/post/5d74d3faf265da03b5747015)\n\n\n[源码下载](https://github.com/zhpanvip/BannerViewPager)\n\n\n**文章上次更新2019.11.16**\n\n","source":"_posts/19.打造一个丝滑般自动轮播无限循环Android库(一).md","raw":"---\ntitle: 打造一个丝滑般自动轮播无限循环Android库(一)\ndate: 2019-09-01 22:14:13\ntags:\n- 自定义View\n- Banner \n- ViewPager2\n---\n\n本文同步发布在[掘金](https://juejin.im/post/5d6bce24f265da03db0790d1)，如需转载请注明出处。\n\n\nBannerViewPager系列文章共三篇，此文为第一篇，另外两篇参看下面链接：\n\n\n[BannerViewPager源码剖析](https://blog.csdn.net/qq_20521573/article/details/100609592)\n\n[剖析BannerViewPager中Indicator的设计思想](https://blog.csdn.net/qq_20521573/article/details/103216593)\n\n\n\n最近公司项目在升级AndroidX，由于项目中用到的一些比较老的库都已停止更新维护，因此需要将这些库替换掉，其中就包括自动轮播的Banner库。恰逢笔者在之前写过一个轮播图，因此就在此基础上重构，打造出了一个全新的支持多种样式的轮播库---[BannerViewPager](https://github.com/zhpanvip/BannerViewPager/tree/master)。个人觉得[BannerViewPager](https://github.com/zhpanvip/BannerViewPager/tree/master)要优于其它开源的Banner库，不仅仅是因为它拥有简洁高效的代码，更是因为它高度的可定制性。[BannerViewPager](https://github.com/zhpanvip/BannerViewPager/tree/master)不仅支持任意的页面布局，而且可以支持任意的Indicator样式。甚至连Indicator的位置都可以做到任意摆放。是的，就是这么随心所欲。无图言叼，还是先通过图片和代码一览BannerViewPager的功能吧(多图预警)。\n\n# 一、BannerViewPager效果预览及API介绍\n由于GIF图片质量问题，下面的预览图并不清晰，大家可以点击下面链接或者扫描二维码下载Apk体验。Apk存放在github上，下载速度可能会比较慢。\n\n [点击或扫描二维码下载apk](https://github.com/zhpanvip/BannerViewPager/raw/master/download/app.apk)\n\n![](https://raw.githubusercontent.com/zhpanvip/Resource/master/image/banner/qrcode.png)\n\n## 1.setIndicatorStyle（开局就放王炸？）\nBannerViewPager目前内置了CIRCLE和DASH两种样式的指示器,通过setIndicatorStyle(int)一行代码就可以切换指示器的样式。当然，如果内置样式不满足你的需求。BannerViewPager还提供了自定义指示器的功能。只要继承BaseIndicatorView或者实现IIndicator接口，并重写相应方法，就可以通过自定义View为所欲为的打造任意的Indicator了。如下图【自定义】就是自己实现的指示器样式。\n\n| CIRCLE | DASH | 自定义 |\n|--|--|--|\n|![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMS8xNi8xNmU3NGNhODFlOWM4OGI5?x-oss-process=image/format,png)|![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMS8xNi8xNmU3NGNiNGU3M2YyM2U3?x-oss-process=image/format,png)|![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMS8xNi8xNmU3NGNjMjE2OWNiOTBi?x-oss-process=image/format,png)|\n\n下面通过代码演示如何切换指示器：\n```\nmViewPager.setIndicatorStyle(IndicatorStyle.DASH)\n          .setIndicatorHeight(BannerUtils.dp2px(3f))\n          .setIndicatorWidth(BannerUtils.dp2px(3), BannerUtils.dp2px(10))\n          .setHolderCreator(() -> new ImageResourceViewHolder(0))\n          .create(mDrawableList)\n```\n通过5行代码就轻松的实现了上图【Dash】仿支付宝的Indicator样式（大家可以留意一下支付宝的轮播Indicator，挺有意思）。\n\n关于自定义IndicatorView将会放在后边章节详细讲解。\n\n\n## 2.setPageStyle\n\n通过setPageStyle(int)一行代码开启一屏三页模式，一屏三页模式下目前有三种样式，分别如下图所示：\n\n| MULTI_PAGE |MULTI_PAGE_SCALE | MULTI_PAGE_OVERLAP |\n|--|--|--|\n|![MULTI_PAGE ](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMS8xNS8xNmU2ZjNjMTdhZDcyMGMx?x-oss-process=image/format,png)|![MULTI_PAGE_SCALE ](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMS8xNS8xNmU2ZjNjMTdiODNhOTQ4?x-oss-process=image/format,png)|![MULTI_PAGE_OVERLAP ](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMS8xNS8xNmU2ZjNjMTdjM2QwOWVh?x-oss-process=image/format,png)|\n代码演示：\n```\n    mViewPager.setPageStyle(PageStyle.MULTI_PAGE)\n              .setPageMargin(BannerUtils.dp2px(10))\n              .setRevealWidth(BannerUtils.dp2px(10))\n              .setHolderCreator(() -> new ImageResourceViewHolder(BannerUtils.dp2px(5)))\n              .create(mDrawableList);\n```\n同样通过短短5行代码就实现了上图【MULTI_PAGE】的效果，简单好用！\n\n## 3.如何实现指示器位置任意摆放？\n我们看到上面图表中MULTI_PAGE_OVERLAP模式下指示器显示到了Banner的下边。这种效果该怎么实现呢？其实BannerViewPager是支持把Indicator摆放在任意位置的。之所以能如此强大是因为我们通过自定义指示器替换了内置的IndicatorView，也就是说此时的IndicatorView已经脱离了BannerViewPager,也就理所当然的可以放在任意位置了。接下来通过代码来看下如何实现：\n\n### (1)Xml布局文件如下\n```\n<RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n\n    <com.zhpan.bannerview.BannerViewPager\n        android:id=\"@+id/banner_view\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"180dp\"\n        android:layout_marginTop=\"20dp\"\n        app:bvp_page_style=\"multi_page\" />\n\n    <com.zhpan.bannerview.indicator.CircleIndicatorView\n        android:id=\"@+id/indicator_view\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:layout_below=\"@id/banner_view\"\n        android:layout_centerHorizontal=\"true\"\n        android:layout_marginTop=\"10dp\" />\n </RelativeLayout>\n\n```\n### (2)通过setIndicatorView(IIndicator)替换内部指示器\n\n```\n        CircleIndicatorView indicatorView = findViewById(R.id.indicator_view);\n \tmViewPager.setIndicatorView(indicatorView)\n                  .setIndicatorColor(Color.parseColor(\"#888888\"),\n                       Color.parseColor(\"#118EEA\"))\n                  .setHolderCreator(() -> new ImageResourceViewHolder(BannerUtils.dp2px(5)))\n                  .create(mDrawableList);\n```\nCircleIndicatorView是什么？其实他就是内置在BannerViewPager中的指示器，现在你只需要把它同BannerViewPager放在同一个布局文件中就可以了。又是仅仅通过一行代码就完成了对内部指示器的替换，不知道你看完之后是否会拍案叫绝，竟然如此简单！\n\n## 4.setIndicatorSlideMode\n我们应该见过很多App轮播图的指示器都会跟随页面一起滑动。BannerViewPager自然也不会少了这个功能。通过setIndicatorSlideMode(int)一行代码就可以轻松切换到下图（SMOOTH）的效果。\n\n| NORMAL | SMOOTH |\n|--|--|\n|![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMS8xNS8xNmU2ZjNjMWIwM2U5NWE5?x-oss-process=image/format,png)|![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMS8xNS8xNmU2ZjNjMWI0MGMwMzAz?x-oss-process=image/format,png)|\n\n代码实现仍然非常简单，使用BannerViewPager你只需要记住一个核心--Only One Line！所以演示代码不再贴出你应该不会揍我吧？\n\n![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMS8xNi8xNmU3NGE4NThhY2ZmZTg2?x-oss-process=image/format,png)\n\n## 5.setPageTransformerStyle\n\n关于Transform更好的方式应该是留给开发者自己去实现，因此BannerViewPager中目前仅内置了四种常用Transform样式，如果不能满足需求，可以通过BannerViewPager的setPageTransformer(ViewPager.PageTransformer transformer)设置自定义的Transform。四种内置Transform样式如下：\n\n| STACK | ACCORDION  | DEPTH | ROTATE  |  \n|--|--|--|--|\n|![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMS8xNy8xNmU3OTkyZGZmMTA5MWYz?x-oss-process=image/format,png)|![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMS8xNy8xNmU3OTkzNjI4NGU2MThm?x-oss-process=image/format,png)|![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMS8xNy8xNmU3OTk0MzBhYThmYTFl?x-oss-process=image/format,png)|![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMS8xNy8xNmU3OTk0YmQ2MzlmYjAw?x-oss-process=image/format,png)|\n\n当然，BannerViewPager的功能并不仅仅局限于此，更多功能就不再演示，可以看下面所有开放的API接口。\n\n\n## 6.BannerViewPager开放的API\n\nBannerViewPager开放了众多API,以供满足不同的需求，具体如下表：\n\n| 方法名 | 方法描述 | 说明 |\n|--|--|--|\n| BannerViewPager<T, VH> setCanLoop(boolean canLoop) | 是否开启循环 | 默认值true|\n| BannerViewPager<T, VH> setAutoPlay(boolean autoPlay) | 是否开启自动轮播 | 默认值true|\n| BannerViewPager<T, VH> setInterval(int interval) | 自动轮播时间间隔 |单位毫秒，默认值3000  |\n| BannerViewPager<T, VH> setScrollDuration(int scrollDuration) | 设置页面滚动时间 | 设置页面滚动时间 |单位毫秒，默认值800  |\n| BannerViewPager<T, VH> setRoundCorner(int radius) | 设置圆角 |默认无圆角 需要SDK_INT>=LOLLIPOP(API 21)  |\n| BannerViewPager<T, VH> setOnPageClickListener(OnPageClickListener onPageClickListener) | 设置页面点击事件 |  |\n| BannerViewPager<T, VH> setHolderCreator(HolderCreator\\<VH> holderCreator) |设置HolderCreator  |必须设置HolderCreator，否则会抛出NullPointerException|\n| BannerViewPager<T, VH> setIndicatorVisibility(@Visibility int visibility) | indicator vibility |默认值VISIBLE 2.4.2 新增|\n| BannerViewPager<T, VH> setIndicatorStyle(int indicatorStyle) | 设置指示器样式 | 可选枚举(CIRCLE, DASH) 默认CIRCLE  |\n| BannerViewPager<T, VH> setIndicatorGravity(int gravity) | 指示器位置 |可选值(CENTER、START、END)默认值CENTER |\n| BannerViewPager<T, VH> setIndicatorColor(int normalColor,int checkedColor) | 指示器圆点颜色 |normalColor：未选中时颜色默认\"#8C6C6D72\"， checkedColor：选中时颜色 默认\"#8C18171C\" |\n| BannerViewPager<T, VH> setIndicatorSlideMode(int slideMode)  | 设置Indicator滑动模式 | 可选（NORMAL、SMOOTH），默认值SMOOTH  |\n| BannerViewPager<T, VH> setIndicatorRadius(int radius) | 设置指示器圆点半径 | 默认值4dp|\n| BannerViewPager<T, VH> setIndicatorRadius(int normalRadius,int checkRadius)  |设置指示器圆点半径  |  normalRadius:未选中时半径  checkedRadius:选中时的半径,默认值4dp |\n| BannerViewPager<T, VH> setIndicatorWidth(int indicatorWidth) | 设置指示器宽度，如果是圆形指示器，则为直径 |  默认值8dp|\n| BannerViewPager<T, VH> setIndicatorWidth(int normalWidth, int checkWidth) | 设置指示器宽度，如果是圆形指示器，则为直径 | 默认值8dp |\n| BannerViewPager<T, VH> setIndicatorHeight(int indicatorHeight) | 设置指示器高度，仅在Indicator样式为DASH时有效 | 默认值normalIndicatorWidth/2 |\n| BannerViewPager<T, VH> setIndicatorGap(int indicatorMargin) | 指示器圆点间距| 默认值为指示器宽度（或者是圆的直径）|\n| BannerViewPager<T, VH> setIndicatorView(IIndicator indicatorView) | 设置自定义指示器| |\n| BannerViewPager<T, VH> setPageTransformerStyle(int style) | 设置页面Transformer内置样式 |  |\n| BannerViewPager<T, VH> setCurrentItem(int item) | Set the currently selected page. | 2.3.5新增 |\n| void getCurrentItem() | 获取当前position | 2.3.5新增 |\n| BannerViewPager<T, VH> setPageStyle(PageStyle pageStyle) | 设置页面样式 | 2.4.0新增 可选（MULTI_PAGE、NORMAL）MULTI_PAGE：一屏多页样式 |\n| BannerViewPager<T, VH> setPageMargin(int pageMargin) | 设置页面间隔 | 2.4.0新增 |\n| BannerViewPager<T, VH> setIndicatorMargin(int left, int top, int right, int bottom) | 设置Indicator边距 | 2.4.1新增 |\n| BannerViewPager<T, VH> setOnPageChangeListener(OnPageChangeListener l) | 页面改变的监听事件 | 2.4.3新增 |\n| void startLoop() |开启自动轮播 | 初始化BannerViewPager时不必调用该方法,设置setAutoPlay后会调用startLoop() |\n| void stopLoop() | 停止自动轮播 | 如果开启自动轮播，为避免内存泄漏需要在onStop()或onDestroy中调用此方法 |\n| List\\<T> getList() | 获取Banner中的集合数据 |  |\n| void create(List<T> list) |初始化并构造BannerViewPager  |必须调用，否则前面设置的参数无效  |\n\n## 7.BannerViewPager支持的attrs\n你也可以通过xml来设置BannerViewPager，xml支持的attrs如下:\n| Attributes | format | description |\n|--|--|--|\n| bvp_interval | integer | 自动轮播时间间隔 |\n| bvp_scroll_duration | integer | 页面切换时滑动时间|\n| bvp_can_loop | boolean| 是否循环 |\n| bvp_auto_play | boolean | 是否自动播放  |\n| bvp_indicator_checked_color | color | indicator选中时颜色 |\n| bvp_indicator_normal_color | color | indicator未选中时颜色 |\n| bvp_indicator_radius | dimension | indicator圆点半径或者Dash模式的1/2宽度  |\n| bvp_round_corner| dimension  | Banner圆角大小 |\n| bvp_page_margin | dimension | 页面item间距 |\n| bvp_reveal_width | dimension | 一屏多页模式下两边item漏出的宽度 |\n| bvp_indicator_style | enum | indicator样式(circle/dash)  |\n| bvp_indicator_slide_mode | enum | indicator滑动模式(normal/smooth) |\n| bvp_indicator_gravity | enum | indicator位置(center/start/end) |\n| bvp_page_style | enum | page样式(normal/multi_page/multi_page_overlap/multi_page_scale) |\n| bvp_transformer_style | enum | transform样式(normal/depth/stack/accordion) |\n| bvp_indicator_visibility| enum | indicator visibility(visible/gone/invisible) |\n\n\n# 二、BannerViewPager详细使用说明\n  \n\n## 1.gradle中添加依赖\n\n如果您已迁移到AndroidX请使用latestVersion(>=2.4.3.1)\n```\nimplementation 'com.zhpan.library:bannerview:latestVersion'\n\n```\n如果未迁移到AndroidX请使用（非Androidx的包托管在JCenter上）：\n```\nimplementation 'com.zhpan.library:bannerview:2.4.3.1'\n```\n\n## 2. 在xml文件中添加如下代码：\n\n```\n    <com.zhpan.bannerview.BannerViewPager\n            android:id=\"@+id/banner_view\"\n            android:layout_width=\"match_parent\"\n            android:layout_margin=\"10dp\"\n            android:layout_height=\"160dp\" />\n```\n## 3.Banner的Item页面布局\n\n```\n<RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"wrap_content\">\n\n    <ImageView\n        android:id=\"@+id/banner_image\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"match_parent\"\n        android:scaleType=\"centerCrop\" />\n\n    <LinearLayout\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\"\n        android:layout_alignParentBottom=\"true\"\n        android:background=\"#66000000\"\n        android:gravity=\"center_vertical\">\n\n        <TextView\n            android:id=\"@+id/tv_describe\"\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"match_parent\"\n            android:layout_gravity=\"center_vertical\"\n            android:layout_marginStart=\"15dp\"\n            android:gravity=\"center_vertical\"\n            android:paddingTop=\"5dp\"\n            android:paddingBottom=\"5dp\"\n            android:textColor=\"#FFFFFF\"\n            android:textSize=\"16sp\" />\n    </LinearLayout>\n\n</RelativeLayout>\n```\n\n## 4.自定义ViewHolder\n\n```\npublic class NetViewHolder implements ViewHolder<BannerData> {\n    private ImageView mImageView;\n    private TextView mTextView;\n\n    @Override\n    public View createView(ViewGroup viewGroup, Context context, int position) {\n        View view = LayoutInflater.from(context).inflate(R.layout.item_net, viewGroup, false);\n        mImageView = view.findViewById(R.id.banner_image);\n        mTextView = view.findViewById(R.id.tv_describe);\n        return view;\n    }\n\n    @Override\n    public void onBind(Context context, BannerData data, int position, int size) {\n        ImageLoaderOptions options = new ImageLoaderOptions.Builder().into(mImageView).load(data.getImagePath()).placeHolder(R.drawable.placeholder).build();\n        ImageLoaderManager.getInstance().loadImage(options);\n        mTextView.setText(data.getTitle());\n    }\n}\n```\n\n## 5.BannerViewPager参数配置\n\n```\n    private BannerViewPager<BannerData, NetViewHolder> mBannerViewPager;\n\tprivate void initViewPager() {\n             mBannerViewPager = findViewById(R.id.banner_view);\n             mBannerViewPager.showIndicator(true)\n                .setInterval(3000)\n                .setCanLoop(false)\n                .setAutoPlay(true)\n                .setRoundCorner(DpUtils.dp2px(7))\n                .setIndicatorColor(Color.parseColor(\"#935656\"), Color.parseColor(\"#FF4C39\"))\n                .setIndicatorGravity(BannerViewPager.END)\n                .setScrollDuration(1000).setHolderCreator(NetViewHolder::new)\n                .setOnPageClickListener(position -> {\n                    BannerData bannerData = mBannerViewPager.getList().get(position);\n                    Toast.makeText(NetworkBannerActivity.this,\n                            \"点击了图片\" + position + \" \" + bannerData.getDesc(), Toast.LENGTH_SHORT).show();\n\n                }).create(mList);\n        }\n```\n\n### 6.开启与停止轮播\n\n***2.5.0之后版本无需自行在Activity或Fragment中管理stopLoop和startLoop方法，但这两个方法依旧保留对外开发***\n\n~~如果开启了自动轮播功能，请务必在onDestroy中停止轮播，以免出现内存泄漏。~~\n\n```\n\t@Override\n    protected void onDestroy() {\n        super.onDestroy();\n        if (mBannerViewPager != null)\n    \t\tmViewpager.stopLoop();\n    }\n```\n~~为了节省性能也可以在onStop中停止轮播，在onResume中开启轮播：~~\n\n```\n    @Override\n    protected void onStop() {\n        super.onStop();\n        if (mBannerViewPager != null)\n            mBannerViewPager.stopLoop();\n    }\n\n    @Override\n    protected void onResume() {\n        super.onResume();\n        if (mBannerViewPager != null)\n            mBannerViewPager.startLoop();\n    }\n```\n\n# 三、高级功能---自定义IndicatorView\n因为指示器的样式千变万化,BannerViewPager中不可能内置所有的样式，因此我将定义权限交给了开发者自己来实现，这样就可以满足所有开发者的需求了。但是自定义IndicatorView需要有一定的自定义View基础，尽管我已经在BaseIndicatorView中处理了许多逻辑，但是还是要开发者根据自身需求进行Indicator的绘制。好了，下面就让我们来看看如何实现自定义IndicatorView吧。\n\n关于自定义IndicatorView其实我们在第一节中讲解Indicator摆放位置时已经提到了，就是通过setIndicator(IIndicator)来替换内部的指示器。当然，这个方法接收的参数不仅仅是内置的两个IndicatorView，它还可以是我们自己实现的Indicator。前提只需要继承BaseIndicatorView或者继承View并实现IIndicator，然后根据需求绘制即可。\n\n### (1)认识BaseIndicatorView\n\nBaseIndicatorView是BannerViewPager库中的一个类，它继承自View并实现了IIndicator接口。在这个类中存储了BannerViewPager的许多参数信息，比如页面个数(pageSize)、页面滑动进度(slideProgress)以及当前页面位置(currentPosition)等，这些都是在绘制IndicatorView时会用到的信息。有了这些参数之后我们就可以比较轻松的去绘制指示器了。如果你觉得我这些数据计算的不够精确或者计算存在错误，那么你大可以自己实现IIndicator接口自行计算。本文我会通过继承BaseIndicatorView的方式来实现一个自定义指示器的例子。\n你可以点击链接查看[BaseIndicatorView](https://github.com/zhpanvip/BannerViewPager/blob/master/bannerview/src/main/java/com/zhpan/bannerview/indicator/BaseIndicatorView.java)的完整代码。\n\n### (2)开启自定义IndicatorView之路\n\n好了，接下来我们就来完成一个如下图所示的自定义IndicatorView吧！\n\n![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMS8xNi8xNmU3NDdhMGJmZDc3MGE1?x-oss-process=image/format,png)\n\n \n**新建一个FigureIndicatorView类并继承BaseIndicatorView**\n\n```\npublic class FigureIndicatorView extends BaseIndicatorView {\n\n    private int radius = DpUtils.dp2px(20);\n\n    private int backgroundColor = Color.parseColor(\"#88FF5252\");\n\n    private int textColor = Color.WHITE;\n\n    private int textSize=DpUtils.dp2px(13);\n\n    // ...省略无关代码\n\n    @Override\n    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n        super.onMeasure(widthMeasureSpec, heightMeasureSpec);\n        setMeasuredDimension(2 * radius, 2 * radius);\n    }\n\n    @Override\n    protected void onDraw(Canvas canvas) {\n        super.onDraw(canvas);\n        mPaint.setColor(backgroundColor);\n        canvas.drawCircle(getWidth() / 2, getHeight() / 2, radius, mPaint);\n        mPaint.setColor(textColor);\n        mPaint.setTextSize(textSize);\n        String text = currentPosition + 1 + \"/\" + pageSize;\n        int textWidth = (int) mPaint.measureText(text);\n        Paint.FontMetricsInt fontMetricsInt = mPaint.getFontMetricsInt();\n        int baseline = (getMeasuredHeight() - fontMetricsInt.bottom + fontMetricsInt.top) / 2 - fontMetricsInt.top;\n        canvas.drawText(text, (getWidth() - textWidth) / 2, baseline, mPaint);\n    }\n\n    public void setRadius(int radius) {\n        this.radius = radius;\n    }\n\n    @Override\n    public void setBackgroundColor(@ColorInt int backgroundColor) {\n        this.backgroundColor = backgroundColor;\n    }\n\n    public void setTextSize(int textSize) {\n        this.textSize = textSize;\n    }\n    // ...省略无关代码\n}\n```\n有自定义View基础的同学应该能很轻松的看懂上边的代码。首先通过onMeasure()方法测量了View的大小，接下来就是在onDraw方法中绘制圆和文字了。很容易就实现了一个自定义的IndicatorView。当然，这个例子本身就比较简单。如果你需要绘制比较复杂且带有动画的Indicator，可以参考源码中的CircleIndicatorView和DashIndicatorView，或许它能给你一些灵感。\n### (3)设置自定义指示器\n接下来就将我们自己绘制的指示器设置到BannerViewPager中吧！\n```\n    FigureIndicatorView indicatorView = new FigureIndicatorView(mContext);\n    indicatorView.setRadius(BannerUtils.dp2px(18));\n    indicatorView.setTextSize(BannerUtils.dp2px(13));\n    indicatorView.setBackgroundColor(Color.parseColor(\"#aa118EEA\"));\n    \n    mViewPager.setIndicatorGravity(IndicatorGravity.END)\n              .setIndicatorView(indicatorView)\n              .setHolderCreator(() -> new ImageResourceViewHolder(0))\n              .create(mDrawableList);    \n        \n```\n依然如此潇洒自然！好了，关于BannerViewPager的介绍今天就讲解到这里了。接下来的一篇文章将会对BannerViewPager的源码进行剖析，了解下它是如何通过简单的Api实现来实现复杂的功能的。\n\n都看到这里了，确定不到GitHub点个星再走？源码已放到文章末尾。如果有好的Idea也欢迎Pull Request。\n\n[《BannerViewPager源码解析》](https://juejin.im/post/5d74d3faf265da03b5747015)\n\n\n[源码下载](https://github.com/zhpanvip/BannerViewPager)\n\n\n**文章上次更新2019.11.16**\n\n","slug":"19.打造一个丝滑般自动轮播无限循环Android库(一)","published":1,"updated":"2020-08-29T01:51:55.935Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckegm5nsn001bdwozdfm1huu6","content":"<p>本文同步发布在<a href=\"https://juejin.im/post/5d6bce24f265da03db0790d1\">掘金</a>，如需转载请注明出处。</p>\n<p>BannerViewPager系列文章共三篇，此文为第一篇，另外两篇参看下面链接：</p>\n<p><a href=\"https://blog.csdn.net/qq_20521573/article/details/100609592\">BannerViewPager源码剖析</a></p>\n<p><a href=\"https://blog.csdn.net/qq_20521573/article/details/103216593\">剖析BannerViewPager中Indicator的设计思想</a></p>\n<p>最近公司项目在升级AndroidX，由于项目中用到的一些比较老的库都已停止更新维护，因此需要将这些库替换掉，其中就包括自动轮播的Banner库。恰逢笔者在之前写过一个轮播图，因此就在此基础上重构，打造出了一个全新的支持多种样式的轮播库—<a href=\"https://github.com/zhpanvip/BannerViewPager/tree/master\">BannerViewPager</a>。个人觉得<a href=\"https://github.com/zhpanvip/BannerViewPager/tree/master\">BannerViewPager</a>要优于其它开源的Banner库，不仅仅是因为它拥有简洁高效的代码，更是因为它高度的可定制性。<a href=\"https://github.com/zhpanvip/BannerViewPager/tree/master\">BannerViewPager</a>不仅支持任意的页面布局，而且可以支持任意的Indicator样式。甚至连Indicator的位置都可以做到任意摆放。是的，就是这么随心所欲。无图言叼，还是先通过图片和代码一览BannerViewPager的功能吧(多图预警)。</p>\n<h1 id=\"一、BannerViewPager效果预览及API介绍\"><a href=\"#一、BannerViewPager效果预览及API介绍\" class=\"headerlink\" title=\"一、BannerViewPager效果预览及API介绍\"></a>一、BannerViewPager效果预览及API介绍</h1><p>由于GIF图片质量问题，下面的预览图并不清晰，大家可以点击下面链接或者扫描二维码下载Apk体验。Apk存放在github上，下载速度可能会比较慢。</p>\n<p> <a href=\"https://github.com/zhpanvip/BannerViewPager/raw/master/download/app.apk\">点击或扫描二维码下载apk</a></p>\n<p><img src=\"https://raw.githubusercontent.com/zhpanvip/Resource/master/image/banner/qrcode.png\"></p>\n<h2 id=\"1-setIndicatorStyle（开局就放王炸？）\"><a href=\"#1-setIndicatorStyle（开局就放王炸？）\" class=\"headerlink\" title=\"1.setIndicatorStyle（开局就放王炸？）\"></a>1.setIndicatorStyle（开局就放王炸？）</h2><p>BannerViewPager目前内置了CIRCLE和DASH两种样式的指示器,通过setIndicatorStyle(int)一行代码就可以切换指示器的样式。当然，如果内置样式不满足你的需求。BannerViewPager还提供了自定义指示器的功能。只要继承BaseIndicatorView或者实现IIndicator接口，并重写相应方法，就可以通过自定义View为所欲为的打造任意的Indicator了。如下图【自定义】就是自己实现的指示器样式。</p>\n<table>\n<thead>\n<tr>\n<th>CIRCLE</th>\n<th>DASH</th>\n<th>自定义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMS8xNi8xNmU3NGNhODFlOWM4OGI5?x-oss-process=image/format,png\"></td>\n<td><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMS8xNi8xNmU3NGNiNGU3M2YyM2U3?x-oss-process=image/format,png\"></td>\n<td><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMS8xNi8xNmU3NGNjMjE2OWNiOTBi?x-oss-process=image/format,png\"></td>\n</tr>\n</tbody></table>\n<p>下面通过代码演示如何切换指示器：</p>\n<pre><code class=\"hljs reasonml\">mViewPager.set<span class=\"hljs-constructor\">IndicatorStyle(IndicatorStyle.DASH)</span>\n          .set<span class=\"hljs-constructor\">IndicatorHeight(BannerUtils.<span class=\"hljs-params\">dp2px</span>(3f)</span>)\n          .set<span class=\"hljs-constructor\">IndicatorWidth(BannerUtils.<span class=\"hljs-params\">dp2px</span>(3)</span>, <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">BannerUtils</span>.</span></span>dp2px(<span class=\"hljs-number\">10</span>))\n          .set<span class=\"hljs-constructor\">HolderCreator(()</span> -&gt; <span class=\"hljs-keyword\">new</span> <span class=\"hljs-constructor\">ImageResourceViewHolder(0)</span>)\n          .create(mDrawableList)</code></pre>\n<p>通过5行代码就轻松的实现了上图【Dash】仿支付宝的Indicator样式（大家可以留意一下支付宝的轮播Indicator，挺有意思）。</p>\n<p>关于自定义IndicatorView将会放在后边章节详细讲解。</p>\n<h2 id=\"2-setPageStyle\"><a href=\"#2-setPageStyle\" class=\"headerlink\" title=\"2.setPageStyle\"></a>2.setPageStyle</h2><p>通过setPageStyle(int)一行代码开启一屏三页模式，一屏三页模式下目前有三种样式，分别如下图所示：</p>\n<table>\n<thead>\n<tr>\n<th>MULTI_PAGE</th>\n<th>MULTI_PAGE_SCALE</th>\n<th>MULTI_PAGE_OVERLAP</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMS8xNS8xNmU2ZjNjMTdhZDcyMGMx?x-oss-process=image/format,png\" alt=\"MULTI_PAGE \"></td>\n<td><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMS8xNS8xNmU2ZjNjMTdiODNhOTQ4?x-oss-process=image/format,png\" alt=\"MULTI_PAGE_SCALE \"></td>\n<td><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMS8xNS8xNmU2ZjNjMTdjM2QwOWVh?x-oss-process=image/format,png\" alt=\"MULTI_PAGE_OVERLAP \"></td>\n</tr>\n<tr>\n<td>代码演示：</td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<pre><code class=\"hljs css\"><span class=\"hljs-selector-tag\">mViewPager</span><span class=\"hljs-selector-class\">.setPageStyle</span>(<span class=\"hljs-selector-tag\">PageStyle</span><span class=\"hljs-selector-class\">.MULTI_PAGE</span>)\n          <span class=\"hljs-selector-class\">.setPageMargin</span>(<span class=\"hljs-selector-tag\">BannerUtils</span><span class=\"hljs-selector-class\">.dp2px</span>(10))\n          <span class=\"hljs-selector-class\">.setRevealWidth</span>(<span class=\"hljs-selector-tag\">BannerUtils</span><span class=\"hljs-selector-class\">.dp2px</span>(10))\n          <span class=\"hljs-selector-class\">.setHolderCreator</span>(() <span class=\"hljs-selector-tag\">-</span>&gt; <span class=\"hljs-selector-tag\">new</span> <span class=\"hljs-selector-tag\">ImageResourceViewHolder</span>(<span class=\"hljs-selector-tag\">BannerUtils</span><span class=\"hljs-selector-class\">.dp2px</span>(5)))\n          <span class=\"hljs-selector-class\">.create</span>(<span class=\"hljs-selector-tag\">mDrawableList</span>);</code></pre>\n<p>同样通过短短5行代码就实现了上图【MULTI_PAGE】的效果，简单好用！</p>\n<h2 id=\"3-如何实现指示器位置任意摆放？\"><a href=\"#3-如何实现指示器位置任意摆放？\" class=\"headerlink\" title=\"3.如何实现指示器位置任意摆放？\"></a>3.如何实现指示器位置任意摆放？</h2><p>我们看到上面图表中MULTI_PAGE_OVERLAP模式下指示器显示到了Banner的下边。这种效果该怎么实现呢？其实BannerViewPager是支持把Indicator摆放在任意位置的。之所以能如此强大是因为我们通过自定义指示器替换了内置的IndicatorView，也就是说此时的IndicatorView已经脱离了BannerViewPager,也就理所当然的可以放在任意位置了。接下来通过代码来看下如何实现：</p>\n<h3 id=\"1-Xml布局文件如下\"><a href=\"#1-Xml布局文件如下\" class=\"headerlink\" title=\"(1)Xml布局文件如下\"></a>(1)Xml布局文件如下</h3><pre><code class=\"hljs stylus\">&lt;RelativeLayout xmlns:android=<span class=\"hljs-string\">&quot;http://schemas.android.com/apk/res/android&quot;</span>\n    xmlns:app=<span class=\"hljs-string\">&quot;http://schemas.android.com/apk/res-auto&quot;</span>\n    android:layout_width=<span class=\"hljs-string\">&quot;match_parent&quot;</span>\n    android:layout_height=<span class=\"hljs-string\">&quot;match_parent&quot;</span>&gt;\n\n    &lt;com<span class=\"hljs-selector-class\">.zhpan</span><span class=\"hljs-selector-class\">.bannerview</span>.BannerViewPager\n        android:id=<span class=\"hljs-string\">&quot;@+id/banner_view&quot;</span>\n        android:layout_width=<span class=\"hljs-string\">&quot;match_parent&quot;</span>\n        android:layout_height=<span class=\"hljs-string\">&quot;180dp&quot;</span>\n        android:layout_marginTop=<span class=\"hljs-string\">&quot;20dp&quot;</span>\n        app:bvp_page_style=<span class=\"hljs-string\">&quot;multi_page&quot;</span> /&gt;\n\n    &lt;com<span class=\"hljs-selector-class\">.zhpan</span><span class=\"hljs-selector-class\">.bannerview</span><span class=\"hljs-selector-class\">.indicator</span>.CircleIndicatorView\n        android:id=<span class=\"hljs-string\">&quot;@+id/indicator_view&quot;</span>\n        android:layout_width=<span class=\"hljs-string\">&quot;wrap_content&quot;</span>\n        android:layout_height=<span class=\"hljs-string\">&quot;wrap_content&quot;</span>\n        android:layout_below=<span class=\"hljs-string\">&quot;@id/banner_view&quot;</span>\n        android:layout_centerHorizontal=<span class=\"hljs-string\">&quot;true&quot;</span>\n        android:layout_marginTop=<span class=\"hljs-string\">&quot;10dp&quot;</span> /&gt;\n &lt;/RelativeLayout&gt;\n</code></pre>\n<h3 id=\"2-通过setIndicatorView-IIndicator-替换内部指示器\"><a href=\"#2-通过setIndicatorView-IIndicator-替换内部指示器\" class=\"headerlink\" title=\"(2)通过setIndicatorView(IIndicator)替换内部指示器\"></a>(2)通过setIndicatorView(IIndicator)替换内部指示器</h3><pre><code class=\"hljs reasonml\">      CircleIndicatorView indicatorView = find<span class=\"hljs-constructor\">ViewById(R.<span class=\"hljs-params\">id</span>.<span class=\"hljs-params\">indicator_view</span>)</span>;\nmViewPager.set<span class=\"hljs-constructor\">IndicatorView(<span class=\"hljs-params\">indicatorView</span>)</span>\n                .set<span class=\"hljs-constructor\">IndicatorColor(Color.<span class=\"hljs-params\">parseColor</span>(<span class=\"hljs-string\">&quot;#888888&quot;</span>)</span>,\n                     <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">Color</span>.</span></span>parse<span class=\"hljs-constructor\">Color(<span class=\"hljs-string\">&quot;#118EEA&quot;</span>)</span>)\n                .set<span class=\"hljs-constructor\">HolderCreator(()</span> -&gt; <span class=\"hljs-keyword\">new</span> <span class=\"hljs-constructor\">ImageResourceViewHolder(BannerUtils.<span class=\"hljs-params\">dp2px</span>(5)</span>))\n                .create(mDrawableList);</code></pre>\n<p>CircleIndicatorView是什么？其实他就是内置在BannerViewPager中的指示器，现在你只需要把它同BannerViewPager放在同一个布局文件中就可以了。又是仅仅通过一行代码就完成了对内部指示器的替换，不知道你看完之后是否会拍案叫绝，竟然如此简单！</p>\n<h2 id=\"4-setIndicatorSlideMode\"><a href=\"#4-setIndicatorSlideMode\" class=\"headerlink\" title=\"4.setIndicatorSlideMode\"></a>4.setIndicatorSlideMode</h2><p>我们应该见过很多App轮播图的指示器都会跟随页面一起滑动。BannerViewPager自然也不会少了这个功能。通过setIndicatorSlideMode(int)一行代码就可以轻松切换到下图（SMOOTH）的效果。</p>\n<table>\n<thead>\n<tr>\n<th>NORMAL</th>\n<th>SMOOTH</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMS8xNS8xNmU2ZjNjMWIwM2U5NWE5?x-oss-process=image/format,png\"></td>\n<td><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMS8xNS8xNmU2ZjNjMWI0MGMwMzAz?x-oss-process=image/format,png\"></td>\n</tr>\n</tbody></table>\n<p>代码实现仍然非常简单，使用BannerViewPager你只需要记住一个核心–Only One Line！所以演示代码不再贴出你应该不会揍我吧？</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMS8xNi8xNmU3NGE4NThhY2ZmZTg2?x-oss-process=image/format,png\"></p>\n<h2 id=\"5-setPageTransformerStyle\"><a href=\"#5-setPageTransformerStyle\" class=\"headerlink\" title=\"5.setPageTransformerStyle\"></a>5.setPageTransformerStyle</h2><p>关于Transform更好的方式应该是留给开发者自己去实现，因此BannerViewPager中目前仅内置了四种常用Transform样式，如果不能满足需求，可以通过BannerViewPager的setPageTransformer(ViewPager.PageTransformer transformer)设置自定义的Transform。四种内置Transform样式如下：</p>\n<table>\n<thead>\n<tr>\n<th>STACK</th>\n<th>ACCORDION</th>\n<th>DEPTH</th>\n<th>ROTATE</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMS8xNy8xNmU3OTkyZGZmMTA5MWYz?x-oss-process=image/format,png\"></td>\n<td><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMS8xNy8xNmU3OTkzNjI4NGU2MThm?x-oss-process=image/format,png\"></td>\n<td><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMS8xNy8xNmU3OTk0MzBhYThmYTFl?x-oss-process=image/format,png\"></td>\n<td><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMS8xNy8xNmU3OTk0YmQ2MzlmYjAw?x-oss-process=image/format,png\"></td>\n</tr>\n</tbody></table>\n<p>当然，BannerViewPager的功能并不仅仅局限于此，更多功能就不再演示，可以看下面所有开放的API接口。</p>\n<h2 id=\"6-BannerViewPager开放的API\"><a href=\"#6-BannerViewPager开放的API\" class=\"headerlink\" title=\"6.BannerViewPager开放的API\"></a>6.BannerViewPager开放的API</h2><p>BannerViewPager开放了众多API,以供满足不同的需求，具体如下表：</p>\n<table>\n<thead>\n<tr>\n<th>方法名</th>\n<th>方法描述</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>BannerViewPager&lt;T, VH&gt; setCanLoop(boolean canLoop)</td>\n<td>是否开启循环</td>\n<td>默认值true</td>\n</tr>\n<tr>\n<td>BannerViewPager&lt;T, VH&gt; setAutoPlay(boolean autoPlay)</td>\n<td>是否开启自动轮播</td>\n<td>默认值true</td>\n</tr>\n<tr>\n<td>BannerViewPager&lt;T, VH&gt; setInterval(int interval)</td>\n<td>自动轮播时间间隔</td>\n<td>单位毫秒，默认值3000</td>\n</tr>\n<tr>\n<td>BannerViewPager&lt;T, VH&gt; setScrollDuration(int scrollDuration)</td>\n<td>设置页面滚动时间</td>\n<td>设置页面滚动时间</td>\n</tr>\n<tr>\n<td>BannerViewPager&lt;T, VH&gt; setRoundCorner(int radius)</td>\n<td>设置圆角</td>\n<td>默认无圆角 需要SDK_INT&gt;=LOLLIPOP(API 21)</td>\n</tr>\n<tr>\n<td>BannerViewPager&lt;T, VH&gt; setOnPageClickListener(OnPageClickListener onPageClickListener)</td>\n<td>设置页面点击事件</td>\n<td></td>\n</tr>\n<tr>\n<td>BannerViewPager&lt;T, VH&gt; setHolderCreator(HolderCreator&lt;VH&gt; holderCreator)</td>\n<td>设置HolderCreator</td>\n<td>必须设置HolderCreator，否则会抛出NullPointerException</td>\n</tr>\n<tr>\n<td>BannerViewPager&lt;T, VH&gt; setIndicatorVisibility(@Visibility int visibility)</td>\n<td>indicator vibility</td>\n<td>默认值VISIBLE 2.4.2 新增</td>\n</tr>\n<tr>\n<td>BannerViewPager&lt;T, VH&gt; setIndicatorStyle(int indicatorStyle)</td>\n<td>设置指示器样式</td>\n<td>可选枚举(CIRCLE, DASH) 默认CIRCLE</td>\n</tr>\n<tr>\n<td>BannerViewPager&lt;T, VH&gt; setIndicatorGravity(int gravity)</td>\n<td>指示器位置</td>\n<td>可选值(CENTER、START、END)默认值CENTER</td>\n</tr>\n<tr>\n<td>BannerViewPager&lt;T, VH&gt; setIndicatorColor(int normalColor,int checkedColor)</td>\n<td>指示器圆点颜色</td>\n<td>normalColor：未选中时颜色默认”#8C6C6D72”， checkedColor：选中时颜色 默认”#8C18171C”</td>\n</tr>\n<tr>\n<td>BannerViewPager&lt;T, VH&gt; setIndicatorSlideMode(int slideMode)</td>\n<td>设置Indicator滑动模式</td>\n<td>可选（NORMAL、SMOOTH），默认值SMOOTH</td>\n</tr>\n<tr>\n<td>BannerViewPager&lt;T, VH&gt; setIndicatorRadius(int radius)</td>\n<td>设置指示器圆点半径</td>\n<td>默认值4dp</td>\n</tr>\n<tr>\n<td>BannerViewPager&lt;T, VH&gt; setIndicatorRadius(int normalRadius,int checkRadius)</td>\n<td>设置指示器圆点半径</td>\n<td>normalRadius:未选中时半径  checkedRadius:选中时的半径,默认值4dp</td>\n</tr>\n<tr>\n<td>BannerViewPager&lt;T, VH&gt; setIndicatorWidth(int indicatorWidth)</td>\n<td>设置指示器宽度，如果是圆形指示器，则为直径</td>\n<td>默认值8dp</td>\n</tr>\n<tr>\n<td>BannerViewPager&lt;T, VH&gt; setIndicatorWidth(int normalWidth, int checkWidth)</td>\n<td>设置指示器宽度，如果是圆形指示器，则为直径</td>\n<td>默认值8dp</td>\n</tr>\n<tr>\n<td>BannerViewPager&lt;T, VH&gt; setIndicatorHeight(int indicatorHeight)</td>\n<td>设置指示器高度，仅在Indicator样式为DASH时有效</td>\n<td>默认值normalIndicatorWidth/2</td>\n</tr>\n<tr>\n<td>BannerViewPager&lt;T, VH&gt; setIndicatorGap(int indicatorMargin)</td>\n<td>指示器圆点间距</td>\n<td>默认值为指示器宽度（或者是圆的直径）</td>\n</tr>\n<tr>\n<td>BannerViewPager&lt;T, VH&gt; setIndicatorView(IIndicator indicatorView)</td>\n<td>设置自定义指示器</td>\n<td></td>\n</tr>\n<tr>\n<td>BannerViewPager&lt;T, VH&gt; setPageTransformerStyle(int style)</td>\n<td>设置页面Transformer内置样式</td>\n<td></td>\n</tr>\n<tr>\n<td>BannerViewPager&lt;T, VH&gt; setCurrentItem(int item)</td>\n<td>Set the currently selected page.</td>\n<td>2.3.5新增</td>\n</tr>\n<tr>\n<td>void getCurrentItem()</td>\n<td>获取当前position</td>\n<td>2.3.5新增</td>\n</tr>\n<tr>\n<td>BannerViewPager&lt;T, VH&gt; setPageStyle(PageStyle pageStyle)</td>\n<td>设置页面样式</td>\n<td>2.4.0新增 可选（MULTI_PAGE、NORMAL）MULTI_PAGE：一屏多页样式</td>\n</tr>\n<tr>\n<td>BannerViewPager&lt;T, VH&gt; setPageMargin(int pageMargin)</td>\n<td>设置页面间隔</td>\n<td>2.4.0新增</td>\n</tr>\n<tr>\n<td>BannerViewPager&lt;T, VH&gt; setIndicatorMargin(int left, int top, int right, int bottom)</td>\n<td>设置Indicator边距</td>\n<td>2.4.1新增</td>\n</tr>\n<tr>\n<td>BannerViewPager&lt;T, VH&gt; setOnPageChangeListener(OnPageChangeListener l)</td>\n<td>页面改变的监听事件</td>\n<td>2.4.3新增</td>\n</tr>\n<tr>\n<td>void startLoop()</td>\n<td>开启自动轮播</td>\n<td>初始化BannerViewPager时不必调用该方法,设置setAutoPlay后会调用startLoop()</td>\n</tr>\n<tr>\n<td>void stopLoop()</td>\n<td>停止自动轮播</td>\n<td>如果开启自动轮播，为避免内存泄漏需要在onStop()或onDestroy中调用此方法</td>\n</tr>\n<tr>\n<td>List&lt;T&gt; getList()</td>\n<td>获取Banner中的集合数据</td>\n<td></td>\n</tr>\n<tr>\n<td>void create(List<T> list)</td>\n<td>初始化并构造BannerViewPager</td>\n<td>必须调用，否则前面设置的参数无效</td>\n</tr>\n</tbody></table>\n<h2 id=\"7-BannerViewPager支持的attrs\"><a href=\"#7-BannerViewPager支持的attrs\" class=\"headerlink\" title=\"7.BannerViewPager支持的attrs\"></a>7.BannerViewPager支持的attrs</h2><p>你也可以通过xml来设置BannerViewPager，xml支持的attrs如下:<br>| Attributes | format | description |<br>|–|–|–|<br>| bvp_interval | integer | 自动轮播时间间隔 |<br>| bvp_scroll_duration | integer | 页面切换时滑动时间|<br>| bvp_can_loop | boolean| 是否循环 |<br>| bvp_auto_play | boolean | 是否自动播放  |<br>| bvp_indicator_checked_color | color | indicator选中时颜色 |<br>| bvp_indicator_normal_color | color | indicator未选中时颜色 |<br>| bvp_indicator_radius | dimension | indicator圆点半径或者Dash模式的1/2宽度  |<br>| bvp_round_corner| dimension  | Banner圆角大小 |<br>| bvp_page_margin | dimension | 页面item间距 |<br>| bvp_reveal_width | dimension | 一屏多页模式下两边item漏出的宽度 |<br>| bvp_indicator_style | enum | indicator样式(circle/dash)  |<br>| bvp_indicator_slide_mode | enum | indicator滑动模式(normal/smooth) |<br>| bvp_indicator_gravity | enum | indicator位置(center/start/end) |<br>| bvp_page_style | enum | page样式(normal/multi_page/multi_page_overlap/multi_page_scale) |<br>| bvp_transformer_style | enum | transform样式(normal/depth/stack/accordion) |<br>| bvp_indicator_visibility| enum | indicator visibility(visible/gone/invisible) |</p>\n<h1 id=\"二、BannerViewPager详细使用说明\"><a href=\"#二、BannerViewPager详细使用说明\" class=\"headerlink\" title=\"二、BannerViewPager详细使用说明\"></a>二、BannerViewPager详细使用说明</h1><h2 id=\"1-gradle中添加依赖\"><a href=\"#1-gradle中添加依赖\" class=\"headerlink\" title=\"1.gradle中添加依赖\"></a>1.gradle中添加依赖</h2><p>如果您已迁移到AndroidX请使用latestVersion(&gt;=2.4.3.1)</p>\n<pre><code class=\"hljs clean\"><span class=\"hljs-keyword\">implementation</span> <span class=\"hljs-string\">&#x27;com.zhpan.library:bannerview:latestVersion&#x27;</span>\n</code></pre>\n<p>如果未迁移到AndroidX请使用（非Androidx的包托管在JCenter上）：</p>\n<pre><code class=\"hljs clean\"><span class=\"hljs-keyword\">implementation</span> <span class=\"hljs-string\">&#x27;com.zhpan.library:bannerview:2.4.3.1&#x27;</span></code></pre>\n\n<h2 id=\"2-在xml文件中添加如下代码：\"><a href=\"#2-在xml文件中添加如下代码：\" class=\"headerlink\" title=\"2. 在xml文件中添加如下代码：\"></a>2. 在xml文件中添加如下代码：</h2><pre><code class=\"hljs routeros\">&lt;com.zhpan.bannerview.BannerViewPager\n        android:<span class=\"hljs-attribute\">id</span>=<span class=\"hljs-string\">&quot;@+id/banner_view&quot;</span>\n        android:<span class=\"hljs-attribute\">layout_width</span>=<span class=\"hljs-string\">&quot;match_parent&quot;</span>\n        android:<span class=\"hljs-attribute\">layout_margin</span>=<span class=\"hljs-string\">&quot;10dp&quot;</span>\n        android:<span class=\"hljs-attribute\">layout_height</span>=<span class=\"hljs-string\">&quot;160dp&quot;</span> /&gt;</code></pre>\n<h2 id=\"3-Banner的Item页面布局\"><a href=\"#3-Banner的Item页面布局\" class=\"headerlink\" title=\"3.Banner的Item页面布局\"></a>3.Banner的Item页面布局</h2><pre><code class=\"hljs xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">RelativeLayout</span> <span class=\"hljs-attr\">xmlns:android</span>=<span class=\"hljs-string\">&quot;http://schemas.android.com/apk/res/android&quot;</span></span>\n<span class=\"hljs-tag\">    <span class=\"hljs-attr\">android:layout_width</span>=<span class=\"hljs-string\">&quot;match_parent&quot;</span></span>\n<span class=\"hljs-tag\">    <span class=\"hljs-attr\">android:layout_height</span>=<span class=\"hljs-string\">&quot;wrap_content&quot;</span>&gt;</span>\n\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ImageView</span></span>\n<span class=\"hljs-tag\">        <span class=\"hljs-attr\">android:id</span>=<span class=\"hljs-string\">&quot;@+id/banner_image&quot;</span></span>\n<span class=\"hljs-tag\">        <span class=\"hljs-attr\">android:layout_width</span>=<span class=\"hljs-string\">&quot;match_parent&quot;</span></span>\n<span class=\"hljs-tag\">        <span class=\"hljs-attr\">android:layout_height</span>=<span class=\"hljs-string\">&quot;match_parent&quot;</span></span>\n<span class=\"hljs-tag\">        <span class=\"hljs-attr\">android:scaleType</span>=<span class=\"hljs-string\">&quot;centerCrop&quot;</span> /&gt;</span>\n\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">LinearLayout</span></span>\n<span class=\"hljs-tag\">        <span class=\"hljs-attr\">android:layout_width</span>=<span class=\"hljs-string\">&quot;match_parent&quot;</span></span>\n<span class=\"hljs-tag\">        <span class=\"hljs-attr\">android:layout_height</span>=<span class=\"hljs-string\">&quot;wrap_content&quot;</span></span>\n<span class=\"hljs-tag\">        <span class=\"hljs-attr\">android:layout_alignParentBottom</span>=<span class=\"hljs-string\">&quot;true&quot;</span></span>\n<span class=\"hljs-tag\">        <span class=\"hljs-attr\">android:background</span>=<span class=\"hljs-string\">&quot;#66000000&quot;</span></span>\n<span class=\"hljs-tag\">        <span class=\"hljs-attr\">android:gravity</span>=<span class=\"hljs-string\">&quot;center_vertical&quot;</span>&gt;</span>\n\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">TextView</span></span>\n<span class=\"hljs-tag\">            <span class=\"hljs-attr\">android:id</span>=<span class=\"hljs-string\">&quot;@+id/tv_describe&quot;</span></span>\n<span class=\"hljs-tag\">            <span class=\"hljs-attr\">android:layout_width</span>=<span class=\"hljs-string\">&quot;wrap_content&quot;</span></span>\n<span class=\"hljs-tag\">            <span class=\"hljs-attr\">android:layout_height</span>=<span class=\"hljs-string\">&quot;match_parent&quot;</span></span>\n<span class=\"hljs-tag\">            <span class=\"hljs-attr\">android:layout_gravity</span>=<span class=\"hljs-string\">&quot;center_vertical&quot;</span></span>\n<span class=\"hljs-tag\">            <span class=\"hljs-attr\">android:layout_marginStart</span>=<span class=\"hljs-string\">&quot;15dp&quot;</span></span>\n<span class=\"hljs-tag\">            <span class=\"hljs-attr\">android:gravity</span>=<span class=\"hljs-string\">&quot;center_vertical&quot;</span></span>\n<span class=\"hljs-tag\">            <span class=\"hljs-attr\">android:paddingTop</span>=<span class=\"hljs-string\">&quot;5dp&quot;</span></span>\n<span class=\"hljs-tag\">            <span class=\"hljs-attr\">android:paddingBottom</span>=<span class=\"hljs-string\">&quot;5dp&quot;</span></span>\n<span class=\"hljs-tag\">            <span class=\"hljs-attr\">android:textColor</span>=<span class=\"hljs-string\">&quot;#FFFFFF&quot;</span></span>\n<span class=\"hljs-tag\">            <span class=\"hljs-attr\">android:textSize</span>=<span class=\"hljs-string\">&quot;16sp&quot;</span> /&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">LinearLayout</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">RelativeLayout</span>&gt;</span></code></pre>\n\n<h2 id=\"4-自定义ViewHolder\"><a href=\"#4-自定义ViewHolder\" class=\"headerlink\" title=\"4.自定义ViewHolder\"></a>4.自定义ViewHolder</h2><pre><code class=\"hljs reasonml\">public <span class=\"hljs-keyword\">class</span> NetViewHolder implements ViewHolder&lt;BannerData&gt; &#123;\n    <span class=\"hljs-keyword\">private</span> ImageView mImageView;\n    <span class=\"hljs-keyword\">private</span> TextView mTextView;\n\n    @Override\n    public View create<span class=\"hljs-constructor\">View(ViewGroup <span class=\"hljs-params\">viewGroup</span>, Context <span class=\"hljs-params\">context</span>, <span class=\"hljs-params\">int</span> <span class=\"hljs-params\">position</span>)</span> &#123;\n        View view = <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">LayoutInflater</span>.</span></span>from(context).inflate(<span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">R</span>.</span></span>layout.item_net, viewGroup, <span class=\"hljs-literal\">false</span>);\n        mImageView = view.find<span class=\"hljs-constructor\">ViewById(R.<span class=\"hljs-params\">id</span>.<span class=\"hljs-params\">banner_image</span>)</span>;\n        mTextView = view.find<span class=\"hljs-constructor\">ViewById(R.<span class=\"hljs-params\">id</span>.<span class=\"hljs-params\">tv_describe</span>)</span>;\n        return view;\n    &#125;\n\n    @Override\n    public void on<span class=\"hljs-constructor\">Bind(Context <span class=\"hljs-params\">context</span>, BannerData <span class=\"hljs-params\">data</span>, <span class=\"hljs-params\">int</span> <span class=\"hljs-params\">position</span>, <span class=\"hljs-params\">int</span> <span class=\"hljs-params\">size</span>)</span> &#123;\n        ImageLoaderOptions options = <span class=\"hljs-keyword\">new</span> ImageLoaderOptions.<span class=\"hljs-constructor\">Builder()</span>.into(mImageView).load(data.get<span class=\"hljs-constructor\">ImagePath()</span>).place<span class=\"hljs-constructor\">Holder(R.<span class=\"hljs-params\">drawable</span>.<span class=\"hljs-params\">placeholder</span>)</span>.build<span class=\"hljs-literal\">()</span>;\n        <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">ImageLoaderManager</span>.</span></span>get<span class=\"hljs-constructor\">Instance()</span>.load<span class=\"hljs-constructor\">Image(<span class=\"hljs-params\">options</span>)</span>;\n        mTextView.set<span class=\"hljs-constructor\">Text(<span class=\"hljs-params\">data</span>.<span class=\"hljs-params\">getTitle</span>()</span>);\n    &#125;\n&#125;</code></pre>\n\n<h2 id=\"5-BannerViewPager参数配置\"><a href=\"#5-BannerViewPager参数配置\" class=\"headerlink\" title=\"5.BannerViewPager参数配置\"></a>5.BannerViewPager参数配置</h2><pre><code class=\"hljs arduino\">   <span class=\"hljs-keyword\">private</span> BannerViewPager&lt;BannerData, NetViewHolder&gt; mBannerViewPager;\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">initViewPager</span><span class=\"hljs-params\">()</span> </span>&#123;\n            mBannerViewPager = findViewById(R.id.banner_view);\n            mBannerViewPager.showIndicator(<span class=\"hljs-literal\">true</span>)\n               .setInterval(<span class=\"hljs-number\">3000</span>)\n               .setCanLoop(<span class=\"hljs-literal\">false</span>)\n               .setAutoPlay(<span class=\"hljs-literal\">true</span>)\n               .setRoundCorner(DpUtils.dp2px(<span class=\"hljs-number\">7</span>))\n               .setIndicatorColor(Color.parseColor(<span class=\"hljs-string\">&quot;#935656&quot;</span>), Color.parseColor(<span class=\"hljs-string\">&quot;#FF4C39&quot;</span>))\n               .setIndicatorGravity(BannerViewPager.END)\n               .setScrollDuration(<span class=\"hljs-number\">1000</span>).setHolderCreator(NetViewHolder::<span class=\"hljs-keyword\">new</span>)\n               .setOnPageClickListener(<span class=\"hljs-built_in\">position</span> -&gt; &#123;\n                   BannerData bannerData = mBannerViewPager.getList().<span class=\"hljs-built_in\">get</span>(<span class=\"hljs-built_in\">position</span>);\n                   Toast.makeText(NetworkBannerActivity.<span class=\"hljs-keyword\">this</span>,\n                           <span class=\"hljs-string\">&quot;点击了图片&quot;</span> + <span class=\"hljs-built_in\">position</span> + <span class=\"hljs-string\">&quot; &quot;</span> + bannerData.getDesc(), Toast.LENGTH_SHORT).show();\n\n               &#125;).create(mList);\n       &#125;</code></pre>\n\n<h3 id=\"6-开启与停止轮播\"><a href=\"#6-开启与停止轮播\" class=\"headerlink\" title=\"6.开启与停止轮播\"></a>6.开启与停止轮播</h3><p><strong><em>2.5.0之后版本无需自行在Activity或Fragment中管理stopLoop和startLoop方法，但这两个方法依旧保留对外开发</em></strong></p>\n<p><del>如果开启了自动轮播功能，请务必在onDestroy中停止轮播，以免出现内存泄漏。</del></p>\n<pre><code class=\"hljs aspectj\"><span class=\"hljs-meta\">@Override</span>\n   <span class=\"hljs-keyword\">protected</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onDestroy</span><span class=\"hljs-params\">()</span> </span>&#123;\n       <span class=\"hljs-keyword\">super</span>.onDestroy();\n       <span class=\"hljs-keyword\">if</span> (mBannerViewPager != <span class=\"hljs-keyword\">null</span>)\n   \t\tmViewpager.stopLoop();\n   &#125;</code></pre>\n<p><del>为了节省性能也可以在onStop中停止轮播，在onResume中开启轮播：</del></p>\n<pre><code class=\"hljs aspectj\"><span class=\"hljs-meta\">@Override</span>\n<span class=\"hljs-keyword\">protected</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onStop</span><span class=\"hljs-params\">()</span> </span>&#123;\n    <span class=\"hljs-keyword\">super</span>.onStop();\n    <span class=\"hljs-keyword\">if</span> (mBannerViewPager != <span class=\"hljs-keyword\">null</span>)\n        mBannerViewPager.stopLoop();\n&#125;\n\n<span class=\"hljs-meta\">@Override</span>\n<span class=\"hljs-keyword\">protected</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onResume</span><span class=\"hljs-params\">()</span> </span>&#123;\n    <span class=\"hljs-keyword\">super</span>.onResume();\n    <span class=\"hljs-keyword\">if</span> (mBannerViewPager != <span class=\"hljs-keyword\">null</span>)\n        mBannerViewPager.startLoop();\n&#125;</code></pre>\n\n<h1 id=\"三、高级功能—自定义IndicatorView\"><a href=\"#三、高级功能—自定义IndicatorView\" class=\"headerlink\" title=\"三、高级功能—自定义IndicatorView\"></a>三、高级功能—自定义IndicatorView</h1><p>因为指示器的样式千变万化,BannerViewPager中不可能内置所有的样式，因此我将定义权限交给了开发者自己来实现，这样就可以满足所有开发者的需求了。但是自定义IndicatorView需要有一定的自定义View基础，尽管我已经在BaseIndicatorView中处理了许多逻辑，但是还是要开发者根据自身需求进行Indicator的绘制。好了，下面就让我们来看看如何实现自定义IndicatorView吧。</p>\n<p>关于自定义IndicatorView其实我们在第一节中讲解Indicator摆放位置时已经提到了，就是通过setIndicator(IIndicator)来替换内部的指示器。当然，这个方法接收的参数不仅仅是内置的两个IndicatorView，它还可以是我们自己实现的Indicator。前提只需要继承BaseIndicatorView或者继承View并实现IIndicator，然后根据需求绘制即可。</p>\n<h3 id=\"1-认识BaseIndicatorView\"><a href=\"#1-认识BaseIndicatorView\" class=\"headerlink\" title=\"(1)认识BaseIndicatorView\"></a>(1)认识BaseIndicatorView</h3><p>BaseIndicatorView是BannerViewPager库中的一个类，它继承自View并实现了IIndicator接口。在这个类中存储了BannerViewPager的许多参数信息，比如页面个数(pageSize)、页面滑动进度(slideProgress)以及当前页面位置(currentPosition)等，这些都是在绘制IndicatorView时会用到的信息。有了这些参数之后我们就可以比较轻松的去绘制指示器了。如果你觉得我这些数据计算的不够精确或者计算存在错误，那么你大可以自己实现IIndicator接口自行计算。本文我会通过继承BaseIndicatorView的方式来实现一个自定义指示器的例子。<br>你可以点击链接查看<a href=\"https://github.com/zhpanvip/BannerViewPager/blob/master/bannerview/src/main/java/com/zhpan/bannerview/indicator/BaseIndicatorView.java\">BaseIndicatorView</a>的完整代码。</p>\n<h3 id=\"2-开启自定义IndicatorView之路\"><a href=\"#2-开启自定义IndicatorView之路\" class=\"headerlink\" title=\"(2)开启自定义IndicatorView之路\"></a>(2)开启自定义IndicatorView之路</h3><p>好了，接下来我们就来完成一个如下图所示的自定义IndicatorView吧！</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMS8xNi8xNmU3NDdhMGJmZDc3MGE1?x-oss-process=image/format,png\"></p>\n<p><strong>新建一个FigureIndicatorView类并继承BaseIndicatorView</strong></p>\n<pre><code class=\"hljs reasonml\">public <span class=\"hljs-keyword\">class</span> FigureIndicatorView extends BaseIndicatorView &#123;\n\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-built_in\">int</span> radius = <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">DpUtils</span>.</span></span>dp2px(<span class=\"hljs-number\">20</span>);\n\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-built_in\">int</span> backgroundColor = <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">Color</span>.</span></span>parse<span class=\"hljs-constructor\">Color(<span class=\"hljs-string\">&quot;#88FF5252&quot;</span>)</span>;\n\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-built_in\">int</span> textColor = Color.WHITE;\n\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-built_in\">int</span> textSize=<span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">DpUtils</span>.</span></span>dp2px(<span class=\"hljs-number\">13</span>);\n\n    <span class=\"hljs-comment\">// ...省略无关代码</span>\n\n    @Override\n    protected void on<span class=\"hljs-constructor\">Measure(<span class=\"hljs-params\">int</span> <span class=\"hljs-params\">widthMeasureSpec</span>, <span class=\"hljs-params\">int</span> <span class=\"hljs-params\">heightMeasureSpec</span>)</span> &#123;\n        super.on<span class=\"hljs-constructor\">Measure(<span class=\"hljs-params\">widthMeasureSpec</span>, <span class=\"hljs-params\">heightMeasureSpec</span>)</span>;\n        set<span class=\"hljs-constructor\">MeasuredDimension(2 <span class=\"hljs-operator\">*</span> <span class=\"hljs-params\">radius</span>, 2 <span class=\"hljs-operator\">*</span> <span class=\"hljs-params\">radius</span>)</span>;\n    &#125;\n\n    @Override\n    protected void on<span class=\"hljs-constructor\">Draw(Canvas <span class=\"hljs-params\">canvas</span>)</span> &#123;\n        super.on<span class=\"hljs-constructor\">Draw(<span class=\"hljs-params\">canvas</span>)</span>;\n        mPaint.set<span class=\"hljs-constructor\">Color(<span class=\"hljs-params\">backgroundColor</span>)</span>;\n        canvas.draw<span class=\"hljs-constructor\">Circle(<span class=\"hljs-params\">getWidth</span>()</span><span class=\"hljs-operator\"> / </span><span class=\"hljs-number\">2</span>, get<span class=\"hljs-constructor\">Height()</span><span class=\"hljs-operator\"> / </span><span class=\"hljs-number\">2</span>, radius, mPaint);\n        mPaint.set<span class=\"hljs-constructor\">Color(<span class=\"hljs-params\">textColor</span>)</span>;\n        mPaint.set<span class=\"hljs-constructor\">TextSize(<span class=\"hljs-params\">textSize</span>)</span>;\n        String text = currentPosition + <span class=\"hljs-number\">1</span> + <span class=\"hljs-string\">&quot;/&quot;</span> + pageSize;\n        <span class=\"hljs-built_in\">int</span> textWidth = (<span class=\"hljs-built_in\">int</span>) mPaint.measure<span class=\"hljs-constructor\">Text(<span class=\"hljs-params\">text</span>)</span>;\n        Paint.FontMetricsInt fontMetricsInt = mPaint.get<span class=\"hljs-constructor\">FontMetricsInt()</span>;\n        <span class=\"hljs-built_in\">int</span> baseline = (get<span class=\"hljs-constructor\">MeasuredHeight()</span> - fontMetricsInt.bottom + fontMetricsInt.top)<span class=\"hljs-operator\"> / </span><span class=\"hljs-number\">2</span> - fontMetricsInt.top;\n        canvas.draw<span class=\"hljs-constructor\">Text(<span class=\"hljs-params\">text</span>, (<span class=\"hljs-params\">getWidth</span>()</span> - textWidth)<span class=\"hljs-operator\"> / </span><span class=\"hljs-number\">2</span>, baseline, mPaint);\n    &#125;\n\n    public void set<span class=\"hljs-constructor\">Radius(<span class=\"hljs-params\">int</span> <span class=\"hljs-params\">radius</span>)</span> &#123;\n        this.radius = radius;\n    &#125;\n\n    @Override\n    public void set<span class=\"hljs-constructor\">BackgroundColor(@ColorInt <span class=\"hljs-params\">int</span> <span class=\"hljs-params\">backgroundColor</span>)</span> &#123;\n        this.backgroundColor = backgroundColor;\n    &#125;\n\n    public void set<span class=\"hljs-constructor\">TextSize(<span class=\"hljs-params\">int</span> <span class=\"hljs-params\">textSize</span>)</span> &#123;\n        this.textSize = textSize;\n    &#125;\n    <span class=\"hljs-comment\">// ...省略无关代码</span>\n&#125;</code></pre>\n<p>有自定义View基础的同学应该能很轻松的看懂上边的代码。首先通过onMeasure()方法测量了View的大小，接下来就是在onDraw方法中绘制圆和文字了。很容易就实现了一个自定义的IndicatorView。当然，这个例子本身就比较简单。如果你需要绘制比较复杂且带有动画的Indicator，可以参考源码中的CircleIndicatorView和DashIndicatorView，或许它能给你一些灵感。</p>\n<h3 id=\"3-设置自定义指示器\"><a href=\"#3-设置自定义指示器\" class=\"headerlink\" title=\"(3)设置自定义指示器\"></a>(3)设置自定义指示器</h3><p>接下来就将我们自己绘制的指示器设置到BannerViewPager中吧！</p>\n<pre><code class=\"hljs reasonml\">FigureIndicatorView indicatorView = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-constructor\">FigureIndicatorView(<span class=\"hljs-params\">mContext</span>)</span>;\nindicatorView.set<span class=\"hljs-constructor\">Radius(BannerUtils.<span class=\"hljs-params\">dp2px</span>(18)</span>);\nindicatorView.set<span class=\"hljs-constructor\">TextSize(BannerUtils.<span class=\"hljs-params\">dp2px</span>(13)</span>);\nindicatorView.set<span class=\"hljs-constructor\">BackgroundColor(Color.<span class=\"hljs-params\">parseColor</span>(<span class=\"hljs-string\">&quot;#aa118EEA&quot;</span>)</span>);\n\nmViewPager.set<span class=\"hljs-constructor\">IndicatorGravity(IndicatorGravity.END)</span>\n          .set<span class=\"hljs-constructor\">IndicatorView(<span class=\"hljs-params\">indicatorView</span>)</span>\n          .set<span class=\"hljs-constructor\">HolderCreator(()</span> -&gt; <span class=\"hljs-keyword\">new</span> <span class=\"hljs-constructor\">ImageResourceViewHolder(0)</span>)\n          .create(mDrawableList);</code></pre>\n<p>依然如此潇洒自然！好了，关于BannerViewPager的介绍今天就讲解到这里了。接下来的一篇文章将会对BannerViewPager的源码进行剖析，了解下它是如何通过简单的Api实现来实现复杂的功能的。</p>\n<p>都看到这里了，确定不到GitHub点个星再走？源码已放到文章末尾。如果有好的Idea也欢迎Pull Request。</p>\n<p><a href=\"https://juejin.im/post/5d74d3faf265da03b5747015\">《BannerViewPager源码解析》</a></p>\n<p><a href=\"https://github.com/zhpanvip/BannerViewPager\">源码下载</a></p>\n<p><strong>文章上次更新2019.11.16</strong></p>\n","site":{"data":{"fluid_config":{"favicon":"/img/favicon.png","apple_touch_icon":"/img/favicon.png","title_join_string":" - ","force_https":false,"highlight":{"enable":true,"style":"Github Gist","bg_color":false,"copy_btn":true},"fun_features":{"typing":{"enable":true,"typeSpeed":70,"cursorChar":"|","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"mouse_click":{"enable":false,"style":"values"}},"dark_mode":{"enable":true,"default":"auto"},"color":{"body_bg_color":"#eee","body_bg_color_dark":"#181c27","navbar_bg_color":"#2f4154","navbar_bg_color_dark":"#1f3144","navbar_text_color":"#fff","navbar_text_color_dark":"#d0d0d0","text_color":"#3c4858","text_color_dark":"#c4c6c9","sec_text_color":"#718096","sec_text_color_dark":"#a7a9ad","post_text_color":"#2c3e50","post_text_color_dark":"#c4c6c9","post_heading_color":"#1a202c","post_heading_color_dark":"#c4c6c9","post_link_color":"#0366d6","post_link_color_dark":"#1589e9","link_hover_color":"#30a9de","link_hover_color_dark":"#30a9de","link_hover_bg_color":"#f8f9fa","link_hover_bg_color_dark":"#364151","board_color":"#fff","board_color_dark":"#252d38"},"font":{"font_size":"16px","font_family":null,"code_font_size":"85%"},"custom_js":null,"custom_css":null,"custom_html":"","web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"tajs":null,"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}},"lazyload":{"enable":true,"onlypost":false},"daovoice":{"enable":false,"appid":""},"aplayer":{"enable":false,"autoplay":false,"loop":"all","order":"random","theme":"#b7daff","songs":[{"name":"name","artist":"artist","url":"/songs/test.mp3","cover":"/img/cover.jpg"},{"name":"name","artist":"artist","url":"https://...url.mp3","cover":"https://...cover.jpg"}]},"version":{"check":false},"navbar":{"blog_title":"zhangpan","ground_glass":{"enable":false,"px":3,"alpha":0.7},"menu":[{"key":"home","link":"/","icon":"iconfont icon-home-fill"},{"key":"archive","link":"/archives/","icon":"iconfont icon-archive-fill"},{"key":"category","link":"/categories/","icon":"iconfont icon-category-fill"},{"key":"tag","link":"/tags/","icon":"iconfont icon-tags-fill"},{"key":"about","link":"/about/","icon":"iconfont icon-user-fill"}]},"search":{"enable":true,"path":"/local-search.xml","generate_path":"/local-search.xml","field":"post","content":true},"scroll_down_arrow":{"enable":true,"banner_height_limit":90,"scroll_after_turning_page":true},"banner_parallax":true,"footer":{"statistics":{"enable":false,"source":"busuanzi","pv_format":"总访问量 {} 次","uv_format":"总访客数 {} 人"},"beian":{"enable":false,"icp_text":"京ICP证123456号","police_text":"京公网安备12345678号","police_code":12345678,"police_icon":"/img/police_beian.png"}},"scroll_top_arrow":{"enable":true},"index":{"banner_img":"/img/default.png","banner_img_height":100,"banner_mask_alpha":0.3,"post_default_img":"","slogan":{"enable":true,"text":"Talk is cheap, show me the code."},"auto_excerpt":{"enable":true},"post_url_target":"_self","post_meta":{"date":true,"category":true,"tag":true}},"page":{"banner_img":"/img/default.png","banner_img_height":60,"banner_mask_alpha":0.3},"post":{"banner_img":"/img/default.png","banner_img_height":70,"banner_mask_alpha":0.3,"meta":{"date":{"enable":true,"format":"LL a"},"wordcount":{"enable":true,"format":"{} 字"},"min2read":{"enable":true,"format":"{} 分钟","words":100},"views":{"enable":false,"source":"busuanzi","format":"{} 次"}},"updated":{"enable":false,"content":"本文最后更新于：","relative":false},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"copyright":{"enable":true,"content":"本博客所有文章除特别声明外，均采用 <a href=\"https://creativecommons.org/licenses/by-sa/4.0/deed.zh\" rel=\"nofollow noopener\">CC BY-SA 4.0 协议</a> ，转载请注明出处！ <h5>开源库推荐</h5> <a href=\"https://github.com/zhpanvip/BannerViewPager\">1.BannerViewPager</a> <p> 一个基于ViewPager2实现的具有强大功能的无限轮播库。支持多种页面切换效果和指示器样式。 </p>\n<a href=\"https://github.com/zhpanvip/viewpagerindicator\">2.ViewPagerIndicator</a> <p> 一个适用于ViewPager和ViewPager2的指示器，支持多种滑块样式及滑动模式 </p>"},"prev_next":{"enable":true},"custom":{"enable":false,"content":"<img src=\"https://octodex.github.com/images/jetpacktocat.png\" class=\"rounded mx-auto d-block mt-5\" style=\"width:150px; height:150px;\">"},"image_zoom":{"enable":true},"footnote":{"enable":true,"header":""},"math":{"enable":false,"specific":false,"engine":"mathjax"},"mermaid":{"enable":false,"specific":false,"options":{"theme":"default"}},"comments":{"enable":true,"type":"utterances"}},"utterances":{"repo":"zhpanvip/utterances-comment","issue_term":"pathname","label":"utterances","theme":"github-light","crossorigin":"anonymous"},"disqus":{"shortname":null,"disqusjs":false,"apikey":null},"gitalk":{"clientID":null,"clientSecret":null,"repo":null,"owner":null,"admin":["name"],"id":"location.pathname","language":"zh-CN","labels":["Gitalk"],"perPage":10,"pagerDirection":"last","distractionFreeMode":false,"createIssueManually":true},"valine":{"appid":"hXIROaIM5y9qnieojJRWP5hS","appkey":"y0f3w3aqd1MF7JL9ma4WECTy","placeholder":"说点什么","path":"window.location.pathname","avatar":"retro","meta":["nick","mail","link"],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"https://zhangpan.site"},"changyan":{"appid":"","appkey":""},"livere":{"uid":""},"archive":{"banner_img":"/img/bg_article.jpg","banner_img_height":60,"banner_mask_alpha":0.3,"subtitle":null},"category":{"banner_img":"/img/bg_default.png","banner_img_height":60,"banner_mask_alpha":0.3,"subtitle":null,"post_limit":10,"order_by":"-length"},"tag":{"banner_img":"/img/bg_label.jpg","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null,"tagcloud":{"min_font":15,"max_font":30,"unit":"px","start_color":"#BBBBEE","end_color":"#337ab7"}},"about":{"banner_img":"/img/bg_default.png","banner_img_height":60,"banner_mask_alpha":0.3,"subtitle":null,"avatar":"/img/avatar.png","name":"myname","introduce":"一句简短的介绍","icons":[{"class":"iconfont icon-github-fill","link":"https://github.com","tip":"GitHub"},{"class":"iconfont icon-douban-fill","link":"https://douban.com","tip":"豆瓣"},{"class":"iconfont icon-wechat-fill","qrcode":"/img/favicon.png"}]},"page404":{"banner_img":"/img/default.png","banner_img_height":85,"banner_mask_alpha":0.3,"subtitle":"Page not found"},"links":{"banner_img":"/img/default.png","banner_img_height":60,"banner_mask_alpha":0.3,"subtitle":null,"items":[{"title":"Fluid Docs","intro":"主题使用指南","link":"https://hexo.fluid-dev.com/docs/","image":"/img/favicon.png"},{"title":"Fluid Repo","intro":"主题 GitHub 仓库","link":"https://github.com/fluid-dev/hexo-theme-fluid","image":"/img/favicon.png"},{"title":"Fluid Example","intro":"主题操作示例","link":"https://hexo.fluid-dev.com/docs/example/","image":"/img/favicon.png"}]}}}},"excerpt":"","more":"<p>本文同步发布在<a href=\"https://juejin.im/post/5d6bce24f265da03db0790d1\">掘金</a>，如需转载请注明出处。</p>\n<p>BannerViewPager系列文章共三篇，此文为第一篇，另外两篇参看下面链接：</p>\n<p><a href=\"https://blog.csdn.net/qq_20521573/article/details/100609592\">BannerViewPager源码剖析</a></p>\n<p><a href=\"https://blog.csdn.net/qq_20521573/article/details/103216593\">剖析BannerViewPager中Indicator的设计思想</a></p>\n<p>最近公司项目在升级AndroidX，由于项目中用到的一些比较老的库都已停止更新维护，因此需要将这些库替换掉，其中就包括自动轮播的Banner库。恰逢笔者在之前写过一个轮播图，因此就在此基础上重构，打造出了一个全新的支持多种样式的轮播库—<a href=\"https://github.com/zhpanvip/BannerViewPager/tree/master\">BannerViewPager</a>。个人觉得<a href=\"https://github.com/zhpanvip/BannerViewPager/tree/master\">BannerViewPager</a>要优于其它开源的Banner库，不仅仅是因为它拥有简洁高效的代码，更是因为它高度的可定制性。<a href=\"https://github.com/zhpanvip/BannerViewPager/tree/master\">BannerViewPager</a>不仅支持任意的页面布局，而且可以支持任意的Indicator样式。甚至连Indicator的位置都可以做到任意摆放。是的，就是这么随心所欲。无图言叼，还是先通过图片和代码一览BannerViewPager的功能吧(多图预警)。</p>\n<h1 id=\"一、BannerViewPager效果预览及API介绍\"><a href=\"#一、BannerViewPager效果预览及API介绍\" class=\"headerlink\" title=\"一、BannerViewPager效果预览及API介绍\"></a>一、BannerViewPager效果预览及API介绍</h1><p>由于GIF图片质量问题，下面的预览图并不清晰，大家可以点击下面链接或者扫描二维码下载Apk体验。Apk存放在github上，下载速度可能会比较慢。</p>\n<p> <a href=\"https://github.com/zhpanvip/BannerViewPager/raw/master/download/app.apk\">点击或扫描二维码下载apk</a></p>\n<p><img src=\"https://raw.githubusercontent.com/zhpanvip/Resource/master/image/banner/qrcode.png\"></p>\n<h2 id=\"1-setIndicatorStyle（开局就放王炸？）\"><a href=\"#1-setIndicatorStyle（开局就放王炸？）\" class=\"headerlink\" title=\"1.setIndicatorStyle（开局就放王炸？）\"></a>1.setIndicatorStyle（开局就放王炸？）</h2><p>BannerViewPager目前内置了CIRCLE和DASH两种样式的指示器,通过setIndicatorStyle(int)一行代码就可以切换指示器的样式。当然，如果内置样式不满足你的需求。BannerViewPager还提供了自定义指示器的功能。只要继承BaseIndicatorView或者实现IIndicator接口，并重写相应方法，就可以通过自定义View为所欲为的打造任意的Indicator了。如下图【自定义】就是自己实现的指示器样式。</p>\n<table>\n<thead>\n<tr>\n<th>CIRCLE</th>\n<th>DASH</th>\n<th>自定义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMS8xNi8xNmU3NGNhODFlOWM4OGI5?x-oss-process=image/format,png\"></td>\n<td><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMS8xNi8xNmU3NGNiNGU3M2YyM2U3?x-oss-process=image/format,png\"></td>\n<td><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMS8xNi8xNmU3NGNjMjE2OWNiOTBi?x-oss-process=image/format,png\"></td>\n</tr>\n</tbody></table>\n<p>下面通过代码演示如何切换指示器：</p>\n<pre><code class=\"hljs reasonml\">mViewPager.set<span class=\"hljs-constructor\">IndicatorStyle(IndicatorStyle.DASH)</span>\n          .set<span class=\"hljs-constructor\">IndicatorHeight(BannerUtils.<span class=\"hljs-params\">dp2px</span>(3f)</span>)\n          .set<span class=\"hljs-constructor\">IndicatorWidth(BannerUtils.<span class=\"hljs-params\">dp2px</span>(3)</span>, <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">BannerUtils</span>.</span></span>dp2px(<span class=\"hljs-number\">10</span>))\n          .set<span class=\"hljs-constructor\">HolderCreator(()</span> -&gt; <span class=\"hljs-keyword\">new</span> <span class=\"hljs-constructor\">ImageResourceViewHolder(0)</span>)\n          .create(mDrawableList)</code></pre>\n<p>通过5行代码就轻松的实现了上图【Dash】仿支付宝的Indicator样式（大家可以留意一下支付宝的轮播Indicator，挺有意思）。</p>\n<p>关于自定义IndicatorView将会放在后边章节详细讲解。</p>\n<h2 id=\"2-setPageStyle\"><a href=\"#2-setPageStyle\" class=\"headerlink\" title=\"2.setPageStyle\"></a>2.setPageStyle</h2><p>通过setPageStyle(int)一行代码开启一屏三页模式，一屏三页模式下目前有三种样式，分别如下图所示：</p>\n<table>\n<thead>\n<tr>\n<th>MULTI_PAGE</th>\n<th>MULTI_PAGE_SCALE</th>\n<th>MULTI_PAGE_OVERLAP</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMS8xNS8xNmU2ZjNjMTdhZDcyMGMx?x-oss-process=image/format,png\" alt=\"MULTI_PAGE \"></td>\n<td><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMS8xNS8xNmU2ZjNjMTdiODNhOTQ4?x-oss-process=image/format,png\" alt=\"MULTI_PAGE_SCALE \"></td>\n<td><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMS8xNS8xNmU2ZjNjMTdjM2QwOWVh?x-oss-process=image/format,png\" alt=\"MULTI_PAGE_OVERLAP \"></td>\n</tr>\n<tr>\n<td>代码演示：</td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<pre><code class=\"hljs css\"><span class=\"hljs-selector-tag\">mViewPager</span><span class=\"hljs-selector-class\">.setPageStyle</span>(<span class=\"hljs-selector-tag\">PageStyle</span><span class=\"hljs-selector-class\">.MULTI_PAGE</span>)\n          <span class=\"hljs-selector-class\">.setPageMargin</span>(<span class=\"hljs-selector-tag\">BannerUtils</span><span class=\"hljs-selector-class\">.dp2px</span>(10))\n          <span class=\"hljs-selector-class\">.setRevealWidth</span>(<span class=\"hljs-selector-tag\">BannerUtils</span><span class=\"hljs-selector-class\">.dp2px</span>(10))\n          <span class=\"hljs-selector-class\">.setHolderCreator</span>(() <span class=\"hljs-selector-tag\">-</span>&gt; <span class=\"hljs-selector-tag\">new</span> <span class=\"hljs-selector-tag\">ImageResourceViewHolder</span>(<span class=\"hljs-selector-tag\">BannerUtils</span><span class=\"hljs-selector-class\">.dp2px</span>(5)))\n          <span class=\"hljs-selector-class\">.create</span>(<span class=\"hljs-selector-tag\">mDrawableList</span>);</code></pre>\n<p>同样通过短短5行代码就实现了上图【MULTI_PAGE】的效果，简单好用！</p>\n<h2 id=\"3-如何实现指示器位置任意摆放？\"><a href=\"#3-如何实现指示器位置任意摆放？\" class=\"headerlink\" title=\"3.如何实现指示器位置任意摆放？\"></a>3.如何实现指示器位置任意摆放？</h2><p>我们看到上面图表中MULTI_PAGE_OVERLAP模式下指示器显示到了Banner的下边。这种效果该怎么实现呢？其实BannerViewPager是支持把Indicator摆放在任意位置的。之所以能如此强大是因为我们通过自定义指示器替换了内置的IndicatorView，也就是说此时的IndicatorView已经脱离了BannerViewPager,也就理所当然的可以放在任意位置了。接下来通过代码来看下如何实现：</p>\n<h3 id=\"1-Xml布局文件如下\"><a href=\"#1-Xml布局文件如下\" class=\"headerlink\" title=\"(1)Xml布局文件如下\"></a>(1)Xml布局文件如下</h3><pre><code class=\"hljs stylus\">&lt;RelativeLayout xmlns:android=<span class=\"hljs-string\">&quot;http://schemas.android.com/apk/res/android&quot;</span>\n    xmlns:app=<span class=\"hljs-string\">&quot;http://schemas.android.com/apk/res-auto&quot;</span>\n    android:layout_width=<span class=\"hljs-string\">&quot;match_parent&quot;</span>\n    android:layout_height=<span class=\"hljs-string\">&quot;match_parent&quot;</span>&gt;\n\n    &lt;com<span class=\"hljs-selector-class\">.zhpan</span><span class=\"hljs-selector-class\">.bannerview</span>.BannerViewPager\n        android:id=<span class=\"hljs-string\">&quot;@+id/banner_view&quot;</span>\n        android:layout_width=<span class=\"hljs-string\">&quot;match_parent&quot;</span>\n        android:layout_height=<span class=\"hljs-string\">&quot;180dp&quot;</span>\n        android:layout_marginTop=<span class=\"hljs-string\">&quot;20dp&quot;</span>\n        app:bvp_page_style=<span class=\"hljs-string\">&quot;multi_page&quot;</span> /&gt;\n\n    &lt;com<span class=\"hljs-selector-class\">.zhpan</span><span class=\"hljs-selector-class\">.bannerview</span><span class=\"hljs-selector-class\">.indicator</span>.CircleIndicatorView\n        android:id=<span class=\"hljs-string\">&quot;@+id/indicator_view&quot;</span>\n        android:layout_width=<span class=\"hljs-string\">&quot;wrap_content&quot;</span>\n        android:layout_height=<span class=\"hljs-string\">&quot;wrap_content&quot;</span>\n        android:layout_below=<span class=\"hljs-string\">&quot;@id/banner_view&quot;</span>\n        android:layout_centerHorizontal=<span class=\"hljs-string\">&quot;true&quot;</span>\n        android:layout_marginTop=<span class=\"hljs-string\">&quot;10dp&quot;</span> /&gt;\n &lt;/RelativeLayout&gt;\n</code></pre>\n<h3 id=\"2-通过setIndicatorView-IIndicator-替换内部指示器\"><a href=\"#2-通过setIndicatorView-IIndicator-替换内部指示器\" class=\"headerlink\" title=\"(2)通过setIndicatorView(IIndicator)替换内部指示器\"></a>(2)通过setIndicatorView(IIndicator)替换内部指示器</h3><pre><code class=\"hljs reasonml\">      CircleIndicatorView indicatorView = find<span class=\"hljs-constructor\">ViewById(R.<span class=\"hljs-params\">id</span>.<span class=\"hljs-params\">indicator_view</span>)</span>;\nmViewPager.set<span class=\"hljs-constructor\">IndicatorView(<span class=\"hljs-params\">indicatorView</span>)</span>\n                .set<span class=\"hljs-constructor\">IndicatorColor(Color.<span class=\"hljs-params\">parseColor</span>(<span class=\"hljs-string\">&quot;#888888&quot;</span>)</span>,\n                     <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">Color</span>.</span></span>parse<span class=\"hljs-constructor\">Color(<span class=\"hljs-string\">&quot;#118EEA&quot;</span>)</span>)\n                .set<span class=\"hljs-constructor\">HolderCreator(()</span> -&gt; <span class=\"hljs-keyword\">new</span> <span class=\"hljs-constructor\">ImageResourceViewHolder(BannerUtils.<span class=\"hljs-params\">dp2px</span>(5)</span>))\n                .create(mDrawableList);</code></pre>\n<p>CircleIndicatorView是什么？其实他就是内置在BannerViewPager中的指示器，现在你只需要把它同BannerViewPager放在同一个布局文件中就可以了。又是仅仅通过一行代码就完成了对内部指示器的替换，不知道你看完之后是否会拍案叫绝，竟然如此简单！</p>\n<h2 id=\"4-setIndicatorSlideMode\"><a href=\"#4-setIndicatorSlideMode\" class=\"headerlink\" title=\"4.setIndicatorSlideMode\"></a>4.setIndicatorSlideMode</h2><p>我们应该见过很多App轮播图的指示器都会跟随页面一起滑动。BannerViewPager自然也不会少了这个功能。通过setIndicatorSlideMode(int)一行代码就可以轻松切换到下图（SMOOTH）的效果。</p>\n<table>\n<thead>\n<tr>\n<th>NORMAL</th>\n<th>SMOOTH</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMS8xNS8xNmU2ZjNjMWIwM2U5NWE5?x-oss-process=image/format,png\"></td>\n<td><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMS8xNS8xNmU2ZjNjMWI0MGMwMzAz?x-oss-process=image/format,png\"></td>\n</tr>\n</tbody></table>\n<p>代码实现仍然非常简单，使用BannerViewPager你只需要记住一个核心–Only One Line！所以演示代码不再贴出你应该不会揍我吧？</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMS8xNi8xNmU3NGE4NThhY2ZmZTg2?x-oss-process=image/format,png\"></p>\n<h2 id=\"5-setPageTransformerStyle\"><a href=\"#5-setPageTransformerStyle\" class=\"headerlink\" title=\"5.setPageTransformerStyle\"></a>5.setPageTransformerStyle</h2><p>关于Transform更好的方式应该是留给开发者自己去实现，因此BannerViewPager中目前仅内置了四种常用Transform样式，如果不能满足需求，可以通过BannerViewPager的setPageTransformer(ViewPager.PageTransformer transformer)设置自定义的Transform。四种内置Transform样式如下：</p>\n<table>\n<thead>\n<tr>\n<th>STACK</th>\n<th>ACCORDION</th>\n<th>DEPTH</th>\n<th>ROTATE</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMS8xNy8xNmU3OTkyZGZmMTA5MWYz?x-oss-process=image/format,png\"></td>\n<td><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMS8xNy8xNmU3OTkzNjI4NGU2MThm?x-oss-process=image/format,png\"></td>\n<td><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMS8xNy8xNmU3OTk0MzBhYThmYTFl?x-oss-process=image/format,png\"></td>\n<td><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMS8xNy8xNmU3OTk0YmQ2MzlmYjAw?x-oss-process=image/format,png\"></td>\n</tr>\n</tbody></table>\n<p>当然，BannerViewPager的功能并不仅仅局限于此，更多功能就不再演示，可以看下面所有开放的API接口。</p>\n<h2 id=\"6-BannerViewPager开放的API\"><a href=\"#6-BannerViewPager开放的API\" class=\"headerlink\" title=\"6.BannerViewPager开放的API\"></a>6.BannerViewPager开放的API</h2><p>BannerViewPager开放了众多API,以供满足不同的需求，具体如下表：</p>\n<table>\n<thead>\n<tr>\n<th>方法名</th>\n<th>方法描述</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>BannerViewPager&lt;T, VH&gt; setCanLoop(boolean canLoop)</td>\n<td>是否开启循环</td>\n<td>默认值true</td>\n</tr>\n<tr>\n<td>BannerViewPager&lt;T, VH&gt; setAutoPlay(boolean autoPlay)</td>\n<td>是否开启自动轮播</td>\n<td>默认值true</td>\n</tr>\n<tr>\n<td>BannerViewPager&lt;T, VH&gt; setInterval(int interval)</td>\n<td>自动轮播时间间隔</td>\n<td>单位毫秒，默认值3000</td>\n</tr>\n<tr>\n<td>BannerViewPager&lt;T, VH&gt; setScrollDuration(int scrollDuration)</td>\n<td>设置页面滚动时间</td>\n<td>设置页面滚动时间</td>\n</tr>\n<tr>\n<td>BannerViewPager&lt;T, VH&gt; setRoundCorner(int radius)</td>\n<td>设置圆角</td>\n<td>默认无圆角 需要SDK_INT&gt;=LOLLIPOP(API 21)</td>\n</tr>\n<tr>\n<td>BannerViewPager&lt;T, VH&gt; setOnPageClickListener(OnPageClickListener onPageClickListener)</td>\n<td>设置页面点击事件</td>\n<td></td>\n</tr>\n<tr>\n<td>BannerViewPager&lt;T, VH&gt; setHolderCreator(HolderCreator&lt;VH&gt; holderCreator)</td>\n<td>设置HolderCreator</td>\n<td>必须设置HolderCreator，否则会抛出NullPointerException</td>\n</tr>\n<tr>\n<td>BannerViewPager&lt;T, VH&gt; setIndicatorVisibility(@Visibility int visibility)</td>\n<td>indicator vibility</td>\n<td>默认值VISIBLE 2.4.2 新增</td>\n</tr>\n<tr>\n<td>BannerViewPager&lt;T, VH&gt; setIndicatorStyle(int indicatorStyle)</td>\n<td>设置指示器样式</td>\n<td>可选枚举(CIRCLE, DASH) 默认CIRCLE</td>\n</tr>\n<tr>\n<td>BannerViewPager&lt;T, VH&gt; setIndicatorGravity(int gravity)</td>\n<td>指示器位置</td>\n<td>可选值(CENTER、START、END)默认值CENTER</td>\n</tr>\n<tr>\n<td>BannerViewPager&lt;T, VH&gt; setIndicatorColor(int normalColor,int checkedColor)</td>\n<td>指示器圆点颜色</td>\n<td>normalColor：未选中时颜色默认”#8C6C6D72”， checkedColor：选中时颜色 默认”#8C18171C”</td>\n</tr>\n<tr>\n<td>BannerViewPager&lt;T, VH&gt; setIndicatorSlideMode(int slideMode)</td>\n<td>设置Indicator滑动模式</td>\n<td>可选（NORMAL、SMOOTH），默认值SMOOTH</td>\n</tr>\n<tr>\n<td>BannerViewPager&lt;T, VH&gt; setIndicatorRadius(int radius)</td>\n<td>设置指示器圆点半径</td>\n<td>默认值4dp</td>\n</tr>\n<tr>\n<td>BannerViewPager&lt;T, VH&gt; setIndicatorRadius(int normalRadius,int checkRadius)</td>\n<td>设置指示器圆点半径</td>\n<td>normalRadius:未选中时半径  checkedRadius:选中时的半径,默认值4dp</td>\n</tr>\n<tr>\n<td>BannerViewPager&lt;T, VH&gt; setIndicatorWidth(int indicatorWidth)</td>\n<td>设置指示器宽度，如果是圆形指示器，则为直径</td>\n<td>默认值8dp</td>\n</tr>\n<tr>\n<td>BannerViewPager&lt;T, VH&gt; setIndicatorWidth(int normalWidth, int checkWidth)</td>\n<td>设置指示器宽度，如果是圆形指示器，则为直径</td>\n<td>默认值8dp</td>\n</tr>\n<tr>\n<td>BannerViewPager&lt;T, VH&gt; setIndicatorHeight(int indicatorHeight)</td>\n<td>设置指示器高度，仅在Indicator样式为DASH时有效</td>\n<td>默认值normalIndicatorWidth/2</td>\n</tr>\n<tr>\n<td>BannerViewPager&lt;T, VH&gt; setIndicatorGap(int indicatorMargin)</td>\n<td>指示器圆点间距</td>\n<td>默认值为指示器宽度（或者是圆的直径）</td>\n</tr>\n<tr>\n<td>BannerViewPager&lt;T, VH&gt; setIndicatorView(IIndicator indicatorView)</td>\n<td>设置自定义指示器</td>\n<td></td>\n</tr>\n<tr>\n<td>BannerViewPager&lt;T, VH&gt; setPageTransformerStyle(int style)</td>\n<td>设置页面Transformer内置样式</td>\n<td></td>\n</tr>\n<tr>\n<td>BannerViewPager&lt;T, VH&gt; setCurrentItem(int item)</td>\n<td>Set the currently selected page.</td>\n<td>2.3.5新增</td>\n</tr>\n<tr>\n<td>void getCurrentItem()</td>\n<td>获取当前position</td>\n<td>2.3.5新增</td>\n</tr>\n<tr>\n<td>BannerViewPager&lt;T, VH&gt; setPageStyle(PageStyle pageStyle)</td>\n<td>设置页面样式</td>\n<td>2.4.0新增 可选（MULTI_PAGE、NORMAL）MULTI_PAGE：一屏多页样式</td>\n</tr>\n<tr>\n<td>BannerViewPager&lt;T, VH&gt; setPageMargin(int pageMargin)</td>\n<td>设置页面间隔</td>\n<td>2.4.0新增</td>\n</tr>\n<tr>\n<td>BannerViewPager&lt;T, VH&gt; setIndicatorMargin(int left, int top, int right, int bottom)</td>\n<td>设置Indicator边距</td>\n<td>2.4.1新增</td>\n</tr>\n<tr>\n<td>BannerViewPager&lt;T, VH&gt; setOnPageChangeListener(OnPageChangeListener l)</td>\n<td>页面改变的监听事件</td>\n<td>2.4.3新增</td>\n</tr>\n<tr>\n<td>void startLoop()</td>\n<td>开启自动轮播</td>\n<td>初始化BannerViewPager时不必调用该方法,设置setAutoPlay后会调用startLoop()</td>\n</tr>\n<tr>\n<td>void stopLoop()</td>\n<td>停止自动轮播</td>\n<td>如果开启自动轮播，为避免内存泄漏需要在onStop()或onDestroy中调用此方法</td>\n</tr>\n<tr>\n<td>List&lt;T&gt; getList()</td>\n<td>获取Banner中的集合数据</td>\n<td></td>\n</tr>\n<tr>\n<td>void create(List<T> list)</td>\n<td>初始化并构造BannerViewPager</td>\n<td>必须调用，否则前面设置的参数无效</td>\n</tr>\n</tbody></table>\n<h2 id=\"7-BannerViewPager支持的attrs\"><a href=\"#7-BannerViewPager支持的attrs\" class=\"headerlink\" title=\"7.BannerViewPager支持的attrs\"></a>7.BannerViewPager支持的attrs</h2><p>你也可以通过xml来设置BannerViewPager，xml支持的attrs如下:<br>| Attributes | format | description |<br>|–|–|–|<br>| bvp_interval | integer | 自动轮播时间间隔 |<br>| bvp_scroll_duration | integer | 页面切换时滑动时间|<br>| bvp_can_loop | boolean| 是否循环 |<br>| bvp_auto_play | boolean | 是否自动播放  |<br>| bvp_indicator_checked_color | color | indicator选中时颜色 |<br>| bvp_indicator_normal_color | color | indicator未选中时颜色 |<br>| bvp_indicator_radius | dimension | indicator圆点半径或者Dash模式的1/2宽度  |<br>| bvp_round_corner| dimension  | Banner圆角大小 |<br>| bvp_page_margin | dimension | 页面item间距 |<br>| bvp_reveal_width | dimension | 一屏多页模式下两边item漏出的宽度 |<br>| bvp_indicator_style | enum | indicator样式(circle/dash)  |<br>| bvp_indicator_slide_mode | enum | indicator滑动模式(normal/smooth) |<br>| bvp_indicator_gravity | enum | indicator位置(center/start/end) |<br>| bvp_page_style | enum | page样式(normal/multi_page/multi_page_overlap/multi_page_scale) |<br>| bvp_transformer_style | enum | transform样式(normal/depth/stack/accordion) |<br>| bvp_indicator_visibility| enum | indicator visibility(visible/gone/invisible) |</p>\n<h1 id=\"二、BannerViewPager详细使用说明\"><a href=\"#二、BannerViewPager详细使用说明\" class=\"headerlink\" title=\"二、BannerViewPager详细使用说明\"></a>二、BannerViewPager详细使用说明</h1><h2 id=\"1-gradle中添加依赖\"><a href=\"#1-gradle中添加依赖\" class=\"headerlink\" title=\"1.gradle中添加依赖\"></a>1.gradle中添加依赖</h2><p>如果您已迁移到AndroidX请使用latestVersion(&gt;=2.4.3.1)</p>\n<pre><code class=\"hljs clean\"><span class=\"hljs-keyword\">implementation</span> <span class=\"hljs-string\">&#x27;com.zhpan.library:bannerview:latestVersion&#x27;</span>\n</code></pre>\n<p>如果未迁移到AndroidX请使用（非Androidx的包托管在JCenter上）：</p>\n<pre><code class=\"hljs clean\"><span class=\"hljs-keyword\">implementation</span> <span class=\"hljs-string\">&#x27;com.zhpan.library:bannerview:2.4.3.1&#x27;</span></code></pre>\n\n<h2 id=\"2-在xml文件中添加如下代码：\"><a href=\"#2-在xml文件中添加如下代码：\" class=\"headerlink\" title=\"2. 在xml文件中添加如下代码：\"></a>2. 在xml文件中添加如下代码：</h2><pre><code class=\"hljs routeros\">&lt;com.zhpan.bannerview.BannerViewPager\n        android:<span class=\"hljs-attribute\">id</span>=<span class=\"hljs-string\">&quot;@+id/banner_view&quot;</span>\n        android:<span class=\"hljs-attribute\">layout_width</span>=<span class=\"hljs-string\">&quot;match_parent&quot;</span>\n        android:<span class=\"hljs-attribute\">layout_margin</span>=<span class=\"hljs-string\">&quot;10dp&quot;</span>\n        android:<span class=\"hljs-attribute\">layout_height</span>=<span class=\"hljs-string\">&quot;160dp&quot;</span> /&gt;</code></pre>\n<h2 id=\"3-Banner的Item页面布局\"><a href=\"#3-Banner的Item页面布局\" class=\"headerlink\" title=\"3.Banner的Item页面布局\"></a>3.Banner的Item页面布局</h2><pre><code class=\"hljs xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">RelativeLayout</span> <span class=\"hljs-attr\">xmlns:android</span>=<span class=\"hljs-string\">&quot;http://schemas.android.com/apk/res/android&quot;</span></span>\n<span class=\"hljs-tag\">    <span class=\"hljs-attr\">android:layout_width</span>=<span class=\"hljs-string\">&quot;match_parent&quot;</span></span>\n<span class=\"hljs-tag\">    <span class=\"hljs-attr\">android:layout_height</span>=<span class=\"hljs-string\">&quot;wrap_content&quot;</span>&gt;</span>\n\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ImageView</span></span>\n<span class=\"hljs-tag\">        <span class=\"hljs-attr\">android:id</span>=<span class=\"hljs-string\">&quot;@+id/banner_image&quot;</span></span>\n<span class=\"hljs-tag\">        <span class=\"hljs-attr\">android:layout_width</span>=<span class=\"hljs-string\">&quot;match_parent&quot;</span></span>\n<span class=\"hljs-tag\">        <span class=\"hljs-attr\">android:layout_height</span>=<span class=\"hljs-string\">&quot;match_parent&quot;</span></span>\n<span class=\"hljs-tag\">        <span class=\"hljs-attr\">android:scaleType</span>=<span class=\"hljs-string\">&quot;centerCrop&quot;</span> /&gt;</span>\n\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">LinearLayout</span></span>\n<span class=\"hljs-tag\">        <span class=\"hljs-attr\">android:layout_width</span>=<span class=\"hljs-string\">&quot;match_parent&quot;</span></span>\n<span class=\"hljs-tag\">        <span class=\"hljs-attr\">android:layout_height</span>=<span class=\"hljs-string\">&quot;wrap_content&quot;</span></span>\n<span class=\"hljs-tag\">        <span class=\"hljs-attr\">android:layout_alignParentBottom</span>=<span class=\"hljs-string\">&quot;true&quot;</span></span>\n<span class=\"hljs-tag\">        <span class=\"hljs-attr\">android:background</span>=<span class=\"hljs-string\">&quot;#66000000&quot;</span></span>\n<span class=\"hljs-tag\">        <span class=\"hljs-attr\">android:gravity</span>=<span class=\"hljs-string\">&quot;center_vertical&quot;</span>&gt;</span>\n\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">TextView</span></span>\n<span class=\"hljs-tag\">            <span class=\"hljs-attr\">android:id</span>=<span class=\"hljs-string\">&quot;@+id/tv_describe&quot;</span></span>\n<span class=\"hljs-tag\">            <span class=\"hljs-attr\">android:layout_width</span>=<span class=\"hljs-string\">&quot;wrap_content&quot;</span></span>\n<span class=\"hljs-tag\">            <span class=\"hljs-attr\">android:layout_height</span>=<span class=\"hljs-string\">&quot;match_parent&quot;</span></span>\n<span class=\"hljs-tag\">            <span class=\"hljs-attr\">android:layout_gravity</span>=<span class=\"hljs-string\">&quot;center_vertical&quot;</span></span>\n<span class=\"hljs-tag\">            <span class=\"hljs-attr\">android:layout_marginStart</span>=<span class=\"hljs-string\">&quot;15dp&quot;</span></span>\n<span class=\"hljs-tag\">            <span class=\"hljs-attr\">android:gravity</span>=<span class=\"hljs-string\">&quot;center_vertical&quot;</span></span>\n<span class=\"hljs-tag\">            <span class=\"hljs-attr\">android:paddingTop</span>=<span class=\"hljs-string\">&quot;5dp&quot;</span></span>\n<span class=\"hljs-tag\">            <span class=\"hljs-attr\">android:paddingBottom</span>=<span class=\"hljs-string\">&quot;5dp&quot;</span></span>\n<span class=\"hljs-tag\">            <span class=\"hljs-attr\">android:textColor</span>=<span class=\"hljs-string\">&quot;#FFFFFF&quot;</span></span>\n<span class=\"hljs-tag\">            <span class=\"hljs-attr\">android:textSize</span>=<span class=\"hljs-string\">&quot;16sp&quot;</span> /&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">LinearLayout</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">RelativeLayout</span>&gt;</span></code></pre>\n\n<h2 id=\"4-自定义ViewHolder\"><a href=\"#4-自定义ViewHolder\" class=\"headerlink\" title=\"4.自定义ViewHolder\"></a>4.自定义ViewHolder</h2><pre><code class=\"hljs reasonml\">public <span class=\"hljs-keyword\">class</span> NetViewHolder implements ViewHolder&lt;BannerData&gt; &#123;\n    <span class=\"hljs-keyword\">private</span> ImageView mImageView;\n    <span class=\"hljs-keyword\">private</span> TextView mTextView;\n\n    @Override\n    public View create<span class=\"hljs-constructor\">View(ViewGroup <span class=\"hljs-params\">viewGroup</span>, Context <span class=\"hljs-params\">context</span>, <span class=\"hljs-params\">int</span> <span class=\"hljs-params\">position</span>)</span> &#123;\n        View view = <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">LayoutInflater</span>.</span></span>from(context).inflate(<span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">R</span>.</span></span>layout.item_net, viewGroup, <span class=\"hljs-literal\">false</span>);\n        mImageView = view.find<span class=\"hljs-constructor\">ViewById(R.<span class=\"hljs-params\">id</span>.<span class=\"hljs-params\">banner_image</span>)</span>;\n        mTextView = view.find<span class=\"hljs-constructor\">ViewById(R.<span class=\"hljs-params\">id</span>.<span class=\"hljs-params\">tv_describe</span>)</span>;\n        return view;\n    &#125;\n\n    @Override\n    public void on<span class=\"hljs-constructor\">Bind(Context <span class=\"hljs-params\">context</span>, BannerData <span class=\"hljs-params\">data</span>, <span class=\"hljs-params\">int</span> <span class=\"hljs-params\">position</span>, <span class=\"hljs-params\">int</span> <span class=\"hljs-params\">size</span>)</span> &#123;\n        ImageLoaderOptions options = <span class=\"hljs-keyword\">new</span> ImageLoaderOptions.<span class=\"hljs-constructor\">Builder()</span>.into(mImageView).load(data.get<span class=\"hljs-constructor\">ImagePath()</span>).place<span class=\"hljs-constructor\">Holder(R.<span class=\"hljs-params\">drawable</span>.<span class=\"hljs-params\">placeholder</span>)</span>.build<span class=\"hljs-literal\">()</span>;\n        <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">ImageLoaderManager</span>.</span></span>get<span class=\"hljs-constructor\">Instance()</span>.load<span class=\"hljs-constructor\">Image(<span class=\"hljs-params\">options</span>)</span>;\n        mTextView.set<span class=\"hljs-constructor\">Text(<span class=\"hljs-params\">data</span>.<span class=\"hljs-params\">getTitle</span>()</span>);\n    &#125;\n&#125;</code></pre>\n\n<h2 id=\"5-BannerViewPager参数配置\"><a href=\"#5-BannerViewPager参数配置\" class=\"headerlink\" title=\"5.BannerViewPager参数配置\"></a>5.BannerViewPager参数配置</h2><pre><code class=\"hljs arduino\">   <span class=\"hljs-keyword\">private</span> BannerViewPager&lt;BannerData, NetViewHolder&gt; mBannerViewPager;\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">initViewPager</span><span class=\"hljs-params\">()</span> </span>&#123;\n            mBannerViewPager = findViewById(R.id.banner_view);\n            mBannerViewPager.showIndicator(<span class=\"hljs-literal\">true</span>)\n               .setInterval(<span class=\"hljs-number\">3000</span>)\n               .setCanLoop(<span class=\"hljs-literal\">false</span>)\n               .setAutoPlay(<span class=\"hljs-literal\">true</span>)\n               .setRoundCorner(DpUtils.dp2px(<span class=\"hljs-number\">7</span>))\n               .setIndicatorColor(Color.parseColor(<span class=\"hljs-string\">&quot;#935656&quot;</span>), Color.parseColor(<span class=\"hljs-string\">&quot;#FF4C39&quot;</span>))\n               .setIndicatorGravity(BannerViewPager.END)\n               .setScrollDuration(<span class=\"hljs-number\">1000</span>).setHolderCreator(NetViewHolder::<span class=\"hljs-keyword\">new</span>)\n               .setOnPageClickListener(<span class=\"hljs-built_in\">position</span> -&gt; &#123;\n                   BannerData bannerData = mBannerViewPager.getList().<span class=\"hljs-built_in\">get</span>(<span class=\"hljs-built_in\">position</span>);\n                   Toast.makeText(NetworkBannerActivity.<span class=\"hljs-keyword\">this</span>,\n                           <span class=\"hljs-string\">&quot;点击了图片&quot;</span> + <span class=\"hljs-built_in\">position</span> + <span class=\"hljs-string\">&quot; &quot;</span> + bannerData.getDesc(), Toast.LENGTH_SHORT).show();\n\n               &#125;).create(mList);\n       &#125;</code></pre>\n\n<h3 id=\"6-开启与停止轮播\"><a href=\"#6-开启与停止轮播\" class=\"headerlink\" title=\"6.开启与停止轮播\"></a>6.开启与停止轮播</h3><p><strong><em>2.5.0之后版本无需自行在Activity或Fragment中管理stopLoop和startLoop方法，但这两个方法依旧保留对外开发</em></strong></p>\n<p><del>如果开启了自动轮播功能，请务必在onDestroy中停止轮播，以免出现内存泄漏。</del></p>\n<pre><code class=\"hljs aspectj\"><span class=\"hljs-meta\">@Override</span>\n   <span class=\"hljs-keyword\">protected</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onDestroy</span><span class=\"hljs-params\">()</span> </span>&#123;\n       <span class=\"hljs-keyword\">super</span>.onDestroy();\n       <span class=\"hljs-keyword\">if</span> (mBannerViewPager != <span class=\"hljs-keyword\">null</span>)\n   \t\tmViewpager.stopLoop();\n   &#125;</code></pre>\n<p><del>为了节省性能也可以在onStop中停止轮播，在onResume中开启轮播：</del></p>\n<pre><code class=\"hljs aspectj\"><span class=\"hljs-meta\">@Override</span>\n<span class=\"hljs-keyword\">protected</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onStop</span><span class=\"hljs-params\">()</span> </span>&#123;\n    <span class=\"hljs-keyword\">super</span>.onStop();\n    <span class=\"hljs-keyword\">if</span> (mBannerViewPager != <span class=\"hljs-keyword\">null</span>)\n        mBannerViewPager.stopLoop();\n&#125;\n\n<span class=\"hljs-meta\">@Override</span>\n<span class=\"hljs-keyword\">protected</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onResume</span><span class=\"hljs-params\">()</span> </span>&#123;\n    <span class=\"hljs-keyword\">super</span>.onResume();\n    <span class=\"hljs-keyword\">if</span> (mBannerViewPager != <span class=\"hljs-keyword\">null</span>)\n        mBannerViewPager.startLoop();\n&#125;</code></pre>\n\n<h1 id=\"三、高级功能—自定义IndicatorView\"><a href=\"#三、高级功能—自定义IndicatorView\" class=\"headerlink\" title=\"三、高级功能—自定义IndicatorView\"></a>三、高级功能—自定义IndicatorView</h1><p>因为指示器的样式千变万化,BannerViewPager中不可能内置所有的样式，因此我将定义权限交给了开发者自己来实现，这样就可以满足所有开发者的需求了。但是自定义IndicatorView需要有一定的自定义View基础，尽管我已经在BaseIndicatorView中处理了许多逻辑，但是还是要开发者根据自身需求进行Indicator的绘制。好了，下面就让我们来看看如何实现自定义IndicatorView吧。</p>\n<p>关于自定义IndicatorView其实我们在第一节中讲解Indicator摆放位置时已经提到了，就是通过setIndicator(IIndicator)来替换内部的指示器。当然，这个方法接收的参数不仅仅是内置的两个IndicatorView，它还可以是我们自己实现的Indicator。前提只需要继承BaseIndicatorView或者继承View并实现IIndicator，然后根据需求绘制即可。</p>\n<h3 id=\"1-认识BaseIndicatorView\"><a href=\"#1-认识BaseIndicatorView\" class=\"headerlink\" title=\"(1)认识BaseIndicatorView\"></a>(1)认识BaseIndicatorView</h3><p>BaseIndicatorView是BannerViewPager库中的一个类，它继承自View并实现了IIndicator接口。在这个类中存储了BannerViewPager的许多参数信息，比如页面个数(pageSize)、页面滑动进度(slideProgress)以及当前页面位置(currentPosition)等，这些都是在绘制IndicatorView时会用到的信息。有了这些参数之后我们就可以比较轻松的去绘制指示器了。如果你觉得我这些数据计算的不够精确或者计算存在错误，那么你大可以自己实现IIndicator接口自行计算。本文我会通过继承BaseIndicatorView的方式来实现一个自定义指示器的例子。<br>你可以点击链接查看<a href=\"https://github.com/zhpanvip/BannerViewPager/blob/master/bannerview/src/main/java/com/zhpan/bannerview/indicator/BaseIndicatorView.java\">BaseIndicatorView</a>的完整代码。</p>\n<h3 id=\"2-开启自定义IndicatorView之路\"><a href=\"#2-开启自定义IndicatorView之路\" class=\"headerlink\" title=\"(2)开启自定义IndicatorView之路\"></a>(2)开启自定义IndicatorView之路</h3><p>好了，接下来我们就来完成一个如下图所示的自定义IndicatorView吧！</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMS8xNi8xNmU3NDdhMGJmZDc3MGE1?x-oss-process=image/format,png\"></p>\n<p><strong>新建一个FigureIndicatorView类并继承BaseIndicatorView</strong></p>\n<pre><code class=\"hljs reasonml\">public <span class=\"hljs-keyword\">class</span> FigureIndicatorView extends BaseIndicatorView &#123;\n\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-built_in\">int</span> radius = <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">DpUtils</span>.</span></span>dp2px(<span class=\"hljs-number\">20</span>);\n\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-built_in\">int</span> backgroundColor = <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">Color</span>.</span></span>parse<span class=\"hljs-constructor\">Color(<span class=\"hljs-string\">&quot;#88FF5252&quot;</span>)</span>;\n\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-built_in\">int</span> textColor = Color.WHITE;\n\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-built_in\">int</span> textSize=<span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">DpUtils</span>.</span></span>dp2px(<span class=\"hljs-number\">13</span>);\n\n    <span class=\"hljs-comment\">// ...省略无关代码</span>\n\n    @Override\n    protected void on<span class=\"hljs-constructor\">Measure(<span class=\"hljs-params\">int</span> <span class=\"hljs-params\">widthMeasureSpec</span>, <span class=\"hljs-params\">int</span> <span class=\"hljs-params\">heightMeasureSpec</span>)</span> &#123;\n        super.on<span class=\"hljs-constructor\">Measure(<span class=\"hljs-params\">widthMeasureSpec</span>, <span class=\"hljs-params\">heightMeasureSpec</span>)</span>;\n        set<span class=\"hljs-constructor\">MeasuredDimension(2 <span class=\"hljs-operator\">*</span> <span class=\"hljs-params\">radius</span>, 2 <span class=\"hljs-operator\">*</span> <span class=\"hljs-params\">radius</span>)</span>;\n    &#125;\n\n    @Override\n    protected void on<span class=\"hljs-constructor\">Draw(Canvas <span class=\"hljs-params\">canvas</span>)</span> &#123;\n        super.on<span class=\"hljs-constructor\">Draw(<span class=\"hljs-params\">canvas</span>)</span>;\n        mPaint.set<span class=\"hljs-constructor\">Color(<span class=\"hljs-params\">backgroundColor</span>)</span>;\n        canvas.draw<span class=\"hljs-constructor\">Circle(<span class=\"hljs-params\">getWidth</span>()</span><span class=\"hljs-operator\"> / </span><span class=\"hljs-number\">2</span>, get<span class=\"hljs-constructor\">Height()</span><span class=\"hljs-operator\"> / </span><span class=\"hljs-number\">2</span>, radius, mPaint);\n        mPaint.set<span class=\"hljs-constructor\">Color(<span class=\"hljs-params\">textColor</span>)</span>;\n        mPaint.set<span class=\"hljs-constructor\">TextSize(<span class=\"hljs-params\">textSize</span>)</span>;\n        String text = currentPosition + <span class=\"hljs-number\">1</span> + <span class=\"hljs-string\">&quot;/&quot;</span> + pageSize;\n        <span class=\"hljs-built_in\">int</span> textWidth = (<span class=\"hljs-built_in\">int</span>) mPaint.measure<span class=\"hljs-constructor\">Text(<span class=\"hljs-params\">text</span>)</span>;\n        Paint.FontMetricsInt fontMetricsInt = mPaint.get<span class=\"hljs-constructor\">FontMetricsInt()</span>;\n        <span class=\"hljs-built_in\">int</span> baseline = (get<span class=\"hljs-constructor\">MeasuredHeight()</span> - fontMetricsInt.bottom + fontMetricsInt.top)<span class=\"hljs-operator\"> / </span><span class=\"hljs-number\">2</span> - fontMetricsInt.top;\n        canvas.draw<span class=\"hljs-constructor\">Text(<span class=\"hljs-params\">text</span>, (<span class=\"hljs-params\">getWidth</span>()</span> - textWidth)<span class=\"hljs-operator\"> / </span><span class=\"hljs-number\">2</span>, baseline, mPaint);\n    &#125;\n\n    public void set<span class=\"hljs-constructor\">Radius(<span class=\"hljs-params\">int</span> <span class=\"hljs-params\">radius</span>)</span> &#123;\n        this.radius = radius;\n    &#125;\n\n    @Override\n    public void set<span class=\"hljs-constructor\">BackgroundColor(@ColorInt <span class=\"hljs-params\">int</span> <span class=\"hljs-params\">backgroundColor</span>)</span> &#123;\n        this.backgroundColor = backgroundColor;\n    &#125;\n\n    public void set<span class=\"hljs-constructor\">TextSize(<span class=\"hljs-params\">int</span> <span class=\"hljs-params\">textSize</span>)</span> &#123;\n        this.textSize = textSize;\n    &#125;\n    <span class=\"hljs-comment\">// ...省略无关代码</span>\n&#125;</code></pre>\n<p>有自定义View基础的同学应该能很轻松的看懂上边的代码。首先通过onMeasure()方法测量了View的大小，接下来就是在onDraw方法中绘制圆和文字了。很容易就实现了一个自定义的IndicatorView。当然，这个例子本身就比较简单。如果你需要绘制比较复杂且带有动画的Indicator，可以参考源码中的CircleIndicatorView和DashIndicatorView，或许它能给你一些灵感。</p>\n<h3 id=\"3-设置自定义指示器\"><a href=\"#3-设置自定义指示器\" class=\"headerlink\" title=\"(3)设置自定义指示器\"></a>(3)设置自定义指示器</h3><p>接下来就将我们自己绘制的指示器设置到BannerViewPager中吧！</p>\n<pre><code class=\"hljs reasonml\">FigureIndicatorView indicatorView = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-constructor\">FigureIndicatorView(<span class=\"hljs-params\">mContext</span>)</span>;\nindicatorView.set<span class=\"hljs-constructor\">Radius(BannerUtils.<span class=\"hljs-params\">dp2px</span>(18)</span>);\nindicatorView.set<span class=\"hljs-constructor\">TextSize(BannerUtils.<span class=\"hljs-params\">dp2px</span>(13)</span>);\nindicatorView.set<span class=\"hljs-constructor\">BackgroundColor(Color.<span class=\"hljs-params\">parseColor</span>(<span class=\"hljs-string\">&quot;#aa118EEA&quot;</span>)</span>);\n\nmViewPager.set<span class=\"hljs-constructor\">IndicatorGravity(IndicatorGravity.END)</span>\n          .set<span class=\"hljs-constructor\">IndicatorView(<span class=\"hljs-params\">indicatorView</span>)</span>\n          .set<span class=\"hljs-constructor\">HolderCreator(()</span> -&gt; <span class=\"hljs-keyword\">new</span> <span class=\"hljs-constructor\">ImageResourceViewHolder(0)</span>)\n          .create(mDrawableList);</code></pre>\n<p>依然如此潇洒自然！好了，关于BannerViewPager的介绍今天就讲解到这里了。接下来的一篇文章将会对BannerViewPager的源码进行剖析，了解下它是如何通过简单的Api实现来实现复杂的功能的。</p>\n<p>都看到这里了，确定不到GitHub点个星再走？源码已放到文章末尾。如果有好的Idea也欢迎Pull Request。</p>\n<p><a href=\"https://juejin.im/post/5d74d3faf265da03b5747015\">《BannerViewPager源码解析》</a></p>\n<p><a href=\"https://github.com/zhpanvip/BannerViewPager\">源码下载</a></p>\n<p><strong>文章上次更新2019.11.16</strong></p>\n"},{"title":"BannerViewPager源码剖析(二)","date":"2019-09-08T07:06:16.000Z","_content":"\nBannerViewPager系列文章共三篇，此文为第二篇，另外两篇参看下面链接：\n\n[《打造一个丝滑般自动轮播无限循环Android库》](https://blog.csdn.net/qq_20521573/article/details/100186077)\n\n[《剖析BannerViewPager中Indicator的设计思想》](https://blog.csdn.net/qq_20521573/article/details/103216593)\n\n\n\n\n上篇文章[《打造一个丝滑般自动轮播无限循环Android库》](https://juejin.im/post/5d6bce24f265da03db0790d1)非常详细的介绍了[BannerViewPager](https://github.com/zhpanvip/BannerViewPager)的基础功能及使用方法。我们知道BannerViewPager不但可以支持任意的页面布局，而且可以支持任意的Indicator。那么[BannerViewPager](https://github.com/zhpanvip/BannerViewPager)的这些功能是如何实现的呢？本篇文章将深入源码来带大家了解[BannerViewPager](https://github.com/zhpanvip/BannerViewPager)的设计思路。\n\n# 一、如何支持任意的Item布局\n\n产品的需求千变万化，你永远也猜不到下一步产品会给你提一个什么样的需求。因此对于一个比较人性化的Banner库来说，它也应该支持开发者去自定义任意的Item页面布局。BannerViewPager就是本着这样的思路来做的。接下来将通过两小节的内容来探究BannerViewPager是如何实现任意Item布局的。\n\n## 1.BannerViewPager的ViewHolder\n我们先从setHolderCreator(HolderCreator<VH> holderCreator)这个方法说起。在使用BannerViewPager的时候必须设置一个HolderCreator，代码如下：\n\n```java\nbannerViewPager.setHolderCreator(new HolderCreator<CustomPageViewHolder>() {\n                    @Override\n                    public CustomPageViewHolder createViewHolder() {\n                        return new CustomPageViewHolder();\n                    }\n                })\n```\n在HolderCreator的createViewHolder方法中返回了一个CustomPageViewHolder，这个CustomPageViewHolder是我们自己实现的。其内部会通过createView方法来inflate出来一自定义的itemView,并在onBind方法中为itemView绑定数据。码如下：\n\n```java\npublic class CustomPageViewHolder implements ViewHolder<CustomBean> {\n    private ImageView mImageView;\n    private TextView mTextView;\n    @Override\n    public View createView(ViewGroup viewGroup, Context context, int position) {\n        View view = LayoutInflater.from(context).inflate(R.layout.item_custom_view, viewGroup, false);\n        mImageView = view.findViewById(R.id.banner_image);\n        mTextView = view.findViewById(R.id.tv_describe);\n        return view;\n    }\n\n    @Override\n    public void onBind(Context context, CustomBean data, int position, int size) {\n        mImageView.setImageResource(data.getImageRes());\n        mTextView.setText(data.getImageDescription());\n    }\n    ...\n}\n```\n在BannerViewPager内部setupViewPager的时候，针对HolderCreator做了如下操作：\n\n```java\n\t private void setupViewPager() {\n\t        if (holderCreator != null) {\n\t             BannerPagerAdapter<T, VH> bannerPagerAdapter =\n                    new BannerPagerAdapter<>(mList, holderCreator);\n           \t\t bannerPagerAdapter.setPageStyle(mPageStyle);\n           \t\t bannerPagerAdapter.setCanLoop(isCanLoop);\n         \t\t bannerPagerAdapter.setPageClickListener(position -> {\n\t                if (mOnPageClickListener != null) {\n\t                    mOnPageClickListener.onPageClick(PositionUtils.getRealPosition(isCanLoop, position, mList.size(), mPageStyle));\n                \t}\n            });\n            mViewPager.setAdapter(bannerPagerAdapter);\n\t        \t\t...\n\t        } else {\n\t            throw new NullPointerException(\"You must set HolderCreator for BannerViewPager\");\n\t        }\n\t    }\n```\n上述代码中判断如果holderCreator为null时就抛出了一个NullPointerException，这也解释了为什么必须要为BannenrViewPager设置holderCreator。当holderCreator不为null时，将holder传递到了BannerPagerAdapter中,并且为BannerPagerAdapter设置了相关参数和页面点击事件。\n\n我们接下来到BannerPagerAdapter中一探究竟：\n\n```java\npublic class BannerPagerAdapter<T, VH extends ViewHolder> extends PagerAdapter {\n\t \n    @Override\n    public @NonNull\n    Object instantiateItem(@NonNull final ViewGroup container, final int position) {\n        View itemView = getView(PositionUtils.getRealPosition(isCanLoop, position, mList.size(), mPageStyle),container);\n        container.addView(itemView);\n        return itemView;\n    }\n\n\t\t...\n\t@SuppressWarnings(\"unchecked\")\n    private View getView(final int position, ViewGroup container) {\n        ViewHolder<T> holder = holderCreator.createViewHolder();\n        if (holder == null) {\n            throw new RuntimeException(\"can not return a null holder\");\n        }\n        return createView(holder, position, container);\n    }\n    \n\tprivate View createView(ViewHolder<T> holder, int position, ViewGroup container) {\n\t        View view = null;\n\t        if (list != null && list.size() > 0) {\n\t          view = holder.createView(container, container.getContext(), position);\n\t          holder.onBind(container.getContext(), list.get(position), position, list.size());\n\t        return view;\n\t    }\n\n}\n```\n在BannerPagerAdapter的getView方法中通过holderCreator.createViewHolder()拿到了自定义的ViewHolder，此时即为上边的CustomPageViewHolder 。接下来在createView方法中调用CustomPageViewHolder的createView方法拿到我们自定义的itemView,并通过holder.onBind方法将集合中的数据传递给了CustomPageViewHolder。到这里我们就完成了自定义item布局以及item数据的绑定。\n## 2 .BannerViewPager的泛型设计\n在上一小节中通过HolderCreator来实现任意的页面布局，但此时我们应该会面临一个问题，既然可以支持任意的页面布局那么BannerViewPager中接收的数据也应该时任意类型的。对于该问题我们可以引入泛型来实现。首先看BannerViewPager的泛型：\n\n```java\npublic class BannerViewPager<T, VH extends ViewHolder> extends RelativeLayout implements\n        ViewPager.OnPageChangeListener {\n        \n\t// 轮播数据集合\n        private List<T> mList;\n\n\tprivate HolderCreator<VH> holderCreator;\n    \n\t//\t...\n}\n```\nBannerViewPager有两个泛型参数，第一个参数T是对应的数据类型，它用来作为BannerViewPager中List集合的泛型。另一个泛型参数VH规定了必须是继承ViewHolder的类，用来作为HolderCreator的泛型。而ViewHolder和HolderCreator均是一个带有泛型参数的接口，其代码如下：\n\n```java\npublic interface ViewHolder<T> {\n    View createView(ViewGroup viewGroup,Context context, int position);\n    \n    /**\n     * @param context context\n     * @param data 实体类对象\n     * @param position 当前位置\n     * @param size 页面个数\n     */\n    void onBind(Context context,T data,int position,int size);\n}\n\npublic interface HolderCreator<VH extends ViewHolder> {\n    /**\n     * 创建ViewHolder\n     */\n    VH createViewHolder();\n}\n```\n另外，T和VH两个泛型也同时作为BannerPagerAdapter的泛型参数：\n\n```java\npublic class BannerPagerAdapter<T, VH extends ViewHolder> extends PagerAdapter {\n\n\tprivate List<T> list;\n\t \n\tpublic BannerPagerAdapter(List<T> list, HolderCreator<VH> holderCreator) {\n\t        this.list = list;\n\t        this.holderCreator = holderCreator;\n\t    }\n\n}\n```\n可以看到，我们通过泛型约束，使得涉及到的相关类中的参数数据类型保持了同步,从而实现了BannerViewPager可以接收并处理任意的数据类型。\n\n# 二、如何实现无限循环轮播\n\n关于ViewPager的无限循环无外乎两种方案。\n\n第一种方案是在PagerAdapter的getCount中返回一个Integer.MAX_VALUE，即一个最大的Integer整数。然后将setCurrentItem的值设置为 Integer.MAX_VALUE / 2，在滑动过程中不断取余以此来达到一个无限循环轮播的假象。\n\n另外一种方案是额外增加两个ViewPager的item count，然后在第0个Item填充最后一条数据，在最后一个Item填充第0条数据。当右滑到第一个Item的时候将currentItem置为pageSize-1,当滑动到最后一个Item的时候将currentItem置为1，以此来达到一个无限循环的目的，此方案的示意图如下：\n\n![无限循环示意图](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMS8xNy8xNmU3ODVhZDcyYmQ2NzQz?x-oss-process=image/format,png)\nBannerViewPager的无限轮播使用的是第二种方案。至于这两种方案孰优孰劣不好判断，因为我并没有深入研究过方案一，因此对比这两种方案的优略对比我暂时没有发言权。但是关于第二种方案的优略我可以加以分析。\n\n## 方案二的优点：\n**1.这一方案实现了真正意义上的无限轮播**\n\n相比方案一设置了一个最大值来制造无限轮播的假象，方案二实现的是一种真正的无限轮播。这个方案通过手动切换position使得轮播能够无限持续下去。这一点可能要略优于方案一。（其实Integer.MAX_VALUE的数值已经达到了数十亿级别，即使从一数到十亿恐怕都要几天吧？所以这一点也算不上方案一的缺点）\n\n**2.页面切换较少出现空白页**\n\n曾经看过几个使用方案一实现的Banner都有偶尔出现空白页的问题，当然不排除是这些库写的有问题，毕竟我也见过使用方案一实现非常好的库。而BannerViewPager在使用方案二时并没有经过什么特殊处理，却也很少见到空白页问题，当然也不排除是我代码写的好。（板儿砖尽管扔过来吧，哈哈！）。\n\n## 方案二的缺点：\n虽然BannerViewPager使用的是方案二，但是秉着公正的态度，绝不包庇这一方案的缺点。这个方案的优点虽然我苦思冥想也只想出来了两条，但是关于它的缺点我却能罗列出来很多。正所谓谁(sei)用谁(sei)知道！\n\n**1.onPageSelected(int)方法重复调用问题**\n\n我们为BannerViewPager开启自动轮播，并为其设置页面改变的监听事件，如下：\n```java\n mBannerViewPager.setAutoPlay(true)\n \t\t\t.setOnPageChangeListener(new OnPageChangeListenerAdapter() {\n                    @Override\n                    public void onPageSelected(int position) {\n                        BannerUtils.e(\"position \" + position);\n                    }\n                })\n```\n然后可以看到打印的Log：\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMS8xNy8xNmU3ODVhZDcyZThkZDZm?x-oss-process=image/format,png)\n在BannerViewPager只有三个页面的情况下，页面position selected的周期是0、1、2、0。很明显，第0个页面被多调用了一次。虽然在大多数情况下并没有影响，但是当需要在选中第0个页面时做一些逻辑的话，就会产生一定影响。至于这个问题有没有解决办法，暂时还未去做进一步探究。\n\n**2.在一屏三页模式下，这一方案在轮播到最后一页时会出现下一页短暂空白的问题**\n\n出现这一问题的原因是因为为了完成循环在切换到最后一页时我们立即将position切换到了position为1的页面，而此时position为2个页面还未加载出来，因此就有了短暂的空白问题。为了解决这一问题，又不得不在原来循环的基础上再增加两个页面，并将setOffscreenPageLimit设置为2。这样无形中增加了内存开销，并且使得逻辑处理变得更为复杂！\n\n**3.需要对position进行变换**\n\n为了实现循环我们将page count增加了2，为了解决一屏三页的空白问题我们将page count增加了4。但对外暴露的接口需要拿到正确的position，此时我们就不得不在BannerViewPager内部对position进行变换，使之能够对应到正确的position。虽然解决了问题，但是这些逻辑处理却变得很臃肿。尽管方案一也会存在position的变换问题，但是相比方案二还是优雅很多。\n\n综上来看，方案二其实并不是一个完美的方案，相反它却存在诸多的问题！但是由于没有用过方案一，所以对于方案一有没有坑，现在也不好妄下结论。有熟悉方案一的同学可以在文章下留言告知。后续我会单独开一个分支来尝试下方案一。如果方案一没有大问题，BannerViewPager的循环轮播方案可能会迁移到第一个解决方案（目前2.4.3版本已切换为方案一，许多问题迎刃而解。真香！）。\n\n\n# 三、千变万化的Indicator\n在最初的设计中，BannerViewPager同其它大多Bannenr库一样,内部维护了一个Indicator的List集合用来存放Indicator的icon，然后根据页面size动态的添加Indicator。显然这样的Indicator非常不灵活，如果UI觉得之前颜色不好看，需要换个颜色。你说，OK！没关系，你给我切图就好了。但是如果UI说我需要一个Indicator跟随ViewPager滑动的效果，那么此时你一定一脸茫然不知所措！于是和UI开启了漫长的拉锯战...扯远了，我们继续回归正题。考虑到这个问题，在后来的版本中针对Indicator进行了优化重构，现在的BannerViewPager已经可以支持任意样式的Indicator。并且还可以根据需求任意摆放Indicator的位置。是否期待了解这些神奇的功能是如何实现的呢？接下来就一起来探究\n首先，定义了一个IIndicator的接口，该接口继承了ViewPager.OnPageChangeListener接口。其代码如下：\n\n```java\npublic interface IIndicator extends ViewPager.OnPageChangeListener {\n    void setPageSize(int pageSize);\n\n    void setNormalColor(int normalColor);\n\n    void setCheckedColor(int checkedColor);\n\n    void setSlideMode(IndicatorSlideMode slideStyle);\n\n    void setIndicatorGap(int gap);\n\n    void setIndicatorWidth(int normalIndicatorWidth, int checkedIndicatorWidth);\n\n    void notifyDataChanged();\n}\n\n```\n在BannerViewPager内部持有了IIndicator的实例，并且setIndicatorView方法只接收IIndicator类型的参数。代码如下：\n\n```java\npublic class BannerPagerAdapter<T, VH extends ViewHolder> extends PagerAdapter {\n\t\n\t\t// 轮播指示器\n\t    private IIndicator mIndicatorView;\n\n\t\t/**\n\t     * 设置自定义View指示器,自定义View需要需要继承BaseIndicator或者实现IIndicator接口自行绘制指示器。\n\t     * 注意，一旦设置了自定义IndicatorView,通过BannerViewPager设置的部分IndicatorView参数将失效。\n\t     *\n\t     * @param customIndicator 自定义指示器\n\t     */\n\t    public BannerViewPager<T, VH> setIndicatorView(IIndicator customIndicator) {\n\t        if (customIndicator instanceof View) {\n\t            isCustomIndicator = true;\n\t            mIndicatorView = customIndicator;\n\t        }\n\t        return this;\n\t    }\n}\n```\n在setIndicatorView内部通过判断customIndicator是否是View的实例，以此确保了指示器必须继承自View并实现IIndicator接口。并且可以看到在满足条件的情况下将isCustomIndicator置为了true，以此来标记是否是自定义的指示器。如果外部没有调用setIndicatorView设置自定义指示器或者设置的指示器不符合要求，那么mIndicatorView岂不是就为null了？不慌，我们接着往下看代码：\n\n```java\npublic class BannerPagerAdapter<T, VH extends ViewHolder> extends PagerAdapter {\n   /**\n     * 构造ViewPager\n     *\n     * @param list ViewPager数据\n     */\n    public void create(List<T> list) {\n        initBannerData(list);\n    }\n\n\tprivate void initBannerData(List<T> list) {\n\t        if (list != null) {\n\t            mList.clear();\n\t            mList.addAll(list);\n\t            if (mList.size() > 0) {\n\t                if (mList.size() > 1) {\n\t                    if (isCustomIndicator && null != mIndicatorView) {\n\t                        initIndicator(mIndicatorView);\n\t                    } else {\n\t                        initIndicator(IndicatorFactory.createIndicatorView(getContext(), mIndicatorStyle));\n\t                    }\n\t                }\n\t                // ...\n\t            }\n\t        }\n\t    }\n}\n```\n我们在使用BannerViewPager的时候设置完参数配置之后需要调用create(List\\<T\\> list)方法，在这个方法中会根据list的数据情况来初始化Indicator。上述代码中只有在list.size()大于1的时候才会初始化Indicator，并且在后边判断如果是自定义的Indicator就直接初始化指示器，如果没有自定义指示器，那么就调用指示器工厂，根据设置的指示器Style生成内置指示器样式。这么一来就实现了内置指示器和自定义指示器的切换。\n\n那么问题又来了，关于Indicator位置任意摆放是如何实现的呢？为什么自定义指示器可以直接new出来，也可以放在xml中呢？关于这两个问题就需要来看下initIndicator做了什么操作了。\n\n```java\nprivate void initIndicator(IIndicator indicatorView) {\n        mIndicatorLayout.setVisibility(mIndicatorVisibility);\n        mIndicatorView = indicatorView;\n        if (((View) mIndicatorView).getParent() == null) {\n            mIndicatorLayout.removeAllViews();\n            mIndicatorLayout.addView((View) mIndicatorView);\n            initIndicatorViewMargin();\n            initIndicatorGravity();\n        }\n    }\n```\n在initIndicator中会首先判断indicatorView的parent是否为null。什么情况下indicatorView的parent会为null呢？答案就是内置指示器和setIndicatorView()的参数通过new的方式传进来的情况下indicatorView的parent会是null的情况！那么此时就将indicator添加到BannerViewPager内部mIndicatorLayout中就可以了。而如果Indicator是声明在xml中的情况，此时通过findViewById获得的Indicator其parent一定不会是null，那么在initIndicator中只是将其赋值给了mIndicatorView。以此完成了对内置IndicatorView的替换。这样其实不管通过怎样的方法设置IndicatorView都保证了BannerViewPager内部始终只会维护一个Indicator。方法非常巧妙，这里我想要一个赞！（似乎又嗅到了板儿砖的气息）\n\n\n\n# 四、遇到的其他问题及解决方案\n在BannerViewPager的开发过避免不了的会碰到一些问题，虽然有些已经解决了，但有些可能还悬而未决。但是不管解决没解决以供大家参考或讨论。\n\n## 1.手指滑动页面过程中应停止自动轮播\n\n自动轮播的功能是通过Handler来实现的。通过postDelayed开启轮播，通过removeCallbacks停止轮播。代码如下：\n\n```java\n/**\n     * 开启轮播\n     */\n    public void startLoop() {\n        if (!isLooping && isAutoPlay && mList.size() > 1) {\n            mHandler.postDelayed(mRunnable, interval);\n            isLooping = true;\n        }\n    }\n\n    /**\n     * 停止轮播\n     */\n    public void stopLoop() {\n        if (isLooping) {\n            mHandler.removeCallbacks(mRunnable);\n            isLooping = false;\n        }\n    }\n```\n如果在手指滑动的过程中没有停止轮播，体验上来说非常不好。因此，需要处理这种情况。解决方案是重写ViewPager的setOnTouchListener方法，监听手指滑动的时候停止轮播，抬起手指的时候开启轮播。代码如下：\n\n```java\n private void setTouchListener() {\n        mViewPager.setOnTouchListener((v, event) -> {\n            int action = event.getAction();\n            switch (action) {\n                case MotionEvent.ACTION_DOWN:\n                case MotionEvent.ACTION_MOVE:\n                    isLooping = true;\n                    stopLoop();\n                    break;\n                case MotionEvent.ACTION_UP:\n                case MotionEvent.ACTION_CANCEL:\n                    isLooping = false;\n                    startLoop();\n                default:\n                    break;\n            }\n            return false;\n        });\n    }\n```\n\n## 2.关于instantiateItem的优化问题\n我们知道，在ViewPager每次切换页面的时候都会调用instantiateItem去实例化ItemView，也就意味着我们在这个方法中通过ViewHolder的createView方法每次切换页面都会被调用重新初始化绑定数据。这样对程序来说是一种性能上的浪费。针对这种情况，在2.4.3之前的版本中做了些优化。在BannerPagerAdapter中维护一个List<View> mViewList集合，用来存放创建出来的itemView.在itemView初始化成功后，为其设置tag并保存到集合中，当在此切换页面时我们从集合中取出itemView并对比tag,如果一致则直接使用即可。这样就避免了重复的创建对象，造成一些性能开销。具体代码如下：\n\n```java\npublic class BannerPagerAdapter<T, VH extends ViewHolder> extends PagerAdapter {\n\n\tprivate List<View> mViewList = new ArrayList<>();\n\n\tprivate View findViewByPosition(ViewGroup container, int position) {\n\t        for (View view : mViewList) {\n\t            if (((int) view.getTag()) == position && view.getParent() == null) {\n\t                return view;\n\t            }\n\t        }\n\t        View view = getView(position, container);\n\t        view.setTag(position);\n\t        mViewList.add(view);\n\t        return view;\n\t    }\n}\n```\n但是这一优化却又会引发另一个问题，即内存问题！通常App的轮播控件都是图片，而图片是比较占用内存的。此时我们把所有的itemView都存储在一个集合中这样真的是一个好的方案吗？在ViewPager页面少的情况下问题可能不会凸显。但是如果ViewPager的页面很多的情况下问题就相当严重了！于是，后来我灵光一闪，突发奇想！那我就设置一个最大缓存呗？当集合中的个数超过阈值的时候就把最近用过的一个itemView移除掉不就好了？妙哉妙哉！可转念一想，这尼玛和设置一个setOffscreenPageLimit有什么区别呢？当我们在考虑这些问题的时候Google工程师早就替我们想到了！所以关于ViewPager的instantiateItem是否有必要去优化我目前持保留态度。但是，在BannerViewPager 2.4.3之前的版本中确实做了上述优化，因此前些版本中可能会存在内存问题。至于2.4.3或之后版本大概会去掉这部分优化。这个问题可能也只能留在未来，待升级到ViewPager2后解决了！关于这个问题欢迎大家在文章下方留言，各抒己见！\n\n## 3.RecyclerView+ViewPager会有非Smooth的页面滑动情况\n\n这个问题不是太好描述，我们直接通过一张GIF来看\n\n![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMS8xOS8xNmU4NDAyYTEyOWI1MGQ3?x-oss-process=image/format,png)\n从图中可以很直观的看到，把BannerViewPager向上划出屏幕再很快划回来，此时BannerViewPager页面切换的动画没有了，很生硬的直接跳到了下一页。这个问题不是BannerViewPager的bug,而是ViewPager内部原因导致的，可以看到很多线上的APP都存在这个问题，例如喜马拉雅（喜马拉雅的轮播图真心做的好看呀，效果也很赞！）。这个bug虽然不影响使用，但是总感觉效果不太好。因此还是要处理一下。处理之前先来分析一下问题原因。\n在ViewPager内部有一个私有成员变量mFirstLayout，其默认值为true。这个参数用来标记是否是第一次layout的。如果是第一次layout那么滑动就不是smooth的。代码如下：\n```\n    public void setCurrentItem(int item) {\n        mPopulatePending = false;\n        setCurrentItemInternal(item, !mFirstLayout, false);\n    }\n    \n    void setCurrentItemInternal(int item, boolean smoothScroll, boolean always) {\n        setCurrentItemInternal(item, smoothScroll, always, 0);\n    }\n```\n这个参数在onLayout方法中会被置为false.代码如下：\n```\n    @Override\n    protected void onLayout(boolean changed, int l, int t, int r, int b) {\n        //  在onLayout的最后一行\n        mFirstLayout = false;\n    }\n```\n因此，在正常情况下，onLayout执行之后页面滑动都应该时smooth的。然后，当ViewPager滑动出屏幕的时候其onDetachedFromWindow方法会被调用，而当其再次进入屏幕的时候则会调用onAttachedToWindow这个方法。来看看onAttachedToWindow方法中的代码：\n```\n@Override\n    protected void onAttachedToWindow() {\n        super.onAttachedToWindow();\n        mFirstLayout = true;\n    }\n```\n仅仅把mFirstLayout置为了true！而如果此时onLayout没有被触发，而是先发生了页面滚动，那么此时的页面滑动就没了的smooth效果了。了解了原因之后处理起来就简单了，因为mFirstLayout是私有属性，我们无法访问，所以只有通过反射来修改其值。我们在CatchViewPager(继承自ViewPager的一个类)中做如下操作：\n\n```\nprivate boolean firstLayout = true;\n\n @Override\n    protected void onAttachedToWindow() {\n        super.onAttachedToWindow();\n        hookFirstLayout();\n    }\n\n\n    @Override\n    protected void onDetachedFromWindow() {\n        super.onDetachedFromWindow();\n        firstLayout = false;\n    }\n\n private void hookFirstLayout() {\n        try {\n            Field mFirstLayout = ViewPager.class.getDeclaredField(\"mFirstLayout\");\n            mFirstLayout.setAccessible(true);\n            mFirstLayout.set(this, firstLayout);\n            setCurrentItem(getCurrentItem());\n        } catch (IllegalAccessException | NoSuchFieldException e) {\n            e.printStackTrace();\n        }\n    }\n\n```\n这样问题就迎刃而解了，再次滑动RecyclerView，一切完好！\n## 4.关于Indicator在SMOOTH下的滑动问题。\n这是一个由来已久的问题，感觉好难处理！如果不处理循环的话其实是非常容易的，但是如果加上循环之后总是有这样那的问题😂。只能说目前的计算方式不是太对，具体怎么计算的我也不贴出来了！毕竟现在写出来的还是有bug的。很羡慕喜马拉雅的滑动效果做的太Nice了！后续版本中我会想办法再优化这个问题。\n\n# 五、总结及致谢\n到这里关于BannerViewPager的两篇文章就全部结束了，[上一篇文章](https://juejin.im/post/5d6bce24f265da03db0790d1)主要着重介绍了BannerViewPager的功能及用法，而本篇文章则详细的讲解了BannerViewPager的实现原理。就目前而言，BannerViewPager并不是一个完美的轮播库，很多地方还有很大值得优化的空间甚至有些功能还存在一些小bug。但是这些都不会阻碍BannerViewPager逐渐走向优秀。在未来的版本中我将会针对这些问题逐一优化。当然，如果你有好的解决方案欢迎在文章下方留言，也可以直接到github提交pull request。如果你有什么好的建议或者遇到什么问题也欢迎在文章下方留言讨论。\n\n最后要特别感谢saiwu-bigkoo大神的[Android-ConvenientBanner](https://github.com/saiwu-bigkoo/Android-ConvenientBanner)库以及youth5201314大神的[banner](https://github.com/youth5201314/banner)库。BannerViewPager中的很多思想来自这两个库。BannerViewPager中内置的四个ViewPager Transform来自[ViewPagerTransforms](https://github.com/ToxicBakery/ViewPagerTransforms)库，在此表示感谢。同时还要感谢[玩Android](https://wanandroid.com/)提供的接口支持，以及在开发过程中参考过的文章或其它优秀开源库，不能一一列出，在此一并表示感谢。\n\n最后还是要贴上源码地址，欢迎star、fork 。\n\n[点击查看源码](https://github.com/zhpanvip/BannerViewPager)","source":"_posts/20.BannerViewPager源码剖析(二).md","raw":"---\ntitle: BannerViewPager源码剖析(二)\ndate:  2019-09-08 15:06:16\ntags: \n- 自定义View\n- Banner\n---\n\nBannerViewPager系列文章共三篇，此文为第二篇，另外两篇参看下面链接：\n\n[《打造一个丝滑般自动轮播无限循环Android库》](https://blog.csdn.net/qq_20521573/article/details/100186077)\n\n[《剖析BannerViewPager中Indicator的设计思想》](https://blog.csdn.net/qq_20521573/article/details/103216593)\n\n\n\n\n上篇文章[《打造一个丝滑般自动轮播无限循环Android库》](https://juejin.im/post/5d6bce24f265da03db0790d1)非常详细的介绍了[BannerViewPager](https://github.com/zhpanvip/BannerViewPager)的基础功能及使用方法。我们知道BannerViewPager不但可以支持任意的页面布局，而且可以支持任意的Indicator。那么[BannerViewPager](https://github.com/zhpanvip/BannerViewPager)的这些功能是如何实现的呢？本篇文章将深入源码来带大家了解[BannerViewPager](https://github.com/zhpanvip/BannerViewPager)的设计思路。\n\n# 一、如何支持任意的Item布局\n\n产品的需求千变万化，你永远也猜不到下一步产品会给你提一个什么样的需求。因此对于一个比较人性化的Banner库来说，它也应该支持开发者去自定义任意的Item页面布局。BannerViewPager就是本着这样的思路来做的。接下来将通过两小节的内容来探究BannerViewPager是如何实现任意Item布局的。\n\n## 1.BannerViewPager的ViewHolder\n我们先从setHolderCreator(HolderCreator<VH> holderCreator)这个方法说起。在使用BannerViewPager的时候必须设置一个HolderCreator，代码如下：\n\n```java\nbannerViewPager.setHolderCreator(new HolderCreator<CustomPageViewHolder>() {\n                    @Override\n                    public CustomPageViewHolder createViewHolder() {\n                        return new CustomPageViewHolder();\n                    }\n                })\n```\n在HolderCreator的createViewHolder方法中返回了一个CustomPageViewHolder，这个CustomPageViewHolder是我们自己实现的。其内部会通过createView方法来inflate出来一自定义的itemView,并在onBind方法中为itemView绑定数据。码如下：\n\n```java\npublic class CustomPageViewHolder implements ViewHolder<CustomBean> {\n    private ImageView mImageView;\n    private TextView mTextView;\n    @Override\n    public View createView(ViewGroup viewGroup, Context context, int position) {\n        View view = LayoutInflater.from(context).inflate(R.layout.item_custom_view, viewGroup, false);\n        mImageView = view.findViewById(R.id.banner_image);\n        mTextView = view.findViewById(R.id.tv_describe);\n        return view;\n    }\n\n    @Override\n    public void onBind(Context context, CustomBean data, int position, int size) {\n        mImageView.setImageResource(data.getImageRes());\n        mTextView.setText(data.getImageDescription());\n    }\n    ...\n}\n```\n在BannerViewPager内部setupViewPager的时候，针对HolderCreator做了如下操作：\n\n```java\n\t private void setupViewPager() {\n\t        if (holderCreator != null) {\n\t             BannerPagerAdapter<T, VH> bannerPagerAdapter =\n                    new BannerPagerAdapter<>(mList, holderCreator);\n           \t\t bannerPagerAdapter.setPageStyle(mPageStyle);\n           \t\t bannerPagerAdapter.setCanLoop(isCanLoop);\n         \t\t bannerPagerAdapter.setPageClickListener(position -> {\n\t                if (mOnPageClickListener != null) {\n\t                    mOnPageClickListener.onPageClick(PositionUtils.getRealPosition(isCanLoop, position, mList.size(), mPageStyle));\n                \t}\n            });\n            mViewPager.setAdapter(bannerPagerAdapter);\n\t        \t\t...\n\t        } else {\n\t            throw new NullPointerException(\"You must set HolderCreator for BannerViewPager\");\n\t        }\n\t    }\n```\n上述代码中判断如果holderCreator为null时就抛出了一个NullPointerException，这也解释了为什么必须要为BannenrViewPager设置holderCreator。当holderCreator不为null时，将holder传递到了BannerPagerAdapter中,并且为BannerPagerAdapter设置了相关参数和页面点击事件。\n\n我们接下来到BannerPagerAdapter中一探究竟：\n\n```java\npublic class BannerPagerAdapter<T, VH extends ViewHolder> extends PagerAdapter {\n\t \n    @Override\n    public @NonNull\n    Object instantiateItem(@NonNull final ViewGroup container, final int position) {\n        View itemView = getView(PositionUtils.getRealPosition(isCanLoop, position, mList.size(), mPageStyle),container);\n        container.addView(itemView);\n        return itemView;\n    }\n\n\t\t...\n\t@SuppressWarnings(\"unchecked\")\n    private View getView(final int position, ViewGroup container) {\n        ViewHolder<T> holder = holderCreator.createViewHolder();\n        if (holder == null) {\n            throw new RuntimeException(\"can not return a null holder\");\n        }\n        return createView(holder, position, container);\n    }\n    \n\tprivate View createView(ViewHolder<T> holder, int position, ViewGroup container) {\n\t        View view = null;\n\t        if (list != null && list.size() > 0) {\n\t          view = holder.createView(container, container.getContext(), position);\n\t          holder.onBind(container.getContext(), list.get(position), position, list.size());\n\t        return view;\n\t    }\n\n}\n```\n在BannerPagerAdapter的getView方法中通过holderCreator.createViewHolder()拿到了自定义的ViewHolder，此时即为上边的CustomPageViewHolder 。接下来在createView方法中调用CustomPageViewHolder的createView方法拿到我们自定义的itemView,并通过holder.onBind方法将集合中的数据传递给了CustomPageViewHolder。到这里我们就完成了自定义item布局以及item数据的绑定。\n## 2 .BannerViewPager的泛型设计\n在上一小节中通过HolderCreator来实现任意的页面布局，但此时我们应该会面临一个问题，既然可以支持任意的页面布局那么BannerViewPager中接收的数据也应该时任意类型的。对于该问题我们可以引入泛型来实现。首先看BannerViewPager的泛型：\n\n```java\npublic class BannerViewPager<T, VH extends ViewHolder> extends RelativeLayout implements\n        ViewPager.OnPageChangeListener {\n        \n\t// 轮播数据集合\n        private List<T> mList;\n\n\tprivate HolderCreator<VH> holderCreator;\n    \n\t//\t...\n}\n```\nBannerViewPager有两个泛型参数，第一个参数T是对应的数据类型，它用来作为BannerViewPager中List集合的泛型。另一个泛型参数VH规定了必须是继承ViewHolder的类，用来作为HolderCreator的泛型。而ViewHolder和HolderCreator均是一个带有泛型参数的接口，其代码如下：\n\n```java\npublic interface ViewHolder<T> {\n    View createView(ViewGroup viewGroup,Context context, int position);\n    \n    /**\n     * @param context context\n     * @param data 实体类对象\n     * @param position 当前位置\n     * @param size 页面个数\n     */\n    void onBind(Context context,T data,int position,int size);\n}\n\npublic interface HolderCreator<VH extends ViewHolder> {\n    /**\n     * 创建ViewHolder\n     */\n    VH createViewHolder();\n}\n```\n另外，T和VH两个泛型也同时作为BannerPagerAdapter的泛型参数：\n\n```java\npublic class BannerPagerAdapter<T, VH extends ViewHolder> extends PagerAdapter {\n\n\tprivate List<T> list;\n\t \n\tpublic BannerPagerAdapter(List<T> list, HolderCreator<VH> holderCreator) {\n\t        this.list = list;\n\t        this.holderCreator = holderCreator;\n\t    }\n\n}\n```\n可以看到，我们通过泛型约束，使得涉及到的相关类中的参数数据类型保持了同步,从而实现了BannerViewPager可以接收并处理任意的数据类型。\n\n# 二、如何实现无限循环轮播\n\n关于ViewPager的无限循环无外乎两种方案。\n\n第一种方案是在PagerAdapter的getCount中返回一个Integer.MAX_VALUE，即一个最大的Integer整数。然后将setCurrentItem的值设置为 Integer.MAX_VALUE / 2，在滑动过程中不断取余以此来达到一个无限循环轮播的假象。\n\n另外一种方案是额外增加两个ViewPager的item count，然后在第0个Item填充最后一条数据，在最后一个Item填充第0条数据。当右滑到第一个Item的时候将currentItem置为pageSize-1,当滑动到最后一个Item的时候将currentItem置为1，以此来达到一个无限循环的目的，此方案的示意图如下：\n\n![无限循环示意图](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMS8xNy8xNmU3ODVhZDcyYmQ2NzQz?x-oss-process=image/format,png)\nBannerViewPager的无限轮播使用的是第二种方案。至于这两种方案孰优孰劣不好判断，因为我并没有深入研究过方案一，因此对比这两种方案的优略对比我暂时没有发言权。但是关于第二种方案的优略我可以加以分析。\n\n## 方案二的优点：\n**1.这一方案实现了真正意义上的无限轮播**\n\n相比方案一设置了一个最大值来制造无限轮播的假象，方案二实现的是一种真正的无限轮播。这个方案通过手动切换position使得轮播能够无限持续下去。这一点可能要略优于方案一。（其实Integer.MAX_VALUE的数值已经达到了数十亿级别，即使从一数到十亿恐怕都要几天吧？所以这一点也算不上方案一的缺点）\n\n**2.页面切换较少出现空白页**\n\n曾经看过几个使用方案一实现的Banner都有偶尔出现空白页的问题，当然不排除是这些库写的有问题，毕竟我也见过使用方案一实现非常好的库。而BannerViewPager在使用方案二时并没有经过什么特殊处理，却也很少见到空白页问题，当然也不排除是我代码写的好。（板儿砖尽管扔过来吧，哈哈！）。\n\n## 方案二的缺点：\n虽然BannerViewPager使用的是方案二，但是秉着公正的态度，绝不包庇这一方案的缺点。这个方案的优点虽然我苦思冥想也只想出来了两条，但是关于它的缺点我却能罗列出来很多。正所谓谁(sei)用谁(sei)知道！\n\n**1.onPageSelected(int)方法重复调用问题**\n\n我们为BannerViewPager开启自动轮播，并为其设置页面改变的监听事件，如下：\n```java\n mBannerViewPager.setAutoPlay(true)\n \t\t\t.setOnPageChangeListener(new OnPageChangeListenerAdapter() {\n                    @Override\n                    public void onPageSelected(int position) {\n                        BannerUtils.e(\"position \" + position);\n                    }\n                })\n```\n然后可以看到打印的Log：\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMS8xNy8xNmU3ODVhZDcyZThkZDZm?x-oss-process=image/format,png)\n在BannerViewPager只有三个页面的情况下，页面position selected的周期是0、1、2、0。很明显，第0个页面被多调用了一次。虽然在大多数情况下并没有影响，但是当需要在选中第0个页面时做一些逻辑的话，就会产生一定影响。至于这个问题有没有解决办法，暂时还未去做进一步探究。\n\n**2.在一屏三页模式下，这一方案在轮播到最后一页时会出现下一页短暂空白的问题**\n\n出现这一问题的原因是因为为了完成循环在切换到最后一页时我们立即将position切换到了position为1的页面，而此时position为2个页面还未加载出来，因此就有了短暂的空白问题。为了解决这一问题，又不得不在原来循环的基础上再增加两个页面，并将setOffscreenPageLimit设置为2。这样无形中增加了内存开销，并且使得逻辑处理变得更为复杂！\n\n**3.需要对position进行变换**\n\n为了实现循环我们将page count增加了2，为了解决一屏三页的空白问题我们将page count增加了4。但对外暴露的接口需要拿到正确的position，此时我们就不得不在BannerViewPager内部对position进行变换，使之能够对应到正确的position。虽然解决了问题，但是这些逻辑处理却变得很臃肿。尽管方案一也会存在position的变换问题，但是相比方案二还是优雅很多。\n\n综上来看，方案二其实并不是一个完美的方案，相反它却存在诸多的问题！但是由于没有用过方案一，所以对于方案一有没有坑，现在也不好妄下结论。有熟悉方案一的同学可以在文章下留言告知。后续我会单独开一个分支来尝试下方案一。如果方案一没有大问题，BannerViewPager的循环轮播方案可能会迁移到第一个解决方案（目前2.4.3版本已切换为方案一，许多问题迎刃而解。真香！）。\n\n\n# 三、千变万化的Indicator\n在最初的设计中，BannerViewPager同其它大多Bannenr库一样,内部维护了一个Indicator的List集合用来存放Indicator的icon，然后根据页面size动态的添加Indicator。显然这样的Indicator非常不灵活，如果UI觉得之前颜色不好看，需要换个颜色。你说，OK！没关系，你给我切图就好了。但是如果UI说我需要一个Indicator跟随ViewPager滑动的效果，那么此时你一定一脸茫然不知所措！于是和UI开启了漫长的拉锯战...扯远了，我们继续回归正题。考虑到这个问题，在后来的版本中针对Indicator进行了优化重构，现在的BannerViewPager已经可以支持任意样式的Indicator。并且还可以根据需求任意摆放Indicator的位置。是否期待了解这些神奇的功能是如何实现的呢？接下来就一起来探究\n首先，定义了一个IIndicator的接口，该接口继承了ViewPager.OnPageChangeListener接口。其代码如下：\n\n```java\npublic interface IIndicator extends ViewPager.OnPageChangeListener {\n    void setPageSize(int pageSize);\n\n    void setNormalColor(int normalColor);\n\n    void setCheckedColor(int checkedColor);\n\n    void setSlideMode(IndicatorSlideMode slideStyle);\n\n    void setIndicatorGap(int gap);\n\n    void setIndicatorWidth(int normalIndicatorWidth, int checkedIndicatorWidth);\n\n    void notifyDataChanged();\n}\n\n```\n在BannerViewPager内部持有了IIndicator的实例，并且setIndicatorView方法只接收IIndicator类型的参数。代码如下：\n\n```java\npublic class BannerPagerAdapter<T, VH extends ViewHolder> extends PagerAdapter {\n\t\n\t\t// 轮播指示器\n\t    private IIndicator mIndicatorView;\n\n\t\t/**\n\t     * 设置自定义View指示器,自定义View需要需要继承BaseIndicator或者实现IIndicator接口自行绘制指示器。\n\t     * 注意，一旦设置了自定义IndicatorView,通过BannerViewPager设置的部分IndicatorView参数将失效。\n\t     *\n\t     * @param customIndicator 自定义指示器\n\t     */\n\t    public BannerViewPager<T, VH> setIndicatorView(IIndicator customIndicator) {\n\t        if (customIndicator instanceof View) {\n\t            isCustomIndicator = true;\n\t            mIndicatorView = customIndicator;\n\t        }\n\t        return this;\n\t    }\n}\n```\n在setIndicatorView内部通过判断customIndicator是否是View的实例，以此确保了指示器必须继承自View并实现IIndicator接口。并且可以看到在满足条件的情况下将isCustomIndicator置为了true，以此来标记是否是自定义的指示器。如果外部没有调用setIndicatorView设置自定义指示器或者设置的指示器不符合要求，那么mIndicatorView岂不是就为null了？不慌，我们接着往下看代码：\n\n```java\npublic class BannerPagerAdapter<T, VH extends ViewHolder> extends PagerAdapter {\n   /**\n     * 构造ViewPager\n     *\n     * @param list ViewPager数据\n     */\n    public void create(List<T> list) {\n        initBannerData(list);\n    }\n\n\tprivate void initBannerData(List<T> list) {\n\t        if (list != null) {\n\t            mList.clear();\n\t            mList.addAll(list);\n\t            if (mList.size() > 0) {\n\t                if (mList.size() > 1) {\n\t                    if (isCustomIndicator && null != mIndicatorView) {\n\t                        initIndicator(mIndicatorView);\n\t                    } else {\n\t                        initIndicator(IndicatorFactory.createIndicatorView(getContext(), mIndicatorStyle));\n\t                    }\n\t                }\n\t                // ...\n\t            }\n\t        }\n\t    }\n}\n```\n我们在使用BannerViewPager的时候设置完参数配置之后需要调用create(List\\<T\\> list)方法，在这个方法中会根据list的数据情况来初始化Indicator。上述代码中只有在list.size()大于1的时候才会初始化Indicator，并且在后边判断如果是自定义的Indicator就直接初始化指示器，如果没有自定义指示器，那么就调用指示器工厂，根据设置的指示器Style生成内置指示器样式。这么一来就实现了内置指示器和自定义指示器的切换。\n\n那么问题又来了，关于Indicator位置任意摆放是如何实现的呢？为什么自定义指示器可以直接new出来，也可以放在xml中呢？关于这两个问题就需要来看下initIndicator做了什么操作了。\n\n```java\nprivate void initIndicator(IIndicator indicatorView) {\n        mIndicatorLayout.setVisibility(mIndicatorVisibility);\n        mIndicatorView = indicatorView;\n        if (((View) mIndicatorView).getParent() == null) {\n            mIndicatorLayout.removeAllViews();\n            mIndicatorLayout.addView((View) mIndicatorView);\n            initIndicatorViewMargin();\n            initIndicatorGravity();\n        }\n    }\n```\n在initIndicator中会首先判断indicatorView的parent是否为null。什么情况下indicatorView的parent会为null呢？答案就是内置指示器和setIndicatorView()的参数通过new的方式传进来的情况下indicatorView的parent会是null的情况！那么此时就将indicator添加到BannerViewPager内部mIndicatorLayout中就可以了。而如果Indicator是声明在xml中的情况，此时通过findViewById获得的Indicator其parent一定不会是null，那么在initIndicator中只是将其赋值给了mIndicatorView。以此完成了对内置IndicatorView的替换。这样其实不管通过怎样的方法设置IndicatorView都保证了BannerViewPager内部始终只会维护一个Indicator。方法非常巧妙，这里我想要一个赞！（似乎又嗅到了板儿砖的气息）\n\n\n\n# 四、遇到的其他问题及解决方案\n在BannerViewPager的开发过避免不了的会碰到一些问题，虽然有些已经解决了，但有些可能还悬而未决。但是不管解决没解决以供大家参考或讨论。\n\n## 1.手指滑动页面过程中应停止自动轮播\n\n自动轮播的功能是通过Handler来实现的。通过postDelayed开启轮播，通过removeCallbacks停止轮播。代码如下：\n\n```java\n/**\n     * 开启轮播\n     */\n    public void startLoop() {\n        if (!isLooping && isAutoPlay && mList.size() > 1) {\n            mHandler.postDelayed(mRunnable, interval);\n            isLooping = true;\n        }\n    }\n\n    /**\n     * 停止轮播\n     */\n    public void stopLoop() {\n        if (isLooping) {\n            mHandler.removeCallbacks(mRunnable);\n            isLooping = false;\n        }\n    }\n```\n如果在手指滑动的过程中没有停止轮播，体验上来说非常不好。因此，需要处理这种情况。解决方案是重写ViewPager的setOnTouchListener方法，监听手指滑动的时候停止轮播，抬起手指的时候开启轮播。代码如下：\n\n```java\n private void setTouchListener() {\n        mViewPager.setOnTouchListener((v, event) -> {\n            int action = event.getAction();\n            switch (action) {\n                case MotionEvent.ACTION_DOWN:\n                case MotionEvent.ACTION_MOVE:\n                    isLooping = true;\n                    stopLoop();\n                    break;\n                case MotionEvent.ACTION_UP:\n                case MotionEvent.ACTION_CANCEL:\n                    isLooping = false;\n                    startLoop();\n                default:\n                    break;\n            }\n            return false;\n        });\n    }\n```\n\n## 2.关于instantiateItem的优化问题\n我们知道，在ViewPager每次切换页面的时候都会调用instantiateItem去实例化ItemView，也就意味着我们在这个方法中通过ViewHolder的createView方法每次切换页面都会被调用重新初始化绑定数据。这样对程序来说是一种性能上的浪费。针对这种情况，在2.4.3之前的版本中做了些优化。在BannerPagerAdapter中维护一个List<View> mViewList集合，用来存放创建出来的itemView.在itemView初始化成功后，为其设置tag并保存到集合中，当在此切换页面时我们从集合中取出itemView并对比tag,如果一致则直接使用即可。这样就避免了重复的创建对象，造成一些性能开销。具体代码如下：\n\n```java\npublic class BannerPagerAdapter<T, VH extends ViewHolder> extends PagerAdapter {\n\n\tprivate List<View> mViewList = new ArrayList<>();\n\n\tprivate View findViewByPosition(ViewGroup container, int position) {\n\t        for (View view : mViewList) {\n\t            if (((int) view.getTag()) == position && view.getParent() == null) {\n\t                return view;\n\t            }\n\t        }\n\t        View view = getView(position, container);\n\t        view.setTag(position);\n\t        mViewList.add(view);\n\t        return view;\n\t    }\n}\n```\n但是这一优化却又会引发另一个问题，即内存问题！通常App的轮播控件都是图片，而图片是比较占用内存的。此时我们把所有的itemView都存储在一个集合中这样真的是一个好的方案吗？在ViewPager页面少的情况下问题可能不会凸显。但是如果ViewPager的页面很多的情况下问题就相当严重了！于是，后来我灵光一闪，突发奇想！那我就设置一个最大缓存呗？当集合中的个数超过阈值的时候就把最近用过的一个itemView移除掉不就好了？妙哉妙哉！可转念一想，这尼玛和设置一个setOffscreenPageLimit有什么区别呢？当我们在考虑这些问题的时候Google工程师早就替我们想到了！所以关于ViewPager的instantiateItem是否有必要去优化我目前持保留态度。但是，在BannerViewPager 2.4.3之前的版本中确实做了上述优化，因此前些版本中可能会存在内存问题。至于2.4.3或之后版本大概会去掉这部分优化。这个问题可能也只能留在未来，待升级到ViewPager2后解决了！关于这个问题欢迎大家在文章下方留言，各抒己见！\n\n## 3.RecyclerView+ViewPager会有非Smooth的页面滑动情况\n\n这个问题不是太好描述，我们直接通过一张GIF来看\n\n![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMS8xOS8xNmU4NDAyYTEyOWI1MGQ3?x-oss-process=image/format,png)\n从图中可以很直观的看到，把BannerViewPager向上划出屏幕再很快划回来，此时BannerViewPager页面切换的动画没有了，很生硬的直接跳到了下一页。这个问题不是BannerViewPager的bug,而是ViewPager内部原因导致的，可以看到很多线上的APP都存在这个问题，例如喜马拉雅（喜马拉雅的轮播图真心做的好看呀，效果也很赞！）。这个bug虽然不影响使用，但是总感觉效果不太好。因此还是要处理一下。处理之前先来分析一下问题原因。\n在ViewPager内部有一个私有成员变量mFirstLayout，其默认值为true。这个参数用来标记是否是第一次layout的。如果是第一次layout那么滑动就不是smooth的。代码如下：\n```\n    public void setCurrentItem(int item) {\n        mPopulatePending = false;\n        setCurrentItemInternal(item, !mFirstLayout, false);\n    }\n    \n    void setCurrentItemInternal(int item, boolean smoothScroll, boolean always) {\n        setCurrentItemInternal(item, smoothScroll, always, 0);\n    }\n```\n这个参数在onLayout方法中会被置为false.代码如下：\n```\n    @Override\n    protected void onLayout(boolean changed, int l, int t, int r, int b) {\n        //  在onLayout的最后一行\n        mFirstLayout = false;\n    }\n```\n因此，在正常情况下，onLayout执行之后页面滑动都应该时smooth的。然后，当ViewPager滑动出屏幕的时候其onDetachedFromWindow方法会被调用，而当其再次进入屏幕的时候则会调用onAttachedToWindow这个方法。来看看onAttachedToWindow方法中的代码：\n```\n@Override\n    protected void onAttachedToWindow() {\n        super.onAttachedToWindow();\n        mFirstLayout = true;\n    }\n```\n仅仅把mFirstLayout置为了true！而如果此时onLayout没有被触发，而是先发生了页面滚动，那么此时的页面滑动就没了的smooth效果了。了解了原因之后处理起来就简单了，因为mFirstLayout是私有属性，我们无法访问，所以只有通过反射来修改其值。我们在CatchViewPager(继承自ViewPager的一个类)中做如下操作：\n\n```\nprivate boolean firstLayout = true;\n\n @Override\n    protected void onAttachedToWindow() {\n        super.onAttachedToWindow();\n        hookFirstLayout();\n    }\n\n\n    @Override\n    protected void onDetachedFromWindow() {\n        super.onDetachedFromWindow();\n        firstLayout = false;\n    }\n\n private void hookFirstLayout() {\n        try {\n            Field mFirstLayout = ViewPager.class.getDeclaredField(\"mFirstLayout\");\n            mFirstLayout.setAccessible(true);\n            mFirstLayout.set(this, firstLayout);\n            setCurrentItem(getCurrentItem());\n        } catch (IllegalAccessException | NoSuchFieldException e) {\n            e.printStackTrace();\n        }\n    }\n\n```\n这样问题就迎刃而解了，再次滑动RecyclerView，一切完好！\n## 4.关于Indicator在SMOOTH下的滑动问题。\n这是一个由来已久的问题，感觉好难处理！如果不处理循环的话其实是非常容易的，但是如果加上循环之后总是有这样那的问题😂。只能说目前的计算方式不是太对，具体怎么计算的我也不贴出来了！毕竟现在写出来的还是有bug的。很羡慕喜马拉雅的滑动效果做的太Nice了！后续版本中我会想办法再优化这个问题。\n\n# 五、总结及致谢\n到这里关于BannerViewPager的两篇文章就全部结束了，[上一篇文章](https://juejin.im/post/5d6bce24f265da03db0790d1)主要着重介绍了BannerViewPager的功能及用法，而本篇文章则详细的讲解了BannerViewPager的实现原理。就目前而言，BannerViewPager并不是一个完美的轮播库，很多地方还有很大值得优化的空间甚至有些功能还存在一些小bug。但是这些都不会阻碍BannerViewPager逐渐走向优秀。在未来的版本中我将会针对这些问题逐一优化。当然，如果你有好的解决方案欢迎在文章下方留言，也可以直接到github提交pull request。如果你有什么好的建议或者遇到什么问题也欢迎在文章下方留言讨论。\n\n最后要特别感谢saiwu-bigkoo大神的[Android-ConvenientBanner](https://github.com/saiwu-bigkoo/Android-ConvenientBanner)库以及youth5201314大神的[banner](https://github.com/youth5201314/banner)库。BannerViewPager中的很多思想来自这两个库。BannerViewPager中内置的四个ViewPager Transform来自[ViewPagerTransforms](https://github.com/ToxicBakery/ViewPagerTransforms)库，在此表示感谢。同时还要感谢[玩Android](https://wanandroid.com/)提供的接口支持，以及在开发过程中参考过的文章或其它优秀开源库，不能一一列出，在此一并表示感谢。\n\n最后还是要贴上源码地址，欢迎star、fork 。\n\n[点击查看源码](https://github.com/zhpanvip/BannerViewPager)","slug":"20.BannerViewPager源码剖析(二)","published":1,"updated":"2020-08-29T01:52:07.048Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckegm5nsr001ddwoz6sku10ty","content":"<p>BannerViewPager系列文章共三篇，此文为第二篇，另外两篇参看下面链接：</p>\n<p><a href=\"https://blog.csdn.net/qq_20521573/article/details/100186077\">《打造一个丝滑般自动轮播无限循环Android库》</a></p>\n<p><a href=\"https://blog.csdn.net/qq_20521573/article/details/103216593\">《剖析BannerViewPager中Indicator的设计思想》</a></p>\n<p>上篇文章<a href=\"https://juejin.im/post/5d6bce24f265da03db0790d1\">《打造一个丝滑般自动轮播无限循环Android库》</a>非常详细的介绍了<a href=\"https://github.com/zhpanvip/BannerViewPager\">BannerViewPager</a>的基础功能及使用方法。我们知道BannerViewPager不但可以支持任意的页面布局，而且可以支持任意的Indicator。那么<a href=\"https://github.com/zhpanvip/BannerViewPager\">BannerViewPager</a>的这些功能是如何实现的呢？本篇文章将深入源码来带大家了解<a href=\"https://github.com/zhpanvip/BannerViewPager\">BannerViewPager</a>的设计思路。</p>\n<h1 id=\"一、如何支持任意的Item布局\"><a href=\"#一、如何支持任意的Item布局\" class=\"headerlink\" title=\"一、如何支持任意的Item布局\"></a>一、如何支持任意的Item布局</h1><p>产品的需求千变万化，你永远也猜不到下一步产品会给你提一个什么样的需求。因此对于一个比较人性化的Banner库来说，它也应该支持开发者去自定义任意的Item页面布局。BannerViewPager就是本着这样的思路来做的。接下来将通过两小节的内容来探究BannerViewPager是如何实现任意Item布局的。</p>\n<h2 id=\"1-BannerViewPager的ViewHolder\"><a href=\"#1-BannerViewPager的ViewHolder\" class=\"headerlink\" title=\"1.BannerViewPager的ViewHolder\"></a>1.BannerViewPager的ViewHolder</h2><p>我们先从setHolderCreator(HolderCreator<VH> holderCreator)这个方法说起。在使用BannerViewPager的时候必须设置一个HolderCreator，代码如下：</p>\n<pre><code class=\"hljs java\">bannerViewPager.setHolderCreator(<span class=\"hljs-keyword\">new</span> HolderCreator&lt;CustomPageViewHolder&gt;() &#123;\n                    <span class=\"hljs-meta\">@Override</span>\n                    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> CustomPageViewHolder <span class=\"hljs-title\">createViewHolder</span><span class=\"hljs-params\">()</span> </span>&#123;\n                        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> CustomPageViewHolder();\n                    &#125;\n                &#125;)</code></pre>\n<p>在HolderCreator的createViewHolder方法中返回了一个CustomPageViewHolder，这个CustomPageViewHolder是我们自己实现的。其内部会通过createView方法来inflate出来一自定义的itemView,并在onBind方法中为itemView绑定数据。码如下：</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">CustomPageViewHolder</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">ViewHolder</span>&lt;<span class=\"hljs-title\">CustomBean</span>&gt; </span>&#123;\n    <span class=\"hljs-keyword\">private</span> ImageView mImageView;\n    <span class=\"hljs-keyword\">private</span> TextView mTextView;\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> View <span class=\"hljs-title\">createView</span><span class=\"hljs-params\">(ViewGroup viewGroup, Context context, <span class=\"hljs-keyword\">int</span> position)</span> </span>&#123;\n        View view = LayoutInflater.from(context).inflate(R.layout.item_custom_view, viewGroup, <span class=\"hljs-keyword\">false</span>);\n        mImageView = view.findViewById(R.id.banner_image);\n        mTextView = view.findViewById(R.id.tv_describe);\n        <span class=\"hljs-keyword\">return</span> view;\n    &#125;\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onBind</span><span class=\"hljs-params\">(Context context, CustomBean data, <span class=\"hljs-keyword\">int</span> position, <span class=\"hljs-keyword\">int</span> size)</span> </span>&#123;\n        mImageView.setImageResource(data.getImageRes());\n        mTextView.setText(data.getImageDescription());\n    &#125;\n    ...\n&#125;</code></pre>\n<p>在BannerViewPager内部setupViewPager的时候，针对HolderCreator做了如下操作：</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">setupViewPager</span><span class=\"hljs-params\">()</span> </span>&#123;\n       <span class=\"hljs-keyword\">if</span> (holderCreator != <span class=\"hljs-keyword\">null</span>) &#123;\n            BannerPagerAdapter&lt;T, VH&gt; bannerPagerAdapter =\n                  <span class=\"hljs-keyword\">new</span> BannerPagerAdapter&lt;&gt;(mList, holderCreator);\n         \t\t bannerPagerAdapter.setPageStyle(mPageStyle);\n         \t\t bannerPagerAdapter.setCanLoop(isCanLoop);\n       \t\t bannerPagerAdapter.setPageClickListener(position -&gt; &#123;\n               <span class=\"hljs-keyword\">if</span> (mOnPageClickListener != <span class=\"hljs-keyword\">null</span>) &#123;\n                   mOnPageClickListener.onPageClick(PositionUtils.getRealPosition(isCanLoop, position, mList.size(), mPageStyle));\n              \t&#125;\n          &#125;);\n          mViewPager.setAdapter(bannerPagerAdapter);\n       \t\t...\n       &#125; <span class=\"hljs-keyword\">else</span> &#123;\n           <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> NullPointerException(<span class=\"hljs-string\">&quot;You must set HolderCreator for BannerViewPager&quot;</span>);\n       &#125;\n   &#125;</code></pre>\n<p>上述代码中判断如果holderCreator为null时就抛出了一个NullPointerException，这也解释了为什么必须要为BannenrViewPager设置holderCreator。当holderCreator不为null时，将holder传递到了BannerPagerAdapter中,并且为BannerPagerAdapter设置了相关参数和页面点击事件。</p>\n<p>我们接下来到BannerPagerAdapter中一探究竟：</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">BannerPagerAdapter</span>&lt;<span class=\"hljs-title\">T</span>, <span class=\"hljs-title\">VH</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">ViewHolder</span>&gt; <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">PagerAdapter</span> </span>&#123;\n\t \n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-meta\">@NonNull</span>\n    <span class=\"hljs-function\">Object <span class=\"hljs-title\">instantiateItem</span><span class=\"hljs-params\">(<span class=\"hljs-meta\">@NonNull</span> <span class=\"hljs-keyword\">final</span> ViewGroup container, <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> position)</span> </span>&#123;\n        View itemView = getView(PositionUtils.getRealPosition(isCanLoop, position, mList.size(), mPageStyle),container);\n        container.addView(itemView);\n        <span class=\"hljs-keyword\">return</span> itemView;\n    &#125;\n\n\t\t...\n\t<span class=\"hljs-meta\">@SuppressWarnings(&quot;unchecked&quot;)</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> View <span class=\"hljs-title\">getView</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> position, ViewGroup container)</span> </span>&#123;\n        ViewHolder&lt;T&gt; holder = holderCreator.createViewHolder();\n        <span class=\"hljs-keyword\">if</span> (holder == <span class=\"hljs-keyword\">null</span>) &#123;\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> RuntimeException(<span class=\"hljs-string\">&quot;can not return a null holder&quot;</span>);\n        &#125;\n        <span class=\"hljs-keyword\">return</span> createView(holder, position, container);\n    &#125;\n    \n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> View <span class=\"hljs-title\">createView</span><span class=\"hljs-params\">(ViewHolder&lt;T&gt; holder, <span class=\"hljs-keyword\">int</span> position, ViewGroup container)</span> </span>&#123;\n\t        View view = <span class=\"hljs-keyword\">null</span>;\n\t        <span class=\"hljs-keyword\">if</span> (list != <span class=\"hljs-keyword\">null</span> &amp;&amp; list.size() &gt; <span class=\"hljs-number\">0</span>) &#123;\n\t          view = holder.createView(container, container.getContext(), position);\n\t          holder.onBind(container.getContext(), list.get(position), position, list.size());\n\t        <span class=\"hljs-keyword\">return</span> view;\n\t    &#125;\n\n&#125;</code></pre>\n<p>在BannerPagerAdapter的getView方法中通过holderCreator.createViewHolder()拿到了自定义的ViewHolder，此时即为上边的CustomPageViewHolder 。接下来在createView方法中调用CustomPageViewHolder的createView方法拿到我们自定义的itemView,并通过holder.onBind方法将集合中的数据传递给了CustomPageViewHolder。到这里我们就完成了自定义item布局以及item数据的绑定。</p>\n<h2 id=\"2-BannerViewPager的泛型设计\"><a href=\"#2-BannerViewPager的泛型设计\" class=\"headerlink\" title=\"2 .BannerViewPager的泛型设计\"></a>2 .BannerViewPager的泛型设计</h2><p>在上一小节中通过HolderCreator来实现任意的页面布局，但此时我们应该会面临一个问题，既然可以支持任意的页面布局那么BannerViewPager中接收的数据也应该时任意类型的。对于该问题我们可以引入泛型来实现。首先看BannerViewPager的泛型：</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">BannerViewPager</span>&lt;<span class=\"hljs-title\">T</span>, <span class=\"hljs-title\">VH</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">ViewHolder</span>&gt; <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">RelativeLayout</span> <span class=\"hljs-keyword\">implements</span></span>\n<span class=\"hljs-class\">        <span class=\"hljs-title\">ViewPager</span>.<span class=\"hljs-title\">OnPageChangeListener</span> </span>&#123;\n        \n\t<span class=\"hljs-comment\">// 轮播数据集合</span>\n        <span class=\"hljs-keyword\">private</span> List&lt;T&gt; mList;\n\n\t<span class=\"hljs-keyword\">private</span> HolderCreator&lt;VH&gt; holderCreator;\n    \n\t<span class=\"hljs-comment\">//\t...</span>\n&#125;</code></pre>\n<p>BannerViewPager有两个泛型参数，第一个参数T是对应的数据类型，它用来作为BannerViewPager中List集合的泛型。另一个泛型参数VH规定了必须是继承ViewHolder的类，用来作为HolderCreator的泛型。而ViewHolder和HolderCreator均是一个带有泛型参数的接口，其代码如下：</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">ViewHolder</span>&lt;<span class=\"hljs-title\">T</span>&gt; </span>&#123;\n    <span class=\"hljs-function\">View <span class=\"hljs-title\">createView</span><span class=\"hljs-params\">(ViewGroup viewGroup,Context context, <span class=\"hljs-keyword\">int</span> position)</span></span>;\n    \n    <span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">     * <span class=\"hljs-doctag\">@param</span> context context</span>\n<span class=\"hljs-comment\">     * <span class=\"hljs-doctag\">@param</span> data 实体类对象</span>\n<span class=\"hljs-comment\">     * <span class=\"hljs-doctag\">@param</span> position 当前位置</span>\n<span class=\"hljs-comment\">     * <span class=\"hljs-doctag\">@param</span> size 页面个数</span>\n<span class=\"hljs-comment\">     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onBind</span><span class=\"hljs-params\">(Context context,T data,<span class=\"hljs-keyword\">int</span> position,<span class=\"hljs-keyword\">int</span> size)</span></span>;\n&#125;\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">HolderCreator</span>&lt;<span class=\"hljs-title\">VH</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">ViewHolder</span>&gt; </span>&#123;\n    <span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">     * 创建ViewHolder</span>\n<span class=\"hljs-comment\">     */</span>\n    <span class=\"hljs-function\">VH <span class=\"hljs-title\">createViewHolder</span><span class=\"hljs-params\">()</span></span>;\n&#125;</code></pre>\n<p>另外，T和VH两个泛型也同时作为BannerPagerAdapter的泛型参数：</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">BannerPagerAdapter</span>&lt;<span class=\"hljs-title\">T</span>, <span class=\"hljs-title\">VH</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">ViewHolder</span>&gt; <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">PagerAdapter</span> </span>&#123;\n\n\t<span class=\"hljs-keyword\">private</span> List&lt;T&gt; list;\n\t \n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">BannerPagerAdapter</span><span class=\"hljs-params\">(List&lt;T&gt; list, HolderCreator&lt;VH&gt; holderCreator)</span> </span>&#123;\n\t        <span class=\"hljs-keyword\">this</span>.list = list;\n\t        <span class=\"hljs-keyword\">this</span>.holderCreator = holderCreator;\n\t    &#125;\n\n&#125;</code></pre>\n<p>可以看到，我们通过泛型约束，使得涉及到的相关类中的参数数据类型保持了同步,从而实现了BannerViewPager可以接收并处理任意的数据类型。</p>\n<h1 id=\"二、如何实现无限循环轮播\"><a href=\"#二、如何实现无限循环轮播\" class=\"headerlink\" title=\"二、如何实现无限循环轮播\"></a>二、如何实现无限循环轮播</h1><p>关于ViewPager的无限循环无外乎两种方案。</p>\n<p>第一种方案是在PagerAdapter的getCount中返回一个Integer.MAX_VALUE，即一个最大的Integer整数。然后将setCurrentItem的值设置为 Integer.MAX_VALUE / 2，在滑动过程中不断取余以此来达到一个无限循环轮播的假象。</p>\n<p>另外一种方案是额外增加两个ViewPager的item count，然后在第0个Item填充最后一条数据，在最后一个Item填充第0条数据。当右滑到第一个Item的时候将currentItem置为pageSize-1,当滑动到最后一个Item的时候将currentItem置为1，以此来达到一个无限循环的目的，此方案的示意图如下：</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMS8xNy8xNmU3ODVhZDcyYmQ2NzQz?x-oss-process=image/format,png\" alt=\"无限循环示意图\"><br>BannerViewPager的无限轮播使用的是第二种方案。至于这两种方案孰优孰劣不好判断，因为我并没有深入研究过方案一，因此对比这两种方案的优略对比我暂时没有发言权。但是关于第二种方案的优略我可以加以分析。</p>\n<h2 id=\"方案二的优点：\"><a href=\"#方案二的优点：\" class=\"headerlink\" title=\"方案二的优点：\"></a>方案二的优点：</h2><p><strong>1.这一方案实现了真正意义上的无限轮播</strong></p>\n<p>相比方案一设置了一个最大值来制造无限轮播的假象，方案二实现的是一种真正的无限轮播。这个方案通过手动切换position使得轮播能够无限持续下去。这一点可能要略优于方案一。（其实Integer.MAX_VALUE的数值已经达到了数十亿级别，即使从一数到十亿恐怕都要几天吧？所以这一点也算不上方案一的缺点）</p>\n<p><strong>2.页面切换较少出现空白页</strong></p>\n<p>曾经看过几个使用方案一实现的Banner都有偶尔出现空白页的问题，当然不排除是这些库写的有问题，毕竟我也见过使用方案一实现非常好的库。而BannerViewPager在使用方案二时并没有经过什么特殊处理，却也很少见到空白页问题，当然也不排除是我代码写的好。（板儿砖尽管扔过来吧，哈哈！）。</p>\n<h2 id=\"方案二的缺点：\"><a href=\"#方案二的缺点：\" class=\"headerlink\" title=\"方案二的缺点：\"></a>方案二的缺点：</h2><p>虽然BannerViewPager使用的是方案二，但是秉着公正的态度，绝不包庇这一方案的缺点。这个方案的优点虽然我苦思冥想也只想出来了两条，但是关于它的缺点我却能罗列出来很多。正所谓谁(sei)用谁(sei)知道！</p>\n<p><strong>1.onPageSelected(int)方法重复调用问题</strong></p>\n<p>我们为BannerViewPager开启自动轮播，并为其设置页面改变的监听事件，如下：</p>\n<pre><code class=\"hljs java\">mBannerViewPager.setAutoPlay(<span class=\"hljs-keyword\">true</span>)\n\t\t\t.setOnPageChangeListener(<span class=\"hljs-keyword\">new</span> OnPageChangeListenerAdapter() &#123;\n                   <span class=\"hljs-meta\">@Override</span>\n                   <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onPageSelected</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> position)</span> </span>&#123;\n                       BannerUtils.e(<span class=\"hljs-string\">&quot;position &quot;</span> + position);\n                   &#125;\n               &#125;)</code></pre>\n<p>然后可以看到打印的Log：<br><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMS8xNy8xNmU3ODVhZDcyZThkZDZm?x-oss-process=image/format,png\" alt=\"在这里插入图片描述\"><br>在BannerViewPager只有三个页面的情况下，页面position selected的周期是0、1、2、0。很明显，第0个页面被多调用了一次。虽然在大多数情况下并没有影响，但是当需要在选中第0个页面时做一些逻辑的话，就会产生一定影响。至于这个问题有没有解决办法，暂时还未去做进一步探究。</p>\n<p><strong>2.在一屏三页模式下，这一方案在轮播到最后一页时会出现下一页短暂空白的问题</strong></p>\n<p>出现这一问题的原因是因为为了完成循环在切换到最后一页时我们立即将position切换到了position为1的页面，而此时position为2个页面还未加载出来，因此就有了短暂的空白问题。为了解决这一问题，又不得不在原来循环的基础上再增加两个页面，并将setOffscreenPageLimit设置为2。这样无形中增加了内存开销，并且使得逻辑处理变得更为复杂！</p>\n<p><strong>3.需要对position进行变换</strong></p>\n<p>为了实现循环我们将page count增加了2，为了解决一屏三页的空白问题我们将page count增加了4。但对外暴露的接口需要拿到正确的position，此时我们就不得不在BannerViewPager内部对position进行变换，使之能够对应到正确的position。虽然解决了问题，但是这些逻辑处理却变得很臃肿。尽管方案一也会存在position的变换问题，但是相比方案二还是优雅很多。</p>\n<p>综上来看，方案二其实并不是一个完美的方案，相反它却存在诸多的问题！但是由于没有用过方案一，所以对于方案一有没有坑，现在也不好妄下结论。有熟悉方案一的同学可以在文章下留言告知。后续我会单独开一个分支来尝试下方案一。如果方案一没有大问题，BannerViewPager的循环轮播方案可能会迁移到第一个解决方案（目前2.4.3版本已切换为方案一，许多问题迎刃而解。真香！）。</p>\n<h1 id=\"三、千变万化的Indicator\"><a href=\"#三、千变万化的Indicator\" class=\"headerlink\" title=\"三、千变万化的Indicator\"></a>三、千变万化的Indicator</h1><p>在最初的设计中，BannerViewPager同其它大多Bannenr库一样,内部维护了一个Indicator的List集合用来存放Indicator的icon，然后根据页面size动态的添加Indicator。显然这样的Indicator非常不灵活，如果UI觉得之前颜色不好看，需要换个颜色。你说，OK！没关系，你给我切图就好了。但是如果UI说我需要一个Indicator跟随ViewPager滑动的效果，那么此时你一定一脸茫然不知所措！于是和UI开启了漫长的拉锯战…扯远了，我们继续回归正题。考虑到这个问题，在后来的版本中针对Indicator进行了优化重构，现在的BannerViewPager已经可以支持任意样式的Indicator。并且还可以根据需求任意摆放Indicator的位置。是否期待了解这些神奇的功能是如何实现的呢？接下来就一起来探究<br>首先，定义了一个IIndicator的接口，该接口继承了ViewPager.OnPageChangeListener接口。其代码如下：</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">IIndicator</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">ViewPager</span>.<span class=\"hljs-title\">OnPageChangeListener</span> </span>&#123;\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">setPageSize</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> pageSize)</span></span>;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">setNormalColor</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> normalColor)</span></span>;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">setCheckedColor</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> checkedColor)</span></span>;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">setSlideMode</span><span class=\"hljs-params\">(IndicatorSlideMode slideStyle)</span></span>;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">setIndicatorGap</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> gap)</span></span>;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">setIndicatorWidth</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> normalIndicatorWidth, <span class=\"hljs-keyword\">int</span> checkedIndicatorWidth)</span></span>;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">notifyDataChanged</span><span class=\"hljs-params\">()</span></span>;\n&#125;\n</code></pre>\n<p>在BannerViewPager内部持有了IIndicator的实例，并且setIndicatorView方法只接收IIndicator类型的参数。代码如下：</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">BannerPagerAdapter</span>&lt;<span class=\"hljs-title\">T</span>, <span class=\"hljs-title\">VH</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">ViewHolder</span>&gt; <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">PagerAdapter</span> </span>&#123;\n\t\n\t\t<span class=\"hljs-comment\">// 轮播指示器</span>\n\t    <span class=\"hljs-keyword\">private</span> IIndicator mIndicatorView;\n\n\t\t<span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">\t     * 设置自定义View指示器,自定义View需要需要继承BaseIndicator或者实现IIndicator接口自行绘制指示器。</span>\n<span class=\"hljs-comment\">\t     * 注意，一旦设置了自定义IndicatorView,通过BannerViewPager设置的部分IndicatorView参数将失效。</span>\n<span class=\"hljs-comment\">\t     *</span>\n<span class=\"hljs-comment\">\t     * <span class=\"hljs-doctag\">@param</span> customIndicator 自定义指示器</span>\n<span class=\"hljs-comment\">\t     */</span>\n\t    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> BannerViewPager&lt;T, VH&gt; <span class=\"hljs-title\">setIndicatorView</span><span class=\"hljs-params\">(IIndicator customIndicator)</span> </span>&#123;\n\t        <span class=\"hljs-keyword\">if</span> (customIndicator <span class=\"hljs-keyword\">instanceof</span> View) &#123;\n\t            isCustomIndicator = <span class=\"hljs-keyword\">true</span>;\n\t            mIndicatorView = customIndicator;\n\t        &#125;\n\t        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>;\n\t    &#125;\n&#125;</code></pre>\n<p>在setIndicatorView内部通过判断customIndicator是否是View的实例，以此确保了指示器必须继承自View并实现IIndicator接口。并且可以看到在满足条件的情况下将isCustomIndicator置为了true，以此来标记是否是自定义的指示器。如果外部没有调用setIndicatorView设置自定义指示器或者设置的指示器不符合要求，那么mIndicatorView岂不是就为null了？不慌，我们接着往下看代码：</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">BannerPagerAdapter</span>&lt;<span class=\"hljs-title\">T</span>, <span class=\"hljs-title\">VH</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">ViewHolder</span>&gt; <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">PagerAdapter</span> </span>&#123;\n   <span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">     * 构造ViewPager</span>\n<span class=\"hljs-comment\">     *</span>\n<span class=\"hljs-comment\">     * <span class=\"hljs-doctag\">@param</span> list ViewPager数据</span>\n<span class=\"hljs-comment\">     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">create</span><span class=\"hljs-params\">(List&lt;T&gt; list)</span> </span>&#123;\n        initBannerData(list);\n    &#125;\n\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">initBannerData</span><span class=\"hljs-params\">(List&lt;T&gt; list)</span> </span>&#123;\n\t        <span class=\"hljs-keyword\">if</span> (list != <span class=\"hljs-keyword\">null</span>) &#123;\n\t            mList.clear();\n\t            mList.addAll(list);\n\t            <span class=\"hljs-keyword\">if</span> (mList.size() &gt; <span class=\"hljs-number\">0</span>) &#123;\n\t                <span class=\"hljs-keyword\">if</span> (mList.size() &gt; <span class=\"hljs-number\">1</span>) &#123;\n\t                    <span class=\"hljs-keyword\">if</span> (isCustomIndicator &amp;&amp; <span class=\"hljs-keyword\">null</span> != mIndicatorView) &#123;\n\t                        initIndicator(mIndicatorView);\n\t                    &#125; <span class=\"hljs-keyword\">else</span> &#123;\n\t                        initIndicator(IndicatorFactory.createIndicatorView(getContext(), mIndicatorStyle));\n\t                    &#125;\n\t                &#125;\n\t                <span class=\"hljs-comment\">// ...</span>\n\t            &#125;\n\t        &#125;\n\t    &#125;\n&#125;</code></pre>\n<p>我们在使用BannerViewPager的时候设置完参数配置之后需要调用create(List&lt;T&gt; list)方法，在这个方法中会根据list的数据情况来初始化Indicator。上述代码中只有在list.size()大于1的时候才会初始化Indicator，并且在后边判断如果是自定义的Indicator就直接初始化指示器，如果没有自定义指示器，那么就调用指示器工厂，根据设置的指示器Style生成内置指示器样式。这么一来就实现了内置指示器和自定义指示器的切换。</p>\n<p>那么问题又来了，关于Indicator位置任意摆放是如何实现的呢？为什么自定义指示器可以直接new出来，也可以放在xml中呢？关于这两个问题就需要来看下initIndicator做了什么操作了。</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">initIndicator</span><span class=\"hljs-params\">(IIndicator indicatorView)</span> </span>&#123;\n        mIndicatorLayout.setVisibility(mIndicatorVisibility);\n        mIndicatorView = indicatorView;\n        <span class=\"hljs-keyword\">if</span> (((View) mIndicatorView).getParent() == <span class=\"hljs-keyword\">null</span>) &#123;\n            mIndicatorLayout.removeAllViews();\n            mIndicatorLayout.addView((View) mIndicatorView);\n            initIndicatorViewMargin();\n            initIndicatorGravity();\n        &#125;\n    &#125;</code></pre>\n<p>在initIndicator中会首先判断indicatorView的parent是否为null。什么情况下indicatorView的parent会为null呢？答案就是内置指示器和setIndicatorView()的参数通过new的方式传进来的情况下indicatorView的parent会是null的情况！那么此时就将indicator添加到BannerViewPager内部mIndicatorLayout中就可以了。而如果Indicator是声明在xml中的情况，此时通过findViewById获得的Indicator其parent一定不会是null，那么在initIndicator中只是将其赋值给了mIndicatorView。以此完成了对内置IndicatorView的替换。这样其实不管通过怎样的方法设置IndicatorView都保证了BannerViewPager内部始终只会维护一个Indicator。方法非常巧妙，这里我想要一个赞！（似乎又嗅到了板儿砖的气息）</p>\n<h1 id=\"四、遇到的其他问题及解决方案\"><a href=\"#四、遇到的其他问题及解决方案\" class=\"headerlink\" title=\"四、遇到的其他问题及解决方案\"></a>四、遇到的其他问题及解决方案</h1><p>在BannerViewPager的开发过避免不了的会碰到一些问题，虽然有些已经解决了，但有些可能还悬而未决。但是不管解决没解决以供大家参考或讨论。</p>\n<h2 id=\"1-手指滑动页面过程中应停止自动轮播\"><a href=\"#1-手指滑动页面过程中应停止自动轮播\" class=\"headerlink\" title=\"1.手指滑动页面过程中应停止自动轮播\"></a>1.手指滑动页面过程中应停止自动轮播</h2><p>自动轮播的功能是通过Handler来实现的。通过postDelayed开启轮播，通过removeCallbacks停止轮播。代码如下：</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">     * 开启轮播</span>\n<span class=\"hljs-comment\">     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">startLoop</span><span class=\"hljs-params\">()</span> </span>&#123;\n        <span class=\"hljs-keyword\">if</span> (!isLooping &amp;&amp; isAutoPlay &amp;&amp; mList.size() &gt; <span class=\"hljs-number\">1</span>) &#123;\n            mHandler.postDelayed(mRunnable, interval);\n            isLooping = <span class=\"hljs-keyword\">true</span>;\n        &#125;\n    &#125;\n\n    <span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">     * 停止轮播</span>\n<span class=\"hljs-comment\">     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">stopLoop</span><span class=\"hljs-params\">()</span> </span>&#123;\n        <span class=\"hljs-keyword\">if</span> (isLooping) &#123;\n            mHandler.removeCallbacks(mRunnable);\n            isLooping = <span class=\"hljs-keyword\">false</span>;\n        &#125;\n    &#125;</code></pre>\n<p>如果在手指滑动的过程中没有停止轮播，体验上来说非常不好。因此，需要处理这种情况。解决方案是重写ViewPager的setOnTouchListener方法，监听手指滑动的时候停止轮播，抬起手指的时候开启轮播。代码如下：</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">setTouchListener</span><span class=\"hljs-params\">()</span> </span>&#123;\n       mViewPager.setOnTouchListener((v, event) -&gt; &#123;\n           <span class=\"hljs-keyword\">int</span> action = event.getAction();\n           <span class=\"hljs-keyword\">switch</span> (action) &#123;\n               <span class=\"hljs-keyword\">case</span> MotionEvent.ACTION_DOWN:\n               <span class=\"hljs-keyword\">case</span> MotionEvent.ACTION_MOVE:\n                   isLooping = <span class=\"hljs-keyword\">true</span>;\n                   stopLoop();\n                   <span class=\"hljs-keyword\">break</span>;\n               <span class=\"hljs-keyword\">case</span> MotionEvent.ACTION_UP:\n               <span class=\"hljs-keyword\">case</span> MotionEvent.ACTION_CANCEL:\n                   isLooping = <span class=\"hljs-keyword\">false</span>;\n                   startLoop();\n               <span class=\"hljs-keyword\">default</span>:\n                   <span class=\"hljs-keyword\">break</span>;\n           &#125;\n           <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>;\n       &#125;);\n   &#125;</code></pre>\n\n<h2 id=\"2-关于instantiateItem的优化问题\"><a href=\"#2-关于instantiateItem的优化问题\" class=\"headerlink\" title=\"2.关于instantiateItem的优化问题\"></a>2.关于instantiateItem的优化问题</h2><p>我们知道，在ViewPager每次切换页面的时候都会调用instantiateItem去实例化ItemView，也就意味着我们在这个方法中通过ViewHolder的createView方法每次切换页面都会被调用重新初始化绑定数据。这样对程序来说是一种性能上的浪费。针对这种情况，在2.4.3之前的版本中做了些优化。在BannerPagerAdapter中维护一个List<View> mViewList集合，用来存放创建出来的itemView.在itemView初始化成功后，为其设置tag并保存到集合中，当在此切换页面时我们从集合中取出itemView并对比tag,如果一致则直接使用即可。这样就避免了重复的创建对象，造成一些性能开销。具体代码如下：</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">BannerPagerAdapter</span>&lt;<span class=\"hljs-title\">T</span>, <span class=\"hljs-title\">VH</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">ViewHolder</span>&gt; <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">PagerAdapter</span> </span>&#123;\n\n\t<span class=\"hljs-keyword\">private</span> List&lt;View&gt; mViewList = <span class=\"hljs-keyword\">new</span> ArrayList&lt;&gt;();\n\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> View <span class=\"hljs-title\">findViewByPosition</span><span class=\"hljs-params\">(ViewGroup container, <span class=\"hljs-keyword\">int</span> position)</span> </span>&#123;\n\t        <span class=\"hljs-keyword\">for</span> (View view : mViewList) &#123;\n\t            <span class=\"hljs-keyword\">if</span> (((<span class=\"hljs-keyword\">int</span>) view.getTag()) == position &amp;&amp; view.getParent() == <span class=\"hljs-keyword\">null</span>) &#123;\n\t                <span class=\"hljs-keyword\">return</span> view;\n\t            &#125;\n\t        &#125;\n\t        View view = getView(position, container);\n\t        view.setTag(position);\n\t        mViewList.add(view);\n\t        <span class=\"hljs-keyword\">return</span> view;\n\t    &#125;\n&#125;</code></pre>\n<p>但是这一优化却又会引发另一个问题，即内存问题！通常App的轮播控件都是图片，而图片是比较占用内存的。此时我们把所有的itemView都存储在一个集合中这样真的是一个好的方案吗？在ViewPager页面少的情况下问题可能不会凸显。但是如果ViewPager的页面很多的情况下问题就相当严重了！于是，后来我灵光一闪，突发奇想！那我就设置一个最大缓存呗？当集合中的个数超过阈值的时候就把最近用过的一个itemView移除掉不就好了？妙哉妙哉！可转念一想，这尼玛和设置一个setOffscreenPageLimit有什么区别呢？当我们在考虑这些问题的时候Google工程师早就替我们想到了！所以关于ViewPager的instantiateItem是否有必要去优化我目前持保留态度。但是，在BannerViewPager 2.4.3之前的版本中确实做了上述优化，因此前些版本中可能会存在内存问题。至于2.4.3或之后版本大概会去掉这部分优化。这个问题可能也只能留在未来，待升级到ViewPager2后解决了！关于这个问题欢迎大家在文章下方留言，各抒己见！</p>\n<h2 id=\"3-RecyclerView-ViewPager会有非Smooth的页面滑动情况\"><a href=\"#3-RecyclerView-ViewPager会有非Smooth的页面滑动情况\" class=\"headerlink\" title=\"3.RecyclerView+ViewPager会有非Smooth的页面滑动情况\"></a>3.RecyclerView+ViewPager会有非Smooth的页面滑动情况</h2><p>这个问题不是太好描述，我们直接通过一张GIF来看</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMS8xOS8xNmU4NDAyYTEyOWI1MGQ3?x-oss-process=image/format,png\"><br>从图中可以很直观的看到，把BannerViewPager向上划出屏幕再很快划回来，此时BannerViewPager页面切换的动画没有了，很生硬的直接跳到了下一页。这个问题不是BannerViewPager的bug,而是ViewPager内部原因导致的，可以看到很多线上的APP都存在这个问题，例如喜马拉雅（喜马拉雅的轮播图真心做的好看呀，效果也很赞！）。这个bug虽然不影响使用，但是总感觉效果不太好。因此还是要处理一下。处理之前先来分析一下问题原因。<br>在ViewPager内部有一个私有成员变量mFirstLayout，其默认值为true。这个参数用来标记是否是第一次layout的。如果是第一次layout那么滑动就不是smooth的。代码如下：</p>\n<pre><code class=\"hljs reasonml\">public void set<span class=\"hljs-constructor\">CurrentItem(<span class=\"hljs-params\">int</span> <span class=\"hljs-params\">item</span>)</span> &#123;\n    mPopulatePending = <span class=\"hljs-literal\">false</span>;\n    set<span class=\"hljs-constructor\">CurrentItemInternal(<span class=\"hljs-params\">item</span>, !<span class=\"hljs-params\">mFirstLayout</span>, <span class=\"hljs-params\">false</span>)</span>;\n&#125;\n\nvoid set<span class=\"hljs-constructor\">CurrentItemInternal(<span class=\"hljs-params\">int</span> <span class=\"hljs-params\">item</span>, <span class=\"hljs-params\">boolean</span> <span class=\"hljs-params\">smoothScroll</span>, <span class=\"hljs-params\">boolean</span> <span class=\"hljs-params\">always</span>)</span> &#123;\n    set<span class=\"hljs-constructor\">CurrentItemInternal(<span class=\"hljs-params\">item</span>, <span class=\"hljs-params\">smoothScroll</span>, <span class=\"hljs-params\">always</span>, 0)</span>;\n&#125;</code></pre>\n<p>这个参数在onLayout方法中会被置为false.代码如下：</p>\n<pre><code class=\"hljs reasonml\">@Override\nprotected void on<span class=\"hljs-constructor\">Layout(<span class=\"hljs-params\">boolean</span> <span class=\"hljs-params\">changed</span>, <span class=\"hljs-params\">int</span> <span class=\"hljs-params\">l</span>, <span class=\"hljs-params\">int</span> <span class=\"hljs-params\">t</span>, <span class=\"hljs-params\">int</span> <span class=\"hljs-params\">r</span>, <span class=\"hljs-params\">int</span> <span class=\"hljs-params\">b</span>)</span> &#123;\n    <span class=\"hljs-comment\">//  在onLayout的最后一行</span>\n    mFirstLayout = <span class=\"hljs-literal\">false</span>;\n&#125;</code></pre>\n<p>因此，在正常情况下，onLayout执行之后页面滑动都应该时smooth的。然后，当ViewPager滑动出屏幕的时候其onDetachedFromWindow方法会被调用，而当其再次进入屏幕的时候则会调用onAttachedToWindow这个方法。来看看onAttachedToWindow方法中的代码：</p>\n<pre><code class=\"hljs aspectj\"><span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-keyword\">protected</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onAttachedToWindow</span><span class=\"hljs-params\">()</span> </span>&#123;\n        <span class=\"hljs-keyword\">super</span>.onAttachedToWindow();\n        mFirstLayout = <span class=\"hljs-keyword\">true</span>;\n    &#125;</code></pre>\n<p>仅仅把mFirstLayout置为了true！而如果此时onLayout没有被触发，而是先发生了页面滚动，那么此时的页面滑动就没了的smooth效果了。了解了原因之后处理起来就简单了，因为mFirstLayout是私有属性，我们无法访问，所以只有通过反射来修改其值。我们在CatchViewPager(继承自ViewPager的一个类)中做如下操作：</p>\n<pre><code class=\"hljs aspectj\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">boolean</span> firstLayout = <span class=\"hljs-keyword\">true</span>;\n\n <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-keyword\">protected</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onAttachedToWindow</span><span class=\"hljs-params\">()</span> </span>&#123;\n        <span class=\"hljs-keyword\">super</span>.onAttachedToWindow();\n        hookFirstLayout();\n    &#125;\n\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-keyword\">protected</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onDetachedFromWindow</span><span class=\"hljs-params\">()</span> </span>&#123;\n        <span class=\"hljs-keyword\">super</span>.onDetachedFromWindow();\n        firstLayout = <span class=\"hljs-keyword\">false</span>;\n    &#125;\n\n <span class=\"hljs-keyword\">private</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">hookFirstLayout</span><span class=\"hljs-params\">()</span> </span>&#123;\n        <span class=\"hljs-keyword\">try</span> &#123;\n            Field mFirstLayout = ViewPager.class.getDeclaredField(&quot;mFirstLayout&quot;);\n            mFirstLayout.setAccessible(<span class=\"hljs-keyword\">true</span>);\n            mFirstLayout.set(<span class=\"hljs-keyword\">this</span>, firstLayout);\n            setCurrentItem(getCurrentItem());\n        &#125; <span class=\"hljs-keyword\">catch</span> (IllegalAccessException | NoSuchFieldException e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n</code></pre>\n<p>这样问题就迎刃而解了，再次滑动RecyclerView，一切完好！</p>\n<h2 id=\"4-关于Indicator在SMOOTH下的滑动问题。\"><a href=\"#4-关于Indicator在SMOOTH下的滑动问题。\" class=\"headerlink\" title=\"4.关于Indicator在SMOOTH下的滑动问题。\"></a>4.关于Indicator在SMOOTH下的滑动问题。</h2><p>这是一个由来已久的问题，感觉好难处理！如果不处理循环的话其实是非常容易的，但是如果加上循环之后总是有这样那的问题😂。只能说目前的计算方式不是太对，具体怎么计算的我也不贴出来了！毕竟现在写出来的还是有bug的。很羡慕喜马拉雅的滑动效果做的太Nice了！后续版本中我会想办法再优化这个问题。</p>\n<h1 id=\"五、总结及致谢\"><a href=\"#五、总结及致谢\" class=\"headerlink\" title=\"五、总结及致谢\"></a>五、总结及致谢</h1><p>到这里关于BannerViewPager的两篇文章就全部结束了，<a href=\"https://juejin.im/post/5d6bce24f265da03db0790d1\">上一篇文章</a>主要着重介绍了BannerViewPager的功能及用法，而本篇文章则详细的讲解了BannerViewPager的实现原理。就目前而言，BannerViewPager并不是一个完美的轮播库，很多地方还有很大值得优化的空间甚至有些功能还存在一些小bug。但是这些都不会阻碍BannerViewPager逐渐走向优秀。在未来的版本中我将会针对这些问题逐一优化。当然，如果你有好的解决方案欢迎在文章下方留言，也可以直接到github提交pull request。如果你有什么好的建议或者遇到什么问题也欢迎在文章下方留言讨论。</p>\n<p>最后要特别感谢saiwu-bigkoo大神的<a href=\"https://github.com/saiwu-bigkoo/Android-ConvenientBanner\">Android-ConvenientBanner</a>库以及youth5201314大神的<a href=\"https://github.com/youth5201314/banner\">banner</a>库。BannerViewPager中的很多思想来自这两个库。BannerViewPager中内置的四个ViewPager Transform来自<a href=\"https://github.com/ToxicBakery/ViewPagerTransforms\">ViewPagerTransforms</a>库，在此表示感谢。同时还要感谢<a href=\"https://wanandroid.com/\">玩Android</a>提供的接口支持，以及在开发过程中参考过的文章或其它优秀开源库，不能一一列出，在此一并表示感谢。</p>\n<p>最后还是要贴上源码地址，欢迎star、fork 。</p>\n<p><a href=\"https://github.com/zhpanvip/BannerViewPager\">点击查看源码</a></p>\n","site":{"data":{"fluid_config":{"favicon":"/img/favicon.png","apple_touch_icon":"/img/favicon.png","title_join_string":" - ","force_https":false,"highlight":{"enable":true,"style":"Github Gist","bg_color":false,"copy_btn":true},"fun_features":{"typing":{"enable":true,"typeSpeed":70,"cursorChar":"|","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"mouse_click":{"enable":false,"style":"values"}},"dark_mode":{"enable":true,"default":"auto"},"color":{"body_bg_color":"#eee","body_bg_color_dark":"#181c27","navbar_bg_color":"#2f4154","navbar_bg_color_dark":"#1f3144","navbar_text_color":"#fff","navbar_text_color_dark":"#d0d0d0","text_color":"#3c4858","text_color_dark":"#c4c6c9","sec_text_color":"#718096","sec_text_color_dark":"#a7a9ad","post_text_color":"#2c3e50","post_text_color_dark":"#c4c6c9","post_heading_color":"#1a202c","post_heading_color_dark":"#c4c6c9","post_link_color":"#0366d6","post_link_color_dark":"#1589e9","link_hover_color":"#30a9de","link_hover_color_dark":"#30a9de","link_hover_bg_color":"#f8f9fa","link_hover_bg_color_dark":"#364151","board_color":"#fff","board_color_dark":"#252d38"},"font":{"font_size":"16px","font_family":null,"code_font_size":"85%"},"custom_js":null,"custom_css":null,"custom_html":"","web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"tajs":null,"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}},"lazyload":{"enable":true,"onlypost":false},"daovoice":{"enable":false,"appid":""},"aplayer":{"enable":false,"autoplay":false,"loop":"all","order":"random","theme":"#b7daff","songs":[{"name":"name","artist":"artist","url":"/songs/test.mp3","cover":"/img/cover.jpg"},{"name":"name","artist":"artist","url":"https://...url.mp3","cover":"https://...cover.jpg"}]},"version":{"check":false},"navbar":{"blog_title":"zhangpan","ground_glass":{"enable":false,"px":3,"alpha":0.7},"menu":[{"key":"home","link":"/","icon":"iconfont icon-home-fill"},{"key":"archive","link":"/archives/","icon":"iconfont icon-archive-fill"},{"key":"category","link":"/categories/","icon":"iconfont icon-category-fill"},{"key":"tag","link":"/tags/","icon":"iconfont icon-tags-fill"},{"key":"about","link":"/about/","icon":"iconfont icon-user-fill"}]},"search":{"enable":true,"path":"/local-search.xml","generate_path":"/local-search.xml","field":"post","content":true},"scroll_down_arrow":{"enable":true,"banner_height_limit":90,"scroll_after_turning_page":true},"banner_parallax":true,"footer":{"statistics":{"enable":false,"source":"busuanzi","pv_format":"总访问量 {} 次","uv_format":"总访客数 {} 人"},"beian":{"enable":false,"icp_text":"京ICP证123456号","police_text":"京公网安备12345678号","police_code":12345678,"police_icon":"/img/police_beian.png"}},"scroll_top_arrow":{"enable":true},"index":{"banner_img":"/img/default.png","banner_img_height":100,"banner_mask_alpha":0.3,"post_default_img":"","slogan":{"enable":true,"text":"Talk is cheap, show me the code."},"auto_excerpt":{"enable":true},"post_url_target":"_self","post_meta":{"date":true,"category":true,"tag":true}},"page":{"banner_img":"/img/default.png","banner_img_height":60,"banner_mask_alpha":0.3},"post":{"banner_img":"/img/default.png","banner_img_height":70,"banner_mask_alpha":0.3,"meta":{"date":{"enable":true,"format":"LL a"},"wordcount":{"enable":true,"format":"{} 字"},"min2read":{"enable":true,"format":"{} 分钟","words":100},"views":{"enable":false,"source":"busuanzi","format":"{} 次"}},"updated":{"enable":false,"content":"本文最后更新于：","relative":false},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"copyright":{"enable":true,"content":"本博客所有文章除特别声明外，均采用 <a href=\"https://creativecommons.org/licenses/by-sa/4.0/deed.zh\" rel=\"nofollow noopener\">CC BY-SA 4.0 协议</a> ，转载请注明出处！ <h5>开源库推荐</h5> <a href=\"https://github.com/zhpanvip/BannerViewPager\">1.BannerViewPager</a> <p> 一个基于ViewPager2实现的具有强大功能的无限轮播库。支持多种页面切换效果和指示器样式。 </p>\n<a href=\"https://github.com/zhpanvip/viewpagerindicator\">2.ViewPagerIndicator</a> <p> 一个适用于ViewPager和ViewPager2的指示器，支持多种滑块样式及滑动模式 </p>"},"prev_next":{"enable":true},"custom":{"enable":false,"content":"<img src=\"https://octodex.github.com/images/jetpacktocat.png\" class=\"rounded mx-auto d-block mt-5\" style=\"width:150px; height:150px;\">"},"image_zoom":{"enable":true},"footnote":{"enable":true,"header":""},"math":{"enable":false,"specific":false,"engine":"mathjax"},"mermaid":{"enable":false,"specific":false,"options":{"theme":"default"}},"comments":{"enable":true,"type":"utterances"}},"utterances":{"repo":"zhpanvip/utterances-comment","issue_term":"pathname","label":"utterances","theme":"github-light","crossorigin":"anonymous"},"disqus":{"shortname":null,"disqusjs":false,"apikey":null},"gitalk":{"clientID":null,"clientSecret":null,"repo":null,"owner":null,"admin":["name"],"id":"location.pathname","language":"zh-CN","labels":["Gitalk"],"perPage":10,"pagerDirection":"last","distractionFreeMode":false,"createIssueManually":true},"valine":{"appid":"hXIROaIM5y9qnieojJRWP5hS","appkey":"y0f3w3aqd1MF7JL9ma4WECTy","placeholder":"说点什么","path":"window.location.pathname","avatar":"retro","meta":["nick","mail","link"],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"https://zhangpan.site"},"changyan":{"appid":"","appkey":""},"livere":{"uid":""},"archive":{"banner_img":"/img/bg_article.jpg","banner_img_height":60,"banner_mask_alpha":0.3,"subtitle":null},"category":{"banner_img":"/img/bg_default.png","banner_img_height":60,"banner_mask_alpha":0.3,"subtitle":null,"post_limit":10,"order_by":"-length"},"tag":{"banner_img":"/img/bg_label.jpg","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null,"tagcloud":{"min_font":15,"max_font":30,"unit":"px","start_color":"#BBBBEE","end_color":"#337ab7"}},"about":{"banner_img":"/img/bg_default.png","banner_img_height":60,"banner_mask_alpha":0.3,"subtitle":null,"avatar":"/img/avatar.png","name":"myname","introduce":"一句简短的介绍","icons":[{"class":"iconfont icon-github-fill","link":"https://github.com","tip":"GitHub"},{"class":"iconfont icon-douban-fill","link":"https://douban.com","tip":"豆瓣"},{"class":"iconfont icon-wechat-fill","qrcode":"/img/favicon.png"}]},"page404":{"banner_img":"/img/default.png","banner_img_height":85,"banner_mask_alpha":0.3,"subtitle":"Page not found"},"links":{"banner_img":"/img/default.png","banner_img_height":60,"banner_mask_alpha":0.3,"subtitle":null,"items":[{"title":"Fluid Docs","intro":"主题使用指南","link":"https://hexo.fluid-dev.com/docs/","image":"/img/favicon.png"},{"title":"Fluid Repo","intro":"主题 GitHub 仓库","link":"https://github.com/fluid-dev/hexo-theme-fluid","image":"/img/favicon.png"},{"title":"Fluid Example","intro":"主题操作示例","link":"https://hexo.fluid-dev.com/docs/example/","image":"/img/favicon.png"}]}}}},"excerpt":"","more":"<p>BannerViewPager系列文章共三篇，此文为第二篇，另外两篇参看下面链接：</p>\n<p><a href=\"https://blog.csdn.net/qq_20521573/article/details/100186077\">《打造一个丝滑般自动轮播无限循环Android库》</a></p>\n<p><a href=\"https://blog.csdn.net/qq_20521573/article/details/103216593\">《剖析BannerViewPager中Indicator的设计思想》</a></p>\n<p>上篇文章<a href=\"https://juejin.im/post/5d6bce24f265da03db0790d1\">《打造一个丝滑般自动轮播无限循环Android库》</a>非常详细的介绍了<a href=\"https://github.com/zhpanvip/BannerViewPager\">BannerViewPager</a>的基础功能及使用方法。我们知道BannerViewPager不但可以支持任意的页面布局，而且可以支持任意的Indicator。那么<a href=\"https://github.com/zhpanvip/BannerViewPager\">BannerViewPager</a>的这些功能是如何实现的呢？本篇文章将深入源码来带大家了解<a href=\"https://github.com/zhpanvip/BannerViewPager\">BannerViewPager</a>的设计思路。</p>\n<h1 id=\"一、如何支持任意的Item布局\"><a href=\"#一、如何支持任意的Item布局\" class=\"headerlink\" title=\"一、如何支持任意的Item布局\"></a>一、如何支持任意的Item布局</h1><p>产品的需求千变万化，你永远也猜不到下一步产品会给你提一个什么样的需求。因此对于一个比较人性化的Banner库来说，它也应该支持开发者去自定义任意的Item页面布局。BannerViewPager就是本着这样的思路来做的。接下来将通过两小节的内容来探究BannerViewPager是如何实现任意Item布局的。</p>\n<h2 id=\"1-BannerViewPager的ViewHolder\"><a href=\"#1-BannerViewPager的ViewHolder\" class=\"headerlink\" title=\"1.BannerViewPager的ViewHolder\"></a>1.BannerViewPager的ViewHolder</h2><p>我们先从setHolderCreator(HolderCreator<VH> holderCreator)这个方法说起。在使用BannerViewPager的时候必须设置一个HolderCreator，代码如下：</p>\n<pre><code class=\"hljs java\">bannerViewPager.setHolderCreator(<span class=\"hljs-keyword\">new</span> HolderCreator&lt;CustomPageViewHolder&gt;() &#123;\n                    <span class=\"hljs-meta\">@Override</span>\n                    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> CustomPageViewHolder <span class=\"hljs-title\">createViewHolder</span><span class=\"hljs-params\">()</span> </span>&#123;\n                        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> CustomPageViewHolder();\n                    &#125;\n                &#125;)</code></pre>\n<p>在HolderCreator的createViewHolder方法中返回了一个CustomPageViewHolder，这个CustomPageViewHolder是我们自己实现的。其内部会通过createView方法来inflate出来一自定义的itemView,并在onBind方法中为itemView绑定数据。码如下：</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">CustomPageViewHolder</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">ViewHolder</span>&lt;<span class=\"hljs-title\">CustomBean</span>&gt; </span>&#123;\n    <span class=\"hljs-keyword\">private</span> ImageView mImageView;\n    <span class=\"hljs-keyword\">private</span> TextView mTextView;\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> View <span class=\"hljs-title\">createView</span><span class=\"hljs-params\">(ViewGroup viewGroup, Context context, <span class=\"hljs-keyword\">int</span> position)</span> </span>&#123;\n        View view = LayoutInflater.from(context).inflate(R.layout.item_custom_view, viewGroup, <span class=\"hljs-keyword\">false</span>);\n        mImageView = view.findViewById(R.id.banner_image);\n        mTextView = view.findViewById(R.id.tv_describe);\n        <span class=\"hljs-keyword\">return</span> view;\n    &#125;\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onBind</span><span class=\"hljs-params\">(Context context, CustomBean data, <span class=\"hljs-keyword\">int</span> position, <span class=\"hljs-keyword\">int</span> size)</span> </span>&#123;\n        mImageView.setImageResource(data.getImageRes());\n        mTextView.setText(data.getImageDescription());\n    &#125;\n    ...\n&#125;</code></pre>\n<p>在BannerViewPager内部setupViewPager的时候，针对HolderCreator做了如下操作：</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">setupViewPager</span><span class=\"hljs-params\">()</span> </span>&#123;\n       <span class=\"hljs-keyword\">if</span> (holderCreator != <span class=\"hljs-keyword\">null</span>) &#123;\n            BannerPagerAdapter&lt;T, VH&gt; bannerPagerAdapter =\n                  <span class=\"hljs-keyword\">new</span> BannerPagerAdapter&lt;&gt;(mList, holderCreator);\n         \t\t bannerPagerAdapter.setPageStyle(mPageStyle);\n         \t\t bannerPagerAdapter.setCanLoop(isCanLoop);\n       \t\t bannerPagerAdapter.setPageClickListener(position -&gt; &#123;\n               <span class=\"hljs-keyword\">if</span> (mOnPageClickListener != <span class=\"hljs-keyword\">null</span>) &#123;\n                   mOnPageClickListener.onPageClick(PositionUtils.getRealPosition(isCanLoop, position, mList.size(), mPageStyle));\n              \t&#125;\n          &#125;);\n          mViewPager.setAdapter(bannerPagerAdapter);\n       \t\t...\n       &#125; <span class=\"hljs-keyword\">else</span> &#123;\n           <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> NullPointerException(<span class=\"hljs-string\">&quot;You must set HolderCreator for BannerViewPager&quot;</span>);\n       &#125;\n   &#125;</code></pre>\n<p>上述代码中判断如果holderCreator为null时就抛出了一个NullPointerException，这也解释了为什么必须要为BannenrViewPager设置holderCreator。当holderCreator不为null时，将holder传递到了BannerPagerAdapter中,并且为BannerPagerAdapter设置了相关参数和页面点击事件。</p>\n<p>我们接下来到BannerPagerAdapter中一探究竟：</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">BannerPagerAdapter</span>&lt;<span class=\"hljs-title\">T</span>, <span class=\"hljs-title\">VH</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">ViewHolder</span>&gt; <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">PagerAdapter</span> </span>&#123;\n\t \n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-meta\">@NonNull</span>\n    <span class=\"hljs-function\">Object <span class=\"hljs-title\">instantiateItem</span><span class=\"hljs-params\">(<span class=\"hljs-meta\">@NonNull</span> <span class=\"hljs-keyword\">final</span> ViewGroup container, <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> position)</span> </span>&#123;\n        View itemView = getView(PositionUtils.getRealPosition(isCanLoop, position, mList.size(), mPageStyle),container);\n        container.addView(itemView);\n        <span class=\"hljs-keyword\">return</span> itemView;\n    &#125;\n\n\t\t...\n\t<span class=\"hljs-meta\">@SuppressWarnings(&quot;unchecked&quot;)</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> View <span class=\"hljs-title\">getView</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> position, ViewGroup container)</span> </span>&#123;\n        ViewHolder&lt;T&gt; holder = holderCreator.createViewHolder();\n        <span class=\"hljs-keyword\">if</span> (holder == <span class=\"hljs-keyword\">null</span>) &#123;\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> RuntimeException(<span class=\"hljs-string\">&quot;can not return a null holder&quot;</span>);\n        &#125;\n        <span class=\"hljs-keyword\">return</span> createView(holder, position, container);\n    &#125;\n    \n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> View <span class=\"hljs-title\">createView</span><span class=\"hljs-params\">(ViewHolder&lt;T&gt; holder, <span class=\"hljs-keyword\">int</span> position, ViewGroup container)</span> </span>&#123;\n\t        View view = <span class=\"hljs-keyword\">null</span>;\n\t        <span class=\"hljs-keyword\">if</span> (list != <span class=\"hljs-keyword\">null</span> &amp;&amp; list.size() &gt; <span class=\"hljs-number\">0</span>) &#123;\n\t          view = holder.createView(container, container.getContext(), position);\n\t          holder.onBind(container.getContext(), list.get(position), position, list.size());\n\t        <span class=\"hljs-keyword\">return</span> view;\n\t    &#125;\n\n&#125;</code></pre>\n<p>在BannerPagerAdapter的getView方法中通过holderCreator.createViewHolder()拿到了自定义的ViewHolder，此时即为上边的CustomPageViewHolder 。接下来在createView方法中调用CustomPageViewHolder的createView方法拿到我们自定义的itemView,并通过holder.onBind方法将集合中的数据传递给了CustomPageViewHolder。到这里我们就完成了自定义item布局以及item数据的绑定。</p>\n<h2 id=\"2-BannerViewPager的泛型设计\"><a href=\"#2-BannerViewPager的泛型设计\" class=\"headerlink\" title=\"2 .BannerViewPager的泛型设计\"></a>2 .BannerViewPager的泛型设计</h2><p>在上一小节中通过HolderCreator来实现任意的页面布局，但此时我们应该会面临一个问题，既然可以支持任意的页面布局那么BannerViewPager中接收的数据也应该时任意类型的。对于该问题我们可以引入泛型来实现。首先看BannerViewPager的泛型：</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">BannerViewPager</span>&lt;<span class=\"hljs-title\">T</span>, <span class=\"hljs-title\">VH</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">ViewHolder</span>&gt; <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">RelativeLayout</span> <span class=\"hljs-keyword\">implements</span></span>\n<span class=\"hljs-class\">        <span class=\"hljs-title\">ViewPager</span>.<span class=\"hljs-title\">OnPageChangeListener</span> </span>&#123;\n        \n\t<span class=\"hljs-comment\">// 轮播数据集合</span>\n        <span class=\"hljs-keyword\">private</span> List&lt;T&gt; mList;\n\n\t<span class=\"hljs-keyword\">private</span> HolderCreator&lt;VH&gt; holderCreator;\n    \n\t<span class=\"hljs-comment\">//\t...</span>\n&#125;</code></pre>\n<p>BannerViewPager有两个泛型参数，第一个参数T是对应的数据类型，它用来作为BannerViewPager中List集合的泛型。另一个泛型参数VH规定了必须是继承ViewHolder的类，用来作为HolderCreator的泛型。而ViewHolder和HolderCreator均是一个带有泛型参数的接口，其代码如下：</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">ViewHolder</span>&lt;<span class=\"hljs-title\">T</span>&gt; </span>&#123;\n    <span class=\"hljs-function\">View <span class=\"hljs-title\">createView</span><span class=\"hljs-params\">(ViewGroup viewGroup,Context context, <span class=\"hljs-keyword\">int</span> position)</span></span>;\n    \n    <span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">     * <span class=\"hljs-doctag\">@param</span> context context</span>\n<span class=\"hljs-comment\">     * <span class=\"hljs-doctag\">@param</span> data 实体类对象</span>\n<span class=\"hljs-comment\">     * <span class=\"hljs-doctag\">@param</span> position 当前位置</span>\n<span class=\"hljs-comment\">     * <span class=\"hljs-doctag\">@param</span> size 页面个数</span>\n<span class=\"hljs-comment\">     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onBind</span><span class=\"hljs-params\">(Context context,T data,<span class=\"hljs-keyword\">int</span> position,<span class=\"hljs-keyword\">int</span> size)</span></span>;\n&#125;\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">HolderCreator</span>&lt;<span class=\"hljs-title\">VH</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">ViewHolder</span>&gt; </span>&#123;\n    <span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">     * 创建ViewHolder</span>\n<span class=\"hljs-comment\">     */</span>\n    <span class=\"hljs-function\">VH <span class=\"hljs-title\">createViewHolder</span><span class=\"hljs-params\">()</span></span>;\n&#125;</code></pre>\n<p>另外，T和VH两个泛型也同时作为BannerPagerAdapter的泛型参数：</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">BannerPagerAdapter</span>&lt;<span class=\"hljs-title\">T</span>, <span class=\"hljs-title\">VH</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">ViewHolder</span>&gt; <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">PagerAdapter</span> </span>&#123;\n\n\t<span class=\"hljs-keyword\">private</span> List&lt;T&gt; list;\n\t \n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">BannerPagerAdapter</span><span class=\"hljs-params\">(List&lt;T&gt; list, HolderCreator&lt;VH&gt; holderCreator)</span> </span>&#123;\n\t        <span class=\"hljs-keyword\">this</span>.list = list;\n\t        <span class=\"hljs-keyword\">this</span>.holderCreator = holderCreator;\n\t    &#125;\n\n&#125;</code></pre>\n<p>可以看到，我们通过泛型约束，使得涉及到的相关类中的参数数据类型保持了同步,从而实现了BannerViewPager可以接收并处理任意的数据类型。</p>\n<h1 id=\"二、如何实现无限循环轮播\"><a href=\"#二、如何实现无限循环轮播\" class=\"headerlink\" title=\"二、如何实现无限循环轮播\"></a>二、如何实现无限循环轮播</h1><p>关于ViewPager的无限循环无外乎两种方案。</p>\n<p>第一种方案是在PagerAdapter的getCount中返回一个Integer.MAX_VALUE，即一个最大的Integer整数。然后将setCurrentItem的值设置为 Integer.MAX_VALUE / 2，在滑动过程中不断取余以此来达到一个无限循环轮播的假象。</p>\n<p>另外一种方案是额外增加两个ViewPager的item count，然后在第0个Item填充最后一条数据，在最后一个Item填充第0条数据。当右滑到第一个Item的时候将currentItem置为pageSize-1,当滑动到最后一个Item的时候将currentItem置为1，以此来达到一个无限循环的目的，此方案的示意图如下：</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMS8xNy8xNmU3ODVhZDcyYmQ2NzQz?x-oss-process=image/format,png\" alt=\"无限循环示意图\"><br>BannerViewPager的无限轮播使用的是第二种方案。至于这两种方案孰优孰劣不好判断，因为我并没有深入研究过方案一，因此对比这两种方案的优略对比我暂时没有发言权。但是关于第二种方案的优略我可以加以分析。</p>\n<h2 id=\"方案二的优点：\"><a href=\"#方案二的优点：\" class=\"headerlink\" title=\"方案二的优点：\"></a>方案二的优点：</h2><p><strong>1.这一方案实现了真正意义上的无限轮播</strong></p>\n<p>相比方案一设置了一个最大值来制造无限轮播的假象，方案二实现的是一种真正的无限轮播。这个方案通过手动切换position使得轮播能够无限持续下去。这一点可能要略优于方案一。（其实Integer.MAX_VALUE的数值已经达到了数十亿级别，即使从一数到十亿恐怕都要几天吧？所以这一点也算不上方案一的缺点）</p>\n<p><strong>2.页面切换较少出现空白页</strong></p>\n<p>曾经看过几个使用方案一实现的Banner都有偶尔出现空白页的问题，当然不排除是这些库写的有问题，毕竟我也见过使用方案一实现非常好的库。而BannerViewPager在使用方案二时并没有经过什么特殊处理，却也很少见到空白页问题，当然也不排除是我代码写的好。（板儿砖尽管扔过来吧，哈哈！）。</p>\n<h2 id=\"方案二的缺点：\"><a href=\"#方案二的缺点：\" class=\"headerlink\" title=\"方案二的缺点：\"></a>方案二的缺点：</h2><p>虽然BannerViewPager使用的是方案二，但是秉着公正的态度，绝不包庇这一方案的缺点。这个方案的优点虽然我苦思冥想也只想出来了两条，但是关于它的缺点我却能罗列出来很多。正所谓谁(sei)用谁(sei)知道！</p>\n<p><strong>1.onPageSelected(int)方法重复调用问题</strong></p>\n<p>我们为BannerViewPager开启自动轮播，并为其设置页面改变的监听事件，如下：</p>\n<pre><code class=\"hljs java\">mBannerViewPager.setAutoPlay(<span class=\"hljs-keyword\">true</span>)\n\t\t\t.setOnPageChangeListener(<span class=\"hljs-keyword\">new</span> OnPageChangeListenerAdapter() &#123;\n                   <span class=\"hljs-meta\">@Override</span>\n                   <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onPageSelected</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> position)</span> </span>&#123;\n                       BannerUtils.e(<span class=\"hljs-string\">&quot;position &quot;</span> + position);\n                   &#125;\n               &#125;)</code></pre>\n<p>然后可以看到打印的Log：<br><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMS8xNy8xNmU3ODVhZDcyZThkZDZm?x-oss-process=image/format,png\" alt=\"在这里插入图片描述\"><br>在BannerViewPager只有三个页面的情况下，页面position selected的周期是0、1、2、0。很明显，第0个页面被多调用了一次。虽然在大多数情况下并没有影响，但是当需要在选中第0个页面时做一些逻辑的话，就会产生一定影响。至于这个问题有没有解决办法，暂时还未去做进一步探究。</p>\n<p><strong>2.在一屏三页模式下，这一方案在轮播到最后一页时会出现下一页短暂空白的问题</strong></p>\n<p>出现这一问题的原因是因为为了完成循环在切换到最后一页时我们立即将position切换到了position为1的页面，而此时position为2个页面还未加载出来，因此就有了短暂的空白问题。为了解决这一问题，又不得不在原来循环的基础上再增加两个页面，并将setOffscreenPageLimit设置为2。这样无形中增加了内存开销，并且使得逻辑处理变得更为复杂！</p>\n<p><strong>3.需要对position进行变换</strong></p>\n<p>为了实现循环我们将page count增加了2，为了解决一屏三页的空白问题我们将page count增加了4。但对外暴露的接口需要拿到正确的position，此时我们就不得不在BannerViewPager内部对position进行变换，使之能够对应到正确的position。虽然解决了问题，但是这些逻辑处理却变得很臃肿。尽管方案一也会存在position的变换问题，但是相比方案二还是优雅很多。</p>\n<p>综上来看，方案二其实并不是一个完美的方案，相反它却存在诸多的问题！但是由于没有用过方案一，所以对于方案一有没有坑，现在也不好妄下结论。有熟悉方案一的同学可以在文章下留言告知。后续我会单独开一个分支来尝试下方案一。如果方案一没有大问题，BannerViewPager的循环轮播方案可能会迁移到第一个解决方案（目前2.4.3版本已切换为方案一，许多问题迎刃而解。真香！）。</p>\n<h1 id=\"三、千变万化的Indicator\"><a href=\"#三、千变万化的Indicator\" class=\"headerlink\" title=\"三、千变万化的Indicator\"></a>三、千变万化的Indicator</h1><p>在最初的设计中，BannerViewPager同其它大多Bannenr库一样,内部维护了一个Indicator的List集合用来存放Indicator的icon，然后根据页面size动态的添加Indicator。显然这样的Indicator非常不灵活，如果UI觉得之前颜色不好看，需要换个颜色。你说，OK！没关系，你给我切图就好了。但是如果UI说我需要一个Indicator跟随ViewPager滑动的效果，那么此时你一定一脸茫然不知所措！于是和UI开启了漫长的拉锯战…扯远了，我们继续回归正题。考虑到这个问题，在后来的版本中针对Indicator进行了优化重构，现在的BannerViewPager已经可以支持任意样式的Indicator。并且还可以根据需求任意摆放Indicator的位置。是否期待了解这些神奇的功能是如何实现的呢？接下来就一起来探究<br>首先，定义了一个IIndicator的接口，该接口继承了ViewPager.OnPageChangeListener接口。其代码如下：</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">IIndicator</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">ViewPager</span>.<span class=\"hljs-title\">OnPageChangeListener</span> </span>&#123;\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">setPageSize</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> pageSize)</span></span>;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">setNormalColor</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> normalColor)</span></span>;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">setCheckedColor</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> checkedColor)</span></span>;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">setSlideMode</span><span class=\"hljs-params\">(IndicatorSlideMode slideStyle)</span></span>;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">setIndicatorGap</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> gap)</span></span>;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">setIndicatorWidth</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> normalIndicatorWidth, <span class=\"hljs-keyword\">int</span> checkedIndicatorWidth)</span></span>;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">notifyDataChanged</span><span class=\"hljs-params\">()</span></span>;\n&#125;\n</code></pre>\n<p>在BannerViewPager内部持有了IIndicator的实例，并且setIndicatorView方法只接收IIndicator类型的参数。代码如下：</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">BannerPagerAdapter</span>&lt;<span class=\"hljs-title\">T</span>, <span class=\"hljs-title\">VH</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">ViewHolder</span>&gt; <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">PagerAdapter</span> </span>&#123;\n\t\n\t\t<span class=\"hljs-comment\">// 轮播指示器</span>\n\t    <span class=\"hljs-keyword\">private</span> IIndicator mIndicatorView;\n\n\t\t<span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">\t     * 设置自定义View指示器,自定义View需要需要继承BaseIndicator或者实现IIndicator接口自行绘制指示器。</span>\n<span class=\"hljs-comment\">\t     * 注意，一旦设置了自定义IndicatorView,通过BannerViewPager设置的部分IndicatorView参数将失效。</span>\n<span class=\"hljs-comment\">\t     *</span>\n<span class=\"hljs-comment\">\t     * <span class=\"hljs-doctag\">@param</span> customIndicator 自定义指示器</span>\n<span class=\"hljs-comment\">\t     */</span>\n\t    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> BannerViewPager&lt;T, VH&gt; <span class=\"hljs-title\">setIndicatorView</span><span class=\"hljs-params\">(IIndicator customIndicator)</span> </span>&#123;\n\t        <span class=\"hljs-keyword\">if</span> (customIndicator <span class=\"hljs-keyword\">instanceof</span> View) &#123;\n\t            isCustomIndicator = <span class=\"hljs-keyword\">true</span>;\n\t            mIndicatorView = customIndicator;\n\t        &#125;\n\t        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>;\n\t    &#125;\n&#125;</code></pre>\n<p>在setIndicatorView内部通过判断customIndicator是否是View的实例，以此确保了指示器必须继承自View并实现IIndicator接口。并且可以看到在满足条件的情况下将isCustomIndicator置为了true，以此来标记是否是自定义的指示器。如果外部没有调用setIndicatorView设置自定义指示器或者设置的指示器不符合要求，那么mIndicatorView岂不是就为null了？不慌，我们接着往下看代码：</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">BannerPagerAdapter</span>&lt;<span class=\"hljs-title\">T</span>, <span class=\"hljs-title\">VH</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">ViewHolder</span>&gt; <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">PagerAdapter</span> </span>&#123;\n   <span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">     * 构造ViewPager</span>\n<span class=\"hljs-comment\">     *</span>\n<span class=\"hljs-comment\">     * <span class=\"hljs-doctag\">@param</span> list ViewPager数据</span>\n<span class=\"hljs-comment\">     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">create</span><span class=\"hljs-params\">(List&lt;T&gt; list)</span> </span>&#123;\n        initBannerData(list);\n    &#125;\n\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">initBannerData</span><span class=\"hljs-params\">(List&lt;T&gt; list)</span> </span>&#123;\n\t        <span class=\"hljs-keyword\">if</span> (list != <span class=\"hljs-keyword\">null</span>) &#123;\n\t            mList.clear();\n\t            mList.addAll(list);\n\t            <span class=\"hljs-keyword\">if</span> (mList.size() &gt; <span class=\"hljs-number\">0</span>) &#123;\n\t                <span class=\"hljs-keyword\">if</span> (mList.size() &gt; <span class=\"hljs-number\">1</span>) &#123;\n\t                    <span class=\"hljs-keyword\">if</span> (isCustomIndicator &amp;&amp; <span class=\"hljs-keyword\">null</span> != mIndicatorView) &#123;\n\t                        initIndicator(mIndicatorView);\n\t                    &#125; <span class=\"hljs-keyword\">else</span> &#123;\n\t                        initIndicator(IndicatorFactory.createIndicatorView(getContext(), mIndicatorStyle));\n\t                    &#125;\n\t                &#125;\n\t                <span class=\"hljs-comment\">// ...</span>\n\t            &#125;\n\t        &#125;\n\t    &#125;\n&#125;</code></pre>\n<p>我们在使用BannerViewPager的时候设置完参数配置之后需要调用create(List&lt;T&gt; list)方法，在这个方法中会根据list的数据情况来初始化Indicator。上述代码中只有在list.size()大于1的时候才会初始化Indicator，并且在后边判断如果是自定义的Indicator就直接初始化指示器，如果没有自定义指示器，那么就调用指示器工厂，根据设置的指示器Style生成内置指示器样式。这么一来就实现了内置指示器和自定义指示器的切换。</p>\n<p>那么问题又来了，关于Indicator位置任意摆放是如何实现的呢？为什么自定义指示器可以直接new出来，也可以放在xml中呢？关于这两个问题就需要来看下initIndicator做了什么操作了。</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">initIndicator</span><span class=\"hljs-params\">(IIndicator indicatorView)</span> </span>&#123;\n        mIndicatorLayout.setVisibility(mIndicatorVisibility);\n        mIndicatorView = indicatorView;\n        <span class=\"hljs-keyword\">if</span> (((View) mIndicatorView).getParent() == <span class=\"hljs-keyword\">null</span>) &#123;\n            mIndicatorLayout.removeAllViews();\n            mIndicatorLayout.addView((View) mIndicatorView);\n            initIndicatorViewMargin();\n            initIndicatorGravity();\n        &#125;\n    &#125;</code></pre>\n<p>在initIndicator中会首先判断indicatorView的parent是否为null。什么情况下indicatorView的parent会为null呢？答案就是内置指示器和setIndicatorView()的参数通过new的方式传进来的情况下indicatorView的parent会是null的情况！那么此时就将indicator添加到BannerViewPager内部mIndicatorLayout中就可以了。而如果Indicator是声明在xml中的情况，此时通过findViewById获得的Indicator其parent一定不会是null，那么在initIndicator中只是将其赋值给了mIndicatorView。以此完成了对内置IndicatorView的替换。这样其实不管通过怎样的方法设置IndicatorView都保证了BannerViewPager内部始终只会维护一个Indicator。方法非常巧妙，这里我想要一个赞！（似乎又嗅到了板儿砖的气息）</p>\n<h1 id=\"四、遇到的其他问题及解决方案\"><a href=\"#四、遇到的其他问题及解决方案\" class=\"headerlink\" title=\"四、遇到的其他问题及解决方案\"></a>四、遇到的其他问题及解决方案</h1><p>在BannerViewPager的开发过避免不了的会碰到一些问题，虽然有些已经解决了，但有些可能还悬而未决。但是不管解决没解决以供大家参考或讨论。</p>\n<h2 id=\"1-手指滑动页面过程中应停止自动轮播\"><a href=\"#1-手指滑动页面过程中应停止自动轮播\" class=\"headerlink\" title=\"1.手指滑动页面过程中应停止自动轮播\"></a>1.手指滑动页面过程中应停止自动轮播</h2><p>自动轮播的功能是通过Handler来实现的。通过postDelayed开启轮播，通过removeCallbacks停止轮播。代码如下：</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">     * 开启轮播</span>\n<span class=\"hljs-comment\">     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">startLoop</span><span class=\"hljs-params\">()</span> </span>&#123;\n        <span class=\"hljs-keyword\">if</span> (!isLooping &amp;&amp; isAutoPlay &amp;&amp; mList.size() &gt; <span class=\"hljs-number\">1</span>) &#123;\n            mHandler.postDelayed(mRunnable, interval);\n            isLooping = <span class=\"hljs-keyword\">true</span>;\n        &#125;\n    &#125;\n\n    <span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">     * 停止轮播</span>\n<span class=\"hljs-comment\">     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">stopLoop</span><span class=\"hljs-params\">()</span> </span>&#123;\n        <span class=\"hljs-keyword\">if</span> (isLooping) &#123;\n            mHandler.removeCallbacks(mRunnable);\n            isLooping = <span class=\"hljs-keyword\">false</span>;\n        &#125;\n    &#125;</code></pre>\n<p>如果在手指滑动的过程中没有停止轮播，体验上来说非常不好。因此，需要处理这种情况。解决方案是重写ViewPager的setOnTouchListener方法，监听手指滑动的时候停止轮播，抬起手指的时候开启轮播。代码如下：</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">setTouchListener</span><span class=\"hljs-params\">()</span> </span>&#123;\n       mViewPager.setOnTouchListener((v, event) -&gt; &#123;\n           <span class=\"hljs-keyword\">int</span> action = event.getAction();\n           <span class=\"hljs-keyword\">switch</span> (action) &#123;\n               <span class=\"hljs-keyword\">case</span> MotionEvent.ACTION_DOWN:\n               <span class=\"hljs-keyword\">case</span> MotionEvent.ACTION_MOVE:\n                   isLooping = <span class=\"hljs-keyword\">true</span>;\n                   stopLoop();\n                   <span class=\"hljs-keyword\">break</span>;\n               <span class=\"hljs-keyword\">case</span> MotionEvent.ACTION_UP:\n               <span class=\"hljs-keyword\">case</span> MotionEvent.ACTION_CANCEL:\n                   isLooping = <span class=\"hljs-keyword\">false</span>;\n                   startLoop();\n               <span class=\"hljs-keyword\">default</span>:\n                   <span class=\"hljs-keyword\">break</span>;\n           &#125;\n           <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>;\n       &#125;);\n   &#125;</code></pre>\n\n<h2 id=\"2-关于instantiateItem的优化问题\"><a href=\"#2-关于instantiateItem的优化问题\" class=\"headerlink\" title=\"2.关于instantiateItem的优化问题\"></a>2.关于instantiateItem的优化问题</h2><p>我们知道，在ViewPager每次切换页面的时候都会调用instantiateItem去实例化ItemView，也就意味着我们在这个方法中通过ViewHolder的createView方法每次切换页面都会被调用重新初始化绑定数据。这样对程序来说是一种性能上的浪费。针对这种情况，在2.4.3之前的版本中做了些优化。在BannerPagerAdapter中维护一个List<View> mViewList集合，用来存放创建出来的itemView.在itemView初始化成功后，为其设置tag并保存到集合中，当在此切换页面时我们从集合中取出itemView并对比tag,如果一致则直接使用即可。这样就避免了重复的创建对象，造成一些性能开销。具体代码如下：</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">BannerPagerAdapter</span>&lt;<span class=\"hljs-title\">T</span>, <span class=\"hljs-title\">VH</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">ViewHolder</span>&gt; <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">PagerAdapter</span> </span>&#123;\n\n\t<span class=\"hljs-keyword\">private</span> List&lt;View&gt; mViewList = <span class=\"hljs-keyword\">new</span> ArrayList&lt;&gt;();\n\n\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> View <span class=\"hljs-title\">findViewByPosition</span><span class=\"hljs-params\">(ViewGroup container, <span class=\"hljs-keyword\">int</span> position)</span> </span>&#123;\n\t        <span class=\"hljs-keyword\">for</span> (View view : mViewList) &#123;\n\t            <span class=\"hljs-keyword\">if</span> (((<span class=\"hljs-keyword\">int</span>) view.getTag()) == position &amp;&amp; view.getParent() == <span class=\"hljs-keyword\">null</span>) &#123;\n\t                <span class=\"hljs-keyword\">return</span> view;\n\t            &#125;\n\t        &#125;\n\t        View view = getView(position, container);\n\t        view.setTag(position);\n\t        mViewList.add(view);\n\t        <span class=\"hljs-keyword\">return</span> view;\n\t    &#125;\n&#125;</code></pre>\n<p>但是这一优化却又会引发另一个问题，即内存问题！通常App的轮播控件都是图片，而图片是比较占用内存的。此时我们把所有的itemView都存储在一个集合中这样真的是一个好的方案吗？在ViewPager页面少的情况下问题可能不会凸显。但是如果ViewPager的页面很多的情况下问题就相当严重了！于是，后来我灵光一闪，突发奇想！那我就设置一个最大缓存呗？当集合中的个数超过阈值的时候就把最近用过的一个itemView移除掉不就好了？妙哉妙哉！可转念一想，这尼玛和设置一个setOffscreenPageLimit有什么区别呢？当我们在考虑这些问题的时候Google工程师早就替我们想到了！所以关于ViewPager的instantiateItem是否有必要去优化我目前持保留态度。但是，在BannerViewPager 2.4.3之前的版本中确实做了上述优化，因此前些版本中可能会存在内存问题。至于2.4.3或之后版本大概会去掉这部分优化。这个问题可能也只能留在未来，待升级到ViewPager2后解决了！关于这个问题欢迎大家在文章下方留言，各抒己见！</p>\n<h2 id=\"3-RecyclerView-ViewPager会有非Smooth的页面滑动情况\"><a href=\"#3-RecyclerView-ViewPager会有非Smooth的页面滑动情况\" class=\"headerlink\" title=\"3.RecyclerView+ViewPager会有非Smooth的页面滑动情况\"></a>3.RecyclerView+ViewPager会有非Smooth的页面滑动情况</h2><p>这个问题不是太好描述，我们直接通过一张GIF来看</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMS8xOS8xNmU4NDAyYTEyOWI1MGQ3?x-oss-process=image/format,png\"><br>从图中可以很直观的看到，把BannerViewPager向上划出屏幕再很快划回来，此时BannerViewPager页面切换的动画没有了，很生硬的直接跳到了下一页。这个问题不是BannerViewPager的bug,而是ViewPager内部原因导致的，可以看到很多线上的APP都存在这个问题，例如喜马拉雅（喜马拉雅的轮播图真心做的好看呀，效果也很赞！）。这个bug虽然不影响使用，但是总感觉效果不太好。因此还是要处理一下。处理之前先来分析一下问题原因。<br>在ViewPager内部有一个私有成员变量mFirstLayout，其默认值为true。这个参数用来标记是否是第一次layout的。如果是第一次layout那么滑动就不是smooth的。代码如下：</p>\n<pre><code class=\"hljs reasonml\">public void set<span class=\"hljs-constructor\">CurrentItem(<span class=\"hljs-params\">int</span> <span class=\"hljs-params\">item</span>)</span> &#123;\n    mPopulatePending = <span class=\"hljs-literal\">false</span>;\n    set<span class=\"hljs-constructor\">CurrentItemInternal(<span class=\"hljs-params\">item</span>, !<span class=\"hljs-params\">mFirstLayout</span>, <span class=\"hljs-params\">false</span>)</span>;\n&#125;\n\nvoid set<span class=\"hljs-constructor\">CurrentItemInternal(<span class=\"hljs-params\">int</span> <span class=\"hljs-params\">item</span>, <span class=\"hljs-params\">boolean</span> <span class=\"hljs-params\">smoothScroll</span>, <span class=\"hljs-params\">boolean</span> <span class=\"hljs-params\">always</span>)</span> &#123;\n    set<span class=\"hljs-constructor\">CurrentItemInternal(<span class=\"hljs-params\">item</span>, <span class=\"hljs-params\">smoothScroll</span>, <span class=\"hljs-params\">always</span>, 0)</span>;\n&#125;</code></pre>\n<p>这个参数在onLayout方法中会被置为false.代码如下：</p>\n<pre><code class=\"hljs reasonml\">@Override\nprotected void on<span class=\"hljs-constructor\">Layout(<span class=\"hljs-params\">boolean</span> <span class=\"hljs-params\">changed</span>, <span class=\"hljs-params\">int</span> <span class=\"hljs-params\">l</span>, <span class=\"hljs-params\">int</span> <span class=\"hljs-params\">t</span>, <span class=\"hljs-params\">int</span> <span class=\"hljs-params\">r</span>, <span class=\"hljs-params\">int</span> <span class=\"hljs-params\">b</span>)</span> &#123;\n    <span class=\"hljs-comment\">//  在onLayout的最后一行</span>\n    mFirstLayout = <span class=\"hljs-literal\">false</span>;\n&#125;</code></pre>\n<p>因此，在正常情况下，onLayout执行之后页面滑动都应该时smooth的。然后，当ViewPager滑动出屏幕的时候其onDetachedFromWindow方法会被调用，而当其再次进入屏幕的时候则会调用onAttachedToWindow这个方法。来看看onAttachedToWindow方法中的代码：</p>\n<pre><code class=\"hljs aspectj\"><span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-keyword\">protected</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onAttachedToWindow</span><span class=\"hljs-params\">()</span> </span>&#123;\n        <span class=\"hljs-keyword\">super</span>.onAttachedToWindow();\n        mFirstLayout = <span class=\"hljs-keyword\">true</span>;\n    &#125;</code></pre>\n<p>仅仅把mFirstLayout置为了true！而如果此时onLayout没有被触发，而是先发生了页面滚动，那么此时的页面滑动就没了的smooth效果了。了解了原因之后处理起来就简单了，因为mFirstLayout是私有属性，我们无法访问，所以只有通过反射来修改其值。我们在CatchViewPager(继承自ViewPager的一个类)中做如下操作：</p>\n<pre><code class=\"hljs aspectj\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">boolean</span> firstLayout = <span class=\"hljs-keyword\">true</span>;\n\n <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-keyword\">protected</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onAttachedToWindow</span><span class=\"hljs-params\">()</span> </span>&#123;\n        <span class=\"hljs-keyword\">super</span>.onAttachedToWindow();\n        hookFirstLayout();\n    &#125;\n\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-keyword\">protected</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onDetachedFromWindow</span><span class=\"hljs-params\">()</span> </span>&#123;\n        <span class=\"hljs-keyword\">super</span>.onDetachedFromWindow();\n        firstLayout = <span class=\"hljs-keyword\">false</span>;\n    &#125;\n\n <span class=\"hljs-keyword\">private</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">hookFirstLayout</span><span class=\"hljs-params\">()</span> </span>&#123;\n        <span class=\"hljs-keyword\">try</span> &#123;\n            Field mFirstLayout = ViewPager.class.getDeclaredField(&quot;mFirstLayout&quot;);\n            mFirstLayout.setAccessible(<span class=\"hljs-keyword\">true</span>);\n            mFirstLayout.set(<span class=\"hljs-keyword\">this</span>, firstLayout);\n            setCurrentItem(getCurrentItem());\n        &#125; <span class=\"hljs-keyword\">catch</span> (IllegalAccessException | NoSuchFieldException e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n</code></pre>\n<p>这样问题就迎刃而解了，再次滑动RecyclerView，一切完好！</p>\n<h2 id=\"4-关于Indicator在SMOOTH下的滑动问题。\"><a href=\"#4-关于Indicator在SMOOTH下的滑动问题。\" class=\"headerlink\" title=\"4.关于Indicator在SMOOTH下的滑动问题。\"></a>4.关于Indicator在SMOOTH下的滑动问题。</h2><p>这是一个由来已久的问题，感觉好难处理！如果不处理循环的话其实是非常容易的，但是如果加上循环之后总是有这样那的问题😂。只能说目前的计算方式不是太对，具体怎么计算的我也不贴出来了！毕竟现在写出来的还是有bug的。很羡慕喜马拉雅的滑动效果做的太Nice了！后续版本中我会想办法再优化这个问题。</p>\n<h1 id=\"五、总结及致谢\"><a href=\"#五、总结及致谢\" class=\"headerlink\" title=\"五、总结及致谢\"></a>五、总结及致谢</h1><p>到这里关于BannerViewPager的两篇文章就全部结束了，<a href=\"https://juejin.im/post/5d6bce24f265da03db0790d1\">上一篇文章</a>主要着重介绍了BannerViewPager的功能及用法，而本篇文章则详细的讲解了BannerViewPager的实现原理。就目前而言，BannerViewPager并不是一个完美的轮播库，很多地方还有很大值得优化的空间甚至有些功能还存在一些小bug。但是这些都不会阻碍BannerViewPager逐渐走向优秀。在未来的版本中我将会针对这些问题逐一优化。当然，如果你有好的解决方案欢迎在文章下方留言，也可以直接到github提交pull request。如果你有什么好的建议或者遇到什么问题也欢迎在文章下方留言讨论。</p>\n<p>最后要特别感谢saiwu-bigkoo大神的<a href=\"https://github.com/saiwu-bigkoo/Android-ConvenientBanner\">Android-ConvenientBanner</a>库以及youth5201314大神的<a href=\"https://github.com/youth5201314/banner\">banner</a>库。BannerViewPager中的很多思想来自这两个库。BannerViewPager中内置的四个ViewPager Transform来自<a href=\"https://github.com/ToxicBakery/ViewPagerTransforms\">ViewPagerTransforms</a>库，在此表示感谢。同时还要感谢<a href=\"https://wanandroid.com/\">玩Android</a>提供的接口支持，以及在开发过程中参考过的文章或其它优秀开源库，不能一一列出，在此一并表示感谢。</p>\n<p>最后还是要贴上源码地址，欢迎star、fork 。</p>\n<p><a href=\"https://github.com/zhpanvip/BannerViewPager\">点击查看源码</a></p>\n"},{"title":"学不动也要学！深入了解ViewPager2","date":"2019-12-14T08:47:19.000Z","_content":"\n就在上个月20号(2019年11月20号)，期待已久的ViewPager2 正式版终于发布了！不知道你是否已经蠢蠢欲动着手用ViewPager2去改造你项目的ViewPager了？什么？你还不知道ViewPager2？那么请你马上系好安全带，本篇文章将带你一览ViewPager2的风采。\n## 一、ViewPager2的新特性\nViewPager2从名字就可以看出来它是ViewPager的升级版，既然是升级版那么它相比ViewPager有哪些新功能和哪些API变化呢？我们接着往下看。\n### 1.ViewPager2新特性\n- 基于RecyclerView实现。这意味着RecyclerView的优点将会被ViewPager2所继承。\n- 支持竖直滑动。只需要一个参数就可以改变滑动方向。\n- 支持关闭用户输入。通过setUserInputEnabled来设置是否禁止用户滑动页面。\n- 支持通过编程方式滚动。通过fakeDragBy(offsetPx)代码模拟用户滑动页面。\n- CompositePageTransformer 支持同时添加多个PageTransformer。\n- 支持DiffUtil ，可以添加数据集合改变的item动画。\n- 支持RTL (right-to-left)布局。我觉得这个功能对国内开发者来说可能用处不大..\n\n### 2.相比ViewPager变化的API\nViewPager2相比ViewPager做了哪些改变呢？研究了一番之后我大概列出以下几点：\n- ViewPager2与ViewPager同是继承自ViewGrop，但是ViewPager2被声明成了final。意味着我们不可能再像ViewPager一样通过继承来修改ViewPager2的代码。\n- FragmentStatePagerAdapter被FragmentStateAdapter 替代\n- PagerAdapter被RecyclerView.Adapter替代\n- addPageChangeListener被registerOnPageChangeCallback。我们知道ViewPager的addPageChangeListener接收的是一个OnPageChangeListener的接口，而这个接口中有三个方法，当想要监听页面变化时需要重写这三个方法。而ViewPager2的registerOnPageChangeCallback方法接收的是一个叫OnPageChangeCallback的抽象类，因此我们可以选择性的重写需要的方法即可。\n- 移除了setPargeMargin方法。\n\n以上所罗列的新特性和API可能并不完整，如有疏漏可以留言补充。\n## 二、开启ViewPager2之旅\nViewPager2位于androidx包下，也就是它不像ViewPager一样被内置在系统源码中。因此，使用ViewPager2需要额外的添加依赖库。另外，android support中不包含ViewPager，也就是要使用ViewPager2必须迁移到androidx才可以。\n\n### 1.添加依赖，目前ViewPager2的最新版本是1.0.0：\n\n```java\ndependencies {\n    implementation \"androidx.viewpager2:viewpager2:1.0.0\"\n}\n```\n### 2.ViewPager2布局文件：\n\n```java\n\t<androidx.viewpager2.widget.ViewPager2\n        android:id=\"@+id/view_pager\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"match_parent\"\n        app:layout_constraintBottom_toBottomOf=\"parent\"\n        app:layout_constraintLeft_toLeftOf=\"parent\"\n        app:layout_constraintRight_toRightOf=\"parent\"\n        app:layout_constraintTop_toTopOf=\"parent\" />\n```\n### 3.ViewPager2的Adapter\n因为ViewPager2内部封装的是RecyclerView，因此它的Adapter也就是RecyclerView的Adapter。\n\n```kotlin\nclass MyAdapter : RecyclerView.Adapter<MyAdapter.PagerViewHolder>() {\n    private var mList: List<Int> = ArrayList()\n    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): PagerViewHolder {\n        val itemView = LayoutInflater.from(parent.context).inflate(R.layout.item_page, parent, false)\n        return PagerViewHolder(itemView)\n    }\n\n    override fun onBindViewHolder(holder: PagerViewHolder, position: Int) {\n        holder.bindData(mList[position])\n    }\n\n    fun setList(list: List<Int>) {\n        mList = list\n    }\n\n    override fun getItemCount(): Int {\n        return mList.size\n    }\n\t//\tViewHolder需要继承RecycleView.ViewHolder\n    class PagerViewHolder(itemView: View) : RecyclerView.ViewHolder(itemView) {\n        private val mTextView: TextView = itemView.findViewById(R.id.tv_text)\n        private var colors = arrayOf(\"#CCFF99\",\"#41F1E5\",\"#8D41F1\",\"#FF99CC\")\n\n        fun bindData(i: Int) {\n            mTextView.text = i.toString()\n            mTextView.setBackgroundColor(Color.parseColor(colors[i]))\n        }\n    }\n}\n```\nitem_page中代码如下：\n\n```kotlin\n<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    android:gravity=\"center\">\n\n    <TextView\n        android:id=\"@+id/tv_text\"\n        android:background=\"@color/colorPrimaryDark\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"280dp\"\n        android:gravity=\"center\"\n        android:textColor=\"#ffffff\"\n        android:textSize=\"22sp\" />\n</LinearLayout>\n```\n### 4.在Activity中为ViewPager设置Adapter：\n\n```kotlin\n\t\tval viewPager2 = findViewById<ViewPager2>(R.id.view_pager)\n        val myAdapter = MyAdapter()\n        myAdapter.setList(data)\n        viewPager2.adapter = myAdapter\n```\n\n很简单就完成了一个ViewPager的功能，来看下效果怎么样：\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi8xNC8xNmYwM2JhZjJkMDAzYzli?x-oss-process=image/format,png)\n### 5.ViewPager2竖直滑动\n接下来我们通过一行代码为其设置竖直滑动\n\n```kotlin\nviewPager2.orientation = ViewPager2.ORIENTATION_VERTICAL\n```\n竖直滑动用ViewPager是很难实现的，而通过ViewPager2只需要设置一个参数即可。来看下效果：\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi8xNC8xNmYwM2JhZjJjZTdiNTI4?x-oss-process=image/format,png)\n### 6.页面滑动事件监听\n上文已经提到过了，我们为ViewPager设置页面滑动的监听事件需要重写三个方法，而为ViewPager2设置监听事件只需要重写需要的方法即可，因为ViewPager2中OnPageChangeCallback是一个抽象类。\n\n```kotlin\nviewPager2.registerOnPageChangeCallback(object : ViewPager2.OnPageChangeCallback() {\n            override fun onPageSelected(position: Int) {\n                super.onPageSelected(position)\n                Toast.makeText(this@MainActivity, \"page selected $position\", Toast.LENGTH_SHORT).show()\n            }\n        })\n```\n### 7.setUserInputEnabled与fakeDragBy\n我们知道，在使用ViewPager的时候想要禁止用户滑动需要重写ViewPager的onInterceptTouchEvent。而ViewPager2被声明为了final，我们无法再去继承ViewPager2。那么我们应该怎么禁止ViewPager2的滑动呢？其实在ViewPager2中已经为我们提供了这个功能，只需要通过setUserInputEnabled即可实现。\n\n```kotlin\nviewPager2.isUserInputEnabled = false\n```\n同时ViewPager2新增了一个fakeDragBy的方法。通过这个方法可以来模拟拖拽。在使用fakeDragBy前需要先beginFakeDrag方法来开启模拟拖拽。fakeDragBy会返回一个boolean值，true表示有fake drag正在执行，而返回false表示当前没有fake drag在执行。我们通过代码来尝试下：\n\n```kotlin\nfun fakeDragBy(view: View) {\n        viewPager2.beginFakeDrag()\n        if (viewPager2.fakeDragBy(-310f))\n            viewPager2.endFakeDrag()\n    }\n```\n需要注意到是fakeDragBy接受一个float的参数，当参数值为正数时表示向前一个页面滑动，当值为负数时表示向下一个页面滑动。\n下面来看下效果图：\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi8xNC8xNmYwM2JhZjJlZmY2ZWY4?x-oss-process=image/format,png)\n演示图中禁止了用户输入，通过按钮点击可以模拟用户滑动。\n\n## 三、ViewPager2的PageTransformer\n相比ViewPager，ViewPager2的Transformer功能有了很大的扩展。ViewPager2不仅可以通过PageTransformer用来设置页面动画，还可以用PageTransformer设置页面间距以及同时添加多个PageTransformer。接下来我们就来认识下ViewPager2的PageTransformer吧！\n\n### 1.setPageMargin\n在第一章中我们提到了ViewPager2移除了setPageMargin方法，那么怎么为ViewPager2设置页面间距呢？其实在ViewPager2中为我们提供了MarginPageTransformer，我们可以通过ViewPager2的setPageTransformer方法来设置页面间距。代码如下：\n\n```kotlin\nviewPager2.setPageTransformer(MarginPageTransformer(resources.getDimension(R.dimen.dp_10).toInt()))\n```\n上述代码我们为ViewPager2设置了10dp的页面间距。效果如下：\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi8xNC8xNmYwM2JhZjJkMmQzODkw?x-oss-process=image/format,png)\n### 2.认识CompositePageTransformer\n这个时候我们应该有个疑问，为ViewPager2设置了页面间距后如果还想设置页面动画的Transformer怎么办呢？这时候就该CompositePageTransformer出场了。从名字上也可以看出来它是一个组合的PageTransformer。没错，CompositePageTransformer实现了PageTransformer接口，同时在其内部维护了一个List集合，我们可以将多个PageTransformer添加到CompositePageTransformer中。\n\n```kotlin\n\tval compositePageTransformer = CompositePageTransformer()\n        compositePageTransformer.addTransformer(ScaleInTransformer())\n        compositePageTransformer.addTransformer(MarginPageTransformer(resources.getDimension(R.dimen.dp_10).toInt()))\n        viewPager2.setPageTransformer(compositePageTransformer)\n```\n上述代码中我们通过CompositePageTransformer为ViewPager设置了MarginPageTransformer和一个页面缩放的ScaleInTransformer。来看下效果：\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi8xNC8xNmYwM2JhZjJmNGQ0MzA1?x-oss-process=image/format,png)\n### 3.ViewPager2中的PageTransformer\nPageTransformer是一个位于ViewPager2中的接口，因此ViewPager2的PageTransformer是独立于ViewPager的，它与ViewPager的PageTransformer没有任何关系。虽然如此，却不必担心。因为ViewPager2的PageTransformer和ViewPager的PageTransformer实现方式一模一样。我们看下上一小节中用到的ScaleInTransformer：\n\n```kotlin\nclass ScaleInTransformer : ViewPager2.PageTransformer {\n    private val mMinScale = DEFAULT_MIN_SCALE\n    override fun transformPage(view: View, position: Float) {\n        view.elevation = -abs(position)\n        val pageWidth = view.width\n        val pageHeight = view.height\n\n        view.pivotY = (pageHeight / 2).toFloat()\n        view.pivotX = (pageWidth / 2).toFloat()\n        if (position < -1) {\n            view.scaleX = mMinScale\n            view.scaleY = mMinScale\n            view.pivotX = pageWidth.toFloat()\n        } else if (position <= 1) {\n            if (position < 0) {\n                val scaleFactor = (1 + position) * (1 - mMinScale) + mMinScale\n                view.scaleX = scaleFactor\n                view.scaleY = scaleFactor\n                view.pivotX = pageWidth * (DEFAULT_CENTER + DEFAULT_CENTER * -position)\n            } else {\n                val scaleFactor = (1 - position) * (1 - mMinScale) + mMinScale\n                view.scaleX = scaleFactor\n                view.scaleY = scaleFactor\n                view.pivotX = pageWidth * ((1 - position) * DEFAULT_CENTER)\n            }\n        } else {\n            view.pivotX = 0f\n            view.scaleX = mMinScale\n            view.scaleY = mMinScale\n        }\n    }\n\n    companion object {\n\n        const val DEFAULT_MIN_SCALE = 0.85f\n        const val DEFAULT_CENTER = 0.5f\n    }\n}\n```\n### 4.ViewPager2的一屏多页效果\n在ViewPager2的官方Sample上看到了ViewPager2的一屏多页可以通过为RecyclerView设置Padding来实现。代码如下：\n\n```kotlin\n\n        viewPager2.apply { \n                    offscreenPageLimit=1\n                   val recyclerView= getChildAt(0) as RecyclerView\n                    recyclerView.apply {\n                        val padding = resources.getDimensionPixelOffset(R.dimen.dp_10) +\n                                resources.getDimensionPixelOffset(R.dimen.dp_10)\n                        // setting padding on inner RecyclerView puts overscroll effect in the right place\n                        setPadding(padding, 0, padding, 0)\n                        clipToPadding = false\n                    }\n                }\n        val compositePageTransformer = CompositePageTransformer()\n        compositePageTransformer.addTransformer(ScaleInTransformer())\n        compositePageTransformer.addTransformer(MarginPageTransformer(resources.getDimension(R.dimen.dp_10).toInt()))\n        viewPager2.setPageTransformer(compositePageTransformer)\n\n```\n最后，我们来看下效果\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi8xNC8xNmYwM2JhZjJmNGZmYTgw?x-oss-process=image/format,png)\n## 四、ViewPager2与Fragment\n我们前面也已经提到了ViewPager2中新增的FragmentStateAdapter 替代了ViewPager的FragmentStatePagerAdapter。那么来我们就用ViewPager2来实现一个Activity中嵌套Fragment的实例。\n### 1.Activity的layout中添加ViewPager2\n```kotlin\n\t<androidx.viewpager2.widget.ViewPager2\n            android:id=\"@+id/vp_fragment\"\n            android:layout_width=\"match_parent\"\n            android:layout_height=\"match_parent\"\n            android:layout_above=\"@id/rg_tab\" />\n```\n### 2.实现FragmentStateAdapter\n\n```kotlin\nclass AdapterFragmentPager(fragmentActivity: FragmentActivity) : FragmentStateAdapter(fragmentActivity) {\n\n    private val fragments: SparseArray<BaseFragment> = SparseArray()\n\n    init {\n        fragments.put(PAGE_HOME, HomeFragment.getInstance())\n        fragments.put(PAGE_FIND, PageFragment.getInstance())\n        fragments.put(PAGE_INDICATOR, IndicatorFragment.getInstance())\n        fragments.put(PAGE_OTHERS, OthersFragment.getInstance())\n    }\n\n    override fun createFragment(position: Int): Fragment {\n        var fragment: Fragment\n        when (position) {\n            PAGE_HOME -> {\n                if (fragments.get(PAGE_HOME) == null) {\n                    fragment = HomeFragment.getInstance();\n                    fragments.put(PAGE_HOME, fragment)\n                } else {\n                    fragment = fragments.get(PAGE_HOME)\n                }\n            }\n            PAGE_FIND -> {\n                if (fragments.get(PAGE_FIND) == null) {\n                    fragment = PageFragment.getInstance();\n                    fragments.put(PAGE_FIND, fragment)\n                } else {\n                    fragment = fragments.get(PAGE_FIND)\n                }\n            }\n\n            PAGE_INDICATOR -> {\n                if (fragments.get(PAGE_INDICATOR) == null) {\n                    fragment = IndicatorFragment.getInstance();\n                    fragments.put(PAGE_INDICATOR, fragment)\n                } else {\n                    fragment = fragments.get(PAGE_INDICATOR)\n                }\n            }\n\n            PAGE_OTHERS -> {\n                if (fragments.get(PAGE_OTHERS) == null) {\n                    fragment = OthersFragment.getInstance();\n                    fragments.put(PAGE_OTHERS, fragment)\n                } else {\n                    fragment = fragments.get(PAGE_OTHERS)\n                }\n            }\n            else -> {\n                if (fragments.get(PAGE_HOME) == null) {\n                    fragment = HomeFragment.getInstance();\n                    fragments.put(PAGE_HOME, fragment)\n                } else {\n                    fragment = fragments.get(PAGE_HOME)\n                }\n            }\n        }\n        return fragment\n    }\n\n    override fun getItemCount(): Int {\n        return fragments.size()\n    }\n\n    companion object {\n\n        const val PAGE_HOME = 0\n\n        const val PAGE_FIND = 1\n\n        const val PAGE_INDICATOR = 2\n\n        const val PAGE_OTHERS = 3\n\n    }\n\n}\n```\n### 3.在Activity中为ViewPager2设置FragmentStateAdapter\n\n```kotlin\n\tvp_fragment.adapter = AdapterFragmentPager(this)\n        vp_fragment.offscreenPageLimit = 3\n        vp_fragment.isUserInputEnabled=false\n```\n## 五、ViewPager2与TabLayout\nTabLayout也是项目中经常用到的一个控件，它通常会与ViewPager一起出现。那么对于ViewPager2应该怎么使用Tablayout呢？这需要我们认识一个新类TabLayoutMediator，这个类是在material-1.2.0中新增的一个类，目前material包的最新版本是1.2.0-alpha03，因此需要我们单独引入这个包，依赖如下：\n```kotlin\nimplementation 'com.google.android.material:material:1.2.0-alpha03'\n```\nTabLayoutMediator的构造方法接收三个参数，第一个参数为TabLayout；第二个参数为ViewPager2；第三个参数是TabConfigurationStrategy，这是一个接口，该接口中有一个方法onConfigureTab(@NonNull TabLayout.Tab tab, int position),第一个参数是当前Tab,第二个当前position，源码如下：\n\n```kotlin\n  public interface TabConfigurationStrategy {\n    /**\n     * Called to configure the tab for the page at the specified position. Typically calls {@link\n     * TabLayout.Tab#setText(CharSequence)}, but any form of styling can be applied.\n     *\n     * @param tab The Tab which should be configured to represent the title of the item at the given\n     *     position in the data set.\n     * @param position The position of the item within the adapter's data set.\n     */\n    void onConfigureTab(@NonNull TabLayout.Tab tab, int position);\n  }\n  ```\n 接下来我们便可以通过TabLayoutMediator将TabLayout与ViewPager2关联起来了： \n```kotlin\nTabLayoutMediator(tab_layout, view_pager) { tab, position ->\n            //  为Tab设置Text\n            tab.text = Card.DECK[position].toString()\n        }.attach()\n```\n使用起来非常简单，实现效果如下图所示：\n\n![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC8xLzEzLzE2ZjllZTk3OTMyYWU1Njk?x-oss-process=image/format,png)\n\n## 六、小结\n本篇文章我们认识了ViewPager2的新特性以及其用法。总得来说ViewPager2相比ViewPager不管在性能上还是在功能上都有了很大的提升。因此，我相信在不久的未来ViewPager2必定会取代ViewPager。那么，你是否已经考虑将ViewPager2用到你的项目中了呢？\n\n最后再来给大家推荐一下[BannerViewPager](https://github.com/zhpanvip/BannerViewPager)。这是一个基于ViewPager实现的具有强大功能的无限轮播库。在未来，我会在BannerViewPager 3.0版本中用ViewPager2来重构代码。欢迎大家到GitHub关注[BannerViewPager](https://github.com/zhpanvip/BannerViewPager) 。\n\n\n[本文涉及源码下载](https://download.csdn.net/download/qq_20521573/12032894)\n\n第四节中ViewPager2与Fragment的代码见：\n\n[BannerViewPager](https://github.com/zhpanvip/BannerViewPager) ","source":"_posts/23.学不动也要学！深入了解ViewPager2.md","raw":"---\ntitle: 学不动也要学！深入了解ViewPager2\ndate:  2019-12-14 16:47:19\ntags:\n- ViewPager2\n---\n\n就在上个月20号(2019年11月20号)，期待已久的ViewPager2 正式版终于发布了！不知道你是否已经蠢蠢欲动着手用ViewPager2去改造你项目的ViewPager了？什么？你还不知道ViewPager2？那么请你马上系好安全带，本篇文章将带你一览ViewPager2的风采。\n## 一、ViewPager2的新特性\nViewPager2从名字就可以看出来它是ViewPager的升级版，既然是升级版那么它相比ViewPager有哪些新功能和哪些API变化呢？我们接着往下看。\n### 1.ViewPager2新特性\n- 基于RecyclerView实现。这意味着RecyclerView的优点将会被ViewPager2所继承。\n- 支持竖直滑动。只需要一个参数就可以改变滑动方向。\n- 支持关闭用户输入。通过setUserInputEnabled来设置是否禁止用户滑动页面。\n- 支持通过编程方式滚动。通过fakeDragBy(offsetPx)代码模拟用户滑动页面。\n- CompositePageTransformer 支持同时添加多个PageTransformer。\n- 支持DiffUtil ，可以添加数据集合改变的item动画。\n- 支持RTL (right-to-left)布局。我觉得这个功能对国内开发者来说可能用处不大..\n\n### 2.相比ViewPager变化的API\nViewPager2相比ViewPager做了哪些改变呢？研究了一番之后我大概列出以下几点：\n- ViewPager2与ViewPager同是继承自ViewGrop，但是ViewPager2被声明成了final。意味着我们不可能再像ViewPager一样通过继承来修改ViewPager2的代码。\n- FragmentStatePagerAdapter被FragmentStateAdapter 替代\n- PagerAdapter被RecyclerView.Adapter替代\n- addPageChangeListener被registerOnPageChangeCallback。我们知道ViewPager的addPageChangeListener接收的是一个OnPageChangeListener的接口，而这个接口中有三个方法，当想要监听页面变化时需要重写这三个方法。而ViewPager2的registerOnPageChangeCallback方法接收的是一个叫OnPageChangeCallback的抽象类，因此我们可以选择性的重写需要的方法即可。\n- 移除了setPargeMargin方法。\n\n以上所罗列的新特性和API可能并不完整，如有疏漏可以留言补充。\n## 二、开启ViewPager2之旅\nViewPager2位于androidx包下，也就是它不像ViewPager一样被内置在系统源码中。因此，使用ViewPager2需要额外的添加依赖库。另外，android support中不包含ViewPager，也就是要使用ViewPager2必须迁移到androidx才可以。\n\n### 1.添加依赖，目前ViewPager2的最新版本是1.0.0：\n\n```java\ndependencies {\n    implementation \"androidx.viewpager2:viewpager2:1.0.0\"\n}\n```\n### 2.ViewPager2布局文件：\n\n```java\n\t<androidx.viewpager2.widget.ViewPager2\n        android:id=\"@+id/view_pager\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"match_parent\"\n        app:layout_constraintBottom_toBottomOf=\"parent\"\n        app:layout_constraintLeft_toLeftOf=\"parent\"\n        app:layout_constraintRight_toRightOf=\"parent\"\n        app:layout_constraintTop_toTopOf=\"parent\" />\n```\n### 3.ViewPager2的Adapter\n因为ViewPager2内部封装的是RecyclerView，因此它的Adapter也就是RecyclerView的Adapter。\n\n```kotlin\nclass MyAdapter : RecyclerView.Adapter<MyAdapter.PagerViewHolder>() {\n    private var mList: List<Int> = ArrayList()\n    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): PagerViewHolder {\n        val itemView = LayoutInflater.from(parent.context).inflate(R.layout.item_page, parent, false)\n        return PagerViewHolder(itemView)\n    }\n\n    override fun onBindViewHolder(holder: PagerViewHolder, position: Int) {\n        holder.bindData(mList[position])\n    }\n\n    fun setList(list: List<Int>) {\n        mList = list\n    }\n\n    override fun getItemCount(): Int {\n        return mList.size\n    }\n\t//\tViewHolder需要继承RecycleView.ViewHolder\n    class PagerViewHolder(itemView: View) : RecyclerView.ViewHolder(itemView) {\n        private val mTextView: TextView = itemView.findViewById(R.id.tv_text)\n        private var colors = arrayOf(\"#CCFF99\",\"#41F1E5\",\"#8D41F1\",\"#FF99CC\")\n\n        fun bindData(i: Int) {\n            mTextView.text = i.toString()\n            mTextView.setBackgroundColor(Color.parseColor(colors[i]))\n        }\n    }\n}\n```\nitem_page中代码如下：\n\n```kotlin\n<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    android:gravity=\"center\">\n\n    <TextView\n        android:id=\"@+id/tv_text\"\n        android:background=\"@color/colorPrimaryDark\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"280dp\"\n        android:gravity=\"center\"\n        android:textColor=\"#ffffff\"\n        android:textSize=\"22sp\" />\n</LinearLayout>\n```\n### 4.在Activity中为ViewPager设置Adapter：\n\n```kotlin\n\t\tval viewPager2 = findViewById<ViewPager2>(R.id.view_pager)\n        val myAdapter = MyAdapter()\n        myAdapter.setList(data)\n        viewPager2.adapter = myAdapter\n```\n\n很简单就完成了一个ViewPager的功能，来看下效果怎么样：\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi8xNC8xNmYwM2JhZjJkMDAzYzli?x-oss-process=image/format,png)\n### 5.ViewPager2竖直滑动\n接下来我们通过一行代码为其设置竖直滑动\n\n```kotlin\nviewPager2.orientation = ViewPager2.ORIENTATION_VERTICAL\n```\n竖直滑动用ViewPager是很难实现的，而通过ViewPager2只需要设置一个参数即可。来看下效果：\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi8xNC8xNmYwM2JhZjJjZTdiNTI4?x-oss-process=image/format,png)\n### 6.页面滑动事件监听\n上文已经提到过了，我们为ViewPager设置页面滑动的监听事件需要重写三个方法，而为ViewPager2设置监听事件只需要重写需要的方法即可，因为ViewPager2中OnPageChangeCallback是一个抽象类。\n\n```kotlin\nviewPager2.registerOnPageChangeCallback(object : ViewPager2.OnPageChangeCallback() {\n            override fun onPageSelected(position: Int) {\n                super.onPageSelected(position)\n                Toast.makeText(this@MainActivity, \"page selected $position\", Toast.LENGTH_SHORT).show()\n            }\n        })\n```\n### 7.setUserInputEnabled与fakeDragBy\n我们知道，在使用ViewPager的时候想要禁止用户滑动需要重写ViewPager的onInterceptTouchEvent。而ViewPager2被声明为了final，我们无法再去继承ViewPager2。那么我们应该怎么禁止ViewPager2的滑动呢？其实在ViewPager2中已经为我们提供了这个功能，只需要通过setUserInputEnabled即可实现。\n\n```kotlin\nviewPager2.isUserInputEnabled = false\n```\n同时ViewPager2新增了一个fakeDragBy的方法。通过这个方法可以来模拟拖拽。在使用fakeDragBy前需要先beginFakeDrag方法来开启模拟拖拽。fakeDragBy会返回一个boolean值，true表示有fake drag正在执行，而返回false表示当前没有fake drag在执行。我们通过代码来尝试下：\n\n```kotlin\nfun fakeDragBy(view: View) {\n        viewPager2.beginFakeDrag()\n        if (viewPager2.fakeDragBy(-310f))\n            viewPager2.endFakeDrag()\n    }\n```\n需要注意到是fakeDragBy接受一个float的参数，当参数值为正数时表示向前一个页面滑动，当值为负数时表示向下一个页面滑动。\n下面来看下效果图：\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi8xNC8xNmYwM2JhZjJlZmY2ZWY4?x-oss-process=image/format,png)\n演示图中禁止了用户输入，通过按钮点击可以模拟用户滑动。\n\n## 三、ViewPager2的PageTransformer\n相比ViewPager，ViewPager2的Transformer功能有了很大的扩展。ViewPager2不仅可以通过PageTransformer用来设置页面动画，还可以用PageTransformer设置页面间距以及同时添加多个PageTransformer。接下来我们就来认识下ViewPager2的PageTransformer吧！\n\n### 1.setPageMargin\n在第一章中我们提到了ViewPager2移除了setPageMargin方法，那么怎么为ViewPager2设置页面间距呢？其实在ViewPager2中为我们提供了MarginPageTransformer，我们可以通过ViewPager2的setPageTransformer方法来设置页面间距。代码如下：\n\n```kotlin\nviewPager2.setPageTransformer(MarginPageTransformer(resources.getDimension(R.dimen.dp_10).toInt()))\n```\n上述代码我们为ViewPager2设置了10dp的页面间距。效果如下：\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi8xNC8xNmYwM2JhZjJkMmQzODkw?x-oss-process=image/format,png)\n### 2.认识CompositePageTransformer\n这个时候我们应该有个疑问，为ViewPager2设置了页面间距后如果还想设置页面动画的Transformer怎么办呢？这时候就该CompositePageTransformer出场了。从名字上也可以看出来它是一个组合的PageTransformer。没错，CompositePageTransformer实现了PageTransformer接口，同时在其内部维护了一个List集合，我们可以将多个PageTransformer添加到CompositePageTransformer中。\n\n```kotlin\n\tval compositePageTransformer = CompositePageTransformer()\n        compositePageTransformer.addTransformer(ScaleInTransformer())\n        compositePageTransformer.addTransformer(MarginPageTransformer(resources.getDimension(R.dimen.dp_10).toInt()))\n        viewPager2.setPageTransformer(compositePageTransformer)\n```\n上述代码中我们通过CompositePageTransformer为ViewPager设置了MarginPageTransformer和一个页面缩放的ScaleInTransformer。来看下效果：\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi8xNC8xNmYwM2JhZjJmNGQ0MzA1?x-oss-process=image/format,png)\n### 3.ViewPager2中的PageTransformer\nPageTransformer是一个位于ViewPager2中的接口，因此ViewPager2的PageTransformer是独立于ViewPager的，它与ViewPager的PageTransformer没有任何关系。虽然如此，却不必担心。因为ViewPager2的PageTransformer和ViewPager的PageTransformer实现方式一模一样。我们看下上一小节中用到的ScaleInTransformer：\n\n```kotlin\nclass ScaleInTransformer : ViewPager2.PageTransformer {\n    private val mMinScale = DEFAULT_MIN_SCALE\n    override fun transformPage(view: View, position: Float) {\n        view.elevation = -abs(position)\n        val pageWidth = view.width\n        val pageHeight = view.height\n\n        view.pivotY = (pageHeight / 2).toFloat()\n        view.pivotX = (pageWidth / 2).toFloat()\n        if (position < -1) {\n            view.scaleX = mMinScale\n            view.scaleY = mMinScale\n            view.pivotX = pageWidth.toFloat()\n        } else if (position <= 1) {\n            if (position < 0) {\n                val scaleFactor = (1 + position) * (1 - mMinScale) + mMinScale\n                view.scaleX = scaleFactor\n                view.scaleY = scaleFactor\n                view.pivotX = pageWidth * (DEFAULT_CENTER + DEFAULT_CENTER * -position)\n            } else {\n                val scaleFactor = (1 - position) * (1 - mMinScale) + mMinScale\n                view.scaleX = scaleFactor\n                view.scaleY = scaleFactor\n                view.pivotX = pageWidth * ((1 - position) * DEFAULT_CENTER)\n            }\n        } else {\n            view.pivotX = 0f\n            view.scaleX = mMinScale\n            view.scaleY = mMinScale\n        }\n    }\n\n    companion object {\n\n        const val DEFAULT_MIN_SCALE = 0.85f\n        const val DEFAULT_CENTER = 0.5f\n    }\n}\n```\n### 4.ViewPager2的一屏多页效果\n在ViewPager2的官方Sample上看到了ViewPager2的一屏多页可以通过为RecyclerView设置Padding来实现。代码如下：\n\n```kotlin\n\n        viewPager2.apply { \n                    offscreenPageLimit=1\n                   val recyclerView= getChildAt(0) as RecyclerView\n                    recyclerView.apply {\n                        val padding = resources.getDimensionPixelOffset(R.dimen.dp_10) +\n                                resources.getDimensionPixelOffset(R.dimen.dp_10)\n                        // setting padding on inner RecyclerView puts overscroll effect in the right place\n                        setPadding(padding, 0, padding, 0)\n                        clipToPadding = false\n                    }\n                }\n        val compositePageTransformer = CompositePageTransformer()\n        compositePageTransformer.addTransformer(ScaleInTransformer())\n        compositePageTransformer.addTransformer(MarginPageTransformer(resources.getDimension(R.dimen.dp_10).toInt()))\n        viewPager2.setPageTransformer(compositePageTransformer)\n\n```\n最后，我们来看下效果\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi8xNC8xNmYwM2JhZjJmNGZmYTgw?x-oss-process=image/format,png)\n## 四、ViewPager2与Fragment\n我们前面也已经提到了ViewPager2中新增的FragmentStateAdapter 替代了ViewPager的FragmentStatePagerAdapter。那么来我们就用ViewPager2来实现一个Activity中嵌套Fragment的实例。\n### 1.Activity的layout中添加ViewPager2\n```kotlin\n\t<androidx.viewpager2.widget.ViewPager2\n            android:id=\"@+id/vp_fragment\"\n            android:layout_width=\"match_parent\"\n            android:layout_height=\"match_parent\"\n            android:layout_above=\"@id/rg_tab\" />\n```\n### 2.实现FragmentStateAdapter\n\n```kotlin\nclass AdapterFragmentPager(fragmentActivity: FragmentActivity) : FragmentStateAdapter(fragmentActivity) {\n\n    private val fragments: SparseArray<BaseFragment> = SparseArray()\n\n    init {\n        fragments.put(PAGE_HOME, HomeFragment.getInstance())\n        fragments.put(PAGE_FIND, PageFragment.getInstance())\n        fragments.put(PAGE_INDICATOR, IndicatorFragment.getInstance())\n        fragments.put(PAGE_OTHERS, OthersFragment.getInstance())\n    }\n\n    override fun createFragment(position: Int): Fragment {\n        var fragment: Fragment\n        when (position) {\n            PAGE_HOME -> {\n                if (fragments.get(PAGE_HOME) == null) {\n                    fragment = HomeFragment.getInstance();\n                    fragments.put(PAGE_HOME, fragment)\n                } else {\n                    fragment = fragments.get(PAGE_HOME)\n                }\n            }\n            PAGE_FIND -> {\n                if (fragments.get(PAGE_FIND) == null) {\n                    fragment = PageFragment.getInstance();\n                    fragments.put(PAGE_FIND, fragment)\n                } else {\n                    fragment = fragments.get(PAGE_FIND)\n                }\n            }\n\n            PAGE_INDICATOR -> {\n                if (fragments.get(PAGE_INDICATOR) == null) {\n                    fragment = IndicatorFragment.getInstance();\n                    fragments.put(PAGE_INDICATOR, fragment)\n                } else {\n                    fragment = fragments.get(PAGE_INDICATOR)\n                }\n            }\n\n            PAGE_OTHERS -> {\n                if (fragments.get(PAGE_OTHERS) == null) {\n                    fragment = OthersFragment.getInstance();\n                    fragments.put(PAGE_OTHERS, fragment)\n                } else {\n                    fragment = fragments.get(PAGE_OTHERS)\n                }\n            }\n            else -> {\n                if (fragments.get(PAGE_HOME) == null) {\n                    fragment = HomeFragment.getInstance();\n                    fragments.put(PAGE_HOME, fragment)\n                } else {\n                    fragment = fragments.get(PAGE_HOME)\n                }\n            }\n        }\n        return fragment\n    }\n\n    override fun getItemCount(): Int {\n        return fragments.size()\n    }\n\n    companion object {\n\n        const val PAGE_HOME = 0\n\n        const val PAGE_FIND = 1\n\n        const val PAGE_INDICATOR = 2\n\n        const val PAGE_OTHERS = 3\n\n    }\n\n}\n```\n### 3.在Activity中为ViewPager2设置FragmentStateAdapter\n\n```kotlin\n\tvp_fragment.adapter = AdapterFragmentPager(this)\n        vp_fragment.offscreenPageLimit = 3\n        vp_fragment.isUserInputEnabled=false\n```\n## 五、ViewPager2与TabLayout\nTabLayout也是项目中经常用到的一个控件，它通常会与ViewPager一起出现。那么对于ViewPager2应该怎么使用Tablayout呢？这需要我们认识一个新类TabLayoutMediator，这个类是在material-1.2.0中新增的一个类，目前material包的最新版本是1.2.0-alpha03，因此需要我们单独引入这个包，依赖如下：\n```kotlin\nimplementation 'com.google.android.material:material:1.2.0-alpha03'\n```\nTabLayoutMediator的构造方法接收三个参数，第一个参数为TabLayout；第二个参数为ViewPager2；第三个参数是TabConfigurationStrategy，这是一个接口，该接口中有一个方法onConfigureTab(@NonNull TabLayout.Tab tab, int position),第一个参数是当前Tab,第二个当前position，源码如下：\n\n```kotlin\n  public interface TabConfigurationStrategy {\n    /**\n     * Called to configure the tab for the page at the specified position. Typically calls {@link\n     * TabLayout.Tab#setText(CharSequence)}, but any form of styling can be applied.\n     *\n     * @param tab The Tab which should be configured to represent the title of the item at the given\n     *     position in the data set.\n     * @param position The position of the item within the adapter's data set.\n     */\n    void onConfigureTab(@NonNull TabLayout.Tab tab, int position);\n  }\n  ```\n 接下来我们便可以通过TabLayoutMediator将TabLayout与ViewPager2关联起来了： \n```kotlin\nTabLayoutMediator(tab_layout, view_pager) { tab, position ->\n            //  为Tab设置Text\n            tab.text = Card.DECK[position].toString()\n        }.attach()\n```\n使用起来非常简单，实现效果如下图所示：\n\n![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC8xLzEzLzE2ZjllZTk3OTMyYWU1Njk?x-oss-process=image/format,png)\n\n## 六、小结\n本篇文章我们认识了ViewPager2的新特性以及其用法。总得来说ViewPager2相比ViewPager不管在性能上还是在功能上都有了很大的提升。因此，我相信在不久的未来ViewPager2必定会取代ViewPager。那么，你是否已经考虑将ViewPager2用到你的项目中了呢？\n\n最后再来给大家推荐一下[BannerViewPager](https://github.com/zhpanvip/BannerViewPager)。这是一个基于ViewPager实现的具有强大功能的无限轮播库。在未来，我会在BannerViewPager 3.0版本中用ViewPager2来重构代码。欢迎大家到GitHub关注[BannerViewPager](https://github.com/zhpanvip/BannerViewPager) 。\n\n\n[本文涉及源码下载](https://download.csdn.net/download/qq_20521573/12032894)\n\n第四节中ViewPager2与Fragment的代码见：\n\n[BannerViewPager](https://github.com/zhpanvip/BannerViewPager) ","slug":"23.学不动也要学！深入了解ViewPager2","published":1,"updated":"2020-08-29T01:57:31.038Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckegm5nss001gdwozas9ahcey","content":"<p>就在上个月20号(2019年11月20号)，期待已久的ViewPager2 正式版终于发布了！不知道你是否已经蠢蠢欲动着手用ViewPager2去改造你项目的ViewPager了？什么？你还不知道ViewPager2？那么请你马上系好安全带，本篇文章将带你一览ViewPager2的风采。</p>\n<h2 id=\"一、ViewPager2的新特性\"><a href=\"#一、ViewPager2的新特性\" class=\"headerlink\" title=\"一、ViewPager2的新特性\"></a>一、ViewPager2的新特性</h2><p>ViewPager2从名字就可以看出来它是ViewPager的升级版，既然是升级版那么它相比ViewPager有哪些新功能和哪些API变化呢？我们接着往下看。</p>\n<h3 id=\"1-ViewPager2新特性\"><a href=\"#1-ViewPager2新特性\" class=\"headerlink\" title=\"1.ViewPager2新特性\"></a>1.ViewPager2新特性</h3><ul>\n<li>基于RecyclerView实现。这意味着RecyclerView的优点将会被ViewPager2所继承。</li>\n<li>支持竖直滑动。只需要一个参数就可以改变滑动方向。</li>\n<li>支持关闭用户输入。通过setUserInputEnabled来设置是否禁止用户滑动页面。</li>\n<li>支持通过编程方式滚动。通过fakeDragBy(offsetPx)代码模拟用户滑动页面。</li>\n<li>CompositePageTransformer 支持同时添加多个PageTransformer。</li>\n<li>支持DiffUtil ，可以添加数据集合改变的item动画。</li>\n<li>支持RTL (right-to-left)布局。我觉得这个功能对国内开发者来说可能用处不大..</li>\n</ul>\n<h3 id=\"2-相比ViewPager变化的API\"><a href=\"#2-相比ViewPager变化的API\" class=\"headerlink\" title=\"2.相比ViewPager变化的API\"></a>2.相比ViewPager变化的API</h3><p>ViewPager2相比ViewPager做了哪些改变呢？研究了一番之后我大概列出以下几点：</p>\n<ul>\n<li>ViewPager2与ViewPager同是继承自ViewGrop，但是ViewPager2被声明成了final。意味着我们不可能再像ViewPager一样通过继承来修改ViewPager2的代码。</li>\n<li>FragmentStatePagerAdapter被FragmentStateAdapter 替代</li>\n<li>PagerAdapter被RecyclerView.Adapter替代</li>\n<li>addPageChangeListener被registerOnPageChangeCallback。我们知道ViewPager的addPageChangeListener接收的是一个OnPageChangeListener的接口，而这个接口中有三个方法，当想要监听页面变化时需要重写这三个方法。而ViewPager2的registerOnPageChangeCallback方法接收的是一个叫OnPageChangeCallback的抽象类，因此我们可以选择性的重写需要的方法即可。</li>\n<li>移除了setPargeMargin方法。</li>\n</ul>\n<p>以上所罗列的新特性和API可能并不完整，如有疏漏可以留言补充。</p>\n<h2 id=\"二、开启ViewPager2之旅\"><a href=\"#二、开启ViewPager2之旅\" class=\"headerlink\" title=\"二、开启ViewPager2之旅\"></a>二、开启ViewPager2之旅</h2><p>ViewPager2位于androidx包下，也就是它不像ViewPager一样被内置在系统源码中。因此，使用ViewPager2需要额外的添加依赖库。另外，android support中不包含ViewPager，也就是要使用ViewPager2必须迁移到androidx才可以。</p>\n<h3 id=\"1-添加依赖，目前ViewPager2的最新版本是1-0-0：\"><a href=\"#1-添加依赖，目前ViewPager2的最新版本是1-0-0：\" class=\"headerlink\" title=\"1.添加依赖，目前ViewPager2的最新版本是1.0.0：\"></a>1.添加依赖，目前ViewPager2的最新版本是1.0.0：</h3><pre><code class=\"hljs java\">dependencies &#123;\n    implementation <span class=\"hljs-string\">&quot;androidx.viewpager2:viewpager2:1.0.0&quot;</span>\n&#125;</code></pre>\n<h3 id=\"2-ViewPager2布局文件：\"><a href=\"#2-ViewPager2布局文件：\" class=\"headerlink\" title=\"2.ViewPager2布局文件：\"></a>2.ViewPager2布局文件：</h3><pre><code class=\"hljs java\">&lt;androidx.viewpager2.widget.ViewPager2\n       android:id=<span class=\"hljs-string\">&quot;@+id/view_pager&quot;</span>\n       android:layout_width=<span class=\"hljs-string\">&quot;match_parent&quot;</span>\n       android:layout_height=<span class=\"hljs-string\">&quot;match_parent&quot;</span>\n       app:layout_constraintBottom_toBottomOf=<span class=\"hljs-string\">&quot;parent&quot;</span>\n       app:layout_constraintLeft_toLeftOf=<span class=\"hljs-string\">&quot;parent&quot;</span>\n       app:layout_constraintRight_toRightOf=<span class=\"hljs-string\">&quot;parent&quot;</span>\n       app:layout_constraintTop_toTopOf=<span class=\"hljs-string\">&quot;parent&quot;</span> /&gt;</code></pre>\n<h3 id=\"3-ViewPager2的Adapter\"><a href=\"#3-ViewPager2的Adapter\" class=\"headerlink\" title=\"3.ViewPager2的Adapter\"></a>3.ViewPager2的Adapter</h3><p>因为ViewPager2内部封装的是RecyclerView，因此它的Adapter也就是RecyclerView的Adapter。</p>\n<pre><code class=\"hljs kotlin\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MyAdapter</span> : <span class=\"hljs-type\">RecyclerView.Adapter</span>&lt;<span class=\"hljs-type\">MyAdapter.PagerViewHolder</span>&gt;</span>() &#123;\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">var</span> mList: List&lt;<span class=\"hljs-built_in\">Int</span>&gt; = ArrayList()\n    <span class=\"hljs-keyword\">override</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">onCreateViewHolder</span><span class=\"hljs-params\">(parent: <span class=\"hljs-type\">ViewGroup</span>, viewType: <span class=\"hljs-type\">Int</span>)</span></span>: PagerViewHolder &#123;\n        <span class=\"hljs-keyword\">val</span> itemView = LayoutInflater.from(parent.context).inflate(R.layout.item_page, parent, <span class=\"hljs-literal\">false</span>)\n        <span class=\"hljs-keyword\">return</span> PagerViewHolder(itemView)\n    &#125;\n\n    <span class=\"hljs-keyword\">override</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">onBindViewHolder</span><span class=\"hljs-params\">(holder: <span class=\"hljs-type\">PagerViewHolder</span>, position: <span class=\"hljs-type\">Int</span>)</span></span> &#123;\n        holder.bindData(mList[position])\n    &#125;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">setList</span><span class=\"hljs-params\">(list: <span class=\"hljs-type\">List</span>&lt;<span class=\"hljs-type\">Int</span>&gt;)</span></span> &#123;\n        mList = list\n    &#125;\n\n    <span class=\"hljs-keyword\">override</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">getItemCount</span><span class=\"hljs-params\">()</span></span>: <span class=\"hljs-built_in\">Int</span> &#123;\n        <span class=\"hljs-keyword\">return</span> mList.size\n    &#125;\n\t<span class=\"hljs-comment\">//\tViewHolder需要继承RecycleView.ViewHolder</span>\n    <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">PagerViewHolder</span></span>(itemView: View) : RecyclerView.ViewHolder(itemView) &#123;\n        <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">val</span> mTextView: TextView = itemView.findViewById(R.id.tv_text)\n        <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">var</span> colors = arrayOf(<span class=\"hljs-string\">&quot;#CCFF99&quot;</span>,<span class=\"hljs-string\">&quot;#41F1E5&quot;</span>,<span class=\"hljs-string\">&quot;#8D41F1&quot;</span>,<span class=\"hljs-string\">&quot;#FF99CC&quot;</span>)\n\n        <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">bindData</span><span class=\"hljs-params\">(i: <span class=\"hljs-type\">Int</span>)</span></span> &#123;\n            mTextView.text = i.toString()\n            mTextView.setBackgroundColor(Color.parseColor(colors[i]))\n        &#125;\n    &#125;\n&#125;</code></pre>\n<p>item_page中代码如下：</p>\n<pre><code class=\"hljs kotlin\">&lt;LinearLayout xmlns:android=<span class=\"hljs-string\">&quot;http://schemas.android.com/apk/res/android&quot;</span>\n    android:layout_width=<span class=\"hljs-string\">&quot;match_parent&quot;</span>\n    android:layout_height=<span class=\"hljs-string\">&quot;match_parent&quot;</span>\n    android:gravity=<span class=\"hljs-string\">&quot;center&quot;</span>&gt;\n\n    &lt;TextView\n        android:id=<span class=\"hljs-string\">&quot;@+id/tv_text&quot;</span>\n        android:background=<span class=\"hljs-string\">&quot;@color/colorPrimaryDark&quot;</span>\n        android:layout_width=<span class=\"hljs-string\">&quot;match_parent&quot;</span>\n        android:layout_height=<span class=\"hljs-string\">&quot;280dp&quot;</span>\n        android:gravity=<span class=\"hljs-string\">&quot;center&quot;</span>\n        android:textColor=<span class=\"hljs-string\">&quot;#ffffff&quot;</span>\n        android:textSize=<span class=\"hljs-string\">&quot;22sp&quot;</span> /&gt;\n&lt;/LinearLayout&gt;</code></pre>\n<h3 id=\"4-在Activity中为ViewPager设置Adapter：\"><a href=\"#4-在Activity中为ViewPager设置Adapter：\" class=\"headerlink\" title=\"4.在Activity中为ViewPager设置Adapter：\"></a>4.在Activity中为ViewPager设置Adapter：</h3><pre><code class=\"hljs kotlin\"><span class=\"hljs-keyword\">val</span> viewPager2 = findViewById&lt;ViewPager2&gt;(R.id.view_pager)\n      <span class=\"hljs-keyword\">val</span> myAdapter = MyAdapter()\n      myAdapter.setList(<span class=\"hljs-keyword\">data</span>)\n      viewPager2.adapter = myAdapter</code></pre>\n\n<p>很简单就完成了一个ViewPager的功能，来看下效果怎么样：<br><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi8xNC8xNmYwM2JhZjJkMDAzYzli?x-oss-process=image/format,png\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"5-ViewPager2竖直滑动\"><a href=\"#5-ViewPager2竖直滑动\" class=\"headerlink\" title=\"5.ViewPager2竖直滑动\"></a>5.ViewPager2竖直滑动</h3><p>接下来我们通过一行代码为其设置竖直滑动</p>\n<pre><code class=\"hljs kotlin\">viewPager2.orientation = ViewPager2.ORIENTATION_VERTICAL</code></pre>\n<p>竖直滑动用ViewPager是很难实现的，而通过ViewPager2只需要设置一个参数即可。来看下效果：<br><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi8xNC8xNmYwM2JhZjJjZTdiNTI4?x-oss-process=image/format,png\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"6-页面滑动事件监听\"><a href=\"#6-页面滑动事件监听\" class=\"headerlink\" title=\"6.页面滑动事件监听\"></a>6.页面滑动事件监听</h3><p>上文已经提到过了，我们为ViewPager设置页面滑动的监听事件需要重写三个方法，而为ViewPager2设置监听事件只需要重写需要的方法即可，因为ViewPager2中OnPageChangeCallback是一个抽象类。</p>\n<pre><code class=\"hljs kotlin\">viewPager2.registerOnPageChangeCallback(<span class=\"hljs-keyword\">object</span> : ViewPager2.OnPageChangeCallback() &#123;\n            <span class=\"hljs-keyword\">override</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">onPageSelected</span><span class=\"hljs-params\">(position: <span class=\"hljs-type\">Int</span>)</span></span> &#123;\n                <span class=\"hljs-keyword\">super</span>.onPageSelected(position)\n                Toast.makeText(<span class=\"hljs-keyword\">this</span><span class=\"hljs-symbol\">@MainActivity</span>, <span class=\"hljs-string\">&quot;page selected <span class=\"hljs-variable\">$position</span>&quot;</span>, Toast.LENGTH_SHORT).show()\n            &#125;\n        &#125;)</code></pre>\n<h3 id=\"7-setUserInputEnabled与fakeDragBy\"><a href=\"#7-setUserInputEnabled与fakeDragBy\" class=\"headerlink\" title=\"7.setUserInputEnabled与fakeDragBy\"></a>7.setUserInputEnabled与fakeDragBy</h3><p>我们知道，在使用ViewPager的时候想要禁止用户滑动需要重写ViewPager的onInterceptTouchEvent。而ViewPager2被声明为了final，我们无法再去继承ViewPager2。那么我们应该怎么禁止ViewPager2的滑动呢？其实在ViewPager2中已经为我们提供了这个功能，只需要通过setUserInputEnabled即可实现。</p>\n<pre><code class=\"hljs kotlin\">viewPager2.isUserInputEnabled = <span class=\"hljs-literal\">false</span></code></pre>\n<p>同时ViewPager2新增了一个fakeDragBy的方法。通过这个方法可以来模拟拖拽。在使用fakeDragBy前需要先beginFakeDrag方法来开启模拟拖拽。fakeDragBy会返回一个boolean值，true表示有fake drag正在执行，而返回false表示当前没有fake drag在执行。我们通过代码来尝试下：</p>\n<pre><code class=\"hljs kotlin\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">fakeDragBy</span><span class=\"hljs-params\">(view: <span class=\"hljs-type\">View</span>)</span></span> &#123;\n        viewPager2.beginFakeDrag()\n        <span class=\"hljs-keyword\">if</span> (viewPager2.fakeDragBy(-<span class=\"hljs-number\">310f</span>))\n            viewPager2.endFakeDrag()\n    &#125;</code></pre>\n<p>需要注意到是fakeDragBy接受一个float的参数，当参数值为正数时表示向前一个页面滑动，当值为负数时表示向下一个页面滑动。<br>下面来看下效果图：<br><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi8xNC8xNmYwM2JhZjJlZmY2ZWY4?x-oss-process=image/format,png\" alt=\"在这里插入图片描述\"><br>演示图中禁止了用户输入，通过按钮点击可以模拟用户滑动。</p>\n<h2 id=\"三、ViewPager2的PageTransformer\"><a href=\"#三、ViewPager2的PageTransformer\" class=\"headerlink\" title=\"三、ViewPager2的PageTransformer\"></a>三、ViewPager2的PageTransformer</h2><p>相比ViewPager，ViewPager2的Transformer功能有了很大的扩展。ViewPager2不仅可以通过PageTransformer用来设置页面动画，还可以用PageTransformer设置页面间距以及同时添加多个PageTransformer。接下来我们就来认识下ViewPager2的PageTransformer吧！</p>\n<h3 id=\"1-setPageMargin\"><a href=\"#1-setPageMargin\" class=\"headerlink\" title=\"1.setPageMargin\"></a>1.setPageMargin</h3><p>在第一章中我们提到了ViewPager2移除了setPageMargin方法，那么怎么为ViewPager2设置页面间距呢？其实在ViewPager2中为我们提供了MarginPageTransformer，我们可以通过ViewPager2的setPageTransformer方法来设置页面间距。代码如下：</p>\n<pre><code class=\"hljs kotlin\">viewPager2.setPageTransformer(MarginPageTransformer(resources.getDimension(R.dimen.dp_10).toInt()))</code></pre>\n<p>上述代码我们为ViewPager2设置了10dp的页面间距。效果如下：<br><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi8xNC8xNmYwM2JhZjJkMmQzODkw?x-oss-process=image/format,png\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"2-认识CompositePageTransformer\"><a href=\"#2-认识CompositePageTransformer\" class=\"headerlink\" title=\"2.认识CompositePageTransformer\"></a>2.认识CompositePageTransformer</h3><p>这个时候我们应该有个疑问，为ViewPager2设置了页面间距后如果还想设置页面动画的Transformer怎么办呢？这时候就该CompositePageTransformer出场了。从名字上也可以看出来它是一个组合的PageTransformer。没错，CompositePageTransformer实现了PageTransformer接口，同时在其内部维护了一个List集合，我们可以将多个PageTransformer添加到CompositePageTransformer中。</p>\n<pre><code class=\"hljs kotlin\"><span class=\"hljs-keyword\">val</span> compositePageTransformer = CompositePageTransformer()\n       compositePageTransformer.addTransformer(ScaleInTransformer())\n       compositePageTransformer.addTransformer(MarginPageTransformer(resources.getDimension(R.dimen.dp_10).toInt()))\n       viewPager2.setPageTransformer(compositePageTransformer)</code></pre>\n<p>上述代码中我们通过CompositePageTransformer为ViewPager设置了MarginPageTransformer和一个页面缩放的ScaleInTransformer。来看下效果：<br><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi8xNC8xNmYwM2JhZjJmNGQ0MzA1?x-oss-process=image/format,png\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"3-ViewPager2中的PageTransformer\"><a href=\"#3-ViewPager2中的PageTransformer\" class=\"headerlink\" title=\"3.ViewPager2中的PageTransformer\"></a>3.ViewPager2中的PageTransformer</h3><p>PageTransformer是一个位于ViewPager2中的接口，因此ViewPager2的PageTransformer是独立于ViewPager的，它与ViewPager的PageTransformer没有任何关系。虽然如此，却不必担心。因为ViewPager2的PageTransformer和ViewPager的PageTransformer实现方式一模一样。我们看下上一小节中用到的ScaleInTransformer：</p>\n<pre><code class=\"hljs kotlin\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ScaleInTransformer</span> : <span class=\"hljs-type\">ViewPager2.PageTransformer &#123;</span></span>\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">val</span> mMinScale = DEFAULT_MIN_SCALE\n    <span class=\"hljs-keyword\">override</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">transformPage</span><span class=\"hljs-params\">(view: <span class=\"hljs-type\">View</span>, position: <span class=\"hljs-type\">Float</span>)</span></span> &#123;\n        view.elevation = -abs(position)\n        <span class=\"hljs-keyword\">val</span> pageWidth = view.width\n        <span class=\"hljs-keyword\">val</span> pageHeight = view.height\n\n        view.pivotY = (pageHeight / <span class=\"hljs-number\">2</span>).toFloat()\n        view.pivotX = (pageWidth / <span class=\"hljs-number\">2</span>).toFloat()\n        <span class=\"hljs-keyword\">if</span> (position &lt; -<span class=\"hljs-number\">1</span>) &#123;\n            view.scaleX = mMinScale\n            view.scaleY = mMinScale\n            view.pivotX = pageWidth.toFloat()\n        &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (position &lt;= <span class=\"hljs-number\">1</span>) &#123;\n            <span class=\"hljs-keyword\">if</span> (position &lt; <span class=\"hljs-number\">0</span>) &#123;\n                <span class=\"hljs-keyword\">val</span> scaleFactor = (<span class=\"hljs-number\">1</span> + position) * (<span class=\"hljs-number\">1</span> - mMinScale) + mMinScale\n                view.scaleX = scaleFactor\n                view.scaleY = scaleFactor\n                view.pivotX = pageWidth * (DEFAULT_CENTER + DEFAULT_CENTER * -position)\n            &#125; <span class=\"hljs-keyword\">else</span> &#123;\n                <span class=\"hljs-keyword\">val</span> scaleFactor = (<span class=\"hljs-number\">1</span> - position) * (<span class=\"hljs-number\">1</span> - mMinScale) + mMinScale\n                view.scaleX = scaleFactor\n                view.scaleY = scaleFactor\n                view.pivotX = pageWidth * ((<span class=\"hljs-number\">1</span> - position) * DEFAULT_CENTER)\n            &#125;\n        &#125; <span class=\"hljs-keyword\">else</span> &#123;\n            view.pivotX = <span class=\"hljs-number\">0f</span>\n            view.scaleX = mMinScale\n            view.scaleY = mMinScale\n        &#125;\n    &#125;\n\n    <span class=\"hljs-keyword\">companion</span> <span class=\"hljs-keyword\">object</span> &#123;\n\n        <span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">val</span> DEFAULT_MIN_SCALE = <span class=\"hljs-number\">0.85f</span>\n        <span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">val</span> DEFAULT_CENTER = <span class=\"hljs-number\">0.5f</span>\n    &#125;\n&#125;</code></pre>\n<h3 id=\"4-ViewPager2的一屏多页效果\"><a href=\"#4-ViewPager2的一屏多页效果\" class=\"headerlink\" title=\"4.ViewPager2的一屏多页效果\"></a>4.ViewPager2的一屏多页效果</h3><p>在ViewPager2的官方Sample上看到了ViewPager2的一屏多页可以通过为RecyclerView设置Padding来实现。代码如下：</p>\n<pre><code class=\"hljs kotlin\">\nviewPager2.apply &#123; \n            offscreenPageLimit=<span class=\"hljs-number\">1</span>\n           <span class=\"hljs-keyword\">val</span> recyclerView= getChildAt(<span class=\"hljs-number\">0</span>) <span class=\"hljs-keyword\">as</span> RecyclerView\n            recyclerView.apply &#123;\n                <span class=\"hljs-keyword\">val</span> padding = resources.getDimensionPixelOffset(R.dimen.dp_10) +\n                        resources.getDimensionPixelOffset(R.dimen.dp_10)\n                <span class=\"hljs-comment\">// setting padding on inner RecyclerView puts overscroll effect in the right place</span>\n                setPadding(padding, <span class=\"hljs-number\">0</span>, padding, <span class=\"hljs-number\">0</span>)\n                clipToPadding = <span class=\"hljs-literal\">false</span>\n            &#125;\n        &#125;\n<span class=\"hljs-keyword\">val</span> compositePageTransformer = CompositePageTransformer()\ncompositePageTransformer.addTransformer(ScaleInTransformer())\ncompositePageTransformer.addTransformer(MarginPageTransformer(resources.getDimension(R.dimen.dp_10).toInt()))\nviewPager2.setPageTransformer(compositePageTransformer)\n</code></pre>\n<p>最后，我们来看下效果<br><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi8xNC8xNmYwM2JhZjJmNGZmYTgw?x-oss-process=image/format,png\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"四、ViewPager2与Fragment\"><a href=\"#四、ViewPager2与Fragment\" class=\"headerlink\" title=\"四、ViewPager2与Fragment\"></a>四、ViewPager2与Fragment</h2><p>我们前面也已经提到了ViewPager2中新增的FragmentStateAdapter 替代了ViewPager的FragmentStatePagerAdapter。那么来我们就用ViewPager2来实现一个Activity中嵌套Fragment的实例。</p>\n<h3 id=\"1-Activity的layout中添加ViewPager2\"><a href=\"#1-Activity的layout中添加ViewPager2\" class=\"headerlink\" title=\"1.Activity的layout中添加ViewPager2\"></a>1.Activity的layout中添加ViewPager2</h3><pre><code class=\"hljs kotlin\">&lt;androidx.viewpager2.widget.ViewPager2\n           android:id=<span class=\"hljs-string\">&quot;@+id/vp_fragment&quot;</span>\n           android:layout_width=<span class=\"hljs-string\">&quot;match_parent&quot;</span>\n           android:layout_height=<span class=\"hljs-string\">&quot;match_parent&quot;</span>\n           android:layout_above=<span class=\"hljs-string\">&quot;@id/rg_tab&quot;</span> /&gt;</code></pre>\n<h3 id=\"2-实现FragmentStateAdapter\"><a href=\"#2-实现FragmentStateAdapter\" class=\"headerlink\" title=\"2.实现FragmentStateAdapter\"></a>2.实现FragmentStateAdapter</h3><pre><code class=\"hljs kotlin\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">AdapterFragmentPager</span></span>(fragmentActivity: FragmentActivity) : FragmentStateAdapter(fragmentActivity) &#123;\n\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">val</span> fragments: SparseArray&lt;BaseFragment&gt; = SparseArray()\n\n    <span class=\"hljs-keyword\">init</span> &#123;\n        fragments.put(PAGE_HOME, HomeFragment.getInstance())\n        fragments.put(PAGE_FIND, PageFragment.getInstance())\n        fragments.put(PAGE_INDICATOR, IndicatorFragment.getInstance())\n        fragments.put(PAGE_OTHERS, OthersFragment.getInstance())\n    &#125;\n\n    <span class=\"hljs-keyword\">override</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">createFragment</span><span class=\"hljs-params\">(position: <span class=\"hljs-type\">Int</span>)</span></span>: Fragment &#123;\n        <span class=\"hljs-keyword\">var</span> fragment: Fragment\n        <span class=\"hljs-keyword\">when</span> (position) &#123;\n            PAGE_HOME -&gt; &#123;\n                <span class=\"hljs-keyword\">if</span> (fragments.<span class=\"hljs-keyword\">get</span>(PAGE_HOME) == <span class=\"hljs-literal\">null</span>) &#123;\n                    fragment = HomeFragment.getInstance();\n                    fragments.put(PAGE_HOME, fragment)\n                &#125; <span class=\"hljs-keyword\">else</span> &#123;\n                    fragment = fragments.<span class=\"hljs-keyword\">get</span>(PAGE_HOME)\n                &#125;\n            &#125;\n            PAGE_FIND -&gt; &#123;\n                <span class=\"hljs-keyword\">if</span> (fragments.<span class=\"hljs-keyword\">get</span>(PAGE_FIND) == <span class=\"hljs-literal\">null</span>) &#123;\n                    fragment = PageFragment.getInstance();\n                    fragments.put(PAGE_FIND, fragment)\n                &#125; <span class=\"hljs-keyword\">else</span> &#123;\n                    fragment = fragments.<span class=\"hljs-keyword\">get</span>(PAGE_FIND)\n                &#125;\n            &#125;\n\n            PAGE_INDICATOR -&gt; &#123;\n                <span class=\"hljs-keyword\">if</span> (fragments.<span class=\"hljs-keyword\">get</span>(PAGE_INDICATOR) == <span class=\"hljs-literal\">null</span>) &#123;\n                    fragment = IndicatorFragment.getInstance();\n                    fragments.put(PAGE_INDICATOR, fragment)\n                &#125; <span class=\"hljs-keyword\">else</span> &#123;\n                    fragment = fragments.<span class=\"hljs-keyword\">get</span>(PAGE_INDICATOR)\n                &#125;\n            &#125;\n\n            PAGE_OTHERS -&gt; &#123;\n                <span class=\"hljs-keyword\">if</span> (fragments.<span class=\"hljs-keyword\">get</span>(PAGE_OTHERS) == <span class=\"hljs-literal\">null</span>) &#123;\n                    fragment = OthersFragment.getInstance();\n                    fragments.put(PAGE_OTHERS, fragment)\n                &#125; <span class=\"hljs-keyword\">else</span> &#123;\n                    fragment = fragments.<span class=\"hljs-keyword\">get</span>(PAGE_OTHERS)\n                &#125;\n            &#125;\n            <span class=\"hljs-keyword\">else</span> -&gt; &#123;\n                <span class=\"hljs-keyword\">if</span> (fragments.<span class=\"hljs-keyword\">get</span>(PAGE_HOME) == <span class=\"hljs-literal\">null</span>) &#123;\n                    fragment = HomeFragment.getInstance();\n                    fragments.put(PAGE_HOME, fragment)\n                &#125; <span class=\"hljs-keyword\">else</span> &#123;\n                    fragment = fragments.<span class=\"hljs-keyword\">get</span>(PAGE_HOME)\n                &#125;\n            &#125;\n        &#125;\n        <span class=\"hljs-keyword\">return</span> fragment\n    &#125;\n\n    <span class=\"hljs-keyword\">override</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">getItemCount</span><span class=\"hljs-params\">()</span></span>: <span class=\"hljs-built_in\">Int</span> &#123;\n        <span class=\"hljs-keyword\">return</span> fragments.size()\n    &#125;\n\n    <span class=\"hljs-keyword\">companion</span> <span class=\"hljs-keyword\">object</span> &#123;\n\n        <span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">val</span> PAGE_HOME = <span class=\"hljs-number\">0</span>\n\n        <span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">val</span> PAGE_FIND = <span class=\"hljs-number\">1</span>\n\n        <span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">val</span> PAGE_INDICATOR = <span class=\"hljs-number\">2</span>\n\n        <span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">val</span> PAGE_OTHERS = <span class=\"hljs-number\">3</span>\n\n    &#125;\n\n&#125;</code></pre>\n<h3 id=\"3-在Activity中为ViewPager2设置FragmentStateAdapter\"><a href=\"#3-在Activity中为ViewPager2设置FragmentStateAdapter\" class=\"headerlink\" title=\"3.在Activity中为ViewPager2设置FragmentStateAdapter\"></a>3.在Activity中为ViewPager2设置FragmentStateAdapter</h3><pre><code class=\"hljs kotlin\">vp_fragment.adapter = AdapterFragmentPager(<span class=\"hljs-keyword\">this</span>)\n       vp_fragment.offscreenPageLimit = <span class=\"hljs-number\">3</span>\n       vp_fragment.isUserInputEnabled=<span class=\"hljs-literal\">false</span></code></pre>\n<h2 id=\"五、ViewPager2与TabLayout\"><a href=\"#五、ViewPager2与TabLayout\" class=\"headerlink\" title=\"五、ViewPager2与TabLayout\"></a>五、ViewPager2与TabLayout</h2><p>TabLayout也是项目中经常用到的一个控件，它通常会与ViewPager一起出现。那么对于ViewPager2应该怎么使用Tablayout呢？这需要我们认识一个新类TabLayoutMediator，这个类是在material-1.2.0中新增的一个类，目前material包的最新版本是1.2.0-alpha03，因此需要我们单独引入这个包，依赖如下：</p>\n<pre><code class=\"hljs kotlin\">implementation <span class=\"hljs-string\">&#x27;com.google.android.material:material:1.2.0-alpha03&#x27;</span></code></pre>\n<p>TabLayoutMediator的构造方法接收三个参数，第一个参数为TabLayout；第二个参数为ViewPager2；第三个参数是TabConfigurationStrategy，这是一个接口，该接口中有一个方法onConfigureTab(@NonNull TabLayout.Tab tab, int position),第一个参数是当前Tab,第二个当前position，源码如下：</p>\n<pre><code class=\"hljs kotlin\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">TabConfigurationStrategy</span> </span>&#123;\n  <span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">   * Called to configure the tab for the page at the specified position. Typically calls &#123;<span class=\"hljs-doctag\">@link</span></span>\n<span class=\"hljs-comment\">   * TabLayout.Tab#setText(CharSequence)&#125;, but any form of styling can be applied.</span>\n<span class=\"hljs-comment\">   *</span>\n<span class=\"hljs-comment\">   * <span class=\"hljs-doctag\">@param</span> tab The Tab which should be configured to represent the title of the item at the given</span>\n<span class=\"hljs-comment\">   *     position in the data set.</span>\n<span class=\"hljs-comment\">   * <span class=\"hljs-doctag\">@param</span> position The position of the item within the adapter&#x27;s data set.</span>\n<span class=\"hljs-comment\">   */</span>\n  void onConfigureTab(<span class=\"hljs-meta\">@NonNull</span> TabLayout.Tab tab, int position);\n&#125;</code></pre>\n<p> 接下来我们便可以通过TabLayoutMediator将TabLayout与ViewPager2关联起来了： </p>\n<pre><code class=\"hljs kotlin\">TabLayoutMediator(tab_layout, view_pager) &#123; tab, position -&gt;\n            <span class=\"hljs-comment\">//  为Tab设置Text</span>\n            tab.text = Card.DECK[position].toString()\n        &#125;.attach()</code></pre>\n<p>使用起来非常简单，实现效果如下图所示：</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC8xLzEzLzE2ZjllZTk3OTMyYWU1Njk?x-oss-process=image/format,png\"></p>\n<h2 id=\"六、小结\"><a href=\"#六、小结\" class=\"headerlink\" title=\"六、小结\"></a>六、小结</h2><p>本篇文章我们认识了ViewPager2的新特性以及其用法。总得来说ViewPager2相比ViewPager不管在性能上还是在功能上都有了很大的提升。因此，我相信在不久的未来ViewPager2必定会取代ViewPager。那么，你是否已经考虑将ViewPager2用到你的项目中了呢？</p>\n<p>最后再来给大家推荐一下<a href=\"https://github.com/zhpanvip/BannerViewPager\">BannerViewPager</a>。这是一个基于ViewPager实现的具有强大功能的无限轮播库。在未来，我会在BannerViewPager 3.0版本中用ViewPager2来重构代码。欢迎大家到GitHub关注<a href=\"https://github.com/zhpanvip/BannerViewPager\">BannerViewPager</a> 。</p>\n<p><a href=\"https://download.csdn.net/download/qq_20521573/12032894\">本文涉及源码下载</a></p>\n<p>第四节中ViewPager2与Fragment的代码见：</p>\n<p><a href=\"https://github.com/zhpanvip/BannerViewPager\">BannerViewPager</a> </p>\n","site":{"data":{"fluid_config":{"favicon":"/img/favicon.png","apple_touch_icon":"/img/favicon.png","title_join_string":" - ","force_https":false,"highlight":{"enable":true,"style":"Github Gist","bg_color":false,"copy_btn":true},"fun_features":{"typing":{"enable":true,"typeSpeed":70,"cursorChar":"|","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"mouse_click":{"enable":false,"style":"values"}},"dark_mode":{"enable":true,"default":"auto"},"color":{"body_bg_color":"#eee","body_bg_color_dark":"#181c27","navbar_bg_color":"#2f4154","navbar_bg_color_dark":"#1f3144","navbar_text_color":"#fff","navbar_text_color_dark":"#d0d0d0","text_color":"#3c4858","text_color_dark":"#c4c6c9","sec_text_color":"#718096","sec_text_color_dark":"#a7a9ad","post_text_color":"#2c3e50","post_text_color_dark":"#c4c6c9","post_heading_color":"#1a202c","post_heading_color_dark":"#c4c6c9","post_link_color":"#0366d6","post_link_color_dark":"#1589e9","link_hover_color":"#30a9de","link_hover_color_dark":"#30a9de","link_hover_bg_color":"#f8f9fa","link_hover_bg_color_dark":"#364151","board_color":"#fff","board_color_dark":"#252d38"},"font":{"font_size":"16px","font_family":null,"code_font_size":"85%"},"custom_js":null,"custom_css":null,"custom_html":"","web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"tajs":null,"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}},"lazyload":{"enable":true,"onlypost":false},"daovoice":{"enable":false,"appid":""},"aplayer":{"enable":false,"autoplay":false,"loop":"all","order":"random","theme":"#b7daff","songs":[{"name":"name","artist":"artist","url":"/songs/test.mp3","cover":"/img/cover.jpg"},{"name":"name","artist":"artist","url":"https://...url.mp3","cover":"https://...cover.jpg"}]},"version":{"check":false},"navbar":{"blog_title":"zhangpan","ground_glass":{"enable":false,"px":3,"alpha":0.7},"menu":[{"key":"home","link":"/","icon":"iconfont icon-home-fill"},{"key":"archive","link":"/archives/","icon":"iconfont icon-archive-fill"},{"key":"category","link":"/categories/","icon":"iconfont icon-category-fill"},{"key":"tag","link":"/tags/","icon":"iconfont icon-tags-fill"},{"key":"about","link":"/about/","icon":"iconfont icon-user-fill"}]},"search":{"enable":true,"path":"/local-search.xml","generate_path":"/local-search.xml","field":"post","content":true},"scroll_down_arrow":{"enable":true,"banner_height_limit":90,"scroll_after_turning_page":true},"banner_parallax":true,"footer":{"statistics":{"enable":false,"source":"busuanzi","pv_format":"总访问量 {} 次","uv_format":"总访客数 {} 人"},"beian":{"enable":false,"icp_text":"京ICP证123456号","police_text":"京公网安备12345678号","police_code":12345678,"police_icon":"/img/police_beian.png"}},"scroll_top_arrow":{"enable":true},"index":{"banner_img":"/img/default.png","banner_img_height":100,"banner_mask_alpha":0.3,"post_default_img":"","slogan":{"enable":true,"text":"Talk is cheap, show me the code."},"auto_excerpt":{"enable":true},"post_url_target":"_self","post_meta":{"date":true,"category":true,"tag":true}},"page":{"banner_img":"/img/default.png","banner_img_height":60,"banner_mask_alpha":0.3},"post":{"banner_img":"/img/default.png","banner_img_height":70,"banner_mask_alpha":0.3,"meta":{"date":{"enable":true,"format":"LL a"},"wordcount":{"enable":true,"format":"{} 字"},"min2read":{"enable":true,"format":"{} 分钟","words":100},"views":{"enable":false,"source":"busuanzi","format":"{} 次"}},"updated":{"enable":false,"content":"本文最后更新于：","relative":false},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"copyright":{"enable":true,"content":"本博客所有文章除特别声明外，均采用 <a href=\"https://creativecommons.org/licenses/by-sa/4.0/deed.zh\" rel=\"nofollow noopener\">CC BY-SA 4.0 协议</a> ，转载请注明出处！ <h5>开源库推荐</h5> <a href=\"https://github.com/zhpanvip/BannerViewPager\">1.BannerViewPager</a> <p> 一个基于ViewPager2实现的具有强大功能的无限轮播库。支持多种页面切换效果和指示器样式。 </p>\n<a href=\"https://github.com/zhpanvip/viewpagerindicator\">2.ViewPagerIndicator</a> <p> 一个适用于ViewPager和ViewPager2的指示器，支持多种滑块样式及滑动模式 </p>"},"prev_next":{"enable":true},"custom":{"enable":false,"content":"<img src=\"https://octodex.github.com/images/jetpacktocat.png\" class=\"rounded mx-auto d-block mt-5\" style=\"width:150px; height:150px;\">"},"image_zoom":{"enable":true},"footnote":{"enable":true,"header":""},"math":{"enable":false,"specific":false,"engine":"mathjax"},"mermaid":{"enable":false,"specific":false,"options":{"theme":"default"}},"comments":{"enable":true,"type":"utterances"}},"utterances":{"repo":"zhpanvip/utterances-comment","issue_term":"pathname","label":"utterances","theme":"github-light","crossorigin":"anonymous"},"disqus":{"shortname":null,"disqusjs":false,"apikey":null},"gitalk":{"clientID":null,"clientSecret":null,"repo":null,"owner":null,"admin":["name"],"id":"location.pathname","language":"zh-CN","labels":["Gitalk"],"perPage":10,"pagerDirection":"last","distractionFreeMode":false,"createIssueManually":true},"valine":{"appid":"hXIROaIM5y9qnieojJRWP5hS","appkey":"y0f3w3aqd1MF7JL9ma4WECTy","placeholder":"说点什么","path":"window.location.pathname","avatar":"retro","meta":["nick","mail","link"],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"https://zhangpan.site"},"changyan":{"appid":"","appkey":""},"livere":{"uid":""},"archive":{"banner_img":"/img/bg_article.jpg","banner_img_height":60,"banner_mask_alpha":0.3,"subtitle":null},"category":{"banner_img":"/img/bg_default.png","banner_img_height":60,"banner_mask_alpha":0.3,"subtitle":null,"post_limit":10,"order_by":"-length"},"tag":{"banner_img":"/img/bg_label.jpg","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null,"tagcloud":{"min_font":15,"max_font":30,"unit":"px","start_color":"#BBBBEE","end_color":"#337ab7"}},"about":{"banner_img":"/img/bg_default.png","banner_img_height":60,"banner_mask_alpha":0.3,"subtitle":null,"avatar":"/img/avatar.png","name":"myname","introduce":"一句简短的介绍","icons":[{"class":"iconfont icon-github-fill","link":"https://github.com","tip":"GitHub"},{"class":"iconfont icon-douban-fill","link":"https://douban.com","tip":"豆瓣"},{"class":"iconfont icon-wechat-fill","qrcode":"/img/favicon.png"}]},"page404":{"banner_img":"/img/default.png","banner_img_height":85,"banner_mask_alpha":0.3,"subtitle":"Page not found"},"links":{"banner_img":"/img/default.png","banner_img_height":60,"banner_mask_alpha":0.3,"subtitle":null,"items":[{"title":"Fluid Docs","intro":"主题使用指南","link":"https://hexo.fluid-dev.com/docs/","image":"/img/favicon.png"},{"title":"Fluid Repo","intro":"主题 GitHub 仓库","link":"https://github.com/fluid-dev/hexo-theme-fluid","image":"/img/favicon.png"},{"title":"Fluid Example","intro":"主题操作示例","link":"https://hexo.fluid-dev.com/docs/example/","image":"/img/favicon.png"}]}}}},"excerpt":"","more":"<p>就在上个月20号(2019年11月20号)，期待已久的ViewPager2 正式版终于发布了！不知道你是否已经蠢蠢欲动着手用ViewPager2去改造你项目的ViewPager了？什么？你还不知道ViewPager2？那么请你马上系好安全带，本篇文章将带你一览ViewPager2的风采。</p>\n<h2 id=\"一、ViewPager2的新特性\"><a href=\"#一、ViewPager2的新特性\" class=\"headerlink\" title=\"一、ViewPager2的新特性\"></a>一、ViewPager2的新特性</h2><p>ViewPager2从名字就可以看出来它是ViewPager的升级版，既然是升级版那么它相比ViewPager有哪些新功能和哪些API变化呢？我们接着往下看。</p>\n<h3 id=\"1-ViewPager2新特性\"><a href=\"#1-ViewPager2新特性\" class=\"headerlink\" title=\"1.ViewPager2新特性\"></a>1.ViewPager2新特性</h3><ul>\n<li>基于RecyclerView实现。这意味着RecyclerView的优点将会被ViewPager2所继承。</li>\n<li>支持竖直滑动。只需要一个参数就可以改变滑动方向。</li>\n<li>支持关闭用户输入。通过setUserInputEnabled来设置是否禁止用户滑动页面。</li>\n<li>支持通过编程方式滚动。通过fakeDragBy(offsetPx)代码模拟用户滑动页面。</li>\n<li>CompositePageTransformer 支持同时添加多个PageTransformer。</li>\n<li>支持DiffUtil ，可以添加数据集合改变的item动画。</li>\n<li>支持RTL (right-to-left)布局。我觉得这个功能对国内开发者来说可能用处不大..</li>\n</ul>\n<h3 id=\"2-相比ViewPager变化的API\"><a href=\"#2-相比ViewPager变化的API\" class=\"headerlink\" title=\"2.相比ViewPager变化的API\"></a>2.相比ViewPager变化的API</h3><p>ViewPager2相比ViewPager做了哪些改变呢？研究了一番之后我大概列出以下几点：</p>\n<ul>\n<li>ViewPager2与ViewPager同是继承自ViewGrop，但是ViewPager2被声明成了final。意味着我们不可能再像ViewPager一样通过继承来修改ViewPager2的代码。</li>\n<li>FragmentStatePagerAdapter被FragmentStateAdapter 替代</li>\n<li>PagerAdapter被RecyclerView.Adapter替代</li>\n<li>addPageChangeListener被registerOnPageChangeCallback。我们知道ViewPager的addPageChangeListener接收的是一个OnPageChangeListener的接口，而这个接口中有三个方法，当想要监听页面变化时需要重写这三个方法。而ViewPager2的registerOnPageChangeCallback方法接收的是一个叫OnPageChangeCallback的抽象类，因此我们可以选择性的重写需要的方法即可。</li>\n<li>移除了setPargeMargin方法。</li>\n</ul>\n<p>以上所罗列的新特性和API可能并不完整，如有疏漏可以留言补充。</p>\n<h2 id=\"二、开启ViewPager2之旅\"><a href=\"#二、开启ViewPager2之旅\" class=\"headerlink\" title=\"二、开启ViewPager2之旅\"></a>二、开启ViewPager2之旅</h2><p>ViewPager2位于androidx包下，也就是它不像ViewPager一样被内置在系统源码中。因此，使用ViewPager2需要额外的添加依赖库。另外，android support中不包含ViewPager，也就是要使用ViewPager2必须迁移到androidx才可以。</p>\n<h3 id=\"1-添加依赖，目前ViewPager2的最新版本是1-0-0：\"><a href=\"#1-添加依赖，目前ViewPager2的最新版本是1-0-0：\" class=\"headerlink\" title=\"1.添加依赖，目前ViewPager2的最新版本是1.0.0：\"></a>1.添加依赖，目前ViewPager2的最新版本是1.0.0：</h3><pre><code class=\"hljs java\">dependencies &#123;\n    implementation <span class=\"hljs-string\">&quot;androidx.viewpager2:viewpager2:1.0.0&quot;</span>\n&#125;</code></pre>\n<h3 id=\"2-ViewPager2布局文件：\"><a href=\"#2-ViewPager2布局文件：\" class=\"headerlink\" title=\"2.ViewPager2布局文件：\"></a>2.ViewPager2布局文件：</h3><pre><code class=\"hljs java\">&lt;androidx.viewpager2.widget.ViewPager2\n       android:id=<span class=\"hljs-string\">&quot;@+id/view_pager&quot;</span>\n       android:layout_width=<span class=\"hljs-string\">&quot;match_parent&quot;</span>\n       android:layout_height=<span class=\"hljs-string\">&quot;match_parent&quot;</span>\n       app:layout_constraintBottom_toBottomOf=<span class=\"hljs-string\">&quot;parent&quot;</span>\n       app:layout_constraintLeft_toLeftOf=<span class=\"hljs-string\">&quot;parent&quot;</span>\n       app:layout_constraintRight_toRightOf=<span class=\"hljs-string\">&quot;parent&quot;</span>\n       app:layout_constraintTop_toTopOf=<span class=\"hljs-string\">&quot;parent&quot;</span> /&gt;</code></pre>\n<h3 id=\"3-ViewPager2的Adapter\"><a href=\"#3-ViewPager2的Adapter\" class=\"headerlink\" title=\"3.ViewPager2的Adapter\"></a>3.ViewPager2的Adapter</h3><p>因为ViewPager2内部封装的是RecyclerView，因此它的Adapter也就是RecyclerView的Adapter。</p>\n<pre><code class=\"hljs kotlin\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MyAdapter</span> : <span class=\"hljs-type\">RecyclerView.Adapter</span>&lt;<span class=\"hljs-type\">MyAdapter.PagerViewHolder</span>&gt;</span>() &#123;\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">var</span> mList: List&lt;<span class=\"hljs-built_in\">Int</span>&gt; = ArrayList()\n    <span class=\"hljs-keyword\">override</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">onCreateViewHolder</span><span class=\"hljs-params\">(parent: <span class=\"hljs-type\">ViewGroup</span>, viewType: <span class=\"hljs-type\">Int</span>)</span></span>: PagerViewHolder &#123;\n        <span class=\"hljs-keyword\">val</span> itemView = LayoutInflater.from(parent.context).inflate(R.layout.item_page, parent, <span class=\"hljs-literal\">false</span>)\n        <span class=\"hljs-keyword\">return</span> PagerViewHolder(itemView)\n    &#125;\n\n    <span class=\"hljs-keyword\">override</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">onBindViewHolder</span><span class=\"hljs-params\">(holder: <span class=\"hljs-type\">PagerViewHolder</span>, position: <span class=\"hljs-type\">Int</span>)</span></span> &#123;\n        holder.bindData(mList[position])\n    &#125;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">setList</span><span class=\"hljs-params\">(list: <span class=\"hljs-type\">List</span>&lt;<span class=\"hljs-type\">Int</span>&gt;)</span></span> &#123;\n        mList = list\n    &#125;\n\n    <span class=\"hljs-keyword\">override</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">getItemCount</span><span class=\"hljs-params\">()</span></span>: <span class=\"hljs-built_in\">Int</span> &#123;\n        <span class=\"hljs-keyword\">return</span> mList.size\n    &#125;\n\t<span class=\"hljs-comment\">//\tViewHolder需要继承RecycleView.ViewHolder</span>\n    <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">PagerViewHolder</span></span>(itemView: View) : RecyclerView.ViewHolder(itemView) &#123;\n        <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">val</span> mTextView: TextView = itemView.findViewById(R.id.tv_text)\n        <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">var</span> colors = arrayOf(<span class=\"hljs-string\">&quot;#CCFF99&quot;</span>,<span class=\"hljs-string\">&quot;#41F1E5&quot;</span>,<span class=\"hljs-string\">&quot;#8D41F1&quot;</span>,<span class=\"hljs-string\">&quot;#FF99CC&quot;</span>)\n\n        <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">bindData</span><span class=\"hljs-params\">(i: <span class=\"hljs-type\">Int</span>)</span></span> &#123;\n            mTextView.text = i.toString()\n            mTextView.setBackgroundColor(Color.parseColor(colors[i]))\n        &#125;\n    &#125;\n&#125;</code></pre>\n<p>item_page中代码如下：</p>\n<pre><code class=\"hljs kotlin\">&lt;LinearLayout xmlns:android=<span class=\"hljs-string\">&quot;http://schemas.android.com/apk/res/android&quot;</span>\n    android:layout_width=<span class=\"hljs-string\">&quot;match_parent&quot;</span>\n    android:layout_height=<span class=\"hljs-string\">&quot;match_parent&quot;</span>\n    android:gravity=<span class=\"hljs-string\">&quot;center&quot;</span>&gt;\n\n    &lt;TextView\n        android:id=<span class=\"hljs-string\">&quot;@+id/tv_text&quot;</span>\n        android:background=<span class=\"hljs-string\">&quot;@color/colorPrimaryDark&quot;</span>\n        android:layout_width=<span class=\"hljs-string\">&quot;match_parent&quot;</span>\n        android:layout_height=<span class=\"hljs-string\">&quot;280dp&quot;</span>\n        android:gravity=<span class=\"hljs-string\">&quot;center&quot;</span>\n        android:textColor=<span class=\"hljs-string\">&quot;#ffffff&quot;</span>\n        android:textSize=<span class=\"hljs-string\">&quot;22sp&quot;</span> /&gt;\n&lt;/LinearLayout&gt;</code></pre>\n<h3 id=\"4-在Activity中为ViewPager设置Adapter：\"><a href=\"#4-在Activity中为ViewPager设置Adapter：\" class=\"headerlink\" title=\"4.在Activity中为ViewPager设置Adapter：\"></a>4.在Activity中为ViewPager设置Adapter：</h3><pre><code class=\"hljs kotlin\"><span class=\"hljs-keyword\">val</span> viewPager2 = findViewById&lt;ViewPager2&gt;(R.id.view_pager)\n      <span class=\"hljs-keyword\">val</span> myAdapter = MyAdapter()\n      myAdapter.setList(<span class=\"hljs-keyword\">data</span>)\n      viewPager2.adapter = myAdapter</code></pre>\n\n<p>很简单就完成了一个ViewPager的功能，来看下效果怎么样：<br><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi8xNC8xNmYwM2JhZjJkMDAzYzli?x-oss-process=image/format,png\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"5-ViewPager2竖直滑动\"><a href=\"#5-ViewPager2竖直滑动\" class=\"headerlink\" title=\"5.ViewPager2竖直滑动\"></a>5.ViewPager2竖直滑动</h3><p>接下来我们通过一行代码为其设置竖直滑动</p>\n<pre><code class=\"hljs kotlin\">viewPager2.orientation = ViewPager2.ORIENTATION_VERTICAL</code></pre>\n<p>竖直滑动用ViewPager是很难实现的，而通过ViewPager2只需要设置一个参数即可。来看下效果：<br><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi8xNC8xNmYwM2JhZjJjZTdiNTI4?x-oss-process=image/format,png\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"6-页面滑动事件监听\"><a href=\"#6-页面滑动事件监听\" class=\"headerlink\" title=\"6.页面滑动事件监听\"></a>6.页面滑动事件监听</h3><p>上文已经提到过了，我们为ViewPager设置页面滑动的监听事件需要重写三个方法，而为ViewPager2设置监听事件只需要重写需要的方法即可，因为ViewPager2中OnPageChangeCallback是一个抽象类。</p>\n<pre><code class=\"hljs kotlin\">viewPager2.registerOnPageChangeCallback(<span class=\"hljs-keyword\">object</span> : ViewPager2.OnPageChangeCallback() &#123;\n            <span class=\"hljs-keyword\">override</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">onPageSelected</span><span class=\"hljs-params\">(position: <span class=\"hljs-type\">Int</span>)</span></span> &#123;\n                <span class=\"hljs-keyword\">super</span>.onPageSelected(position)\n                Toast.makeText(<span class=\"hljs-keyword\">this</span><span class=\"hljs-symbol\">@MainActivity</span>, <span class=\"hljs-string\">&quot;page selected <span class=\"hljs-variable\">$position</span>&quot;</span>, Toast.LENGTH_SHORT).show()\n            &#125;\n        &#125;)</code></pre>\n<h3 id=\"7-setUserInputEnabled与fakeDragBy\"><a href=\"#7-setUserInputEnabled与fakeDragBy\" class=\"headerlink\" title=\"7.setUserInputEnabled与fakeDragBy\"></a>7.setUserInputEnabled与fakeDragBy</h3><p>我们知道，在使用ViewPager的时候想要禁止用户滑动需要重写ViewPager的onInterceptTouchEvent。而ViewPager2被声明为了final，我们无法再去继承ViewPager2。那么我们应该怎么禁止ViewPager2的滑动呢？其实在ViewPager2中已经为我们提供了这个功能，只需要通过setUserInputEnabled即可实现。</p>\n<pre><code class=\"hljs kotlin\">viewPager2.isUserInputEnabled = <span class=\"hljs-literal\">false</span></code></pre>\n<p>同时ViewPager2新增了一个fakeDragBy的方法。通过这个方法可以来模拟拖拽。在使用fakeDragBy前需要先beginFakeDrag方法来开启模拟拖拽。fakeDragBy会返回一个boolean值，true表示有fake drag正在执行，而返回false表示当前没有fake drag在执行。我们通过代码来尝试下：</p>\n<pre><code class=\"hljs kotlin\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">fakeDragBy</span><span class=\"hljs-params\">(view: <span class=\"hljs-type\">View</span>)</span></span> &#123;\n        viewPager2.beginFakeDrag()\n        <span class=\"hljs-keyword\">if</span> (viewPager2.fakeDragBy(-<span class=\"hljs-number\">310f</span>))\n            viewPager2.endFakeDrag()\n    &#125;</code></pre>\n<p>需要注意到是fakeDragBy接受一个float的参数，当参数值为正数时表示向前一个页面滑动，当值为负数时表示向下一个页面滑动。<br>下面来看下效果图：<br><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi8xNC8xNmYwM2JhZjJlZmY2ZWY4?x-oss-process=image/format,png\" alt=\"在这里插入图片描述\"><br>演示图中禁止了用户输入，通过按钮点击可以模拟用户滑动。</p>\n<h2 id=\"三、ViewPager2的PageTransformer\"><a href=\"#三、ViewPager2的PageTransformer\" class=\"headerlink\" title=\"三、ViewPager2的PageTransformer\"></a>三、ViewPager2的PageTransformer</h2><p>相比ViewPager，ViewPager2的Transformer功能有了很大的扩展。ViewPager2不仅可以通过PageTransformer用来设置页面动画，还可以用PageTransformer设置页面间距以及同时添加多个PageTransformer。接下来我们就来认识下ViewPager2的PageTransformer吧！</p>\n<h3 id=\"1-setPageMargin\"><a href=\"#1-setPageMargin\" class=\"headerlink\" title=\"1.setPageMargin\"></a>1.setPageMargin</h3><p>在第一章中我们提到了ViewPager2移除了setPageMargin方法，那么怎么为ViewPager2设置页面间距呢？其实在ViewPager2中为我们提供了MarginPageTransformer，我们可以通过ViewPager2的setPageTransformer方法来设置页面间距。代码如下：</p>\n<pre><code class=\"hljs kotlin\">viewPager2.setPageTransformer(MarginPageTransformer(resources.getDimension(R.dimen.dp_10).toInt()))</code></pre>\n<p>上述代码我们为ViewPager2设置了10dp的页面间距。效果如下：<br><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi8xNC8xNmYwM2JhZjJkMmQzODkw?x-oss-process=image/format,png\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"2-认识CompositePageTransformer\"><a href=\"#2-认识CompositePageTransformer\" class=\"headerlink\" title=\"2.认识CompositePageTransformer\"></a>2.认识CompositePageTransformer</h3><p>这个时候我们应该有个疑问，为ViewPager2设置了页面间距后如果还想设置页面动画的Transformer怎么办呢？这时候就该CompositePageTransformer出场了。从名字上也可以看出来它是一个组合的PageTransformer。没错，CompositePageTransformer实现了PageTransformer接口，同时在其内部维护了一个List集合，我们可以将多个PageTransformer添加到CompositePageTransformer中。</p>\n<pre><code class=\"hljs kotlin\"><span class=\"hljs-keyword\">val</span> compositePageTransformer = CompositePageTransformer()\n       compositePageTransformer.addTransformer(ScaleInTransformer())\n       compositePageTransformer.addTransformer(MarginPageTransformer(resources.getDimension(R.dimen.dp_10).toInt()))\n       viewPager2.setPageTransformer(compositePageTransformer)</code></pre>\n<p>上述代码中我们通过CompositePageTransformer为ViewPager设置了MarginPageTransformer和一个页面缩放的ScaleInTransformer。来看下效果：<br><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi8xNC8xNmYwM2JhZjJmNGQ0MzA1?x-oss-process=image/format,png\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"3-ViewPager2中的PageTransformer\"><a href=\"#3-ViewPager2中的PageTransformer\" class=\"headerlink\" title=\"3.ViewPager2中的PageTransformer\"></a>3.ViewPager2中的PageTransformer</h3><p>PageTransformer是一个位于ViewPager2中的接口，因此ViewPager2的PageTransformer是独立于ViewPager的，它与ViewPager的PageTransformer没有任何关系。虽然如此，却不必担心。因为ViewPager2的PageTransformer和ViewPager的PageTransformer实现方式一模一样。我们看下上一小节中用到的ScaleInTransformer：</p>\n<pre><code class=\"hljs kotlin\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ScaleInTransformer</span> : <span class=\"hljs-type\">ViewPager2.PageTransformer &#123;</span></span>\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">val</span> mMinScale = DEFAULT_MIN_SCALE\n    <span class=\"hljs-keyword\">override</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">transformPage</span><span class=\"hljs-params\">(view: <span class=\"hljs-type\">View</span>, position: <span class=\"hljs-type\">Float</span>)</span></span> &#123;\n        view.elevation = -abs(position)\n        <span class=\"hljs-keyword\">val</span> pageWidth = view.width\n        <span class=\"hljs-keyword\">val</span> pageHeight = view.height\n\n        view.pivotY = (pageHeight / <span class=\"hljs-number\">2</span>).toFloat()\n        view.pivotX = (pageWidth / <span class=\"hljs-number\">2</span>).toFloat()\n        <span class=\"hljs-keyword\">if</span> (position &lt; -<span class=\"hljs-number\">1</span>) &#123;\n            view.scaleX = mMinScale\n            view.scaleY = mMinScale\n            view.pivotX = pageWidth.toFloat()\n        &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (position &lt;= <span class=\"hljs-number\">1</span>) &#123;\n            <span class=\"hljs-keyword\">if</span> (position &lt; <span class=\"hljs-number\">0</span>) &#123;\n                <span class=\"hljs-keyword\">val</span> scaleFactor = (<span class=\"hljs-number\">1</span> + position) * (<span class=\"hljs-number\">1</span> - mMinScale) + mMinScale\n                view.scaleX = scaleFactor\n                view.scaleY = scaleFactor\n                view.pivotX = pageWidth * (DEFAULT_CENTER + DEFAULT_CENTER * -position)\n            &#125; <span class=\"hljs-keyword\">else</span> &#123;\n                <span class=\"hljs-keyword\">val</span> scaleFactor = (<span class=\"hljs-number\">1</span> - position) * (<span class=\"hljs-number\">1</span> - mMinScale) + mMinScale\n                view.scaleX = scaleFactor\n                view.scaleY = scaleFactor\n                view.pivotX = pageWidth * ((<span class=\"hljs-number\">1</span> - position) * DEFAULT_CENTER)\n            &#125;\n        &#125; <span class=\"hljs-keyword\">else</span> &#123;\n            view.pivotX = <span class=\"hljs-number\">0f</span>\n            view.scaleX = mMinScale\n            view.scaleY = mMinScale\n        &#125;\n    &#125;\n\n    <span class=\"hljs-keyword\">companion</span> <span class=\"hljs-keyword\">object</span> &#123;\n\n        <span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">val</span> DEFAULT_MIN_SCALE = <span class=\"hljs-number\">0.85f</span>\n        <span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">val</span> DEFAULT_CENTER = <span class=\"hljs-number\">0.5f</span>\n    &#125;\n&#125;</code></pre>\n<h3 id=\"4-ViewPager2的一屏多页效果\"><a href=\"#4-ViewPager2的一屏多页效果\" class=\"headerlink\" title=\"4.ViewPager2的一屏多页效果\"></a>4.ViewPager2的一屏多页效果</h3><p>在ViewPager2的官方Sample上看到了ViewPager2的一屏多页可以通过为RecyclerView设置Padding来实现。代码如下：</p>\n<pre><code class=\"hljs kotlin\">\nviewPager2.apply &#123; \n            offscreenPageLimit=<span class=\"hljs-number\">1</span>\n           <span class=\"hljs-keyword\">val</span> recyclerView= getChildAt(<span class=\"hljs-number\">0</span>) <span class=\"hljs-keyword\">as</span> RecyclerView\n            recyclerView.apply &#123;\n                <span class=\"hljs-keyword\">val</span> padding = resources.getDimensionPixelOffset(R.dimen.dp_10) +\n                        resources.getDimensionPixelOffset(R.dimen.dp_10)\n                <span class=\"hljs-comment\">// setting padding on inner RecyclerView puts overscroll effect in the right place</span>\n                setPadding(padding, <span class=\"hljs-number\">0</span>, padding, <span class=\"hljs-number\">0</span>)\n                clipToPadding = <span class=\"hljs-literal\">false</span>\n            &#125;\n        &#125;\n<span class=\"hljs-keyword\">val</span> compositePageTransformer = CompositePageTransformer()\ncompositePageTransformer.addTransformer(ScaleInTransformer())\ncompositePageTransformer.addTransformer(MarginPageTransformer(resources.getDimension(R.dimen.dp_10).toInt()))\nviewPager2.setPageTransformer(compositePageTransformer)\n</code></pre>\n<p>最后，我们来看下效果<br><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi8xNC8xNmYwM2JhZjJmNGZmYTgw?x-oss-process=image/format,png\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"四、ViewPager2与Fragment\"><a href=\"#四、ViewPager2与Fragment\" class=\"headerlink\" title=\"四、ViewPager2与Fragment\"></a>四、ViewPager2与Fragment</h2><p>我们前面也已经提到了ViewPager2中新增的FragmentStateAdapter 替代了ViewPager的FragmentStatePagerAdapter。那么来我们就用ViewPager2来实现一个Activity中嵌套Fragment的实例。</p>\n<h3 id=\"1-Activity的layout中添加ViewPager2\"><a href=\"#1-Activity的layout中添加ViewPager2\" class=\"headerlink\" title=\"1.Activity的layout中添加ViewPager2\"></a>1.Activity的layout中添加ViewPager2</h3><pre><code class=\"hljs kotlin\">&lt;androidx.viewpager2.widget.ViewPager2\n           android:id=<span class=\"hljs-string\">&quot;@+id/vp_fragment&quot;</span>\n           android:layout_width=<span class=\"hljs-string\">&quot;match_parent&quot;</span>\n           android:layout_height=<span class=\"hljs-string\">&quot;match_parent&quot;</span>\n           android:layout_above=<span class=\"hljs-string\">&quot;@id/rg_tab&quot;</span> /&gt;</code></pre>\n<h3 id=\"2-实现FragmentStateAdapter\"><a href=\"#2-实现FragmentStateAdapter\" class=\"headerlink\" title=\"2.实现FragmentStateAdapter\"></a>2.实现FragmentStateAdapter</h3><pre><code class=\"hljs kotlin\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">AdapterFragmentPager</span></span>(fragmentActivity: FragmentActivity) : FragmentStateAdapter(fragmentActivity) &#123;\n\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">val</span> fragments: SparseArray&lt;BaseFragment&gt; = SparseArray()\n\n    <span class=\"hljs-keyword\">init</span> &#123;\n        fragments.put(PAGE_HOME, HomeFragment.getInstance())\n        fragments.put(PAGE_FIND, PageFragment.getInstance())\n        fragments.put(PAGE_INDICATOR, IndicatorFragment.getInstance())\n        fragments.put(PAGE_OTHERS, OthersFragment.getInstance())\n    &#125;\n\n    <span class=\"hljs-keyword\">override</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">createFragment</span><span class=\"hljs-params\">(position: <span class=\"hljs-type\">Int</span>)</span></span>: Fragment &#123;\n        <span class=\"hljs-keyword\">var</span> fragment: Fragment\n        <span class=\"hljs-keyword\">when</span> (position) &#123;\n            PAGE_HOME -&gt; &#123;\n                <span class=\"hljs-keyword\">if</span> (fragments.<span class=\"hljs-keyword\">get</span>(PAGE_HOME) == <span class=\"hljs-literal\">null</span>) &#123;\n                    fragment = HomeFragment.getInstance();\n                    fragments.put(PAGE_HOME, fragment)\n                &#125; <span class=\"hljs-keyword\">else</span> &#123;\n                    fragment = fragments.<span class=\"hljs-keyword\">get</span>(PAGE_HOME)\n                &#125;\n            &#125;\n            PAGE_FIND -&gt; &#123;\n                <span class=\"hljs-keyword\">if</span> (fragments.<span class=\"hljs-keyword\">get</span>(PAGE_FIND) == <span class=\"hljs-literal\">null</span>) &#123;\n                    fragment = PageFragment.getInstance();\n                    fragments.put(PAGE_FIND, fragment)\n                &#125; <span class=\"hljs-keyword\">else</span> &#123;\n                    fragment = fragments.<span class=\"hljs-keyword\">get</span>(PAGE_FIND)\n                &#125;\n            &#125;\n\n            PAGE_INDICATOR -&gt; &#123;\n                <span class=\"hljs-keyword\">if</span> (fragments.<span class=\"hljs-keyword\">get</span>(PAGE_INDICATOR) == <span class=\"hljs-literal\">null</span>) &#123;\n                    fragment = IndicatorFragment.getInstance();\n                    fragments.put(PAGE_INDICATOR, fragment)\n                &#125; <span class=\"hljs-keyword\">else</span> &#123;\n                    fragment = fragments.<span class=\"hljs-keyword\">get</span>(PAGE_INDICATOR)\n                &#125;\n            &#125;\n\n            PAGE_OTHERS -&gt; &#123;\n                <span class=\"hljs-keyword\">if</span> (fragments.<span class=\"hljs-keyword\">get</span>(PAGE_OTHERS) == <span class=\"hljs-literal\">null</span>) &#123;\n                    fragment = OthersFragment.getInstance();\n                    fragments.put(PAGE_OTHERS, fragment)\n                &#125; <span class=\"hljs-keyword\">else</span> &#123;\n                    fragment = fragments.<span class=\"hljs-keyword\">get</span>(PAGE_OTHERS)\n                &#125;\n            &#125;\n            <span class=\"hljs-keyword\">else</span> -&gt; &#123;\n                <span class=\"hljs-keyword\">if</span> (fragments.<span class=\"hljs-keyword\">get</span>(PAGE_HOME) == <span class=\"hljs-literal\">null</span>) &#123;\n                    fragment = HomeFragment.getInstance();\n                    fragments.put(PAGE_HOME, fragment)\n                &#125; <span class=\"hljs-keyword\">else</span> &#123;\n                    fragment = fragments.<span class=\"hljs-keyword\">get</span>(PAGE_HOME)\n                &#125;\n            &#125;\n        &#125;\n        <span class=\"hljs-keyword\">return</span> fragment\n    &#125;\n\n    <span class=\"hljs-keyword\">override</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">getItemCount</span><span class=\"hljs-params\">()</span></span>: <span class=\"hljs-built_in\">Int</span> &#123;\n        <span class=\"hljs-keyword\">return</span> fragments.size()\n    &#125;\n\n    <span class=\"hljs-keyword\">companion</span> <span class=\"hljs-keyword\">object</span> &#123;\n\n        <span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">val</span> PAGE_HOME = <span class=\"hljs-number\">0</span>\n\n        <span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">val</span> PAGE_FIND = <span class=\"hljs-number\">1</span>\n\n        <span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">val</span> PAGE_INDICATOR = <span class=\"hljs-number\">2</span>\n\n        <span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">val</span> PAGE_OTHERS = <span class=\"hljs-number\">3</span>\n\n    &#125;\n\n&#125;</code></pre>\n<h3 id=\"3-在Activity中为ViewPager2设置FragmentStateAdapter\"><a href=\"#3-在Activity中为ViewPager2设置FragmentStateAdapter\" class=\"headerlink\" title=\"3.在Activity中为ViewPager2设置FragmentStateAdapter\"></a>3.在Activity中为ViewPager2设置FragmentStateAdapter</h3><pre><code class=\"hljs kotlin\">vp_fragment.adapter = AdapterFragmentPager(<span class=\"hljs-keyword\">this</span>)\n       vp_fragment.offscreenPageLimit = <span class=\"hljs-number\">3</span>\n       vp_fragment.isUserInputEnabled=<span class=\"hljs-literal\">false</span></code></pre>\n<h2 id=\"五、ViewPager2与TabLayout\"><a href=\"#五、ViewPager2与TabLayout\" class=\"headerlink\" title=\"五、ViewPager2与TabLayout\"></a>五、ViewPager2与TabLayout</h2><p>TabLayout也是项目中经常用到的一个控件，它通常会与ViewPager一起出现。那么对于ViewPager2应该怎么使用Tablayout呢？这需要我们认识一个新类TabLayoutMediator，这个类是在material-1.2.0中新增的一个类，目前material包的最新版本是1.2.0-alpha03，因此需要我们单独引入这个包，依赖如下：</p>\n<pre><code class=\"hljs kotlin\">implementation <span class=\"hljs-string\">&#x27;com.google.android.material:material:1.2.0-alpha03&#x27;</span></code></pre>\n<p>TabLayoutMediator的构造方法接收三个参数，第一个参数为TabLayout；第二个参数为ViewPager2；第三个参数是TabConfigurationStrategy，这是一个接口，该接口中有一个方法onConfigureTab(@NonNull TabLayout.Tab tab, int position),第一个参数是当前Tab,第二个当前position，源码如下：</p>\n<pre><code class=\"hljs kotlin\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">TabConfigurationStrategy</span> </span>&#123;\n  <span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">   * Called to configure the tab for the page at the specified position. Typically calls &#123;<span class=\"hljs-doctag\">@link</span></span>\n<span class=\"hljs-comment\">   * TabLayout.Tab#setText(CharSequence)&#125;, but any form of styling can be applied.</span>\n<span class=\"hljs-comment\">   *</span>\n<span class=\"hljs-comment\">   * <span class=\"hljs-doctag\">@param</span> tab The Tab which should be configured to represent the title of the item at the given</span>\n<span class=\"hljs-comment\">   *     position in the data set.</span>\n<span class=\"hljs-comment\">   * <span class=\"hljs-doctag\">@param</span> position The position of the item within the adapter&#x27;s data set.</span>\n<span class=\"hljs-comment\">   */</span>\n  void onConfigureTab(<span class=\"hljs-meta\">@NonNull</span> TabLayout.Tab tab, int position);\n&#125;</code></pre>\n<p> 接下来我们便可以通过TabLayoutMediator将TabLayout与ViewPager2关联起来了： </p>\n<pre><code class=\"hljs kotlin\">TabLayoutMediator(tab_layout, view_pager) &#123; tab, position -&gt;\n            <span class=\"hljs-comment\">//  为Tab设置Text</span>\n            tab.text = Card.DECK[position].toString()\n        &#125;.attach()</code></pre>\n<p>使用起来非常简单，实现效果如下图所示：</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC8xLzEzLzE2ZjllZTk3OTMyYWU1Njk?x-oss-process=image/format,png\"></p>\n<h2 id=\"六、小结\"><a href=\"#六、小结\" class=\"headerlink\" title=\"六、小结\"></a>六、小结</h2><p>本篇文章我们认识了ViewPager2的新特性以及其用法。总得来说ViewPager2相比ViewPager不管在性能上还是在功能上都有了很大的提升。因此，我相信在不久的未来ViewPager2必定会取代ViewPager。那么，你是否已经考虑将ViewPager2用到你的项目中了呢？</p>\n<p>最后再来给大家推荐一下<a href=\"https://github.com/zhpanvip/BannerViewPager\">BannerViewPager</a>。这是一个基于ViewPager实现的具有强大功能的无限轮播库。在未来，我会在BannerViewPager 3.0版本中用ViewPager2来重构代码。欢迎大家到GitHub关注<a href=\"https://github.com/zhpanvip/BannerViewPager\">BannerViewPager</a> 。</p>\n<p><a href=\"https://download.csdn.net/download/qq_20521573/12032894\">本文涉及源码下载</a></p>\n<p>第四节中ViewPager2与Fragment的代码见：</p>\n<p><a href=\"https://github.com/zhpanvip/BannerViewPager\">BannerViewPager</a> </p>\n"},{"title":"学不动也要学！探究Fragment延迟加载的前世今生","date":"2020-01-02T09:31:50.000Z","_content":"\n上周在[《学不动也要学！深入了解ViewPager2》](https://juejin.im/post/5df4aabe6fb9a0161104c8eb)一篇文章的留言中，大家普遍对于Fragment懒加载的问题比较关心。其实，对于Fragment懒加载问题的处理由来已久，网上不乏相关的优秀文章。但是，由于Fragment生命周期的原因使得懒加载问题的处理并不是那么的优雅。显然，Google也意识到了问题所在。因此，在Androidx的库中对于Fragment的生命周期状态的控制进行了深度优化，使得我们更容易的去管控Fragment的生命周期，也使得我们更容易的去处理懒加载问题。但是，前提条件是我们要了解Google对于Fragment做了哪些优化。那么就让我们借此机会一起来探究一下吧！（ ***懒加载称作延迟加载我觉得更贴切一些，所以下文就统称为延迟加载了。*** ）\n## 一、Fragment延迟加载的前世\n虽然本篇文章是对于Fragment新特性的探究，但是我觉得写文章总要有个因果。也为了照顾一下还不太了解什么是延迟加载的同学。我们还是先来了解一下延迟加载，顺便回顾一下Fragment延迟加载的旧方案。\n### 1.为什么要对Fragment做延迟加载?\n首先，我们要搞清楚一个问题。“Fragment延迟加载“中的“延迟”并不指的是延迟加载Fragment，而是延迟加载Fragment中的数据。对于Fragment的使用通常我们会结合ViewPager。在[《学不动也要学！深入了解ViewPager2》](https://juejin.im/post/5df4aabe6fb9a0161104c8eb)一文中我们也提到ViewPager的预加载问题。ViewPager会默认在当前页面的左右两边至少预加载一个页面以保证ViewPager的流畅性。我们假设在ViewPager的所有Fragment中都存在网络请求。当我们打开这个页面的时候由于ViewPager的预加载原因，即使在其它Fragment不可见的情况下也会去进行网络请求加载数据。而如果此时用户根本就没有去滑动ViewPager就退出了应用或者切换到了其他页面。那么对于这个不可见的Fragment中的网络请求岂不是既浪费了流量也浪费了手机和服务器的性能？\n\n那么此时有的同学就有问题了。你就不能在Fragment显示的时候去加载数据吗?问的好！在解答之前我们先来看下Fragment的生命周期\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi8yOS8xNmY1MGFlMTUwMGM3ZDFk?x-oss-process=image/format,png)\n想必这张图大家应该都非常熟悉了。当Fragment被预加载的时候，此Fragment的生命周期会从onAttach执行到onResume。显然我们无法通过Fragment的生命周期来控制Fragment的延迟加载。那么该怎么办呢？我们且往下看。\n\n### 2.如何处理Fragment的延迟加载？\n通过上一小节的分析我们知道想要在Fragment的生命周期中处理延迟加载的问题显然是走不通的。所以想要处理Fragment的延迟加载就需要另想它法了。还好，在Fragment中为我们提供了一个setUserVisibleHint(isVisibleToUser: Boolean)的方法，这个方法中有一个isVisibleToUser的boolean类型的参数，其意义表示当前的Fragment是否对用户可见。因此，对于Fragment的延迟加载我们便可以通过这个方法来展开。\n既然要使用setUserVisibleHint(isVisibleToUser: Boolean)那么就应该知道这个方法的调用时机。我们写一个ViewPager嵌套Fragment的例子来打印下日志：\n\n![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi8yOS8xNmY1MWE0N2UzMDg1Mzdk?x-oss-process=image/format,png)\n*注：上图打印的日志中”position:0“表示当前Fragment，“position:1”表示预加载的Fragment，下同。*\n\n可见该方法是在Fragment的onAttach之前就已经被调用了。因此，对于延迟加载我们可以在setUserVisibleHint(isVisibleToUser: Boolean)方法及onViewCreated(view: View, savedInstanceState: Bundle?)添加标志位来控制是否加载数据。我们来看下代码：\n\n```kotlin\nabstract class BaseLazyFragment : Fragment() {\n    /**\n     * 当前Fragment状态是否可见\n     */\n    private var isVisibleToUser: Boolean = false\n    /**\n     * 是否已创建View\n     */\n    private var isViewCreated: Boolean = false\n    /**\n     * 是否第一次加载数据\n     */\n    private var isFirstLoad = true\n\n    override fun setUserVisibleHint(isVisibleToUser: Boolean) {\n        super.setUserVisibleHint(isVisibleToUser)\n        this.isVisibleToUser = isVisibleToUser\n        onLazyLoad()\n    }\n\n    private fun onLazyLoad() {\n        if (isVisibleToUser && isViewCreated && isFirstLoad) {\n            isFirstLoad = false\n            lazyLoad()\n        }\n    }\n\n    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n        super.onViewCreated(view, savedInstanceState)\n        isViewCreated = true\n        onLazyLoad()\n    }\n\n    protected abstract fun lazyLoad()\n\n}\n```\n我们通过在Fragment中添加了三个标志位实现了延迟加载的功能。我们到TestFragment尝试一下：\n\n```kotlin\nclass TestFragment : BaseLazyFragment() {\n\n    private var position: Int = 0\n\n    override fun setUserVisibleHint(isVisibleToUser: Boolean) {\n        super.setUserVisibleHint(isVisibleToUser)\n        val bundle = arguments\n        position = bundle!!.getInt(KEY_POSITION)\n    }\n\n    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? {\n        val cardView = CardView(inflater, container)\n        cardView.bind(Card.fromBundle(arguments!!),position)\n        return cardView.view\n    }\n\n    companion object {\n\n        private const val KEY_POSITION = \"position\"\n\n        fun getInstance(card: Card, position: Int): TestFragment {\n            val fragment = TestFragment()\n            val bundle = card.toBundle()\n            bundle.putInt(KEY_POSITION, position)\n            fragment.arguments = bundle\n            return fragment\n        }\n    }\n\n    override fun lazyLoad() {\n        showToast(\"Fragment$position is loading data\")\n    }\n\n    private fun showToast(content: String) {\n        Toast.makeText(context, content, Toast.LENGTH_SHORT).show()\n    }\n\n}\n\n```\n\n我们来看下效果：\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi8yOS8xNmY1MGFlMTUwMjk5Njk2?x-oss-process=image/format,png)\n嗯！立竿见影，只有当Fragment完全显示出来的时候loading data的操作才被执行。这种延迟加载的方案在Androidx 1.1.0版本以前被广泛应用。而在Androidx 1.1.0版本中，Google对于Fragment进行了优化处理，使得延迟加载也有了新的解决方案。\n\n## 二、Fragment的setMaxLifecycle探究\n上一节中我们讲到因为ViewPager的预加载机制以及Fragment的生命周期无法得以控制，我们不得不通过setUserVisibleHint(isVisibleToUser: Boolean)和onViewCreated(view: View, savedInstanceState: Bundle?)方法以及添加三个标志位来处理延迟加载，显然这样的代码并不优雅。\n\n当我们将Android项目迁移到Androidx并将androidx版本升级到1.1.0之后发现，我们第一节中用到的setUserVisibleHint(isVisibleToUser: Boolean)方法已被标记为废弃了！\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi8yOS8xNmY1MGFlMTUwNWY2NjU0?x-oss-process=image/format,png)\n\n```java\n     /**\n     * ... 省略其它注释\n     * @deprecated Use {@link FragmentTransaction#setMaxLifecycle(Fragment, Lifecycle.State)}\n     * instead.\n     */\n    @Deprecated\n    public void setUserVisibleHint(boolean isVisibleToUser) {\n        if (!mUserVisibleHint && isVisibleToUser && mState < STARTED\n                && mFragmentManager != null && isAdded() && mIsCreated) {\n            mFragmentManager.performPendingDeferredStart(this);\n        }\n        mUserVisibleHint = isVisibleToUser;\n        mDeferStart = mState < STARTED && !isVisibleToUser;\n        if (mSavedFragmentState != null) {\n            // Ensure that if the user visible hint is set before the Fragment has\n            // restored its state that we don't lose the new value\n            mSavedUserVisibleHint = isVisibleToUser;\n        }\n    }\n```\n并且从注释中可以看到使用 FragmentTransaction#setMaxLifecycle(Fragment, Lifecycle.State)方法来替换setUserVisibleHint方法。setMaxLifecycle实在Androidx 1.1.0中新增加的一个方法。setMaxLifecycle从名字上来看意思是设置一个最大的生命周期，因为这个方法是在FragmentTransaction中，因此我们可以知道应该是为Fragment来设置一个最大的生命周期。我们来看下setMaxLifecycle的源码：\n\n```java\n /**\n     * Set a ceiling for the state of an active fragment in this FragmentManager. If fragment is\n     * already above the received state, it will be forced down to the correct state.\n     *\n     * <p>The fragment provided must currently be added to the FragmentManager to have it's\n     * Lifecycle state capped, or previously added as part of this transaction. The\n     * {@link Lifecycle.State} passed in must at least be {@link Lifecycle.State#CREATED}, otherwise\n     * an {@link IllegalArgumentException} will be thrown.</p>\n     *\n     * @param fragment the fragment to have it's state capped.\n     * @param state the ceiling state for the fragment.\n     * @return the same FragmentTransaction instance\n     */\n    @NonNull\n    public FragmentTransaction setMaxLifecycle(@NonNull Fragment fragment,\n            @NonNull Lifecycle.State state) {\n        addOp(new Op(OP_SET_MAX_LIFECYCLE, fragment, state));\n        return this;\n    }\n```\n这个方法接收一个Fragment参数和一个Lifecycle的状态参数。Lifecycle是jetpack中很重要的一个库，它具有对Activity和Fragment生命周期感知能力，相信很多同学都应该对Lifecycle都略知一二。在Lifecycle的State中定义了五种生命周期状态，如下：\n\n```java\npublic enum State {\n        /**\n         * Destroyed state for a LifecycleOwner. After this event, this Lifecycle will not dispatch\n         * any more events. For instance, for an {@link android.app.Activity}, this state is reached\n         * <b>right before</b> Activity's {@link android.app.Activity#onDestroy() onDestroy} call.\n         */\n        DESTROYED,\n\n        /**\n         * Initialized state for a LifecycleOwner. For an {@link android.app.Activity}, this is\n         * the state when it is constructed but has not received\n         * {@link android.app.Activity#onCreate(android.os.Bundle) onCreate} yet.\n         */\n        INITIALIZED,\n\n        /**\n         * Created state for a LifecycleOwner. For an {@link android.app.Activity}, this state\n         * is reached in two cases:\n         * <ul>\n         *     <li>after {@link android.app.Activity#onCreate(android.os.Bundle) onCreate} call;\n         *     <li><b>right before</b> {@link android.app.Activity#onStop() onStop} call.\n         * </ul>\n         */\n        CREATED,\n\n        /**\n         * Started state for a LifecycleOwner. For an {@link android.app.Activity}, this state\n         * is reached in two cases:\n         * <ul>\n         *     <li>after {@link android.app.Activity#onStart() onStart} call;\n         *     <li><b>right before</b> {@link android.app.Activity#onPause() onPause} call.\n         * </ul>\n         */\n        STARTED,\n\n        /**\n         * Resumed state for a LifecycleOwner. For an {@link android.app.Activity}, this state\n         * is reached after {@link android.app.Activity#onResume() onResume} is called.\n         */\n        RESUMED;\n\n        /**\n         * Compares if this State is greater or equal to the given {@code state}.\n         *\n         * @param state State to compare with\n         * @return true if this State is greater or equal to the given {@code state}\n         */\n        public boolean isAtLeast(@NonNull State state) {\n            return compareTo(state) >= 0;\n        }\n    }\n```\n而在setMaxLifecycle中接收的生命周期状态要求不能低于CREATED，否则会抛出一个IllegalArgumentException的异常。当传入参数为DESTROYED或者INITIALIZED时则会抛出如下图的异常：\n\n![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi8yOS8xNmY1MWE1NjA5MjMzYjFi?x-oss-process=image/format,png)\n因此除去这两个生命周期外，仅剩下CREATED、STARTED、RESUMED三个生命周期状态的参数可用，那么接下来我们就逐个来研究这三个参数的效果。\n\n### 1.不设置setMaxLifecycle\n我们先来看下在不设置setMaxLifecycle的时候添加一个Fragment的状态，以便和后边的情况进行对比。首先我们在Activity中添加一个Fragment，代码如下：\n\n```kotlin\n\tfragment = TestLifecycleFragment.getInstance(Card.DECK[0], 0)\n        val fragmentTransaction = supportFragmentManager.beginTransaction()\n        fragmentTransaction.add(R.id.ll_fragment, fragment)\n        fragmentTransaction.commit()\n```\n启动Activity，我们将该Fragment生命周期的日志打印出来如下：\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi8yOS8xNmY1MGFlMTVhODk1NDBi?x-oss-process=image/format,png)\n可以看到这个Fragment生命周期从onAttach一直执行到了onResume。并且在Activity中成功显示出了Fragment\n\n![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi8yOS8xNmY1MWE1YzJhYjRkY2Y2?x-oss-process=image/format,png)\n\n### 2.setMaxLifecycle与CREATED\n\n接下来，我们将maxLifecycle设置为CREATED：\n\n```kotlin\n        fragment = TestLifecycleFragment.getInstance(Card.DECK[0], 0)\n        val fragmentTransaction = supportFragmentManager.beginTransaction()\n        fragmentTransaction.add(R.id.ll_fragment, fragment)\n        fragmentTransaction.setMaxLifecycle(fragment, Lifecycle.State.CREATED)\n        fragmentTransaction.commit()\n```\n再来看日志输出：\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi8yOS8xNmY1MGFlMTgzYmMxMTI5?x-oss-process=image/format,png)\n可以看到该Fragment的生命周期仅仅执行到了onCreate就没再往下执行了。并且Activity中没有加载出来当前Fragment。\n\n那么现在问题来了，假设Fragment已经执行到了onResume,此时再为Fragment设置一个CREATED的最大生命周期会出现什么样的情况呢？我们通过日志来验证一下：\n\n![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi8yOS8xNmY1MWE3MWQ4MGY3NGFl?x-oss-process=image/format,png)\n从日志中可以看到已经执行了onResume的Fragment，将其最大生命周期设置为CREATED后会执行onPause->onStop->onDestoryView。也就是回退到了onCreate的状态。\n\n### 3.setMaxLifecycle与STARTED\n\n接下来，我们将maxLifecycle设置为STARTED：\n```kotlin\n        fragment = TestLifecycleFragment.getInstance(Card.DECK[0], 0)\n        val fragmentTransaction = supportFragmentManager.beginTransaction()\n        fragmentTransaction.add(R.id.ll_fragment, fragment)\n        fragmentTransaction.setMaxLifecycle(fragment, Lifecycle.State.STARTED)\n        fragmentTransaction.commit()\n```\n日志输出如下：\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi8yOS8xNmY1MGFlMTk1Mjk3NDJl?x-oss-process=image/format,png)\n可以看到Fragment的生命周期执行到了onStart,并且Activity中成功显示出了当前fragment。\n\n同样，假设Fragment已经执行到了onResume方法再为其设置最大生命周期为STARTED会怎样呢？来看日志：\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi8yOS8xNmY1MGFlMTljODdiOGIy?x-oss-process=image/format,png)\n可以看到，设置最大生命周期STARTED后Fragment执行了onPause方法，也就是生命周期退回到了onStart。\n\n### 4.setMaxLifecycle与RESUMED\n最后，我们将maxLifecycle设置为RESUMED：\n```kotlin\n        fragment = TestLifecycleFragment.getInstance(Card.DECK[0], 0)\n        val fragmentTransaction = supportFragmentManager.beginTransaction()\n        fragmentTransaction.add(R.id.ll_fragment, fragment)\n        fragmentTransaction.setMaxLifecycle(fragment, Lifecycle.State.RESUMED)\n        fragmentTransaction.commit()\n```\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi8yOS8xNmY1MGFlMTljOTViZjM1?x-oss-process=image/format,png)\n可以看到此时和第一种情况一样的效果,Fragment的生命周期执行到了onResume。\n\n而对于已经执行了onResume后的Fragment，再去设置最大生命周期为RESUMED会怎么样呢？因为当前Fragment已经是RESUMED状态了,所以不会再去执行任何代码。\n\n到这里我们可以得出一个结论：\n\n> **通过setMaxLifecycle方法可以精确控制Fragment生命周期的状态，如果Fragment的生命周期状态小于被设置的最大生命周期，则当前Fragment的生命周期会执行到被设置的最大生命周期，反之，如果Fragment的生命周期状态大于被设置的最大生命周期，那么则会回退到被设置的最大生命周期。**\n\n有了这一结论，在ViewPager中便可以对Fragment的生命周期进行控制，以此来更方便的实现延迟加载功能了。\n\n## 三、Fragment延迟加载的今生\n ### 1、延迟加载新方案之于ViewPager\n通过上一小节的分析我们知道了可以通过setMaxLifecycle来设置Fragment的最大生命周期，从而可以实现ViewPager中Fragment的延迟加载。当然，关于生命周期状态处理的操作无需我们自己实现，在Androidx 1.1.0版本中的FragmentStatePagerAdapter已经帮我们实现了，只需要在使用时候传进去相应的参数即可。\n\nFragmentStatePagerAdapter的构造方法接收两个参数，如下：\n```java\n   /**\n     * Constructor for {@link FragmentStatePagerAdapter}.\n     *\n     * If {@link #BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT} is passed in, then only the current\n     * Fragment is in the {@link Lifecycle.State#RESUMED} state, while all other fragments are\n     * capped at {@link Lifecycle.State#STARTED}. If {@link #BEHAVIOR_SET_USER_VISIBLE_HINT} is\n     * passed, all fragments are in the {@link Lifecycle.State#RESUMED} state and there will be\n     * callbacks to {@link Fragment#setUserVisibleHint(boolean)}.\n     *\n     * @param fm fragment manager that will interact with this adapter\n     * @param behavior determines if only current fragments are in a resumed state\n     */\n    public FragmentStatePagerAdapter(@NonNull FragmentManager fm,\n            @Behavior int behavior) {\n        mFragmentManager = fm;\n        mBehavior = behavior;\n    }\n```\n第一个FragmentManager 参数不必多说，第二个参数时一个枚举类型的Behavior参数，其可选值如下：\n\n```kotlin\n    @Retention(RetentionPolicy.SOURCE)\n    @IntDef({BEHAVIOR_SET_USER_VISIBLE_HINT, BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT})\n    private @interface Behavior { }\n```\n当behavior为BEHAVIOR_SET_USER_VISIBLE_HINT时，Fragment改变的时候，setUserVisibleHint方法会被调用，也就是这个参数其实是为了兼容以前的老代码。并且BEHAVIOR_SET_USER_VISIBLE_HINT参数已经被置为废弃。所以我们的可选参数只剩下了BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT。\n\n当behavior为BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT时意味着只有当前显示的Fragment会被执行到onResume，而其它Fragment的生命周期都只会执行到onStart.\n\n这一功能时如何实现的呢？我们追随BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT的脚步找到了setPrimaryItem方法，这个方法的作用是设置ViewPager当前显示的Item，其源码如下：\n\n```java\npublic void setPrimaryItem(@NonNull ViewGroup container, int position, @NonNull Object object) {\n        Fragment fragment = (Fragment)object;\n        if (fragment != mCurrentPrimaryItem) {\n            if (mCurrentPrimaryItem != null) {\n                mCurrentPrimaryItem.setMenuVisibility(false);\n                if (mBehavior == BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT) {\n                    if (mCurTransaction == null) {\n                        mCurTransaction = mFragmentManager.beginTransaction();\n                    }\n                    mCurTransaction.setMaxLifecycle(mCurrentPrimaryItem, Lifecycle.State.STARTED);\n                } else {\n                    mCurrentPrimaryItem.setUserVisibleHint(false);\n                }\n            }\n            fragment.setMenuVisibility(true);\n            if (mBehavior == BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT) {\n                if (mCurTransaction == null) {\n                    mCurTransaction = mFragmentManager.beginTransaction();\n                }\n                mCurTransaction.setMaxLifecycle(fragment, Lifecycle.State.RESUMED);\n            } else {\n                fragment.setUserVisibleHint(true);\n            }\n\n            mCurrentPrimaryItem = fragment;\n        }\n    }\n```\n这段代码非常简单易懂，mCurrentPrimaryItem是当前正在显示的item，fragment是接下来要显示的item。可以看到当mBehavior 为BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT时，mCurrentPrimaryItem的最大生命周期被设置为了STARTED，而fragment的最大生命周期则被设置为了RESUMED。而当mBehavior为BEHAVIOR_SET_USER_VISIBLE_HINT时仍然会调用setUserVisibleHint方法，这种情况就不再讨论，因为BEHAVIOR_SET_USER_VISIBLE_HINT也已经被废弃掉了。\n那么我们着重来分析一下BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT时的情况：\n\n**mCurrentPrimaryItem是当前显示的Fragment，所以该Fragment必然已经执行到了onResume方法，而此时为其设置了最大生命周期STARTED，那么mCurrentPrimaryItem必然会执行onPause退回到STARTED状态。\n而fragment当前生命周期状态为onStart，当为其设置了RESUME的最大生命周期状态后,fragment必然会执行onResume方法进入RESUMED状态。**\n\n知道了这一结论后，我们再去进行懒加载的控制是不是就异常简单了？此时我们只需要一个flag去标志是否是第一次加载数据就可以了。因此，懒加载的实现可以如下：\n\n```kotlin\nabstract class TestLifecycleFragment : Fragment() {\n    private var isFirstLoad = true\n\n    override fun onResume() {\n        super.onResume()\n        if (isFirstLoad) {\n        \tisFirstLoad = false\n            loadData()\n        }\n    }\n\n    abstract fun loadData()\n}\n```\n\n### 2、延迟加载之于ViewPager2\n上篇文章[《学不动也要学！深入了解ViewPager2》](https://juejin.im/post/5df4aabe6fb9a0161104c8eb)中我们对ViewPager2有了比较深入的了解,其中在讲解ViewPager2的offScreenPageLimit时候得出过这样一个结论:\n\n> ViewPager2的offScreenPageLimit默认值为OFFSCREEN_PAGE_LIMIT_DEFAULT,当setOffscreenPageLimit为OFFSCREEN_PAGE_LIMIT_DEFAULT时候会使用RecyclerView的缓存机制。默认只会加载当前显示的Fragment,而不会像ViewPager一样至少预加载一个item.当切换到下一个item的时候，当前Fragment会执行onPause方法，而下一个Fragment则会从onCreate一直执行到onResume。当再次滑动回第一个页面的时候当前页面同样会执行onPuase，而第一个页面会执行onResume。\n\n也就是说在ViewPager2中，默认关闭了预加载机制。没有了预加载机制再谈延迟加载其实也没有任何意义了。所以关于ViewPager2的延迟加载也就不用多说了吧？只需要将网络请求放到onStart中即可。相信随着ViewPager2的普及延迟加载的概念也会慢慢淡出开发者的视线。\n\n**2020/1/4补充：**\n\n如果为ViewPager2设置了offScreenPageLimit(1)那结果会是怎样的呢？我们来看日志：\n\n![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC8xLzQvMTZmNzA3MTBjOTY1M2Y1Nw?x-oss-process=image/format,png)\n从日志中可以看到ViewPager2预加载了一个Fragment，并且预加载的Fragment的生命周期仅仅执行到了onStart。所以此处我们可以猜测在FragmentStateAdapter中一定设置了setMaxLifecycle(fragment, STARTED)，具体源码不再贴出，大家可以自行查看。因此，此时处理懒加载问题其实和ViewPager的懒加载新方案如出一辙了，仅仅需要添加一个boolean值即可。\n\n## 三、总结\n本篇文章对于Fragment的延迟加载进行了深入的探究，并且了解了在Androidx 1.1.0版本中对Fragment最大生命周期状态的控制，从而探究出了Fragment延迟加载的新方案。对于ViewPager2，因其默认不会进行预加载因此也就意味着我们无需处理ViewPager2的延迟加载问题。好了，这一篇花费了我两个周末（其实是上周末写了一半偷了个懒）的文章到此就结束了，如果你从中学有所收获那么请你不要吝啬留下你的赞。\n\n[本文涉及源码](https://github.com/zhpanvip/ViewPagerSample)\n\n\n\n\n","source":"_posts/24.学不动也要学！探究Fragment延迟加载的前世今生.md","raw":"---\ntitle: 学不动也要学！探究Fragment延迟加载的前世今生\ndate: 2020-01-02 17:31:50\ntags:\n- Fragment\n- 懒加载\n---\n\n上周在[《学不动也要学！深入了解ViewPager2》](https://juejin.im/post/5df4aabe6fb9a0161104c8eb)一篇文章的留言中，大家普遍对于Fragment懒加载的问题比较关心。其实，对于Fragment懒加载问题的处理由来已久，网上不乏相关的优秀文章。但是，由于Fragment生命周期的原因使得懒加载问题的处理并不是那么的优雅。显然，Google也意识到了问题所在。因此，在Androidx的库中对于Fragment的生命周期状态的控制进行了深度优化，使得我们更容易的去管控Fragment的生命周期，也使得我们更容易的去处理懒加载问题。但是，前提条件是我们要了解Google对于Fragment做了哪些优化。那么就让我们借此机会一起来探究一下吧！（ ***懒加载称作延迟加载我觉得更贴切一些，所以下文就统称为延迟加载了。*** ）\n## 一、Fragment延迟加载的前世\n虽然本篇文章是对于Fragment新特性的探究，但是我觉得写文章总要有个因果。也为了照顾一下还不太了解什么是延迟加载的同学。我们还是先来了解一下延迟加载，顺便回顾一下Fragment延迟加载的旧方案。\n### 1.为什么要对Fragment做延迟加载?\n首先，我们要搞清楚一个问题。“Fragment延迟加载“中的“延迟”并不指的是延迟加载Fragment，而是延迟加载Fragment中的数据。对于Fragment的使用通常我们会结合ViewPager。在[《学不动也要学！深入了解ViewPager2》](https://juejin.im/post/5df4aabe6fb9a0161104c8eb)一文中我们也提到ViewPager的预加载问题。ViewPager会默认在当前页面的左右两边至少预加载一个页面以保证ViewPager的流畅性。我们假设在ViewPager的所有Fragment中都存在网络请求。当我们打开这个页面的时候由于ViewPager的预加载原因，即使在其它Fragment不可见的情况下也会去进行网络请求加载数据。而如果此时用户根本就没有去滑动ViewPager就退出了应用或者切换到了其他页面。那么对于这个不可见的Fragment中的网络请求岂不是既浪费了流量也浪费了手机和服务器的性能？\n\n那么此时有的同学就有问题了。你就不能在Fragment显示的时候去加载数据吗?问的好！在解答之前我们先来看下Fragment的生命周期\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi8yOS8xNmY1MGFlMTUwMGM3ZDFk?x-oss-process=image/format,png)\n想必这张图大家应该都非常熟悉了。当Fragment被预加载的时候，此Fragment的生命周期会从onAttach执行到onResume。显然我们无法通过Fragment的生命周期来控制Fragment的延迟加载。那么该怎么办呢？我们且往下看。\n\n### 2.如何处理Fragment的延迟加载？\n通过上一小节的分析我们知道想要在Fragment的生命周期中处理延迟加载的问题显然是走不通的。所以想要处理Fragment的延迟加载就需要另想它法了。还好，在Fragment中为我们提供了一个setUserVisibleHint(isVisibleToUser: Boolean)的方法，这个方法中有一个isVisibleToUser的boolean类型的参数，其意义表示当前的Fragment是否对用户可见。因此，对于Fragment的延迟加载我们便可以通过这个方法来展开。\n既然要使用setUserVisibleHint(isVisibleToUser: Boolean)那么就应该知道这个方法的调用时机。我们写一个ViewPager嵌套Fragment的例子来打印下日志：\n\n![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi8yOS8xNmY1MWE0N2UzMDg1Mzdk?x-oss-process=image/format,png)\n*注：上图打印的日志中”position:0“表示当前Fragment，“position:1”表示预加载的Fragment，下同。*\n\n可见该方法是在Fragment的onAttach之前就已经被调用了。因此，对于延迟加载我们可以在setUserVisibleHint(isVisibleToUser: Boolean)方法及onViewCreated(view: View, savedInstanceState: Bundle?)添加标志位来控制是否加载数据。我们来看下代码：\n\n```kotlin\nabstract class BaseLazyFragment : Fragment() {\n    /**\n     * 当前Fragment状态是否可见\n     */\n    private var isVisibleToUser: Boolean = false\n    /**\n     * 是否已创建View\n     */\n    private var isViewCreated: Boolean = false\n    /**\n     * 是否第一次加载数据\n     */\n    private var isFirstLoad = true\n\n    override fun setUserVisibleHint(isVisibleToUser: Boolean) {\n        super.setUserVisibleHint(isVisibleToUser)\n        this.isVisibleToUser = isVisibleToUser\n        onLazyLoad()\n    }\n\n    private fun onLazyLoad() {\n        if (isVisibleToUser && isViewCreated && isFirstLoad) {\n            isFirstLoad = false\n            lazyLoad()\n        }\n    }\n\n    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n        super.onViewCreated(view, savedInstanceState)\n        isViewCreated = true\n        onLazyLoad()\n    }\n\n    protected abstract fun lazyLoad()\n\n}\n```\n我们通过在Fragment中添加了三个标志位实现了延迟加载的功能。我们到TestFragment尝试一下：\n\n```kotlin\nclass TestFragment : BaseLazyFragment() {\n\n    private var position: Int = 0\n\n    override fun setUserVisibleHint(isVisibleToUser: Boolean) {\n        super.setUserVisibleHint(isVisibleToUser)\n        val bundle = arguments\n        position = bundle!!.getInt(KEY_POSITION)\n    }\n\n    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? {\n        val cardView = CardView(inflater, container)\n        cardView.bind(Card.fromBundle(arguments!!),position)\n        return cardView.view\n    }\n\n    companion object {\n\n        private const val KEY_POSITION = \"position\"\n\n        fun getInstance(card: Card, position: Int): TestFragment {\n            val fragment = TestFragment()\n            val bundle = card.toBundle()\n            bundle.putInt(KEY_POSITION, position)\n            fragment.arguments = bundle\n            return fragment\n        }\n    }\n\n    override fun lazyLoad() {\n        showToast(\"Fragment$position is loading data\")\n    }\n\n    private fun showToast(content: String) {\n        Toast.makeText(context, content, Toast.LENGTH_SHORT).show()\n    }\n\n}\n\n```\n\n我们来看下效果：\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi8yOS8xNmY1MGFlMTUwMjk5Njk2?x-oss-process=image/format,png)\n嗯！立竿见影，只有当Fragment完全显示出来的时候loading data的操作才被执行。这种延迟加载的方案在Androidx 1.1.0版本以前被广泛应用。而在Androidx 1.1.0版本中，Google对于Fragment进行了优化处理，使得延迟加载也有了新的解决方案。\n\n## 二、Fragment的setMaxLifecycle探究\n上一节中我们讲到因为ViewPager的预加载机制以及Fragment的生命周期无法得以控制，我们不得不通过setUserVisibleHint(isVisibleToUser: Boolean)和onViewCreated(view: View, savedInstanceState: Bundle?)方法以及添加三个标志位来处理延迟加载，显然这样的代码并不优雅。\n\n当我们将Android项目迁移到Androidx并将androidx版本升级到1.1.0之后发现，我们第一节中用到的setUserVisibleHint(isVisibleToUser: Boolean)方法已被标记为废弃了！\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi8yOS8xNmY1MGFlMTUwNWY2NjU0?x-oss-process=image/format,png)\n\n```java\n     /**\n     * ... 省略其它注释\n     * @deprecated Use {@link FragmentTransaction#setMaxLifecycle(Fragment, Lifecycle.State)}\n     * instead.\n     */\n    @Deprecated\n    public void setUserVisibleHint(boolean isVisibleToUser) {\n        if (!mUserVisibleHint && isVisibleToUser && mState < STARTED\n                && mFragmentManager != null && isAdded() && mIsCreated) {\n            mFragmentManager.performPendingDeferredStart(this);\n        }\n        mUserVisibleHint = isVisibleToUser;\n        mDeferStart = mState < STARTED && !isVisibleToUser;\n        if (mSavedFragmentState != null) {\n            // Ensure that if the user visible hint is set before the Fragment has\n            // restored its state that we don't lose the new value\n            mSavedUserVisibleHint = isVisibleToUser;\n        }\n    }\n```\n并且从注释中可以看到使用 FragmentTransaction#setMaxLifecycle(Fragment, Lifecycle.State)方法来替换setUserVisibleHint方法。setMaxLifecycle实在Androidx 1.1.0中新增加的一个方法。setMaxLifecycle从名字上来看意思是设置一个最大的生命周期，因为这个方法是在FragmentTransaction中，因此我们可以知道应该是为Fragment来设置一个最大的生命周期。我们来看下setMaxLifecycle的源码：\n\n```java\n /**\n     * Set a ceiling for the state of an active fragment in this FragmentManager. If fragment is\n     * already above the received state, it will be forced down to the correct state.\n     *\n     * <p>The fragment provided must currently be added to the FragmentManager to have it's\n     * Lifecycle state capped, or previously added as part of this transaction. The\n     * {@link Lifecycle.State} passed in must at least be {@link Lifecycle.State#CREATED}, otherwise\n     * an {@link IllegalArgumentException} will be thrown.</p>\n     *\n     * @param fragment the fragment to have it's state capped.\n     * @param state the ceiling state for the fragment.\n     * @return the same FragmentTransaction instance\n     */\n    @NonNull\n    public FragmentTransaction setMaxLifecycle(@NonNull Fragment fragment,\n            @NonNull Lifecycle.State state) {\n        addOp(new Op(OP_SET_MAX_LIFECYCLE, fragment, state));\n        return this;\n    }\n```\n这个方法接收一个Fragment参数和一个Lifecycle的状态参数。Lifecycle是jetpack中很重要的一个库，它具有对Activity和Fragment生命周期感知能力，相信很多同学都应该对Lifecycle都略知一二。在Lifecycle的State中定义了五种生命周期状态，如下：\n\n```java\npublic enum State {\n        /**\n         * Destroyed state for a LifecycleOwner. After this event, this Lifecycle will not dispatch\n         * any more events. For instance, for an {@link android.app.Activity}, this state is reached\n         * <b>right before</b> Activity's {@link android.app.Activity#onDestroy() onDestroy} call.\n         */\n        DESTROYED,\n\n        /**\n         * Initialized state for a LifecycleOwner. For an {@link android.app.Activity}, this is\n         * the state when it is constructed but has not received\n         * {@link android.app.Activity#onCreate(android.os.Bundle) onCreate} yet.\n         */\n        INITIALIZED,\n\n        /**\n         * Created state for a LifecycleOwner. For an {@link android.app.Activity}, this state\n         * is reached in two cases:\n         * <ul>\n         *     <li>after {@link android.app.Activity#onCreate(android.os.Bundle) onCreate} call;\n         *     <li><b>right before</b> {@link android.app.Activity#onStop() onStop} call.\n         * </ul>\n         */\n        CREATED,\n\n        /**\n         * Started state for a LifecycleOwner. For an {@link android.app.Activity}, this state\n         * is reached in two cases:\n         * <ul>\n         *     <li>after {@link android.app.Activity#onStart() onStart} call;\n         *     <li><b>right before</b> {@link android.app.Activity#onPause() onPause} call.\n         * </ul>\n         */\n        STARTED,\n\n        /**\n         * Resumed state for a LifecycleOwner. For an {@link android.app.Activity}, this state\n         * is reached after {@link android.app.Activity#onResume() onResume} is called.\n         */\n        RESUMED;\n\n        /**\n         * Compares if this State is greater or equal to the given {@code state}.\n         *\n         * @param state State to compare with\n         * @return true if this State is greater or equal to the given {@code state}\n         */\n        public boolean isAtLeast(@NonNull State state) {\n            return compareTo(state) >= 0;\n        }\n    }\n```\n而在setMaxLifecycle中接收的生命周期状态要求不能低于CREATED，否则会抛出一个IllegalArgumentException的异常。当传入参数为DESTROYED或者INITIALIZED时则会抛出如下图的异常：\n\n![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi8yOS8xNmY1MWE1NjA5MjMzYjFi?x-oss-process=image/format,png)\n因此除去这两个生命周期外，仅剩下CREATED、STARTED、RESUMED三个生命周期状态的参数可用，那么接下来我们就逐个来研究这三个参数的效果。\n\n### 1.不设置setMaxLifecycle\n我们先来看下在不设置setMaxLifecycle的时候添加一个Fragment的状态，以便和后边的情况进行对比。首先我们在Activity中添加一个Fragment，代码如下：\n\n```kotlin\n\tfragment = TestLifecycleFragment.getInstance(Card.DECK[0], 0)\n        val fragmentTransaction = supportFragmentManager.beginTransaction()\n        fragmentTransaction.add(R.id.ll_fragment, fragment)\n        fragmentTransaction.commit()\n```\n启动Activity，我们将该Fragment生命周期的日志打印出来如下：\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi8yOS8xNmY1MGFlMTVhODk1NDBi?x-oss-process=image/format,png)\n可以看到这个Fragment生命周期从onAttach一直执行到了onResume。并且在Activity中成功显示出了Fragment\n\n![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi8yOS8xNmY1MWE1YzJhYjRkY2Y2?x-oss-process=image/format,png)\n\n### 2.setMaxLifecycle与CREATED\n\n接下来，我们将maxLifecycle设置为CREATED：\n\n```kotlin\n        fragment = TestLifecycleFragment.getInstance(Card.DECK[0], 0)\n        val fragmentTransaction = supportFragmentManager.beginTransaction()\n        fragmentTransaction.add(R.id.ll_fragment, fragment)\n        fragmentTransaction.setMaxLifecycle(fragment, Lifecycle.State.CREATED)\n        fragmentTransaction.commit()\n```\n再来看日志输出：\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi8yOS8xNmY1MGFlMTgzYmMxMTI5?x-oss-process=image/format,png)\n可以看到该Fragment的生命周期仅仅执行到了onCreate就没再往下执行了。并且Activity中没有加载出来当前Fragment。\n\n那么现在问题来了，假设Fragment已经执行到了onResume,此时再为Fragment设置一个CREATED的最大生命周期会出现什么样的情况呢？我们通过日志来验证一下：\n\n![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi8yOS8xNmY1MWE3MWQ4MGY3NGFl?x-oss-process=image/format,png)\n从日志中可以看到已经执行了onResume的Fragment，将其最大生命周期设置为CREATED后会执行onPause->onStop->onDestoryView。也就是回退到了onCreate的状态。\n\n### 3.setMaxLifecycle与STARTED\n\n接下来，我们将maxLifecycle设置为STARTED：\n```kotlin\n        fragment = TestLifecycleFragment.getInstance(Card.DECK[0], 0)\n        val fragmentTransaction = supportFragmentManager.beginTransaction()\n        fragmentTransaction.add(R.id.ll_fragment, fragment)\n        fragmentTransaction.setMaxLifecycle(fragment, Lifecycle.State.STARTED)\n        fragmentTransaction.commit()\n```\n日志输出如下：\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi8yOS8xNmY1MGFlMTk1Mjk3NDJl?x-oss-process=image/format,png)\n可以看到Fragment的生命周期执行到了onStart,并且Activity中成功显示出了当前fragment。\n\n同样，假设Fragment已经执行到了onResume方法再为其设置最大生命周期为STARTED会怎样呢？来看日志：\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi8yOS8xNmY1MGFlMTljODdiOGIy?x-oss-process=image/format,png)\n可以看到，设置最大生命周期STARTED后Fragment执行了onPause方法，也就是生命周期退回到了onStart。\n\n### 4.setMaxLifecycle与RESUMED\n最后，我们将maxLifecycle设置为RESUMED：\n```kotlin\n        fragment = TestLifecycleFragment.getInstance(Card.DECK[0], 0)\n        val fragmentTransaction = supportFragmentManager.beginTransaction()\n        fragmentTransaction.add(R.id.ll_fragment, fragment)\n        fragmentTransaction.setMaxLifecycle(fragment, Lifecycle.State.RESUMED)\n        fragmentTransaction.commit()\n```\n![在这里插入图片描述](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi8yOS8xNmY1MGFlMTljOTViZjM1?x-oss-process=image/format,png)\n可以看到此时和第一种情况一样的效果,Fragment的生命周期执行到了onResume。\n\n而对于已经执行了onResume后的Fragment，再去设置最大生命周期为RESUMED会怎么样呢？因为当前Fragment已经是RESUMED状态了,所以不会再去执行任何代码。\n\n到这里我们可以得出一个结论：\n\n> **通过setMaxLifecycle方法可以精确控制Fragment生命周期的状态，如果Fragment的生命周期状态小于被设置的最大生命周期，则当前Fragment的生命周期会执行到被设置的最大生命周期，反之，如果Fragment的生命周期状态大于被设置的最大生命周期，那么则会回退到被设置的最大生命周期。**\n\n有了这一结论，在ViewPager中便可以对Fragment的生命周期进行控制，以此来更方便的实现延迟加载功能了。\n\n## 三、Fragment延迟加载的今生\n ### 1、延迟加载新方案之于ViewPager\n通过上一小节的分析我们知道了可以通过setMaxLifecycle来设置Fragment的最大生命周期，从而可以实现ViewPager中Fragment的延迟加载。当然，关于生命周期状态处理的操作无需我们自己实现，在Androidx 1.1.0版本中的FragmentStatePagerAdapter已经帮我们实现了，只需要在使用时候传进去相应的参数即可。\n\nFragmentStatePagerAdapter的构造方法接收两个参数，如下：\n```java\n   /**\n     * Constructor for {@link FragmentStatePagerAdapter}.\n     *\n     * If {@link #BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT} is passed in, then only the current\n     * Fragment is in the {@link Lifecycle.State#RESUMED} state, while all other fragments are\n     * capped at {@link Lifecycle.State#STARTED}. If {@link #BEHAVIOR_SET_USER_VISIBLE_HINT} is\n     * passed, all fragments are in the {@link Lifecycle.State#RESUMED} state and there will be\n     * callbacks to {@link Fragment#setUserVisibleHint(boolean)}.\n     *\n     * @param fm fragment manager that will interact with this adapter\n     * @param behavior determines if only current fragments are in a resumed state\n     */\n    public FragmentStatePagerAdapter(@NonNull FragmentManager fm,\n            @Behavior int behavior) {\n        mFragmentManager = fm;\n        mBehavior = behavior;\n    }\n```\n第一个FragmentManager 参数不必多说，第二个参数时一个枚举类型的Behavior参数，其可选值如下：\n\n```kotlin\n    @Retention(RetentionPolicy.SOURCE)\n    @IntDef({BEHAVIOR_SET_USER_VISIBLE_HINT, BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT})\n    private @interface Behavior { }\n```\n当behavior为BEHAVIOR_SET_USER_VISIBLE_HINT时，Fragment改变的时候，setUserVisibleHint方法会被调用，也就是这个参数其实是为了兼容以前的老代码。并且BEHAVIOR_SET_USER_VISIBLE_HINT参数已经被置为废弃。所以我们的可选参数只剩下了BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT。\n\n当behavior为BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT时意味着只有当前显示的Fragment会被执行到onResume，而其它Fragment的生命周期都只会执行到onStart.\n\n这一功能时如何实现的呢？我们追随BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT的脚步找到了setPrimaryItem方法，这个方法的作用是设置ViewPager当前显示的Item，其源码如下：\n\n```java\npublic void setPrimaryItem(@NonNull ViewGroup container, int position, @NonNull Object object) {\n        Fragment fragment = (Fragment)object;\n        if (fragment != mCurrentPrimaryItem) {\n            if (mCurrentPrimaryItem != null) {\n                mCurrentPrimaryItem.setMenuVisibility(false);\n                if (mBehavior == BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT) {\n                    if (mCurTransaction == null) {\n                        mCurTransaction = mFragmentManager.beginTransaction();\n                    }\n                    mCurTransaction.setMaxLifecycle(mCurrentPrimaryItem, Lifecycle.State.STARTED);\n                } else {\n                    mCurrentPrimaryItem.setUserVisibleHint(false);\n                }\n            }\n            fragment.setMenuVisibility(true);\n            if (mBehavior == BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT) {\n                if (mCurTransaction == null) {\n                    mCurTransaction = mFragmentManager.beginTransaction();\n                }\n                mCurTransaction.setMaxLifecycle(fragment, Lifecycle.State.RESUMED);\n            } else {\n                fragment.setUserVisibleHint(true);\n            }\n\n            mCurrentPrimaryItem = fragment;\n        }\n    }\n```\n这段代码非常简单易懂，mCurrentPrimaryItem是当前正在显示的item，fragment是接下来要显示的item。可以看到当mBehavior 为BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT时，mCurrentPrimaryItem的最大生命周期被设置为了STARTED，而fragment的最大生命周期则被设置为了RESUMED。而当mBehavior为BEHAVIOR_SET_USER_VISIBLE_HINT时仍然会调用setUserVisibleHint方法，这种情况就不再讨论，因为BEHAVIOR_SET_USER_VISIBLE_HINT也已经被废弃掉了。\n那么我们着重来分析一下BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT时的情况：\n\n**mCurrentPrimaryItem是当前显示的Fragment，所以该Fragment必然已经执行到了onResume方法，而此时为其设置了最大生命周期STARTED，那么mCurrentPrimaryItem必然会执行onPause退回到STARTED状态。\n而fragment当前生命周期状态为onStart，当为其设置了RESUME的最大生命周期状态后,fragment必然会执行onResume方法进入RESUMED状态。**\n\n知道了这一结论后，我们再去进行懒加载的控制是不是就异常简单了？此时我们只需要一个flag去标志是否是第一次加载数据就可以了。因此，懒加载的实现可以如下：\n\n```kotlin\nabstract class TestLifecycleFragment : Fragment() {\n    private var isFirstLoad = true\n\n    override fun onResume() {\n        super.onResume()\n        if (isFirstLoad) {\n        \tisFirstLoad = false\n            loadData()\n        }\n    }\n\n    abstract fun loadData()\n}\n```\n\n### 2、延迟加载之于ViewPager2\n上篇文章[《学不动也要学！深入了解ViewPager2》](https://juejin.im/post/5df4aabe6fb9a0161104c8eb)中我们对ViewPager2有了比较深入的了解,其中在讲解ViewPager2的offScreenPageLimit时候得出过这样一个结论:\n\n> ViewPager2的offScreenPageLimit默认值为OFFSCREEN_PAGE_LIMIT_DEFAULT,当setOffscreenPageLimit为OFFSCREEN_PAGE_LIMIT_DEFAULT时候会使用RecyclerView的缓存机制。默认只会加载当前显示的Fragment,而不会像ViewPager一样至少预加载一个item.当切换到下一个item的时候，当前Fragment会执行onPause方法，而下一个Fragment则会从onCreate一直执行到onResume。当再次滑动回第一个页面的时候当前页面同样会执行onPuase，而第一个页面会执行onResume。\n\n也就是说在ViewPager2中，默认关闭了预加载机制。没有了预加载机制再谈延迟加载其实也没有任何意义了。所以关于ViewPager2的延迟加载也就不用多说了吧？只需要将网络请求放到onStart中即可。相信随着ViewPager2的普及延迟加载的概念也会慢慢淡出开发者的视线。\n\n**2020/1/4补充：**\n\n如果为ViewPager2设置了offScreenPageLimit(1)那结果会是怎样的呢？我们来看日志：\n\n![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC8xLzQvMTZmNzA3MTBjOTY1M2Y1Nw?x-oss-process=image/format,png)\n从日志中可以看到ViewPager2预加载了一个Fragment，并且预加载的Fragment的生命周期仅仅执行到了onStart。所以此处我们可以猜测在FragmentStateAdapter中一定设置了setMaxLifecycle(fragment, STARTED)，具体源码不再贴出，大家可以自行查看。因此，此时处理懒加载问题其实和ViewPager的懒加载新方案如出一辙了，仅仅需要添加一个boolean值即可。\n\n## 三、总结\n本篇文章对于Fragment的延迟加载进行了深入的探究，并且了解了在Androidx 1.1.0版本中对Fragment最大生命周期状态的控制，从而探究出了Fragment延迟加载的新方案。对于ViewPager2，因其默认不会进行预加载因此也就意味着我们无需处理ViewPager2的延迟加载问题。好了，这一篇花费了我两个周末（其实是上周末写了一半偷了个懒）的文章到此就结束了，如果你从中学有所收获那么请你不要吝啬留下你的赞。\n\n[本文涉及源码](https://github.com/zhpanvip/ViewPagerSample)\n\n\n\n\n","slug":"24.学不动也要学！探究Fragment延迟加载的前世今生","published":1,"updated":"2020-08-29T18:01:07.010Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckegm5nsu001idwozgh1b44q2","content":"<p>上周在<a href=\"https://juejin.im/post/5df4aabe6fb9a0161104c8eb\">《学不动也要学！深入了解ViewPager2》</a>一篇文章的留言中，大家普遍对于Fragment懒加载的问题比较关心。其实，对于Fragment懒加载问题的处理由来已久，网上不乏相关的优秀文章。但是，由于Fragment生命周期的原因使得懒加载问题的处理并不是那么的优雅。显然，Google也意识到了问题所在。因此，在Androidx的库中对于Fragment的生命周期状态的控制进行了深度优化，使得我们更容易的去管控Fragment的生命周期，也使得我们更容易的去处理懒加载问题。但是，前提条件是我们要了解Google对于Fragment做了哪些优化。那么就让我们借此机会一起来探究一下吧！（ <strong><em>懒加载称作延迟加载我觉得更贴切一些，所以下文就统称为延迟加载了。</em></strong> ）</p>\n<h2 id=\"一、Fragment延迟加载的前世\"><a href=\"#一、Fragment延迟加载的前世\" class=\"headerlink\" title=\"一、Fragment延迟加载的前世\"></a>一、Fragment延迟加载的前世</h2><p>虽然本篇文章是对于Fragment新特性的探究，但是我觉得写文章总要有个因果。也为了照顾一下还不太了解什么是延迟加载的同学。我们还是先来了解一下延迟加载，顺便回顾一下Fragment延迟加载的旧方案。</p>\n<h3 id=\"1-为什么要对Fragment做延迟加载\"><a href=\"#1-为什么要对Fragment做延迟加载\" class=\"headerlink\" title=\"1.为什么要对Fragment做延迟加载?\"></a>1.为什么要对Fragment做延迟加载?</h3><p>首先，我们要搞清楚一个问题。“Fragment延迟加载“中的“延迟”并不指的是延迟加载Fragment，而是延迟加载Fragment中的数据。对于Fragment的使用通常我们会结合ViewPager。在<a href=\"https://juejin.im/post/5df4aabe6fb9a0161104c8eb\">《学不动也要学！深入了解ViewPager2》</a>一文中我们也提到ViewPager的预加载问题。ViewPager会默认在当前页面的左右两边至少预加载一个页面以保证ViewPager的流畅性。我们假设在ViewPager的所有Fragment中都存在网络请求。当我们打开这个页面的时候由于ViewPager的预加载原因，即使在其它Fragment不可见的情况下也会去进行网络请求加载数据。而如果此时用户根本就没有去滑动ViewPager就退出了应用或者切换到了其他页面。那么对于这个不可见的Fragment中的网络请求岂不是既浪费了流量也浪费了手机和服务器的性能？</p>\n<p>那么此时有的同学就有问题了。你就不能在Fragment显示的时候去加载数据吗?问的好！在解答之前我们先来看下Fragment的生命周期<br><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi8yOS8xNmY1MGFlMTUwMGM3ZDFk?x-oss-process=image/format,png\" alt=\"在这里插入图片描述\"><br>想必这张图大家应该都非常熟悉了。当Fragment被预加载的时候，此Fragment的生命周期会从onAttach执行到onResume。显然我们无法通过Fragment的生命周期来控制Fragment的延迟加载。那么该怎么办呢？我们且往下看。</p>\n<h3 id=\"2-如何处理Fragment的延迟加载？\"><a href=\"#2-如何处理Fragment的延迟加载？\" class=\"headerlink\" title=\"2.如何处理Fragment的延迟加载？\"></a>2.如何处理Fragment的延迟加载？</h3><p>通过上一小节的分析我们知道想要在Fragment的生命周期中处理延迟加载的问题显然是走不通的。所以想要处理Fragment的延迟加载就需要另想它法了。还好，在Fragment中为我们提供了一个setUserVisibleHint(isVisibleToUser: Boolean)的方法，这个方法中有一个isVisibleToUser的boolean类型的参数，其意义表示当前的Fragment是否对用户可见。因此，对于Fragment的延迟加载我们便可以通过这个方法来展开。<br>既然要使用setUserVisibleHint(isVisibleToUser: Boolean)那么就应该知道这个方法的调用时机。我们写一个ViewPager嵌套Fragment的例子来打印下日志：</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi8yOS8xNmY1MWE0N2UzMDg1Mzdk?x-oss-process=image/format,png\"><br><em>注：上图打印的日志中”position:0“表示当前Fragment，“position:1”表示预加载的Fragment，下同。</em></p>\n<p>可见该方法是在Fragment的onAttach之前就已经被调用了。因此，对于延迟加载我们可以在setUserVisibleHint(isVisibleToUser: Boolean)方法及onViewCreated(view: View, savedInstanceState: Bundle?)添加标志位来控制是否加载数据。我们来看下代码：</p>\n<pre><code class=\"hljs kotlin\"><span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">BaseLazyFragment</span> : <span class=\"hljs-type\">Fragment</span></span>() &#123;\n    <span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">     * 当前Fragment状态是否可见</span>\n<span class=\"hljs-comment\">     */</span>\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">var</span> isVisibleToUser: <span class=\"hljs-built_in\">Boolean</span> = <span class=\"hljs-literal\">false</span>\n    <span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">     * 是否已创建View</span>\n<span class=\"hljs-comment\">     */</span>\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">var</span> isViewCreated: <span class=\"hljs-built_in\">Boolean</span> = <span class=\"hljs-literal\">false</span>\n    <span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">     * 是否第一次加载数据</span>\n<span class=\"hljs-comment\">     */</span>\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">var</span> isFirstLoad = <span class=\"hljs-literal\">true</span>\n\n    <span class=\"hljs-keyword\">override</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">setUserVisibleHint</span><span class=\"hljs-params\">(isVisibleToUser: <span class=\"hljs-type\">Boolean</span>)</span></span> &#123;\n        <span class=\"hljs-keyword\">super</span>.setUserVisibleHint(isVisibleToUser)\n        <span class=\"hljs-keyword\">this</span>.isVisibleToUser = isVisibleToUser\n        onLazyLoad()\n    &#125;\n\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">onLazyLoad</span><span class=\"hljs-params\">()</span></span> &#123;\n        <span class=\"hljs-keyword\">if</span> (isVisibleToUser &amp;&amp; isViewCreated &amp;&amp; isFirstLoad) &#123;\n            isFirstLoad = <span class=\"hljs-literal\">false</span>\n            lazyLoad()\n        &#125;\n    &#125;\n\n    <span class=\"hljs-keyword\">override</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">onViewCreated</span><span class=\"hljs-params\">(view: <span class=\"hljs-type\">View</span>, savedInstanceState: <span class=\"hljs-type\">Bundle</span>?)</span></span> &#123;\n        <span class=\"hljs-keyword\">super</span>.onViewCreated(view, savedInstanceState)\n        isViewCreated = <span class=\"hljs-literal\">true</span>\n        onLazyLoad()\n    &#125;\n\n    <span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">lazyLoad</span><span class=\"hljs-params\">()</span></span>\n\n&#125;</code></pre>\n<p>我们通过在Fragment中添加了三个标志位实现了延迟加载的功能。我们到TestFragment尝试一下：</p>\n<pre><code class=\"hljs kotlin\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">TestFragment</span> : <span class=\"hljs-type\">BaseLazyFragment</span></span>() &#123;\n\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">var</span> position: <span class=\"hljs-built_in\">Int</span> = <span class=\"hljs-number\">0</span>\n\n    <span class=\"hljs-keyword\">override</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">setUserVisibleHint</span><span class=\"hljs-params\">(isVisibleToUser: <span class=\"hljs-type\">Boolean</span>)</span></span> &#123;\n        <span class=\"hljs-keyword\">super</span>.setUserVisibleHint(isVisibleToUser)\n        <span class=\"hljs-keyword\">val</span> bundle = arguments\n        position = bundle!!.getInt(KEY_POSITION)\n    &#125;\n\n    <span class=\"hljs-keyword\">override</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">onCreateView</span><span class=\"hljs-params\">(inflater: <span class=\"hljs-type\">LayoutInflater</span>, container: <span class=\"hljs-type\">ViewGroup</span>?, savedInstanceState: <span class=\"hljs-type\">Bundle</span>?)</span></span>: View? &#123;\n        <span class=\"hljs-keyword\">val</span> cardView = CardView(inflater, container)\n        cardView.bind(Card.fromBundle(arguments!!),position)\n        <span class=\"hljs-keyword\">return</span> cardView.view\n    &#125;\n\n    <span class=\"hljs-keyword\">companion</span> <span class=\"hljs-keyword\">object</span> &#123;\n\n        <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">val</span> KEY_POSITION = <span class=\"hljs-string\">&quot;position&quot;</span>\n\n        <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">getInstance</span><span class=\"hljs-params\">(card: <span class=\"hljs-type\">Card</span>, position: <span class=\"hljs-type\">Int</span>)</span></span>: TestFragment &#123;\n            <span class=\"hljs-keyword\">val</span> fragment = TestFragment()\n            <span class=\"hljs-keyword\">val</span> bundle = card.toBundle()\n            bundle.putInt(KEY_POSITION, position)\n            fragment.arguments = bundle\n            <span class=\"hljs-keyword\">return</span> fragment\n        &#125;\n    &#125;\n\n    <span class=\"hljs-keyword\">override</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">lazyLoad</span><span class=\"hljs-params\">()</span></span> &#123;\n        showToast(<span class=\"hljs-string\">&quot;Fragment<span class=\"hljs-variable\">$position</span> is loading data&quot;</span>)\n    &#125;\n\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">showToast</span><span class=\"hljs-params\">(content: <span class=\"hljs-type\">String</span>)</span></span> &#123;\n        Toast.makeText(context, content, Toast.LENGTH_SHORT).show()\n    &#125;\n\n&#125;\n</code></pre>\n\n<p>我们来看下效果：<br><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi8yOS8xNmY1MGFlMTUwMjk5Njk2?x-oss-process=image/format,png\" alt=\"在这里插入图片描述\"><br>嗯！立竿见影，只有当Fragment完全显示出来的时候loading data的操作才被执行。这种延迟加载的方案在Androidx 1.1.0版本以前被广泛应用。而在Androidx 1.1.0版本中，Google对于Fragment进行了优化处理，使得延迟加载也有了新的解决方案。</p>\n<h2 id=\"二、Fragment的setMaxLifecycle探究\"><a href=\"#二、Fragment的setMaxLifecycle探究\" class=\"headerlink\" title=\"二、Fragment的setMaxLifecycle探究\"></a>二、Fragment的setMaxLifecycle探究</h2><p>上一节中我们讲到因为ViewPager的预加载机制以及Fragment的生命周期无法得以控制，我们不得不通过setUserVisibleHint(isVisibleToUser: Boolean)和onViewCreated(view: View, savedInstanceState: Bundle?)方法以及添加三个标志位来处理延迟加载，显然这样的代码并不优雅。</p>\n<p>当我们将Android项目迁移到Androidx并将androidx版本升级到1.1.0之后发现，我们第一节中用到的setUserVisibleHint(isVisibleToUser: Boolean)方法已被标记为废弃了！<br><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi8yOS8xNmY1MGFlMTUwNWY2NjU0?x-oss-process=image/format,png\" alt=\"在这里插入图片描述\"></p>\n<pre><code class=\"hljs java\"> <span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\"> * ... 省略其它注释</span>\n<span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@deprecated</span> Use &#123;<span class=\"hljs-doctag\">@link</span> FragmentTransaction#setMaxLifecycle(Fragment, Lifecycle.State)&#125;</span>\n<span class=\"hljs-comment\"> * instead.</span>\n<span class=\"hljs-comment\"> */</span>\n<span class=\"hljs-meta\">@Deprecated</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">setUserVisibleHint</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">boolean</span> isVisibleToUser)</span> </span>&#123;\n    <span class=\"hljs-keyword\">if</span> (!mUserVisibleHint &amp;&amp; isVisibleToUser &amp;&amp; mState &lt; STARTED\n            &amp;&amp; mFragmentManager != <span class=\"hljs-keyword\">null</span> &amp;&amp; isAdded() &amp;&amp; mIsCreated) &#123;\n        mFragmentManager.performPendingDeferredStart(<span class=\"hljs-keyword\">this</span>);\n    &#125;\n    mUserVisibleHint = isVisibleToUser;\n    mDeferStart = mState &lt; STARTED &amp;&amp; !isVisibleToUser;\n    <span class=\"hljs-keyword\">if</span> (mSavedFragmentState != <span class=\"hljs-keyword\">null</span>) &#123;\n        <span class=\"hljs-comment\">// Ensure that if the user visible hint is set before the Fragment has</span>\n        <span class=\"hljs-comment\">// restored its state that we don&#x27;t lose the new value</span>\n        mSavedUserVisibleHint = isVisibleToUser;\n    &#125;\n&#125;</code></pre>\n<p>并且从注释中可以看到使用 FragmentTransaction#setMaxLifecycle(Fragment, Lifecycle.State)方法来替换setUserVisibleHint方法。setMaxLifecycle实在Androidx 1.1.0中新增加的一个方法。setMaxLifecycle从名字上来看意思是设置一个最大的生命周期，因为这个方法是在FragmentTransaction中，因此我们可以知道应该是为Fragment来设置一个最大的生命周期。我们来看下setMaxLifecycle的源码：</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">    * Set a ceiling for the state of an active fragment in this FragmentManager. If fragment is</span>\n<span class=\"hljs-comment\">    * already above the received state, it will be forced down to the correct state.</span>\n<span class=\"hljs-comment\">    *</span>\n<span class=\"hljs-comment\">    * &lt;p&gt;The fragment provided must currently be added to the FragmentManager to have it&#x27;s</span>\n<span class=\"hljs-comment\">    * Lifecycle state capped, or previously added as part of this transaction. The</span>\n<span class=\"hljs-comment\">    * &#123;<span class=\"hljs-doctag\">@link</span> Lifecycle.State&#125; passed in must at least be &#123;<span class=\"hljs-doctag\">@link</span> Lifecycle.State#CREATED&#125;, otherwise</span>\n<span class=\"hljs-comment\">    * an &#123;<span class=\"hljs-doctag\">@link</span> IllegalArgumentException&#125; will be thrown.&lt;/p&gt;</span>\n<span class=\"hljs-comment\">    *</span>\n<span class=\"hljs-comment\">    * <span class=\"hljs-doctag\">@param</span> fragment the fragment to have it&#x27;s state capped.</span>\n<span class=\"hljs-comment\">    * <span class=\"hljs-doctag\">@param</span> state the ceiling state for the fragment.</span>\n<span class=\"hljs-comment\">    * <span class=\"hljs-doctag\">@return</span> the same FragmentTransaction instance</span>\n<span class=\"hljs-comment\">    */</span>\n   <span class=\"hljs-meta\">@NonNull</span>\n   <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> FragmentTransaction <span class=\"hljs-title\">setMaxLifecycle</span><span class=\"hljs-params\">(<span class=\"hljs-meta\">@NonNull</span> Fragment fragment,</span></span>\n<span class=\"hljs-function\"><span class=\"hljs-params\">           <span class=\"hljs-meta\">@NonNull</span> Lifecycle.State state)</span> </span>&#123;\n       addOp(<span class=\"hljs-keyword\">new</span> Op(OP_SET_MAX_LIFECYCLE, fragment, state));\n       <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>;\n   &#125;</code></pre>\n<p>这个方法接收一个Fragment参数和一个Lifecycle的状态参数。Lifecycle是jetpack中很重要的一个库，它具有对Activity和Fragment生命周期感知能力，相信很多同学都应该对Lifecycle都略知一二。在Lifecycle的State中定义了五种生命周期状态，如下：</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">enum</span> State &#123;\n        <span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">         * Destroyed state for a LifecycleOwner. After this event, this Lifecycle will not dispatch</span>\n<span class=\"hljs-comment\">         * any more events. For instance, for an &#123;<span class=\"hljs-doctag\">@link</span> android.app.Activity&#125;, this state is reached</span>\n<span class=\"hljs-comment\">         * &lt;b&gt;right before&lt;/b&gt; Activity&#x27;s &#123;<span class=\"hljs-doctag\">@link</span> android.app.Activity#onDestroy() onDestroy&#125; call.</span>\n<span class=\"hljs-comment\">         */</span>\n        DESTROYED,\n\n        <span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">         * Initialized state for a LifecycleOwner. For an &#123;<span class=\"hljs-doctag\">@link</span> android.app.Activity&#125;, this is</span>\n<span class=\"hljs-comment\">         * the state when it is constructed but has not received</span>\n<span class=\"hljs-comment\">         * &#123;<span class=\"hljs-doctag\">@link</span> android.app.Activity#onCreate(android.os.Bundle) onCreate&#125; yet.</span>\n<span class=\"hljs-comment\">         */</span>\n        INITIALIZED,\n\n        <span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">         * Created state for a LifecycleOwner. For an &#123;<span class=\"hljs-doctag\">@link</span> android.app.Activity&#125;, this state</span>\n<span class=\"hljs-comment\">         * is reached in two cases:</span>\n<span class=\"hljs-comment\">         * &lt;ul&gt;</span>\n<span class=\"hljs-comment\">         *     &lt;li&gt;after &#123;<span class=\"hljs-doctag\">@link</span> android.app.Activity#onCreate(android.os.Bundle) onCreate&#125; call;</span>\n<span class=\"hljs-comment\">         *     &lt;li&gt;&lt;b&gt;right before&lt;/b&gt; &#123;<span class=\"hljs-doctag\">@link</span> android.app.Activity#onStop() onStop&#125; call.</span>\n<span class=\"hljs-comment\">         * &lt;/ul&gt;</span>\n<span class=\"hljs-comment\">         */</span>\n        CREATED,\n\n        <span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">         * Started state for a LifecycleOwner. For an &#123;<span class=\"hljs-doctag\">@link</span> android.app.Activity&#125;, this state</span>\n<span class=\"hljs-comment\">         * is reached in two cases:</span>\n<span class=\"hljs-comment\">         * &lt;ul&gt;</span>\n<span class=\"hljs-comment\">         *     &lt;li&gt;after &#123;<span class=\"hljs-doctag\">@link</span> android.app.Activity#onStart() onStart&#125; call;</span>\n<span class=\"hljs-comment\">         *     &lt;li&gt;&lt;b&gt;right before&lt;/b&gt; &#123;<span class=\"hljs-doctag\">@link</span> android.app.Activity#onPause() onPause&#125; call.</span>\n<span class=\"hljs-comment\">         * &lt;/ul&gt;</span>\n<span class=\"hljs-comment\">         */</span>\n        STARTED,\n\n        <span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">         * Resumed state for a LifecycleOwner. For an &#123;<span class=\"hljs-doctag\">@link</span> android.app.Activity&#125;, this state</span>\n<span class=\"hljs-comment\">         * is reached after &#123;<span class=\"hljs-doctag\">@link</span> android.app.Activity#onResume() onResume&#125; is called.</span>\n<span class=\"hljs-comment\">         */</span>\n        RESUMED;\n\n        <span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">         * Compares if this State is greater or equal to the given &#123;<span class=\"hljs-doctag\">@code</span> state&#125;.</span>\n<span class=\"hljs-comment\">         *</span>\n<span class=\"hljs-comment\">         * <span class=\"hljs-doctag\">@param</span> state State to compare with</span>\n<span class=\"hljs-comment\">         * <span class=\"hljs-doctag\">@return</span> true if this State is greater or equal to the given &#123;<span class=\"hljs-doctag\">@code</span> state&#125;</span>\n<span class=\"hljs-comment\">         */</span>\n        <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">isAtLeast</span><span class=\"hljs-params\">(<span class=\"hljs-meta\">@NonNull</span> State state)</span> </span>&#123;\n            <span class=\"hljs-keyword\">return</span> compareTo(state) &gt;= <span class=\"hljs-number\">0</span>;\n        &#125;\n    &#125;</code></pre>\n<p>而在setMaxLifecycle中接收的生命周期状态要求不能低于CREATED，否则会抛出一个IllegalArgumentException的异常。当传入参数为DESTROYED或者INITIALIZED时则会抛出如下图的异常：</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi8yOS8xNmY1MWE1NjA5MjMzYjFi?x-oss-process=image/format,png\"><br>因此除去这两个生命周期外，仅剩下CREATED、STARTED、RESUMED三个生命周期状态的参数可用，那么接下来我们就逐个来研究这三个参数的效果。</p>\n<h3 id=\"1-不设置setMaxLifecycle\"><a href=\"#1-不设置setMaxLifecycle\" class=\"headerlink\" title=\"1.不设置setMaxLifecycle\"></a>1.不设置setMaxLifecycle</h3><p>我们先来看下在不设置setMaxLifecycle的时候添加一个Fragment的状态，以便和后边的情况进行对比。首先我们在Activity中添加一个Fragment，代码如下：</p>\n<pre><code class=\"hljs kotlin\">fragment = TestLifecycleFragment.getInstance(Card.DECK[<span class=\"hljs-number\">0</span>], <span class=\"hljs-number\">0</span>)\n       <span class=\"hljs-keyword\">val</span> fragmentTransaction = supportFragmentManager.beginTransaction()\n       fragmentTransaction.add(R.id.ll_fragment, fragment)\n       fragmentTransaction.commit()</code></pre>\n<p>启动Activity，我们将该Fragment生命周期的日志打印出来如下：<br><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi8yOS8xNmY1MGFlMTVhODk1NDBi?x-oss-process=image/format,png\" alt=\"在这里插入图片描述\"><br>可以看到这个Fragment生命周期从onAttach一直执行到了onResume。并且在Activity中成功显示出了Fragment</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi8yOS8xNmY1MWE1YzJhYjRkY2Y2?x-oss-process=image/format,png\"></p>\n<h3 id=\"2-setMaxLifecycle与CREATED\"><a href=\"#2-setMaxLifecycle与CREATED\" class=\"headerlink\" title=\"2.setMaxLifecycle与CREATED\"></a>2.setMaxLifecycle与CREATED</h3><p>接下来，我们将maxLifecycle设置为CREATED：</p>\n<pre><code class=\"hljs kotlin\">fragment = TestLifecycleFragment.getInstance(Card.DECK[<span class=\"hljs-number\">0</span>], <span class=\"hljs-number\">0</span>)\n<span class=\"hljs-keyword\">val</span> fragmentTransaction = supportFragmentManager.beginTransaction()\nfragmentTransaction.add(R.id.ll_fragment, fragment)\nfragmentTransaction.setMaxLifecycle(fragment, Lifecycle.State.CREATED)\nfragmentTransaction.commit()</code></pre>\n<p>再来看日志输出：<br><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi8yOS8xNmY1MGFlMTgzYmMxMTI5?x-oss-process=image/format,png\" alt=\"在这里插入图片描述\"><br>可以看到该Fragment的生命周期仅仅执行到了onCreate就没再往下执行了。并且Activity中没有加载出来当前Fragment。</p>\n<p>那么现在问题来了，假设Fragment已经执行到了onResume,此时再为Fragment设置一个CREATED的最大生命周期会出现什么样的情况呢？我们通过日志来验证一下：</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi8yOS8xNmY1MWE3MWQ4MGY3NGFl?x-oss-process=image/format,png\"><br>从日志中可以看到已经执行了onResume的Fragment，将其最大生命周期设置为CREATED后会执行onPause-&gt;onStop-&gt;onDestoryView。也就是回退到了onCreate的状态。</p>\n<h3 id=\"3-setMaxLifecycle与STARTED\"><a href=\"#3-setMaxLifecycle与STARTED\" class=\"headerlink\" title=\"3.setMaxLifecycle与STARTED\"></a>3.setMaxLifecycle与STARTED</h3><p>接下来，我们将maxLifecycle设置为STARTED：</p>\n<pre><code class=\"hljs kotlin\">fragment = TestLifecycleFragment.getInstance(Card.DECK[<span class=\"hljs-number\">0</span>], <span class=\"hljs-number\">0</span>)\n<span class=\"hljs-keyword\">val</span> fragmentTransaction = supportFragmentManager.beginTransaction()\nfragmentTransaction.add(R.id.ll_fragment, fragment)\nfragmentTransaction.setMaxLifecycle(fragment, Lifecycle.State.STARTED)\nfragmentTransaction.commit()</code></pre>\n<p>日志输出如下：<br><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi8yOS8xNmY1MGFlMTk1Mjk3NDJl?x-oss-process=image/format,png\" alt=\"在这里插入图片描述\"><br>可以看到Fragment的生命周期执行到了onStart,并且Activity中成功显示出了当前fragment。</p>\n<p>同样，假设Fragment已经执行到了onResume方法再为其设置最大生命周期为STARTED会怎样呢？来看日志：<br><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi8yOS8xNmY1MGFlMTljODdiOGIy?x-oss-process=image/format,png\" alt=\"在这里插入图片描述\"><br>可以看到，设置最大生命周期STARTED后Fragment执行了onPause方法，也就是生命周期退回到了onStart。</p>\n<h3 id=\"4-setMaxLifecycle与RESUMED\"><a href=\"#4-setMaxLifecycle与RESUMED\" class=\"headerlink\" title=\"4.setMaxLifecycle与RESUMED\"></a>4.setMaxLifecycle与RESUMED</h3><p>最后，我们将maxLifecycle设置为RESUMED：</p>\n<pre><code class=\"hljs kotlin\">fragment = TestLifecycleFragment.getInstance(Card.DECK[<span class=\"hljs-number\">0</span>], <span class=\"hljs-number\">0</span>)\n<span class=\"hljs-keyword\">val</span> fragmentTransaction = supportFragmentManager.beginTransaction()\nfragmentTransaction.add(R.id.ll_fragment, fragment)\nfragmentTransaction.setMaxLifecycle(fragment, Lifecycle.State.RESUMED)\nfragmentTransaction.commit()</code></pre>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi8yOS8xNmY1MGFlMTljOTViZjM1?x-oss-process=image/format,png\" alt=\"在这里插入图片描述\"><br>可以看到此时和第一种情况一样的效果,Fragment的生命周期执行到了onResume。</p>\n<p>而对于已经执行了onResume后的Fragment，再去设置最大生命周期为RESUMED会怎么样呢？因为当前Fragment已经是RESUMED状态了,所以不会再去执行任何代码。</p>\n<p>到这里我们可以得出一个结论：</p>\n<blockquote>\n<p><strong>通过setMaxLifecycle方法可以精确控制Fragment生命周期的状态，如果Fragment的生命周期状态小于被设置的最大生命周期，则当前Fragment的生命周期会执行到被设置的最大生命周期，反之，如果Fragment的生命周期状态大于被设置的最大生命周期，那么则会回退到被设置的最大生命周期。</strong></p>\n</blockquote>\n<p>有了这一结论，在ViewPager中便可以对Fragment的生命周期进行控制，以此来更方便的实现延迟加载功能了。</p>\n<h2 id=\"三、Fragment延迟加载的今生\"><a href=\"#三、Fragment延迟加载的今生\" class=\"headerlink\" title=\"三、Fragment延迟加载的今生\"></a>三、Fragment延迟加载的今生</h2><h3 id=\"1、延迟加载新方案之于ViewPager\"><a href=\"#1、延迟加载新方案之于ViewPager\" class=\"headerlink\" title=\"1、延迟加载新方案之于ViewPager\"></a>1、延迟加载新方案之于ViewPager</h3><p>通过上一小节的分析我们知道了可以通过setMaxLifecycle来设置Fragment的最大生命周期，从而可以实现ViewPager中Fragment的延迟加载。当然，关于生命周期状态处理的操作无需我们自己实现，在Androidx 1.1.0版本中的FragmentStatePagerAdapter已经帮我们实现了，只需要在使用时候传进去相应的参数即可。</p>\n<p>FragmentStatePagerAdapter的构造方法接收两个参数，如下：</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">  * Constructor for &#123;<span class=\"hljs-doctag\">@link</span> FragmentStatePagerAdapter&#125;.</span>\n<span class=\"hljs-comment\">  *</span>\n<span class=\"hljs-comment\">  * If &#123;<span class=\"hljs-doctag\">@link</span> #BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT&#125; is passed in, then only the current</span>\n<span class=\"hljs-comment\">  * Fragment is in the &#123;<span class=\"hljs-doctag\">@link</span> Lifecycle.State#RESUMED&#125; state, while all other fragments are</span>\n<span class=\"hljs-comment\">  * capped at &#123;<span class=\"hljs-doctag\">@link</span> Lifecycle.State#STARTED&#125;. If &#123;<span class=\"hljs-doctag\">@link</span> #BEHAVIOR_SET_USER_VISIBLE_HINT&#125; is</span>\n<span class=\"hljs-comment\">  * passed, all fragments are in the &#123;<span class=\"hljs-doctag\">@link</span> Lifecycle.State#RESUMED&#125; state and there will be</span>\n<span class=\"hljs-comment\">  * callbacks to &#123;<span class=\"hljs-doctag\">@link</span> Fragment#setUserVisibleHint(boolean)&#125;.</span>\n<span class=\"hljs-comment\">  *</span>\n<span class=\"hljs-comment\">  * <span class=\"hljs-doctag\">@param</span> fm fragment manager that will interact with this adapter</span>\n<span class=\"hljs-comment\">  * <span class=\"hljs-doctag\">@param</span> behavior determines if only current fragments are in a resumed state</span>\n<span class=\"hljs-comment\">  */</span>\n <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">FragmentStatePagerAdapter</span><span class=\"hljs-params\">(<span class=\"hljs-meta\">@NonNull</span> FragmentManager fm,</span></span>\n<span class=\"hljs-function\"><span class=\"hljs-params\">         <span class=\"hljs-meta\">@Behavior</span> <span class=\"hljs-keyword\">int</span> behavior)</span> </span>&#123;\n     mFragmentManager = fm;\n     mBehavior = behavior;\n &#125;</code></pre>\n<p>第一个FragmentManager 参数不必多说，第二个参数时一个枚举类型的Behavior参数，其可选值如下：</p>\n<pre><code class=\"hljs kotlin\"><span class=\"hljs-meta\">@Retention(RetentionPolicy.SOURCE)</span>\n<span class=\"hljs-meta\">@IntDef(&#123;BEHAVIOR_SET_USER_VISIBLE_HINT, BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT&#125;)</span>\n<span class=\"hljs-keyword\">private</span> <span class=\"hljs-meta\">@interface</span> Behavior &#123; &#125;</code></pre>\n<p>当behavior为BEHAVIOR_SET_USER_VISIBLE_HINT时，Fragment改变的时候，setUserVisibleHint方法会被调用，也就是这个参数其实是为了兼容以前的老代码。并且BEHAVIOR_SET_USER_VISIBLE_HINT参数已经被置为废弃。所以我们的可选参数只剩下了BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT。</p>\n<p>当behavior为BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT时意味着只有当前显示的Fragment会被执行到onResume，而其它Fragment的生命周期都只会执行到onStart.</p>\n<p>这一功能时如何实现的呢？我们追随BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT的脚步找到了setPrimaryItem方法，这个方法的作用是设置ViewPager当前显示的Item，其源码如下：</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">setPrimaryItem</span><span class=\"hljs-params\">(<span class=\"hljs-meta\">@NonNull</span> ViewGroup container, <span class=\"hljs-keyword\">int</span> position, <span class=\"hljs-meta\">@NonNull</span> Object object)</span> </span>&#123;\n        Fragment fragment = (Fragment)object;\n        <span class=\"hljs-keyword\">if</span> (fragment != mCurrentPrimaryItem) &#123;\n            <span class=\"hljs-keyword\">if</span> (mCurrentPrimaryItem != <span class=\"hljs-keyword\">null</span>) &#123;\n                mCurrentPrimaryItem.setMenuVisibility(<span class=\"hljs-keyword\">false</span>);\n                <span class=\"hljs-keyword\">if</span> (mBehavior == BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT) &#123;\n                    <span class=\"hljs-keyword\">if</span> (mCurTransaction == <span class=\"hljs-keyword\">null</span>) &#123;\n                        mCurTransaction = mFragmentManager.beginTransaction();\n                    &#125;\n                    mCurTransaction.setMaxLifecycle(mCurrentPrimaryItem, Lifecycle.State.STARTED);\n                &#125; <span class=\"hljs-keyword\">else</span> &#123;\n                    mCurrentPrimaryItem.setUserVisibleHint(<span class=\"hljs-keyword\">false</span>);\n                &#125;\n            &#125;\n            fragment.setMenuVisibility(<span class=\"hljs-keyword\">true</span>);\n            <span class=\"hljs-keyword\">if</span> (mBehavior == BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT) &#123;\n                <span class=\"hljs-keyword\">if</span> (mCurTransaction == <span class=\"hljs-keyword\">null</span>) &#123;\n                    mCurTransaction = mFragmentManager.beginTransaction();\n                &#125;\n                mCurTransaction.setMaxLifecycle(fragment, Lifecycle.State.RESUMED);\n            &#125; <span class=\"hljs-keyword\">else</span> &#123;\n                fragment.setUserVisibleHint(<span class=\"hljs-keyword\">true</span>);\n            &#125;\n\n            mCurrentPrimaryItem = fragment;\n        &#125;\n    &#125;</code></pre>\n<p>这段代码非常简单易懂，mCurrentPrimaryItem是当前正在显示的item，fragment是接下来要显示的item。可以看到当mBehavior 为BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT时，mCurrentPrimaryItem的最大生命周期被设置为了STARTED，而fragment的最大生命周期则被设置为了RESUMED。而当mBehavior为BEHAVIOR_SET_USER_VISIBLE_HINT时仍然会调用setUserVisibleHint方法，这种情况就不再讨论，因为BEHAVIOR_SET_USER_VISIBLE_HINT也已经被废弃掉了。<br>那么我们着重来分析一下BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT时的情况：</p>\n<p><strong>mCurrentPrimaryItem是当前显示的Fragment，所以该Fragment必然已经执行到了onResume方法，而此时为其设置了最大生命周期STARTED，那么mCurrentPrimaryItem必然会执行onPause退回到STARTED状态。<br>而fragment当前生命周期状态为onStart，当为其设置了RESUME的最大生命周期状态后,fragment必然会执行onResume方法进入RESUMED状态。</strong></p>\n<p>知道了这一结论后，我们再去进行懒加载的控制是不是就异常简单了？此时我们只需要一个flag去标志是否是第一次加载数据就可以了。因此，懒加载的实现可以如下：</p>\n<pre><code class=\"hljs kotlin\"><span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">TestLifecycleFragment</span> : <span class=\"hljs-type\">Fragment</span></span>() &#123;\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">var</span> isFirstLoad = <span class=\"hljs-literal\">true</span>\n\n    <span class=\"hljs-keyword\">override</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">onResume</span><span class=\"hljs-params\">()</span></span> &#123;\n        <span class=\"hljs-keyword\">super</span>.onResume()\n        <span class=\"hljs-keyword\">if</span> (isFirstLoad) &#123;\n        \tisFirstLoad = <span class=\"hljs-literal\">false</span>\n            loadData()\n        &#125;\n    &#125;\n\n    <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">loadData</span><span class=\"hljs-params\">()</span></span>\n&#125;</code></pre>\n\n<h3 id=\"2、延迟加载之于ViewPager2\"><a href=\"#2、延迟加载之于ViewPager2\" class=\"headerlink\" title=\"2、延迟加载之于ViewPager2\"></a>2、延迟加载之于ViewPager2</h3><p>上篇文章<a href=\"https://juejin.im/post/5df4aabe6fb9a0161104c8eb\">《学不动也要学！深入了解ViewPager2》</a>中我们对ViewPager2有了比较深入的了解,其中在讲解ViewPager2的offScreenPageLimit时候得出过这样一个结论:</p>\n<blockquote>\n<p>ViewPager2的offScreenPageLimit默认值为OFFSCREEN_PAGE_LIMIT_DEFAULT,当setOffscreenPageLimit为OFFSCREEN_PAGE_LIMIT_DEFAULT时候会使用RecyclerView的缓存机制。默认只会加载当前显示的Fragment,而不会像ViewPager一样至少预加载一个item.当切换到下一个item的时候，当前Fragment会执行onPause方法，而下一个Fragment则会从onCreate一直执行到onResume。当再次滑动回第一个页面的时候当前页面同样会执行onPuase，而第一个页面会执行onResume。</p>\n</blockquote>\n<p>也就是说在ViewPager2中，默认关闭了预加载机制。没有了预加载机制再谈延迟加载其实也没有任何意义了。所以关于ViewPager2的延迟加载也就不用多说了吧？只需要将网络请求放到onStart中即可。相信随着ViewPager2的普及延迟加载的概念也会慢慢淡出开发者的视线。</p>\n<p><strong>2020/1/4补充：</strong></p>\n<p>如果为ViewPager2设置了offScreenPageLimit(1)那结果会是怎样的呢？我们来看日志：</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC8xLzQvMTZmNzA3MTBjOTY1M2Y1Nw?x-oss-process=image/format,png\"><br>从日志中可以看到ViewPager2预加载了一个Fragment，并且预加载的Fragment的生命周期仅仅执行到了onStart。所以此处我们可以猜测在FragmentStateAdapter中一定设置了setMaxLifecycle(fragment, STARTED)，具体源码不再贴出，大家可以自行查看。因此，此时处理懒加载问题其实和ViewPager的懒加载新方案如出一辙了，仅仅需要添加一个boolean值即可。</p>\n<h2 id=\"三、总结\"><a href=\"#三、总结\" class=\"headerlink\" title=\"三、总结\"></a>三、总结</h2><p>本篇文章对于Fragment的延迟加载进行了深入的探究，并且了解了在Androidx 1.1.0版本中对Fragment最大生命周期状态的控制，从而探究出了Fragment延迟加载的新方案。对于ViewPager2，因其默认不会进行预加载因此也就意味着我们无需处理ViewPager2的延迟加载问题。好了，这一篇花费了我两个周末（其实是上周末写了一半偷了个懒）的文章到此就结束了，如果你从中学有所收获那么请你不要吝啬留下你的赞。</p>\n<p><a href=\"https://github.com/zhpanvip/ViewPagerSample\">本文涉及源码</a></p>\n","site":{"data":{"fluid_config":{"favicon":"/img/favicon.png","apple_touch_icon":"/img/favicon.png","title_join_string":" - ","force_https":false,"highlight":{"enable":true,"style":"Github Gist","bg_color":false,"copy_btn":true},"fun_features":{"typing":{"enable":true,"typeSpeed":70,"cursorChar":"|","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"mouse_click":{"enable":false,"style":"values"}},"dark_mode":{"enable":true,"default":"auto"},"color":{"body_bg_color":"#eee","body_bg_color_dark":"#181c27","navbar_bg_color":"#2f4154","navbar_bg_color_dark":"#1f3144","navbar_text_color":"#fff","navbar_text_color_dark":"#d0d0d0","text_color":"#3c4858","text_color_dark":"#c4c6c9","sec_text_color":"#718096","sec_text_color_dark":"#a7a9ad","post_text_color":"#2c3e50","post_text_color_dark":"#c4c6c9","post_heading_color":"#1a202c","post_heading_color_dark":"#c4c6c9","post_link_color":"#0366d6","post_link_color_dark":"#1589e9","link_hover_color":"#30a9de","link_hover_color_dark":"#30a9de","link_hover_bg_color":"#f8f9fa","link_hover_bg_color_dark":"#364151","board_color":"#fff","board_color_dark":"#252d38"},"font":{"font_size":"16px","font_family":null,"code_font_size":"85%"},"custom_js":null,"custom_css":null,"custom_html":"","web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"tajs":null,"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}},"lazyload":{"enable":true,"onlypost":false},"daovoice":{"enable":false,"appid":""},"aplayer":{"enable":false,"autoplay":false,"loop":"all","order":"random","theme":"#b7daff","songs":[{"name":"name","artist":"artist","url":"/songs/test.mp3","cover":"/img/cover.jpg"},{"name":"name","artist":"artist","url":"https://...url.mp3","cover":"https://...cover.jpg"}]},"version":{"check":false},"navbar":{"blog_title":"zhangpan","ground_glass":{"enable":false,"px":3,"alpha":0.7},"menu":[{"key":"home","link":"/","icon":"iconfont icon-home-fill"},{"key":"archive","link":"/archives/","icon":"iconfont icon-archive-fill"},{"key":"category","link":"/categories/","icon":"iconfont icon-category-fill"},{"key":"tag","link":"/tags/","icon":"iconfont icon-tags-fill"},{"key":"about","link":"/about/","icon":"iconfont icon-user-fill"}]},"search":{"enable":true,"path":"/local-search.xml","generate_path":"/local-search.xml","field":"post","content":true},"scroll_down_arrow":{"enable":true,"banner_height_limit":90,"scroll_after_turning_page":true},"banner_parallax":true,"footer":{"statistics":{"enable":false,"source":"busuanzi","pv_format":"总访问量 {} 次","uv_format":"总访客数 {} 人"},"beian":{"enable":false,"icp_text":"京ICP证123456号","police_text":"京公网安备12345678号","police_code":12345678,"police_icon":"/img/police_beian.png"}},"scroll_top_arrow":{"enable":true},"index":{"banner_img":"/img/default.png","banner_img_height":100,"banner_mask_alpha":0.3,"post_default_img":"","slogan":{"enable":true,"text":"Talk is cheap, show me the code."},"auto_excerpt":{"enable":true},"post_url_target":"_self","post_meta":{"date":true,"category":true,"tag":true}},"page":{"banner_img":"/img/default.png","banner_img_height":60,"banner_mask_alpha":0.3},"post":{"banner_img":"/img/default.png","banner_img_height":70,"banner_mask_alpha":0.3,"meta":{"date":{"enable":true,"format":"LL a"},"wordcount":{"enable":true,"format":"{} 字"},"min2read":{"enable":true,"format":"{} 分钟","words":100},"views":{"enable":false,"source":"busuanzi","format":"{} 次"}},"updated":{"enable":false,"content":"本文最后更新于：","relative":false},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"copyright":{"enable":true,"content":"本博客所有文章除特别声明外，均采用 <a href=\"https://creativecommons.org/licenses/by-sa/4.0/deed.zh\" rel=\"nofollow noopener\">CC BY-SA 4.0 协议</a> ，转载请注明出处！ <h5>开源库推荐</h5> <a href=\"https://github.com/zhpanvip/BannerViewPager\">1.BannerViewPager</a> <p> 一个基于ViewPager2实现的具有强大功能的无限轮播库。支持多种页面切换效果和指示器样式。 </p>\n<a href=\"https://github.com/zhpanvip/viewpagerindicator\">2.ViewPagerIndicator</a> <p> 一个适用于ViewPager和ViewPager2的指示器，支持多种滑块样式及滑动模式 </p>"},"prev_next":{"enable":true},"custom":{"enable":false,"content":"<img src=\"https://octodex.github.com/images/jetpacktocat.png\" class=\"rounded mx-auto d-block mt-5\" style=\"width:150px; height:150px;\">"},"image_zoom":{"enable":true},"footnote":{"enable":true,"header":""},"math":{"enable":false,"specific":false,"engine":"mathjax"},"mermaid":{"enable":false,"specific":false,"options":{"theme":"default"}},"comments":{"enable":true,"type":"utterances"}},"utterances":{"repo":"zhpanvip/utterances-comment","issue_term":"pathname","label":"utterances","theme":"github-light","crossorigin":"anonymous"},"disqus":{"shortname":null,"disqusjs":false,"apikey":null},"gitalk":{"clientID":null,"clientSecret":null,"repo":null,"owner":null,"admin":["name"],"id":"location.pathname","language":"zh-CN","labels":["Gitalk"],"perPage":10,"pagerDirection":"last","distractionFreeMode":false,"createIssueManually":true},"valine":{"appid":"hXIROaIM5y9qnieojJRWP5hS","appkey":"y0f3w3aqd1MF7JL9ma4WECTy","placeholder":"说点什么","path":"window.location.pathname","avatar":"retro","meta":["nick","mail","link"],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"https://zhangpan.site"},"changyan":{"appid":"","appkey":""},"livere":{"uid":""},"archive":{"banner_img":"/img/bg_article.jpg","banner_img_height":60,"banner_mask_alpha":0.3,"subtitle":null},"category":{"banner_img":"/img/bg_default.png","banner_img_height":60,"banner_mask_alpha":0.3,"subtitle":null,"post_limit":10,"order_by":"-length"},"tag":{"banner_img":"/img/bg_label.jpg","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null,"tagcloud":{"min_font":15,"max_font":30,"unit":"px","start_color":"#BBBBEE","end_color":"#337ab7"}},"about":{"banner_img":"/img/bg_default.png","banner_img_height":60,"banner_mask_alpha":0.3,"subtitle":null,"avatar":"/img/avatar.png","name":"myname","introduce":"一句简短的介绍","icons":[{"class":"iconfont icon-github-fill","link":"https://github.com","tip":"GitHub"},{"class":"iconfont icon-douban-fill","link":"https://douban.com","tip":"豆瓣"},{"class":"iconfont icon-wechat-fill","qrcode":"/img/favicon.png"}]},"page404":{"banner_img":"/img/default.png","banner_img_height":85,"banner_mask_alpha":0.3,"subtitle":"Page not found"},"links":{"banner_img":"/img/default.png","banner_img_height":60,"banner_mask_alpha":0.3,"subtitle":null,"items":[{"title":"Fluid Docs","intro":"主题使用指南","link":"https://hexo.fluid-dev.com/docs/","image":"/img/favicon.png"},{"title":"Fluid Repo","intro":"主题 GitHub 仓库","link":"https://github.com/fluid-dev/hexo-theme-fluid","image":"/img/favicon.png"},{"title":"Fluid Example","intro":"主题操作示例","link":"https://hexo.fluid-dev.com/docs/example/","image":"/img/favicon.png"}]}}}},"excerpt":"","more":"<p>上周在<a href=\"https://juejin.im/post/5df4aabe6fb9a0161104c8eb\">《学不动也要学！深入了解ViewPager2》</a>一篇文章的留言中，大家普遍对于Fragment懒加载的问题比较关心。其实，对于Fragment懒加载问题的处理由来已久，网上不乏相关的优秀文章。但是，由于Fragment生命周期的原因使得懒加载问题的处理并不是那么的优雅。显然，Google也意识到了问题所在。因此，在Androidx的库中对于Fragment的生命周期状态的控制进行了深度优化，使得我们更容易的去管控Fragment的生命周期，也使得我们更容易的去处理懒加载问题。但是，前提条件是我们要了解Google对于Fragment做了哪些优化。那么就让我们借此机会一起来探究一下吧！（ <strong><em>懒加载称作延迟加载我觉得更贴切一些，所以下文就统称为延迟加载了。</em></strong> ）</p>\n<h2 id=\"一、Fragment延迟加载的前世\"><a href=\"#一、Fragment延迟加载的前世\" class=\"headerlink\" title=\"一、Fragment延迟加载的前世\"></a>一、Fragment延迟加载的前世</h2><p>虽然本篇文章是对于Fragment新特性的探究，但是我觉得写文章总要有个因果。也为了照顾一下还不太了解什么是延迟加载的同学。我们还是先来了解一下延迟加载，顺便回顾一下Fragment延迟加载的旧方案。</p>\n<h3 id=\"1-为什么要对Fragment做延迟加载\"><a href=\"#1-为什么要对Fragment做延迟加载\" class=\"headerlink\" title=\"1.为什么要对Fragment做延迟加载?\"></a>1.为什么要对Fragment做延迟加载?</h3><p>首先，我们要搞清楚一个问题。“Fragment延迟加载“中的“延迟”并不指的是延迟加载Fragment，而是延迟加载Fragment中的数据。对于Fragment的使用通常我们会结合ViewPager。在<a href=\"https://juejin.im/post/5df4aabe6fb9a0161104c8eb\">《学不动也要学！深入了解ViewPager2》</a>一文中我们也提到ViewPager的预加载问题。ViewPager会默认在当前页面的左右两边至少预加载一个页面以保证ViewPager的流畅性。我们假设在ViewPager的所有Fragment中都存在网络请求。当我们打开这个页面的时候由于ViewPager的预加载原因，即使在其它Fragment不可见的情况下也会去进行网络请求加载数据。而如果此时用户根本就没有去滑动ViewPager就退出了应用或者切换到了其他页面。那么对于这个不可见的Fragment中的网络请求岂不是既浪费了流量也浪费了手机和服务器的性能？</p>\n<p>那么此时有的同学就有问题了。你就不能在Fragment显示的时候去加载数据吗?问的好！在解答之前我们先来看下Fragment的生命周期<br><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi8yOS8xNmY1MGFlMTUwMGM3ZDFk?x-oss-process=image/format,png\" alt=\"在这里插入图片描述\"><br>想必这张图大家应该都非常熟悉了。当Fragment被预加载的时候，此Fragment的生命周期会从onAttach执行到onResume。显然我们无法通过Fragment的生命周期来控制Fragment的延迟加载。那么该怎么办呢？我们且往下看。</p>\n<h3 id=\"2-如何处理Fragment的延迟加载？\"><a href=\"#2-如何处理Fragment的延迟加载？\" class=\"headerlink\" title=\"2.如何处理Fragment的延迟加载？\"></a>2.如何处理Fragment的延迟加载？</h3><p>通过上一小节的分析我们知道想要在Fragment的生命周期中处理延迟加载的问题显然是走不通的。所以想要处理Fragment的延迟加载就需要另想它法了。还好，在Fragment中为我们提供了一个setUserVisibleHint(isVisibleToUser: Boolean)的方法，这个方法中有一个isVisibleToUser的boolean类型的参数，其意义表示当前的Fragment是否对用户可见。因此，对于Fragment的延迟加载我们便可以通过这个方法来展开。<br>既然要使用setUserVisibleHint(isVisibleToUser: Boolean)那么就应该知道这个方法的调用时机。我们写一个ViewPager嵌套Fragment的例子来打印下日志：</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi8yOS8xNmY1MWE0N2UzMDg1Mzdk?x-oss-process=image/format,png\"><br><em>注：上图打印的日志中”position:0“表示当前Fragment，“position:1”表示预加载的Fragment，下同。</em></p>\n<p>可见该方法是在Fragment的onAttach之前就已经被调用了。因此，对于延迟加载我们可以在setUserVisibleHint(isVisibleToUser: Boolean)方法及onViewCreated(view: View, savedInstanceState: Bundle?)添加标志位来控制是否加载数据。我们来看下代码：</p>\n<pre><code class=\"hljs kotlin\"><span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">BaseLazyFragment</span> : <span class=\"hljs-type\">Fragment</span></span>() &#123;\n    <span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">     * 当前Fragment状态是否可见</span>\n<span class=\"hljs-comment\">     */</span>\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">var</span> isVisibleToUser: <span class=\"hljs-built_in\">Boolean</span> = <span class=\"hljs-literal\">false</span>\n    <span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">     * 是否已创建View</span>\n<span class=\"hljs-comment\">     */</span>\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">var</span> isViewCreated: <span class=\"hljs-built_in\">Boolean</span> = <span class=\"hljs-literal\">false</span>\n    <span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">     * 是否第一次加载数据</span>\n<span class=\"hljs-comment\">     */</span>\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">var</span> isFirstLoad = <span class=\"hljs-literal\">true</span>\n\n    <span class=\"hljs-keyword\">override</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">setUserVisibleHint</span><span class=\"hljs-params\">(isVisibleToUser: <span class=\"hljs-type\">Boolean</span>)</span></span> &#123;\n        <span class=\"hljs-keyword\">super</span>.setUserVisibleHint(isVisibleToUser)\n        <span class=\"hljs-keyword\">this</span>.isVisibleToUser = isVisibleToUser\n        onLazyLoad()\n    &#125;\n\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">onLazyLoad</span><span class=\"hljs-params\">()</span></span> &#123;\n        <span class=\"hljs-keyword\">if</span> (isVisibleToUser &amp;&amp; isViewCreated &amp;&amp; isFirstLoad) &#123;\n            isFirstLoad = <span class=\"hljs-literal\">false</span>\n            lazyLoad()\n        &#125;\n    &#125;\n\n    <span class=\"hljs-keyword\">override</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">onViewCreated</span><span class=\"hljs-params\">(view: <span class=\"hljs-type\">View</span>, savedInstanceState: <span class=\"hljs-type\">Bundle</span>?)</span></span> &#123;\n        <span class=\"hljs-keyword\">super</span>.onViewCreated(view, savedInstanceState)\n        isViewCreated = <span class=\"hljs-literal\">true</span>\n        onLazyLoad()\n    &#125;\n\n    <span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">lazyLoad</span><span class=\"hljs-params\">()</span></span>\n\n&#125;</code></pre>\n<p>我们通过在Fragment中添加了三个标志位实现了延迟加载的功能。我们到TestFragment尝试一下：</p>\n<pre><code class=\"hljs kotlin\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">TestFragment</span> : <span class=\"hljs-type\">BaseLazyFragment</span></span>() &#123;\n\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">var</span> position: <span class=\"hljs-built_in\">Int</span> = <span class=\"hljs-number\">0</span>\n\n    <span class=\"hljs-keyword\">override</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">setUserVisibleHint</span><span class=\"hljs-params\">(isVisibleToUser: <span class=\"hljs-type\">Boolean</span>)</span></span> &#123;\n        <span class=\"hljs-keyword\">super</span>.setUserVisibleHint(isVisibleToUser)\n        <span class=\"hljs-keyword\">val</span> bundle = arguments\n        position = bundle!!.getInt(KEY_POSITION)\n    &#125;\n\n    <span class=\"hljs-keyword\">override</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">onCreateView</span><span class=\"hljs-params\">(inflater: <span class=\"hljs-type\">LayoutInflater</span>, container: <span class=\"hljs-type\">ViewGroup</span>?, savedInstanceState: <span class=\"hljs-type\">Bundle</span>?)</span></span>: View? &#123;\n        <span class=\"hljs-keyword\">val</span> cardView = CardView(inflater, container)\n        cardView.bind(Card.fromBundle(arguments!!),position)\n        <span class=\"hljs-keyword\">return</span> cardView.view\n    &#125;\n\n    <span class=\"hljs-keyword\">companion</span> <span class=\"hljs-keyword\">object</span> &#123;\n\n        <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">val</span> KEY_POSITION = <span class=\"hljs-string\">&quot;position&quot;</span>\n\n        <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">getInstance</span><span class=\"hljs-params\">(card: <span class=\"hljs-type\">Card</span>, position: <span class=\"hljs-type\">Int</span>)</span></span>: TestFragment &#123;\n            <span class=\"hljs-keyword\">val</span> fragment = TestFragment()\n            <span class=\"hljs-keyword\">val</span> bundle = card.toBundle()\n            bundle.putInt(KEY_POSITION, position)\n            fragment.arguments = bundle\n            <span class=\"hljs-keyword\">return</span> fragment\n        &#125;\n    &#125;\n\n    <span class=\"hljs-keyword\">override</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">lazyLoad</span><span class=\"hljs-params\">()</span></span> &#123;\n        showToast(<span class=\"hljs-string\">&quot;Fragment<span class=\"hljs-variable\">$position</span> is loading data&quot;</span>)\n    &#125;\n\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">showToast</span><span class=\"hljs-params\">(content: <span class=\"hljs-type\">String</span>)</span></span> &#123;\n        Toast.makeText(context, content, Toast.LENGTH_SHORT).show()\n    &#125;\n\n&#125;\n</code></pre>\n\n<p>我们来看下效果：<br><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi8yOS8xNmY1MGFlMTUwMjk5Njk2?x-oss-process=image/format,png\" alt=\"在这里插入图片描述\"><br>嗯！立竿见影，只有当Fragment完全显示出来的时候loading data的操作才被执行。这种延迟加载的方案在Androidx 1.1.0版本以前被广泛应用。而在Androidx 1.1.0版本中，Google对于Fragment进行了优化处理，使得延迟加载也有了新的解决方案。</p>\n<h2 id=\"二、Fragment的setMaxLifecycle探究\"><a href=\"#二、Fragment的setMaxLifecycle探究\" class=\"headerlink\" title=\"二、Fragment的setMaxLifecycle探究\"></a>二、Fragment的setMaxLifecycle探究</h2><p>上一节中我们讲到因为ViewPager的预加载机制以及Fragment的生命周期无法得以控制，我们不得不通过setUserVisibleHint(isVisibleToUser: Boolean)和onViewCreated(view: View, savedInstanceState: Bundle?)方法以及添加三个标志位来处理延迟加载，显然这样的代码并不优雅。</p>\n<p>当我们将Android项目迁移到Androidx并将androidx版本升级到1.1.0之后发现，我们第一节中用到的setUserVisibleHint(isVisibleToUser: Boolean)方法已被标记为废弃了！<br><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi8yOS8xNmY1MGFlMTUwNWY2NjU0?x-oss-process=image/format,png\" alt=\"在这里插入图片描述\"></p>\n<pre><code class=\"hljs java\"> <span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\"> * ... 省略其它注释</span>\n<span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@deprecated</span> Use &#123;<span class=\"hljs-doctag\">@link</span> FragmentTransaction#setMaxLifecycle(Fragment, Lifecycle.State)&#125;</span>\n<span class=\"hljs-comment\"> * instead.</span>\n<span class=\"hljs-comment\"> */</span>\n<span class=\"hljs-meta\">@Deprecated</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">setUserVisibleHint</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">boolean</span> isVisibleToUser)</span> </span>&#123;\n    <span class=\"hljs-keyword\">if</span> (!mUserVisibleHint &amp;&amp; isVisibleToUser &amp;&amp; mState &lt; STARTED\n            &amp;&amp; mFragmentManager != <span class=\"hljs-keyword\">null</span> &amp;&amp; isAdded() &amp;&amp; mIsCreated) &#123;\n        mFragmentManager.performPendingDeferredStart(<span class=\"hljs-keyword\">this</span>);\n    &#125;\n    mUserVisibleHint = isVisibleToUser;\n    mDeferStart = mState &lt; STARTED &amp;&amp; !isVisibleToUser;\n    <span class=\"hljs-keyword\">if</span> (mSavedFragmentState != <span class=\"hljs-keyword\">null</span>) &#123;\n        <span class=\"hljs-comment\">// Ensure that if the user visible hint is set before the Fragment has</span>\n        <span class=\"hljs-comment\">// restored its state that we don&#x27;t lose the new value</span>\n        mSavedUserVisibleHint = isVisibleToUser;\n    &#125;\n&#125;</code></pre>\n<p>并且从注释中可以看到使用 FragmentTransaction#setMaxLifecycle(Fragment, Lifecycle.State)方法来替换setUserVisibleHint方法。setMaxLifecycle实在Androidx 1.1.0中新增加的一个方法。setMaxLifecycle从名字上来看意思是设置一个最大的生命周期，因为这个方法是在FragmentTransaction中，因此我们可以知道应该是为Fragment来设置一个最大的生命周期。我们来看下setMaxLifecycle的源码：</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">    * Set a ceiling for the state of an active fragment in this FragmentManager. If fragment is</span>\n<span class=\"hljs-comment\">    * already above the received state, it will be forced down to the correct state.</span>\n<span class=\"hljs-comment\">    *</span>\n<span class=\"hljs-comment\">    * &lt;p&gt;The fragment provided must currently be added to the FragmentManager to have it&#x27;s</span>\n<span class=\"hljs-comment\">    * Lifecycle state capped, or previously added as part of this transaction. The</span>\n<span class=\"hljs-comment\">    * &#123;<span class=\"hljs-doctag\">@link</span> Lifecycle.State&#125; passed in must at least be &#123;<span class=\"hljs-doctag\">@link</span> Lifecycle.State#CREATED&#125;, otherwise</span>\n<span class=\"hljs-comment\">    * an &#123;<span class=\"hljs-doctag\">@link</span> IllegalArgumentException&#125; will be thrown.&lt;/p&gt;</span>\n<span class=\"hljs-comment\">    *</span>\n<span class=\"hljs-comment\">    * <span class=\"hljs-doctag\">@param</span> fragment the fragment to have it&#x27;s state capped.</span>\n<span class=\"hljs-comment\">    * <span class=\"hljs-doctag\">@param</span> state the ceiling state for the fragment.</span>\n<span class=\"hljs-comment\">    * <span class=\"hljs-doctag\">@return</span> the same FragmentTransaction instance</span>\n<span class=\"hljs-comment\">    */</span>\n   <span class=\"hljs-meta\">@NonNull</span>\n   <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> FragmentTransaction <span class=\"hljs-title\">setMaxLifecycle</span><span class=\"hljs-params\">(<span class=\"hljs-meta\">@NonNull</span> Fragment fragment,</span></span>\n<span class=\"hljs-function\"><span class=\"hljs-params\">           <span class=\"hljs-meta\">@NonNull</span> Lifecycle.State state)</span> </span>&#123;\n       addOp(<span class=\"hljs-keyword\">new</span> Op(OP_SET_MAX_LIFECYCLE, fragment, state));\n       <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>;\n   &#125;</code></pre>\n<p>这个方法接收一个Fragment参数和一个Lifecycle的状态参数。Lifecycle是jetpack中很重要的一个库，它具有对Activity和Fragment生命周期感知能力，相信很多同学都应该对Lifecycle都略知一二。在Lifecycle的State中定义了五种生命周期状态，如下：</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">enum</span> State &#123;\n        <span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">         * Destroyed state for a LifecycleOwner. After this event, this Lifecycle will not dispatch</span>\n<span class=\"hljs-comment\">         * any more events. For instance, for an &#123;<span class=\"hljs-doctag\">@link</span> android.app.Activity&#125;, this state is reached</span>\n<span class=\"hljs-comment\">         * &lt;b&gt;right before&lt;/b&gt; Activity&#x27;s &#123;<span class=\"hljs-doctag\">@link</span> android.app.Activity#onDestroy() onDestroy&#125; call.</span>\n<span class=\"hljs-comment\">         */</span>\n        DESTROYED,\n\n        <span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">         * Initialized state for a LifecycleOwner. For an &#123;<span class=\"hljs-doctag\">@link</span> android.app.Activity&#125;, this is</span>\n<span class=\"hljs-comment\">         * the state when it is constructed but has not received</span>\n<span class=\"hljs-comment\">         * &#123;<span class=\"hljs-doctag\">@link</span> android.app.Activity#onCreate(android.os.Bundle) onCreate&#125; yet.</span>\n<span class=\"hljs-comment\">         */</span>\n        INITIALIZED,\n\n        <span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">         * Created state for a LifecycleOwner. For an &#123;<span class=\"hljs-doctag\">@link</span> android.app.Activity&#125;, this state</span>\n<span class=\"hljs-comment\">         * is reached in two cases:</span>\n<span class=\"hljs-comment\">         * &lt;ul&gt;</span>\n<span class=\"hljs-comment\">         *     &lt;li&gt;after &#123;<span class=\"hljs-doctag\">@link</span> android.app.Activity#onCreate(android.os.Bundle) onCreate&#125; call;</span>\n<span class=\"hljs-comment\">         *     &lt;li&gt;&lt;b&gt;right before&lt;/b&gt; &#123;<span class=\"hljs-doctag\">@link</span> android.app.Activity#onStop() onStop&#125; call.</span>\n<span class=\"hljs-comment\">         * &lt;/ul&gt;</span>\n<span class=\"hljs-comment\">         */</span>\n        CREATED,\n\n        <span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">         * Started state for a LifecycleOwner. For an &#123;<span class=\"hljs-doctag\">@link</span> android.app.Activity&#125;, this state</span>\n<span class=\"hljs-comment\">         * is reached in two cases:</span>\n<span class=\"hljs-comment\">         * &lt;ul&gt;</span>\n<span class=\"hljs-comment\">         *     &lt;li&gt;after &#123;<span class=\"hljs-doctag\">@link</span> android.app.Activity#onStart() onStart&#125; call;</span>\n<span class=\"hljs-comment\">         *     &lt;li&gt;&lt;b&gt;right before&lt;/b&gt; &#123;<span class=\"hljs-doctag\">@link</span> android.app.Activity#onPause() onPause&#125; call.</span>\n<span class=\"hljs-comment\">         * &lt;/ul&gt;</span>\n<span class=\"hljs-comment\">         */</span>\n        STARTED,\n\n        <span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">         * Resumed state for a LifecycleOwner. For an &#123;<span class=\"hljs-doctag\">@link</span> android.app.Activity&#125;, this state</span>\n<span class=\"hljs-comment\">         * is reached after &#123;<span class=\"hljs-doctag\">@link</span> android.app.Activity#onResume() onResume&#125; is called.</span>\n<span class=\"hljs-comment\">         */</span>\n        RESUMED;\n\n        <span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">         * Compares if this State is greater or equal to the given &#123;<span class=\"hljs-doctag\">@code</span> state&#125;.</span>\n<span class=\"hljs-comment\">         *</span>\n<span class=\"hljs-comment\">         * <span class=\"hljs-doctag\">@param</span> state State to compare with</span>\n<span class=\"hljs-comment\">         * <span class=\"hljs-doctag\">@return</span> true if this State is greater or equal to the given &#123;<span class=\"hljs-doctag\">@code</span> state&#125;</span>\n<span class=\"hljs-comment\">         */</span>\n        <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">isAtLeast</span><span class=\"hljs-params\">(<span class=\"hljs-meta\">@NonNull</span> State state)</span> </span>&#123;\n            <span class=\"hljs-keyword\">return</span> compareTo(state) &gt;= <span class=\"hljs-number\">0</span>;\n        &#125;\n    &#125;</code></pre>\n<p>而在setMaxLifecycle中接收的生命周期状态要求不能低于CREATED，否则会抛出一个IllegalArgumentException的异常。当传入参数为DESTROYED或者INITIALIZED时则会抛出如下图的异常：</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi8yOS8xNmY1MWE1NjA5MjMzYjFi?x-oss-process=image/format,png\"><br>因此除去这两个生命周期外，仅剩下CREATED、STARTED、RESUMED三个生命周期状态的参数可用，那么接下来我们就逐个来研究这三个参数的效果。</p>\n<h3 id=\"1-不设置setMaxLifecycle\"><a href=\"#1-不设置setMaxLifecycle\" class=\"headerlink\" title=\"1.不设置setMaxLifecycle\"></a>1.不设置setMaxLifecycle</h3><p>我们先来看下在不设置setMaxLifecycle的时候添加一个Fragment的状态，以便和后边的情况进行对比。首先我们在Activity中添加一个Fragment，代码如下：</p>\n<pre><code class=\"hljs kotlin\">fragment = TestLifecycleFragment.getInstance(Card.DECK[<span class=\"hljs-number\">0</span>], <span class=\"hljs-number\">0</span>)\n       <span class=\"hljs-keyword\">val</span> fragmentTransaction = supportFragmentManager.beginTransaction()\n       fragmentTransaction.add(R.id.ll_fragment, fragment)\n       fragmentTransaction.commit()</code></pre>\n<p>启动Activity，我们将该Fragment生命周期的日志打印出来如下：<br><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi8yOS8xNmY1MGFlMTVhODk1NDBi?x-oss-process=image/format,png\" alt=\"在这里插入图片描述\"><br>可以看到这个Fragment生命周期从onAttach一直执行到了onResume。并且在Activity中成功显示出了Fragment</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi8yOS8xNmY1MWE1YzJhYjRkY2Y2?x-oss-process=image/format,png\"></p>\n<h3 id=\"2-setMaxLifecycle与CREATED\"><a href=\"#2-setMaxLifecycle与CREATED\" class=\"headerlink\" title=\"2.setMaxLifecycle与CREATED\"></a>2.setMaxLifecycle与CREATED</h3><p>接下来，我们将maxLifecycle设置为CREATED：</p>\n<pre><code class=\"hljs kotlin\">fragment = TestLifecycleFragment.getInstance(Card.DECK[<span class=\"hljs-number\">0</span>], <span class=\"hljs-number\">0</span>)\n<span class=\"hljs-keyword\">val</span> fragmentTransaction = supportFragmentManager.beginTransaction()\nfragmentTransaction.add(R.id.ll_fragment, fragment)\nfragmentTransaction.setMaxLifecycle(fragment, Lifecycle.State.CREATED)\nfragmentTransaction.commit()</code></pre>\n<p>再来看日志输出：<br><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi8yOS8xNmY1MGFlMTgzYmMxMTI5?x-oss-process=image/format,png\" alt=\"在这里插入图片描述\"><br>可以看到该Fragment的生命周期仅仅执行到了onCreate就没再往下执行了。并且Activity中没有加载出来当前Fragment。</p>\n<p>那么现在问题来了，假设Fragment已经执行到了onResume,此时再为Fragment设置一个CREATED的最大生命周期会出现什么样的情况呢？我们通过日志来验证一下：</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi8yOS8xNmY1MWE3MWQ4MGY3NGFl?x-oss-process=image/format,png\"><br>从日志中可以看到已经执行了onResume的Fragment，将其最大生命周期设置为CREATED后会执行onPause-&gt;onStop-&gt;onDestoryView。也就是回退到了onCreate的状态。</p>\n<h3 id=\"3-setMaxLifecycle与STARTED\"><a href=\"#3-setMaxLifecycle与STARTED\" class=\"headerlink\" title=\"3.setMaxLifecycle与STARTED\"></a>3.setMaxLifecycle与STARTED</h3><p>接下来，我们将maxLifecycle设置为STARTED：</p>\n<pre><code class=\"hljs kotlin\">fragment = TestLifecycleFragment.getInstance(Card.DECK[<span class=\"hljs-number\">0</span>], <span class=\"hljs-number\">0</span>)\n<span class=\"hljs-keyword\">val</span> fragmentTransaction = supportFragmentManager.beginTransaction()\nfragmentTransaction.add(R.id.ll_fragment, fragment)\nfragmentTransaction.setMaxLifecycle(fragment, Lifecycle.State.STARTED)\nfragmentTransaction.commit()</code></pre>\n<p>日志输出如下：<br><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi8yOS8xNmY1MGFlMTk1Mjk3NDJl?x-oss-process=image/format,png\" alt=\"在这里插入图片描述\"><br>可以看到Fragment的生命周期执行到了onStart,并且Activity中成功显示出了当前fragment。</p>\n<p>同样，假设Fragment已经执行到了onResume方法再为其设置最大生命周期为STARTED会怎样呢？来看日志：<br><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi8yOS8xNmY1MGFlMTljODdiOGIy?x-oss-process=image/format,png\" alt=\"在这里插入图片描述\"><br>可以看到，设置最大生命周期STARTED后Fragment执行了onPause方法，也就是生命周期退回到了onStart。</p>\n<h3 id=\"4-setMaxLifecycle与RESUMED\"><a href=\"#4-setMaxLifecycle与RESUMED\" class=\"headerlink\" title=\"4.setMaxLifecycle与RESUMED\"></a>4.setMaxLifecycle与RESUMED</h3><p>最后，我们将maxLifecycle设置为RESUMED：</p>\n<pre><code class=\"hljs kotlin\">fragment = TestLifecycleFragment.getInstance(Card.DECK[<span class=\"hljs-number\">0</span>], <span class=\"hljs-number\">0</span>)\n<span class=\"hljs-keyword\">val</span> fragmentTransaction = supportFragmentManager.beginTransaction()\nfragmentTransaction.add(R.id.ll_fragment, fragment)\nfragmentTransaction.setMaxLifecycle(fragment, Lifecycle.State.RESUMED)\nfragmentTransaction.commit()</code></pre>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi8yOS8xNmY1MGFlMTljOTViZjM1?x-oss-process=image/format,png\" alt=\"在这里插入图片描述\"><br>可以看到此时和第一种情况一样的效果,Fragment的生命周期执行到了onResume。</p>\n<p>而对于已经执行了onResume后的Fragment，再去设置最大生命周期为RESUMED会怎么样呢？因为当前Fragment已经是RESUMED状态了,所以不会再去执行任何代码。</p>\n<p>到这里我们可以得出一个结论：</p>\n<blockquote>\n<p><strong>通过setMaxLifecycle方法可以精确控制Fragment生命周期的状态，如果Fragment的生命周期状态小于被设置的最大生命周期，则当前Fragment的生命周期会执行到被设置的最大生命周期，反之，如果Fragment的生命周期状态大于被设置的最大生命周期，那么则会回退到被设置的最大生命周期。</strong></p>\n</blockquote>\n<p>有了这一结论，在ViewPager中便可以对Fragment的生命周期进行控制，以此来更方便的实现延迟加载功能了。</p>\n<h2 id=\"三、Fragment延迟加载的今生\"><a href=\"#三、Fragment延迟加载的今生\" class=\"headerlink\" title=\"三、Fragment延迟加载的今生\"></a>三、Fragment延迟加载的今生</h2><h3 id=\"1、延迟加载新方案之于ViewPager\"><a href=\"#1、延迟加载新方案之于ViewPager\" class=\"headerlink\" title=\"1、延迟加载新方案之于ViewPager\"></a>1、延迟加载新方案之于ViewPager</h3><p>通过上一小节的分析我们知道了可以通过setMaxLifecycle来设置Fragment的最大生命周期，从而可以实现ViewPager中Fragment的延迟加载。当然，关于生命周期状态处理的操作无需我们自己实现，在Androidx 1.1.0版本中的FragmentStatePagerAdapter已经帮我们实现了，只需要在使用时候传进去相应的参数即可。</p>\n<p>FragmentStatePagerAdapter的构造方法接收两个参数，如下：</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">  * Constructor for &#123;<span class=\"hljs-doctag\">@link</span> FragmentStatePagerAdapter&#125;.</span>\n<span class=\"hljs-comment\">  *</span>\n<span class=\"hljs-comment\">  * If &#123;<span class=\"hljs-doctag\">@link</span> #BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT&#125; is passed in, then only the current</span>\n<span class=\"hljs-comment\">  * Fragment is in the &#123;<span class=\"hljs-doctag\">@link</span> Lifecycle.State#RESUMED&#125; state, while all other fragments are</span>\n<span class=\"hljs-comment\">  * capped at &#123;<span class=\"hljs-doctag\">@link</span> Lifecycle.State#STARTED&#125;. If &#123;<span class=\"hljs-doctag\">@link</span> #BEHAVIOR_SET_USER_VISIBLE_HINT&#125; is</span>\n<span class=\"hljs-comment\">  * passed, all fragments are in the &#123;<span class=\"hljs-doctag\">@link</span> Lifecycle.State#RESUMED&#125; state and there will be</span>\n<span class=\"hljs-comment\">  * callbacks to &#123;<span class=\"hljs-doctag\">@link</span> Fragment#setUserVisibleHint(boolean)&#125;.</span>\n<span class=\"hljs-comment\">  *</span>\n<span class=\"hljs-comment\">  * <span class=\"hljs-doctag\">@param</span> fm fragment manager that will interact with this adapter</span>\n<span class=\"hljs-comment\">  * <span class=\"hljs-doctag\">@param</span> behavior determines if only current fragments are in a resumed state</span>\n<span class=\"hljs-comment\">  */</span>\n <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">FragmentStatePagerAdapter</span><span class=\"hljs-params\">(<span class=\"hljs-meta\">@NonNull</span> FragmentManager fm,</span></span>\n<span class=\"hljs-function\"><span class=\"hljs-params\">         <span class=\"hljs-meta\">@Behavior</span> <span class=\"hljs-keyword\">int</span> behavior)</span> </span>&#123;\n     mFragmentManager = fm;\n     mBehavior = behavior;\n &#125;</code></pre>\n<p>第一个FragmentManager 参数不必多说，第二个参数时一个枚举类型的Behavior参数，其可选值如下：</p>\n<pre><code class=\"hljs kotlin\"><span class=\"hljs-meta\">@Retention(RetentionPolicy.SOURCE)</span>\n<span class=\"hljs-meta\">@IntDef(&#123;BEHAVIOR_SET_USER_VISIBLE_HINT, BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT&#125;)</span>\n<span class=\"hljs-keyword\">private</span> <span class=\"hljs-meta\">@interface</span> Behavior &#123; &#125;</code></pre>\n<p>当behavior为BEHAVIOR_SET_USER_VISIBLE_HINT时，Fragment改变的时候，setUserVisibleHint方法会被调用，也就是这个参数其实是为了兼容以前的老代码。并且BEHAVIOR_SET_USER_VISIBLE_HINT参数已经被置为废弃。所以我们的可选参数只剩下了BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT。</p>\n<p>当behavior为BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT时意味着只有当前显示的Fragment会被执行到onResume，而其它Fragment的生命周期都只会执行到onStart.</p>\n<p>这一功能时如何实现的呢？我们追随BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT的脚步找到了setPrimaryItem方法，这个方法的作用是设置ViewPager当前显示的Item，其源码如下：</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">setPrimaryItem</span><span class=\"hljs-params\">(<span class=\"hljs-meta\">@NonNull</span> ViewGroup container, <span class=\"hljs-keyword\">int</span> position, <span class=\"hljs-meta\">@NonNull</span> Object object)</span> </span>&#123;\n        Fragment fragment = (Fragment)object;\n        <span class=\"hljs-keyword\">if</span> (fragment != mCurrentPrimaryItem) &#123;\n            <span class=\"hljs-keyword\">if</span> (mCurrentPrimaryItem != <span class=\"hljs-keyword\">null</span>) &#123;\n                mCurrentPrimaryItem.setMenuVisibility(<span class=\"hljs-keyword\">false</span>);\n                <span class=\"hljs-keyword\">if</span> (mBehavior == BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT) &#123;\n                    <span class=\"hljs-keyword\">if</span> (mCurTransaction == <span class=\"hljs-keyword\">null</span>) &#123;\n                        mCurTransaction = mFragmentManager.beginTransaction();\n                    &#125;\n                    mCurTransaction.setMaxLifecycle(mCurrentPrimaryItem, Lifecycle.State.STARTED);\n                &#125; <span class=\"hljs-keyword\">else</span> &#123;\n                    mCurrentPrimaryItem.setUserVisibleHint(<span class=\"hljs-keyword\">false</span>);\n                &#125;\n            &#125;\n            fragment.setMenuVisibility(<span class=\"hljs-keyword\">true</span>);\n            <span class=\"hljs-keyword\">if</span> (mBehavior == BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT) &#123;\n                <span class=\"hljs-keyword\">if</span> (mCurTransaction == <span class=\"hljs-keyword\">null</span>) &#123;\n                    mCurTransaction = mFragmentManager.beginTransaction();\n                &#125;\n                mCurTransaction.setMaxLifecycle(fragment, Lifecycle.State.RESUMED);\n            &#125; <span class=\"hljs-keyword\">else</span> &#123;\n                fragment.setUserVisibleHint(<span class=\"hljs-keyword\">true</span>);\n            &#125;\n\n            mCurrentPrimaryItem = fragment;\n        &#125;\n    &#125;</code></pre>\n<p>这段代码非常简单易懂，mCurrentPrimaryItem是当前正在显示的item，fragment是接下来要显示的item。可以看到当mBehavior 为BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT时，mCurrentPrimaryItem的最大生命周期被设置为了STARTED，而fragment的最大生命周期则被设置为了RESUMED。而当mBehavior为BEHAVIOR_SET_USER_VISIBLE_HINT时仍然会调用setUserVisibleHint方法，这种情况就不再讨论，因为BEHAVIOR_SET_USER_VISIBLE_HINT也已经被废弃掉了。<br>那么我们着重来分析一下BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT时的情况：</p>\n<p><strong>mCurrentPrimaryItem是当前显示的Fragment，所以该Fragment必然已经执行到了onResume方法，而此时为其设置了最大生命周期STARTED，那么mCurrentPrimaryItem必然会执行onPause退回到STARTED状态。<br>而fragment当前生命周期状态为onStart，当为其设置了RESUME的最大生命周期状态后,fragment必然会执行onResume方法进入RESUMED状态。</strong></p>\n<p>知道了这一结论后，我们再去进行懒加载的控制是不是就异常简单了？此时我们只需要一个flag去标志是否是第一次加载数据就可以了。因此，懒加载的实现可以如下：</p>\n<pre><code class=\"hljs kotlin\"><span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">TestLifecycleFragment</span> : <span class=\"hljs-type\">Fragment</span></span>() &#123;\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">var</span> isFirstLoad = <span class=\"hljs-literal\">true</span>\n\n    <span class=\"hljs-keyword\">override</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">onResume</span><span class=\"hljs-params\">()</span></span> &#123;\n        <span class=\"hljs-keyword\">super</span>.onResume()\n        <span class=\"hljs-keyword\">if</span> (isFirstLoad) &#123;\n        \tisFirstLoad = <span class=\"hljs-literal\">false</span>\n            loadData()\n        &#125;\n    &#125;\n\n    <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">loadData</span><span class=\"hljs-params\">()</span></span>\n&#125;</code></pre>\n\n<h3 id=\"2、延迟加载之于ViewPager2\"><a href=\"#2、延迟加载之于ViewPager2\" class=\"headerlink\" title=\"2、延迟加载之于ViewPager2\"></a>2、延迟加载之于ViewPager2</h3><p>上篇文章<a href=\"https://juejin.im/post/5df4aabe6fb9a0161104c8eb\">《学不动也要学！深入了解ViewPager2》</a>中我们对ViewPager2有了比较深入的了解,其中在讲解ViewPager2的offScreenPageLimit时候得出过这样一个结论:</p>\n<blockquote>\n<p>ViewPager2的offScreenPageLimit默认值为OFFSCREEN_PAGE_LIMIT_DEFAULT,当setOffscreenPageLimit为OFFSCREEN_PAGE_LIMIT_DEFAULT时候会使用RecyclerView的缓存机制。默认只会加载当前显示的Fragment,而不会像ViewPager一样至少预加载一个item.当切换到下一个item的时候，当前Fragment会执行onPause方法，而下一个Fragment则会从onCreate一直执行到onResume。当再次滑动回第一个页面的时候当前页面同样会执行onPuase，而第一个页面会执行onResume。</p>\n</blockquote>\n<p>也就是说在ViewPager2中，默认关闭了预加载机制。没有了预加载机制再谈延迟加载其实也没有任何意义了。所以关于ViewPager2的延迟加载也就不用多说了吧？只需要将网络请求放到onStart中即可。相信随着ViewPager2的普及延迟加载的概念也会慢慢淡出开发者的视线。</p>\n<p><strong>2020/1/4补充：</strong></p>\n<p>如果为ViewPager2设置了offScreenPageLimit(1)那结果会是怎样的呢？我们来看日志：</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC8xLzQvMTZmNzA3MTBjOTY1M2Y1Nw?x-oss-process=image/format,png\"><br>从日志中可以看到ViewPager2预加载了一个Fragment，并且预加载的Fragment的生命周期仅仅执行到了onStart。所以此处我们可以猜测在FragmentStateAdapter中一定设置了setMaxLifecycle(fragment, STARTED)，具体源码不再贴出，大家可以自行查看。因此，此时处理懒加载问题其实和ViewPager的懒加载新方案如出一辙了，仅仅需要添加一个boolean值即可。</p>\n<h2 id=\"三、总结\"><a href=\"#三、总结\" class=\"headerlink\" title=\"三、总结\"></a>三、总结</h2><p>本篇文章对于Fragment的延迟加载进行了深入的探究，并且了解了在Androidx 1.1.0版本中对Fragment最大生命周期状态的控制，从而探究出了Fragment延迟加载的新方案。对于ViewPager2，因其默认不会进行预加载因此也就意味着我们无需处理ViewPager2的延迟加载问题。好了，这一篇花费了我两个周末（其实是上周末写了一半偷了个懒）的文章到此就结束了，如果你从中学有所收获那么请你不要吝啬留下你的赞。</p>\n<p><a href=\"https://github.com/zhpanvip/ViewPagerSample\">本文涉及源码</a></p>\n"},{"title":"RxJava+Retrofit完美封装（一）","date":"2017-04-29T19:29:43.000Z","_content":"\n***本篇文章已授权微信公众号 guolin_blog （郭霖）独家发布***\n\n要说2016年最火的Android技术是什么，毫无疑问肯定是RxJava+Retrofit+Mvp。现如今2017年也已经过了快一半了。相信做android开发的小伙伴对RxJava和Retrofit也不再陌生。即使没有刻意的去学习过，也应该对RxJava和Retrofit有个一知半解。去年的时候学习了Rxjava和Retrofit的基本用法，但一直没有在实际项目中运用。今年开做新项目，果断在新项目中引入了RxJava和Retrofit。本篇文章将介绍笔者在项目中对Retrofit的封装。\n先来看一下封装过后的Retrofit如何使用。\n```\nRetrofitHelper.getApiService()\n                .getArticle()\n                .compose(RxUtil.<ArticleWrapper>rxSchedulerHelper(this))\n                .subscribe(new DefaultObserver<ArticleWrapper>() {\n                    @Override\n                    public void onSuccess(ArticleWrapper response) {\n                        showToast(\"Request Success，size is：\" + response.getDatas().size());\n                    }\n                });\n```\n没错，就是这么简洁的一个链式调用，可以显示加载动画，还加入了Retrofit生命周期的管理。\n开始之前需要先在module项目里的Gradle文件中添加用到的依赖库\n```\n\tcompile \"io.reactivex.rxjava2:rxjava:$rootProject.ext.rxjava2Version\"\n    compile \"com.squareup.retrofit2:retrofit:$rootProject.ext.retrofit2Version\"\n    compile \"com.squareup.retrofit2:converter-scalars:$rootProject.ext.retrofit2Version\"\n    compile \"com.squareup.retrofit2:converter-gson:$rootProject.ext.retrofit2Version\"\n    compile \"com.squareup.retrofit2:adapter-rxjava2:$rootProject.ext.retrofit2Version\"\n    compile 'com.jakewharton.retrofit:retrofit2-rxjava2-adapter:1.0.0'\n    compile 'io.reactivex.rxjava2:rxandroid:2.0.1'\n    compile 'com.squareup.okhttp3:logging-interceptor:3.4.1'\n    compile \"com.trello.rxlifecycle2:rxlifecycle:$rootProject.ext.rxlifecycle\"\n    //compile \"com.trello.rxlifecycle2:rxlifecycle-android:$rootProject.ext.rxlifecycle\"\n    compile \"com.trello.rxlifecycle2:rxlifecycle-components:$rootProject.ext.rxlifecycle\"\n```\n为了方便依赖库版本的修改我们采用\"io.reactivex.rxjava2:rxjava:$rootProject.ext.rxjava2Version\"这中方式添加依赖，因此需要在project的build.gradle文件的加上以下内容：\n```\next {\n    supportLibVersion = '25.1.0'\n    butterknifeVersion = '8.5.1'\n    rxjava2Version = '2.0.8'\n    retrofit2Version = '2.2.0'\n    rxlifecycle='2.1.0'\n    gsonVersion = '2.8.0'\n}\n```\n下面将通过几个小节对本次封装作详细的解析：\n\n - 服务器响应数据的基类BasicResponse\n - 构建初始化Retrofit的工具类IdeaApi\n - 通过GsonConverterFactory获取真实响应数据\n - 封装DefaultObserver处理服务器响应\n - 处理加载Loading\n - 管理Retrofit生命周期\n - 如何使用封装\n - 小结\n\n一.服务器响应数据的基类BasicResponse。\n----------------------------\n\n假定服务器返回的Json数据格式如下：\n```\n{\n \"code\": 200,\n \"message\": \"成功\",\n \"content\": {\n\t...\n\t}\n}\n```\n根据Json数据格式构建我们的BasicResponse（BasicResponse中的字段内容需要根据自己服务器返回的数据确定）。代码如下：\n\n```\npublic class BasicResponse<T> {\n\n    private int code;\n    private String message;\n    private T content;\n\t...此处省去get、set方法。\n```\n\n二.构建初始化Retrofit的工具类IdeaApi。\n---------------------------\n\n该类通过RetrofitUtils来获取ApiService的实例。代码如下：\n```\npublic class IdeaApi {\n    public static <T> T getApiService(Class<T> cls,String baseUrl) {\n        Retrofit retrofit = RetrofitUtils .getRetrofitBuilder(baseUrl).build();\n        return retrofit.create(cls);\n    }\n}\n```\nRetrofitUtils用来构建Retrofit.Builder，并对OkHttp做以下几个方面的配置：\n 1.  设置日志拦截器，拦截服务器返回的json数据。Retrofit将请求到json数据直接转换成了实体类，但有时候我们需要查看json数据，Retrofit并没有提供直接获取json数据的功能。因此我们需要自定义一个日志拦截器拦截json数据，并输入到控制台。\n 2. 设置Http请求头。给OkHttp 添加请求头拦截器，配置请求头信息。还可以为接口统一添加请求头数据。例如，把用户名、密码（或者token）统一添加到请求头。后续每个接口的请求头中都会携带用户名、密码（或者token）数据，避免了为每个接口单独添加。\n 3. 为OkHttp配置缓存。同样可以同过拦截器实现缓存处理。包括控制缓存的最大生命值，控制缓存的过期时间。\n 4. 如果采用https，我们还可以在此处理证书校验以及服务器校验。\n 5. 为Retrofit添加GsonConverterFactory。此处是一个比较重要的环节，将在后边详细讲解。\nRetrofitUtils 代码如下：\n```\npublic class RetrofitUtils {\n    public static OkHttpClient.Builder getOkHttpClientBuilder() {\n\n        HttpLoggingInterceptor loggingInterceptor = new HttpLoggingInterceptor(new HttpLoggingInterceptor.Logger() {\n            @Override\n            public void log(String message) {\n                try {\n                    LogUtils.e(\"OKHttp-----\", URLDecoder.decode(message, \"utf-8\"));\n                } catch (UnsupportedEncodingException e) {\n                    e.printStackTrace();\n                    LogUtils.e(\"OKHttp-----\", message);\n                }\n            }\n        });\n        loggingInterceptor.setLevel(HttpLoggingInterceptor.Level.BODY);\n\n        File cacheFile = new File(Utils.getContext().getCacheDir(), \"cache\");\n        Cache cache = new Cache(cacheFile, 1024 * 1024 * 100); //100Mb\n\n        return new OkHttpClient.Builder()\n                .readTimeout(Constants.DEFAULT_TIMEOUT, TimeUnit.MILLISECONDS)\n                .connectTimeout(Constants.DEFAULT_TIMEOUT, TimeUnit.MILLISECONDS)\n                .addInterceptor(loggingInterceptor)\n                .addInterceptor(new HttpHeaderInterceptor())\n                .addNetworkInterceptor(new HttpCacheInterceptor())\n               // .sslSocketFactory(SslContextFactory.getSSLSocketFactoryForTwoWay())  // https认证 如果要使用https且为自定义证书 可以去掉这两行注释，并自行配制证书。\n               // .hostnameVerifier(new SafeHostnameVerifier())\n                .cache(cache);\n    }\n\n    public static Retrofit.Builder getRetrofitBuilder(String baseUrl) {\n        Gson gson = new GsonBuilder().setDateFormat(\"yyyy-MM-dd HH:mm:ss\").serializeNulls().create();\n        OkHttpClient okHttpClient = RetrofitUtils.getOkHttpClientBuilder().build();\n        return new Retrofit.Builder()\n                .client(okHttpClient)\n                .addConverterFactory(GsonConverterFactory.create(gson))\n                .addCallAdapterFactory(RxJava2CallAdapterFactory.create())\n                .baseUrl(baseUrl);\n    }\n}\n```\n\n三.通过GsonConverterFactory获取真实响应数据\n--------------------------------\n在第一节中我们构建了服务器响应数据BasicResponse，BasicResponse由code、message、和content三个字段。其中code为服务器返回的错误码。我们会事先和服务器约定成功时的code值，比如200表示请求成功。但通常在请求服务器数据过程中免不了会出现各种错误。例如用户登录时密码错误、请求参数错误的情况。此时服务器会根据错误情况返回对应的错误码。一般来说，我们只关心成功时即code为200时的content数据。而对于code不为200时我们只需要给出对应的Toast提示即可。事实上我们对我们有用的仅仅时code为200时的content数据。因此我们可以考虑过滤掉code和message，在请求成功的回调中只返回content的内容。\n在此种情况下就需要我们通过自定义GsonConverterFactory来实现了。我们可以直接从Retrofit的源码中copy出GsonConverterFactory的三个相关类来做修改。\n其中最终要的一部分是修改GsonResponseBodyConverter中的convert方法。在该方法中拿到服务器响应数据并判断code是否为200。如果是，则获取到content并返回，如果不是，则在此处可以抛出对应的自定义的异常。然后再Observer中统一处理异常情况。GsonResponseBodyConverter代码如下：\n```\nfinal class GsonResponseBodyConverter<T> implements Converter<ResponseBody, Object> {\n\n    private final TypeAdapter<T> adapter;\n\n    GsonResponseBodyConverter(TypeAdapter<T> adapter) {\n        this.adapter = adapter;\n    }\n\n    @Override\n    public Object convert(ResponseBody value) throws IOException {\n        try {\n            BasicResponse response = (BasicResponse) adapter.fromJson(value.charStream());\n            if (response.getCode()==200) {\n            return response.getResults();\n            } else {\n                // 特定 API 的错误，在相应的 DefaultObserver 的 onError 的方法中进行处理\n                throw new ServerResponseException(response.getCode(), response.getMessage());\n            }\n        } finally {\n            value.close();\n        }\n        return null;\n    }\n}\n```\n\n四.构建DefaultObserver处理服务器响应。\n-----------------------------\n上一节中我们讲到了在请求服务器时可能出现的一些例如密码错误、参数错误的情况，服务器给我们返回了对应的错误码，我们根据错误码抛出了对应自定义异常。除此之外在我们发起网络请求时还可能发生一些异常情况。例如没有网络、请求超时或者服务器返回了数据但在解析时出现了数据解析异常等。对于这样的情况我们也要进行统一处理的。那么我们就需要自定义一个DefaultObserver类继承Observer，并重写相应的方法。\n该类中最重要的两个方法时onNext和onError。\n**1.在服务器返回数据成功的情况下会回调到onNext方法。**因此我们可以在DefaultObserver中定义一个抽象方法onSuccess(T response)，在调用网络时重写onSuccess方法即可。\n**2.如果在请求服务器过程中出现任何异常，都会回调到onError方法中。**包括上节中我们自己抛出的异常都会回调到onError。因此我们的重头戏就是处理onError。在onError中我们根据异常信息给出对应的Toast提示即可。\nDefaultObserver类的代码如下：\n```\npublic abstract class DefaultObserver<T> implements Observer<T> {\n    @Override\n    public void onSubscribe(Disposable d) {\n\n    }\n\n    @Override\n    public void onNext(T response) {\n        onSuccess(response);\n        onFinish();\n    }\n\n    @Override\n    public void onError(Throwable e) {\n        LogUtils.e(\"Retrofit\", e.getMessage());\n        if (e instanceof HttpException) {     //   HTTP错误\n            onException(ExceptionReason.BAD_NETWORK);\n        } else if (e instanceof ConnectException\n                || e instanceof UnknownHostException) {   //   连接错误\n            onException(ExceptionReason.CONNECT_ERROR);\n        } else if (e instanceof InterruptedIOException) {   //  连接超时\n            onException(ExceptionReason.CONNECT_TIMEOUT);\n        } else if (e instanceof JsonParseException\n                || e instanceof JSONException\n                || e instanceof ParseException) {   //  解析错误\n            onException(ExceptionReason.PARSE_ERROR);\n        }else if(e instanceof ServerResponseException){\n            onFail(e.getMessage());\n        } else {\n            onException(ExceptionReason.UNKNOWN_ERROR);\n        }\n        onFinish();\n    }\n\n    @Override\n    public void onComplete() {\n    }\n\n    /**\n     * 请求成功\n     *\n     * @param response 服务器返回的数据\n     */\n    abstract public void onSuccess(T response);\n\n    /**\n     * 服务器返回数据，但响应码不为200\n     *\n     */\n    public void onFail(String message) {\n        ToastUtils.show(message);\n    }\n    \n    public void onFinish(){}\n\n    /**\n     * 请求异常\n     *\n     * @param reason\n     */\n    public void onException(ExceptionReason reason) {\n        switch (reason) {\n            case CONNECT_ERROR:\n                ToastUtils.show(R.string.connect_error, Toast.LENGTH_SHORT);\n                break;\n\n            case CONNECT_TIMEOUT:\n                ToastUtils.show(R.string.connect_timeout, Toast.LENGTH_SHORT);\n                break;\n\n            case BAD_NETWORK:\n                ToastUtils.show(R.string.bad_network, Toast.LENGTH_SHORT);\n                break;\n\n            case PARSE_ERROR:\n                ToastUtils.show(R.string.parse_error, Toast.LENGTH_SHORT);\n                break;\n\n            case UNKNOWN_ERROR:\n            default:\n                ToastUtils.show(R.string.unknown_error, Toast.LENGTH_SHORT);\n                break;\n        }\n    }\n\n    /**\n     * 请求网络失败原因\n     */\n    public enum ExceptionReason {\n        /**\n         * 解析数据失败\n         */\n        PARSE_ERROR,\n        /**\n         * 网络问题\n         */\n        BAD_NETWORK,\n        /**\n         * 连接错误\n         */\n        CONNECT_ERROR,\n        /**\n         * 连接超时\n         */\n        CONNECT_TIMEOUT,\n        /**\n         * 未知错误\n         */\n        UNKNOWN_ERROR,\n    }\n}\n```\n\n五.处理加载Loading\n----------------------\n关于Loading我们可以通过RxJava的compose操作符来做一个非常优雅的处理。首先定义一个ProgressUtils工具类，然后通过RxJava的ObservableTransformer做一个变换来处理Loading。想要显示Loading，只需要加上.compose(ProgressUtils.< T >applyProgressBar(this))即可。\nProgressUtils代码如下：\n```\npublic class ProgressUtils {\n    public static <T> ObservableTransformer<T, T> applyProgressBar(\n            @NonNull final Activity activity, String msg) {\n        final WeakReference<Activity> activityWeakReference = new WeakReference<>(activity);\n        final DialogUtils dialogUtils = new DialogUtils();\n        dialogUtils.showProgress(activityWeakReference.get());\n        return new ObservableTransformer<T, T>() {\n            @Override\n            public ObservableSource<T> apply(Observable<T> upstream) {\n                return upstream.doOnSubscribe(new Consumer<Disposable>() {\n                    @Override\n                    public void accept(Disposable disposable) throws Exception {\n\n                    }\n                }).doOnTerminate(new Action() {\n                    @Override\n                    public void run() throws Exception {\n                        Activity context;\n                        if ((context = activityWeakReference.get()) != null\n                                && !context.isFinishing()) {\n                            dialogUtils.dismissProgress();\n                        }\n                    }\n                }).doOnSubscribe(new Consumer<Disposable>() {\n                    @Override\n                    public void accept(Disposable disposable) throws Exception {\n                        /*Activity context;\n                        if ((context = activityWeakReference.get()) != null\n                                && !context.isFinishing()) {\n                            dialogUtils.dismissProgress();\n                        }*/\n                    }\n                });\n            }\n        };\n    }\n\n    public static <T> ObservableTransformer<T, T> applyProgressBar(\n            @NonNull final Activity activity) {\n        return applyProgressBar(activity, \"\");\n    }\n}\n```\n至此关于RxJava和Retrofit的二次封装已经基本完成。但是我们不能忽略了很重要的一点，就是网络请求的生命周期。我们将在下一节中详细讲解。\n\n六、管理Retrofit生命周期\n----------------\n当activity被销毁时，网络请求也应该随之终止的。要不然就可能造成内存泄漏。会严重影到响App的性能！因此Retrofit生命周期的管理也是比较重要的一点内容。在这里我们使用 **[RxLifecycle](https://github.com/trello/RxLifecycle)**来对Retrofit进行生命周期管理。其使用流程如下：\n\n**1.在gradel中添加依赖如下：**\n```\ncompile 'com.trello.rxlifecycle2:rxlifecycle:2.1.0'\ncompile 'com.trello.rxlifecycle2:rxlifecycle-components:2.1.0'\n\n```\n**2.让我们的BaseActivity继承RxAppCompatActivity。**\n具体代码如下：\n```\npublic abstract class BaseActivity extends RxAppCompatActivity {\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(getLayoutId());\n        init(savedInstanceState);\n    }\n    protected void showToast(String msg) {\n        ToastUtils.show(msg);\n    }\n\n    protected abstract @LayoutRes int getLayoutId();\n\n    protected abstract void init(Bundle savedInstanceState);\n}\n```\n同样我们项目的BaseFragment继承RxFragment（注意使用继承V4包下的RxFragment），如下：\n```\npublic abstract class BaseFragment extends RxFragment {\n\n    public View rootView;\n    public LayoutInflater inflater;\n\n\n    @Nullable\n    @Override\n    public final View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {\n        super.onCreateView(inflater, container, savedInstanceState);\n        this.inflater = inflater;\n        if (rootView == null) {\n            rootView = inflater.inflate(this.getLayoutId(), container, false);\n            init(savedInstanceState);\n        }\n        ViewGroup parent = (ViewGroup) rootView.getParent();\n        if (parent != null) {\n            parent.removeView(rootView);\n        }\n        return rootView;\n    }\n\n    protected abstract int getLayoutId();\n\n    protected abstract void init(Bundle savedInstanceState);\n\n    protected void showToast(String msg) {\n        ToastUtils.show(msg);\n    }\n\n    @Override\n    public void onResume() {\n        super.onResume();\n    }\n\n    @Override\n    public void onPause() {\n        super.onPause();\n    }\n\n\n    @Override\n    public void onDestroyView() {\n        super.onDestroyView();\n    }\n}\n```\n3.使用compose操作符管理Retrofit生命周期了:\n\n```\nmyObservable\n            .compose(bindToLifecycle())\n            .subscribe();\n\n或者\n\nmyObservable\n    .compose(RxLifecycle.bindUntilEvent(lifecycle, ActivityEvent.DESTROY))\n    .subscribe();\n\n```\n关于RxLifecycle的详细使用方法可以参考 **[RxLifecycle官网](https://github.com/trello/RxLifecycle)**\n\n七.如何使用封装\n--------\n前面几节内容讲解了如何RxJava进行二次封装，封装部分的代码可以放在我们项目的Library模块中。那么封装好之后我们应该如何在app模块中使用呢？\n**1.定义一个接口来存放我们项目的API**\n```\npublic interface IdeaApiService {\n    /**\n     * 此接口服务器响应数据BasicResponse的泛型T应该是List<MeiZi>\n     * 即BasicResponse<List<MeiZi>>\n     * @return BasicResponse<List<MeiZi>>\n     */\n    @Headers(\"Cache-Control: public, max-age=10\")//设置缓存 缓存时间为100s\n    @GET(\"福利/10/1\")\n    Observable<List<MeiZi>> getMezi();\n\n    /**\n     * 登录 接口为假接口 并不能返回数据\n     * @return\n     */\n    @POST(\"login.do\")\n    Observable<LoginResponse> login(@Body LoginRequest request);\n\n    /**\n     * 刷新token 接口为假接口 并不能返回数据\n     * @return\n     */\n    @POST(\"refresh_token.do\")\n    Observable<RefreshTokenResponseBean> refreshToken(@Body RefreshTokenRequest request);\n\n    @Multipart\n    @POST(\"upload/uploadFile.do\")\n    Observable<BasicResponse> uploadFiles(@Part List<MultipartBody.Part> partList);\n}\n```\n\n**2.定义一个RetrofitHelper 类，通过IdeaApi来获取IdeaApiService的实例。**\n```\npublic class RetrofitHelper {\n    private static IdeaApiService mIdeaApiService;\n\n    public static IdeaApiService getApiService(){\n        return mIdeaApiService;\n    }\n    static {\n       mIdeaApiService= IdeaApi.getApiService(IdeaApiService.class, Constants.API_SERVER_URL);\n    }\n}\n```\n**3.在Activity或者Fragment中发起网络请求**\n\n```\n    /**\n     * Get请求\n     * @param view\n     */\n    public void getData(View view) {\n        RetrofitHelper.getApiService()\n                .getMezi()\n                .compose(this.<List<MeiZi>>bindToLifecycle())\n                .compose(ProgressUtils.<List<MeiZi>>applyProgressBar(this))\n                .subscribeOn(Schedulers.io())\n                .observeOn(AndroidSchedulers.mainThread())\n                .subscribe(new DefaultObserver<List<MeiZi>>() {\n                    @Override\n                    public void onSuccess(List<MeiZi> response) {\n                        showToast(\"请求成功，妹子个数为\" + response.size());\n                    }\n                });\n    }\n```\n\n八.小结\n----\n本篇文章主要讲解了Rxjava和Retrofit的二次封装。以上内容也是笔者参考多方面的资料经过长时间的改动优化而来。但鉴于本人能力有限，其中也避免不了出现不当之处。还请大家多多包涵。另外，在投稿郭神公众号时文章可能还存在很多处理不优雅的地方，比如对响应数据的处理以及对Loading的处理。在投稿被推送后收到了很多小伙伴的建议，因此笔者也参考了大家的意见并做了优化，在此感谢大家。最后如果有疑问欢迎在文章留言评论。\n\t\t\t\t\t\t\t\t\t\t\t\t\t \n[（二）Rxjava2+Retrofit之Token自动刷新](https://blog.csdn.net/qq_20521573/article/details/76100558)\n[（三）Rxjava2+Retrofit实现文件上传与下载](https://blog.csdn.net/qq_20521573/article/details/78356747)\n\n[ 源码传送门](https://github.com/zhpanvip/Retrofit2)\n\n","source":"_posts/8,RxJava-Retrofit完美封装（一）.md","raw":"---\ntitle: RxJava+Retrofit完美封装（一）\ndate: 2017-04-30 03:29:43\ntags: RxJava\n---\n\n***本篇文章已授权微信公众号 guolin_blog （郭霖）独家发布***\n\n要说2016年最火的Android技术是什么，毫无疑问肯定是RxJava+Retrofit+Mvp。现如今2017年也已经过了快一半了。相信做android开发的小伙伴对RxJava和Retrofit也不再陌生。即使没有刻意的去学习过，也应该对RxJava和Retrofit有个一知半解。去年的时候学习了Rxjava和Retrofit的基本用法，但一直没有在实际项目中运用。今年开做新项目，果断在新项目中引入了RxJava和Retrofit。本篇文章将介绍笔者在项目中对Retrofit的封装。\n先来看一下封装过后的Retrofit如何使用。\n```\nRetrofitHelper.getApiService()\n                .getArticle()\n                .compose(RxUtil.<ArticleWrapper>rxSchedulerHelper(this))\n                .subscribe(new DefaultObserver<ArticleWrapper>() {\n                    @Override\n                    public void onSuccess(ArticleWrapper response) {\n                        showToast(\"Request Success，size is：\" + response.getDatas().size());\n                    }\n                });\n```\n没错，就是这么简洁的一个链式调用，可以显示加载动画，还加入了Retrofit生命周期的管理。\n开始之前需要先在module项目里的Gradle文件中添加用到的依赖库\n```\n\tcompile \"io.reactivex.rxjava2:rxjava:$rootProject.ext.rxjava2Version\"\n    compile \"com.squareup.retrofit2:retrofit:$rootProject.ext.retrofit2Version\"\n    compile \"com.squareup.retrofit2:converter-scalars:$rootProject.ext.retrofit2Version\"\n    compile \"com.squareup.retrofit2:converter-gson:$rootProject.ext.retrofit2Version\"\n    compile \"com.squareup.retrofit2:adapter-rxjava2:$rootProject.ext.retrofit2Version\"\n    compile 'com.jakewharton.retrofit:retrofit2-rxjava2-adapter:1.0.0'\n    compile 'io.reactivex.rxjava2:rxandroid:2.0.1'\n    compile 'com.squareup.okhttp3:logging-interceptor:3.4.1'\n    compile \"com.trello.rxlifecycle2:rxlifecycle:$rootProject.ext.rxlifecycle\"\n    //compile \"com.trello.rxlifecycle2:rxlifecycle-android:$rootProject.ext.rxlifecycle\"\n    compile \"com.trello.rxlifecycle2:rxlifecycle-components:$rootProject.ext.rxlifecycle\"\n```\n为了方便依赖库版本的修改我们采用\"io.reactivex.rxjava2:rxjava:$rootProject.ext.rxjava2Version\"这中方式添加依赖，因此需要在project的build.gradle文件的加上以下内容：\n```\next {\n    supportLibVersion = '25.1.0'\n    butterknifeVersion = '8.5.1'\n    rxjava2Version = '2.0.8'\n    retrofit2Version = '2.2.0'\n    rxlifecycle='2.1.0'\n    gsonVersion = '2.8.0'\n}\n```\n下面将通过几个小节对本次封装作详细的解析：\n\n - 服务器响应数据的基类BasicResponse\n - 构建初始化Retrofit的工具类IdeaApi\n - 通过GsonConverterFactory获取真实响应数据\n - 封装DefaultObserver处理服务器响应\n - 处理加载Loading\n - 管理Retrofit生命周期\n - 如何使用封装\n - 小结\n\n一.服务器响应数据的基类BasicResponse。\n----------------------------\n\n假定服务器返回的Json数据格式如下：\n```\n{\n \"code\": 200,\n \"message\": \"成功\",\n \"content\": {\n\t...\n\t}\n}\n```\n根据Json数据格式构建我们的BasicResponse（BasicResponse中的字段内容需要根据自己服务器返回的数据确定）。代码如下：\n\n```\npublic class BasicResponse<T> {\n\n    private int code;\n    private String message;\n    private T content;\n\t...此处省去get、set方法。\n```\n\n二.构建初始化Retrofit的工具类IdeaApi。\n---------------------------\n\n该类通过RetrofitUtils来获取ApiService的实例。代码如下：\n```\npublic class IdeaApi {\n    public static <T> T getApiService(Class<T> cls,String baseUrl) {\n        Retrofit retrofit = RetrofitUtils .getRetrofitBuilder(baseUrl).build();\n        return retrofit.create(cls);\n    }\n}\n```\nRetrofitUtils用来构建Retrofit.Builder，并对OkHttp做以下几个方面的配置：\n 1.  设置日志拦截器，拦截服务器返回的json数据。Retrofit将请求到json数据直接转换成了实体类，但有时候我们需要查看json数据，Retrofit并没有提供直接获取json数据的功能。因此我们需要自定义一个日志拦截器拦截json数据，并输入到控制台。\n 2. 设置Http请求头。给OkHttp 添加请求头拦截器，配置请求头信息。还可以为接口统一添加请求头数据。例如，把用户名、密码（或者token）统一添加到请求头。后续每个接口的请求头中都会携带用户名、密码（或者token）数据，避免了为每个接口单独添加。\n 3. 为OkHttp配置缓存。同样可以同过拦截器实现缓存处理。包括控制缓存的最大生命值，控制缓存的过期时间。\n 4. 如果采用https，我们还可以在此处理证书校验以及服务器校验。\n 5. 为Retrofit添加GsonConverterFactory。此处是一个比较重要的环节，将在后边详细讲解。\nRetrofitUtils 代码如下：\n```\npublic class RetrofitUtils {\n    public static OkHttpClient.Builder getOkHttpClientBuilder() {\n\n        HttpLoggingInterceptor loggingInterceptor = new HttpLoggingInterceptor(new HttpLoggingInterceptor.Logger() {\n            @Override\n            public void log(String message) {\n                try {\n                    LogUtils.e(\"OKHttp-----\", URLDecoder.decode(message, \"utf-8\"));\n                } catch (UnsupportedEncodingException e) {\n                    e.printStackTrace();\n                    LogUtils.e(\"OKHttp-----\", message);\n                }\n            }\n        });\n        loggingInterceptor.setLevel(HttpLoggingInterceptor.Level.BODY);\n\n        File cacheFile = new File(Utils.getContext().getCacheDir(), \"cache\");\n        Cache cache = new Cache(cacheFile, 1024 * 1024 * 100); //100Mb\n\n        return new OkHttpClient.Builder()\n                .readTimeout(Constants.DEFAULT_TIMEOUT, TimeUnit.MILLISECONDS)\n                .connectTimeout(Constants.DEFAULT_TIMEOUT, TimeUnit.MILLISECONDS)\n                .addInterceptor(loggingInterceptor)\n                .addInterceptor(new HttpHeaderInterceptor())\n                .addNetworkInterceptor(new HttpCacheInterceptor())\n               // .sslSocketFactory(SslContextFactory.getSSLSocketFactoryForTwoWay())  // https认证 如果要使用https且为自定义证书 可以去掉这两行注释，并自行配制证书。\n               // .hostnameVerifier(new SafeHostnameVerifier())\n                .cache(cache);\n    }\n\n    public static Retrofit.Builder getRetrofitBuilder(String baseUrl) {\n        Gson gson = new GsonBuilder().setDateFormat(\"yyyy-MM-dd HH:mm:ss\").serializeNulls().create();\n        OkHttpClient okHttpClient = RetrofitUtils.getOkHttpClientBuilder().build();\n        return new Retrofit.Builder()\n                .client(okHttpClient)\n                .addConverterFactory(GsonConverterFactory.create(gson))\n                .addCallAdapterFactory(RxJava2CallAdapterFactory.create())\n                .baseUrl(baseUrl);\n    }\n}\n```\n\n三.通过GsonConverterFactory获取真实响应数据\n--------------------------------\n在第一节中我们构建了服务器响应数据BasicResponse，BasicResponse由code、message、和content三个字段。其中code为服务器返回的错误码。我们会事先和服务器约定成功时的code值，比如200表示请求成功。但通常在请求服务器数据过程中免不了会出现各种错误。例如用户登录时密码错误、请求参数错误的情况。此时服务器会根据错误情况返回对应的错误码。一般来说，我们只关心成功时即code为200时的content数据。而对于code不为200时我们只需要给出对应的Toast提示即可。事实上我们对我们有用的仅仅时code为200时的content数据。因此我们可以考虑过滤掉code和message，在请求成功的回调中只返回content的内容。\n在此种情况下就需要我们通过自定义GsonConverterFactory来实现了。我们可以直接从Retrofit的源码中copy出GsonConverterFactory的三个相关类来做修改。\n其中最终要的一部分是修改GsonResponseBodyConverter中的convert方法。在该方法中拿到服务器响应数据并判断code是否为200。如果是，则获取到content并返回，如果不是，则在此处可以抛出对应的自定义的异常。然后再Observer中统一处理异常情况。GsonResponseBodyConverter代码如下：\n```\nfinal class GsonResponseBodyConverter<T> implements Converter<ResponseBody, Object> {\n\n    private final TypeAdapter<T> adapter;\n\n    GsonResponseBodyConverter(TypeAdapter<T> adapter) {\n        this.adapter = adapter;\n    }\n\n    @Override\n    public Object convert(ResponseBody value) throws IOException {\n        try {\n            BasicResponse response = (BasicResponse) adapter.fromJson(value.charStream());\n            if (response.getCode()==200) {\n            return response.getResults();\n            } else {\n                // 特定 API 的错误，在相应的 DefaultObserver 的 onError 的方法中进行处理\n                throw new ServerResponseException(response.getCode(), response.getMessage());\n            }\n        } finally {\n            value.close();\n        }\n        return null;\n    }\n}\n```\n\n四.构建DefaultObserver处理服务器响应。\n-----------------------------\n上一节中我们讲到了在请求服务器时可能出现的一些例如密码错误、参数错误的情况，服务器给我们返回了对应的错误码，我们根据错误码抛出了对应自定义异常。除此之外在我们发起网络请求时还可能发生一些异常情况。例如没有网络、请求超时或者服务器返回了数据但在解析时出现了数据解析异常等。对于这样的情况我们也要进行统一处理的。那么我们就需要自定义一个DefaultObserver类继承Observer，并重写相应的方法。\n该类中最重要的两个方法时onNext和onError。\n**1.在服务器返回数据成功的情况下会回调到onNext方法。**因此我们可以在DefaultObserver中定义一个抽象方法onSuccess(T response)，在调用网络时重写onSuccess方法即可。\n**2.如果在请求服务器过程中出现任何异常，都会回调到onError方法中。**包括上节中我们自己抛出的异常都会回调到onError。因此我们的重头戏就是处理onError。在onError中我们根据异常信息给出对应的Toast提示即可。\nDefaultObserver类的代码如下：\n```\npublic abstract class DefaultObserver<T> implements Observer<T> {\n    @Override\n    public void onSubscribe(Disposable d) {\n\n    }\n\n    @Override\n    public void onNext(T response) {\n        onSuccess(response);\n        onFinish();\n    }\n\n    @Override\n    public void onError(Throwable e) {\n        LogUtils.e(\"Retrofit\", e.getMessage());\n        if (e instanceof HttpException) {     //   HTTP错误\n            onException(ExceptionReason.BAD_NETWORK);\n        } else if (e instanceof ConnectException\n                || e instanceof UnknownHostException) {   //   连接错误\n            onException(ExceptionReason.CONNECT_ERROR);\n        } else if (e instanceof InterruptedIOException) {   //  连接超时\n            onException(ExceptionReason.CONNECT_TIMEOUT);\n        } else if (e instanceof JsonParseException\n                || e instanceof JSONException\n                || e instanceof ParseException) {   //  解析错误\n            onException(ExceptionReason.PARSE_ERROR);\n        }else if(e instanceof ServerResponseException){\n            onFail(e.getMessage());\n        } else {\n            onException(ExceptionReason.UNKNOWN_ERROR);\n        }\n        onFinish();\n    }\n\n    @Override\n    public void onComplete() {\n    }\n\n    /**\n     * 请求成功\n     *\n     * @param response 服务器返回的数据\n     */\n    abstract public void onSuccess(T response);\n\n    /**\n     * 服务器返回数据，但响应码不为200\n     *\n     */\n    public void onFail(String message) {\n        ToastUtils.show(message);\n    }\n    \n    public void onFinish(){}\n\n    /**\n     * 请求异常\n     *\n     * @param reason\n     */\n    public void onException(ExceptionReason reason) {\n        switch (reason) {\n            case CONNECT_ERROR:\n                ToastUtils.show(R.string.connect_error, Toast.LENGTH_SHORT);\n                break;\n\n            case CONNECT_TIMEOUT:\n                ToastUtils.show(R.string.connect_timeout, Toast.LENGTH_SHORT);\n                break;\n\n            case BAD_NETWORK:\n                ToastUtils.show(R.string.bad_network, Toast.LENGTH_SHORT);\n                break;\n\n            case PARSE_ERROR:\n                ToastUtils.show(R.string.parse_error, Toast.LENGTH_SHORT);\n                break;\n\n            case UNKNOWN_ERROR:\n            default:\n                ToastUtils.show(R.string.unknown_error, Toast.LENGTH_SHORT);\n                break;\n        }\n    }\n\n    /**\n     * 请求网络失败原因\n     */\n    public enum ExceptionReason {\n        /**\n         * 解析数据失败\n         */\n        PARSE_ERROR,\n        /**\n         * 网络问题\n         */\n        BAD_NETWORK,\n        /**\n         * 连接错误\n         */\n        CONNECT_ERROR,\n        /**\n         * 连接超时\n         */\n        CONNECT_TIMEOUT,\n        /**\n         * 未知错误\n         */\n        UNKNOWN_ERROR,\n    }\n}\n```\n\n五.处理加载Loading\n----------------------\n关于Loading我们可以通过RxJava的compose操作符来做一个非常优雅的处理。首先定义一个ProgressUtils工具类，然后通过RxJava的ObservableTransformer做一个变换来处理Loading。想要显示Loading，只需要加上.compose(ProgressUtils.< T >applyProgressBar(this))即可。\nProgressUtils代码如下：\n```\npublic class ProgressUtils {\n    public static <T> ObservableTransformer<T, T> applyProgressBar(\n            @NonNull final Activity activity, String msg) {\n        final WeakReference<Activity> activityWeakReference = new WeakReference<>(activity);\n        final DialogUtils dialogUtils = new DialogUtils();\n        dialogUtils.showProgress(activityWeakReference.get());\n        return new ObservableTransformer<T, T>() {\n            @Override\n            public ObservableSource<T> apply(Observable<T> upstream) {\n                return upstream.doOnSubscribe(new Consumer<Disposable>() {\n                    @Override\n                    public void accept(Disposable disposable) throws Exception {\n\n                    }\n                }).doOnTerminate(new Action() {\n                    @Override\n                    public void run() throws Exception {\n                        Activity context;\n                        if ((context = activityWeakReference.get()) != null\n                                && !context.isFinishing()) {\n                            dialogUtils.dismissProgress();\n                        }\n                    }\n                }).doOnSubscribe(new Consumer<Disposable>() {\n                    @Override\n                    public void accept(Disposable disposable) throws Exception {\n                        /*Activity context;\n                        if ((context = activityWeakReference.get()) != null\n                                && !context.isFinishing()) {\n                            dialogUtils.dismissProgress();\n                        }*/\n                    }\n                });\n            }\n        };\n    }\n\n    public static <T> ObservableTransformer<T, T> applyProgressBar(\n            @NonNull final Activity activity) {\n        return applyProgressBar(activity, \"\");\n    }\n}\n```\n至此关于RxJava和Retrofit的二次封装已经基本完成。但是我们不能忽略了很重要的一点，就是网络请求的生命周期。我们将在下一节中详细讲解。\n\n六、管理Retrofit生命周期\n----------------\n当activity被销毁时，网络请求也应该随之终止的。要不然就可能造成内存泄漏。会严重影到响App的性能！因此Retrofit生命周期的管理也是比较重要的一点内容。在这里我们使用 **[RxLifecycle](https://github.com/trello/RxLifecycle)**来对Retrofit进行生命周期管理。其使用流程如下：\n\n**1.在gradel中添加依赖如下：**\n```\ncompile 'com.trello.rxlifecycle2:rxlifecycle:2.1.0'\ncompile 'com.trello.rxlifecycle2:rxlifecycle-components:2.1.0'\n\n```\n**2.让我们的BaseActivity继承RxAppCompatActivity。**\n具体代码如下：\n```\npublic abstract class BaseActivity extends RxAppCompatActivity {\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(getLayoutId());\n        init(savedInstanceState);\n    }\n    protected void showToast(String msg) {\n        ToastUtils.show(msg);\n    }\n\n    protected abstract @LayoutRes int getLayoutId();\n\n    protected abstract void init(Bundle savedInstanceState);\n}\n```\n同样我们项目的BaseFragment继承RxFragment（注意使用继承V4包下的RxFragment），如下：\n```\npublic abstract class BaseFragment extends RxFragment {\n\n    public View rootView;\n    public LayoutInflater inflater;\n\n\n    @Nullable\n    @Override\n    public final View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {\n        super.onCreateView(inflater, container, savedInstanceState);\n        this.inflater = inflater;\n        if (rootView == null) {\n            rootView = inflater.inflate(this.getLayoutId(), container, false);\n            init(savedInstanceState);\n        }\n        ViewGroup parent = (ViewGroup) rootView.getParent();\n        if (parent != null) {\n            parent.removeView(rootView);\n        }\n        return rootView;\n    }\n\n    protected abstract int getLayoutId();\n\n    protected abstract void init(Bundle savedInstanceState);\n\n    protected void showToast(String msg) {\n        ToastUtils.show(msg);\n    }\n\n    @Override\n    public void onResume() {\n        super.onResume();\n    }\n\n    @Override\n    public void onPause() {\n        super.onPause();\n    }\n\n\n    @Override\n    public void onDestroyView() {\n        super.onDestroyView();\n    }\n}\n```\n3.使用compose操作符管理Retrofit生命周期了:\n\n```\nmyObservable\n            .compose(bindToLifecycle())\n            .subscribe();\n\n或者\n\nmyObservable\n    .compose(RxLifecycle.bindUntilEvent(lifecycle, ActivityEvent.DESTROY))\n    .subscribe();\n\n```\n关于RxLifecycle的详细使用方法可以参考 **[RxLifecycle官网](https://github.com/trello/RxLifecycle)**\n\n七.如何使用封装\n--------\n前面几节内容讲解了如何RxJava进行二次封装，封装部分的代码可以放在我们项目的Library模块中。那么封装好之后我们应该如何在app模块中使用呢？\n**1.定义一个接口来存放我们项目的API**\n```\npublic interface IdeaApiService {\n    /**\n     * 此接口服务器响应数据BasicResponse的泛型T应该是List<MeiZi>\n     * 即BasicResponse<List<MeiZi>>\n     * @return BasicResponse<List<MeiZi>>\n     */\n    @Headers(\"Cache-Control: public, max-age=10\")//设置缓存 缓存时间为100s\n    @GET(\"福利/10/1\")\n    Observable<List<MeiZi>> getMezi();\n\n    /**\n     * 登录 接口为假接口 并不能返回数据\n     * @return\n     */\n    @POST(\"login.do\")\n    Observable<LoginResponse> login(@Body LoginRequest request);\n\n    /**\n     * 刷新token 接口为假接口 并不能返回数据\n     * @return\n     */\n    @POST(\"refresh_token.do\")\n    Observable<RefreshTokenResponseBean> refreshToken(@Body RefreshTokenRequest request);\n\n    @Multipart\n    @POST(\"upload/uploadFile.do\")\n    Observable<BasicResponse> uploadFiles(@Part List<MultipartBody.Part> partList);\n}\n```\n\n**2.定义一个RetrofitHelper 类，通过IdeaApi来获取IdeaApiService的实例。**\n```\npublic class RetrofitHelper {\n    private static IdeaApiService mIdeaApiService;\n\n    public static IdeaApiService getApiService(){\n        return mIdeaApiService;\n    }\n    static {\n       mIdeaApiService= IdeaApi.getApiService(IdeaApiService.class, Constants.API_SERVER_URL);\n    }\n}\n```\n**3.在Activity或者Fragment中发起网络请求**\n\n```\n    /**\n     * Get请求\n     * @param view\n     */\n    public void getData(View view) {\n        RetrofitHelper.getApiService()\n                .getMezi()\n                .compose(this.<List<MeiZi>>bindToLifecycle())\n                .compose(ProgressUtils.<List<MeiZi>>applyProgressBar(this))\n                .subscribeOn(Schedulers.io())\n                .observeOn(AndroidSchedulers.mainThread())\n                .subscribe(new DefaultObserver<List<MeiZi>>() {\n                    @Override\n                    public void onSuccess(List<MeiZi> response) {\n                        showToast(\"请求成功，妹子个数为\" + response.size());\n                    }\n                });\n    }\n```\n\n八.小结\n----\n本篇文章主要讲解了Rxjava和Retrofit的二次封装。以上内容也是笔者参考多方面的资料经过长时间的改动优化而来。但鉴于本人能力有限，其中也避免不了出现不当之处。还请大家多多包涵。另外，在投稿郭神公众号时文章可能还存在很多处理不优雅的地方，比如对响应数据的处理以及对Loading的处理。在投稿被推送后收到了很多小伙伴的建议，因此笔者也参考了大家的意见并做了优化，在此感谢大家。最后如果有疑问欢迎在文章留言评论。\n\t\t\t\t\t\t\t\t\t\t\t\t\t \n[（二）Rxjava2+Retrofit之Token自动刷新](https://blog.csdn.net/qq_20521573/article/details/76100558)\n[（三）Rxjava2+Retrofit实现文件上传与下载](https://blog.csdn.net/qq_20521573/article/details/78356747)\n\n[ 源码传送门](https://github.com/zhpanvip/Retrofit2)\n\n","slug":"8,RxJava-Retrofit完美封装（一）","published":1,"updated":"2020-08-29T18:02:21.507Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckegm5nsw001ldwoze3l216w4","content":"<p><strong><em>本篇文章已授权微信公众号 guolin_blog （郭霖）独家发布</em></strong></p>\n<p>要说2016年最火的Android技术是什么，毫无疑问肯定是RxJava+Retrofit+Mvp。现如今2017年也已经过了快一半了。相信做android开发的小伙伴对RxJava和Retrofit也不再陌生。即使没有刻意的去学习过，也应该对RxJava和Retrofit有个一知半解。去年的时候学习了Rxjava和Retrofit的基本用法，但一直没有在实际项目中运用。今年开做新项目，果断在新项目中引入了RxJava和Retrofit。本篇文章将介绍笔者在项目中对Retrofit的封装。<br>先来看一下封装过后的Retrofit如何使用。</p>\n<pre><code class=\"hljs reasonml\"><span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">RetrofitHelper</span>.</span></span>get<span class=\"hljs-constructor\">ApiService()</span>\n                .get<span class=\"hljs-constructor\">Article()</span>\n                .compose(RxUtil.&lt;ArticleWrapper&gt;rx<span class=\"hljs-constructor\">SchedulerHelper(<span class=\"hljs-params\">this</span>)</span>)\n                .subscribe(<span class=\"hljs-keyword\">new</span> DefaultObserver&lt;ArticleWrapper&gt;<span class=\"hljs-literal\">()</span> &#123;\n                    @Override\n                    public void on<span class=\"hljs-constructor\">Success(ArticleWrapper <span class=\"hljs-params\">response</span>)</span> &#123;\n                        show<span class=\"hljs-constructor\">Toast(<span class=\"hljs-string\">&quot;Request Success，size is：&quot;</span> + <span class=\"hljs-params\">response</span>.<span class=\"hljs-params\">getDatas</span>()</span>.size<span class=\"hljs-literal\">()</span>);\n                    &#125;\n                &#125;);</code></pre>\n<p>没错，就是这么简洁的一个链式调用，可以显示加载动画，还加入了Retrofit生命周期的管理。<br>开始之前需要先在module项目里的Gradle文件中添加用到的依赖库</p>\n<pre><code class=\"hljs gradle\"><span class=\"hljs-keyword\">compile</span> <span class=\"hljs-string\">&quot;io.reactivex.rxjava2:rxjava:$rootProject.ext.rxjava2Version&quot;</span>\n   <span class=\"hljs-keyword\">compile</span> <span class=\"hljs-string\">&quot;com.squareup.retrofit2:retrofit:$rootProject.ext.retrofit2Version&quot;</span>\n   <span class=\"hljs-keyword\">compile</span> <span class=\"hljs-string\">&quot;com.squareup.retrofit2:converter-scalars:$rootProject.ext.retrofit2Version&quot;</span>\n   <span class=\"hljs-keyword\">compile</span> <span class=\"hljs-string\">&quot;com.squareup.retrofit2:converter-gson:$rootProject.ext.retrofit2Version&quot;</span>\n   <span class=\"hljs-keyword\">compile</span> <span class=\"hljs-string\">&quot;com.squareup.retrofit2:adapter-rxjava2:$rootProject.ext.retrofit2Version&quot;</span>\n   <span class=\"hljs-keyword\">compile</span> <span class=\"hljs-string\">&#x27;com.jakewharton.retrofit:retrofit2-rxjava2-adapter:1.0.0&#x27;</span>\n   <span class=\"hljs-keyword\">compile</span> <span class=\"hljs-string\">&#x27;io.reactivex.rxjava2:rxandroid:2.0.1&#x27;</span>\n   <span class=\"hljs-keyword\">compile</span> <span class=\"hljs-string\">&#x27;com.squareup.okhttp3:logging-interceptor:3.4.1&#x27;</span>\n   <span class=\"hljs-keyword\">compile</span> <span class=\"hljs-string\">&quot;com.trello.rxlifecycle2:rxlifecycle:$rootProject.ext.rxlifecycle&quot;</span>\n   <span class=\"hljs-comment\">//compile &quot;com.trello.rxlifecycle2:rxlifecycle-android:$rootProject.ext.rxlifecycle&quot;</span>\n   <span class=\"hljs-keyword\">compile</span> <span class=\"hljs-string\">&quot;com.trello.rxlifecycle2:rxlifecycle-components:$rootProject.ext.rxlifecycle&quot;</span></code></pre>\n<p>为了方便依赖库版本的修改我们采用”io.reactivex.rxjava2:rxjava:$rootProject.ext.rxjava2Version”这中方式添加依赖，因此需要在project的build.gradle文件的加上以下内容：</p>\n<pre><code class=\"hljs lsl\">ext &#123;\n    supportLibVersion = &#x27;<span class=\"hljs-number\">25.1</span><span class=\"hljs-number\">.0</span>&#x27;\n    butterknifeVersion = &#x27;<span class=\"hljs-number\">8.5</span><span class=\"hljs-number\">.1</span>&#x27;\n    rxjava2Version = &#x27;<span class=\"hljs-number\">2.0</span><span class=\"hljs-number\">.8</span>&#x27;\n    retrofit2Version = &#x27;<span class=\"hljs-number\">2.2</span><span class=\"hljs-number\">.0</span>&#x27;\n    rxlifecycle=&#x27;<span class=\"hljs-number\">2.1</span><span class=\"hljs-number\">.0</span>&#x27;\n    gsonVersion = &#x27;<span class=\"hljs-number\">2.8</span><span class=\"hljs-number\">.0</span>&#x27;\n&#125;</code></pre>\n<p>下面将通过几个小节对本次封装作详细的解析：</p>\n<ul>\n<li>服务器响应数据的基类BasicResponse</li>\n<li>构建初始化Retrofit的工具类IdeaApi</li>\n<li>通过GsonConverterFactory获取真实响应数据</li>\n<li>封装DefaultObserver处理服务器响应</li>\n<li>处理加载Loading</li>\n<li>管理Retrofit生命周期</li>\n<li>如何使用封装</li>\n<li>小结</li>\n</ul>\n<h2 id=\"一-服务器响应数据的基类BasicResponse。\"><a href=\"#一-服务器响应数据的基类BasicResponse。\" class=\"headerlink\" title=\"一.服务器响应数据的基类BasicResponse。\"></a>一.服务器响应数据的基类BasicResponse。</h2><p>假定服务器返回的Json数据格式如下：</p>\n<pre><code class=\"hljs clojure\">&#123;\n <span class=\"hljs-string\">&quot;code&quot;</span>: <span class=\"hljs-number\">200</span>,\n <span class=\"hljs-string\">&quot;message&quot;</span>: <span class=\"hljs-string\">&quot;成功&quot;</span>,\n <span class=\"hljs-string\">&quot;content&quot;</span>: &#123;\n\t...\n\t&#125;\n&#125;</code></pre>\n<p>根据Json数据格式构建我们的BasicResponse（BasicResponse中的字段内容需要根据自己服务器返回的数据确定）。代码如下：</p>\n<pre><code class=\"hljs arduino\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">BasicResponse</span>&lt;T&gt; &#123;</span>\n\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">int</span> code;\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">String</span> message;\n    <span class=\"hljs-keyword\">private</span> T content;\n\t...此处省去<span class=\"hljs-built_in\">get</span>、<span class=\"hljs-built_in\">set</span>方法。</code></pre>\n\n<h2 id=\"二-构建初始化Retrofit的工具类IdeaApi。\"><a href=\"#二-构建初始化Retrofit的工具类IdeaApi。\" class=\"headerlink\" title=\"二.构建初始化Retrofit的工具类IdeaApi。\"></a>二.构建初始化Retrofit的工具类IdeaApi。</h2><p>该类通过RetrofitUtils来获取ApiService的实例。代码如下：</p>\n<pre><code class=\"hljs arduino\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">IdeaApi</span> &#123;</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> &lt;T&gt; <span class=\"hljs-function\">T <span class=\"hljs-title\">getApiService</span><span class=\"hljs-params\">(Class&lt;T&gt; cls,<span class=\"hljs-keyword\">String</span> baseUrl)</span> </span>&#123;\n        Retrofit retrofit = RetrofitUtils .getRetrofitBuilder(baseUrl).build();\n        <span class=\"hljs-keyword\">return</span> retrofit.create(cls);\n    &#125;\n&#125;</code></pre>\n<p>RetrofitUtils用来构建Retrofit.Builder，并对OkHttp做以下几个方面的配置：</p>\n<ol>\n<li>设置日志拦截器，拦截服务器返回的json数据。Retrofit将请求到json数据直接转换成了实体类，但有时候我们需要查看json数据，Retrofit并没有提供直接获取json数据的功能。因此我们需要自定义一个日志拦截器拦截json数据，并输入到控制台。</li>\n<li>设置Http请求头。给OkHttp 添加请求头拦截器，配置请求头信息。还可以为接口统一添加请求头数据。例如，把用户名、密码（或者token）统一添加到请求头。后续每个接口的请求头中都会携带用户名、密码（或者token）数据，避免了为每个接口单独添加。</li>\n<li>为OkHttp配置缓存。同样可以同过拦截器实现缓存处理。包括控制缓存的最大生命值，控制缓存的过期时间。</li>\n<li>如果采用https，我们还可以在此处理证书校验以及服务器校验。</li>\n<li>为Retrofit添加GsonConverterFactory。此处是一个比较重要的环节，将在后边详细讲解。<br>RetrofitUtils 代码如下：<pre><code class=\"hljs reasonml\">public <span class=\"hljs-keyword\">class</span> RetrofitUtils &#123;\n    public static OkHttpClient.Builder get<span class=\"hljs-constructor\">OkHttpClientBuilder()</span> &#123;\n\n        HttpLoggingInterceptor loggingInterceptor = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-constructor\">HttpLoggingInterceptor(<span class=\"hljs-params\">new</span> HttpLoggingInterceptor.Logger()</span> &#123;\n            @Override\n            public void log(String message) &#123;\n                <span class=\"hljs-keyword\">try</span> &#123;\n                    <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">LogUtils</span>.</span></span>e(<span class=\"hljs-string\">&quot;OKHttp-----&quot;</span>, <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">URLDecoder</span>.</span></span>decode(message, <span class=\"hljs-string\">&quot;utf-8&quot;</span>));\n                &#125; catch (UnsupportedEncodingException e) &#123;\n                    e.print<span class=\"hljs-constructor\">StackTrace()</span>;\n                    <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">LogUtils</span>.</span></span>e(<span class=\"hljs-string\">&quot;OKHttp-----&quot;</span>, message);\n                &#125;\n            &#125;\n        &#125;);\n        loggingInterceptor.set<span class=\"hljs-constructor\">Level(HttpLoggingInterceptor.Level.BODY)</span>;\n\n        File cacheFile = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-constructor\">File(Utils.<span class=\"hljs-params\">getContext</span>()</span>.get<span class=\"hljs-constructor\">CacheDir()</span>, <span class=\"hljs-string\">&quot;cache&quot;</span>);\n        Cache cache = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-constructor\">Cache(<span class=\"hljs-params\">cacheFile</span>, 1024 <span class=\"hljs-operator\">*</span> 1024 <span class=\"hljs-operator\">*</span> 100)</span>; <span class=\"hljs-comment\">//100Mb</span>\n\n        return <span class=\"hljs-keyword\">new</span> OkHttpClient.<span class=\"hljs-constructor\">Builder()</span>\n                .read<span class=\"hljs-constructor\">Timeout(Constants.DEFAULT_TIMEOUT, TimeUnit.MILLISECONDS)</span>\n                .connect<span class=\"hljs-constructor\">Timeout(Constants.DEFAULT_TIMEOUT, TimeUnit.MILLISECONDS)</span>\n                .add<span class=\"hljs-constructor\">Interceptor(<span class=\"hljs-params\">loggingInterceptor</span>)</span>\n                .add<span class=\"hljs-constructor\">Interceptor(<span class=\"hljs-params\">new</span> HttpHeaderInterceptor()</span>)\n                .add<span class=\"hljs-constructor\">NetworkInterceptor(<span class=\"hljs-params\">new</span> HttpCacheInterceptor()</span>)\n               <span class=\"hljs-comment\">// .sslSocketFactory(SslContextFactory.getSSLSocketFactoryForTwoWay())  // https认证 如果要使用https且为自定义证书 可以去掉这两行注释，并自行配制证书。</span>\n               <span class=\"hljs-comment\">// .hostnameVerifier(new SafeHostnameVerifier())</span>\n                .cache(cache);\n    &#125;\n\n    public static Retrofit.Builder get<span class=\"hljs-constructor\">RetrofitBuilder(String <span class=\"hljs-params\">baseUrl</span>)</span> &#123;\n        Gson gson = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-constructor\">GsonBuilder()</span>.set<span class=\"hljs-constructor\">DateFormat(<span class=\"hljs-string\">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>)</span>.serialize<span class=\"hljs-constructor\">Nulls()</span>.create<span class=\"hljs-literal\">()</span>;\n        OkHttpClient okHttpClient = <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">RetrofitUtils</span>.</span></span>get<span class=\"hljs-constructor\">OkHttpClientBuilder()</span>.build<span class=\"hljs-literal\">()</span>;\n        return <span class=\"hljs-keyword\">new</span> Retrofit.<span class=\"hljs-constructor\">Builder()</span>\n                .client(okHttpClient)\n                .add<span class=\"hljs-constructor\">ConverterFactory(GsonConverterFactory.<span class=\"hljs-params\">create</span>(<span class=\"hljs-params\">gson</span>)</span>)\n                .add<span class=\"hljs-constructor\">CallAdapterFactory(RxJava2CallAdapterFactory.<span class=\"hljs-params\">create</span>()</span>)\n                .base<span class=\"hljs-constructor\">Url(<span class=\"hljs-params\">baseUrl</span>)</span>;\n    &#125;\n&#125;</code></pre>\n\n</li>\n</ol>\n<h2 id=\"三-通过GsonConverterFactory获取真实响应数据\"><a href=\"#三-通过GsonConverterFactory获取真实响应数据\" class=\"headerlink\" title=\"三.通过GsonConverterFactory获取真实响应数据\"></a>三.通过GsonConverterFactory获取真实响应数据</h2><p>在第一节中我们构建了服务器响应数据BasicResponse，BasicResponse由code、message、和content三个字段。其中code为服务器返回的错误码。我们会事先和服务器约定成功时的code值，比如200表示请求成功。但通常在请求服务器数据过程中免不了会出现各种错误。例如用户登录时密码错误、请求参数错误的情况。此时服务器会根据错误情况返回对应的错误码。一般来说，我们只关心成功时即code为200时的content数据。而对于code不为200时我们只需要给出对应的Toast提示即可。事实上我们对我们有用的仅仅时code为200时的content数据。因此我们可以考虑过滤掉code和message，在请求成功的回调中只返回content的内容。<br>在此种情况下就需要我们通过自定义GsonConverterFactory来实现了。我们可以直接从Retrofit的源码中copy出GsonConverterFactory的三个相关类来做修改。<br>其中最终要的一部分是修改GsonResponseBodyConverter中的convert方法。在该方法中拿到服务器响应数据并判断code是否为200。如果是，则获取到content并返回，如果不是，则在此处可以抛出对应的自定义的异常。然后再Observer中统一处理异常情况。GsonResponseBodyConverter代码如下：</p>\n<pre><code class=\"hljs angelscript\"><span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-symbol\">GsonResponseBodyConverter</span>&lt;<span class=\"hljs-symbol\">T</span>&gt; <span class=\"hljs-symbol\">implements</span> <span class=\"hljs-symbol\">Converter</span>&lt;<span class=\"hljs-symbol\">ResponseBody, <span class=\"hljs-symbol\">Object</span></span>&gt; &#123;\n\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">final</span> TypeAdapter&lt;T&gt; adapter;\n\n    GsonResponseBodyConverter(TypeAdapter&lt;T&gt; adapter) &#123;\n        <span class=\"hljs-keyword\">this</span>.adapter = adapter;\n    &#125;\n\n    @Override\n    <span class=\"hljs-keyword\">public</span> Object convert(ResponseBody value) throws IOException &#123;\n        <span class=\"hljs-keyword\">try</span> &#123;\n            BasicResponse response = (BasicResponse) adapter.fromJson(value.charStream());\n            <span class=\"hljs-keyword\">if</span> (response.getCode()==<span class=\"hljs-number\">200</span>) &#123;\n            <span class=\"hljs-keyword\">return</span> response.getResults();\n            &#125; <span class=\"hljs-keyword\">else</span> &#123;\n                <span class=\"hljs-comment\">// 特定 API 的错误，在相应的 DefaultObserver 的 onError 的方法中进行处理</span>\n                throw new ServerResponseException(response.getCode(), response.getMessage());\n            &#125;\n        &#125; finally &#123;\n            value.close();\n        &#125;\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">null</span>;\n    &#125;\n&#125;</code></pre>\n\n<h2 id=\"四-构建DefaultObserver处理服务器响应。\"><a href=\"#四-构建DefaultObserver处理服务器响应。\" class=\"headerlink\" title=\"四.构建DefaultObserver处理服务器响应。\"></a>四.构建DefaultObserver处理服务器响应。</h2><p>上一节中我们讲到了在请求服务器时可能出现的一些例如密码错误、参数错误的情况，服务器给我们返回了对应的错误码，我们根据错误码抛出了对应自定义异常。除此之外在我们发起网络请求时还可能发生一些异常情况。例如没有网络、请求超时或者服务器返回了数据但在解析时出现了数据解析异常等。对于这样的情况我们也要进行统一处理的。那么我们就需要自定义一个DefaultObserver类继承Observer，并重写相应的方法。<br>该类中最重要的两个方法时onNext和onError。<br><strong>1.在服务器返回数据成功的情况下会回调到onNext方法。</strong>因此我们可以在DefaultObserver中定义一个抽象方法onSuccess(T response)，在调用网络时重写onSuccess方法即可。<br><strong>2.如果在请求服务器过程中出现任何异常，都会回调到onError方法中。</strong>包括上节中我们自己抛出的异常都会回调到onError。因此我们的重头戏就是处理onError。在onError中我们根据异常信息给出对应的Toast提示即可。<br>DefaultObserver类的代码如下：</p>\n<pre><code class=\"hljs reasonml\">public abstract <span class=\"hljs-keyword\">class</span> DefaultObserver&lt;T&gt; implements Observer&lt;T&gt; &#123;\n    @Override\n    public void on<span class=\"hljs-constructor\">Subscribe(Disposable <span class=\"hljs-params\">d</span>)</span> &#123;\n\n    &#125;\n\n    @Override\n    public void on<span class=\"hljs-constructor\">Next(T <span class=\"hljs-params\">response</span>)</span> &#123;\n        on<span class=\"hljs-constructor\">Success(<span class=\"hljs-params\">response</span>)</span>;\n        on<span class=\"hljs-constructor\">Finish()</span>;\n    &#125;\n\n    @Override\n    public void on<span class=\"hljs-constructor\">Error(Throwable <span class=\"hljs-params\">e</span>)</span> &#123;\n        <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">LogUtils</span>.</span></span>e(<span class=\"hljs-string\">&quot;Retrofit&quot;</span>, e.get<span class=\"hljs-constructor\">Message()</span>);\n        <span class=\"hljs-keyword\">if</span> (e instanceof HttpException) &#123;     <span class=\"hljs-comment\">//   HTTP错误</span>\n            on<span class=\"hljs-constructor\">Exception(ExceptionReason.BAD_NETWORK)</span>;\n        &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (e instanceof ConnectException\n<span class=\"hljs-operator\">                || </span>e instanceof UnknownHostException) &#123;   <span class=\"hljs-comment\">//   连接错误</span>\n            on<span class=\"hljs-constructor\">Exception(ExceptionReason.CONNECT_ERROR)</span>;\n        &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (e instanceof InterruptedIOException) &#123;   <span class=\"hljs-comment\">//  连接超时</span>\n            on<span class=\"hljs-constructor\">Exception(ExceptionReason.CONNECT_TIMEOUT)</span>;\n        &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (e instanceof JsonParseException\n<span class=\"hljs-operator\">                || </span>e instanceof JSONException\n<span class=\"hljs-operator\">                || </span>e instanceof ParseException) &#123;   <span class=\"hljs-comment\">//  解析错误</span>\n            on<span class=\"hljs-constructor\">Exception(ExceptionReason.PARSE_ERROR)</span>;\n        &#125;<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(e instanceof ServerResponseException)&#123;\n            on<span class=\"hljs-constructor\">Fail(<span class=\"hljs-params\">e</span>.<span class=\"hljs-params\">getMessage</span>()</span>);\n        &#125; <span class=\"hljs-keyword\">else</span> &#123;\n            on<span class=\"hljs-constructor\">Exception(ExceptionReason.UNKNOWN_ERROR)</span>;\n        &#125;\n        on<span class=\"hljs-constructor\">Finish()</span>;\n    &#125;\n\n    @Override\n    public void on<span class=\"hljs-constructor\">Complete()</span> &#123;\n    &#125;\n\n    <span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">     * 请求成功</span>\n<span class=\"hljs-comment\">     *</span>\n<span class=\"hljs-comment\">     * @param response 服务器返回的数据</span>\n<span class=\"hljs-comment\">     */</span>\n    abstract public void on<span class=\"hljs-constructor\">Success(T <span class=\"hljs-params\">response</span>)</span>;\n\n    <span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">     * 服务器返回数据，但响应码不为200</span>\n<span class=\"hljs-comment\">     *</span>\n<span class=\"hljs-comment\">     */</span>\n    public void on<span class=\"hljs-constructor\">Fail(String <span class=\"hljs-params\">message</span>)</span> &#123;\n        <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">ToastUtils</span>.</span></span>show(message);\n    &#125;\n    \n    public void on<span class=\"hljs-constructor\">Finish()</span>&#123;&#125;\n\n    <span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">     * 请求异常</span>\n<span class=\"hljs-comment\">     *</span>\n<span class=\"hljs-comment\">     * @param reason</span>\n<span class=\"hljs-comment\">     */</span>\n    public void on<span class=\"hljs-constructor\">Exception(ExceptionReason <span class=\"hljs-params\">reason</span>)</span> &#123;\n        switch (reason) &#123;\n            case CONNECT_ERROR:\n                <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">ToastUtils</span>.</span></span>show(<span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">R</span>.</span></span><span class=\"hljs-built_in\">string</span>.connect_error, Toast.LENGTH_SHORT);\n                break;\n\n            case CONNECT_TIMEOUT:\n                <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">ToastUtils</span>.</span></span>show(<span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">R</span>.</span></span><span class=\"hljs-built_in\">string</span>.connect_timeout, Toast.LENGTH_SHORT);\n                break;\n\n            case BAD_NETWORK:\n                <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">ToastUtils</span>.</span></span>show(<span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">R</span>.</span></span><span class=\"hljs-built_in\">string</span>.bad_network, Toast.LENGTH_SHORT);\n                break;\n\n            case PARSE_ERROR:\n                <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">ToastUtils</span>.</span></span>show(<span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">R</span>.</span></span><span class=\"hljs-built_in\">string</span>.parse_error, Toast.LENGTH_SHORT);\n                break;\n\n            case UNKNOWN_ERROR:\n            default:\n                <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">ToastUtils</span>.</span></span>show(<span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">R</span>.</span></span><span class=\"hljs-built_in\">string</span>.unknown_error, Toast.LENGTH_SHORT);\n                break;\n        &#125;\n    &#125;\n\n    <span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">     * 请求网络失败原因</span>\n<span class=\"hljs-comment\">     */</span>\n    public enum ExceptionReason &#123;\n        <span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">         * 解析数据失败</span>\n<span class=\"hljs-comment\">         */</span>\n        PARSE_ERROR,\n        <span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">         * 网络问题</span>\n<span class=\"hljs-comment\">         */</span>\n        BAD_NETWORK,\n        <span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">         * 连接错误</span>\n<span class=\"hljs-comment\">         */</span>\n        CONNECT_ERROR,\n        <span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">         * 连接超时</span>\n<span class=\"hljs-comment\">         */</span>\n        CONNECT_TIMEOUT,\n        <span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">         * 未知错误</span>\n<span class=\"hljs-comment\">         */</span>\n        UNKNOWN_ERROR,\n    &#125;\n&#125;</code></pre>\n\n<h2 id=\"五-处理加载Loading\"><a href=\"#五-处理加载Loading\" class=\"headerlink\" title=\"五.处理加载Loading\"></a>五.处理加载Loading</h2><p>关于Loading我们可以通过RxJava的compose操作符来做一个非常优雅的处理。首先定义一个ProgressUtils工具类，然后通过RxJava的ObservableTransformer做一个变换来处理Loading。想要显示Loading，只需要加上.compose(ProgressUtils.&lt; T &gt;applyProgressBar(this))即可。<br>ProgressUtils代码如下：</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ProgressUtils</span> </span>&#123;\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> &lt;T&gt; <span class=\"hljs-function\">ObservableTransformer&lt;T, T&gt; <span class=\"hljs-title\">applyProgressBar</span><span class=\"hljs-params\">(</span></span>\n<span class=\"hljs-function\"><span class=\"hljs-params\">            <span class=\"hljs-meta\">@NonNull</span> <span class=\"hljs-keyword\">final</span> Activity activity, String msg)</span> </span>&#123;\n        <span class=\"hljs-keyword\">final</span> WeakReference&lt;Activity&gt; activityWeakReference = <span class=\"hljs-keyword\">new</span> WeakReference&lt;&gt;(activity);\n        <span class=\"hljs-keyword\">final</span> DialogUtils dialogUtils = <span class=\"hljs-keyword\">new</span> DialogUtils();\n        dialogUtils.showProgress(activityWeakReference.get());\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> ObservableTransformer&lt;T, T&gt;() &#123;\n            <span class=\"hljs-meta\">@Override</span>\n            <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> ObservableSource&lt;T&gt; <span class=\"hljs-title\">apply</span><span class=\"hljs-params\">(Observable&lt;T&gt; upstream)</span> </span>&#123;\n                <span class=\"hljs-keyword\">return</span> upstream.doOnSubscribe(<span class=\"hljs-keyword\">new</span> Consumer&lt;Disposable&gt;() &#123;\n                    <span class=\"hljs-meta\">@Override</span>\n                    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">accept</span><span class=\"hljs-params\">(Disposable disposable)</span> <span class=\"hljs-keyword\">throws</span> Exception </span>&#123;\n\n                    &#125;\n                &#125;).doOnTerminate(<span class=\"hljs-keyword\">new</span> Action() &#123;\n                    <span class=\"hljs-meta\">@Override</span>\n                    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">run</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> Exception </span>&#123;\n                        Activity context;\n                        <span class=\"hljs-keyword\">if</span> ((context = activityWeakReference.get()) != <span class=\"hljs-keyword\">null</span>\n                                &amp;&amp; !context.isFinishing()) &#123;\n                            dialogUtils.dismissProgress();\n                        &#125;\n                    &#125;\n                &#125;).doOnSubscribe(<span class=\"hljs-keyword\">new</span> Consumer&lt;Disposable&gt;() &#123;\n                    <span class=\"hljs-meta\">@Override</span>\n                    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">accept</span><span class=\"hljs-params\">(Disposable disposable)</span> <span class=\"hljs-keyword\">throws</span> Exception </span>&#123;\n                        <span class=\"hljs-comment\">/*Activity context;</span>\n<span class=\"hljs-comment\">                        if ((context = activityWeakReference.get()) != null</span>\n<span class=\"hljs-comment\">                                &amp;&amp; !context.isFinishing()) &#123;</span>\n<span class=\"hljs-comment\">                            dialogUtils.dismissProgress();</span>\n<span class=\"hljs-comment\">                        &#125;*/</span>\n                    &#125;\n                &#125;);\n            &#125;\n        &#125;;\n    &#125;\n\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> &lt;T&gt; <span class=\"hljs-function\">ObservableTransformer&lt;T, T&gt; <span class=\"hljs-title\">applyProgressBar</span><span class=\"hljs-params\">(</span></span>\n<span class=\"hljs-function\"><span class=\"hljs-params\">            <span class=\"hljs-meta\">@NonNull</span> <span class=\"hljs-keyword\">final</span> Activity activity)</span> </span>&#123;\n        <span class=\"hljs-keyword\">return</span> applyProgressBar(activity, <span class=\"hljs-string\">&quot;&quot;</span>);\n    &#125;\n&#125;</code></pre>\n<p>至此关于RxJava和Retrofit的二次封装已经基本完成。但是我们不能忽略了很重要的一点，就是网络请求的生命周期。我们将在下一节中详细讲解。</p>\n<h2 id=\"六、管理Retrofit生命周期\"><a href=\"#六、管理Retrofit生命周期\" class=\"headerlink\" title=\"六、管理Retrofit生命周期\"></a>六、管理Retrofit生命周期</h2><p>当activity被销毁时，网络请求也应该随之终止的。要不然就可能造成内存泄漏。会严重影到响App的性能！因此Retrofit生命周期的管理也是比较重要的一点内容。在这里我们使用 **<a href=\"https://github.com/trello/RxLifecycle\">RxLifecycle</a>**来对Retrofit进行生命周期管理。其使用流程如下：</p>\n<p><strong>1.在gradel中添加依赖如下：</strong></p>\n<pre><code class=\"hljs apache\"><span class=\"hljs-attribute\">compile</span> &#x27;com.trello.rxlifecycle<span class=\"hljs-number\">2</span>:rxlifecycle:<span class=\"hljs-number\">2</span>.<span class=\"hljs-number\">1</span>.<span class=\"hljs-number\">0</span>&#x27;\n<span class=\"hljs-attribute\">compile</span> &#x27;com.trello.rxlifecycle<span class=\"hljs-number\">2</span>:rxlifecycle-components:<span class=\"hljs-number\">2</span>.<span class=\"hljs-number\">1</span>.<span class=\"hljs-number\">0</span>&#x27;\n</code></pre>\n<p><strong>2.让我们的BaseActivity继承RxAppCompatActivity。</strong><br>具体代码如下：</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">BaseActivity</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">RxAppCompatActivity</span> </span>&#123;\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onCreate</span><span class=\"hljs-params\">(Bundle savedInstanceState)</span> </span>&#123;\n        <span class=\"hljs-keyword\">super</span>.onCreate(savedInstanceState);\n        setContentView(getLayoutId());\n        init(savedInstanceState);\n    &#125;\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">showToast</span><span class=\"hljs-params\">(String msg)</span> </span>&#123;\n        ToastUtils.show(msg);\n    &#125;\n\n    <span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-meta\">@LayoutRes</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">getLayoutId</span><span class=\"hljs-params\">()</span></span>;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">init</span><span class=\"hljs-params\">(Bundle savedInstanceState)</span></span>;\n&#125;</code></pre>\n<p>同样我们项目的BaseFragment继承RxFragment（注意使用继承V4包下的RxFragment），如下：</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">BaseFragment</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">RxFragment</span> </span>&#123;\n\n    <span class=\"hljs-keyword\">public</span> View rootView;\n    <span class=\"hljs-keyword\">public</span> LayoutInflater inflater;\n\n\n    <span class=\"hljs-meta\">@Nullable</span>\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">final</span> View <span class=\"hljs-title\">onCreateView</span><span class=\"hljs-params\">(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState)</span> </span>&#123;\n        <span class=\"hljs-keyword\">super</span>.onCreateView(inflater, container, savedInstanceState);\n        <span class=\"hljs-keyword\">this</span>.inflater = inflater;\n        <span class=\"hljs-keyword\">if</span> (rootView == <span class=\"hljs-keyword\">null</span>) &#123;\n            rootView = inflater.inflate(<span class=\"hljs-keyword\">this</span>.getLayoutId(), container, <span class=\"hljs-keyword\">false</span>);\n            init(savedInstanceState);\n        &#125;\n        ViewGroup parent = (ViewGroup) rootView.getParent();\n        <span class=\"hljs-keyword\">if</span> (parent != <span class=\"hljs-keyword\">null</span>) &#123;\n            parent.removeView(rootView);\n        &#125;\n        <span class=\"hljs-keyword\">return</span> rootView;\n    &#125;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">getLayoutId</span><span class=\"hljs-params\">()</span></span>;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">init</span><span class=\"hljs-params\">(Bundle savedInstanceState)</span></span>;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">showToast</span><span class=\"hljs-params\">(String msg)</span> </span>&#123;\n        ToastUtils.show(msg);\n    &#125;\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onResume</span><span class=\"hljs-params\">()</span> </span>&#123;\n        <span class=\"hljs-keyword\">super</span>.onResume();\n    &#125;\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onPause</span><span class=\"hljs-params\">()</span> </span>&#123;\n        <span class=\"hljs-keyword\">super</span>.onPause();\n    &#125;\n\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onDestroyView</span><span class=\"hljs-params\">()</span> </span>&#123;\n        <span class=\"hljs-keyword\">super</span>.onDestroyView();\n    &#125;\n&#125;</code></pre>\n<p>3.使用compose操作符管理Retrofit生命周期了:</p>\n<pre><code class=\"hljs css\"><span class=\"hljs-selector-tag\">myObservable</span>\n            <span class=\"hljs-selector-class\">.compose</span>(<span class=\"hljs-selector-tag\">bindToLifecycle</span>())\n            <span class=\"hljs-selector-class\">.subscribe</span>();\n\n或者\n\n<span class=\"hljs-selector-tag\">myObservable</span>\n    <span class=\"hljs-selector-class\">.compose</span>(<span class=\"hljs-selector-tag\">RxLifecycle</span><span class=\"hljs-selector-class\">.bindUntilEvent</span>(<span class=\"hljs-selector-tag\">lifecycle</span>, <span class=\"hljs-selector-tag\">ActivityEvent</span><span class=\"hljs-selector-class\">.DESTROY</span>))\n    <span class=\"hljs-selector-class\">.subscribe</span>();\n</code></pre>\n<p>关于RxLifecycle的详细使用方法可以参考 <strong><a href=\"https://github.com/trello/RxLifecycle\">RxLifecycle官网</a></strong></p>\n<h2 id=\"七-如何使用封装\"><a href=\"#七-如何使用封装\" class=\"headerlink\" title=\"七.如何使用封装\"></a>七.如何使用封装</h2><p>前面几节内容讲解了如何RxJava进行二次封装，封装部分的代码可以放在我们项目的Library模块中。那么封装好之后我们应该如何在app模块中使用呢？<br><strong>1.定义一个接口来存放我们项目的API</strong></p>\n<pre><code class=\"hljs less\"><span class=\"hljs-selector-tag\">public</span> <span class=\"hljs-selector-tag\">interface</span> <span class=\"hljs-selector-tag\">IdeaApiService</span> &#123;\n    <span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">     * 此接口服务器响应数据BasicResponse的泛型T应该是List&lt;MeiZi&gt;</span>\n<span class=\"hljs-comment\">     * 即BasicResponse&lt;List&lt;MeiZi&gt;&gt;</span>\n<span class=\"hljs-comment\">     * @return BasicResponse&lt;List&lt;MeiZi&gt;&gt;</span>\n<span class=\"hljs-comment\">     */</span>\n    <span class=\"hljs-variable\">@Headers</span>(<span class=\"hljs-string\">&quot;Cache-Control: public, max-age=10&quot;</span>)<span class=\"hljs-comment\">//设置缓存 缓存时间为100s</span>\n    <span class=\"hljs-variable\">@GET</span>(<span class=\"hljs-string\">&quot;福利/10/1&quot;</span>)\n    Observable&lt;List&lt;MeiZi&gt;&gt; getMezi();\n\n    <span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">     * 登录 接口为假接口 并不能返回数据</span>\n<span class=\"hljs-comment\">     * @return</span>\n<span class=\"hljs-comment\">     */</span>\n    <span class=\"hljs-variable\">@POST</span>(<span class=\"hljs-string\">&quot;login.do&quot;</span>)\n    Observable&lt;LoginResponse&gt; login(<span class=\"hljs-variable\">@Body</span> LoginRequest request);\n\n    <span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">     * 刷新token 接口为假接口 并不能返回数据</span>\n<span class=\"hljs-comment\">     * @return</span>\n<span class=\"hljs-comment\">     */</span>\n    <span class=\"hljs-variable\">@POST</span>(<span class=\"hljs-string\">&quot;refresh_token.do&quot;</span>)\n    Observable&lt;RefreshTokenResponseBean&gt; refreshToken(<span class=\"hljs-variable\">@Body</span> RefreshTokenRequest request);\n\n    <span class=\"hljs-variable\">@Multipart</span>\n    <span class=\"hljs-variable\">@POST</span>(<span class=\"hljs-string\">&quot;upload/uploadFile.do&quot;</span>)\n    Observable&lt;BasicResponse&gt; uploadFiles(<span class=\"hljs-variable\">@Part</span> List&lt;MultipartBody.Part&gt; partList);\n&#125;</code></pre>\n\n<p><strong>2.定义一个RetrofitHelper 类，通过IdeaApi来获取IdeaApiService的实例。</strong></p>\n<pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">RetrofitHelper</span> &#123;</span>\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> IdeaApiService mIdeaApiService;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> IdeaApiService <span class=\"hljs-title\">getApiService</span><span class=\"hljs-params\">()</span></span>&#123;\n        <span class=\"hljs-keyword\">return</span> mIdeaApiService;\n    &#125;\n    <span class=\"hljs-keyword\">static</span> &#123;\n       mIdeaApiService= IdeaApi.getApiService(IdeaApiService.class, Constants.API_SERVER_URL);\n    &#125;\n&#125;</code></pre>\n<p><strong>3.在Activity或者Fragment中发起网络请求</strong></p>\n<pre><code class=\"hljs reasonml\"><span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\"> * Get请求</span>\n<span class=\"hljs-comment\"> * @param view</span>\n<span class=\"hljs-comment\"> */</span>\npublic void get<span class=\"hljs-constructor\">Data(View <span class=\"hljs-params\">view</span>)</span> &#123;\n    <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">RetrofitHelper</span>.</span></span>get<span class=\"hljs-constructor\">ApiService()</span>\n            .get<span class=\"hljs-constructor\">Mezi()</span>\n            .compose(this.&lt;List&lt;MeiZi&gt;&gt;bind<span class=\"hljs-constructor\">ToLifecycle()</span>)\n            .compose(ProgressUtils.&lt;List&lt;MeiZi&gt;&gt;apply<span class=\"hljs-constructor\">ProgressBar(<span class=\"hljs-params\">this</span>)</span>)\n            .subscribe<span class=\"hljs-constructor\">On(Schedulers.<span class=\"hljs-params\">io</span>()</span>)\n            .observe<span class=\"hljs-constructor\">On(AndroidSchedulers.<span class=\"hljs-params\">mainThread</span>()</span>)\n            .subscribe(<span class=\"hljs-keyword\">new</span> DefaultObserver&lt;List&lt;MeiZi&gt;&gt;<span class=\"hljs-literal\">()</span> &#123;\n                @Override\n                public void on<span class=\"hljs-constructor\">Success(List&lt;MeiZi&gt; <span class=\"hljs-params\">response</span>)</span> &#123;\n                    show<span class=\"hljs-constructor\">Toast(<span class=\"hljs-string\">&quot;请求成功，妹子个数为&quot;</span> + <span class=\"hljs-params\">response</span>.<span class=\"hljs-params\">size</span>()</span>);\n                &#125;\n            &#125;);\n&#125;</code></pre>\n\n<h2 id=\"八-小结\"><a href=\"#八-小结\" class=\"headerlink\" title=\"八.小结\"></a>八.小结</h2><p>本篇文章主要讲解了Rxjava和Retrofit的二次封装。以上内容也是笔者参考多方面的资料经过长时间的改动优化而来。但鉴于本人能力有限，其中也避免不了出现不当之处。还请大家多多包涵。另外，在投稿郭神公众号时文章可能还存在很多处理不优雅的地方，比如对响应数据的处理以及对Loading的处理。在投稿被推送后收到了很多小伙伴的建议，因此笔者也参考了大家的意见并做了优化，在此感谢大家。最后如果有疑问欢迎在文章留言评论。</p>\n<p><a href=\"https://blog.csdn.net/qq_20521573/article/details/76100558\">（二）Rxjava2+Retrofit之Token自动刷新</a><br><a href=\"https://blog.csdn.net/qq_20521573/article/details/78356747\">（三）Rxjava2+Retrofit实现文件上传与下载</a></p>\n<p><a href=\"https://github.com/zhpanvip/Retrofit2\"> 源码传送门</a></p>\n","site":{"data":{"fluid_config":{"favicon":"/img/favicon.png","apple_touch_icon":"/img/favicon.png","title_join_string":" - ","force_https":false,"highlight":{"enable":true,"style":"Github Gist","bg_color":false,"copy_btn":true},"fun_features":{"typing":{"enable":true,"typeSpeed":70,"cursorChar":"|","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"mouse_click":{"enable":false,"style":"values"}},"dark_mode":{"enable":true,"default":"auto"},"color":{"body_bg_color":"#eee","body_bg_color_dark":"#181c27","navbar_bg_color":"#2f4154","navbar_bg_color_dark":"#1f3144","navbar_text_color":"#fff","navbar_text_color_dark":"#d0d0d0","text_color":"#3c4858","text_color_dark":"#c4c6c9","sec_text_color":"#718096","sec_text_color_dark":"#a7a9ad","post_text_color":"#2c3e50","post_text_color_dark":"#c4c6c9","post_heading_color":"#1a202c","post_heading_color_dark":"#c4c6c9","post_link_color":"#0366d6","post_link_color_dark":"#1589e9","link_hover_color":"#30a9de","link_hover_color_dark":"#30a9de","link_hover_bg_color":"#f8f9fa","link_hover_bg_color_dark":"#364151","board_color":"#fff","board_color_dark":"#252d38"},"font":{"font_size":"16px","font_family":null,"code_font_size":"85%"},"custom_js":null,"custom_css":null,"custom_html":"","web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"tajs":null,"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}},"lazyload":{"enable":true,"onlypost":false},"daovoice":{"enable":false,"appid":""},"aplayer":{"enable":false,"autoplay":false,"loop":"all","order":"random","theme":"#b7daff","songs":[{"name":"name","artist":"artist","url":"/songs/test.mp3","cover":"/img/cover.jpg"},{"name":"name","artist":"artist","url":"https://...url.mp3","cover":"https://...cover.jpg"}]},"version":{"check":false},"navbar":{"blog_title":"zhangpan","ground_glass":{"enable":false,"px":3,"alpha":0.7},"menu":[{"key":"home","link":"/","icon":"iconfont icon-home-fill"},{"key":"archive","link":"/archives/","icon":"iconfont icon-archive-fill"},{"key":"category","link":"/categories/","icon":"iconfont icon-category-fill"},{"key":"tag","link":"/tags/","icon":"iconfont icon-tags-fill"},{"key":"about","link":"/about/","icon":"iconfont icon-user-fill"}]},"search":{"enable":true,"path":"/local-search.xml","generate_path":"/local-search.xml","field":"post","content":true},"scroll_down_arrow":{"enable":true,"banner_height_limit":90,"scroll_after_turning_page":true},"banner_parallax":true,"footer":{"statistics":{"enable":false,"source":"busuanzi","pv_format":"总访问量 {} 次","uv_format":"总访客数 {} 人"},"beian":{"enable":false,"icp_text":"京ICP证123456号","police_text":"京公网安备12345678号","police_code":12345678,"police_icon":"/img/police_beian.png"}},"scroll_top_arrow":{"enable":true},"index":{"banner_img":"/img/default.png","banner_img_height":100,"banner_mask_alpha":0.3,"post_default_img":"","slogan":{"enable":true,"text":"Talk is cheap, show me the code."},"auto_excerpt":{"enable":true},"post_url_target":"_self","post_meta":{"date":true,"category":true,"tag":true}},"page":{"banner_img":"/img/default.png","banner_img_height":60,"banner_mask_alpha":0.3},"post":{"banner_img":"/img/default.png","banner_img_height":70,"banner_mask_alpha":0.3,"meta":{"date":{"enable":true,"format":"LL a"},"wordcount":{"enable":true,"format":"{} 字"},"min2read":{"enable":true,"format":"{} 分钟","words":100},"views":{"enable":false,"source":"busuanzi","format":"{} 次"}},"updated":{"enable":false,"content":"本文最后更新于：","relative":false},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"copyright":{"enable":true,"content":"本博客所有文章除特别声明外，均采用 <a href=\"https://creativecommons.org/licenses/by-sa/4.0/deed.zh\" rel=\"nofollow noopener\">CC BY-SA 4.0 协议</a> ，转载请注明出处！ <h5>开源库推荐</h5> <a href=\"https://github.com/zhpanvip/BannerViewPager\">1.BannerViewPager</a> <p> 一个基于ViewPager2实现的具有强大功能的无限轮播库。支持多种页面切换效果和指示器样式。 </p>\n<a href=\"https://github.com/zhpanvip/viewpagerindicator\">2.ViewPagerIndicator</a> <p> 一个适用于ViewPager和ViewPager2的指示器，支持多种滑块样式及滑动模式 </p>"},"prev_next":{"enable":true},"custom":{"enable":false,"content":"<img src=\"https://octodex.github.com/images/jetpacktocat.png\" class=\"rounded mx-auto d-block mt-5\" style=\"width:150px; height:150px;\">"},"image_zoom":{"enable":true},"footnote":{"enable":true,"header":""},"math":{"enable":false,"specific":false,"engine":"mathjax"},"mermaid":{"enable":false,"specific":false,"options":{"theme":"default"}},"comments":{"enable":true,"type":"utterances"}},"utterances":{"repo":"zhpanvip/utterances-comment","issue_term":"pathname","label":"utterances","theme":"github-light","crossorigin":"anonymous"},"disqus":{"shortname":null,"disqusjs":false,"apikey":null},"gitalk":{"clientID":null,"clientSecret":null,"repo":null,"owner":null,"admin":["name"],"id":"location.pathname","language":"zh-CN","labels":["Gitalk"],"perPage":10,"pagerDirection":"last","distractionFreeMode":false,"createIssueManually":true},"valine":{"appid":"hXIROaIM5y9qnieojJRWP5hS","appkey":"y0f3w3aqd1MF7JL9ma4WECTy","placeholder":"说点什么","path":"window.location.pathname","avatar":"retro","meta":["nick","mail","link"],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"https://zhangpan.site"},"changyan":{"appid":"","appkey":""},"livere":{"uid":""},"archive":{"banner_img":"/img/bg_article.jpg","banner_img_height":60,"banner_mask_alpha":0.3,"subtitle":null},"category":{"banner_img":"/img/bg_default.png","banner_img_height":60,"banner_mask_alpha":0.3,"subtitle":null,"post_limit":10,"order_by":"-length"},"tag":{"banner_img":"/img/bg_label.jpg","banner_img_height":80,"banner_mask_alpha":0.3,"subtitle":null,"tagcloud":{"min_font":15,"max_font":30,"unit":"px","start_color":"#BBBBEE","end_color":"#337ab7"}},"about":{"banner_img":"/img/bg_default.png","banner_img_height":60,"banner_mask_alpha":0.3,"subtitle":null,"avatar":"/img/avatar.png","name":"myname","introduce":"一句简短的介绍","icons":[{"class":"iconfont icon-github-fill","link":"https://github.com","tip":"GitHub"},{"class":"iconfont icon-douban-fill","link":"https://douban.com","tip":"豆瓣"},{"class":"iconfont icon-wechat-fill","qrcode":"/img/favicon.png"}]},"page404":{"banner_img":"/img/default.png","banner_img_height":85,"banner_mask_alpha":0.3,"subtitle":"Page not found"},"links":{"banner_img":"/img/default.png","banner_img_height":60,"banner_mask_alpha":0.3,"subtitle":null,"items":[{"title":"Fluid Docs","intro":"主题使用指南","link":"https://hexo.fluid-dev.com/docs/","image":"/img/favicon.png"},{"title":"Fluid Repo","intro":"主题 GitHub 仓库","link":"https://github.com/fluid-dev/hexo-theme-fluid","image":"/img/favicon.png"},{"title":"Fluid Example","intro":"主题操作示例","link":"https://hexo.fluid-dev.com/docs/example/","image":"/img/favicon.png"}]}}}},"excerpt":"","more":"<p><strong><em>本篇文章已授权微信公众号 guolin_blog （郭霖）独家发布</em></strong></p>\n<p>要说2016年最火的Android技术是什么，毫无疑问肯定是RxJava+Retrofit+Mvp。现如今2017年也已经过了快一半了。相信做android开发的小伙伴对RxJava和Retrofit也不再陌生。即使没有刻意的去学习过，也应该对RxJava和Retrofit有个一知半解。去年的时候学习了Rxjava和Retrofit的基本用法，但一直没有在实际项目中运用。今年开做新项目，果断在新项目中引入了RxJava和Retrofit。本篇文章将介绍笔者在项目中对Retrofit的封装。<br>先来看一下封装过后的Retrofit如何使用。</p>\n<pre><code class=\"hljs reasonml\"><span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">RetrofitHelper</span>.</span></span>get<span class=\"hljs-constructor\">ApiService()</span>\n                .get<span class=\"hljs-constructor\">Article()</span>\n                .compose(RxUtil.&lt;ArticleWrapper&gt;rx<span class=\"hljs-constructor\">SchedulerHelper(<span class=\"hljs-params\">this</span>)</span>)\n                .subscribe(<span class=\"hljs-keyword\">new</span> DefaultObserver&lt;ArticleWrapper&gt;<span class=\"hljs-literal\">()</span> &#123;\n                    @Override\n                    public void on<span class=\"hljs-constructor\">Success(ArticleWrapper <span class=\"hljs-params\">response</span>)</span> &#123;\n                        show<span class=\"hljs-constructor\">Toast(<span class=\"hljs-string\">&quot;Request Success，size is：&quot;</span> + <span class=\"hljs-params\">response</span>.<span class=\"hljs-params\">getDatas</span>()</span>.size<span class=\"hljs-literal\">()</span>);\n                    &#125;\n                &#125;);</code></pre>\n<p>没错，就是这么简洁的一个链式调用，可以显示加载动画，还加入了Retrofit生命周期的管理。<br>开始之前需要先在module项目里的Gradle文件中添加用到的依赖库</p>\n<pre><code class=\"hljs gradle\"><span class=\"hljs-keyword\">compile</span> <span class=\"hljs-string\">&quot;io.reactivex.rxjava2:rxjava:$rootProject.ext.rxjava2Version&quot;</span>\n   <span class=\"hljs-keyword\">compile</span> <span class=\"hljs-string\">&quot;com.squareup.retrofit2:retrofit:$rootProject.ext.retrofit2Version&quot;</span>\n   <span class=\"hljs-keyword\">compile</span> <span class=\"hljs-string\">&quot;com.squareup.retrofit2:converter-scalars:$rootProject.ext.retrofit2Version&quot;</span>\n   <span class=\"hljs-keyword\">compile</span> <span class=\"hljs-string\">&quot;com.squareup.retrofit2:converter-gson:$rootProject.ext.retrofit2Version&quot;</span>\n   <span class=\"hljs-keyword\">compile</span> <span class=\"hljs-string\">&quot;com.squareup.retrofit2:adapter-rxjava2:$rootProject.ext.retrofit2Version&quot;</span>\n   <span class=\"hljs-keyword\">compile</span> <span class=\"hljs-string\">&#x27;com.jakewharton.retrofit:retrofit2-rxjava2-adapter:1.0.0&#x27;</span>\n   <span class=\"hljs-keyword\">compile</span> <span class=\"hljs-string\">&#x27;io.reactivex.rxjava2:rxandroid:2.0.1&#x27;</span>\n   <span class=\"hljs-keyword\">compile</span> <span class=\"hljs-string\">&#x27;com.squareup.okhttp3:logging-interceptor:3.4.1&#x27;</span>\n   <span class=\"hljs-keyword\">compile</span> <span class=\"hljs-string\">&quot;com.trello.rxlifecycle2:rxlifecycle:$rootProject.ext.rxlifecycle&quot;</span>\n   <span class=\"hljs-comment\">//compile &quot;com.trello.rxlifecycle2:rxlifecycle-android:$rootProject.ext.rxlifecycle&quot;</span>\n   <span class=\"hljs-keyword\">compile</span> <span class=\"hljs-string\">&quot;com.trello.rxlifecycle2:rxlifecycle-components:$rootProject.ext.rxlifecycle&quot;</span></code></pre>\n<p>为了方便依赖库版本的修改我们采用”io.reactivex.rxjava2:rxjava:$rootProject.ext.rxjava2Version”这中方式添加依赖，因此需要在project的build.gradle文件的加上以下内容：</p>\n<pre><code class=\"hljs lsl\">ext &#123;\n    supportLibVersion = &#x27;<span class=\"hljs-number\">25.1</span><span class=\"hljs-number\">.0</span>&#x27;\n    butterknifeVersion = &#x27;<span class=\"hljs-number\">8.5</span><span class=\"hljs-number\">.1</span>&#x27;\n    rxjava2Version = &#x27;<span class=\"hljs-number\">2.0</span><span class=\"hljs-number\">.8</span>&#x27;\n    retrofit2Version = &#x27;<span class=\"hljs-number\">2.2</span><span class=\"hljs-number\">.0</span>&#x27;\n    rxlifecycle=&#x27;<span class=\"hljs-number\">2.1</span><span class=\"hljs-number\">.0</span>&#x27;\n    gsonVersion = &#x27;<span class=\"hljs-number\">2.8</span><span class=\"hljs-number\">.0</span>&#x27;\n&#125;</code></pre>\n<p>下面将通过几个小节对本次封装作详细的解析：</p>\n<ul>\n<li>服务器响应数据的基类BasicResponse</li>\n<li>构建初始化Retrofit的工具类IdeaApi</li>\n<li>通过GsonConverterFactory获取真实响应数据</li>\n<li>封装DefaultObserver处理服务器响应</li>\n<li>处理加载Loading</li>\n<li>管理Retrofit生命周期</li>\n<li>如何使用封装</li>\n<li>小结</li>\n</ul>\n<h2 id=\"一-服务器响应数据的基类BasicResponse。\"><a href=\"#一-服务器响应数据的基类BasicResponse。\" class=\"headerlink\" title=\"一.服务器响应数据的基类BasicResponse。\"></a>一.服务器响应数据的基类BasicResponse。</h2><p>假定服务器返回的Json数据格式如下：</p>\n<pre><code class=\"hljs clojure\">&#123;\n <span class=\"hljs-string\">&quot;code&quot;</span>: <span class=\"hljs-number\">200</span>,\n <span class=\"hljs-string\">&quot;message&quot;</span>: <span class=\"hljs-string\">&quot;成功&quot;</span>,\n <span class=\"hljs-string\">&quot;content&quot;</span>: &#123;\n\t...\n\t&#125;\n&#125;</code></pre>\n<p>根据Json数据格式构建我们的BasicResponse（BasicResponse中的字段内容需要根据自己服务器返回的数据确定）。代码如下：</p>\n<pre><code class=\"hljs arduino\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">BasicResponse</span>&lt;T&gt; &#123;</span>\n\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">int</span> code;\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">String</span> message;\n    <span class=\"hljs-keyword\">private</span> T content;\n\t...此处省去<span class=\"hljs-built_in\">get</span>、<span class=\"hljs-built_in\">set</span>方法。</code></pre>\n\n<h2 id=\"二-构建初始化Retrofit的工具类IdeaApi。\"><a href=\"#二-构建初始化Retrofit的工具类IdeaApi。\" class=\"headerlink\" title=\"二.构建初始化Retrofit的工具类IdeaApi。\"></a>二.构建初始化Retrofit的工具类IdeaApi。</h2><p>该类通过RetrofitUtils来获取ApiService的实例。代码如下：</p>\n<pre><code class=\"hljs arduino\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">IdeaApi</span> &#123;</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> &lt;T&gt; <span class=\"hljs-function\">T <span class=\"hljs-title\">getApiService</span><span class=\"hljs-params\">(Class&lt;T&gt; cls,<span class=\"hljs-keyword\">String</span> baseUrl)</span> </span>&#123;\n        Retrofit retrofit = RetrofitUtils .getRetrofitBuilder(baseUrl).build();\n        <span class=\"hljs-keyword\">return</span> retrofit.create(cls);\n    &#125;\n&#125;</code></pre>\n<p>RetrofitUtils用来构建Retrofit.Builder，并对OkHttp做以下几个方面的配置：</p>\n<ol>\n<li>设置日志拦截器，拦截服务器返回的json数据。Retrofit将请求到json数据直接转换成了实体类，但有时候我们需要查看json数据，Retrofit并没有提供直接获取json数据的功能。因此我们需要自定义一个日志拦截器拦截json数据，并输入到控制台。</li>\n<li>设置Http请求头。给OkHttp 添加请求头拦截器，配置请求头信息。还可以为接口统一添加请求头数据。例如，把用户名、密码（或者token）统一添加到请求头。后续每个接口的请求头中都会携带用户名、密码（或者token）数据，避免了为每个接口单独添加。</li>\n<li>为OkHttp配置缓存。同样可以同过拦截器实现缓存处理。包括控制缓存的最大生命值，控制缓存的过期时间。</li>\n<li>如果采用https，我们还可以在此处理证书校验以及服务器校验。</li>\n<li>为Retrofit添加GsonConverterFactory。此处是一个比较重要的环节，将在后边详细讲解。<br>RetrofitUtils 代码如下：<pre><code class=\"hljs reasonml\">public <span class=\"hljs-keyword\">class</span> RetrofitUtils &#123;\n    public static OkHttpClient.Builder get<span class=\"hljs-constructor\">OkHttpClientBuilder()</span> &#123;\n\n        HttpLoggingInterceptor loggingInterceptor = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-constructor\">HttpLoggingInterceptor(<span class=\"hljs-params\">new</span> HttpLoggingInterceptor.Logger()</span> &#123;\n            @Override\n            public void log(String message) &#123;\n                <span class=\"hljs-keyword\">try</span> &#123;\n                    <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">LogUtils</span>.</span></span>e(<span class=\"hljs-string\">&quot;OKHttp-----&quot;</span>, <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">URLDecoder</span>.</span></span>decode(message, <span class=\"hljs-string\">&quot;utf-8&quot;</span>));\n                &#125; catch (UnsupportedEncodingException e) &#123;\n                    e.print<span class=\"hljs-constructor\">StackTrace()</span>;\n                    <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">LogUtils</span>.</span></span>e(<span class=\"hljs-string\">&quot;OKHttp-----&quot;</span>, message);\n                &#125;\n            &#125;\n        &#125;);\n        loggingInterceptor.set<span class=\"hljs-constructor\">Level(HttpLoggingInterceptor.Level.BODY)</span>;\n\n        File cacheFile = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-constructor\">File(Utils.<span class=\"hljs-params\">getContext</span>()</span>.get<span class=\"hljs-constructor\">CacheDir()</span>, <span class=\"hljs-string\">&quot;cache&quot;</span>);\n        Cache cache = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-constructor\">Cache(<span class=\"hljs-params\">cacheFile</span>, 1024 <span class=\"hljs-operator\">*</span> 1024 <span class=\"hljs-operator\">*</span> 100)</span>; <span class=\"hljs-comment\">//100Mb</span>\n\n        return <span class=\"hljs-keyword\">new</span> OkHttpClient.<span class=\"hljs-constructor\">Builder()</span>\n                .read<span class=\"hljs-constructor\">Timeout(Constants.DEFAULT_TIMEOUT, TimeUnit.MILLISECONDS)</span>\n                .connect<span class=\"hljs-constructor\">Timeout(Constants.DEFAULT_TIMEOUT, TimeUnit.MILLISECONDS)</span>\n                .add<span class=\"hljs-constructor\">Interceptor(<span class=\"hljs-params\">loggingInterceptor</span>)</span>\n                .add<span class=\"hljs-constructor\">Interceptor(<span class=\"hljs-params\">new</span> HttpHeaderInterceptor()</span>)\n                .add<span class=\"hljs-constructor\">NetworkInterceptor(<span class=\"hljs-params\">new</span> HttpCacheInterceptor()</span>)\n               <span class=\"hljs-comment\">// .sslSocketFactory(SslContextFactory.getSSLSocketFactoryForTwoWay())  // https认证 如果要使用https且为自定义证书 可以去掉这两行注释，并自行配制证书。</span>\n               <span class=\"hljs-comment\">// .hostnameVerifier(new SafeHostnameVerifier())</span>\n                .cache(cache);\n    &#125;\n\n    public static Retrofit.Builder get<span class=\"hljs-constructor\">RetrofitBuilder(String <span class=\"hljs-params\">baseUrl</span>)</span> &#123;\n        Gson gson = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-constructor\">GsonBuilder()</span>.set<span class=\"hljs-constructor\">DateFormat(<span class=\"hljs-string\">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>)</span>.serialize<span class=\"hljs-constructor\">Nulls()</span>.create<span class=\"hljs-literal\">()</span>;\n        OkHttpClient okHttpClient = <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">RetrofitUtils</span>.</span></span>get<span class=\"hljs-constructor\">OkHttpClientBuilder()</span>.build<span class=\"hljs-literal\">()</span>;\n        return <span class=\"hljs-keyword\">new</span> Retrofit.<span class=\"hljs-constructor\">Builder()</span>\n                .client(okHttpClient)\n                .add<span class=\"hljs-constructor\">ConverterFactory(GsonConverterFactory.<span class=\"hljs-params\">create</span>(<span class=\"hljs-params\">gson</span>)</span>)\n                .add<span class=\"hljs-constructor\">CallAdapterFactory(RxJava2CallAdapterFactory.<span class=\"hljs-params\">create</span>()</span>)\n                .base<span class=\"hljs-constructor\">Url(<span class=\"hljs-params\">baseUrl</span>)</span>;\n    &#125;\n&#125;</code></pre>\n\n</li>\n</ol>\n<h2 id=\"三-通过GsonConverterFactory获取真实响应数据\"><a href=\"#三-通过GsonConverterFactory获取真实响应数据\" class=\"headerlink\" title=\"三.通过GsonConverterFactory获取真实响应数据\"></a>三.通过GsonConverterFactory获取真实响应数据</h2><p>在第一节中我们构建了服务器响应数据BasicResponse，BasicResponse由code、message、和content三个字段。其中code为服务器返回的错误码。我们会事先和服务器约定成功时的code值，比如200表示请求成功。但通常在请求服务器数据过程中免不了会出现各种错误。例如用户登录时密码错误、请求参数错误的情况。此时服务器会根据错误情况返回对应的错误码。一般来说，我们只关心成功时即code为200时的content数据。而对于code不为200时我们只需要给出对应的Toast提示即可。事实上我们对我们有用的仅仅时code为200时的content数据。因此我们可以考虑过滤掉code和message，在请求成功的回调中只返回content的内容。<br>在此种情况下就需要我们通过自定义GsonConverterFactory来实现了。我们可以直接从Retrofit的源码中copy出GsonConverterFactory的三个相关类来做修改。<br>其中最终要的一部分是修改GsonResponseBodyConverter中的convert方法。在该方法中拿到服务器响应数据并判断code是否为200。如果是，则获取到content并返回，如果不是，则在此处可以抛出对应的自定义的异常。然后再Observer中统一处理异常情况。GsonResponseBodyConverter代码如下：</p>\n<pre><code class=\"hljs angelscript\"><span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-symbol\">GsonResponseBodyConverter</span>&lt;<span class=\"hljs-symbol\">T</span>&gt; <span class=\"hljs-symbol\">implements</span> <span class=\"hljs-symbol\">Converter</span>&lt;<span class=\"hljs-symbol\">ResponseBody, <span class=\"hljs-symbol\">Object</span></span>&gt; &#123;\n\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">final</span> TypeAdapter&lt;T&gt; adapter;\n\n    GsonResponseBodyConverter(TypeAdapter&lt;T&gt; adapter) &#123;\n        <span class=\"hljs-keyword\">this</span>.adapter = adapter;\n    &#125;\n\n    @Override\n    <span class=\"hljs-keyword\">public</span> Object convert(ResponseBody value) throws IOException &#123;\n        <span class=\"hljs-keyword\">try</span> &#123;\n            BasicResponse response = (BasicResponse) adapter.fromJson(value.charStream());\n            <span class=\"hljs-keyword\">if</span> (response.getCode()==<span class=\"hljs-number\">200</span>) &#123;\n            <span class=\"hljs-keyword\">return</span> response.getResults();\n            &#125; <span class=\"hljs-keyword\">else</span> &#123;\n                <span class=\"hljs-comment\">// 特定 API 的错误，在相应的 DefaultObserver 的 onError 的方法中进行处理</span>\n                throw new ServerResponseException(response.getCode(), response.getMessage());\n            &#125;\n        &#125; finally &#123;\n            value.close();\n        &#125;\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">null</span>;\n    &#125;\n&#125;</code></pre>\n\n<h2 id=\"四-构建DefaultObserver处理服务器响应。\"><a href=\"#四-构建DefaultObserver处理服务器响应。\" class=\"headerlink\" title=\"四.构建DefaultObserver处理服务器响应。\"></a>四.构建DefaultObserver处理服务器响应。</h2><p>上一节中我们讲到了在请求服务器时可能出现的一些例如密码错误、参数错误的情况，服务器给我们返回了对应的错误码，我们根据错误码抛出了对应自定义异常。除此之外在我们发起网络请求时还可能发生一些异常情况。例如没有网络、请求超时或者服务器返回了数据但在解析时出现了数据解析异常等。对于这样的情况我们也要进行统一处理的。那么我们就需要自定义一个DefaultObserver类继承Observer，并重写相应的方法。<br>该类中最重要的两个方法时onNext和onError。<br><strong>1.在服务器返回数据成功的情况下会回调到onNext方法。</strong>因此我们可以在DefaultObserver中定义一个抽象方法onSuccess(T response)，在调用网络时重写onSuccess方法即可。<br><strong>2.如果在请求服务器过程中出现任何异常，都会回调到onError方法中。</strong>包括上节中我们自己抛出的异常都会回调到onError。因此我们的重头戏就是处理onError。在onError中我们根据异常信息给出对应的Toast提示即可。<br>DefaultObserver类的代码如下：</p>\n<pre><code class=\"hljs reasonml\">public abstract <span class=\"hljs-keyword\">class</span> DefaultObserver&lt;T&gt; implements Observer&lt;T&gt; &#123;\n    @Override\n    public void on<span class=\"hljs-constructor\">Subscribe(Disposable <span class=\"hljs-params\">d</span>)</span> &#123;\n\n    &#125;\n\n    @Override\n    public void on<span class=\"hljs-constructor\">Next(T <span class=\"hljs-params\">response</span>)</span> &#123;\n        on<span class=\"hljs-constructor\">Success(<span class=\"hljs-params\">response</span>)</span>;\n        on<span class=\"hljs-constructor\">Finish()</span>;\n    &#125;\n\n    @Override\n    public void on<span class=\"hljs-constructor\">Error(Throwable <span class=\"hljs-params\">e</span>)</span> &#123;\n        <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">LogUtils</span>.</span></span>e(<span class=\"hljs-string\">&quot;Retrofit&quot;</span>, e.get<span class=\"hljs-constructor\">Message()</span>);\n        <span class=\"hljs-keyword\">if</span> (e instanceof HttpException) &#123;     <span class=\"hljs-comment\">//   HTTP错误</span>\n            on<span class=\"hljs-constructor\">Exception(ExceptionReason.BAD_NETWORK)</span>;\n        &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (e instanceof ConnectException\n<span class=\"hljs-operator\">                || </span>e instanceof UnknownHostException) &#123;   <span class=\"hljs-comment\">//   连接错误</span>\n            on<span class=\"hljs-constructor\">Exception(ExceptionReason.CONNECT_ERROR)</span>;\n        &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (e instanceof InterruptedIOException) &#123;   <span class=\"hljs-comment\">//  连接超时</span>\n            on<span class=\"hljs-constructor\">Exception(ExceptionReason.CONNECT_TIMEOUT)</span>;\n        &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (e instanceof JsonParseException\n<span class=\"hljs-operator\">                || </span>e instanceof JSONException\n<span class=\"hljs-operator\">                || </span>e instanceof ParseException) &#123;   <span class=\"hljs-comment\">//  解析错误</span>\n            on<span class=\"hljs-constructor\">Exception(ExceptionReason.PARSE_ERROR)</span>;\n        &#125;<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(e instanceof ServerResponseException)&#123;\n            on<span class=\"hljs-constructor\">Fail(<span class=\"hljs-params\">e</span>.<span class=\"hljs-params\">getMessage</span>()</span>);\n        &#125; <span class=\"hljs-keyword\">else</span> &#123;\n            on<span class=\"hljs-constructor\">Exception(ExceptionReason.UNKNOWN_ERROR)</span>;\n        &#125;\n        on<span class=\"hljs-constructor\">Finish()</span>;\n    &#125;\n\n    @Override\n    public void on<span class=\"hljs-constructor\">Complete()</span> &#123;\n    &#125;\n\n    <span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">     * 请求成功</span>\n<span class=\"hljs-comment\">     *</span>\n<span class=\"hljs-comment\">     * @param response 服务器返回的数据</span>\n<span class=\"hljs-comment\">     */</span>\n    abstract public void on<span class=\"hljs-constructor\">Success(T <span class=\"hljs-params\">response</span>)</span>;\n\n    <span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">     * 服务器返回数据，但响应码不为200</span>\n<span class=\"hljs-comment\">     *</span>\n<span class=\"hljs-comment\">     */</span>\n    public void on<span class=\"hljs-constructor\">Fail(String <span class=\"hljs-params\">message</span>)</span> &#123;\n        <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">ToastUtils</span>.</span></span>show(message);\n    &#125;\n    \n    public void on<span class=\"hljs-constructor\">Finish()</span>&#123;&#125;\n\n    <span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">     * 请求异常</span>\n<span class=\"hljs-comment\">     *</span>\n<span class=\"hljs-comment\">     * @param reason</span>\n<span class=\"hljs-comment\">     */</span>\n    public void on<span class=\"hljs-constructor\">Exception(ExceptionReason <span class=\"hljs-params\">reason</span>)</span> &#123;\n        switch (reason) &#123;\n            case CONNECT_ERROR:\n                <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">ToastUtils</span>.</span></span>show(<span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">R</span>.</span></span><span class=\"hljs-built_in\">string</span>.connect_error, Toast.LENGTH_SHORT);\n                break;\n\n            case CONNECT_TIMEOUT:\n                <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">ToastUtils</span>.</span></span>show(<span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">R</span>.</span></span><span class=\"hljs-built_in\">string</span>.connect_timeout, Toast.LENGTH_SHORT);\n                break;\n\n            case BAD_NETWORK:\n                <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">ToastUtils</span>.</span></span>show(<span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">R</span>.</span></span><span class=\"hljs-built_in\">string</span>.bad_network, Toast.LENGTH_SHORT);\n                break;\n\n            case PARSE_ERROR:\n                <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">ToastUtils</span>.</span></span>show(<span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">R</span>.</span></span><span class=\"hljs-built_in\">string</span>.parse_error, Toast.LENGTH_SHORT);\n                break;\n\n            case UNKNOWN_ERROR:\n            default:\n                <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">ToastUtils</span>.</span></span>show(<span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">R</span>.</span></span><span class=\"hljs-built_in\">string</span>.unknown_error, Toast.LENGTH_SHORT);\n                break;\n        &#125;\n    &#125;\n\n    <span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">     * 请求网络失败原因</span>\n<span class=\"hljs-comment\">     */</span>\n    public enum ExceptionReason &#123;\n        <span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">         * 解析数据失败</span>\n<span class=\"hljs-comment\">         */</span>\n        PARSE_ERROR,\n        <span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">         * 网络问题</span>\n<span class=\"hljs-comment\">         */</span>\n        BAD_NETWORK,\n        <span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">         * 连接错误</span>\n<span class=\"hljs-comment\">         */</span>\n        CONNECT_ERROR,\n        <span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">         * 连接超时</span>\n<span class=\"hljs-comment\">         */</span>\n        CONNECT_TIMEOUT,\n        <span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">         * 未知错误</span>\n<span class=\"hljs-comment\">         */</span>\n        UNKNOWN_ERROR,\n    &#125;\n&#125;</code></pre>\n\n<h2 id=\"五-处理加载Loading\"><a href=\"#五-处理加载Loading\" class=\"headerlink\" title=\"五.处理加载Loading\"></a>五.处理加载Loading</h2><p>关于Loading我们可以通过RxJava的compose操作符来做一个非常优雅的处理。首先定义一个ProgressUtils工具类，然后通过RxJava的ObservableTransformer做一个变换来处理Loading。想要显示Loading，只需要加上.compose(ProgressUtils.&lt; T &gt;applyProgressBar(this))即可。<br>ProgressUtils代码如下：</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ProgressUtils</span> </span>&#123;\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> &lt;T&gt; <span class=\"hljs-function\">ObservableTransformer&lt;T, T&gt; <span class=\"hljs-title\">applyProgressBar</span><span class=\"hljs-params\">(</span></span>\n<span class=\"hljs-function\"><span class=\"hljs-params\">            <span class=\"hljs-meta\">@NonNull</span> <span class=\"hljs-keyword\">final</span> Activity activity, String msg)</span> </span>&#123;\n        <span class=\"hljs-keyword\">final</span> WeakReference&lt;Activity&gt; activityWeakReference = <span class=\"hljs-keyword\">new</span> WeakReference&lt;&gt;(activity);\n        <span class=\"hljs-keyword\">final</span> DialogUtils dialogUtils = <span class=\"hljs-keyword\">new</span> DialogUtils();\n        dialogUtils.showProgress(activityWeakReference.get());\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> ObservableTransformer&lt;T, T&gt;() &#123;\n            <span class=\"hljs-meta\">@Override</span>\n            <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> ObservableSource&lt;T&gt; <span class=\"hljs-title\">apply</span><span class=\"hljs-params\">(Observable&lt;T&gt; upstream)</span> </span>&#123;\n                <span class=\"hljs-keyword\">return</span> upstream.doOnSubscribe(<span class=\"hljs-keyword\">new</span> Consumer&lt;Disposable&gt;() &#123;\n                    <span class=\"hljs-meta\">@Override</span>\n                    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">accept</span><span class=\"hljs-params\">(Disposable disposable)</span> <span class=\"hljs-keyword\">throws</span> Exception </span>&#123;\n\n                    &#125;\n                &#125;).doOnTerminate(<span class=\"hljs-keyword\">new</span> Action() &#123;\n                    <span class=\"hljs-meta\">@Override</span>\n                    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">run</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> Exception </span>&#123;\n                        Activity context;\n                        <span class=\"hljs-keyword\">if</span> ((context = activityWeakReference.get()) != <span class=\"hljs-keyword\">null</span>\n                                &amp;&amp; !context.isFinishing()) &#123;\n                            dialogUtils.dismissProgress();\n                        &#125;\n                    &#125;\n                &#125;).doOnSubscribe(<span class=\"hljs-keyword\">new</span> Consumer&lt;Disposable&gt;() &#123;\n                    <span class=\"hljs-meta\">@Override</span>\n                    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">accept</span><span class=\"hljs-params\">(Disposable disposable)</span> <span class=\"hljs-keyword\">throws</span> Exception </span>&#123;\n                        <span class=\"hljs-comment\">/*Activity context;</span>\n<span class=\"hljs-comment\">                        if ((context = activityWeakReference.get()) != null</span>\n<span class=\"hljs-comment\">                                &amp;&amp; !context.isFinishing()) &#123;</span>\n<span class=\"hljs-comment\">                            dialogUtils.dismissProgress();</span>\n<span class=\"hljs-comment\">                        &#125;*/</span>\n                    &#125;\n                &#125;);\n            &#125;\n        &#125;;\n    &#125;\n\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> &lt;T&gt; <span class=\"hljs-function\">ObservableTransformer&lt;T, T&gt; <span class=\"hljs-title\">applyProgressBar</span><span class=\"hljs-params\">(</span></span>\n<span class=\"hljs-function\"><span class=\"hljs-params\">            <span class=\"hljs-meta\">@NonNull</span> <span class=\"hljs-keyword\">final</span> Activity activity)</span> </span>&#123;\n        <span class=\"hljs-keyword\">return</span> applyProgressBar(activity, <span class=\"hljs-string\">&quot;&quot;</span>);\n    &#125;\n&#125;</code></pre>\n<p>至此关于RxJava和Retrofit的二次封装已经基本完成。但是我们不能忽略了很重要的一点，就是网络请求的生命周期。我们将在下一节中详细讲解。</p>\n<h2 id=\"六、管理Retrofit生命周期\"><a href=\"#六、管理Retrofit生命周期\" class=\"headerlink\" title=\"六、管理Retrofit生命周期\"></a>六、管理Retrofit生命周期</h2><p>当activity被销毁时，网络请求也应该随之终止的。要不然就可能造成内存泄漏。会严重影到响App的性能！因此Retrofit生命周期的管理也是比较重要的一点内容。在这里我们使用 **<a href=\"https://github.com/trello/RxLifecycle\">RxLifecycle</a>**来对Retrofit进行生命周期管理。其使用流程如下：</p>\n<p><strong>1.在gradel中添加依赖如下：</strong></p>\n<pre><code class=\"hljs apache\"><span class=\"hljs-attribute\">compile</span> &#x27;com.trello.rxlifecycle<span class=\"hljs-number\">2</span>:rxlifecycle:<span class=\"hljs-number\">2</span>.<span class=\"hljs-number\">1</span>.<span class=\"hljs-number\">0</span>&#x27;\n<span class=\"hljs-attribute\">compile</span> &#x27;com.trello.rxlifecycle<span class=\"hljs-number\">2</span>:rxlifecycle-components:<span class=\"hljs-number\">2</span>.<span class=\"hljs-number\">1</span>.<span class=\"hljs-number\">0</span>&#x27;\n</code></pre>\n<p><strong>2.让我们的BaseActivity继承RxAppCompatActivity。</strong><br>具体代码如下：</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">BaseActivity</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">RxAppCompatActivity</span> </span>&#123;\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onCreate</span><span class=\"hljs-params\">(Bundle savedInstanceState)</span> </span>&#123;\n        <span class=\"hljs-keyword\">super</span>.onCreate(savedInstanceState);\n        setContentView(getLayoutId());\n        init(savedInstanceState);\n    &#125;\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">showToast</span><span class=\"hljs-params\">(String msg)</span> </span>&#123;\n        ToastUtils.show(msg);\n    &#125;\n\n    <span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-meta\">@LayoutRes</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">getLayoutId</span><span class=\"hljs-params\">()</span></span>;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">init</span><span class=\"hljs-params\">(Bundle savedInstanceState)</span></span>;\n&#125;</code></pre>\n<p>同样我们项目的BaseFragment继承RxFragment（注意使用继承V4包下的RxFragment），如下：</p>\n<pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">BaseFragment</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">RxFragment</span> </span>&#123;\n\n    <span class=\"hljs-keyword\">public</span> View rootView;\n    <span class=\"hljs-keyword\">public</span> LayoutInflater inflater;\n\n\n    <span class=\"hljs-meta\">@Nullable</span>\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">final</span> View <span class=\"hljs-title\">onCreateView</span><span class=\"hljs-params\">(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState)</span> </span>&#123;\n        <span class=\"hljs-keyword\">super</span>.onCreateView(inflater, container, savedInstanceState);\n        <span class=\"hljs-keyword\">this</span>.inflater = inflater;\n        <span class=\"hljs-keyword\">if</span> (rootView == <span class=\"hljs-keyword\">null</span>) &#123;\n            rootView = inflater.inflate(<span class=\"hljs-keyword\">this</span>.getLayoutId(), container, <span class=\"hljs-keyword\">false</span>);\n            init(savedInstanceState);\n        &#125;\n        ViewGroup parent = (ViewGroup) rootView.getParent();\n        <span class=\"hljs-keyword\">if</span> (parent != <span class=\"hljs-keyword\">null</span>) &#123;\n            parent.removeView(rootView);\n        &#125;\n        <span class=\"hljs-keyword\">return</span> rootView;\n    &#125;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">getLayoutId</span><span class=\"hljs-params\">()</span></span>;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">init</span><span class=\"hljs-params\">(Bundle savedInstanceState)</span></span>;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">showToast</span><span class=\"hljs-params\">(String msg)</span> </span>&#123;\n        ToastUtils.show(msg);\n    &#125;\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onResume</span><span class=\"hljs-params\">()</span> </span>&#123;\n        <span class=\"hljs-keyword\">super</span>.onResume();\n    &#125;\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onPause</span><span class=\"hljs-params\">()</span> </span>&#123;\n        <span class=\"hljs-keyword\">super</span>.onPause();\n    &#125;\n\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onDestroyView</span><span class=\"hljs-params\">()</span> </span>&#123;\n        <span class=\"hljs-keyword\">super</span>.onDestroyView();\n    &#125;\n&#125;</code></pre>\n<p>3.使用compose操作符管理Retrofit生命周期了:</p>\n<pre><code class=\"hljs css\"><span class=\"hljs-selector-tag\">myObservable</span>\n            <span class=\"hljs-selector-class\">.compose</span>(<span class=\"hljs-selector-tag\">bindToLifecycle</span>())\n            <span class=\"hljs-selector-class\">.subscribe</span>();\n\n或者\n\n<span class=\"hljs-selector-tag\">myObservable</span>\n    <span class=\"hljs-selector-class\">.compose</span>(<span class=\"hljs-selector-tag\">RxLifecycle</span><span class=\"hljs-selector-class\">.bindUntilEvent</span>(<span class=\"hljs-selector-tag\">lifecycle</span>, <span class=\"hljs-selector-tag\">ActivityEvent</span><span class=\"hljs-selector-class\">.DESTROY</span>))\n    <span class=\"hljs-selector-class\">.subscribe</span>();\n</code></pre>\n<p>关于RxLifecycle的详细使用方法可以参考 <strong><a href=\"https://github.com/trello/RxLifecycle\">RxLifecycle官网</a></strong></p>\n<h2 id=\"七-如何使用封装\"><a href=\"#七-如何使用封装\" class=\"headerlink\" title=\"七.如何使用封装\"></a>七.如何使用封装</h2><p>前面几节内容讲解了如何RxJava进行二次封装，封装部分的代码可以放在我们项目的Library模块中。那么封装好之后我们应该如何在app模块中使用呢？<br><strong>1.定义一个接口来存放我们项目的API</strong></p>\n<pre><code class=\"hljs less\"><span class=\"hljs-selector-tag\">public</span> <span class=\"hljs-selector-tag\">interface</span> <span class=\"hljs-selector-tag\">IdeaApiService</span> &#123;\n    <span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">     * 此接口服务器响应数据BasicResponse的泛型T应该是List&lt;MeiZi&gt;</span>\n<span class=\"hljs-comment\">     * 即BasicResponse&lt;List&lt;MeiZi&gt;&gt;</span>\n<span class=\"hljs-comment\">     * @return BasicResponse&lt;List&lt;MeiZi&gt;&gt;</span>\n<span class=\"hljs-comment\">     */</span>\n    <span class=\"hljs-variable\">@Headers</span>(<span class=\"hljs-string\">&quot;Cache-Control: public, max-age=10&quot;</span>)<span class=\"hljs-comment\">//设置缓存 缓存时间为100s</span>\n    <span class=\"hljs-variable\">@GET</span>(<span class=\"hljs-string\">&quot;福利/10/1&quot;</span>)\n    Observable&lt;List&lt;MeiZi&gt;&gt; getMezi();\n\n    <span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">     * 登录 接口为假接口 并不能返回数据</span>\n<span class=\"hljs-comment\">     * @return</span>\n<span class=\"hljs-comment\">     */</span>\n    <span class=\"hljs-variable\">@POST</span>(<span class=\"hljs-string\">&quot;login.do&quot;</span>)\n    Observable&lt;LoginResponse&gt; login(<span class=\"hljs-variable\">@Body</span> LoginRequest request);\n\n    <span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">     * 刷新token 接口为假接口 并不能返回数据</span>\n<span class=\"hljs-comment\">     * @return</span>\n<span class=\"hljs-comment\">     */</span>\n    <span class=\"hljs-variable\">@POST</span>(<span class=\"hljs-string\">&quot;refresh_token.do&quot;</span>)\n    Observable&lt;RefreshTokenResponseBean&gt; refreshToken(<span class=\"hljs-variable\">@Body</span> RefreshTokenRequest request);\n\n    <span class=\"hljs-variable\">@Multipart</span>\n    <span class=\"hljs-variable\">@POST</span>(<span class=\"hljs-string\">&quot;upload/uploadFile.do&quot;</span>)\n    Observable&lt;BasicResponse&gt; uploadFiles(<span class=\"hljs-variable\">@Part</span> List&lt;MultipartBody.Part&gt; partList);\n&#125;</code></pre>\n\n<p><strong>2.定义一个RetrofitHelper 类，通过IdeaApi来获取IdeaApiService的实例。</strong></p>\n<pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">RetrofitHelper</span> &#123;</span>\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> IdeaApiService mIdeaApiService;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> IdeaApiService <span class=\"hljs-title\">getApiService</span><span class=\"hljs-params\">()</span></span>&#123;\n        <span class=\"hljs-keyword\">return</span> mIdeaApiService;\n    &#125;\n    <span class=\"hljs-keyword\">static</span> &#123;\n       mIdeaApiService= IdeaApi.getApiService(IdeaApiService.class, Constants.API_SERVER_URL);\n    &#125;\n&#125;</code></pre>\n<p><strong>3.在Activity或者Fragment中发起网络请求</strong></p>\n<pre><code class=\"hljs reasonml\"><span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\"> * Get请求</span>\n<span class=\"hljs-comment\"> * @param view</span>\n<span class=\"hljs-comment\"> */</span>\npublic void get<span class=\"hljs-constructor\">Data(View <span class=\"hljs-params\">view</span>)</span> &#123;\n    <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">RetrofitHelper</span>.</span></span>get<span class=\"hljs-constructor\">ApiService()</span>\n            .get<span class=\"hljs-constructor\">Mezi()</span>\n            .compose(this.&lt;List&lt;MeiZi&gt;&gt;bind<span class=\"hljs-constructor\">ToLifecycle()</span>)\n            .compose(ProgressUtils.&lt;List&lt;MeiZi&gt;&gt;apply<span class=\"hljs-constructor\">ProgressBar(<span class=\"hljs-params\">this</span>)</span>)\n            .subscribe<span class=\"hljs-constructor\">On(Schedulers.<span class=\"hljs-params\">io</span>()</span>)\n            .observe<span class=\"hljs-constructor\">On(AndroidSchedulers.<span class=\"hljs-params\">mainThread</span>()</span>)\n            .subscribe(<span class=\"hljs-keyword\">new</span> DefaultObserver&lt;List&lt;MeiZi&gt;&gt;<span class=\"hljs-literal\">()</span> &#123;\n                @Override\n                public void on<span class=\"hljs-constructor\">Success(List&lt;MeiZi&gt; <span class=\"hljs-params\">response</span>)</span> &#123;\n                    show<span class=\"hljs-constructor\">Toast(<span class=\"hljs-string\">&quot;请求成功，妹子个数为&quot;</span> + <span class=\"hljs-params\">response</span>.<span class=\"hljs-params\">size</span>()</span>);\n                &#125;\n            &#125;);\n&#125;</code></pre>\n\n<h2 id=\"八-小结\"><a href=\"#八-小结\" class=\"headerlink\" title=\"八.小结\"></a>八.小结</h2><p>本篇文章主要讲解了Rxjava和Retrofit的二次封装。以上内容也是笔者参考多方面的资料经过长时间的改动优化而来。但鉴于本人能力有限，其中也避免不了出现不当之处。还请大家多多包涵。另外，在投稿郭神公众号时文章可能还存在很多处理不优雅的地方，比如对响应数据的处理以及对Loading的处理。在投稿被推送后收到了很多小伙伴的建议，因此笔者也参考了大家的意见并做了优化，在此感谢大家。最后如果有疑问欢迎在文章留言评论。</p>\n<p><a href=\"https://blog.csdn.net/qq_20521573/article/details/76100558\">（二）Rxjava2+Retrofit之Token自动刷新</a><br><a href=\"https://blog.csdn.net/qq_20521573/article/details/78356747\">（三）Rxjava2+Retrofit实现文件上传与下载</a></p>\n<p><a href=\"https://github.com/zhpanvip/Retrofit2\"> 源码传送门</a></p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"ckegm5nrm0001dwoz6qr9gbhu","tag_id":"ckegm5nrq0003dwoz79e58set","_id":"ckegm5nrv0008dwozfhg5b61x"},{"post_id":"ckegm5nrt0006dwozdcl1amnu","tag_id":"ckegm5nrq0003dwoz79e58set","_id":"ckegm5nrw000adwoza3wz17y9"},{"post_id":"ckegm5nrr0004dwoz1maebn1u","tag_id":"ckegm5nru0007dwozacxwa3j1","_id":"ckegm5nry000edwoz3pf16eka"},{"post_id":"ckegm5nrx000ddwoz983q8l7l","tag_id":"ckegm5nrq0003dwoz79e58set","_id":"ckegm5ns0000hdwoze3j72ncn"},{"post_id":"ckegm5nrs0005dwozaxqh2isq","tag_id":"ckegm5nrx000cdwoz55op8b7x","_id":"ckegm5ns2000mdwoz1fkc829k"},{"post_id":"ckegm5nrs0005dwozaxqh2isq","tag_id":"ckegm5nrz000gdwozgtbsfwgl","_id":"ckegm5ns3000odwozd6tp9r69"},{"post_id":"ckegm5nrv0009dwozgxao5ubv","tag_id":"ckegm5ns1000kdwoz1g2x39x1","_id":"ckegm5ns5000rdwoz8dni9zdh"},{"post_id":"ckegm5nrv0009dwozgxao5ubv","tag_id":"ckegm5ns3000pdwoz8f662m1x","_id":"ckegm5ns5000sdwozdacl78w7"},{"post_id":"ckegm5nrw000bdwozd408gnus","tag_id":"ckegm5ns4000qdwozdtb45thf","_id":"ckegm5ns5000udwoz0yerfz9l"},{"post_id":"ckegm5ns1000jdwoz28kc34wm","tag_id":"ckegm5ns5000tdwozg0d923yw","_id":"ckegm5ns6000wdwoz7vvu90s2"},{"post_id":"ckegm5ns2000ndwozai4re9j3","tag_id":"ckegm5ns5000vdwozc39hb8uo","_id":"ckegm5ns7000ydwozbpjh6yt2"},{"post_id":"ckegm5ns2000ndwozai4re9j3","tag_id":"ckegm5ns6000xdwoz1q0178nn","_id":"ckegm5ns7000zdwozgcu5f18y"},{"post_id":"ckegm5nsh0010dwoz2zyp77vo","tag_id":"ckegm5nrx000cdwoz55op8b7x","_id":"ckegm5nsj0012dwozcyff1ujs"},{"post_id":"ckegm5nsk0015dwoz2nrn4ljo","tag_id":"ckegm5ns5000tdwozg0d923yw","_id":"ckegm5nsl0017dwozagw8hiqv"},{"post_id":"ckegm5nsi0011dwozevsm7hup","tag_id":"ckegm5nsk0014dwoz0neo8qfn","_id":"ckegm5nsm001adwoze67hgqiz"},{"post_id":"ckegm5nsm0018dwozgz0lan2h","tag_id":"ckegm5nru0007dwozacxwa3j1","_id":"ckegm5nsq001cdwozdnnt0x7u"},{"post_id":"ckegm5nsm0018dwozgz0lan2h","tag_id":"ckegm5nrz000gdwozgtbsfwgl","_id":"ckegm5nss001fdwozadri2e5a"},{"post_id":"ckegm5nsj0013dwoz70yc5m2i","tag_id":"ckegm5nsm0019dwozea3r18l7","_id":"ckegm5nsu001hdwozahr0dtu4"},{"post_id":"ckegm5nss001gdwozas9ahcey","tag_id":"ckegm5ns3000pdwoz8f662m1x","_id":"ckegm5nsw001kdwozbmr03xpd"},{"post_id":"ckegm5nsl0016dwozehrl6v2k","tag_id":"ckegm5nss001edwozdu8n3t93","_id":"ckegm5nsx001mdwozfydqalfe"},{"post_id":"ckegm5nsw001ldwoze3l216w4","tag_id":"ckegm5ns5000vdwozc39hb8uo","_id":"ckegm5nsz001odwozep8r5c6i"},{"post_id":"ckegm5nsn001bdwozdfm1huu6","tag_id":"ckegm5ns5000tdwozg0d923yw","_id":"ckegm5nt1001pdwozdexlezzq"},{"post_id":"ckegm5nsn001bdwozdfm1huu6","tag_id":"ckegm5nsv001jdwoz2exfdi4x","_id":"ckegm5nt2001rdwoz84d77r9m"},{"post_id":"ckegm5nsn001bdwozdfm1huu6","tag_id":"ckegm5ns3000pdwoz8f662m1x","_id":"ckegm5nt3001sdwozde9yd7yi"},{"post_id":"ckegm5nsr001ddwoz6sku10ty","tag_id":"ckegm5ns5000tdwozg0d923yw","_id":"ckegm5nt3001tdwoz5kofc52b"},{"post_id":"ckegm5nsr001ddwoz6sku10ty","tag_id":"ckegm5nsv001jdwoz2exfdi4x","_id":"ckegm5nt3001vdwozcrhwejw5"},{"post_id":"ckegm5nsu001idwozgh1b44q2","tag_id":"ckegm5nt2001qdwozet6mg8jx","_id":"ckegm5nt4001wdwoz6vrl2v4c"},{"post_id":"ckegm5nsu001idwozgh1b44q2","tag_id":"ckegm5nt3001udwoz1gwugxxb","_id":"ckegm5nt4001xdwoz3n2p1ie4"}],"Tag":[{"name":"设计模式","_id":"ckegm5nrq0003dwoz79e58set"},{"name":"Annotation","_id":"ckegm5nru0007dwozacxwa3j1"},{"name":"源码分析","_id":"ckegm5nrx000cdwoz55op8b7x"},{"name":"APT","_id":"ckegm5nrz000gdwozgtbsfwgl"},{"name":"indicator","_id":"ckegm5ns1000kdwoz1g2x39x1"},{"name":"ViewPager2","_id":"ckegm5ns3000pdwoz8f662m1x"},{"name":"开发工具","_id":"ckegm5ns4000qdwozdtb45thf"},{"name":"自定义View","_id":"ckegm5ns5000tdwozg0d923yw"},{"name":"RxJava","_id":"ckegm5ns5000vdwozc39hb8uo"},{"name":"token","_id":"ckegm5ns6000xdwoz1q0178nn"},{"name":"https","_id":"ckegm5nsk0014dwoz0neo8qfn"},{"name":"Widget","_id":"ckegm5nsm0019dwozea3r18l7"},{"name":"Arouter","_id":"ckegm5nss001edwozdu8n3t93"},{"name":"Banner","_id":"ckegm5nsv001jdwoz2exfdi4x"},{"name":"Fragment","_id":"ckegm5nt2001qdwozet6mg8jx"},{"name":"懒加载","_id":"ckegm5nt3001udwoz1gwugxxb"}]}}