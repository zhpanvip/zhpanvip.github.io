---
title: 温故知新--你不知道的JVM内存分配
date: 2020-09-04 09:56:11
categories:
- Java
tags:
- JVM
---


<section id="nice" data-tool="mdnice编辑器" data-website="https://www.mdnice.com" style="font-size: 16px; color: black; padding: 0 10px; line-height: 1.6; word-spacing: 0px; letter-spacing: 0px; word-break: break-word; word-wrap: break-word; text-align: left; font-family: Optima-Regular, Optima, PingFangSC-light, PingFangTC-light, 'PingFang SC', Cambria, Cochin, Georgia, Times, 'Times New Roman', serif;"><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">Java内存分配是Java基础中非常重要的一部分内容，深入理解JVM的内存分配机制将有助于我们解决开发中遇到的很多问题。同时，内存分配这一块也是面试常客。笔者作为面试官也问过不少内存分配的问题，但令笔者惊讶的是不少三五年经验的面试者对于这块内容的回答也是含糊其辞，显然没有完全搞明白。那么本节内容我们就来系统的回顾一下Java中的内存分配机制。</p>
<h2 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; border-bottom: 2px solid rgb(239, 112, 96); font-size: 1.3em;"><span class="prefix" style="display: none;"></span><span class="content" style="display: inline-block; font-weight: bold; background: rgb(239, 112, 96); color: #ffffff; padding: 3px 10px 1px; border-top-right-radius: 3px; border-top-left-radius: 3px; margin-right: 3px;">JVM内存分配概述</span><span class="suffix"></span><span style="display: inline-block; vertical-align: bottom; border-bottom: 36px solid #efebe9; border-right: 20px solid transparent;"> </span></h2>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">首先，我们应该明白一点，JVM并不是单一的存在，在Java二十多年的发展史中曾经涌现出了许多优秀的虚拟机，如大家耳熟能详的HotSpot虚拟机就是其中之一。不同的虚拟机在内存分配上也略有差异，但总体来说都遵循《Java虚拟机规范》。在《Java虚拟机规范》中规定了五种虚拟机运行时数据区，他们分别为：程序计数器、Java虚拟机栈、本地方法栈、本地方法区、Java堆、以及方法区。如下图所示：
<img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ef637faa853f4142b0bb2860c2d3282d~tplv-k3u1fbpfcp-zoom-1.image" alt style="display: block; margin: 0 auto; max-width: 100%;"></p>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">接下来，我们来对以上五个内存区域进行详细分析。</p>
<h2 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; border-bottom: 2px solid rgb(239, 112, 96); font-size: 1.3em;"><span class="prefix" style="display: none;"></span><span class="content" style="display: inline-block; font-weight: bold; background: rgb(239, 112, 96); color: #ffffff; padding: 3px 10px 1px; border-top-right-radius: 3px; border-top-left-radius: 3px; margin-right: 3px;">一、程序计数器（Program Counter）</span><span class="suffix"></span><span style="display: inline-block; vertical-align: bottom; border-bottom: 36px solid #efebe9; border-right: 20px solid transparent;"> </span></h2>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">程序计数器是用于存放下一条指令所在单元地址的一块内存，在Intel x86和Itanium微处理器中，被称作<strong style="font-weight: bold; color: black;">指令指针</strong>（instruction pointer，IP），显然“指令指针”这个名字更易于我们理解这个概念。在JVM中，程序计数器是一块较小的内存空间，可以看作是<strong style="font-weight: bold; color: black;">当前线程所执行字节码的行号指示器</strong>。字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成。</p>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">我们知道，多线程的情况下，线程是由CPU调度来执行指令的，在单核CPU中，某一时刻只会有一个线程在执行指令，这就意味着CPU会频繁的切换线程，而在线程切换后需要恢复到正确的执行位置，这就需要<strong style="font-weight: bold; color: black;">每条线程都有一个独立的程序计数器</strong>，各个线程之间计数器互不影响。</p>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">从以上内容中我们可以总结出以下几点：</p>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><strong style="font-weight: bold; color: black;">程序计数器存放了下一条要执行的指令的位置</strong></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><strong style="font-weight: bold; color: black;">字节码解释器通过给改变计数器的值来执行指令</strong></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><strong style="font-weight: bold; color: black;">程序计数器是线程私有的，每条线程都有一个程序计数器。</strong></section></li></ul>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">另外，关于程序计数器我们需要了解的是，Java虚拟机规范中没有针对程序计数器规定任何的OutMemoryError。至于为什么？我个人觉得应该是程序计数器所占用的内存很小，加之线程数是有限的。因此，规范中并未对其做任何约束限制。</p>
<h2 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; border-bottom: 2px solid rgb(239, 112, 96); font-size: 1.3em;"><span class="prefix" style="display: none;"></span><span class="content" style="display: inline-block; font-weight: bold; background: rgb(239, 112, 96); color: #ffffff; padding: 3px 10px 1px; border-top-right-radius: 3px; border-top-left-radius: 3px; margin-right: 3px;">二、Java虚拟机栈(Java Virtual Machine Stacks)</span><span class="suffix"></span><span style="display: inline-block; vertical-align: bottom; border-bottom: 36px solid #efebe9; border-right: 20px solid transparent;"> </span></h2>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">提到Java中的<strong style="font-weight: bold; color: black;">栈内存</strong>，大家应该都不陌生，甚至很多小伙伴对于栈内存说的头头是道：“栈内存是用来存储基本数据类型和对象的引用的”。但是，事实如此吗？其实，并不准确！这仅仅是Java虚拟机栈功能的一部分。</p>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧用于存储局部变量表、操作数栈、动态连接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。</p>
<blockquote data-tool="mdnice编辑器" style="display: block; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; border-left: 3px solid rgba(0, 0, 0, 0.4); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; border-left-color: rgb(239, 112, 96); background: #fff9f9;">
<p style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0px; color: black; line-height: 26px;">栈帧是用于支持虚拟机进行方法调用和方法执行的数据结构，它是虚拟机运行时数据区中的虚拟机栈的栈元素，栈帧存储了方法的变量表、操作数栈、动态连接和方法返回等信息。本篇内容对栈帧不做过多解读，了解即可。</p>
</blockquote>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">而我们平时说的“栈内存”其实指的是虚拟机中的局部变量表部分。局部变量表存放了编译器可以知道的各种基本数据类型（boolean、type、char、short、int、final、long、double）、对象引用（reference类型，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其它与此对象相关的位置）和returnAddress类型（指向了一条字节码指令地址）。其中长度为long和double类型的数据会占用两个局部变量空间（Slot），其余的数据类型只占用一个。而局部变量表所需要的空间是在编译期间完成分配的，当进入一个方法时这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法的运行期间不会改变局部变量的大小。</p>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">同时，Java虚拟机栈与程序计数器一样都是线程私有的。Java虚拟机栈的生命周期与线程相同。另外，在Java虚拟机规范中对这一区域规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，就会抛出StackOverflowError异常；如果虚拟机栈可以动态扩展（当前大部分的虚拟机都可以动态扩展）如果扩展时无法申请到足够的内存则会抛出OutOfMemoryError异常。</p>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">对于以上内容，我们可以有以下节点结论：</p>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><strong style="font-weight: bold; color: black;">虚拟机栈的功能不仅仅是存储基本数据类型和对象的引用</strong></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><strong style="font-weight: bold; color: black;">虚拟机栈描述的是Java方法执行的内存模型</strong></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><strong style="font-weight: bold; color: black;">虚拟机栈是线程私有的，生命周期与线程相同</strong></section></li></ul>
<h2 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; border-bottom: 2px solid rgb(239, 112, 96); font-size: 1.3em;"><span class="prefix" style="display: none;"></span><span class="content" style="display: inline-block; font-weight: bold; background: rgb(239, 112, 96); color: #ffffff; padding: 3px 10px 1px; border-top-right-radius: 3px; border-top-left-radius: 3px; margin-right: 3px;">三、本地方法栈（Native Method Stack）</span><span class="suffix"></span><span style="display: inline-block; vertical-align: bottom; border-bottom: 36px solid #efebe9; border-right: 20px solid transparent;"> </span></h2>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">本地方法栈与虚拟机栈的作用是非常相似的，他们之间的区别不过是虚拟机栈为虚拟机执行Java方法（字节码）服务，而本地方法栈则为虚拟机使用到的Native方法服务。在虚拟机规范中对本地方法栈中方法使用的语言、使用的方式与数据结构并没有强制的规定，因此虚拟机是可以自由实现的。像HotSpot虚拟机就把本地方法栈和虚拟机栈合二为一了。</p>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError.</p>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">关于本地虚拟机栈，我们有如下总结：</p>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><strong style="font-weight: bold; color: black;">本地方法栈为虚拟机使用到的Native方法服务</strong></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><strong style="font-weight: bold; color: black;">某些虚拟机本地方法栈与虚拟机栈合二为一</strong></section></li></ul>
<h2 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; border-bottom: 2px solid rgb(239, 112, 96); font-size: 1.3em;"><span class="prefix" style="display: none;"></span><span class="content" style="display: inline-block; font-weight: bold; background: rgb(239, 112, 96); color: #ffffff; padding: 3px 10px 1px; border-top-right-radius: 3px; border-top-left-radius: 3px; margin-right: 3px;">四、Java堆</span><span class="suffix"></span><span style="display: inline-block; vertical-align: bottom; border-bottom: 36px solid #efebe9; border-right: 20px solid transparent;"> </span></h2>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">堆内存应该是Java开发者最熟悉的一块内存区域了，因为它实在是太重要了！我们所创建的对象实例几乎都是存放在堆内存中。因此，Java堆是虚拟机所管理的最大的一块内存区域。<strong style="font-weight: bold; color: black;">Java堆是被所有线程共享的一块内存区域</strong>，在虚拟机启动时创建。Java虚拟机规范中对堆内存有这样的描述：<strong style="font-weight: bold; color: black;">所有的对象实例以及数组都要在堆上分配</strong>，但是随着JIT编译器的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都在堆上分配也不是那么绝对了。</p>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">对于Java堆内存我们还可以进行一个细分：<strong style="font-weight: bold; color: black;">新生代（Young Generation）</strong>、<strong style="font-weight: bold; color: black;">老年代（Old Generation</strong>）；而新生代则又可以细分为Eden空间、From Survivor空间、To Survivor。如下图所示（注：图片中Permanent Generation即永生代不属于堆内存，而是方法区的一部分）：
<img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1de04c22b94c4322a004aecaf5e90689~tplv-k3u1fbpfcp-zoom-1.image" alt style="display: block; margin: 0 auto; max-width: 100%;">
而Java中的垃圾回收就是针对Java堆上不同的区域进行扫描回收，关于Java的GC机制我会在后续“温故知新”系列文章中详细解读。</p>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">从内存分配的角度来看，线程共享的Java堆中可能划分出多个线程私有的缓冲区（Thread Local Allocation Buffer，TLAB).</p>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">但是，无论怎么划分，堆上所存放的内容都是对象的实例。进一步划分只不过是为了更好的回收内存或者更快的分配内存。</p>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">另外，Java虚拟机规范中规定，Java堆可以处于物理上不连续的内存空间中。如果虚拟机在为实例分配内存时没有足够的空间，并且堆也无法在扩展，则会抛出OutOfMemoryError异常。</p>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">关于Java堆我们可做如下总结：</p>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><strong style="font-weight: bold; color: black;">Java中创建的对象几乎都存放在堆内存中</strong></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><strong style="font-weight: bold; color: black;">垃圾回收机制会对堆内存进行扫描和垃圾对象的回收</strong></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><strong style="font-weight: bold; color: black;">堆内存是被所有线程共享的一块内存区域</strong></section></li></ul>
<h2 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; border-bottom: 2px solid rgb(239, 112, 96); font-size: 1.3em;"><span class="prefix" style="display: none;"></span><span class="content" style="display: inline-block; font-weight: bold; background: rgb(239, 112, 96); color: #ffffff; padding: 3px 10px 1px; border-top-right-radius: 3px; border-top-left-radius: 3px; margin-right: 3px;">五、方法区（Method Area）</span><span class="suffix"></span><span style="display: inline-block; vertical-align: bottom; border-bottom: 36px solid #efebe9; border-right: 20px solid transparent;"> </span></h2>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">方法区是用来存储虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。方法区与堆内存一样是所有线程共享的一块区域。Java虚拟机对于方法区的限制非常宽松，因此也就导致了不同的虚拟机上方法区有不同的表现。我们以HotSpot虚拟机为例：<strong style="font-weight: bold; color: black;">方法区在JDK1.7之前是一块单独的区域</strong>，很多人喜欢把它成为“永生代”（Permanent Generation），但本质上两者并不等价，仅仅是因为HotSpot虚拟机的设计团队把GC分代收集扩展到了方法区，或者说<strong style="font-weight: bold; color: black;">使用永生代来实现了方法区</strong>。这样HotSpot的垃圾收集器就可以向管理Java堆一样管理这部分内存。但是对于其它虚拟机（如BEA JRockit、IBM J9等）来说其实是不存在永生代的概念的。用永生代来实现方法区并不是一个好主意，因为这样更容易出现内存溢出的问题。而HotSpot的团队显然也意识到了这点问题，因此，在JDK1.7中将方法区中的运行时常量池移到了堆内存中，并在JDK1.8中完全取消了“永生代”。</p>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">另外，根据Java虚拟机规范规定，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。</p>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">关于方法区我们有如下总结：</p>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><strong style="font-weight: bold; color: black;">方法区是用来存储虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据</strong></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><strong style="font-weight: bold; color: black;">不同的虚拟机对于方法区的实现不同</strong></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><strong style="font-weight: bold; color: black;">方法区与堆内存一样是所有线程共享的一块区域</strong></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><strong style="font-weight: bold; color: black;">HotSpot虚拟机在JDK1.7中将常量池移到了堆内存，并在JDK1.8中取消了永久代。</strong></section></li></ul>
<h2 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; border-bottom: 2px solid rgb(239, 112, 96); font-size: 1.3em;"><span class="prefix" style="display: none;"></span><span class="content" style="display: inline-block; font-weight: bold; background: rgb(239, 112, 96); color: #ffffff; padding: 3px 10px 1px; border-top-right-radius: 3px; border-top-left-radius: 3px; margin-right: 3px;">六、运行时常量池（Runtime Constant Pool）</span><span class="suffix"></span><span style="display: inline-block; vertical-align: bottom; border-bottom: 36px solid #efebe9; border-right: 20px solid transparent;"> </span></h2>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">上一节中我们我们已经提到运行时常量池是方法区的一部分，但是因为该区域太重要，因此，将常量池也作为单独一节来分析。
Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有以像是<strong style="font-weight: bold; color: black;">常量池（Constants Pool Table）</strong>，常量池用于存放编译期间生产的各种字面量和符号引用，<strong style="font-weight: bold; color: black;">这部分内容会在类加载后进入方法区的运行时常量池中存放</strong>。</p>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">Java虚拟机对Class文件每一部分（包括常量池）的格式都有严格的规定，没有个字节用于存储哪种数据都必须符合规范上的要求才会被虚拟机认可、装载和执行。但对于运行时常量池，Java虚拟机规范没有做任何细节要求。不同的虚拟机提供商实现的虚拟机可以按照自己的需求来实现这个内存区域。一般来说，除了保存Class文件中的符号引用外，还会把翻译出来的直接引用也存储在运行时常量池中。</p>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">运行时常量池相对于Class文件的常量池另外一个重要特性是具备动态性，Java语言并不要求常量一定在编译期间才能生成。也就是并非预置入Class文件常量池中的内容才能进入运行时常量池，运行期间也可以将新的常量放入常量池中，例如String类中的intern()方法（关于String及其intern方法我也会在后续“温故知新”系列文章中详细讲解）</p>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">另外，我们应该清楚，在JDK1.7之前，HotSpot虚拟机的运行时常量池是放在永久代的，而在JDK1.7中将运行时常量池移动到了堆内存。</p>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">运行时常量池属于方法区，因此其内存限制自然与方法区无异，当常量池无法再申请到内存时会抛出OutMemoryError异常。</p>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">关于运行时常量池我们要注意其与Class常量池的区分，总结如下：</p>
<ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;">
<li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><strong style="font-weight: bold; color: black;">运行时常量池是方法区的一部分</strong></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><strong style="font-weight: bold; color: black;">Class常量池中的数据会在类加载后进入方法区的运行时常量池</strong></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><strong style="font-weight: bold; color: black;">运行时常量池也会在运行期间添加新的常量</strong></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><strong style="font-weight: bold; color: black;">运行时常量池样是所有线程共享的一块区域</strong></section></li></ul>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">本篇内容详细的分析了JVM的内存分配策略，网上关于JVM内存分配的文章多到数不胜数。但是我敢保证绝大部分文章没有本文写的详细且易懂。如果你能够认真读完本文相信你对JVM的内存分配一定会有一个更加深入的认识。</p>
<h2 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; border-bottom: 2px solid rgb(239, 112, 96); font-size: 1.3em;"><span class="prefix" style="display: none;"></span><span class="content" style="display: inline-block; font-weight: bold; background: rgb(239, 112, 96); color: #ffffff; padding: 3px 10px 1px; border-top-right-radius: 3px; border-top-left-radius: 3px; margin-right: 3px;">参考&amp;推荐阅读</span><span class="suffix"></span><span style="display: inline-block; vertical-align: bottom; border-bottom: 36px solid #efebe9; border-right: 20px solid transparent;"> </span></h2>
<p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">《深入理解Java虚拟机》</p>
</section>