---
title: 浅析Java设计模式（三）
date: 2016-07-26 10:26:41
categories:
- 设计模式
tags:
- 设计模式
---

本篇文章继续来学习Java的设计模式，这篇文章来解析行为型模式种的几种比较常用的设计模式。

一、观察者模式
观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态发生变化时，会通知所有的观察者对象，使它们能够自动更新自己。以微信推送腾讯新闻为例，用户在微信订阅了腾讯新闻后，用户会收到腾讯的新闻推送。如果用户取消了新闻订阅，那么就不会再收到推送。
1.创建一个被观察者Observer 接口，接口中有update方法

```
public interface Observer {
	void update(String news);
}
```

2.创建观察者Observable接口，接口中有订阅、取消订阅、通知三个方法。

```
public interface Observable {
	void subscribe(Observer observer);
	void unsubscribe(Observer observer);
	void notifyObserver();
}

```
3.创建TencentNewsObservable并实现Observable接口

```

public class TencentNewsObservable implements Observable {
	private List<Observer> observers=new ArrayList<Observer>();
	private String news;
	@Override
	public void subscribe(Observer observer) {
		observers.add(observer);
	}

	@Override
	public void unsubscribe(Observer observer) {
		observers.remove(observer);
	}

	@Override
	public void notifyObserver() {
		for(Observer observer:observers) {
			observer.update(news);
		}
	}
	
	public void sendNews(String news) {
		this.news=news;
		notifyObserver();
	}

}
```
4.定义一个UserObserver并实现Observer接口

```
public class UserObserver implements Observer{
	private String name;
	
	public UserObserver(String name) {
		this.name=name;
	}

	@Override
	public void update(String news) {
		System.out.println(name+"收到一条消息："+news);
	}
}
```
5.编写测试类

```
public class ObserverTest {

	public static void main(String[] args) {
		UserObserver mike=new UserObserver("Mike");
		UserObserver lucy=new UserObserver("Lucy");
		UserObserver kate=new UserObserver("Kate");
		TencentNewsObservable observerable=new TencentNewsObservable();
		
		observerable.subscribe(mike);
		observerable.subscribe(lucy);
		observerable.subscribe(kate);
		observerable.sendNews("this is an ad");
	}
}
```
运行结果：

> Mike收到一条消息：this is an advertisement
Lucy收到一条消息：this is an advertisement
Kate收到一条消息：this is an advertisement

此时Mike收到推送打开后一看，竟然是一条广告，愤怒之下取消了订阅！

```
		System.out.println("Mike unsubscribe news");
		observerable.unsubscribe(mike);
		observerable.sendNews("this is a news");
```
运行结果：

> Mike收到一条消息：this is an advertisement
Lucy收到一条消息：this is an advertisement
Kate收到一条消息：this is an advertisement
Mike unsubscribe news
Lucy收到一条消息：this is a news
Kate收到一条消息：this is a news

取消订阅后Mike再也没有收到新闻推送。

二、策略模式
策略模式定义了一系列的算法，并将每一个算法封装起来，而且使他们可以相互替换，让算法独立于使用它的客户而独立变化。策略模式设计三个角色，环境(Context)角色、抽象策略(Strategy)角色以及具体策略(ConcreteStrategy)角色。
来看一个现实生活的例子，假设一个商场有三种会员（Strategy），分别为普通会员（StandardMemberStraegy）、白银会员（SilverMemberStrategy）以及黄金会员（GoldenMemberStrategy）。针对三种会员分别制定了不同的优方案。普通会员打九折、白银会员打八折、黄金会员打七折。来看如何用策略模式实现上述场景。
1.创建抽象策略类

```
public abstract class Strategy {
	
	private String strategy;
	
	
	public String getStrategy() {
		return strategy;
	}



	public Strategy(String strategy) {
		super();
		this.strategy = strategy;
	}
	
	abstract double getPrice(double normalPrice);
}
```
2.创建环境类（Context）并持有抽象策略类

```
public class Context {
	private Strategy mStrategy;
	
	public void setStrategy(Strategy strategy) {
		mStrategy=strategy;
	}
	
	public double executePrice(double normalPrice) {
		System.out.println(mStrategy.getStrategy()+"Member，折后价："+mStrategy.getPrice(normalPrice));
		return mStrategy.getPrice(normalPrice);
	}
}
```
3.创建三种会员策略类

```
public class StandardMemberStraegy extends Strategy {
	
	public StandardMemberStraegy(String strategy) {
		super(strategy);
	}

	@Override
	public double getPrice(double normalPrice) {
		return 0.9*normalPrice;
	}
}

public class SilverMemberStrategy extends Strategy{

	public SilverMemberStrategy(String strategy) {
		super(strategy);
	}

	@Override
	public double getPrice(double normalPrice) {
		return 0.8*normalPrice;
	}

}

public class GoldenMemberStrategy extends Strategy {


	public GoldenMemberStrategy(String strategy) {
		super(strategy);
	}

	@Override
	public double getPrice(double normalPrice) {
		return 0.7*normalPrice;
	}
	
}
```
4.创建策略模式测试类

```
public class StrategyTest {

	public static void main(String[] args) {
		StandardMemberStraegy standar=new StandardMemberStraegy("Standar");
		SilverMemberStrategy silver=new SilverMemberStrategy("Silver");
		GoldenMemberStrategy golden=new GoldenMemberStrategy("Golden");
		Context context=new Context();
		
		context.setStrategy(standar);
		context.executePrice(100);
		
		context.setStrategy(silver);
		context.executePrice(100);
		
		context.setStrategy(golden);
		context.executePrice(100);
	}

}
```
运行结果：

> StandarMember，折后价：90.0
SilverMember，折后价：80.0
GoldenMember，折后价：70.0

