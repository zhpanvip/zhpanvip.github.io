---
title: 浅析Java设计模式（三）
date: 2016-07-26 10:26:41
categories:
- 设计模式
tags:
- 设计模式
---

本篇文章继续来学习Java的设计模式，这篇文章来解析行为型模式种的几种比较常用的设计模式。

## 一、观察者模式
观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态发生变化时，会通知所有的观察者对象，使它们能够自动更新自己。以微信推送腾讯新闻为例，用户在微信订阅了腾讯新闻后，用户会收到腾讯的新闻推送。如果用户取消了新闻订阅，那么就不会再收到推送。
观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态发生变化时，会通知所有的观察者对象，使它们能够自动更新自己。

以订阅微信公众号为例：

> 用户在微信订阅了微信公众号后，会收到公众号的消息推送。如果用户取消了订阅，那么就不会再收到推送。



### 1.观察者Observer抽象层

观察者订阅公众号后会监听公众号推送的消息，推送后观察者会收到更新。可以抽象出一个观察者接口：

```java
/**
 * 观察者抽象层
 */
public interface Observer {
    void update(String obj);
}
```



### 2.观察者实现

用户实现观察者接口，收到消息后将消息打印：

```java
/**
 * 观察者实现
 */
public class UserObserver implements Observer {

    private String name;
    private String message;

    public UserObserver(String name) {
        this.name = name;
    }

    @Override
    public void update(String message) {
        this.message = message;
        readMessage();
    }

    private void readMessage() {
        System.out.println(name + "收到一条消息：" + message);
    }
}
```



### 3.被观察者抽象层

被观察者提供订阅、取消订阅、发布消息、以及发布消息后通知观察者的功能：

```java
/**
 * 被观察者抽象层
 */
public interface Observable {
    void addObserver(Observer observer);

    void removeObserver(Observer observer);

    void notifyObservers();

    // 发布消息
    void pushMessage(String message);
}
```



### 4.被观察者实现

定义一个公众号的被观察者，并实现Observable：

```java
/**
 * 被观察者
 */
public class WechatObservable implements Observable {

    private final List<Observer> list = new ArrayList<>();
    private String message;

    @Override
    public void addObserver(Observer observer) {
        list.add(observer);
    }

    @Override
    public void removeObserver(Observer observer) {
        list.remove(observer);
    }


    @Override
    public void notifyObservers() {
        for (Observer observer : list) {
            observer.update(message);
        }
    }

    @Override
    public void pushMessage(String message) {
        this.message = message;
        // 通知订阅的用户
        notifyObservers();
    }
}
```



### 5.测试代码

```java
public class ObserverTest {

    public static void main(String[] args) {
        WechatObservable wechatObservable = new WechatObservable();
        UserObserver ryan = new UserObserver("Ryan");
        UserObserver frank = new UserObserver("Mike");

        wechatObservable.addObserver(ryan);
        wechatObservable.addObserver(frank);

        wechatObservable.pushMessage("this is a news");
    }
}
```

打印结果：
```
Ryan收到一条消息：this is a news
Mike收到一条消息：this is a news
```

## 二、策略模式
策略模式定义了一系列的算法，并将每一个算法封装起来，而且使他们可以相互替换，让算法独立于使用它的客户而独立变化。策略模式设计三个角色，环境(Context)角色、抽象策略(Strategy)角色以及具体策略(ConcreteStrategy)角色。
来看一个现实生活的例子，假设一个商场有三种会员（Strategy），分别为普通会员（StandardMemberStraegy）、白银会员（SilverMemberStrategy）以及黄金会员（GoldenMemberStrategy）。针对三种会员分别制定了不同的优方案。普通会员打九折、白银会员打八折、黄金会员打七折。来看如何用策略模式实现上述场景。
### 1.创建抽象策略类

```
public abstract class Strategy {

	private String strategy;


	public String getStrategy() {
		return strategy;
	}



	public Strategy(String strategy) {
		super();
		this.strategy = strategy;
	}

	abstract double getPrice(double normalPrice);
}
```
### 2.创建环境类（Context）并持有抽象策略类

```
public class Context {
	private Strategy mStrategy;

	public void setStrategy(Strategy strategy) {
		mStrategy=strategy;
	}

	public double executePrice(double normalPrice) {
		System.out.println(mStrategy.getStrategy()+"Member，折后价："+mStrategy.getPrice(normalPrice));
		return mStrategy.getPrice(normalPrice);
	}
}
```
### 3.创建三种会员策略类

```
public class StandardMemberStraegy extends Strategy {

	public StandardMemberStraegy(String strategy) {
		super(strategy);
	}

	@Override
	public double getPrice(double normalPrice) {
		return 0.9*normalPrice;
	}
}

public class SilverMemberStrategy extends Strategy{

	public SilverMemberStrategy(String strategy) {
		super(strategy);
	}

	@Override
	public double getPrice(double normalPrice) {
		return 0.8*normalPrice;
	}

}

public class GoldenMemberStrategy extends Strategy {


	public GoldenMemberStrategy(String strategy) {
		super(strategy);
	}

	@Override
	public double getPrice(double normalPrice) {
		return 0.7*normalPrice;
	}

}
```
### 4.创建策略模式测试类

```
public class StrategyTest {

	public static void main(String[] args) {
		StandardMemberStraegy standar=new StandardMemberStraegy("Standar");
		SilverMemberStrategy silver=new SilverMemberStrategy("Silver");
		GoldenMemberStrategy golden=new GoldenMemberStrategy("Golden");
		Context context=new Context();

		context.setStrategy(standar);
		context.executePrice(100);

		context.setStrategy(silver);
		context.executePrice(100);

		context.setStrategy(golden);
		context.executePrice(100);
	}

}
```
运行结果：

> StandarMember，折后价：90.0
SilverMember，折后价：80.0
GoldenMember，折后价：70.0

