

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  <title>自定义View之弹性滑动的LockView - Hexo</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/github-gist.min.css" />
  

  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_6peoq002giu.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_pjno9b9zyxs.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.1.1"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>zhangpan</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner intro-2" id="background" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container page-header text-center fade-in-up">
            <span class="h2" id="subtitle">
              
            </span>

            
              
  <div class="mt-3 post-meta">
    <i class="iconfont icon-date-fill" aria-hidden="true"></i>
    <time datetime="2018-07-14 20:30" pubdate>
      2018年7月14日 晚上
    </time>
  </div>


<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      4.6k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      63
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto" id="post">
            <!-- SEO header -->
            <h1 style="display: none">自定义View之弹性滑动的LockView</h1>
            
            <div class="markdown-body" id="post-body">
              <p><strong><em>本文已发表在<a target="_blank" rel="noopener" href="https://juejin.im/post/5d465e18518825219c280e5c">掘金</a>，转载请注明出处。</em></strong></p>
<p>本篇文章我们来实现一个带有弹性滑动效果的自定义View。当然，文章的侧重点是自定义View但也会涉及到View的事件分发以及一些其他方面的知识，例如使用Scroller实现带有阻尼效果的弹性滑动。因此，我相信看完这篇文章你不仅能学到自定义View的相关知识，还会了解到View的事件分发！还是老规矩，看下最终实现效果。<br><img src="https://raw.githubusercontent.com/zhpanvip/Resource/master/image/1401.gif" srcset="/img/loading.gif"></p>
<p> 分析图中效果会发现其核心功能类似于一个简单的下拉刷新、上拉加载的框架，但又有区别。开始前还是先来罗列一下几个核心步骤，如下：<br>      一. 明确需求，确定对外开放的接口<br>      二. 分析滑动效果，初步实现控件布局<br>      三. 关于滑动，不得不说的事件分发<br>      四. 实现自定义CircleWaveView</p>
<h2 id="一-明确需求，确定对外开放接口"><a href="#一-明确需求，确定对外开放接口" class="headerlink" title="一. 明确需求，确定对外开放接口"></a>一. 明确需求，确定对外开放接口</h2><p>首先应该明确控件的需求，确定有哪些功能，然后做针对性开发。这里先贴出该控件的使用方法，也是为了更好地认识控件的需求。<br><strong>1.布局文件添加</strong></p>
<pre><code class="hljs vim">&lt;RelativeLayout xmln<span class="hljs-variable">s:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span>
    xmln<span class="hljs-variable">s:tools</span>=<span class="hljs-string">&quot;http://schemas.android.com/tools&quot;</span>
    android:layout_width=<span class="hljs-string">&quot;match_parent&quot;</span>
    android:layout_height=<span class="hljs-string">&quot;match_parent&quot;</span>
    tool<span class="hljs-variable">s:context</span>=<span class="hljs-string">&quot;.MainActivity&quot;</span>&gt;

    &lt;<span class="hljs-keyword">com</span>.zhpan.lockview.<span class="hljs-keyword">view</span>.LockView
        android:id=<span class="hljs-string">&quot;@+id/lock_view&quot;</span>
        android:layout_width=<span class="hljs-string">&quot;wrap_content&quot;</span>
        android:layout_height=<span class="hljs-string">&quot;wrap_content&quot;</span>
        android:layout_centerInParent=<span class="hljs-string">&quot;true&quot;</span> /&gt;

&lt;/RelativeLayout&gt;</code></pre>
<p><strong>2.设置操作的监听事件。</strong>代码如下：</p>
<pre><code class="hljs less"><span class="hljs-selector-tag">mLockView</span><span class="hljs-selector-class">.setOnLockOperateListener</span>(new OnLockOperateListener() &#123;
     <span class="hljs-variable">@Override</span>
     public void onLockPrepared() &#123;<span class="hljs-comment">//  上锁就绪</span>
         
     &#125;

     <span class="hljs-variable">@Override</span>
     public void onUnLockPrepared() &#123;<span class="hljs-comment">//  开锁就绪</span>

     &#125;

     <span class="hljs-variable">@Override</span>
     public void onLockStart() &#123;<span class="hljs-comment">// 开始上锁</span>

     &#125;

     <span class="hljs-variable">@Override</span>
     public void onUnlockStart() &#123;<span class="hljs-comment">// 开始开锁</span>

     &#125;

     <span class="hljs-variable">@Override</span>
     public void onNotPrepared() &#123;<span class="hljs-comment">// 上下滑动距离未达到就绪状态</span>

     &#125;
 &#125;);</code></pre>

<p><strong>3.对外开放接口</strong></p>
<pre><code class="hljs reasonml"><span class="hljs-comment">// 设置蓝牙是否连接</span>
mLockView.set<span class="hljs-constructor">BluetoothConnect(<span class="hljs-params">false</span>)</span>;
<span class="hljs-comment">// 设置上锁状态</span>
mLockView.set<span class="hljs-constructor">LockState(<span class="hljs-params">isLock</span>)</span>;
<span class="hljs-comment">// 设置View是否可以滑动</span>
mLockView.set<span class="hljs-constructor">CanSlide(<span class="hljs-params">true</span>)</span>
<span class="hljs-comment">// 设置滑动阻尼大小</span>
mLockView.set<span class="hljs-constructor">Damping(1.7)</span>
<span class="hljs-comment">// 设置View中心文字</span>
mLockView.set<span class="hljs-constructor">Text(<span class="hljs-string">&quot;已上锁&quot;</span>)</span>;
<span class="hljs-comment">// 设置中心大圆的颜色</span>
mLockView.setCircleColor
<span class="hljs-comment">// 开启心跳动画</span>
mLockView.start<span class="hljs-constructor">Wave()</span>;
<span class="hljs-comment">// 停止心跳动画</span>
mLockView.stop<span class="hljs-constructor">Wave()</span>;
<span class="hljs-comment">// 是否正在搜索/连接蓝牙</span>
mLockView.connecting(<span class="hljs-literal">true</span>);

<span class="hljs-comment">// 点击事件监听（只有在未连接蓝牙时有效）</span>
mLockView.set<span class="hljs-constructor">OnClickListener(<span class="hljs-params">new</span> View.OnClickListener()</span> &#123;
         @Override
         public void on<span class="hljs-constructor">Click(View <span class="hljs-params">v</span>)</span> &#123;
             
         &#125;
     &#125;);</code></pre>
<p>我们来总结下控件中需要实现的功能：</p>
<ol>
<li>控件布局的实现。</li>
<li>蓝牙未连接时，只能点击而不能滑动。</li>
<li>点击事件以及连接中动画。</li>
<li>更改连接状态。</li>
<li>实现上下弹性滑动，且需要控制滑动边界。</li>
<li>滑动事件回掉。</li>
<li>心跳动画实现。</li>
</ol>
<p>以上几点就是我们要完成的核心功能，有了需求之后就直接进入主题来实现我们想要的效果吧。</p>
<h2 id="二、分析控件，初步实现控件布局"><a href="#二、分析控件，初步实现控件布局" class="headerlink" title="二、分析控件，初步实现控件布局"></a>二、分析控件，初步实现控件布局</h2><p>分析上图的效果发现，中间的View是可滑动的，且覆盖在上下小圆点的上面。对于这种效果直接继承View实现起来会不太方便。因此我们可以想到利用自定义ViewGroup来布局页面。这么一来使开发简单了许多。那么接下来先新建一个layout_oval_lock.xml的布局为文件，并采用FrameLayout来布局控件，这样就实现了层次叠加效果，FrameLayout内部是两个自定义View，我们可以暂且搁置不管，后面会讲到如何实现。布局文件如下：</p>
<pre><code class="hljs stylus">&lt;FrameLayout xmlns:android=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span>
    android:layout_width=<span class="hljs-string">&quot;match_parent&quot;</span>
    android:layout_height=<span class="hljs-string">&quot;match_parent&quot;</span>
    xmlns:app=<span class="hljs-string">&quot;http://schemas.android.com/apk/res-auto&quot;</span>
    android:orientation=<span class="hljs-string">&quot;vertical&quot;</span>&gt;

    &lt;com<span class="hljs-selector-class">.zhpan</span><span class="hljs-selector-class">.lockview</span><span class="hljs-selector-class">.view</span>.CircleView
        android:id=<span class="hljs-string">&quot;@+id/green_cv&quot;</span>
        android:layout_width=<span class="hljs-string">&quot;15dp&quot;</span>
        android:layout_height=<span class="hljs-string">&quot;15dp&quot;</span>
        android:layout_marginTop=<span class="hljs-string">&quot;110dp&quot;</span>
        app:circle_color=<span class="hljs-string">&quot;@color/green&quot;</span>
        android:layout_gravity=<span class="hljs-string">&quot;center&quot;</span>/&gt;

    &lt;com<span class="hljs-selector-class">.zhpan</span><span class="hljs-selector-class">.lockview</span><span class="hljs-selector-class">.view</span>.CircleView
        android:id=<span class="hljs-string">&quot;@+id/red_cv&quot;</span>
        android:layout_width=<span class="hljs-string">&quot;15dp&quot;</span>
        android:layout_height=<span class="hljs-string">&quot;15dp&quot;</span>
        app:circle_color=<span class="hljs-string">&quot;@color/red&quot;</span>
        android:layout_marginTop=<span class="hljs-string">&quot;-110dp&quot;</span>
        android:layout_gravity=<span class="hljs-string">&quot;center&quot;</span>/&gt;

    &lt;com<span class="hljs-selector-class">.zhpan</span><span class="hljs-selector-class">.lockview</span><span class="hljs-selector-class">.view</span>.CircleWaveView
        android:id=<span class="hljs-string">&quot;@+id/circle_wave_view&quot;</span>
        android:layout_width=<span class="hljs-string">&quot;220dp&quot;</span>
        android:layout_height=<span class="hljs-string">&quot;300dp&quot;</span>
        android:layout_gravity=<span class="hljs-string">&quot;center&quot;</span>
        android:<span class="hljs-attribute">padding</span>=<span class="hljs-string">&quot;20dp&quot;</span>/&gt;

    &lt;ProgressBar
        android:id=<span class="hljs-string">&quot;@+id/progress&quot;</span>
        android:layout_width=<span class="hljs-string">&quot;30dp&quot;</span>
        android:layout_height=<span class="hljs-string">&quot;30dp&quot;</span>
        android:<span class="hljs-attribute">visibility</span>=<span class="hljs-string">&quot;gone&quot;</span>
        android:indeterminateTint=<span class="hljs-string">&quot;@color/white&quot;</span>
        android:layout_gravity=<span class="hljs-string">&quot;center&quot;</span>/&gt;
&lt;/FrameLayout&gt;</code></pre>
<p>接下来新建一个LockView类并继承FrameLayout。LockView与 上边layout_oval_lock的布局文件关联，并重写相应的方法。代码如下：</p>
<pre><code class="hljs reasonml">public <span class="hljs-constructor">LockView(Context <span class="hljs-params">context</span>)</span> &#123;
        this(context, null);
    &#125;

    public <span class="hljs-constructor">LockView(Context <span class="hljs-params">context</span>, AttributeSet <span class="hljs-params">attrs</span>)</span> &#123;
        this(context, attrs, <span class="hljs-number">0</span>);
    &#125;

    public <span class="hljs-constructor">LockView(Context <span class="hljs-params">context</span>, AttributeSet <span class="hljs-params">attrs</span>, <span class="hljs-params">int</span> <span class="hljs-params">defStyleAttr</span>)</span> &#123;
        super(context, attrs, defStyleAttr);
        init(context, attrs);
    &#125;

    <span class="hljs-keyword">private</span> void init(Context context, AttributeSet attrs) &#123;
        mTouchSlop = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ViewConfiguration</span>.</span></span>get(context).get<span class="hljs-constructor">ScaledTouchSlop()</span>;
        View view = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">View</span>.</span></span>inflate(context, <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">R</span>.</span></span>layout.layout_oval_lock, this);
        mCircleWaveView = (CircleWaveView) view.find<span class="hljs-constructor">ViewById(R.<span class="hljs-params">id</span>.<span class="hljs-params">circle_wave_view</span>)</span>;
        mCircleView = (CircleView) view.find<span class="hljs-constructor">ViewById(R.<span class="hljs-params">id</span>.<span class="hljs-params">green_cv</span>)</span>;
        distance = ((LayoutParams) mCircleView.get<span class="hljs-constructor">LayoutParams()</span>).topMargin;
        mProgressBar = (ProgressBar) view.find<span class="hljs-constructor">ViewById(R.<span class="hljs-params">id</span>.<span class="hljs-params">progress</span>)</span>;
        mScroller = mCircleWaveView.get<span class="hljs-constructor">Scroller()</span>;
        mContext = context;
        mCircleWaveView.set<span class="hljs-constructor">OnClickListener(<span class="hljs-params">new</span> OnClickListener()</span> &#123;
            @Override
            public void on<span class="hljs-constructor">Click(View <span class="hljs-params">v</span>)</span> &#123;
            &#125;
        &#125;);
    &#125;

    @Override
    protected void on<span class="hljs-constructor">Layout(<span class="hljs-params">boolean</span> <span class="hljs-params">changed</span>, <span class="hljs-params">int</span> <span class="hljs-params">l</span>, <span class="hljs-params">int</span> <span class="hljs-params">t</span>, <span class="hljs-params">int</span> <span class="hljs-params">r</span>, <span class="hljs-params">int</span> <span class="hljs-params">b</span>)</span> &#123;
        View view = get<span class="hljs-constructor">ChildAt(0)</span>;
        view.layout(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, get<span class="hljs-constructor">MeasuredWidth()</span>, get<span class="hljs-constructor">MeasuredHeight()</span>);
    &#125;

    @Override
    protected void on<span class="hljs-constructor">SizeChanged(<span class="hljs-params">int</span> <span class="hljs-params">w</span>, <span class="hljs-params">int</span> <span class="hljs-params">h</span>, <span class="hljs-params">int</span> <span class="hljs-params">oldw</span>, <span class="hljs-params">int</span> <span class="hljs-params">oldh</span>)</span> &#123;
        super.on<span class="hljs-constructor">SizeChanged(<span class="hljs-params">w</span>, <span class="hljs-params">h</span>, <span class="hljs-params">oldw</span>, <span class="hljs-params">oldh</span>)</span>;
    &#125;</code></pre>
<h2 id="三-关于滑动，不得不说的事件分发"><a href="#三-关于滑动，不得不说的事件分发" class="headerlink" title="三.关于滑动，不得不说的事件分发"></a>三.关于滑动，不得不说的事件分发</h2><p>接下来就要来处理中心View的滑动了！说到滑动，避免不了的就应该想到Android中View的事件分发，那么对于滑动事件的处理我们需要重写三个方法。我想很多小伙伴肯定已经想到了！没错，就是事件分发的三个核心方法：dispatchTouchEvent、onInterceptTouchEvent、以及onTouchEvent。我觉得还是先简单来了解一下这三个方法吧，因为它确实挺重要的。</p>
<ul>
<li><strong><em>dispatchTouchEvent</em></strong>   顾名思义，这个方法就是用来对事件进行分发的。如果事件传递到了当前View，那么这个方法一定会被调用。它的返回结果受当前View的onTouchEvent或下级View的dispatchTouchEvent方法的影响，表示是否消费当前事件。</li>
<li><strong><em>onInterceptTouchEvent</em></strong>  这个方法在dispatchTouchEvent方法的内部被调用，用来表示是否拦截某个事件。返回结果表示是否拦截当前事件。需要注意的是View并没有该方法，这个方法仅仅存在于ViewGroup中！如果事件传递到View中，那么会直接调用该View的onTouchEvent方法。</li>
<li><strong><em>onTouchEvent</em></strong>  这个方法在dispatchTouchEvent方法中调用。用来处理点击事件。返回结果表示是否消费当前事件。View中的onTouchEvent方法默认会消费事件，只有当设置clickable和longClickable为false时则不会消费该事件。</li>
</ul>
<p><strong>首先来看LockView中重写的dispatchTouchEvent方法中的代码</strong>：</p>
<pre><code class="hljs aspectj"><span class="hljs-meta">@Override</span>
<span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">dispatchTouchEvent</span><span class="hljs-params">(MotionEvent ev)</span> </span>&#123;
    <span class="hljs-keyword">if</span> (!canSlide)
        <span class="hljs-keyword">switch</span> (ev.getAction()) &#123;
            <span class="hljs-keyword">case</span> ACTION_DOWN:
                timestamp = System.currentTimeMillis();
                <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">case</span> ACTION_UP:
                <span class="hljs-keyword">if</span> (System.currentTimeMillis() - timestamp &lt; 500) &#123;
                    performClick();
                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
                &#125;
                <span class="hljs-keyword">break</span>;
        &#125;
    <span class="hljs-function"><span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.<span class="hljs-title">dispatchTouchEvent</span><span class="hljs-params">(ev)</span></span>;
&#125;</code></pre>

<p>上面提到，只要有事件传递到当前的ViewGroup那么dispatchTouchEvent就会首先被调用！因此在这个方法里先来判断当前是否是可以滑动状态（蓝牙未连接时不可滑动）。如果不可以滑动，那么就去处理点击事件，我们认为ACTION_DOWN和ACTION_UP之间间隔小于500毫秒就是一次点击事件，那么就在此处调用performClick方法并消费掉当前事件，如果间隔大于500毫秒，不认为是点击事件，那么紧接着就去调用父类的dispatchTouchEvent方法。如果当前可以滑动，那么同样调用父类的dispatchTouchEvent方法来处理。</p>
<p><strong>接下来我们看重写的onInterceptTouchEvent方法</strong></p>
<pre><code class="hljs angelscript">
@Override
<span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span>ean onInterceptTouchEvent(MotionEvent ev) &#123;
        <span class="hljs-built_in">bool</span>ean <span class="hljs-built_in">int</span>ercepted = <span class="hljs-literal">true</span>;
        <span class="hljs-built_in">int</span> y = (<span class="hljs-built_in">int</span>) ev.getY();
        <span class="hljs-keyword">switch</span> (ev.getAction()) &#123;
            <span class="hljs-keyword">case</span> ACTION_DOWN:
                <span class="hljs-built_in">int</span>ercepted = <span class="hljs-literal">false</span>;
                <span class="hljs-keyword">if</span> (!mScroller.isFinished()) &#123;
                    mScroller.abortAnimation();
                &#125;
                <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">case</span> MotionEvent.ACTION_MOVE:
                <span class="hljs-keyword">if</span> (Math.abs(y - mLastY) &gt; mTouchSlop) &#123;
                    <span class="hljs-built_in">int</span>ercepted = <span class="hljs-literal">true</span>;
                &#125;
                <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">case</span> MotionEvent.ACTION_UP:
                <span class="hljs-built_in">int</span>ercepted = <span class="hljs-literal">false</span>;
                <span class="hljs-keyword">break</span>;
        &#125;
        mLastY = y;
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">int</span>ercepted;
    &#125;</code></pre>
<p>在这个方法中我们重点来看ACTION_MOVE的时候，在这里先判断了滑动的距离是否大于mTouchSlop，这个值是认为滑动的最小距离，当大于这个值的时候就认为是滑动了。那么看此时intercepted返回了true，表示要拦截这个事件！此处拦截了这个滑动事件会怎么样呢？答案是当前View中的onTouchEvent方法被调用了！现在请将我们的目光聚焦到onTouchEvent方法中，注意前方高能！</p>
<p><strong>核心中最核心的onTouchEvent方法</strong></p>
<pre><code class="hljs reasonml">    
    @Override
    public boolean on<span class="hljs-constructor">TouchEvent(MotionEvent <span class="hljs-params">event</span>)</span> &#123;

        <span class="hljs-built_in">int</span> y = (<span class="hljs-built_in">int</span>) event.get<span class="hljs-constructor">Y()</span>;
        <span class="hljs-built_in">int</span> scrollY = mCircleWaveView.get<span class="hljs-constructor">ScrollY()</span>;
        switch (event.get<span class="hljs-constructor">Action()</span>) &#123;
            case ACTION_DOWN:
                <span class="hljs-keyword">if</span> (!mScroller.is<span class="hljs-constructor">Finished()</span>) &#123;
                    mScroller.abort<span class="hljs-constructor">Animation()</span>;
                &#125;
                break;
            case MotionEvent.ACTION_MOVE:
                <span class="hljs-keyword">if</span> (!canSlide) &#123;
                    return super.on<span class="hljs-constructor">TouchEvent(<span class="hljs-params">event</span>)</span>;
                &#125;
                <span class="hljs-built_in">int</span> deltaY = (<span class="hljs-built_in">int</span>) ((mLastY - y)<span class="hljs-operator"> / </span>damping);
                <span class="hljs-keyword">if</span> (mCircleWaveView.get<span class="hljs-constructor">ScrollY()</span> &gt; mTouchSlop) &#123;
                    mOption = Option.LOCK;
                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mCircleWaveView.get<span class="hljs-constructor">ScrollY()</span> &lt; -mTouchSlop) &#123;
                    mOption = Option.UNLOCK;
                &#125;
                <span class="hljs-keyword">if</span> (<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>abs(scrollY) &gt; (distance - mCircleWaveView.get<span class="hljs-constructor">Radius()</span> + mCircleView.get<span class="hljs-constructor">Radius()</span>)) &#123;
                    <span class="hljs-keyword">if</span> (mOption != null) &#123;
                        switch (mOption) &#123;
                            case LOCK:
                                <span class="hljs-keyword">if</span> (mOnLockOperateListener != null)
                                    mOnLockOperateListener.on<span class="hljs-constructor">LockPrepared()</span>;
                                mCircleWaveView.set<span class="hljs-constructor">LockPrepared(<span class="hljs-params">true</span>)</span>;
                                break;
                            case UNLOCK:
                                <span class="hljs-keyword">if</span> (mOnLockOperateListener != null)
                                    mOnLockOperateListener.on<span class="hljs-constructor">UnLockPrepared()</span>;
                                mCircleWaveView.set<span class="hljs-constructor">UnLockPrePared(<span class="hljs-params">true</span>)</span>;
                                break;
                        &#125;
                    &#125;
                &#125; <span class="hljs-keyword">else</span> &#123;
                    mCircleWaveView.set<span class="hljs-constructor">UnLockPrePared(<span class="hljs-params">false</span>)</span>;
                    mCircleWaveView.set<span class="hljs-constructor">LockPrepared(<span class="hljs-params">false</span>)</span>;
                    mOnLockOperateListener.on<span class="hljs-constructor">NotPrepared()</span>;
                   <span class="hljs-comment">/* if (isLock()) &#123;</span>
<span class="hljs-comment">                        mCircleWaveView.setText(mContext.getResources().getString(R.string.device_control_unlock));</span>
<span class="hljs-comment">                    &#125; else &#123;</span>
<span class="hljs-comment">                        mCircleWaveView.setText(mContext.getResources().getString(R.string.device_control_lock));</span>
<span class="hljs-comment">                    &#125;*/</span>
<span class="hljs-comment">//                    isOperating = false;</span>
                &#125;

                <span class="hljs-comment">/**</span>
<span class="hljs-comment">                 * 控制滑动边界</span>
<span class="hljs-comment">                 */</span>
                <span class="hljs-built_in">int</span> border = (distance - mCircleWaveView.get<span class="hljs-constructor">Radius()</span> + mCircleView.get<span class="hljs-constructor">Radius()</span>) +
                        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">DensityUtils</span>.</span></span>dp2px(mContext, <span class="hljs-number">25</span>);<span class="hljs-comment">//  可上下滑动的最大距离</span>
                <span class="hljs-comment">//  当前上下滑动的距离</span>
                <span class="hljs-built_in">int</span> slideHeight = deltaY + mCircleWaveView.get<span class="hljs-constructor">ScrollY()</span>;
                <span class="hljs-keyword">if</span> (slideHeight &gt; border) &#123;
                    mCircleWaveView.scroll<span class="hljs-constructor">To(0, <span class="hljs-params">border</span>)</span>;
                    return <span class="hljs-literal">true</span>;
                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (slideHeight + border &lt; <span class="hljs-number">0</span>) &#123;
                    mCircleWaveView.scroll<span class="hljs-constructor">To(0, -<span class="hljs-params">border</span>)</span>;
                    return <span class="hljs-literal">true</span>;
                &#125;
                mCircleWaveView.scroll<span class="hljs-constructor">By(0, <span class="hljs-params">deltaY</span>)</span>;
                break;
            case MotionEvent.ACTION_UP:
                mCircleWaveView.set<span class="hljs-constructor">UnLockPrePared(<span class="hljs-params">false</span>)</span>;
                mCircleWaveView.set<span class="hljs-constructor">LockPrepared(<span class="hljs-params">false</span>)</span>;
                scrollY = mCircleWaveView.get<span class="hljs-constructor">ScrollY()</span>;
                <span class="hljs-keyword">if</span> (<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>abs(scrollY) &gt; (distance - mCircleWaveView.get<span class="hljs-constructor">Radius()</span> + mCircleView.get<span class="hljs-constructor">Radius()</span>)<span class="hljs-operator"> &amp;&amp; </span>mOption != null) &#123;
                    switch (mOption) &#123;
                        case LOCK:
                            <span class="hljs-keyword">if</span> (mOnLockOperateListener != null)
                                mOnLockOperateListener.on<span class="hljs-constructor">LockStart()</span>;
                            break;
                        case UNLOCK:
                            <span class="hljs-keyword">if</span> (mOnLockOperateListener != null)
                                mOnLockOperateListener.on<span class="hljs-constructor">UnlockStart()</span>;
                            break;
                    &#125;
                &#125;
                mCircleWaveView.smooth<span class="hljs-constructor">Scroll(0, 0)</span>;
                break;
        &#125;
        mLastY = y;
        return super.on<span class="hljs-constructor">TouchEvent(<span class="hljs-params">event</span>)</span>;
    &#125;
</code></pre>
<p>看到这个方法中这么多代码不知道各位是否已经懵逼？（好吧，我承认，这地方代码写的确实比较乱）不过没关系，其实细细分析来还是不难理解的！同样，我们选择比较重要的点来看。首先来看ACTION_MOVE的时候，在这里先判断了是否可以滑动（其实不可以滑动的情况下应该不会走到这个方法，但是为了严谨还是加了判断），如果不能滑动则下边的逻辑全都不会再走了。接下来<br>通过判断滑动的方向来确定是要开锁还是上锁，并根据滑动距离来给出回调处理。即当中心圆CircleWaveView向上或向下滑动并完全覆盖到上/下的小圆点时则会回掉上锁就绪或者开锁就绪（onLockPrepared、onUnLockPrepared）的方法。此时释放CircleWaveView，则会回调开锁或者上锁（onLockStart、onUnlockStart）的方法。如果CircleWaveView在完全覆盖到上/下的小圆点的状态下，再向反方向滑动至未完全覆盖小圆点，此时则会回掉未就绪（onNotPrepared）的方法。下边贴一下回调接口，一共五个方法，如下：</p>
<pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span>  <span class="hljs-title">OnLockOperateListener</span> &#123;
   <span class="hljs-comment">// 上锁就绪</span>
   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onLockPrepared</span>(<span class="hljs-params"></span>)</span>;
   <span class="hljs-comment">// 开锁就绪</span>
   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onUnLockPrepared</span>(<span class="hljs-params"></span>)</span>;
   <span class="hljs-comment">// 开始上锁</span>
   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onLockStart</span>(<span class="hljs-params"></span>)</span>;
   <span class="hljs-comment">// 开始开锁</span>
   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onUnlockStart</span>(<span class="hljs-params"></span>)</span>;
   <span class="hljs-comment">// 未就绪</span>
   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onNotPrepared</span>(<span class="hljs-params"></span>)</span>;
&#125;</code></pre>
<p>接下来是通过一系列计算来控制CircleWaveView的滑动边界。思路大致如此：首先根据CircleWaveView和上下小圆的位置来计算出可上下滑动的最大距离border。然后计算当CircleWaveView滑动的距离超过border时就强制将其滚动到border位置，已达到固定的效果。代码如下：</p>
<pre><code class="hljs reasonml"><span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 控制滑动边界</span>
<span class="hljs-comment">     */</span>
   <span class="hljs-built_in">int</span> border = (distance - mCircleWaveView.get<span class="hljs-constructor">Radius()</span> + mCircleView.get<span class="hljs-constructor">Radius()</span>) +
                       <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">DensityUtils</span>.</span></span>dp2px(mContext, <span class="hljs-number">25</span>);<span class="hljs-comment">//  可上下滑动的最大距离</span>
   <span class="hljs-built_in">int</span> deltaY = (<span class="hljs-built_in">int</span>) ((mLastY - y)<span class="hljs-operator"> / </span>damping);
   <span class="hljs-comment">//  当前上下滑动的距离</span>
   <span class="hljs-built_in">int</span> slideHeight = deltaY + mCircleWaveView.get<span class="hljs-constructor">ScrollY()</span>;
   <span class="hljs-keyword">if</span> (slideHeight &gt; border) &#123;
        mCircleWaveView.scroll<span class="hljs-constructor">To(0, <span class="hljs-params">border</span>)</span>;
        return <span class="hljs-literal">true</span>;
       &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (slideHeight + border &lt; <span class="hljs-number">0</span>) &#123;
         mCircleWaveView.scroll<span class="hljs-constructor">To(0, -<span class="hljs-params">border</span>)</span>;
         return <span class="hljs-literal">true</span>;
       &#125;
   mCircleWaveView.scroll<span class="hljs-constructor">By(0, <span class="hljs-params">deltaY</span>)</span>;</code></pre>

<p>然后是实现CircleWaveView的弹性滑动，这里我们给CircleWaveView加了一个弹性滑动和阻尼效果。弹性滑动是在CircleWaveView中通过Scroller来实现的，CircleWaveView暴漏出来smoothScroll的弹性滑动接口供在LockView中调用。这点我们在后面讲解CircleWaveView时再说。而阻尼滑动则是将原滑动距离除以阻尼系数以减小滑动距离从而产生阻尼效果。<br>最后来看ACTION_UP，同样是根据Y轴滑动距离与滑动方向回掉对应的方法，并将CircleWaveView恢复到原位。代码如下：</p>
<pre><code class="hljs yaml"><span class="hljs-string">scrollY</span> <span class="hljs-string">=</span> <span class="hljs-string">mCircleWaveView.getScrollY();</span>
<span class="hljs-string">if</span> <span class="hljs-string">(Math.abs(scrollY)</span> <span class="hljs-string">&gt;</span> <span class="hljs-string">(distance</span> <span class="hljs-bullet">-</span> <span class="hljs-string">mCircleWaveView.getRadius()</span> <span class="hljs-string">+</span> <span class="hljs-string">mCircleView.getRadius())</span> <span class="hljs-string">&amp;&amp;</span> <span class="hljs-string">mOption</span> <span class="hljs-type">!=</span> <span class="hljs-literal">null</span><span class="hljs-string">)</span> &#123;
   <span class="hljs-string">switch</span> <span class="hljs-string">(mOption)</span> &#123;
         <span class="hljs-attr">case LOCK:</span>
              <span class="hljs-string">if</span> <span class="hljs-string">(mOnLockOperateListener</span> <span class="hljs-type">!=</span> <span class="hljs-literal">null</span><span class="hljs-string">)</span>
                   <span class="hljs-string">mOnLockOperateListener.onLockStart();</span>
          <span class="hljs-string">break;</span>
          <span class="hljs-attr">case UNLOCK:</span>
              <span class="hljs-string">if</span> <span class="hljs-string">(mOnLockOperateListener</span> <span class="hljs-type">!=</span> <span class="hljs-literal">null</span><span class="hljs-string">)</span>
                   <span class="hljs-string">mOnLockOperateListener.onUnlockStart();</span>
          <span class="hljs-string">break;</span>
    &#125;
<span class="hljs-string">mCircleWaveView.smoothScroll(0</span>, <span class="hljs-number">0</span><span class="hljs-string">);</span></code></pre>


<h2 id="四-实现自定义CircleWaveView"><a href="#四-实现自定义CircleWaveView" class="headerlink" title="四. 实现自定义CircleWaveView"></a>四. 实现自定义CircleWaveView</h2><p>关于自定义CircleWaveView就不具体来讲了，因为关于自定义View都是一样的步骤。这里我们只选取几个重要的地方来说。1.CircleWaveView中内容的绘制。2.关于弹性滑动的实现。3.心跳动画的实现以及状态改变的扩散动画。</p>
<p><strong>1.CircleWaveView中内容的绘制。</strong></p>
<p><strong>绘制主体圆。</strong>主要分为几种情况：<br>a.蓝牙未连接，且未能获取到网络数据，背景色为灰色。<br>b.蓝牙未连接，且能获取到网络数据，背景色为淡绿色或淡红色。<br>c.蓝牙已连接，开锁状态为绿色，未开锁状态为红色。<br>d.上拉上锁就绪状态为深红色，下拉开锁就绪状态为深绿色。</p>
<p>结合以上需求有如下代码：</p>
<pre><code class="hljs reasonml"><span class="hljs-keyword">private</span> void draw<span class="hljs-constructor">Circle(Canvas <span class="hljs-params">canvas</span>)</span> &#123;
        mPaint.set<span class="hljs-constructor">Color(<span class="hljs-params">circleColor</span>)</span>;
        <span class="hljs-built_in">int</span> verticalCenter = get<span class="hljs-constructor">Height()</span><span class="hljs-operator"> / </span><span class="hljs-number">2</span>;
        <span class="hljs-built_in">int</span> horizontalCenter = get<span class="hljs-constructor">Width()</span><span class="hljs-operator"> / </span><span class="hljs-number">2</span>;
        <span class="hljs-built_in">int</span> mRadius = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>min(verticalCenter, horizontalCenter) - <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>min(verticalCenter, horizontalCenter)<span class="hljs-operator"> / </span><span class="hljs-number">5</span>;
        radius = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>min(verticalCenter, horizontalCenter) - <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>min(verticalCenter, horizontalCenter)<span class="hljs-operator"> / </span><span class="hljs-number">5</span>;
        <span class="hljs-keyword">if</span> (transforming) &#123;
            mPaint.set<span class="hljs-constructor">Color(<span class="hljs-params">getResources</span>()</span>.get<span class="hljs-constructor">Color(R.<span class="hljs-params">color</span>.<span class="hljs-params">green</span>)</span>);
            canvas.draw<span class="hljs-constructor">Circle(<span class="hljs-params">mPieCenterX</span>, <span class="hljs-params">mPieCenterY</span>, <span class="hljs-params">mRadius</span>, <span class="hljs-params">mPaint</span>)</span>;
            mRadius = isLock ? transformDelta : mRadius - transformDelta;
            mPaint.set<span class="hljs-constructor">Color(<span class="hljs-params">getResources</span>()</span>.get<span class="hljs-constructor">Color(R.<span class="hljs-params">color</span>.<span class="hljs-params">red</span>)</span>);
            canvas.draw<span class="hljs-constructor">Circle(<span class="hljs-params">mPieCenterX</span>, <span class="hljs-params">mPieCenterY</span>, <span class="hljs-params">mRadius</span>, <span class="hljs-params">mPaint</span>)</span>;
        &#125; <span class="hljs-keyword">else</span> &#123;
            mRadius = mRadius - waveDelta;
            <span class="hljs-keyword">if</span> (!isBluetoothConnect) &#123;
                <span class="hljs-keyword">if</span> (isNoNetData) &#123;
                    mPaint.set<span class="hljs-constructor">Color(<span class="hljs-params">getColor</span>(R.<span class="hljs-params">color</span>.<span class="hljs-params">gray</span>)</span>);
                &#125; <span class="hljs-keyword">else</span>
                    mPaint.set<span class="hljs-constructor">Color(<span class="hljs-params">isLock</span> ? <span class="hljs-params">getColor</span>(R.<span class="hljs-params">color</span>.<span class="hljs-params">redLight</span>)</span> : get<span class="hljs-constructor">Color(R.<span class="hljs-params">color</span>.<span class="hljs-params">greenLight</span>)</span>);
            &#125; <span class="hljs-keyword">else</span> &#123;
                <span class="hljs-keyword">if</span> (isLockPrepared) &#123;
                    mPaint.set<span class="hljs-constructor">Color(<span class="hljs-params">getColor</span>(R.<span class="hljs-params">color</span>.<span class="hljs-params">redDark</span>)</span>);
                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isUnLockPrePared) &#123;
                    mPaint.set<span class="hljs-constructor">Color(<span class="hljs-params">getColor</span>(R.<span class="hljs-params">color</span>.<span class="hljs-params">greenDark</span>)</span>);
                &#125; <span class="hljs-keyword">else</span> &#123;
                    mPaint.set<span class="hljs-constructor">Color(<span class="hljs-params">isLock</span> ? <span class="hljs-params">getColor</span>(R.<span class="hljs-params">color</span>.<span class="hljs-params">red</span>)</span> : get<span class="hljs-constructor">Color(R.<span class="hljs-params">color</span>.<span class="hljs-params">green</span>)</span>);
                &#125;
            &#125;
            canvas.draw<span class="hljs-constructor">Circle(<span class="hljs-params">mPieCenterX</span>, <span class="hljs-params">mPieCenterY</span>, <span class="hljs-params">mRadius</span>, <span class="hljs-params">mPaint</span>)</span>;
        &#125;
    &#125;</code></pre>

<p><strong>绘制CircleWaveView中上下箭头。</strong>  关于箭头绘制，注释部分是通过Path来绘制的，但是发现效果不太好，绘制三角形圆角比较麻烦，所以后台改为了直接在canvas上绘制Bitmap来实现。代码如下：</p>
<pre><code class="hljs yaml"><span class="hljs-string">//</span>  <span class="hljs-string">绘制圆中两个三角</span>
    <span class="hljs-string">private</span> <span class="hljs-string">void</span> <span class="hljs-string">drawTriangle(Canvas</span> <span class="hljs-string">canvas)</span> &#123;
        <span class="hljs-string">int</span> <span class="hljs-string">left</span> <span class="hljs-string">=</span> <span class="hljs-string">(mWidth</span> <span class="hljs-bullet">-</span> <span class="hljs-string">arrowUp.getWidth())</span> <span class="hljs-string">/</span> <span class="hljs-number">2</span><span class="hljs-string">;</span>
        <span class="hljs-string">canvas.drawBitmap(arrowUp</span>, <span class="hljs-string">left</span>, <span class="hljs-string">mHeight</span> <span class="hljs-string">/</span> <span class="hljs-number">2</span> <span class="hljs-bullet">-</span> <span class="hljs-string">radius</span> <span class="hljs-string">+</span> <span class="hljs-string">dp13</span>, <span class="hljs-string">mPaint);</span>
        <span class="hljs-string">canvas.drawBitmap(arrowDown</span>, <span class="hljs-string">left</span>, <span class="hljs-string">mHeight</span> <span class="hljs-string">/</span> <span class="hljs-number">2</span> <span class="hljs-string">+</span> <span class="hljs-string">radius</span> <span class="hljs-bullet">-</span> <span class="hljs-string">dp13</span> <span class="hljs-bullet">-</span> <span class="hljs-string">arrowDown.getHeight()</span>, <span class="hljs-string">mPaint);</span>
        <span class="hljs-string">/*int</span> <span class="hljs-string">radius</span> <span class="hljs-string">=</span> <span class="hljs-string">Math.min(mHeight</span>, <span class="hljs-string">mWidth)</span> <span class="hljs-string">/</span> <span class="hljs-number">2</span> <span class="hljs-bullet">-</span> <span class="hljs-string">Math.min(mHeight</span>, <span class="hljs-string">mWidth)</span> <span class="hljs-string">/</span> <span class="hljs-number">8</span><span class="hljs-string">;</span>
        <span class="hljs-string">mPaintTrangel.setStyle(Paint.Style.FILL);</span>
        <span class="hljs-string">mPaintTrangel.setShadowLayer(4</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-string">Color.GRAY);</span>
        <span class="hljs-string">//</span>  <span class="hljs-string">三角形顶点到圆边的距离</span>
        <span class="hljs-string">int</span> <span class="hljs-string">h0</span> <span class="hljs-string">=</span> <span class="hljs-string">DensityUtils.dp2px(mContext</span>, <span class="hljs-number">10</span><span class="hljs-string">);</span>
        <span class="hljs-string">//</span>  <span class="hljs-string">三角形高</span>
        <span class="hljs-string">int</span> <span class="hljs-string">h1</span> <span class="hljs-string">=</span> <span class="hljs-string">DensityUtils.dp2px(mContext</span>, <span class="hljs-number">12</span><span class="hljs-string">);</span>
        <span class="hljs-string">//</span>  <span class="hljs-string">三角形底边长</span>
        <span class="hljs-string">int</span> <span class="hljs-string">w</span> <span class="hljs-string">=</span> <span class="hljs-string">DensityUtils.dp2px(mContext</span>, <span class="hljs-number">14</span><span class="hljs-string">);</span>
        <span class="hljs-string">mPaintTrangel.setColor(getResources().getColor(R.color.transparent_33));</span>
        <span class="hljs-string">mPath.moveTo(mWidth</span> <span class="hljs-string">/</span> <span class="hljs-number">2</span>, <span class="hljs-string">mHeight</span> <span class="hljs-string">/</span> <span class="hljs-number">2</span> <span class="hljs-bullet">-</span> <span class="hljs-string">(radius</span> <span class="hljs-bullet">-</span> <span class="hljs-string">h0));</span>
        <span class="hljs-string">mPath.lineTo(mWidth</span> <span class="hljs-string">/</span> <span class="hljs-number">2</span> <span class="hljs-bullet">-</span> <span class="hljs-string">w</span>, <span class="hljs-string">mHeight</span> <span class="hljs-string">/</span> <span class="hljs-number">2</span> <span class="hljs-bullet">-</span> <span class="hljs-string">(radius</span> <span class="hljs-bullet">-</span> <span class="hljs-string">h1</span> <span class="hljs-bullet">-</span> <span class="hljs-string">h0));</span>
        <span class="hljs-string">mPath.lineTo(mWidth</span> <span class="hljs-string">/</span> <span class="hljs-number">2</span> <span class="hljs-string">+</span> <span class="hljs-string">w</span>, <span class="hljs-string">mHeight</span> <span class="hljs-string">/</span> <span class="hljs-number">2</span> <span class="hljs-bullet">-</span> <span class="hljs-string">(radius</span> <span class="hljs-bullet">-</span> <span class="hljs-string">h1</span> <span class="hljs-bullet">-</span> <span class="hljs-string">h0));</span>
        <span class="hljs-string">canvas.drawPath(mPath</span>, <span class="hljs-string">mPaintTrangel);</span>
        <span class="hljs-string">mPaintTrangel.setShadowLayer(4</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-3</span>, <span class="hljs-string">Color.GRAY);</span>
        <span class="hljs-string">mPath.moveTo(mWidth</span> <span class="hljs-string">/</span> <span class="hljs-number">2</span>, <span class="hljs-string">mHeight</span> <span class="hljs-string">/</span> <span class="hljs-number">2</span> <span class="hljs-string">+</span> <span class="hljs-string">(radius</span> <span class="hljs-bullet">-</span> <span class="hljs-string">h0));</span>
        <span class="hljs-string">mPath.lineTo(mWidth</span> <span class="hljs-string">/</span> <span class="hljs-number">2</span> <span class="hljs-bullet">-</span> <span class="hljs-string">w</span>, <span class="hljs-string">mHeight</span> <span class="hljs-string">/</span> <span class="hljs-number">2</span> <span class="hljs-string">+</span> <span class="hljs-string">(radius</span> <span class="hljs-bullet">-</span> <span class="hljs-string">h1</span> <span class="hljs-bullet">-</span> <span class="hljs-string">h0));</span>
        <span class="hljs-string">mPath.lineTo(mWidth</span> <span class="hljs-string">/</span> <span class="hljs-number">2</span> <span class="hljs-string">+</span> <span class="hljs-string">w</span>, <span class="hljs-string">mHeight</span> <span class="hljs-string">/</span> <span class="hljs-number">2</span> <span class="hljs-string">+</span> <span class="hljs-string">(radius</span> <span class="hljs-bullet">-</span> <span class="hljs-string">h1</span> <span class="hljs-bullet">-</span> <span class="hljs-string">h0));</span>
        <span class="hljs-string">canvas.drawPath(mPath</span>, <span class="hljs-string">mPaintTrangel);*/</span>
    &#125;</code></pre>
<p><strong>绘制CircleWaveView中心的文字</strong> 中心文字分为两种情况：当蓝牙未连接时，显示为两行。当蓝牙已连接时显示为一行。绘制思路是先计算出中心基线，然后再来分情况实现。代码如下：</p>
<pre><code class="hljs reasonml"><span class="hljs-comment">//  绘制圆中的文字</span>
    <span class="hljs-keyword">private</span> void draw<span class="hljs-constructor">Text(Canvas <span class="hljs-params">canvas</span>)</span> &#123;
        <span class="hljs-keyword">if</span> (isConnecting) return;
        <span class="hljs-keyword">if</span> (<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">TextUtils</span>.</span></span>is<span class="hljs-constructor">Empty(<span class="hljs-params">mText</span>)</span>) &#123; <span class="hljs-comment">//   绘制单行文字</span>
            String text = mContext.get<span class="hljs-constructor">Resources()</span>.get<span class="hljs-constructor">String(R.<span class="hljs-params">string</span>.<span class="hljs-params">ble_not_connect</span>)</span>;
            canvas.draw<span class="hljs-constructor">Text(<span class="hljs-params">text</span>, <span class="hljs-params">mPieCenterX</span>, <span class="hljs-params">getBaseline</span>(<span class="hljs-params">text</span>)</span>, mPaintText);
            return;
        &#125;
        <span class="hljs-keyword">if</span> (isBluetoothConnect) &#123;   <span class="hljs-comment">//   绘制单行文字</span>
            canvas.draw<span class="hljs-constructor">Text(<span class="hljs-params">mText</span>, <span class="hljs-params">mPieCenterX</span>, <span class="hljs-params">getBaseline</span>(<span class="hljs-params">mText</span>)</span>, mPaintText);
        &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-comment">//   绘制两行文字</span>
            String text = mContext.get<span class="hljs-constructor">Resources()</span>.get<span class="hljs-constructor">String(R.<span class="hljs-params">string</span>.<span class="hljs-params">ble_not_connect</span>)</span>;
            <span class="hljs-built_in">int</span> baseline = get<span class="hljs-constructor">Baseline(<span class="hljs-params">text</span>)</span>;
            canvas.draw<span class="hljs-constructor">Text(<span class="hljs-params">text</span>, <span class="hljs-params">mPieCenterX</span>, <span class="hljs-params">baseline</span> - 30, <span class="hljs-params">mPaintText</span>)</span>;
            mPaintText.set<span class="hljs-constructor">TextSize(DensityUtils.<span class="hljs-params">dp2px</span>(<span class="hljs-params">mContext</span>, 12)</span>);
            canvas.draw<span class="hljs-constructor">Text(<span class="hljs-params">mText</span>, <span class="hljs-params">mPieCenterX</span>, <span class="hljs-params">baseline</span> + 30, <span class="hljs-params">mPaintText</span>)</span>;
        &#125;
    &#125;

    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> get<span class="hljs-constructor">Baseline(String <span class="hljs-params">text</span>)</span> &#123;
        mPaintText.set<span class="hljs-constructor">TextSize(<span class="hljs-params">mTextSize</span>)</span>;
        mPaintText.get<span class="hljs-constructor">TextBounds(<span class="hljs-params">text</span>, 0, <span class="hljs-params">text</span>.<span class="hljs-params">length</span>()</span>, bounds);
        Paint.FontMetricsInt fontMetricsInt = mPaintText.get<span class="hljs-constructor">FontMetricsInt()</span>;
        return (get<span class="hljs-constructor">MeasuredHeight()</span> - fontMetricsInt.bottom + fontMetricsInt.top)<span class="hljs-operator"> / </span><span class="hljs-number">2</span>
                - fontMetricsInt.top;
    &#125;</code></pre>
<p><strong>2.关于弹性滑动的实现。</strong> 关于滑动，通常我们会想到用ScrollTo或ScrollBy来实现。但由于这两个方法实现滑动都是瞬间完成的，因此滑动看起来会比较生硬，体验也很不好。因此想到可以使用Scroller来做一个滑动延迟实现带有弹性效果的滑动。由于Scroller本身时无法实现滑动的，因此还必须配合computeScroll方法共同完成。这里我们封装一个smoothScroll方法，提供给LockView调用。具体代码如下：</p>
<pre><code class="hljs reasonml">public void smooth<span class="hljs-constructor">Scroll(<span class="hljs-params">int</span> <span class="hljs-params">destX</span>, <span class="hljs-params">int</span> <span class="hljs-params">destY</span>)</span> &#123;
        <span class="hljs-built_in">int</span> scrollY = get<span class="hljs-constructor">ScrollY()</span>;
        <span class="hljs-built_in">int</span> delta = destY - scrollY;
        mScroller.start<span class="hljs-constructor">Scroll(<span class="hljs-params">destX</span>, <span class="hljs-params">scrollY</span>, 0, <span class="hljs-params">delta</span>, 400)</span>;
        invalidate<span class="hljs-literal">()</span>;
    &#125;

    @Override
    public void compute<span class="hljs-constructor">Scroll()</span> &#123;
        <span class="hljs-keyword">if</span> (mScroller.compute<span class="hljs-constructor">ScrollOffset()</span>) &#123;
            scroll<span class="hljs-constructor">To(<span class="hljs-params">mScroller</span>.<span class="hljs-params">getCurrX</span>()</span>, mScroller.get<span class="hljs-constructor">CurrY()</span>);
            post<span class="hljs-constructor">Invalidate()</span>;
        &#125;
    &#125;</code></pre>
<p><strong>3.心跳动画的实现以及状态改变的扩散动画。</strong> </p>
<p>首先来看心跳动画的实现，这里使用属性动画，首先为ValueAnimator设置从0到1再到0的一个数值变化，并且周期时间设置为600毫秒、重复次数设置为ValueAnimator.INFINITE，即为无限次循环。通过ValueAnimator中不断变化的value来计算圆半径的大小，并通过invalidate()方法不断重绘View，从而达到一个心跳动画的效果。代码如下：</p>
<pre><code class="hljs reasonml"><span class="hljs-comment">//  开始心跳动画</span>
public void start<span class="hljs-constructor">Wave()</span> &#123;
        <span class="hljs-keyword">if</span> (animator != null<span class="hljs-operator"> &amp;&amp; </span>animator.is<span class="hljs-constructor">Running()</span>)
            animator.<span class="hljs-keyword">end</span><span class="hljs-literal">()</span>;
        animator = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ValueAnimator</span>.</span></span><span class="hljs-keyword">of</span><span class="hljs-constructor">Float(0f, 1f, 0f)</span>;
        animator.set<span class="hljs-constructor">RepeatCount(ValueAnimator.INFINITE)</span>;
        animator.set<span class="hljs-constructor">RepeatMode(ValueAnimator.RESTART)</span>;
        animator.set<span class="hljs-constructor">Duration(600)</span>;

        animator.add<span class="hljs-constructor">UpdateListener(<span class="hljs-params">new</span> ValueAnimator.AnimatorUpdateListener()</span> &#123;
            @Override
            public void on<span class="hljs-constructor">AnimationUpdate(ValueAnimator <span class="hljs-params">animation</span>)</span> &#123;
                <span class="hljs-built_in">int</span> verticalCenter = get<span class="hljs-constructor">Height()</span><span class="hljs-operator"> / </span><span class="hljs-number">2</span>;
                <span class="hljs-built_in">int</span> horizontalCenter = get<span class="hljs-constructor">Width()</span><span class="hljs-operator"> / </span><span class="hljs-number">2</span>;
                waveDelta = (<span class="hljs-built_in">int</span>) (<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>min(verticalCenter, horizontalCenter)<span class="hljs-operator"> * </span>(<span class="hljs-built_in">float</span>) animation.get<span class="hljs-constructor">AnimatedValue()</span><span class="hljs-operator"> / </span><span class="hljs-number">16</span>);
                invalidate<span class="hljs-literal">()</span>;
            &#125;
        &#125;);

        animator.start<span class="hljs-literal">()</span>;
    &#125;
 <span class="hljs-comment">//  停止心跳动画</span>
 public void stop<span class="hljs-constructor">Wave()</span> &#123;
        <span class="hljs-keyword">if</span> (animator != null<span class="hljs-operator"> &amp;&amp; </span>animator.is<span class="hljs-constructor">Running()</span>)
            animator.<span class="hljs-keyword">end</span><span class="hljs-literal">()</span>;
    &#125;</code></pre>
<p>接下来看状态改变时扩散动画的实现，其实方法和心跳动画一样，都是采用ValueAnimator动态计算绘制圆的半径，不在赘述。参考如下代码：</p>
<pre><code class="hljs reasonml">public void change<span class="hljs-constructor">LockState(<span class="hljs-params">final</span> <span class="hljs-params">boolean</span> <span class="hljs-params">lock</span>)</span> &#123;
        stop<span class="hljs-constructor">Wave()</span>;
        <span class="hljs-keyword">if</span> (this.isLock != lock) &#123;
            transforming = <span class="hljs-literal">true</span>;
            ValueAnimator valueAnimator = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ValueAnimator</span>.</span></span><span class="hljs-keyword">of</span><span class="hljs-constructor">Float(0f, 0.99f)</span>;
            valueAnimator.set<span class="hljs-constructor">Duration(500)</span>;
            valueAnimator.add<span class="hljs-constructor">Listener(<span class="hljs-params">new</span> Animator.AnimatorListener()</span> &#123;
                @Override
                public void on<span class="hljs-constructor">AnimationStart(Animator <span class="hljs-params">animation</span>)</span> &#123;

                &#125;

                @Override
                public void on<span class="hljs-constructor">AnimationEnd(Animator <span class="hljs-params">animation</span>)</span> &#123;
                    transforming = <span class="hljs-literal">false</span>;
                    isLock = lock;
                    invalidate<span class="hljs-literal">()</span>;
                &#125;

                @Override
                public void on<span class="hljs-constructor">AnimationCancel(Animator <span class="hljs-params">animation</span>)</span> &#123;
                    transforming = <span class="hljs-literal">false</span>;
                &#125;

                @Override
                public void on<span class="hljs-constructor">AnimationRepeat(Animator <span class="hljs-params">animation</span>)</span> &#123;

                &#125;
            &#125;);
            valueAnimator.add<span class="hljs-constructor">UpdateListener(<span class="hljs-params">new</span> ValueAnimator.AnimatorUpdateListener()</span> &#123;
                @Override
                public void on<span class="hljs-constructor">AnimationUpdate(ValueAnimator <span class="hljs-params">animation</span>)</span> &#123;
                    <span class="hljs-built_in">int</span> verticalCenter = get<span class="hljs-constructor">Height()</span><span class="hljs-operator"> / </span><span class="hljs-number">2</span>;
                    <span class="hljs-built_in">int</span> horizontalCenter = get<span class="hljs-constructor">Width()</span><span class="hljs-operator"> / </span><span class="hljs-number">2</span>;
                    transformDelta = (<span class="hljs-built_in">int</span>) ((<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>min(verticalCenter, horizontalCenter) - <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>min(verticalCenter, horizontalCenter)<span class="hljs-operator"> / </span><span class="hljs-number">6</span>)
<span class="hljs-operator">                            * </span>(<span class="hljs-built_in">float</span>) animation.get<span class="hljs-constructor">AnimatedValue()</span>);
                    invalidate<span class="hljs-literal">()</span>;
                &#125;
            &#125;);
            valueAnimator.start<span class="hljs-literal">()</span>;
        &#125;
    &#125;</code></pre>
<p>至此，关于LockView的绘制到这里就完全结束了。回顾一下本篇文章，重讲解了自定义LockView以及弹性滑动实现，然后探讨了关于事件分发的一些知识以及使用属性动画来实现心跳和扩散效果。相信看完本篇文章的小伙伴也会有不小的收获，最后关于源码，已放在文章末尾，欢迎start、forck！</p>
<p> <a target="_blank" rel="noopener" href="https://github.com/zhpanvip/CustomView">源码链接</a></p>
<h3 id="好库推荐"><a href="#好库推荐" class="headerlink" title="好库推荐"></a>好库推荐</h3><p>给大家推荐一下<a target="_blank" rel="noopener" href="https://github.com/zhpanvip/BannerViewPager">BannerViewPager</a>。这是一个基于ViewPager实现的具有强大功能的无限轮播库。通过<a target="_blank" rel="noopener" href="https://github.com/zhpanvip/BannerViewPager">BannerViewPager</a>可以实现腾讯视频、QQ音乐、酷狗音乐、支付宝、天猫、淘宝、优酷视频、喜马拉雅、网易云音乐、哔哩哔哩等APP的Banner样式以及指示器样式。</p>
<p>欢迎大家到github关注<a target="_blank" rel="noopener" href="https://github.com/zhpanvip/BannerViewPager">BannerViewPager</a>！</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/%E8%87%AA%E5%AE%9A%E4%B9%89View/">自定义View</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2018/07/26/15.%E5%9F%BA%E4%BA%8EArouter%E7%9A%84%E8%B7%AF%E7%94%B1%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">基于Arouter的路由实现方案</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2018/06/21/13.Android-Widget%E5%BC%80%E5%8F%91%E8%AF%A6%E8%A7%A3/">
                        <span class="hidden-mobile">Android Widget开发详解</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments">
                
                
  <div id="vcomments"></div>
  <script type="text/javascript">
    function loadValine() {
      addScript('https://cdn.staticfile.org/valine/1.4.14/Valine.min.js', function () {
        new Valine({
          el: "#vcomments",
          app_id: "hXIROaIM5y9qnieojJRWP5hS-gzGzoHsz",
          app_key: "y0f3w3aqd1MF7JL9ma4WECTy",
          placeholder: "说点什么",
          path: window.location.pathname,
          avatar: "retro",
          meta: ["nick","mail","link"],
          pageSize: "10",
          lang: "zh-CN",
          highlight: false,
          recordIP: false,
          serverURLs: "https://zhpanvip.github.io",
        });
      });
    }
    waitElementVisible('vcomments', loadValine);
  </script>
  <noscript>Please enable JavaScript to view the <a target="_blank" href="https://valine.js.org" rel="nofollow noopener noopener">comments
      powered by Valine.</a></noscript>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener">
        <span>Fluid</span></a>
    </div>
    

    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/main.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>







  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: '#post-body',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "自定义View之弹性滑动的LockView&nbsp;",
      ],
      cursorChar: "|",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>




















</body>
</html>
