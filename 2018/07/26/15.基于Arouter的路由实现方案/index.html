

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  <title>基于Arouter的路由实现方案 - Hexo</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/github-gist.min.css" />
  

  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_6peoq002giu.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_pjno9b9zyxs.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.1.1"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>zhangpan</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner intro-2" id="background" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container page-header text-center fade-in-up">
            <span class="h2" id="subtitle">
              
            </span>

            
              
  <div class="mt-3 post-meta">
    <i class="iconfont icon-date-fill" aria-hidden="true"></i>
    <time datetime="2018-07-26 00:39" pubdate>
      2018年7月26日 凌晨
    </time>
  </div>


<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      4.6k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      55
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto" id="post">
            <!-- SEO header -->
            <h1 style="display: none">基于Arouter的路由实现方案</h1>
            
            <div class="markdown-body" id="post-body">
              <p>这本是一篇应该写在去年的文章，但仅仅因为…懒，这篇文章在草稿箱里静静的躺了一年多，被无限期推迟到了现在。最近刚好完成了公司项目的路由改造，借此机会来对这篇文章做一个了结。<br><img src="https://img-blog.csdnimg.cn/20190918012522155.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p>
<h1 id="一、为什么要在项目中引入路由？"><a href="#一、为什么要在项目中引入路由？" class="headerlink" title="一、为什么要在项目中引入路由？"></a>一、为什么要在项目中引入路由？</h1><p>在开始之前我们先来思考一下这个问题。为什么要在项目中引入路由？相信大家的答案可能会有所不同，但是应该也不外乎以下几点：</p>
<h2 id="1-为了实现项目组件化"><a href="#1-为了实现项目组件化" class="headerlink" title="1.为了实现项目组件化"></a>1.为了实现项目组件化</h2><p>想必很多开发者引入路由的目的都是因为要实现项目组件化。我们知道，组件化的项目各个业务模块之间没有相互的依赖关系。不同业务模块之间的通信最好的解决方案就是支持页面路由。</p>
<h2 id="2-方便APP内部跳转"><a href="#2-方便APP内部跳转" class="headerlink" title="2.方便APP内部跳转"></a>2.方便APP内部跳转</h2><p>可能有些小伙伴会有疑问，App内部直接通过Intent跳转不是很好吗，为什么要多此一举引入路由呢？当然，通常情况下通过Intent跳转也无伤大雅。但是在某些情况下，比如像下图这样的一个页面：<br><img src="https://img-blog.csdnimg.cn/2019091700111637.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwNTIxNTcz,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>这是一个典型的多Type的RecyclerView页面，这个页面中所有的数据都是从服务器获取的，在引入路由之前所有的点击跳转事件都需要后台给我们一个type,我们根据type判断需要向哪一个Activity跳转，并且需要通过Intent携带目的页面所需要的参数。显然这样写会使我们代码变得非常臃肿，代码之间的耦合度也非常高。然而在引入路由之后一切都变得不一样了。我们只需要后台返回目的页面所对应的URL，并在URL上拼接页面跳转所需要的参数，此时前台只需要拿到URL，然后通过路由即可到达对应的页面。这样以来使我们的代码变得简洁明了，并且保证了代码的低耦合。</p>
<h2 id="3-方便APP外部跳转"><a href="#3-方便APP外部跳转" class="headerlink" title="3.方便APP外部跳转"></a>3.方便APP外部跳转</h2><p>通常可以看到很多应用支持从浏览器唤醒App并跳转到对应的页面。做到比较好的如知乎，体验过知乎的小伙伴应该知道，知乎可以从浏览器唤醒App并且直接在App中打开当前在浏览器中浏览的内容。我们知道，从外部唤起App需要给Activity添加Schema。而如果App内部有许多Activity需要支持外部唤起，我们不可能为这些Activity都添加Schema。那么此时我们就可以单独设置一个支持Schema的Activity，浏览器可以通过Schema唤起这个Activity。而在这个Activity中会接收浏览器传过来的URL，然后根据URL进行路由分发，通过URL路由到对应的页面即可。</p>
<h1 id="二-、ARouter的使用"><a href="#二-、ARouter的使用" class="headerlink" title="二 、ARouter的使用"></a>二 、ARouter的使用</h1><p>其实很不想在这篇文章中长篇大论如何使用<a target="_blank" rel="noopener" href="https://github.com/alibaba/ARouter">ARouter</a>，因为<a target="_blank" rel="noopener" href="https://github.com/alibaba/ARouter/blob/master/README_CN.md">ARouter的官方文档</a>上已经非常详细的告诉了开发者如何去使用，只要仔细的阅读ARouter的文档基本上绝大部分问题都可以得到解决。但是为了照顾没有使用过ARouter的小伙伴，这里还是再啰嗦一下。如果你对ARouter的使用已经非常熟悉了那么你可以忽略此章节，直接到下一章了。</p>
<h2 id="1-添加依赖和配置"><a href="#1-添加依赖和配置" class="headerlink" title="1.添加依赖和配置"></a>1.添加依赖和配置</h2><pre><code class="hljs properties"><span class="hljs-attr">android</span> <span class="hljs-string">&#123;</span>
    <span class="hljs-attr">defaultConfig</span> <span class="hljs-string">&#123;</span>
        <span class="hljs-attr">...</span>
        <span class="hljs-attr">javaCompileOptions</span> <span class="hljs-string">&#123;</span>
            <span class="hljs-attr">annotationProcessorOptions</span> <span class="hljs-string">&#123;</span>
                <span class="hljs-attr">arguments</span> = <span class="hljs-string">[AROUTER_MODULE_NAME: project.getName()]</span>
            <span class="hljs-attr">&#125;</span>
        <span class="hljs-attr">&#125;</span>
    <span class="hljs-attr">&#125;</span>
<span class="hljs-attr">&#125;</span>

<span class="hljs-attr">dependencies</span> <span class="hljs-string">&#123;</span>
    <span class="hljs-meta">//</span> <span class="hljs-string">替换成最新版本, 需要注意的是api</span>
    <span class="hljs-meta">//</span> <span class="hljs-string">要与compiler匹配使用，均使用最新版可以保证兼容</span>
    <span class="hljs-attr">implementation</span> <span class="hljs-string">&#x27;com.alibaba:arouter-api:x.x.x&#x27;</span>
    <span class="hljs-attr">annotationProcessor</span> <span class="hljs-string">&#x27;com.alibaba:arouter-compiler:x.x.x&#x27;</span>
    <span class="hljs-attr">...</span>
<span class="hljs-attr">&#125;</span></code></pre>
<p>这里需要注意，如果你的项目有多个业务模块，那么每个模块都需要在gradle中添加以上配置。</p>
<h2 id="2-初始化SDK"><a href="#2-初始化SDK" class="headerlink" title="2.初始化SDK"></a>2.初始化SDK</h2><pre><code class="hljs reasonml"><span class="hljs-keyword">if</span> (is<span class="hljs-constructor">Debug()</span>) &#123;           <span class="hljs-comment">// 这两行必须写在init之前，否则这些配置在init过程中将无效</span>
    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ARouter</span>.</span></span><span class="hljs-keyword">open</span><span class="hljs-constructor">Log()</span>;     <span class="hljs-comment">// 打印日志</span>
    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ARouter</span>.</span></span><span class="hljs-keyword">open</span><span class="hljs-constructor">Debug()</span>;   <span class="hljs-comment">// 开启调试模式(如果在InstantRun模式下运行，必须开启调试模式！线上版本需要关闭,否则有安全风险)</span>
&#125;
<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ARouter</span>.</span></span>init(mApplication); <span class="hljs-comment">// 尽可能早，推荐在Application中初始化</span></code></pre>

<h2 id="3-添加注解"><a href="#3-添加注解" class="headerlink" title="3.添加注解"></a>3.添加注解</h2><pre><code class="hljs angelscript"><span class="hljs-comment">// 在支持路由的页面上添加注解(必选)</span>
<span class="hljs-comment">// 这里的路径需要注意的是至少需要有两级，/xx/xx</span>
@Route(path = <span class="hljs-string">&quot;/test/activity&quot;</span>)
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-symbol">YourActivity</span> <span class="hljs-symbol">extend</span> <span class="hljs-symbol">Activity</span> &#123;
    ...
&#125;</code></pre>

<h2 id="4-发起路由操作"><a href="#4-发起路由操作" class="headerlink" title="4.发起路由操作"></a>4.发起路由操作</h2><pre><code class="hljs reasonml"><span class="hljs-comment">// 1. 应用内简单的跳转(通过URL跳转在&#x27;进阶用法&#x27;中)</span>
<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ARouter</span>.</span></span>get<span class="hljs-constructor">Instance()</span>.build(<span class="hljs-string">&quot;/test/activity&quot;</span>).navigation<span class="hljs-literal">()</span>;

<span class="hljs-comment">// 2. 跳转并携带参数</span>
<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ARouter</span>.</span></span>get<span class="hljs-constructor">Instance()</span>.build(<span class="hljs-string">&quot;/test/1&quot;</span>)
            .<span class="hljs-keyword">with</span><span class="hljs-constructor">Long(<span class="hljs-string">&quot;key1&quot;</span>, 666L)</span>
            .<span class="hljs-keyword">with</span><span class="hljs-constructor">String(<span class="hljs-string">&quot;key3&quot;</span>, <span class="hljs-string">&quot;888&quot;</span>)</span>
            .<span class="hljs-keyword">with</span><span class="hljs-constructor">Object(<span class="hljs-string">&quot;key4&quot;</span>, <span class="hljs-params">new</span> Test(<span class="hljs-string">&quot;Jack&quot;</span>, <span class="hljs-string">&quot;Rose&quot;</span>)</span>)
            .navigation<span class="hljs-literal">()</span>;</code></pre>
<p>很多情况下需要通过URL跳转，ARouter支持直接通过URL跳转：</p>
<pre><code class="hljs reasonml">Uri uri= <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Uri</span>.</span></span>parse(url);
<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ARouter</span>.</span></span>get<span class="hljs-constructor">Instance()</span>.build(uri).navigation<span class="hljs-literal">()</span>;</code></pre>

<h2 id="5-路由解析参数"><a href="#5-路由解析参数" class="headerlink" title="5.路由解析参数"></a>5.路由解析参数</h2><pre><code class="hljs aspectj"><span class="hljs-comment">// 为每一个参数声明一个字段，并使用 @Autowired 标注</span>
<span class="hljs-comment">// URL中不能传递Parcelable类型数据，通过ARouter api可以传递Parcelable对象</span>
<span class="hljs-meta">@Route</span>(path = <span class="hljs-string">&quot;/test/activity&quot;</span>)
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test1Activity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Activity</span> </span>&#123;
    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">public</span> String name;
    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">int</span> age;
    
    <span class="hljs-comment">// 通过name来映射URL中的不同参数</span>
    <span class="hljs-meta">@Autowired</span>(name = <span class="hljs-string">&quot;girl&quot;</span>) 
    <span class="hljs-keyword">boolean</span> boy;
    
    <span class="hljs-comment">// 支持解析自定义对象，URL中使用json传递</span>
    <span class="hljs-meta">@Autowired</span>
    TestObj obj;      
    
    <span class="hljs-comment">// 使用 withObject 传递 List 和 Map 的实现了</span>
    <span class="hljs-comment">// Serializable 接口的实现类(ArrayList/HashMap)</span>
    <span class="hljs-comment">// 的时候，接收该对象的地方不能标注具体的实现类类型</span>
    <span class="hljs-comment">// 应仅标注为 List 或 Map，否则会影响序列化中类型</span>
    <span class="hljs-comment">// 的判断, 其他类似情况需要同样处理        </span>
    <span class="hljs-meta">@Autowired</span>
    List&lt;TestObj&gt; list;
    <span class="hljs-meta">@Autowired</span>
    Map&lt;String, List&lt;TestObj&gt;&gt; map;
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">protected</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> </span>&#123;
    <span class="hljs-keyword">super</span>.onCreate(savedInstanceState);
    ARouter.getInstance().inject(<span class="hljs-keyword">this</span>);

    <span class="hljs-comment">// ARouter会自动对字段进行赋值，无需主动获取</span>
    Log.d(<span class="hljs-string">&quot;param&quot;</span>, name + age + boy);
    &#125;
&#125;


<span class="hljs-comment">// 如果需要传递自定义对象，新建一个类（并非自定义对象类），然后实现 SerializationService,并使用@Route注解标注(方便用户自行选择序列化方式)，例如：</span>
<span class="hljs-meta">@Route</span>(path = <span class="hljs-string">&quot;/yourservicegroupname/json&quot;</span>)
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JsonServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">SerializationService</span> </span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(Context context)</span> </span>&#123;

    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">json2Object</span><span class="hljs-params">(String text, Class&lt;T&gt; clazz)</span> </span>&#123;
        <span class="hljs-function"><span class="hljs-keyword">return</span> JSON.<span class="hljs-title">parseObject</span><span class="hljs-params">(text, clazz)</span></span>;
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-function">String <span class="hljs-title">object2Json</span><span class="hljs-params">(Object instance)</span> </span>&#123;
        <span class="hljs-function"><span class="hljs-keyword">return</span> JSON.<span class="hljs-title">toJSONString</span><span class="hljs-params">(instance)</span></span>;
    &#125;
&#125;</code></pre>
<p>除了使用@Autowired注解注入参数外，还可以与普通页面跳转一样通过getIntent()获取参数。</p>
<p>以上就是ARouter的一些基本用法，了解这些基本用法之后并不等于已经掌握了ARouter。因为当你实际用到项目中的时候可能会面临诸多问题。</p>
<h1 id="三-、ARouter的采坑之路"><a href="#三-、ARouter的采坑之路" class="headerlink" title="三 、ARouter的采坑之路"></a>三 、ARouter的采坑之路</h1><p>如果你只是简单的写一个ARouter使用的Demo，那么可能上一章的内容已经足够了。但是当你在项目中引入ARouter后各种各样的问题便会接踵而至。</p>
<h2 id="1-使用ARouter实现登录拦截"><a href="#1-使用ARouter实现登录拦截" class="headerlink" title="1.使用ARouter实现登录拦截"></a>1.使用ARouter实现登录拦截</h2><p>这是在项目中引入ARouter后面临的第一个问题。通常情况下，大部分App不登录便可以进入主页面，在跳转需要用户权限的页面时会首先跳转到登录页面引导用户登录。我相信大部分的开发在最初时候都写过类似这样的代码：</p>
<pre><code class="hljs isbl"><span class="hljs-variable"><span class="hljs-keyword">if</span></span> (<span class="hljs-variable">isLogin</span>) &#123;
    <span class="hljs-function"><span class="hljs-title">goToDestination</span>();</span>
<span class="hljs-function"> &#125; <span class="hljs-variable"><span class="hljs-keyword">else</span></span> &#123;</span>
<span class="hljs-function">    <span class="hljs-title">goToLogin</span>();</span>
<span class="hljs-function"> &#125;</span></code></pre>
<p>在每次跳转页面的时候都需要进行是否登录的判断，这样的代码显然有很大的弊端。而ARouter为我们提供了面向切面的登录拦截功能，ARouter的文档上给了我们一个例子：</p>
<pre><code class="hljs less"><span class="hljs-comment">// 比较经典的应用就是在跳转过程中处理登陆事件，这样就不需要在目标页重复做登陆检查</span>
<span class="hljs-comment">// 拦截器会在跳转之间执行，多个拦截器会按优先级顺序依次执行</span>
<span class="hljs-variable">@Interceptor</span>(priority = <span class="hljs-number">8</span>, name = <span class="hljs-string">&quot;测试用拦截器&quot;</span>)
public class TestInterceptor implements IInterceptor &#123;
    <span class="hljs-variable">@Override</span>
    public void process(Postcard postcard, InterceptorCallback callback) &#123;
    ...
    <span class="hljs-selector-tag">callback</span><span class="hljs-selector-class">.onContinue</span>(postcard);  <span class="hljs-comment">// 处理完成，交还控制权</span>
    <span class="hljs-comment">// callback.onInterrupt(new RuntimeException(&quot;我觉得有点异常&quot;));      // 觉得有问题，中断路由流程</span>

    <span class="hljs-comment">// 以上两种至少需要调用其中一种，否则不会继续路由</span>
    &#125;

    <span class="hljs-variable">@Override</span>
    public void init(Context context) &#123;
    <span class="hljs-comment">// 拦截器的初始化，会在sdk初始化的时候调用该方法，仅会调用一次</span>
    &#125;
&#125;</code></pre>
<p>如果你按着官方文档上这样写，那么你大概率会碰到很多问题。列举如下：<br><strong>如何处理有些页面需要登录拦截，有些页面不需要登录拦截？</strong><br>如果你添加了拦截器，那么在每次路由跳转时都会优先走到拦截器中，在拦截器的process()方法中你可以通过判断当前是否登录来决定是否继续该路由操作，如果已经登录，那么直接通过 callback.onContinue(postcard)继续当前路由，而如果没有登录，那么就将目的页面修改为登录页。但是，不要忘了，添加拦截器后所有的路由操作都会优先走到这里，而我们的需求是只有需要用户权限的时候才需要跳转到登录页，否则即使没有登录依然可以跳转到目的页。此时我们应该怎么办？<br>如果你仔细的看了ARouter的开发文档，你可能注意到在@Route的注解有一个int类型的extras参数。如此我们便可以通过这个参数来对Activity进行标记是否需要登录：</p>
<pre><code class="hljs scala"><span class="hljs-meta">@Route</span>(path = <span class="hljs-type">PATH_TEST</span>, extras = <span class="hljs-type">IGNORE_LOGIN</span>)
public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BaseTitleCompatActivity</span> </span>&#123;&#125;</code></pre>
<p>接下来，在拦截器中可以拿到extras参数，以此来确定该页面是否需要登录：</p>
<pre><code class="hljs reasonml"><span class="hljs-keyword">if</span>(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">UserInfoTools</span>.</span></span>is<span class="hljs-constructor">Login()</span><span class="hljs-operator"> || </span>IGNORE_LOGIN<span class="hljs-operator"> == </span>postcard.get<span class="hljs-constructor">Extra()</span>) &#123;  <span class="hljs-comment">//  已经登录或者不需要拦截的情况</span>
	 <span class="hljs-comment">//  继续当前路由</span>
      callback.on<span class="hljs-constructor">Continue(<span class="hljs-params">postcard</span>)</span>;
 &#125; <span class="hljs-keyword">else</span> &#123;	<span class="hljs-comment">// 未登录且需要登录的情况</span>
    <span class="hljs-comment">//	路由到登录页面</span>
    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ARouter</span>.</span></span>get<span class="hljs-constructor">Instance()</span>.build(RoutingTable.PATH_GUEST_LOGIN).navigation<span class="hljs-literal">()</span>;
    ...
  &#125;</code></pre>
<p>到这里这个问题解决了，但是当你兴致勃勃的运行起来App,在未登录的情况下点击跳转到需要用户权限的页面，你憧憬着跳转页面会被拦截到登录页，但是你又被无情的事实打脸了。竟然页面毫无反应？于是你断点、打Log发现ARouter.getInstance().build(RoutingTable.PATH_GUEST_LOGIN).navigation()这句代码确实执行了，但是为什么没有跳转到登录页？于是你苦思冥想，突然灵光一闪，哇！是因为这一句路由也会走到了拦截器里，如此岂不成了一个死循环。于是你Google如何解决，发现原来需要调用greenChannel()来避免出现死循环。于是有了如下代码：</p>
<pre><code class="hljs reasonml"><span class="hljs-keyword">if</span>(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">UserInfoTools</span>.</span></span>is<span class="hljs-constructor">Login()</span><span class="hljs-operator"> || </span>IGNORE_LOGIN<span class="hljs-operator"> == </span>postcard.get<span class="hljs-constructor">Extra()</span>) &#123;  <span class="hljs-comment">//  已经登录或者不需要拦截的情况</span>
	 <span class="hljs-comment">//  继续当前路由</span>
      callback.on<span class="hljs-constructor">Continue(<span class="hljs-params">postcard</span>)</span>;
 &#125; <span class="hljs-keyword">else</span> &#123;	<span class="hljs-comment">// 未登录且需要登录的情况</span>
    <span class="hljs-comment">//	路由到登录页面</span>
   <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ARouter</span>.</span></span>get<span class="hljs-constructor">Instance()</span>.build(RoutingTable.PATH_GUEST_LOGIN).green<span class="hljs-constructor">Channel()</span>.navigation<span class="hljs-literal">()</span>;
    ...
  &#125;</code></pre>
<p>修改之后你怀着和刚才一样的心情兴致勃勃的运行起来App,心想，这次一定没问题。好！点击按钮….竟然成功跳转到了登录页面。于是你兴奋起来，疯狂的点击这些页面，发现都没问题。可是…当你点了几次之后突然发现，页面跳转无效了！！你简直不敢相信自己的眼睛，刚才明明是好好的…于是你在此陷入了沉思。<br>好吧，这次直接公布答案了，那是因为你需要将原来的路由打断，而之所以前几次有效大概猜测是因为greenChannel()去开启了多个channel，而ARouter的channel是有限的，因此在点击几次之后路由再次失效了。于是修改后代码如下：</p>
<pre><code class="hljs reasonml"><span class="hljs-keyword">if</span>(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">UserInfoTools</span>.</span></span>is<span class="hljs-constructor">Login()</span><span class="hljs-operator"> || </span>IGNORE_LOGIN<span class="hljs-operator"> == </span>postcard.get<span class="hljs-constructor">Extra()</span>) &#123;  <span class="hljs-comment">//  已经登录或者不需要拦截的情况</span>
	 <span class="hljs-comment">//  继续当前路由</span>
      callback.on<span class="hljs-constructor">Continue(<span class="hljs-params">postcard</span>)</span>;
 &#125; <span class="hljs-keyword">else</span> &#123;	<span class="hljs-comment">// 未登录且需要登录的情况</span>
    <span class="hljs-comment">//	路由到登录页面</span>
   <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ARouter</span>.</span></span>get<span class="hljs-constructor">Instance()</span>.build(RoutingTable.PATH_GUEST_LOGIN).green<span class="hljs-constructor">Channel()</span>.navigation<span class="hljs-literal">()</span>;
   callback.on<span class="hljs-constructor">Interrupt(<span class="hljs-params">null</span>)</span>;
  &#125;</code></pre>
<p>关于登录拦截看似简单，实则使用时候竟然会碰到这么多问题！相信第一次使用时都会被虐的掉眼泪。</p>
<h2 id="2-处理一个Activity对应多个路径的情况"><a href="#2-处理一个Activity对应多个路径的情况" class="headerlink" title="2.处理一个Activity对应多个路径的情况"></a>2.处理一个Activity对应多个路径的情况</h2><p>在某些情况可能出现一个页面对应多个路径的情况。出现这种情况的原因可能是前期路由没有规划好，导致后边版本的路由路径做了修改。从而出现了一个Activity对应多个页面的情况。为了兼容旧版路由，我们不得不处理这种情况。但是，Route的注解中path是唯一的，并不能通过@Route注解解决一个Activity对应多个路径的情况。此时就需要用到ARouter的重写URL的功能。只需要实现PathReplaceService 接口，在重写的方法中对URI或者Path进行替换即可，注意，这个类一定要加@Route注解。代码参考如下：</p>
<pre><code class="hljs reasonml">@<span class="hljs-constructor">Route(<span class="hljs-params">path</span> = <span class="hljs-string">&quot;/lost/service&quot;</span>)</span>
public <span class="hljs-keyword">class</span> ARouterLostReplaceService implements PathReplaceService &#123;
    @Override
    public String <span class="hljs-keyword">for</span><span class="hljs-constructor">String(String <span class="hljs-params">path</span>)</span> &#123;	<span class="hljs-comment">//	对于path处理与uri类似</span>
        return path;
    &#125;

    @Override
    public Uri <span class="hljs-keyword">for</span><span class="hljs-constructor">Uri(Uri <span class="hljs-params">uri</span>)</span> &#123;	
        String path = uri.get<span class="hljs-constructor">Path()</span>;
        <span class="hljs-keyword">if</span>(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">PATH_LOST1</span>.</span></span>equals(path)) &#123;
            uri = replace<span class="hljs-constructor">UriPath(<span class="hljs-params">uri</span>, PATH_REAL1)</span>;
        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">PATH_LOST2</span>.</span></span>equals(path)) &#123;
            uri = replace<span class="hljs-constructor">UriPath(<span class="hljs-params">uri</span>, PATH_REAL2)</span>;
        &#125;
        return uri;
    &#125;

    @Override
    public void init(Context context) &#123;

    &#125;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 替换URI中的path</span>
<span class="hljs-comment">     * </span>
<span class="hljs-comment">     * @param uri 被替换的uri</span>
<span class="hljs-comment">     * @param path 要替换的path</span>
<span class="hljs-comment">     * @return 替换后的uri</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-keyword">private</span> Uri replace<span class="hljs-constructor">UriPath(Uri <span class="hljs-params">uri</span>, String <span class="hljs-params">path</span>)</span> &#123;
        StringBuilder resultUrl = <span class="hljs-keyword">new</span> <span class="hljs-constructor">StringBuilder(<span class="hljs-params">uri</span>.<span class="hljs-params">getScheme</span>()</span> + <span class="hljs-string">&quot;://&quot;</span> + uri.get<span class="hljs-constructor">Host()</span> + path);
        String<span class="hljs-literal">[]</span> split = uri.<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span>.split(<span class="hljs-string">&quot;\\?&quot;</span>);
        <span class="hljs-keyword">if</span>(split.length &gt;= <span class="hljs-number">2</span>) &#123;
            resultUrl.append(<span class="hljs-string">&quot;?&quot;</span>).append(split<span class="hljs-literal">[<span class="hljs-number">1</span>]</span>);
        &#125;
        return <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Uri</span>.</span></span>parse(resultUrl.<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span>);
    &#125;
&#125;</code></pre>

<h2 id="3-ARouter全局降级策略"><a href="#3-ARouter全局降级策略" class="headerlink" title="3.ARouter全局降级策略"></a>3.ARouter全局降级策略</h2><p>在路由跳转时可能会出现找不到Path对应页面的情况，对于这种情况可以通过实现DegradeService 接口来处理，同样这个类也必须要添加@Route注解。这样当路由跳转时找不到路径就会走到这个类的onLost方法中，此时就可以在这个方法中来做相应的处理了。</p>
<pre><code class="hljs less"><span class="hljs-comment">// 实现DegradeService接口，并加上一个Path内容任意的注解即可</span>
<span class="hljs-variable">@Route</span>(path = <span class="hljs-string">&quot;/lost/path&quot;</span>)
public class DegradeServiceImpl implements DegradeService &#123;
	<span class="hljs-variable">@Override</span>
	public void onLost(Context context, Postcard postcard) &#123;
	    <span class="hljs-comment">//  可以在此处统一处理，比如跳转到首页</span>
	&#125;

	<span class="hljs-variable">@Override</span>
	public void init(Context context) &#123;

	&#125;
&#125;</code></pre>

<h1 id="四、通过浏览器跳转到App对应页面"><a href="#四、通过浏览器跳转到App对应页面" class="headerlink" title="四、通过浏览器跳转到App对应页面"></a>四、通过浏览器跳转到App对应页面</h1><h2 id="1-Schema协议"><a href="#1-Schema协议" class="headerlink" title="1.Schema协议"></a>1.Schema协议</h2><p>很多人对于Schema协议比较陌生，但是如果说URL大家一定都非常熟悉。其实URL就是一种Schema协议。Schema协议通常由四部分组成：</p>
<pre><code class="hljs inform7"><span class="hljs-comment">[scheme]</span>://<span class="hljs-comment">[host]</span>/<span class="hljs-comment">[path]</span>?<span class="hljs-comment">[query]</span>
scheme：表示协议名称
host：Schema所作用的地址域
path：Schema指定的路径
query：携带的参数</code></pre>
<p>拿百度搜索的URL来举例子：<a target="_blank" rel="noopener" href="https://www.baidu.com/s?wd=%E8%A6%81%E6%90%9C%E7%B4%A2%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97%E3%80%82%E8%BF%99%E4%B8%AAURL%E4%B8%8ESchema%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB%E5%A6%82%E4%B8%8B">https://www.baidu.com/s?wd=要搜索的关键字。这个URL与Schema协议的对应关系如下</a></p>
<blockquote>
<p>schema:：https<br>host： <a target="_blank" rel="noopener" href="http://www.baidu.com/">www.baidu.com</a><br>path： /s<br>query：wd=要搜索的关键字</p>
</blockquote>
<p>了解了Schema协议后，其实我们完全可以按照Schema协议的格式来自定义一个Schema链接，如下：</p>
<blockquote>
<p>myApp://<a target="_blank" rel="noopener" href="http://www.myapp.com/main/home?id=1">www.myApp.com/main/home?id=1</a></p>
<p>我们自己定义的Schema链接的对应关系为：<br> schema:：myApp<br>host：<a target="_blank" rel="noopener" href="http://www.myapp.com/">www.myApp.com</a><br>path：/main/home<br>query：id=1</p>
</blockquote>
<h2 id="2-通过Schema链接打开Activity"><a href="#2-通过Schema链接打开Activity" class="headerlink" title="2.通过Schema链接打开Activity"></a>2.通过Schema链接打开Activity</h2><p>通过浏览器打开App其实就是通过Schema链接来实现的。我们就以上一节中自定义的Schema链接为例来实现浏览器打开App。首先在项目中添加一个RouterActivity，RouterActivity在AndroidManifest中的配置如下：</p>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">activity</span></span>
<span class="hljs-tag">      <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;.activity.RouterActivity&quot;</span></span>
<span class="hljs-tag">      <span class="hljs-attr">android:configChanges</span>=<span class="hljs-string">&quot;orientation|keyboardHidden|screenSize&quot;</span></span>
<span class="hljs-tag">      <span class="hljs-attr">android:screenOrientation</span>=<span class="hljs-string">&quot;portrait&quot;</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">intent-filter</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">action</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.intent.action.VIEW&quot;</span> /&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">category</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.intent.category.DEFAULT&quot;</span> /&gt;</span>
           <span class="hljs-tag">&lt;<span class="hljs-name">category</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.intent.category.BROWSABLE&quot;</span> /&gt;</span>
           <span class="hljs-tag">&lt;<span class="hljs-name">data</span> <span class="hljs-attr">android:scheme</span>=<span class="hljs-string">&quot;myApp&quot;</span> /&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">intent-filter</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">activity</span>&gt;</span></code></pre>
<p>我们在AndroidManifest中为RouterActivity添加了schema，此时在HTML中写入以下代码：</p>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;myApp://www.myApp.com/main/home?id=1&quot;</span>&gt;</span>打开APP<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></code></pre>
<p>通过点击HTML页面的”打开App”便可启动RouterActivity。并且RouterActivity启动后可以通过Intent获取到启动的URI。代码如下：</p>
<pre><code class="hljs reasonml">  #RouterActivity
 
@Override
   protected void on<span class="hljs-constructor">Create(Bundle <span class="hljs-params">data</span>)</span> &#123;
       super.on<span class="hljs-constructor">Create(<span class="hljs-params">data</span>)</span>;
       Uri launchUri = get<span class="hljs-constructor">Intent()</span>.get<span class="hljs-constructor">Data()</span>;
       dispatch<span class="hljs-constructor">RouterUri(<span class="hljs-params">launchUri</span>)</span>;
   &#125;</code></pre>
<p>至此，我们已经可以通过App来打开项目的RouterActivity。</p>
<h2 id="3-通过路由跳转到目的页面"><a href="#3-通过路由跳转到目的页面" class="headerlink" title="3.通过路由跳转到目的页面"></a>3.通过路由跳转到目的页面</h2><p>上一节中我们通过HTML打开了RouterActivity，并在RouterActivity中拿到了跳转的URI，那么接下来我们便可以根据URI的信息打开对应的页面了。但是在开启路由跳转之前为了保险起见需要对URI进行一些校验。详细代码如下：</p>
<pre><code class="hljs reasonml"><span class="hljs-keyword">private</span> void dispatch<span class="hljs-constructor">RouterUri(Uri <span class="hljs-params">launchUri</span>)</span> &#123;
        <span class="hljs-keyword">if</span>(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">RoutingTable</span>.</span></span>is<span class="hljs-constructor">ValidRouterUri(<span class="hljs-params">launchUri</span>)</span>) &#123;  <span class="hljs-comment">//	判断是否是合法的URI，这里只有URI携带了Path才算合法</span>
            <span class="hljs-keyword">if</span>(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">App</span>.</span></span>is<span class="hljs-constructor">RootActivityLaunched()</span>) &#123; <span class="hljs-comment">// app已启动</span>
                <span class="hljs-keyword">if</span>(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">RoutingTable</span>.</span></span>is<span class="hljs-constructor">WxUri(<span class="hljs-params">launchUri</span>)</span>) &#123; <span class="hljs-comment">//	如果是微信的URI那么目的地是要跳转到小程序的（此处为项目中的需求）</span>
                    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">RoutingTable</span>.</span></span><span class="hljs-keyword">open</span><span class="hljs-constructor">MiniProgram(<span class="hljs-params">this</span>, <span class="hljs-params">launchUri</span>)</span>;
                    finish<span class="hljs-literal">()</span>;
                    return;
                &#125;
                <span class="hljs-comment">//	通过ARouter路由到目的页面</span>
               <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ARouter</span>.</span></span>get<span class="hljs-constructor">Instance()</span>.build(launchUri).navigation<span class="hljs-literal">()</span>;
            &#125; <span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">// app未启动, 保存router uri, 幷尝试启动app</span>
               <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">SharedPreferUtil</span>.</span></span>put(Constants.ROUTER_URI, launchUri.<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span>);
               launch<span class="hljs-constructor">App()</span>;
            &#125;
        &#125; <span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">//	 走到此处可能是因为URI没有携带Path，即并非要跳转目的页面，而是要启动APP  。因此直接启动App即可</span>
            launch<span class="hljs-constructor">App()</span>;
        &#125;
        finish<span class="hljs-literal">()</span>;
    &#125;</code></pre>
<p>上面代码中，我们对URI做了一系列校验，根据不同的URI做不同的处理。同时我们应该也注意到了，如果APP已经启动了，那么就可以直接跳转对应的页面了，而如果App没有启动，那么则是先将URI保存到了SharedPreference中，接着启动了App。那么此时App启动后会在MainActivity中读取SharedPreference中的配置，如果读取到URI的信息，那么就先将此数据从SharedPreference中移除，然后通过ARouter跳转到URI指定的页面去。MainActivity中的部分代码如下：</p>
<pre><code class="hljs csharp"><span class="hljs-meta">#MainActivity</span>

<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">resumeRoute</span>(<span class="hljs-params"></span>)</span> &#123;
        <span class="hljs-comment">// Continue for interrupted router uri</span>
        String interruptedLaunchUriString =
                Configuration.<span class="hljs-keyword">get</span>(Constants.INTERRUPTED_ROUTER_URI, <span class="hljs-literal">null</span>);
         <span class="hljs-comment">//	移除SharedPreference中的URI，避免下次打开MainActivity错误跳转</span>
        SharedPreferUtil.<span class="hljs-keyword">remove</span>(Constants.ROUTER_URI);
        Uri launchUri = <span class="hljs-literal">null</span>;
        <span class="hljs-keyword">if</span>(interruptedLaunchUriString != <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// Activity未启动的情况下 通过外部Scheme跳转非MainActivity</span>
            launchUri = Uri.parse(interruptedLaunchUriString);
        &#125;

        <span class="hljs-keyword">if</span>(launchUri == <span class="hljs-literal">null</span>) &#123;
            <span class="hljs-keyword">return</span>;
        &#125;
		<span class="hljs-comment">//	通过路由跳转到URI对应的页面</span>
        ARouter.getInstance().build(launchUri).navigation();
    &#125;</code></pre>
<p>关于ARouter的路由方案所涉及的内容至此已经全部讲完了。</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Arouter/">Arouter</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！ <h5>开源库推荐</h5> <a target="_blank" rel="noopener" href="https://github.com/zhpanvip/BannerViewPager">1.BannerViewPager</a> <p> 一个基于ViewPager2实现的具有强大功能的无限轮播库。支持多种页面切换效果和指示器样式。 </p>
<a target="_blank" rel="noopener" href="https://github.com/zhpanvip/viewpagerindicator">2.ViewPagerIndicator</a> <p> 一个适用于ViewPager和ViewPager2的指示器，支持多种滑块样式及滑动模式 </p></p>
              
              
                <div class="post-prevnext row">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2018/08/25/16.Java%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3%E5%9C%A8Android%E4%B8%AD%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%BA%94%E7%94%A8/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Java自定义注解在Android中的实例应用</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2018/07/14/14.%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B9%8B%E5%BC%B9%E6%80%A7%E6%BB%91%E5%8A%A8%E7%9A%84LockView/">
                        <span class="hidden-mobile">自定义View之弹性滑动的LockView</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments">
                
                
  <div id="vcomments"></div>
  <script type="text/javascript">
    function loadValine() {
      addScript('https://cdn.staticfile.org/valine/1.4.14/Valine.min.js', function () {
        new Valine({
          el: "#vcomments",
          app_id: "hXIROaIM5y9qnieojJRWP5hS",
          app_key: "y0f3w3aqd1MF7JL9ma4WECTy",
          placeholder: "说点什么",
          path: window.location.pathname,
          avatar: "retro",
          meta: ["nick","mail","link"],
          pageSize: "10",
          lang: "zh-CN",
          highlight: false,
          recordIP: false,
          serverURLs: "https://zhangpan.site",
        });
      });
    }
    waitElementVisible('vcomments', loadValine);
  </script>
  <noscript>Please enable JavaScript to view the <a target="_blank" href="https://valine.js.org" rel="nofollow noopener noopener">comments
      powered by Valine.</a></noscript>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener">
        <span>Fluid</span></a>
    </div>
    

    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/main.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>







  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: '#post-body',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "基于Arouter的路由实现方案&nbsp;",
      ],
      cursorChar: "|",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>




















</body>
</html>
