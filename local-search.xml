<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>自定义View之弹性滑动的LockView</title>
    <link href="/2018/07/14/%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B9%8B%E5%BC%B9%E6%80%A7%E6%BB%91%E5%8A%A8%E7%9A%84LockView/"/>
    <url>/2018/07/14/%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B9%8B%E5%BC%B9%E6%80%A7%E6%BB%91%E5%8A%A8%E7%9A%84LockView/</url>
    
    <content type="html"><![CDATA[<p><strong><em>本文已发表在<a href="https://juejin.im/post/5d465e18518825219c280e5c">掘金</a>，转载请注明出处。</em></strong></p><p>本篇文章我们来实现一个带有弹性滑动效果的自定义View。当然，文章的侧重点是自定义View但也会涉及到View的事件分发以及一些其他方面的知识，例如使用Scroller实现带有阻尼效果的弹性滑动。因此，我相信看完这篇文章你不仅能学到自定义View的相关知识，还会了解到View的事件分发！还是老规矩，看下最终实现效果。<br><img src="https://raw.githubusercontent.com/zhpanvip/Resource/master/image/1401.gif"></p><p> 分析图中效果会发现其核心功能类似于一个简单的下拉刷新、上拉加载的框架，但又有区别。开始前还是先来罗列一下几个核心步骤，如下：<br>      一. 明确需求，确定对外开放的接口<br>      二. 分析滑动效果，初步实现控件布局<br>      三. 关于滑动，不得不说的事件分发<br>      四. 实现自定义CircleWaveView</p><h2 id="一-明确需求，确定对外开放接口"><a href="#一-明确需求，确定对外开放接口" class="headerlink" title="一. 明确需求，确定对外开放接口"></a>一. 明确需求，确定对外开放接口</h2><p>首先应该明确控件的需求，确定有哪些功能，然后做针对性开发。这里先贴出该控件的使用方法，也是为了更好地认识控件的需求。<br><strong>1.布局文件添加</strong></p><pre><code class="hljs vim">&lt;RelativeLayout xmln<span class="hljs-variable">s:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span>    xmln<span class="hljs-variable">s:tools</span>=<span class="hljs-string">&quot;http://schemas.android.com/tools&quot;</span>    android:layout_width=<span class="hljs-string">&quot;match_parent&quot;</span>    android:layout_height=<span class="hljs-string">&quot;match_parent&quot;</span>    tool<span class="hljs-variable">s:context</span>=<span class="hljs-string">&quot;.MainActivity&quot;</span>&gt;    &lt;<span class="hljs-keyword">com</span>.zhpan.lockview.<span class="hljs-keyword">view</span>.LockView        android:id=<span class="hljs-string">&quot;@+id/lock_view&quot;</span>        android:layout_width=<span class="hljs-string">&quot;wrap_content&quot;</span>        android:layout_height=<span class="hljs-string">&quot;wrap_content&quot;</span>        android:layout_centerInParent=<span class="hljs-string">&quot;true&quot;</span> /&gt;&lt;/RelativeLayout&gt;</code></pre><p><strong>2.设置操作的监听事件。</strong>代码如下：</p><pre><code class="hljs less"><span class="hljs-selector-tag">mLockView</span><span class="hljs-selector-class">.setOnLockOperateListener</span>(new OnLockOperateListener() &#123;     <span class="hljs-variable">@Override</span>     public void onLockPrepared() &#123;<span class="hljs-comment">//  上锁就绪</span>              &#125;     <span class="hljs-variable">@Override</span>     public void onUnLockPrepared() &#123;<span class="hljs-comment">//  开锁就绪</span>     &#125;     <span class="hljs-variable">@Override</span>     public void onLockStart() &#123;<span class="hljs-comment">// 开始上锁</span>     &#125;     <span class="hljs-variable">@Override</span>     public void onUnlockStart() &#123;<span class="hljs-comment">// 开始开锁</span>     &#125;     <span class="hljs-variable">@Override</span>     public void onNotPrepared() &#123;<span class="hljs-comment">// 上下滑动距离未达到就绪状态</span>     &#125; &#125;);</code></pre><p><strong>3.对外开放接口</strong></p><pre><code class="hljs reasonml"><span class="hljs-comment">// 设置蓝牙是否连接</span>mLockView.set<span class="hljs-constructor">BluetoothConnect(<span class="hljs-params">false</span>)</span>;<span class="hljs-comment">// 设置上锁状态</span>mLockView.set<span class="hljs-constructor">LockState(<span class="hljs-params">isLock</span>)</span>;<span class="hljs-comment">// 设置View是否可以滑动</span>mLockView.set<span class="hljs-constructor">CanSlide(<span class="hljs-params">true</span>)</span><span class="hljs-comment">// 设置滑动阻尼大小</span>mLockView.set<span class="hljs-constructor">Damping(1.7)</span><span class="hljs-comment">// 设置View中心文字</span>mLockView.set<span class="hljs-constructor">Text(<span class="hljs-string">&quot;已上锁&quot;</span>)</span>;<span class="hljs-comment">// 设置中心大圆的颜色</span>mLockView.setCircleColor<span class="hljs-comment">// 开启心跳动画</span>mLockView.start<span class="hljs-constructor">Wave()</span>;<span class="hljs-comment">// 停止心跳动画</span>mLockView.stop<span class="hljs-constructor">Wave()</span>;<span class="hljs-comment">// 是否正在搜索/连接蓝牙</span>mLockView.connecting(<span class="hljs-literal">true</span>);<span class="hljs-comment">// 点击事件监听（只有在未连接蓝牙时有效）</span>mLockView.set<span class="hljs-constructor">OnClickListener(<span class="hljs-params">new</span> View.OnClickListener()</span> &#123;         @Override         public void on<span class="hljs-constructor">Click(View <span class="hljs-params">v</span>)</span> &#123;                      &#125;     &#125;);</code></pre><p>我们来总结下控件中需要实现的功能：</p><ol><li>控件布局的实现。</li><li>蓝牙未连接时，只能点击而不能滑动。</li><li>点击事件以及连接中动画。</li><li>更改连接状态。</li><li>实现上下弹性滑动，且需要控制滑动边界。</li><li>滑动事件回掉。</li><li>心跳动画实现。</li></ol><p>以上几点就是我们要完成的核心功能，有了需求之后就直接进入主题来实现我们想要的效果吧。</p><h2 id="二、分析控件，初步实现控件布局"><a href="#二、分析控件，初步实现控件布局" class="headerlink" title="二、分析控件，初步实现控件布局"></a>二、分析控件，初步实现控件布局</h2><p>分析上图的效果发现，中间的View是可滑动的，且覆盖在上下小圆点的上面。对于这种效果直接继承View实现起来会不太方便。因此我们可以想到利用自定义ViewGroup来布局页面。这么一来使开发简单了许多。那么接下来先新建一个layout_oval_lock.xml的布局为文件，并采用FrameLayout来布局控件，这样就实现了层次叠加效果，FrameLayout内部是两个自定义View，我们可以暂且搁置不管，后面会讲到如何实现。布局文件如下：</p><pre><code class="hljs stylus">&lt;FrameLayout xmlns:android=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span>    android:layout_width=<span class="hljs-string">&quot;match_parent&quot;</span>    android:layout_height=<span class="hljs-string">&quot;match_parent&quot;</span>    xmlns:app=<span class="hljs-string">&quot;http://schemas.android.com/apk/res-auto&quot;</span>    android:orientation=<span class="hljs-string">&quot;vertical&quot;</span>&gt;    &lt;com<span class="hljs-selector-class">.zhpan</span><span class="hljs-selector-class">.lockview</span><span class="hljs-selector-class">.view</span>.CircleView        android:id=<span class="hljs-string">&quot;@+id/green_cv&quot;</span>        android:layout_width=<span class="hljs-string">&quot;15dp&quot;</span>        android:layout_height=<span class="hljs-string">&quot;15dp&quot;</span>        android:layout_marginTop=<span class="hljs-string">&quot;110dp&quot;</span>        app:circle_color=<span class="hljs-string">&quot;@color/green&quot;</span>        android:layout_gravity=<span class="hljs-string">&quot;center&quot;</span>/&gt;    &lt;com<span class="hljs-selector-class">.zhpan</span><span class="hljs-selector-class">.lockview</span><span class="hljs-selector-class">.view</span>.CircleView        android:id=<span class="hljs-string">&quot;@+id/red_cv&quot;</span>        android:layout_width=<span class="hljs-string">&quot;15dp&quot;</span>        android:layout_height=<span class="hljs-string">&quot;15dp&quot;</span>        app:circle_color=<span class="hljs-string">&quot;@color/red&quot;</span>        android:layout_marginTop=<span class="hljs-string">&quot;-110dp&quot;</span>        android:layout_gravity=<span class="hljs-string">&quot;center&quot;</span>/&gt;    &lt;com<span class="hljs-selector-class">.zhpan</span><span class="hljs-selector-class">.lockview</span><span class="hljs-selector-class">.view</span>.CircleWaveView        android:id=<span class="hljs-string">&quot;@+id/circle_wave_view&quot;</span>        android:layout_width=<span class="hljs-string">&quot;220dp&quot;</span>        android:layout_height=<span class="hljs-string">&quot;300dp&quot;</span>        android:layout_gravity=<span class="hljs-string">&quot;center&quot;</span>        android:<span class="hljs-attribute">padding</span>=<span class="hljs-string">&quot;20dp&quot;</span>/&gt;    &lt;ProgressBar        android:id=<span class="hljs-string">&quot;@+id/progress&quot;</span>        android:layout_width=<span class="hljs-string">&quot;30dp&quot;</span>        android:layout_height=<span class="hljs-string">&quot;30dp&quot;</span>        android:<span class="hljs-attribute">visibility</span>=<span class="hljs-string">&quot;gone&quot;</span>        android:indeterminateTint=<span class="hljs-string">&quot;@color/white&quot;</span>        android:layout_gravity=<span class="hljs-string">&quot;center&quot;</span>/&gt;&lt;/FrameLayout&gt;</code></pre><p>接下来新建一个LockView类并继承FrameLayout。LockView与 上边layout_oval_lock的布局文件关联，并重写相应的方法。代码如下：</p><pre><code class="hljs reasonml">public <span class="hljs-constructor">LockView(Context <span class="hljs-params">context</span>)</span> &#123;        this(context, null);    &#125;    public <span class="hljs-constructor">LockView(Context <span class="hljs-params">context</span>, AttributeSet <span class="hljs-params">attrs</span>)</span> &#123;        this(context, attrs, <span class="hljs-number">0</span>);    &#125;    public <span class="hljs-constructor">LockView(Context <span class="hljs-params">context</span>, AttributeSet <span class="hljs-params">attrs</span>, <span class="hljs-params">int</span> <span class="hljs-params">defStyleAttr</span>)</span> &#123;        super(context, attrs, defStyleAttr);        init(context, attrs);    &#125;    <span class="hljs-keyword">private</span> void init(Context context, AttributeSet attrs) &#123;        mTouchSlop = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ViewConfiguration</span>.</span></span>get(context).get<span class="hljs-constructor">ScaledTouchSlop()</span>;        View view = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">View</span>.</span></span>inflate(context, <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">R</span>.</span></span>layout.layout_oval_lock, this);        mCircleWaveView = (CircleWaveView) view.find<span class="hljs-constructor">ViewById(R.<span class="hljs-params">id</span>.<span class="hljs-params">circle_wave_view</span>)</span>;        mCircleView = (CircleView) view.find<span class="hljs-constructor">ViewById(R.<span class="hljs-params">id</span>.<span class="hljs-params">green_cv</span>)</span>;        distance = ((LayoutParams) mCircleView.get<span class="hljs-constructor">LayoutParams()</span>).topMargin;        mProgressBar = (ProgressBar) view.find<span class="hljs-constructor">ViewById(R.<span class="hljs-params">id</span>.<span class="hljs-params">progress</span>)</span>;        mScroller = mCircleWaveView.get<span class="hljs-constructor">Scroller()</span>;        mContext = context;        mCircleWaveView.set<span class="hljs-constructor">OnClickListener(<span class="hljs-params">new</span> OnClickListener()</span> &#123;            @Override            public void on<span class="hljs-constructor">Click(View <span class="hljs-params">v</span>)</span> &#123;            &#125;        &#125;);    &#125;    @Override    protected void on<span class="hljs-constructor">Layout(<span class="hljs-params">boolean</span> <span class="hljs-params">changed</span>, <span class="hljs-params">int</span> <span class="hljs-params">l</span>, <span class="hljs-params">int</span> <span class="hljs-params">t</span>, <span class="hljs-params">int</span> <span class="hljs-params">r</span>, <span class="hljs-params">int</span> <span class="hljs-params">b</span>)</span> &#123;        View view = get<span class="hljs-constructor">ChildAt(0)</span>;        view.layout(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, get<span class="hljs-constructor">MeasuredWidth()</span>, get<span class="hljs-constructor">MeasuredHeight()</span>);    &#125;    @Override    protected void on<span class="hljs-constructor">SizeChanged(<span class="hljs-params">int</span> <span class="hljs-params">w</span>, <span class="hljs-params">int</span> <span class="hljs-params">h</span>, <span class="hljs-params">int</span> <span class="hljs-params">oldw</span>, <span class="hljs-params">int</span> <span class="hljs-params">oldh</span>)</span> &#123;        super.on<span class="hljs-constructor">SizeChanged(<span class="hljs-params">w</span>, <span class="hljs-params">h</span>, <span class="hljs-params">oldw</span>, <span class="hljs-params">oldh</span>)</span>;    &#125;</code></pre><h2 id="三-关于滑动，不得不说的事件分发"><a href="#三-关于滑动，不得不说的事件分发" class="headerlink" title="三.关于滑动，不得不说的事件分发"></a>三.关于滑动，不得不说的事件分发</h2><p>接下来就要来处理中心View的滑动了！说到滑动，避免不了的就应该想到Android中View的事件分发，那么对于滑动事件的处理我们需要重写三个方法。我想很多小伙伴肯定已经想到了！没错，就是事件分发的三个核心方法：dispatchTouchEvent、onInterceptTouchEvent、以及onTouchEvent。我觉得还是先简单来了解一下这三个方法吧，因为它确实挺重要的。</p><ul><li><strong><em>dispatchTouchEvent</em></strong>   顾名思义，这个方法就是用来对事件进行分发的。如果事件传递到了当前View，那么这个方法一定会被调用。它的返回结果受当前View的onTouchEvent或下级View的dispatchTouchEvent方法的影响，表示是否消费当前事件。</li><li><strong><em>onInterceptTouchEvent</em></strong>  这个方法在dispatchTouchEvent方法的内部被调用，用来表示是否拦截某个事件。返回结果表示是否拦截当前事件。需要注意的是View并没有该方法，这个方法仅仅存在于ViewGroup中！如果事件传递到View中，那么会直接调用该View的onTouchEvent方法。</li><li><strong><em>onTouchEvent</em></strong>  这个方法在dispatchTouchEvent方法中调用。用来处理点击事件。返回结果表示是否消费当前事件。View中的onTouchEvent方法默认会消费事件，只有当设置clickable和longClickable为false时则不会消费该事件。</li></ul><p><strong>首先来看LockView中重写的dispatchTouchEvent方法中的代码</strong>：</p><pre><code class="hljs aspectj"><span class="hljs-meta">@Override</span><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">dispatchTouchEvent</span><span class="hljs-params">(MotionEvent ev)</span> </span>&#123;    <span class="hljs-keyword">if</span> (!canSlide)        <span class="hljs-keyword">switch</span> (ev.getAction()) &#123;            <span class="hljs-keyword">case</span> ACTION_DOWN:                timestamp = System.currentTimeMillis();                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> ACTION_UP:                <span class="hljs-keyword">if</span> (System.currentTimeMillis() - timestamp &lt; 500) &#123;                    performClick();                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;                &#125;                <span class="hljs-keyword">break</span>;        &#125;    <span class="hljs-function"><span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.<span class="hljs-title">dispatchTouchEvent</span><span class="hljs-params">(ev)</span></span>;&#125;</code></pre><p>上面提到，只要有事件传递到当前的ViewGroup那么dispatchTouchEvent就会首先被调用！因此在这个方法里先来判断当前是否是可以滑动状态（蓝牙未连接时不可滑动）。如果不可以滑动，那么就去处理点击事件，我们认为ACTION_DOWN和ACTION_UP之间间隔小于500毫秒就是一次点击事件，那么就在此处调用performClick方法并消费掉当前事件，如果间隔大于500毫秒，不认为是点击事件，那么紧接着就去调用父类的dispatchTouchEvent方法。如果当前可以滑动，那么同样调用父类的dispatchTouchEvent方法来处理。</p><p><strong>接下来我们看重写的onInterceptTouchEvent方法</strong></p><pre><code class="hljs angelscript">@Override<span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span>ean onInterceptTouchEvent(MotionEvent ev) &#123;        <span class="hljs-built_in">bool</span>ean <span class="hljs-built_in">int</span>ercepted = <span class="hljs-literal">true</span>;        <span class="hljs-built_in">int</span> y = (<span class="hljs-built_in">int</span>) ev.getY();        <span class="hljs-keyword">switch</span> (ev.getAction()) &#123;            <span class="hljs-keyword">case</span> ACTION_DOWN:                <span class="hljs-built_in">int</span>ercepted = <span class="hljs-literal">false</span>;                <span class="hljs-keyword">if</span> (!mScroller.isFinished()) &#123;                    mScroller.abortAnimation();                &#125;                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> MotionEvent.ACTION_MOVE:                <span class="hljs-keyword">if</span> (Math.abs(y - mLastY) &gt; mTouchSlop) &#123;                    <span class="hljs-built_in">int</span>ercepted = <span class="hljs-literal">true</span>;                &#125;                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> MotionEvent.ACTION_UP:                <span class="hljs-built_in">int</span>ercepted = <span class="hljs-literal">false</span>;                <span class="hljs-keyword">break</span>;        &#125;        mLastY = y;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">int</span>ercepted;    &#125;</code></pre><p>在这个方法中我们重点来看ACTION_MOVE的时候，在这里先判断了滑动的距离是否大于mTouchSlop，这个值是认为滑动的最小距离，当大于这个值的时候就认为是滑动了。那么看此时intercepted返回了true，表示要拦截这个事件！此处拦截了这个滑动事件会怎么样呢？答案是当前View中的onTouchEvent方法被调用了！现在请将我们的目光聚焦到onTouchEvent方法中，注意前方高能！</p><p><strong>核心中最核心的onTouchEvent方法</strong></p><pre><code class="hljs reasonml">        @Override    public boolean on<span class="hljs-constructor">TouchEvent(MotionEvent <span class="hljs-params">event</span>)</span> &#123;        <span class="hljs-built_in">int</span> y = (<span class="hljs-built_in">int</span>) event.get<span class="hljs-constructor">Y()</span>;        <span class="hljs-built_in">int</span> scrollY = mCircleWaveView.get<span class="hljs-constructor">ScrollY()</span>;        switch (event.get<span class="hljs-constructor">Action()</span>) &#123;            case ACTION_DOWN:                <span class="hljs-keyword">if</span> (!mScroller.is<span class="hljs-constructor">Finished()</span>) &#123;                    mScroller.abort<span class="hljs-constructor">Animation()</span>;                &#125;                break;            case MotionEvent.ACTION_MOVE:                <span class="hljs-keyword">if</span> (!canSlide) &#123;                    return super.on<span class="hljs-constructor">TouchEvent(<span class="hljs-params">event</span>)</span>;                &#125;                <span class="hljs-built_in">int</span> deltaY = (<span class="hljs-built_in">int</span>) ((mLastY - y)<span class="hljs-operator"> / </span>damping);                <span class="hljs-keyword">if</span> (mCircleWaveView.get<span class="hljs-constructor">ScrollY()</span> &gt; mTouchSlop) &#123;                    mOption = Option.LOCK;                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mCircleWaveView.get<span class="hljs-constructor">ScrollY()</span> &lt; -mTouchSlop) &#123;                    mOption = Option.UNLOCK;                &#125;                <span class="hljs-keyword">if</span> (<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>abs(scrollY) &gt; (distance - mCircleWaveView.get<span class="hljs-constructor">Radius()</span> + mCircleView.get<span class="hljs-constructor">Radius()</span>)) &#123;                    <span class="hljs-keyword">if</span> (mOption != null) &#123;                        switch (mOption) &#123;                            case LOCK:                                <span class="hljs-keyword">if</span> (mOnLockOperateListener != null)                                    mOnLockOperateListener.on<span class="hljs-constructor">LockPrepared()</span>;                                mCircleWaveView.set<span class="hljs-constructor">LockPrepared(<span class="hljs-params">true</span>)</span>;                                break;                            case UNLOCK:                                <span class="hljs-keyword">if</span> (mOnLockOperateListener != null)                                    mOnLockOperateListener.on<span class="hljs-constructor">UnLockPrepared()</span>;                                mCircleWaveView.set<span class="hljs-constructor">UnLockPrePared(<span class="hljs-params">true</span>)</span>;                                break;                        &#125;                    &#125;                &#125; <span class="hljs-keyword">else</span> &#123;                    mCircleWaveView.set<span class="hljs-constructor">UnLockPrePared(<span class="hljs-params">false</span>)</span>;                    mCircleWaveView.set<span class="hljs-constructor">LockPrepared(<span class="hljs-params">false</span>)</span>;                    mOnLockOperateListener.on<span class="hljs-constructor">NotPrepared()</span>;                   <span class="hljs-comment">/* if (isLock()) &#123;</span><span class="hljs-comment">                        mCircleWaveView.setText(mContext.getResources().getString(R.string.device_control_unlock));</span><span class="hljs-comment">                    &#125; else &#123;</span><span class="hljs-comment">                        mCircleWaveView.setText(mContext.getResources().getString(R.string.device_control_lock));</span><span class="hljs-comment">                    &#125;*/</span><span class="hljs-comment">//                    isOperating = false;</span>                &#125;                <span class="hljs-comment">/**</span><span class="hljs-comment">                 * 控制滑动边界</span><span class="hljs-comment">                 */</span>                <span class="hljs-built_in">int</span> border = (distance - mCircleWaveView.get<span class="hljs-constructor">Radius()</span> + mCircleView.get<span class="hljs-constructor">Radius()</span>) +                        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">DensityUtils</span>.</span></span>dp2px(mContext, <span class="hljs-number">25</span>);<span class="hljs-comment">//  可上下滑动的最大距离</span>                <span class="hljs-comment">//  当前上下滑动的距离</span>                <span class="hljs-built_in">int</span> slideHeight = deltaY + mCircleWaveView.get<span class="hljs-constructor">ScrollY()</span>;                <span class="hljs-keyword">if</span> (slideHeight &gt; border) &#123;                    mCircleWaveView.scroll<span class="hljs-constructor">To(0, <span class="hljs-params">border</span>)</span>;                    return <span class="hljs-literal">true</span>;                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (slideHeight + border &lt; <span class="hljs-number">0</span>) &#123;                    mCircleWaveView.scroll<span class="hljs-constructor">To(0, -<span class="hljs-params">border</span>)</span>;                    return <span class="hljs-literal">true</span>;                &#125;                mCircleWaveView.scroll<span class="hljs-constructor">By(0, <span class="hljs-params">deltaY</span>)</span>;                break;            case MotionEvent.ACTION_UP:                mCircleWaveView.set<span class="hljs-constructor">UnLockPrePared(<span class="hljs-params">false</span>)</span>;                mCircleWaveView.set<span class="hljs-constructor">LockPrepared(<span class="hljs-params">false</span>)</span>;                scrollY = mCircleWaveView.get<span class="hljs-constructor">ScrollY()</span>;                <span class="hljs-keyword">if</span> (<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>abs(scrollY) &gt; (distance - mCircleWaveView.get<span class="hljs-constructor">Radius()</span> + mCircleView.get<span class="hljs-constructor">Radius()</span>)<span class="hljs-operator"> &amp;&amp; </span>mOption != null) &#123;                    switch (mOption) &#123;                        case LOCK:                            <span class="hljs-keyword">if</span> (mOnLockOperateListener != null)                                mOnLockOperateListener.on<span class="hljs-constructor">LockStart()</span>;                            break;                        case UNLOCK:                            <span class="hljs-keyword">if</span> (mOnLockOperateListener != null)                                mOnLockOperateListener.on<span class="hljs-constructor">UnlockStart()</span>;                            break;                    &#125;                &#125;                mCircleWaveView.smooth<span class="hljs-constructor">Scroll(0, 0)</span>;                break;        &#125;        mLastY = y;        return super.on<span class="hljs-constructor">TouchEvent(<span class="hljs-params">event</span>)</span>;    &#125;</code></pre><p>看到这个方法中这么多代码不知道各位是否已经懵逼？（好吧，我承认，这地方代码写的确实比较乱）不过没关系，其实细细分析来还是不难理解的！同样，我们选择比较重要的点来看。首先来看ACTION_MOVE的时候，在这里先判断了是否可以滑动（其实不可以滑动的情况下应该不会走到这个方法，但是为了严谨还是加了判断），如果不能滑动则下边的逻辑全都不会再走了。接下来<br>通过判断滑动的方向来确定是要开锁还是上锁，并根据滑动距离来给出回调处理。即当中心圆CircleWaveView向上或向下滑动并完全覆盖到上/下的小圆点时则会回掉上锁就绪或者开锁就绪（onLockPrepared、onUnLockPrepared）的方法。此时释放CircleWaveView，则会回调开锁或者上锁（onLockStart、onUnlockStart）的方法。如果CircleWaveView在完全覆盖到上/下的小圆点的状态下，再向反方向滑动至未完全覆盖小圆点，此时则会回掉未就绪（onNotPrepared）的方法。下边贴一下回调接口，一共五个方法，如下：</p><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span>  <span class="hljs-title">OnLockOperateListener</span> &#123;   <span class="hljs-comment">// 上锁就绪</span>   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onLockPrepared</span>(<span class="hljs-params"></span>)</span>;   <span class="hljs-comment">// 开锁就绪</span>   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onUnLockPrepared</span>(<span class="hljs-params"></span>)</span>;   <span class="hljs-comment">// 开始上锁</span>   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onLockStart</span>(<span class="hljs-params"></span>)</span>;   <span class="hljs-comment">// 开始开锁</span>   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onUnlockStart</span>(<span class="hljs-params"></span>)</span>;   <span class="hljs-comment">// 未就绪</span>   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onNotPrepared</span>(<span class="hljs-params"></span>)</span>;&#125;</code></pre><p>接下来是通过一系列计算来控制CircleWaveView的滑动边界。思路大致如此：首先根据CircleWaveView和上下小圆的位置来计算出可上下滑动的最大距离border。然后计算当CircleWaveView滑动的距离超过border时就强制将其滚动到border位置，已达到固定的效果。代码如下：</p><pre><code class="hljs reasonml"><span class="hljs-comment">/**</span><span class="hljs-comment">     * 控制滑动边界</span><span class="hljs-comment">     */</span>   <span class="hljs-built_in">int</span> border = (distance - mCircleWaveView.get<span class="hljs-constructor">Radius()</span> + mCircleView.get<span class="hljs-constructor">Radius()</span>) +                       <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">DensityUtils</span>.</span></span>dp2px(mContext, <span class="hljs-number">25</span>);<span class="hljs-comment">//  可上下滑动的最大距离</span>   <span class="hljs-built_in">int</span> deltaY = (<span class="hljs-built_in">int</span>) ((mLastY - y)<span class="hljs-operator"> / </span>damping);   <span class="hljs-comment">//  当前上下滑动的距离</span>   <span class="hljs-built_in">int</span> slideHeight = deltaY + mCircleWaveView.get<span class="hljs-constructor">ScrollY()</span>;   <span class="hljs-keyword">if</span> (slideHeight &gt; border) &#123;        mCircleWaveView.scroll<span class="hljs-constructor">To(0, <span class="hljs-params">border</span>)</span>;        return <span class="hljs-literal">true</span>;       &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (slideHeight + border &lt; <span class="hljs-number">0</span>) &#123;         mCircleWaveView.scroll<span class="hljs-constructor">To(0, -<span class="hljs-params">border</span>)</span>;         return <span class="hljs-literal">true</span>;       &#125;   mCircleWaveView.scroll<span class="hljs-constructor">By(0, <span class="hljs-params">deltaY</span>)</span>;</code></pre><p>然后是实现CircleWaveView的弹性滑动，这里我们给CircleWaveView加了一个弹性滑动和阻尼效果。弹性滑动是在CircleWaveView中通过Scroller来实现的，CircleWaveView暴漏出来smoothScroll的弹性滑动接口供在LockView中调用。这点我们在后面讲解CircleWaveView时再说。而阻尼滑动则是将原滑动距离除以阻尼系数以减小滑动距离从而产生阻尼效果。<br>最后来看ACTION_UP，同样是根据Y轴滑动距离与滑动方向回掉对应的方法，并将CircleWaveView恢复到原位。代码如下：</p><pre><code class="hljs yaml"><span class="hljs-string">scrollY</span> <span class="hljs-string">=</span> <span class="hljs-string">mCircleWaveView.getScrollY();</span><span class="hljs-string">if</span> <span class="hljs-string">(Math.abs(scrollY)</span> <span class="hljs-string">&gt;</span> <span class="hljs-string">(distance</span> <span class="hljs-bullet">-</span> <span class="hljs-string">mCircleWaveView.getRadius()</span> <span class="hljs-string">+</span> <span class="hljs-string">mCircleView.getRadius())</span> <span class="hljs-string">&amp;&amp;</span> <span class="hljs-string">mOption</span> <span class="hljs-type">!=</span> <span class="hljs-literal">null</span><span class="hljs-string">)</span> &#123;   <span class="hljs-string">switch</span> <span class="hljs-string">(mOption)</span> &#123;         <span class="hljs-attr">case LOCK:</span>              <span class="hljs-string">if</span> <span class="hljs-string">(mOnLockOperateListener</span> <span class="hljs-type">!=</span> <span class="hljs-literal">null</span><span class="hljs-string">)</span>                   <span class="hljs-string">mOnLockOperateListener.onLockStart();</span>          <span class="hljs-string">break;</span>          <span class="hljs-attr">case UNLOCK:</span>              <span class="hljs-string">if</span> <span class="hljs-string">(mOnLockOperateListener</span> <span class="hljs-type">!=</span> <span class="hljs-literal">null</span><span class="hljs-string">)</span>                   <span class="hljs-string">mOnLockOperateListener.onUnlockStart();</span>          <span class="hljs-string">break;</span>    &#125;<span class="hljs-string">mCircleWaveView.smoothScroll(0</span>, <span class="hljs-number">0</span><span class="hljs-string">);</span></code></pre><h2 id="四-实现自定义CircleWaveView"><a href="#四-实现自定义CircleWaveView" class="headerlink" title="四. 实现自定义CircleWaveView"></a>四. 实现自定义CircleWaveView</h2><p>关于自定义CircleWaveView就不具体来讲了，因为关于自定义View都是一样的步骤。这里我们只选取几个重要的地方来说。1.CircleWaveView中内容的绘制。2.关于弹性滑动的实现。3.心跳动画的实现以及状态改变的扩散动画。</p><p><strong>1.CircleWaveView中内容的绘制。</strong></p><p><strong>绘制主体圆。</strong>主要分为几种情况：<br>a.蓝牙未连接，且未能获取到网络数据，背景色为灰色。<br>b.蓝牙未连接，且能获取到网络数据，背景色为淡绿色或淡红色。<br>c.蓝牙已连接，开锁状态为绿色，未开锁状态为红色。<br>d.上拉上锁就绪状态为深红色，下拉开锁就绪状态为深绿色。</p><p>结合以上需求有如下代码：</p><pre><code class="hljs reasonml"><span class="hljs-keyword">private</span> void draw<span class="hljs-constructor">Circle(Canvas <span class="hljs-params">canvas</span>)</span> &#123;        mPaint.set<span class="hljs-constructor">Color(<span class="hljs-params">circleColor</span>)</span>;        <span class="hljs-built_in">int</span> verticalCenter = get<span class="hljs-constructor">Height()</span><span class="hljs-operator"> / </span><span class="hljs-number">2</span>;        <span class="hljs-built_in">int</span> horizontalCenter = get<span class="hljs-constructor">Width()</span><span class="hljs-operator"> / </span><span class="hljs-number">2</span>;        <span class="hljs-built_in">int</span> mRadius = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>min(verticalCenter, horizontalCenter) - <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>min(verticalCenter, horizontalCenter)<span class="hljs-operator"> / </span><span class="hljs-number">5</span>;        radius = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>min(verticalCenter, horizontalCenter) - <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>min(verticalCenter, horizontalCenter)<span class="hljs-operator"> / </span><span class="hljs-number">5</span>;        <span class="hljs-keyword">if</span> (transforming) &#123;            mPaint.set<span class="hljs-constructor">Color(<span class="hljs-params">getResources</span>()</span>.get<span class="hljs-constructor">Color(R.<span class="hljs-params">color</span>.<span class="hljs-params">green</span>)</span>);            canvas.draw<span class="hljs-constructor">Circle(<span class="hljs-params">mPieCenterX</span>, <span class="hljs-params">mPieCenterY</span>, <span class="hljs-params">mRadius</span>, <span class="hljs-params">mPaint</span>)</span>;            mRadius = isLock ? transformDelta : mRadius - transformDelta;            mPaint.set<span class="hljs-constructor">Color(<span class="hljs-params">getResources</span>()</span>.get<span class="hljs-constructor">Color(R.<span class="hljs-params">color</span>.<span class="hljs-params">red</span>)</span>);            canvas.draw<span class="hljs-constructor">Circle(<span class="hljs-params">mPieCenterX</span>, <span class="hljs-params">mPieCenterY</span>, <span class="hljs-params">mRadius</span>, <span class="hljs-params">mPaint</span>)</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            mRadius = mRadius - waveDelta;            <span class="hljs-keyword">if</span> (!isBluetoothConnect) &#123;                <span class="hljs-keyword">if</span> (isNoNetData) &#123;                    mPaint.set<span class="hljs-constructor">Color(<span class="hljs-params">getColor</span>(R.<span class="hljs-params">color</span>.<span class="hljs-params">gray</span>)</span>);                &#125; <span class="hljs-keyword">else</span>                    mPaint.set<span class="hljs-constructor">Color(<span class="hljs-params">isLock</span> ? <span class="hljs-params">getColor</span>(R.<span class="hljs-params">color</span>.<span class="hljs-params">redLight</span>)</span> : get<span class="hljs-constructor">Color(R.<span class="hljs-params">color</span>.<span class="hljs-params">greenLight</span>)</span>);            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-keyword">if</span> (isLockPrepared) &#123;                    mPaint.set<span class="hljs-constructor">Color(<span class="hljs-params">getColor</span>(R.<span class="hljs-params">color</span>.<span class="hljs-params">redDark</span>)</span>);                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isUnLockPrePared) &#123;                    mPaint.set<span class="hljs-constructor">Color(<span class="hljs-params">getColor</span>(R.<span class="hljs-params">color</span>.<span class="hljs-params">greenDark</span>)</span>);                &#125; <span class="hljs-keyword">else</span> &#123;                    mPaint.set<span class="hljs-constructor">Color(<span class="hljs-params">isLock</span> ? <span class="hljs-params">getColor</span>(R.<span class="hljs-params">color</span>.<span class="hljs-params">red</span>)</span> : get<span class="hljs-constructor">Color(R.<span class="hljs-params">color</span>.<span class="hljs-params">green</span>)</span>);                &#125;            &#125;            canvas.draw<span class="hljs-constructor">Circle(<span class="hljs-params">mPieCenterX</span>, <span class="hljs-params">mPieCenterY</span>, <span class="hljs-params">mRadius</span>, <span class="hljs-params">mPaint</span>)</span>;        &#125;    &#125;</code></pre><p><strong>绘制CircleWaveView中上下箭头。</strong>  关于箭头绘制，注释部分是通过Path来绘制的，但是发现效果不太好，绘制三角形圆角比较麻烦，所以后台改为了直接在canvas上绘制Bitmap来实现。代码如下：</p><pre><code class="hljs yaml"><span class="hljs-string">//</span>  <span class="hljs-string">绘制圆中两个三角</span>    <span class="hljs-string">private</span> <span class="hljs-string">void</span> <span class="hljs-string">drawTriangle(Canvas</span> <span class="hljs-string">canvas)</span> &#123;        <span class="hljs-string">int</span> <span class="hljs-string">left</span> <span class="hljs-string">=</span> <span class="hljs-string">(mWidth</span> <span class="hljs-bullet">-</span> <span class="hljs-string">arrowUp.getWidth())</span> <span class="hljs-string">/</span> <span class="hljs-number">2</span><span class="hljs-string">;</span>        <span class="hljs-string">canvas.drawBitmap(arrowUp</span>, <span class="hljs-string">left</span>, <span class="hljs-string">mHeight</span> <span class="hljs-string">/</span> <span class="hljs-number">2</span> <span class="hljs-bullet">-</span> <span class="hljs-string">radius</span> <span class="hljs-string">+</span> <span class="hljs-string">dp13</span>, <span class="hljs-string">mPaint);</span>        <span class="hljs-string">canvas.drawBitmap(arrowDown</span>, <span class="hljs-string">left</span>, <span class="hljs-string">mHeight</span> <span class="hljs-string">/</span> <span class="hljs-number">2</span> <span class="hljs-string">+</span> <span class="hljs-string">radius</span> <span class="hljs-bullet">-</span> <span class="hljs-string">dp13</span> <span class="hljs-bullet">-</span> <span class="hljs-string">arrowDown.getHeight()</span>, <span class="hljs-string">mPaint);</span>        <span class="hljs-string">/*int</span> <span class="hljs-string">radius</span> <span class="hljs-string">=</span> <span class="hljs-string">Math.min(mHeight</span>, <span class="hljs-string">mWidth)</span> <span class="hljs-string">/</span> <span class="hljs-number">2</span> <span class="hljs-bullet">-</span> <span class="hljs-string">Math.min(mHeight</span>, <span class="hljs-string">mWidth)</span> <span class="hljs-string">/</span> <span class="hljs-number">8</span><span class="hljs-string">;</span>        <span class="hljs-string">mPaintTrangel.setStyle(Paint.Style.FILL);</span>        <span class="hljs-string">mPaintTrangel.setShadowLayer(4</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-string">Color.GRAY);</span>        <span class="hljs-string">//</span>  <span class="hljs-string">三角形顶点到圆边的距离</span>        <span class="hljs-string">int</span> <span class="hljs-string">h0</span> <span class="hljs-string">=</span> <span class="hljs-string">DensityUtils.dp2px(mContext</span>, <span class="hljs-number">10</span><span class="hljs-string">);</span>        <span class="hljs-string">//</span>  <span class="hljs-string">三角形高</span>        <span class="hljs-string">int</span> <span class="hljs-string">h1</span> <span class="hljs-string">=</span> <span class="hljs-string">DensityUtils.dp2px(mContext</span>, <span class="hljs-number">12</span><span class="hljs-string">);</span>        <span class="hljs-string">//</span>  <span class="hljs-string">三角形底边长</span>        <span class="hljs-string">int</span> <span class="hljs-string">w</span> <span class="hljs-string">=</span> <span class="hljs-string">DensityUtils.dp2px(mContext</span>, <span class="hljs-number">14</span><span class="hljs-string">);</span>        <span class="hljs-string">mPaintTrangel.setColor(getResources().getColor(R.color.transparent_33));</span>        <span class="hljs-string">mPath.moveTo(mWidth</span> <span class="hljs-string">/</span> <span class="hljs-number">2</span>, <span class="hljs-string">mHeight</span> <span class="hljs-string">/</span> <span class="hljs-number">2</span> <span class="hljs-bullet">-</span> <span class="hljs-string">(radius</span> <span class="hljs-bullet">-</span> <span class="hljs-string">h0));</span>        <span class="hljs-string">mPath.lineTo(mWidth</span> <span class="hljs-string">/</span> <span class="hljs-number">2</span> <span class="hljs-bullet">-</span> <span class="hljs-string">w</span>, <span class="hljs-string">mHeight</span> <span class="hljs-string">/</span> <span class="hljs-number">2</span> <span class="hljs-bullet">-</span> <span class="hljs-string">(radius</span> <span class="hljs-bullet">-</span> <span class="hljs-string">h1</span> <span class="hljs-bullet">-</span> <span class="hljs-string">h0));</span>        <span class="hljs-string">mPath.lineTo(mWidth</span> <span class="hljs-string">/</span> <span class="hljs-number">2</span> <span class="hljs-string">+</span> <span class="hljs-string">w</span>, <span class="hljs-string">mHeight</span> <span class="hljs-string">/</span> <span class="hljs-number">2</span> <span class="hljs-bullet">-</span> <span class="hljs-string">(radius</span> <span class="hljs-bullet">-</span> <span class="hljs-string">h1</span> <span class="hljs-bullet">-</span> <span class="hljs-string">h0));</span>        <span class="hljs-string">canvas.drawPath(mPath</span>, <span class="hljs-string">mPaintTrangel);</span>        <span class="hljs-string">mPaintTrangel.setShadowLayer(4</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-3</span>, <span class="hljs-string">Color.GRAY);</span>        <span class="hljs-string">mPath.moveTo(mWidth</span> <span class="hljs-string">/</span> <span class="hljs-number">2</span>, <span class="hljs-string">mHeight</span> <span class="hljs-string">/</span> <span class="hljs-number">2</span> <span class="hljs-string">+</span> <span class="hljs-string">(radius</span> <span class="hljs-bullet">-</span> <span class="hljs-string">h0));</span>        <span class="hljs-string">mPath.lineTo(mWidth</span> <span class="hljs-string">/</span> <span class="hljs-number">2</span> <span class="hljs-bullet">-</span> <span class="hljs-string">w</span>, <span class="hljs-string">mHeight</span> <span class="hljs-string">/</span> <span class="hljs-number">2</span> <span class="hljs-string">+</span> <span class="hljs-string">(radius</span> <span class="hljs-bullet">-</span> <span class="hljs-string">h1</span> <span class="hljs-bullet">-</span> <span class="hljs-string">h0));</span>        <span class="hljs-string">mPath.lineTo(mWidth</span> <span class="hljs-string">/</span> <span class="hljs-number">2</span> <span class="hljs-string">+</span> <span class="hljs-string">w</span>, <span class="hljs-string">mHeight</span> <span class="hljs-string">/</span> <span class="hljs-number">2</span> <span class="hljs-string">+</span> <span class="hljs-string">(radius</span> <span class="hljs-bullet">-</span> <span class="hljs-string">h1</span> <span class="hljs-bullet">-</span> <span class="hljs-string">h0));</span>        <span class="hljs-string">canvas.drawPath(mPath</span>, <span class="hljs-string">mPaintTrangel);*/</span>    &#125;</code></pre><p><strong>绘制CircleWaveView中心的文字</strong> 中心文字分为两种情况：当蓝牙未连接时，显示为两行。当蓝牙已连接时显示为一行。绘制思路是先计算出中心基线，然后再来分情况实现。代码如下：</p><pre><code class="hljs reasonml"><span class="hljs-comment">//  绘制圆中的文字</span>    <span class="hljs-keyword">private</span> void draw<span class="hljs-constructor">Text(Canvas <span class="hljs-params">canvas</span>)</span> &#123;        <span class="hljs-keyword">if</span> (isConnecting) return;        <span class="hljs-keyword">if</span> (<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">TextUtils</span>.</span></span>is<span class="hljs-constructor">Empty(<span class="hljs-params">mText</span>)</span>) &#123; <span class="hljs-comment">//   绘制单行文字</span>            String text = mContext.get<span class="hljs-constructor">Resources()</span>.get<span class="hljs-constructor">String(R.<span class="hljs-params">string</span>.<span class="hljs-params">ble_not_connect</span>)</span>;            canvas.draw<span class="hljs-constructor">Text(<span class="hljs-params">text</span>, <span class="hljs-params">mPieCenterX</span>, <span class="hljs-params">getBaseline</span>(<span class="hljs-params">text</span>)</span>, mPaintText);            return;        &#125;        <span class="hljs-keyword">if</span> (isBluetoothConnect) &#123;   <span class="hljs-comment">//   绘制单行文字</span>            canvas.draw<span class="hljs-constructor">Text(<span class="hljs-params">mText</span>, <span class="hljs-params">mPieCenterX</span>, <span class="hljs-params">getBaseline</span>(<span class="hljs-params">mText</span>)</span>, mPaintText);        &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-comment">//   绘制两行文字</span>            String text = mContext.get<span class="hljs-constructor">Resources()</span>.get<span class="hljs-constructor">String(R.<span class="hljs-params">string</span>.<span class="hljs-params">ble_not_connect</span>)</span>;            <span class="hljs-built_in">int</span> baseline = get<span class="hljs-constructor">Baseline(<span class="hljs-params">text</span>)</span>;            canvas.draw<span class="hljs-constructor">Text(<span class="hljs-params">text</span>, <span class="hljs-params">mPieCenterX</span>, <span class="hljs-params">baseline</span> - 30, <span class="hljs-params">mPaintText</span>)</span>;            mPaintText.set<span class="hljs-constructor">TextSize(DensityUtils.<span class="hljs-params">dp2px</span>(<span class="hljs-params">mContext</span>, 12)</span>);            canvas.draw<span class="hljs-constructor">Text(<span class="hljs-params">mText</span>, <span class="hljs-params">mPieCenterX</span>, <span class="hljs-params">baseline</span> + 30, <span class="hljs-params">mPaintText</span>)</span>;        &#125;    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> get<span class="hljs-constructor">Baseline(String <span class="hljs-params">text</span>)</span> &#123;        mPaintText.set<span class="hljs-constructor">TextSize(<span class="hljs-params">mTextSize</span>)</span>;        mPaintText.get<span class="hljs-constructor">TextBounds(<span class="hljs-params">text</span>, 0, <span class="hljs-params">text</span>.<span class="hljs-params">length</span>()</span>, bounds);        Paint.FontMetricsInt fontMetricsInt = mPaintText.get<span class="hljs-constructor">FontMetricsInt()</span>;        return (get<span class="hljs-constructor">MeasuredHeight()</span> - fontMetricsInt.bottom + fontMetricsInt.top)<span class="hljs-operator"> / </span><span class="hljs-number">2</span>                - fontMetricsInt.top;    &#125;</code></pre><p><strong>2.关于弹性滑动的实现。</strong> 关于滑动，通常我们会想到用ScrollTo或ScrollBy来实现。但由于这两个方法实现滑动都是瞬间完成的，因此滑动看起来会比较生硬，体验也很不好。因此想到可以使用Scroller来做一个滑动延迟实现带有弹性效果的滑动。由于Scroller本身时无法实现滑动的，因此还必须配合computeScroll方法共同完成。这里我们封装一个smoothScroll方法，提供给LockView调用。具体代码如下：</p><pre><code class="hljs reasonml">public void smooth<span class="hljs-constructor">Scroll(<span class="hljs-params">int</span> <span class="hljs-params">destX</span>, <span class="hljs-params">int</span> <span class="hljs-params">destY</span>)</span> &#123;        <span class="hljs-built_in">int</span> scrollY = get<span class="hljs-constructor">ScrollY()</span>;        <span class="hljs-built_in">int</span> delta = destY - scrollY;        mScroller.start<span class="hljs-constructor">Scroll(<span class="hljs-params">destX</span>, <span class="hljs-params">scrollY</span>, 0, <span class="hljs-params">delta</span>, 400)</span>;        invalidate<span class="hljs-literal">()</span>;    &#125;    @Override    public void compute<span class="hljs-constructor">Scroll()</span> &#123;        <span class="hljs-keyword">if</span> (mScroller.compute<span class="hljs-constructor">ScrollOffset()</span>) &#123;            scroll<span class="hljs-constructor">To(<span class="hljs-params">mScroller</span>.<span class="hljs-params">getCurrX</span>()</span>, mScroller.get<span class="hljs-constructor">CurrY()</span>);            post<span class="hljs-constructor">Invalidate()</span>;        &#125;    &#125;</code></pre><p><strong>3.心跳动画的实现以及状态改变的扩散动画。</strong> </p><p>首先来看心跳动画的实现，这里使用属性动画，首先为ValueAnimator设置从0到1再到0的一个数值变化，并且周期时间设置为600毫秒、重复次数设置为ValueAnimator.INFINITE，即为无限次循环。通过ValueAnimator中不断变化的value来计算圆半径的大小，并通过invalidate()方法不断重绘View，从而达到一个心跳动画的效果。代码如下：</p><pre><code class="hljs reasonml"><span class="hljs-comment">//  开始心跳动画</span>public void start<span class="hljs-constructor">Wave()</span> &#123;        <span class="hljs-keyword">if</span> (animator != null<span class="hljs-operator"> &amp;&amp; </span>animator.is<span class="hljs-constructor">Running()</span>)            animator.<span class="hljs-keyword">end</span><span class="hljs-literal">()</span>;        animator = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ValueAnimator</span>.</span></span><span class="hljs-keyword">of</span><span class="hljs-constructor">Float(0f, 1f, 0f)</span>;        animator.set<span class="hljs-constructor">RepeatCount(ValueAnimator.INFINITE)</span>;        animator.set<span class="hljs-constructor">RepeatMode(ValueAnimator.RESTART)</span>;        animator.set<span class="hljs-constructor">Duration(600)</span>;        animator.add<span class="hljs-constructor">UpdateListener(<span class="hljs-params">new</span> ValueAnimator.AnimatorUpdateListener()</span> &#123;            @Override            public void on<span class="hljs-constructor">AnimationUpdate(ValueAnimator <span class="hljs-params">animation</span>)</span> &#123;                <span class="hljs-built_in">int</span> verticalCenter = get<span class="hljs-constructor">Height()</span><span class="hljs-operator"> / </span><span class="hljs-number">2</span>;                <span class="hljs-built_in">int</span> horizontalCenter = get<span class="hljs-constructor">Width()</span><span class="hljs-operator"> / </span><span class="hljs-number">2</span>;                waveDelta = (<span class="hljs-built_in">int</span>) (<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>min(verticalCenter, horizontalCenter)<span class="hljs-operator"> * </span>(<span class="hljs-built_in">float</span>) animation.get<span class="hljs-constructor">AnimatedValue()</span><span class="hljs-operator"> / </span><span class="hljs-number">16</span>);                invalidate<span class="hljs-literal">()</span>;            &#125;        &#125;);        animator.start<span class="hljs-literal">()</span>;    &#125; <span class="hljs-comment">//  停止心跳动画</span> public void stop<span class="hljs-constructor">Wave()</span> &#123;        <span class="hljs-keyword">if</span> (animator != null<span class="hljs-operator"> &amp;&amp; </span>animator.is<span class="hljs-constructor">Running()</span>)            animator.<span class="hljs-keyword">end</span><span class="hljs-literal">()</span>;    &#125;</code></pre><p>接下来看状态改变时扩散动画的实现，其实方法和心跳动画一样，都是采用ValueAnimator动态计算绘制圆的半径，不在赘述。参考如下代码：</p><pre><code class="hljs reasonml">public void change<span class="hljs-constructor">LockState(<span class="hljs-params">final</span> <span class="hljs-params">boolean</span> <span class="hljs-params">lock</span>)</span> &#123;        stop<span class="hljs-constructor">Wave()</span>;        <span class="hljs-keyword">if</span> (this.isLock != lock) &#123;            transforming = <span class="hljs-literal">true</span>;            ValueAnimator valueAnimator = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ValueAnimator</span>.</span></span><span class="hljs-keyword">of</span><span class="hljs-constructor">Float(0f, 0.99f)</span>;            valueAnimator.set<span class="hljs-constructor">Duration(500)</span>;            valueAnimator.add<span class="hljs-constructor">Listener(<span class="hljs-params">new</span> Animator.AnimatorListener()</span> &#123;                @Override                public void on<span class="hljs-constructor">AnimationStart(Animator <span class="hljs-params">animation</span>)</span> &#123;                &#125;                @Override                public void on<span class="hljs-constructor">AnimationEnd(Animator <span class="hljs-params">animation</span>)</span> &#123;                    transforming = <span class="hljs-literal">false</span>;                    isLock = lock;                    invalidate<span class="hljs-literal">()</span>;                &#125;                @Override                public void on<span class="hljs-constructor">AnimationCancel(Animator <span class="hljs-params">animation</span>)</span> &#123;                    transforming = <span class="hljs-literal">false</span>;                &#125;                @Override                public void on<span class="hljs-constructor">AnimationRepeat(Animator <span class="hljs-params">animation</span>)</span> &#123;                &#125;            &#125;);            valueAnimator.add<span class="hljs-constructor">UpdateListener(<span class="hljs-params">new</span> ValueAnimator.AnimatorUpdateListener()</span> &#123;                @Override                public void on<span class="hljs-constructor">AnimationUpdate(ValueAnimator <span class="hljs-params">animation</span>)</span> &#123;                    <span class="hljs-built_in">int</span> verticalCenter = get<span class="hljs-constructor">Height()</span><span class="hljs-operator"> / </span><span class="hljs-number">2</span>;                    <span class="hljs-built_in">int</span> horizontalCenter = get<span class="hljs-constructor">Width()</span><span class="hljs-operator"> / </span><span class="hljs-number">2</span>;                    transformDelta = (<span class="hljs-built_in">int</span>) ((<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>min(verticalCenter, horizontalCenter) - <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>min(verticalCenter, horizontalCenter)<span class="hljs-operator"> / </span><span class="hljs-number">6</span>)<span class="hljs-operator">                            * </span>(<span class="hljs-built_in">float</span>) animation.get<span class="hljs-constructor">AnimatedValue()</span>);                    invalidate<span class="hljs-literal">()</span>;                &#125;            &#125;);            valueAnimator.start<span class="hljs-literal">()</span>;        &#125;    &#125;</code></pre><p>至此，关于LockView的绘制到这里就完全结束了。回顾一下本篇文章，重讲解了自定义LockView以及弹性滑动实现，然后探讨了关于事件分发的一些知识以及使用属性动画来实现心跳和扩散效果。相信看完本篇文章的小伙伴也会有不小的收获，最后关于源码，已放在文章末尾，欢迎start、forck！</p><p> <a href="https://github.com/zhpanvip/CustomView">源码链接</a></p><h3 id="好库推荐"><a href="#好库推荐" class="headerlink" title="好库推荐"></a>好库推荐</h3><p>给大家推荐一下<a href="https://github.com/zhpanvip/BannerViewPager">BannerViewPager</a>。这是一个基于ViewPager实现的具有强大功能的无限轮播库。通过<a href="https://github.com/zhpanvip/BannerViewPager">BannerViewPager</a>可以实现腾讯视频、QQ音乐、酷狗音乐、支付宝、天猫、淘宝、优酷视频、喜马拉雅、网易云音乐、哔哩哔哩等APP的Banner样式以及指示器样式。</p><p>欢迎大家到github关注<a href="https://github.com/zhpanvip/BannerViewPager">BannerViewPager</a>！</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Android Widget开发详解</title>
    <link href="/2018/06/21/Android-Widget%E5%BC%80%E5%8F%91%E8%AF%A6%E8%A7%A3/"/>
    <url>/2018/06/21/Android-Widget%E5%BC%80%E5%8F%91%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p>好久没博客更新了，本篇文章来学习一下如何实现一个Android列表小部件，效果可以参看下图：<br><img src="https://raw.githubusercontent.com/zhpanvip/Resource/master/image/1303.gif"></p><p>这个页面如果是在App内部实现，相信只要有一点Android基础的童鞋都能很轻松写出来。但是如果放到Widget中可能就不是那么简单了。因为Widget并没有运行在我们App的进程中，而是运行在系统的SystemServer进程中。你可能会惊讶，Whf！竟然不在我们App进程中！那么是不是意味着我们也不能像在App中那样操作View控件了？答案确实如此。不过不必过于担心，为了我们能在远程进程中更新界面，Google爸爸专门为我们提供了一个RemoteViews类。从名字上看，可能会觉得RemoteViews就是一个View。但事实并非如此，RemoteViews仅仅表示的是一个View结构。它可以在远程进程中展示和更新界面。今天我们要实现的列表小部件就是基于RemoteVeiw实现的。<br>那么接下来我们来学习如何实现一个桌面Widget，我们先列出要实现Widget的几个核心步骤：</p><ul><li>widget页面布局  </li><li>小部件配置信息 </li><li>了解AppWidgetProvider</li><li>RemoteViewsFactory实现列表适配</li><li>点击的事件处理</li></ul><h2 id="一-实现Widget界面"><a href="#一-实现Widget界面" class="headerlink" title="一. 实现Widget界面"></a>一. 实现Widget界面</h2><p><strong>1.widget页面布局。</strong>首先创建一个布局文件layout_widget.xml，内容如下：</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">LinearLayout</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/ll_right&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">android:background</span>=<span class="hljs-string">&quot;@drawable/bg_widget&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">android:orientation</span>=<span class="hljs-string">&quot;vertical&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">RelativeLayout</span></span><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;40dp&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:background</span>=<span class="hljs-string">&quot;#ccc&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">ImageView</span></span><span class="hljs-tag">            <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/iv_icon&quot;</span></span><span class="hljs-tag">            <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;30dp&quot;</span></span><span class="hljs-tag">            <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;30dp&quot;</span></span><span class="hljs-tag">            <span class="hljs-attr">android:layout_centerVertical</span>=<span class="hljs-string">&quot;true&quot;</span></span><span class="hljs-tag">            <span class="hljs-attr">android:layout_marginEnd</span>=<span class="hljs-string">&quot;5dp&quot;</span></span><span class="hljs-tag">            <span class="hljs-attr">android:layout_marginStart</span>=<span class="hljs-string">&quot;5dp&quot;</span></span><span class="hljs-tag">            <span class="hljs-attr">android:background</span>=<span class="hljs-string">&quot;@mipmap/ic_launcher_round&quot;</span> /&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span></span><span class="hljs-tag">            <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/tv_title&quot;</span></span><span class="hljs-tag">            <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><span class="hljs-tag">            <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><span class="hljs-tag">            <span class="hljs-attr">android:layout_centerVertical</span>=<span class="hljs-string">&quot;true&quot;</span></span><span class="hljs-tag">            <span class="hljs-attr">android:layout_toEndOf</span>=<span class="hljs-string">&quot;@id/iv_icon&quot;</span></span><span class="hljs-tag">            <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;Widget&quot;</span> /&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">LinearLayout</span></span><span class="hljs-tag">            <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><span class="hljs-tag">            <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><span class="hljs-tag">            <span class="hljs-attr">android:layout_alignParentEnd</span>=<span class="hljs-string">&quot;true&quot;</span></span><span class="hljs-tag">            <span class="hljs-attr">android:gravity</span>=<span class="hljs-string">&quot;center_vertical&quot;</span></span><span class="hljs-tag">            <span class="hljs-attr">android:orientation</span>=<span class="hljs-string">&quot;horizontal&quot;</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">ProgressBar</span></span><span class="hljs-tag">                <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/progress_bar&quot;</span></span><span class="hljs-tag">                <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;20dp&quot;</span></span><span class="hljs-tag">                <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;20dp&quot;</span></span><span class="hljs-tag">                <span class="hljs-attr">android:indeterminateTint</span>=<span class="hljs-string">&quot;@color/colorAccent&quot;</span></span><span class="hljs-tag">                <span class="hljs-attr">android:indeterminateTintMode</span>=<span class="hljs-string">&quot;src_atop&quot;</span></span><span class="hljs-tag">                <span class="hljs-attr">android:visibility</span>=<span class="hljs-string">&quot;gone&quot;</span> /&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span></span><span class="hljs-tag">                <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/tv_refresh&quot;</span></span><span class="hljs-tag">                <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><span class="hljs-tag">                <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><span class="hljs-tag">                <span class="hljs-attr">android:layout_marginEnd</span>=<span class="hljs-string">&quot;15dp&quot;</span></span><span class="hljs-tag">                <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;刷新&quot;</span></span><span class="hljs-tag">                <span class="hljs-attr">android:padding</span>=<span class="hljs-string">&quot;5dp&quot;</span></span><span class="hljs-tag">                <span class="hljs-attr">android:textSize</span>=<span class="hljs-string">&quot;12sp&quot;</span> /&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">LinearLayout</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">RelativeLayout</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">ListView</span></span><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/lv_device&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:columnWidth</span>=<span class="hljs-string">&quot;80dip&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:gravity</span>=<span class="hljs-string">&quot;center&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:horizontalSpacing</span>=<span class="hljs-string">&quot;4dip&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:numColumns</span>=<span class="hljs-string">&quot;auto_fit&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:verticalSpacing</span>=<span class="hljs-string">&quot;4dip&quot;</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">LinearLayout</span>&gt;</span></code></pre><p>看到布局中的ListView控件，你可能会不屑一笑，都什么年代了还在用ListView？RecyclerView才是王道吧？可是我只能说句抱歉，Widget不支持RecyclerView。对，你没看错，真的不支持。在Widget中我们没办法做到想用什么就用什么，甚至觉得原生用着不爽，自己撸一个控件出来。对不起，Widget都不支持。因此Widget也有很大的局限性。我们来看下支持在Widget中运行的有哪些控件：</p><blockquote><p>A RemoteViews object (and, consequently, an App Widget) can support the following layout classes:<br>FrameLayout<br>LinearLayout<br>RelativeLayout<br>GridLayout<br>And the following widget classes:<br>AnalogClock<br>Button<br>Chronometer<br>ImageButton<br>ImageView<br>ProgressBar<br>TextView<br>ViewFlipper<br>ListView<br>GridView<br>StackView<br>AdapterViewFlipper<br>Descendants of these classes are not supported.</p></blockquote><p>除了上述列出的几个View，其它的包括Android原生View和自定义View是都不支持在Widget中运行的。因此基于Widget页面限制我们基本就可以告别炫酷的动画效果了。</p><h2 id="二-小部件配置信息"><a href="#二-小部件配置信息" class="headerlink" title="二.小部件配置信息"></a>二.小部件配置信息</h2><p>配置信息主要是设定小部件的一些属性，比如宽高、缩放模式、更新时间间隔等。我们需要在res/xml目录下新建widget_provider.xml文件，文件名字可以任意取。文件内容如下（可做参考）：</p><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">appwidget-provider</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">android:minHeight</span>=<span class="hljs-string">&quot;180dp&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">android:minWidth</span>=<span class="hljs-string">&quot;300dp&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">android:previewImage</span>=<span class="hljs-string">&quot;@drawable/ic_launcher_background&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">android:initialLayout</span>=<span class="hljs-string">&quot;@layout/layout_widget&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">android:updatePeriodMillis</span>=<span class="hljs-string">&quot;50000&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">android:resizeMode</span>=<span class="hljs-string">&quot;horizontal|vertical&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">android:widgetCategory</span>=<span class="hljs-string">&quot;home_screen&quot;</span>&gt;</span>     <span class="hljs-tag">&lt;/<span class="hljs-name">appwidget-provider</span>&gt;</span></code></pre><p>针对上述文件中的配置信息来做下介绍。</p><ul><li><strong><em>minHeight、minWidth</em></strong> 定义Widget的最小高度和最小宽度（Widget可以通过拉伸来调整尺寸大小）。</li><li><strong><em>previewImage</em></strong> 定义添加小部件时显示的图标。</li><li><strong><em>initialLayout</em></strong> 定义了小部件使用的布局。</li><li><strong><em>updatePeriodMillis</em></strong>定义小部件自动更新的周期，单位为毫秒。</li><li><strong><em>resizeMode</em></strong> 指定了 widget 的调整尺寸的规则。可取的值有: “horizontal”, “vertical”, “none”。”horizontal”意味着widget可以水平拉伸，“vertical”意味着widget可以竖值拉伸，“none”意味着widget不能拉伸；默认值是”none”。</li><li><strong><em>widgetCategory</em></strong> 指定了 widget 能显示的地方：能否显示在 home Screen 或 lock screen 或 两者都可以。它的取值包括：”home_screen” 和 “keyguard”。Android 4.2 引入。<br>最后，需要我们在AndroidManifest中注册AppWidgetProvider时引用该文件，使用如下：</li></ul><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">receiver</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;.widget.ListWidgetProvider&quot;</span>&gt;</span>     ...    <span class="hljs-tag">&lt;<span class="hljs-name">meta-data</span></span><span class="hljs-tag">        <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.appwidget.provider&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:resource</span>=<span class="hljs-string">&quot;@xml/widget_provider&quot;</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">receiver</span>&gt;</span></code></pre><h2 id="三-了解AppWidgetProvider类"><a href="#三-了解AppWidgetProvider类" class="headerlink" title="三.了解AppWidgetProvider类"></a>三.了解AppWidgetProvider类</h2><p>我们来简单了解下AppWidgetProvider这个类。Widget的功能均是通过AppWidgetProvider来实现的。我们跟进源码可以发现它是继承自BroadcastReceiver类，也就是一个广播接收者。上面我们提到过RemoteViews是运行在SystemServer进程中的，再结合此处我们应该可以推测小部件的事件应该是通过广播来实现的。像小部件的添加、删除、更新、启用、禁用等均是在AppWidgetProvider中通过接受广播来完成的。看AppWidgetProvider中的几个方法：</p><ul><li>onUpdate() 当Widget被添加或者被更新时会调用该方法。上边我们提到通过配置updatePeriodMillis可以定期更新Widget。但是当我们在widget的配置文件中声明了android:configure的时候，添加Widget时则不会调用onUpdate方法。</li><li>onEnable() 这个方法会在用户首次添加Widget时调用。</li><li>onAppWidgetOptionsChanged() 这个方法会在添加Widget或者改变Widget的大小时候被调用。在这个方法中我们还可以根据Widget的大小来选择性的显示或隐藏某些控件。</li><li>onDeleted(Context, int[]) 当控件被删除的时候调用该方法</li><li>onEnabled(Context) 当第一个Widget被添加的时候调用。如果用户添加了两个这个小部件，那么只有第一个添加时才会调用onEnabled.</li><li>onDisabled(Context) 当最后一个Widget实例被移除的时候调用这个方法。在这个方法中我们可以做一些清除工作，例如删掉临时的数据库等。</li><li>onReceive(Context, Intent) 当接收到广播的时候会被调用。</li></ul><p>上述方法中，我们需要着重关心一下onUpdate()方法和onReceive()方法。因为onUpdate()方法会在Widget被添加时候调用，我们可以在此时为Widget添加一View的些交互事件，例如点击事件。由于本篇我们要实现的是一个列表小部件。因此我们还需要RemoteViewsFactory这个类来适配列表数据。</p><p>先来看下ListWidgetProvider这个类中的代码：</p><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListWidgetProvider</span> <span class="hljs-title">extends</span> <span class="hljs-title">AppWidgetProvider</span> &#123;</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">String</span> TAG = <span class="hljs-string">&quot;WIDGET&quot;</span>;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">String</span> REFRESH_WIDGET = <span class="hljs-string">&quot;com.oitsme.REFRESH_WIDGET&quot;</span>;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">String</span> COLLECTION_VIEW_ACTION = <span class="hljs-string">&quot;com.oitsme.COLLECTION_VIEW_ACTION&quot;</span>;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">String</span> COLLECTION_VIEW_EXTRA = <span class="hljs-string">&quot;com.oitsme.COLLECTION_VIEW_EXTRA&quot;</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Handler mHandler=<span class="hljs-keyword">new</span> Handler();    <span class="hljs-keyword">private</span> Runnable runnable=<span class="hljs-keyword">new</span> Runnable() &#123;        @Override        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-built_in">run</span>() &#123;            hideLoading(Utils.getContext());            Toast.makeText(Utils.getContext(), <span class="hljs-string">&quot;刷新成功&quot;</span>, Toast.LENGTH_SHORT).show();        &#125;    &#125;;    @Override    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onUpdate</span><span class="hljs-params">(Context context, AppWidgetManager appWidgetManager,</span></span><span class="hljs-function"><span class="hljs-params">                         <span class="hljs-keyword">int</span>[] appWidgetIds)</span> </span>&#123;        Log.d(TAG, <span class="hljs-string">&quot;ListWidgetProvider onUpdate&quot;</span>);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> appWidgetId : appWidgetIds) &#123;            <span class="hljs-comment">// 获取AppWidget对应的视图</span>            RemoteViews remoteViews = <span class="hljs-keyword">new</span> RemoteViews(context.getPackageName(), R.layout.layout_widget);            <span class="hljs-comment">// 设置响应 “按钮(bt_refresh)” 的intent</span>            Intent btIntent = <span class="hljs-keyword">new</span> Intent().setAction(REFRESH_WIDGET);            PendingIntent btPendingIntent = PendingIntent.getBroadcast(context, <span class="hljs-number">0</span>, btIntent, PendingIntent.FLAG_UPDATE_CURRENT);            remoteViews.setOnClickPendingIntent(R.id.tv_refresh, btPendingIntent);            <span class="hljs-comment">// 设置 “ListView” 的adapter。</span>            <span class="hljs-comment">// (01) intent: 对应启动 ListWidgetService(RemoteViewsService) 的intent</span>            <span class="hljs-comment">// (02) setRemoteAdapter: 设置 gridview的适配器</span>            <span class="hljs-comment">//    通过setRemoteAdapter将ListView和ListWidgetService关联起来，</span>            <span class="hljs-comment">//    以达到通过 ListWidgetService 更新 ListView的目的</span>            Intent serviceIntent = <span class="hljs-keyword">new</span> Intent(context, ListWidgetService.class);            remoteViews.setRemoteAdapter(R.id.lv_device, serviceIntent);            <span class="hljs-comment">// 设置响应 “ListView” 的intent模板</span>            <span class="hljs-comment">// 说明：“集合控件(如GridView、ListView、StackView等)”中包含很多子元素，如GridView包含很多格子。</span>            <span class="hljs-comment">//     它们不能像普通的按钮一样通过 setOnClickPendingIntent 设置点击事件，必须先通过两步。</span>            <span class="hljs-comment">//        (01) 通过 setPendingIntentTemplate 设置 “intent模板”，这是比不可少的！</span>            <span class="hljs-comment">//        (02) 然后在处理该“集合控件”的RemoteViewsFactory类的getViewAt()接口中 通过 setOnClickFillInIntent 设置“集合控件的某一项的数据”</span>            Intent gridIntent = <span class="hljs-keyword">new</span> Intent();            gridIntent.setAction(COLLECTION_VIEW_ACTION);            gridIntent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, appWidgetId);            PendingIntent pendingIntent = PendingIntent.getBroadcast(context, <span class="hljs-number">0</span>, gridIntent, PendingIntent.FLAG_UPDATE_CURRENT);            <span class="hljs-comment">// 设置intent模板</span>            remoteViews.setPendingIntentTemplate(R.id.lv_device, pendingIntent);            <span class="hljs-comment">// 调用集合管理器对集合进行更新</span>            appWidgetManager.updateAppWidget(appWidgetId, remoteViews);        &#125;        super.onUpdate(context, appWidgetManager, appWidgetIds);    &#125;    @Override    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onReceive</span><span class="hljs-params">(Context context, Intent intent)</span> </span>&#123;        <span class="hljs-keyword">String</span> action = intent.getAction();        AppWidgetManager appWidgetManager = AppWidgetManager.getInstance(context);        <span class="hljs-keyword">if</span> (action.equals(COLLECTION_VIEW_ACTION)) &#123;            <span class="hljs-comment">// 接受“ListView”的点击事件的广播</span>            <span class="hljs-keyword">int</span> type = intent.getIntExtra(<span class="hljs-string">&quot;Type&quot;</span>, <span class="hljs-number">0</span>);            <span class="hljs-keyword">int</span> appWidgetId = intent.getIntExtra(AppWidgetManager.EXTRA_APPWIDGET_ID,                    AppWidgetManager.INVALID_APPWIDGET_ID);            <span class="hljs-keyword">int</span> index = intent.getIntExtra(COLLECTION_VIEW_EXTRA, <span class="hljs-number">0</span>);            <span class="hljs-keyword">switch</span> (type) &#123;                <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:                    Toast.makeText(context, <span class="hljs-string">&quot;item&quot;</span> + index, Toast.LENGTH_SHORT).show();                    <span class="hljs-keyword">break</span>;                <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:                    Toast.makeText(context, <span class="hljs-string">&quot;lock&quot;</span>+index, Toast.LENGTH_SHORT).show();                    <span class="hljs-keyword">break</span>;                <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:                    Toast.makeText(context, <span class="hljs-string">&quot;unlock&quot;</span>+index, Toast.LENGTH_SHORT).show();                    <span class="hljs-keyword">break</span>;            &#125;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (action.equals(REFRESH_WIDGET)) &#123;            <span class="hljs-comment">// 接受“bt_refresh”的点击事件的广播</span>            Toast.makeText(context, <span class="hljs-string">&quot;刷新...&quot;</span>, Toast.LENGTH_SHORT).show();            <span class="hljs-keyword">final</span> AppWidgetManager mgr = AppWidgetManager.getInstance(context);            <span class="hljs-keyword">final</span> ComponentName cn = <span class="hljs-keyword">new</span> ComponentName(context,ListWidgetProvider.class);            ListRemoteViewsFactory.refresh();            mgr.notifyAppWidgetViewDataChanged(mgr.getAppWidgetIds(cn),R.id.lv_device);            mHandler.postDelayed(runnable,<span class="hljs-number">2000</span>);            showLoading(context);        &#125;        super.<span class="hljs-built_in">onReceive</span>(context, intent);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 显示加载loading</span><span class="hljs-comment">     *</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">showLoading</span><span class="hljs-params">(Context context)</span> </span>&#123;        RemoteViews remoteViews = <span class="hljs-keyword">new</span> RemoteViews(context.getPackageName(), R.layout.layout_widget);        remoteViews.setViewVisibility(R.id.tv_refresh, View.VISIBLE);        remoteViews.setViewVisibility(R.id.progress_bar, View.VISIBLE);        remoteViews.setTextViewText(R.id.tv_refresh, <span class="hljs-string">&quot;正在刷新...&quot;</span>);        refreshWidget(context, remoteViews, <span class="hljs-literal">false</span>);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 隐藏加载loading</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hideLoading</span><span class="hljs-params">(Context context)</span> </span>&#123;        RemoteViews remoteViews = <span class="hljs-keyword">new</span> RemoteViews(context.getPackageName(), R.layout.layout_widget);        remoteViews.setViewVisibility(R.id.progress_bar, View.GONE);        remoteViews.setTextViewText(R.id.tv_refresh, <span class="hljs-string">&quot;刷新&quot;</span>);        refreshWidget(context, remoteViews, <span class="hljs-literal">false</span>);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 刷新Widget</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">refreshWidget</span><span class="hljs-params">(Context context, RemoteViews remoteViews, <span class="hljs-keyword">boolean</span> refreshList)</span> </span>&#123;        AppWidgetManager appWidgetManager = AppWidgetManager.getInstance(context);        ComponentName componentName = <span class="hljs-keyword">new</span> ComponentName(context, ListWidgetProvider.class);        appWidgetManager.updateAppWidget(componentName, remoteViews);        <span class="hljs-keyword">if</span> (refreshList)            appWidgetManager.notifyAppWidgetViewDataChanged(appWidgetManager.getAppWidgetIds(componentName), R.id.lv_device);    &#125;&#125;</code></pre><p>针对以上代码，我们着重来看onUpdate()方法。在onUpdate()中我们主要实现了两个功能，第一个功能ListView以外的事件点击，例如点击“刷新”来更新小部件。第二个功能是适配ListView并实现ListView内部Item控件的点击事件。在这个方法中我们首先获取到了一个RemoteView的实例，这个RemoteView对应的就是我们Widget布局的View。关于点击事件的实现代码中注释写的也比较详细，在这里就不做过多解释了。重点是需要了解如何实现并适配ListView，具体实现请看下节。</p><h2 id="四-RemoteViewsFactory实现列表适配"><a href="#四-RemoteViewsFactory实现列表适配" class="headerlink" title="四.RemoteViewsFactory实现列表适配"></a>四.RemoteViewsFactory实现列表适配</h2><p>上面我们提到了RemoteViewsFactory，这个类其实可以类比为ListView的Adapter，该类存在的意义就是为了适配ListView的数据。只不过这里是把Adapter换成RemoteViews来实现的。看下ListRemoteViewsFactory中的代码：</p><pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListRemoteViewsFactory</span> <span class="hljs-title">implements</span> <span class="hljs-title">RemoteViewsService</span>.<span class="hljs-title">RemoteViewsFactory</span> &#123;</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">String</span> TAG=<span class="hljs-string">&quot;Widget&quot;</span>;    <span class="hljs-keyword">private</span> Context mContext;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> mAppWidgetId;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> List&lt;Device&gt; mDevices;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 构造GridRemoteViewsFactory</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ListRemoteViewsFactory</span><span class="hljs-params">(Context context, Intent intent)</span> </span>&#123;        mContext = context;        mAppWidgetId = intent.getIntExtra(AppWidgetManager.EXTRA_APPWIDGET_ID,                AppWidgetManager.INVALID_APPWIDGET_ID);    &#125;    @Override    <span class="hljs-function"><span class="hljs-keyword">public</span> RemoteViews <span class="hljs-title">getViewAt</span><span class="hljs-params">(<span class="hljs-keyword">int</span> <span class="hljs-built_in">position</span>)</span> </span>&#123;        <span class="hljs-comment">//  HashMap&lt;String, Object&gt; map;</span>        <span class="hljs-comment">// 获取 item_widget_device.xml 对应的RemoteViews</span>        RemoteViews rv = <span class="hljs-keyword">new</span> RemoteViews(mContext.getPackageName(), R.layout.item_widget_device);        <span class="hljs-comment">// 设置 第position位的“视图”的数据</span>        Device device = mDevices.<span class="hljs-built_in">get</span>(<span class="hljs-built_in">position</span>);        <span class="hljs-comment">//  rv.setImageViewResource(R.id.iv_lock, ((Integer) map.get(IMAGE_ITEM)).intValue());</span>        rv.setTextViewText(R.id.tv_name, device.getName());        <span class="hljs-comment">// 设置 第position位的“视图”对应的响应事件</span>        Intent fillInIntent = <span class="hljs-keyword">new</span> Intent();        fillInIntent.putExtra(<span class="hljs-string">&quot;Type&quot;</span>, <span class="hljs-number">0</span>);        fillInIntent.putExtra(ListWidgetProvider.COLLECTION_VIEW_EXTRA, <span class="hljs-built_in">position</span>);        rv.setOnClickFillInIntent(R.id.rl_widget_device, fillInIntent);        Intent lockIntent = <span class="hljs-keyword">new</span> Intent();        lockIntent.putExtra(ListWidgetProvider.COLLECTION_VIEW_EXTRA, <span class="hljs-built_in">position</span>);        lockIntent.putExtra(<span class="hljs-string">&quot;Type&quot;</span>, <span class="hljs-number">1</span>);        rv.setOnClickFillInIntent(R.id.iv_lock, lockIntent);        Intent unlockIntent = <span class="hljs-keyword">new</span> Intent();        unlockIntent.putExtra(<span class="hljs-string">&quot;Type&quot;</span>, <span class="hljs-number">2</span>);        unlockIntent.putExtra(ListWidgetProvider.COLLECTION_VIEW_EXTRA, <span class="hljs-built_in">position</span>);        rv.setOnClickFillInIntent(R.id.iv_unlock, unlockIntent);        <span class="hljs-keyword">return</span> rv;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 初始化ListView的数据</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initListViewData</span><span class="hljs-params">()</span> </span>&#123;        mDevices = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        mDevices.add(<span class="hljs-keyword">new</span> Device(<span class="hljs-string">&quot;Hello&quot;</span>, <span class="hljs-number">0</span>));        mDevices.add(<span class="hljs-keyword">new</span> Device(<span class="hljs-string">&quot;Oitsme&quot;</span>, <span class="hljs-number">1</span>));        mDevices.add(<span class="hljs-keyword">new</span> Device(<span class="hljs-string">&quot;Hi&quot;</span>, <span class="hljs-number">0</span>));        mDevices.add(<span class="hljs-keyword">new</span> Device(<span class="hljs-string">&quot;Hey&quot;</span>, <span class="hljs-number">1</span>));    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> i;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">refresh</span><span class="hljs-params">()</span></span>&#123;        i++;        mDevices.add(<span class="hljs-keyword">new</span> Device(<span class="hljs-string">&quot;Refresh&quot;</span>+i, <span class="hljs-number">1</span>));    &#125;    @Override    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">()</span> </span>&#123;        Log.e(TAG,<span class="hljs-string">&quot;onCreate&quot;</span>);        <span class="hljs-comment">// 初始化“集合视图”中的数据</span>        initListViewData();    &#125;    @Override    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getCount</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// 返回“集合视图”中的数据的总数</span>        <span class="hljs-keyword">return</span> mDevices.<span class="hljs-built_in">size</span>();    &#125;    @Override    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getItemId</span><span class="hljs-params">(<span class="hljs-keyword">int</span> <span class="hljs-built_in">position</span>)</span> </span>&#123;        <span class="hljs-comment">// 返回当前项在“集合视图”中的位置</span>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">position</span>;    &#125;    @Override    <span class="hljs-function"><span class="hljs-keyword">public</span> RemoteViews <span class="hljs-title">getLoadingView</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> null;    &#125;    @Override    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getViewTypeCount</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// 只有一类 ListView</span>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    &#125;    @Override    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasStableIds</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;    @Override    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onDataSetChanged</span><span class="hljs-params">()</span> </span>&#123;    &#125;    @Override    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onDestroy</span><span class="hljs-params">()</span> </span>&#123;        mDevices.<span class="hljs-built_in">clear</span>();    &#125;&#125;</code></pre><p>有了RemoteViewsFactory 还需要有RemoteViewsService才能与ListView关联起来。来看RemoteViewsService的实现类ListWidgetService，很简单，只重写了onGetViewFactory方法：</p><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListWidgetService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RemoteViewsService</span> </span>&#123;    <span class="hljs-meta">@Override</span>    public <span class="hljs-type">RemoteViewsService</span>.<span class="hljs-type">RemoteViewsFactory</span> onGetViewFactory(<span class="hljs-type">Intent</span> intent) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-type">ListRemoteViewsFactory</span>(<span class="hljs-keyword">this</span>, intent);    &#125;&#125;</code></pre><p>至此我们可以再次回到ListWidgetProvider中的onUpdate()方法，来看ListWidgetService 是如何与ListView关联到一起的了。</p><pre><code class="hljs reasonml"><span class="hljs-comment">//  设置 “ListView” 的adapter。</span><span class="hljs-comment">// (01) intent: 对应启动 ListWidgetService(RemoteViewsService) 的intent</span><span class="hljs-comment">// (02) setRemoteAdapter: 设置 ListView的适配器</span><span class="hljs-comment">//  通过setRemoteAdapter将ListView和ListWidgetService关联起来，</span><span class="hljs-comment">//  以达到通过 ListWidgetService 更新 ListView 的目的</span> Intent serviceIntent = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Intent(<span class="hljs-params">context</span>, ListWidgetService.<span class="hljs-params">class</span>)</span>; remoteViews.set<span class="hljs-constructor">RemoteAdapter(R.<span class="hljs-params">id</span>.<span class="hljs-params">lv_device</span>, <span class="hljs-params">serviceIntent</span>)</span>;</code></pre><h2 id="五-点击事件处理"><a href="#五-点击事件处理" class="headerlink" title="五.点击事件处理"></a>五.点击事件处理</h2><p>Widget中事件点击以及适配ListView，想必大家都有所了解了。那么对于事件的处理我们还没有提到，例如在Widget中点击了刷新后我们不能像在App中那样给控件设置一个事件监听来在回掉方法中处理。在文章开头我们就提到了Widget是依赖广播来实现，因此我们点击了刷新后其实仅仅是发送出来一个广播。如果我们不去处理广播那么点击事件其实是没有任何意义的。因此，来看ListWidgetProvider中第二个比较重要的方法onReceive()。这个方法比较简单，只要我们对特定的广播来做相应的处理就可以了。</p><pre><code class="hljs verilog">@Override    public <span class="hljs-keyword">void</span> onReceive(Context <span class="hljs-keyword">context</span>, Intent intent) &#123;        String action = intent<span class="hljs-variable">.getAction</span>();        AppWidgetManager appWidgetManager = AppWidgetManager<span class="hljs-variable">.getInstance</span>(<span class="hljs-keyword">context</span>);        <span class="hljs-keyword">if</span> (action<span class="hljs-variable">.equals</span>(COLLECTION_VIEW_ACTION)) &#123;<span class="hljs-comment">//处理列表中的事件</span>            <span class="hljs-comment">// 接受“ListView”的点击事件的广播</span>            <span class="hljs-keyword">int</span> <span class="hljs-keyword">type</span> = intent<span class="hljs-variable">.getIntExtra</span>(<span class="hljs-string">&quot;Type&quot;</span>, <span class="hljs-number">0</span>);            <span class="hljs-keyword">int</span> appWidgetId = intent<span class="hljs-variable">.getIntExtra</span>(AppWidgetManager<span class="hljs-variable">.EXTRA_APPWIDGET_ID</span>,                    AppWidgetManager<span class="hljs-variable">.INVALID_APPWIDGET_ID</span>);            <span class="hljs-keyword">int</span> index = intent<span class="hljs-variable">.getIntExtra</span>(COLLECTION_VIEW_EXTRA, <span class="hljs-number">0</span>);            switch (<span class="hljs-keyword">type</span>) &#123;                <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:                    Toast<span class="hljs-variable">.makeText</span>(<span class="hljs-keyword">context</span>, <span class="hljs-string">&quot;item&quot;</span> + index, Toast<span class="hljs-variable">.LENGTH_SHORT</span>)<span class="hljs-variable">.show</span>();                    <span class="hljs-keyword">break</span>;                <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:                    Toast<span class="hljs-variable">.makeText</span>(<span class="hljs-keyword">context</span>, <span class="hljs-string">&quot;lock&quot;</span>+index, Toast<span class="hljs-variable">.LENGTH_SHORT</span>)<span class="hljs-variable">.show</span>();                    <span class="hljs-keyword">break</span>;                <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:                    Toast<span class="hljs-variable">.makeText</span>(<span class="hljs-keyword">context</span>, <span class="hljs-string">&quot;unlock&quot;</span>+index, Toast<span class="hljs-variable">.LENGTH_SHORT</span>)<span class="hljs-variable">.show</span>();                    <span class="hljs-keyword">break</span>;            &#125;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (action<span class="hljs-variable">.equals</span>(REFRESH_WIDGET)) &#123;<span class="hljs-comment">//处理刷新事件</span>            <span class="hljs-comment">// 接受“bt_refresh”的点击事件的广播</span>            Toast<span class="hljs-variable">.makeText</span>(<span class="hljs-keyword">context</span>, <span class="hljs-string">&quot;刷新...&quot;</span>, Toast<span class="hljs-variable">.LENGTH_SHORT</span>)<span class="hljs-variable">.show</span>();            <span class="hljs-keyword">final</span> AppWidgetManager mgr = AppWidgetManager<span class="hljs-variable">.getInstance</span>(<span class="hljs-keyword">context</span>);            <span class="hljs-keyword">final</span> ComponentName cn = <span class="hljs-keyword">new</span> ComponentName(<span class="hljs-keyword">context</span>,ListWidgetProvider<span class="hljs-variable">.class</span>);            ListRemoteViewsFactory<span class="hljs-variable">.refresh</span>();            mgr<span class="hljs-variable">.notifyAppWidgetViewDataChanged</span>(mgr<span class="hljs-variable">.getAppWidgetIds</span>(cn),R<span class="hljs-variable">.id</span><span class="hljs-variable">.lv_device</span>);            mHandler<span class="hljs-variable">.postDelayed</span>(runnable,<span class="hljs-number">2000</span>);            showLoading(<span class="hljs-keyword">context</span>);        &#125;        <span class="hljs-keyword">super</span><span class="hljs-variable">.onReceive</span>(<span class="hljs-keyword">context</span>, intent);    &#125;</code></pre><p>最后，别忘了ListWidgetProvider是广播，ListWidgetService是服务，都需要我们在AndroidManifest文件中来注册：</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">receiver</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;.widget.ListWidgetProvider&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">intent-filter</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">action</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.appwidget.action.APPWIDGET_UPDATE&quot;</span> /&gt;</span>            <span class="hljs-comment">&lt;!-- ListWidgetProvider接收点击ListView的响应事件 --&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">action</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;com.oitsme.COLLECTION_VIEW_ACTION&quot;</span> /&gt;</span>            <span class="hljs-comment">&lt;!-- ListWidgetProvider接收点击bt_refresh的响应事件 --&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">action</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;com.oitsme.REFRESH_WIDGET&quot;</span> /&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">action</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;com.oitsme.LOCK_ACTION&quot;</span>/&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">action</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;com.oitsme.UNLOCK_ACTION&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">intent-filter</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">meta-data</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.appwidget.provider&quot;</span></span><span class="hljs-tag">            <span class="hljs-attr">android:resource</span>=<span class="hljs-string">&quot;@xml/widget_provider&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">receiver</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">service</span></span><span class="hljs-tag">        <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;.widget.ListWidgetService&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:permission</span>=<span class="hljs-string">&quot;android.permission.BIND_REMOTEVIEWS&quot;</span> /&gt;</span></code></pre><h2 id="六-小结"><a href="#六-小结" class="headerlink" title="六.小结"></a>六.小结</h2><p>至此关于列表小部件的讲解就完成了。只是自我感觉文章的逻辑有点乱。如果没明白，大家可以参考下面Demo源码。其实关于Widget的这个Demo其实早在几个月前就已经写好了，但由于最近项目紧再加上本身也是第一次接触Widget控件，因此直至近日才开始动笔写这篇文章。所以文章中避免不了有错误和不合理的地方，欢迎留言指正。</p><p>参考<br><a href="https://developer.android.com/guide/topics/appwidgets/">https://developer.android.com/guide/topics/appwidgets/</a></p><p><a href="https://download.csdn.net/download/qq_20521573/11659588">源码下载</a></p><h3 id="好库推荐"><a href="#好库推荐" class="headerlink" title="好库推荐"></a>好库推荐</h3><p>给大家推荐一下<a href="https://github.com/zhpanvip/BannerViewPager">BannerViewPager</a>。这是一个基于ViewPager实现的具有强大功能的无限轮播库。通过<a href="https://github.com/zhpanvip/BannerViewPager">BannerViewPager</a>可以实现腾讯视频、QQ音乐、酷狗音乐、支付宝、天猫、淘宝、优酷视频、喜马拉雅、网易云音乐、哔哩哔哩等APP的Banner样式以及指示器样式。</p><p>欢迎大家到github关注<a href="https://github.com/zhpanvip/BannerViewPager">BannerViewPager</a>！</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>关于Https的那些事儿</title>
    <link href="/2018/02/12/%E5%85%B3%E4%BA%8EHttps%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/"/>
    <url>/2018/02/12/%E5%85%B3%E4%BA%8EHttps%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/</url>
    
    <content type="html"><![CDATA[<p>*<strong>* 本篇文章已授权微信公众号 guolin_blog （郭霖）独家发布*</strong></p><p>由于前不久苹果公司已经强制IOS应用必须使用HTTPS协议开发，虽然Google没有强制开发者使用HTTPS，但相信不久的将来Android也会跟随IOS全面转向HTTPS。因此，HTTPS的学习也是相当重要。本篇文章涉及到的代码不多，主要内容是对HTTPS协议的讲解，最后将结合Retrofit实现HTTPS的单双向认证。</p><p>下面将通过以下几节内容来学习HTTPS。</p><ul><li>HTTPS概述 </li><li>HTTPS实现原理  </li><li>数字证书   </li><li>Https单项认证   </li><li>Https双向认证</li></ul><h2 id="一、HTTPS概述"><a href="#一、HTTPS概述" class="headerlink" title="一、HTTPS概述"></a>一、HTTPS概述</h2><p> <strong>1.什么是HTTPS？</strong><br> 我们看维基百科给HTTPS的定义：</p><blockquote><p>HTTPS（Hypertext Transfer Protocol Secure）是一种通过计算机网络进行安全通信的传输协议。HTTPS经由HTTP进行通信，但利用TLS来加密数据包。HTTPS开发的主要目的，是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。</p></blockquote><p>原来HTTPS就是在HTTP协议的基础上加入了TLS协议。目的是保证我们的数据在网络上传输的安全性。</p><blockquote><p>TLS是传输层加密协议，前身是SSL协议。由网景公司于1995年发布。后改名为TLS。常用的 TLS 协议版本有：TLS1.2, TLS1.1, TLS1.0 和 SSL3.0。其中 SSL3.0 由于 POODLE 攻击已经被证明不安全。TLS1.0 也存在部分安全漏洞，比如 RC4 和 BEAST 攻击。</p></blockquote><p>由于HTTP协议采用明文传输，我们可以通过抓包很轻松的获取到HTTP所传输的数据。因此，采用HTTP协议是不安全的。这才催生了HTTPS的诞生。HTTPS相对HTTP提供了更安全的数据传输保障。主要体现在三个方面：</p><blockquote><p>1，  内容加密。客户端到服务器的内容都是以加密形式传输，中间者无法直接查看明文内容。<br>2，  身份认证。通过校验保证客户端访问的是自己的服务器。<br>3，  数据完整性。防止内容被第三方冒充或者篡改。</p></blockquote><h2 id="二、HTTPS实现原理"><a href="#二、HTTPS实现原理" class="headerlink" title="二、HTTPS实现原理"></a>二、HTTPS实现原理</h2><p>在学习HTTPS原理之前我们先了解一下两种加密方式： 对称加密和非对称加密。<br><strong>对称加密</strong> 即加密和解密使用同一个密钥，虽然对称加密破解难度很大，但由于对称加密需要在网络上传输密钥和密文，一旦被黑客截取很容就能被破解，因此对称加密并不是一个较好的选择。<br><strong>非对称加密</strong> 即加密和解密使用不同的密钥，分别称为公钥和私钥。我们可以用公钥对数据进行加密，但必须要用私钥才能解密。在网络上只需要传送公钥，私钥保存在服务端用于解密公钥加密后的密文。但是非对称加密消耗的CPU资源非常大，效率很低，严重影响HTTPS的性能和速度。因此非对称加密也不是HTTPS的理想选择。</p><p>那么HTTPS采用了怎样的加密方式呢？其实为了提高安全性和效率HTTPS结合了对称和非对称两种加密方式。即客户端使用对称加密生成密钥（key）对传输数据进行加密，然后使用非对称加密的公钥再对key进行加密。因此网络上传输的数据是被key加密的密文和用公钥加密后的密文key，因此即使被黑客截取，由于没有私钥，无法获取到明文key，便无法获取到明文数据。所以HTTPS的加密方式是安全的。</p><p>接下来我们以TLS1.2为例来认识HTTPS的握手过程。</p><blockquote><p>1，  客户端发送 client_hello，包含一个随机数 random1。<br>2，  服务端回复 server_hello，包含一个随机数 random2，携带了证书公钥 P。<br>3，  客户端接收到 random2 之后就能够生成 premaster_secrect （对称加密的密钥）以及 master_secrect（用premaster_secret加密后的数据）。<br>4，  客户端使用证书公钥 P 将 premaster_secrect 加密后发送给服务器 (用公钥P对premaster_secret加密)。<br>5，  服务端使用私钥解密得到 premaster_secrect。又由于服务端之前就收到了随机数 1，所以服务端根据相同的生成算法，在相同的输入参数下，求出了相同的 master secrect。</p></blockquote><p>HTTPS的握手过程如下图：<br><img src="https://raw.githubusercontent.com/zhpanvip/Resource/master/image/1201.jfif"></p><h2 id="三、数字证书"><a href="#三、数字证书" class="headerlink" title="三、数字证书"></a>三、数字证书</h2><p>我们上面提到了HTTPS的工作原理，通过对称加密和非对称加密实现数据的安全传输。我们也知道非对称加密过程需要用到公钥进行加密。那么公钥从何而来？其实公钥就被包含在数字证书中。数字证书通常来说是由受信任的数字证书颁发机构CA，在验证服务器身份后颁发，证书中包含了一个密钥对（公钥和私钥）和所有者识别信息。数字证书被放到服务端，具有服务器身份验证和数据传输加密功能。</p><p>除了CA机构颁发的证书之外，还有非CA机构颁发的证书和自签名证书。</p><ul><li>非CA机构即是不受信任的机构颁发的证书，理所当然这样的证书是不受信任的。</li><li>自签名证书，就是自己给自己颁发的证书。当然自签名证书也是不受信任的。</li></ul><p>例如大(chou)名(ming)鼎(zhao)鼎(zhu)的12306网站使用的就是非CA机构颁发的证书（最近发现12306购票页面已经改为CA证书了），12306的证书是由SRCA颁发，SRCA中文名叫中铁数字证书认证中心，简称中铁CA。这是个铁道部自己搞的机构，相当于是自己给自己颁发证书。因此我们访问12306时通常会看到如下情景：<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTgwMjExMTczMjQ4NjE3?x-oss-process=image/format,png" alt="这里写图片描述"></p><p>说了这么多，我们来总结一下数字证书的两个作用：</p><blockquote><p>1， 分发公钥。每个数字证书都包含了注册者生成的公钥。在 TLS握手时会通过 certificate 消息传输给客户端。<br>2， 身份授权。确保客户端访问的网站是经过 CA 验证的可信任的网站。（在自签名证书的情况下可以验证是否是我们自己的服务器）</p></blockquote><p>最后我们从<a href="http://blog.csdn.net/dd864140130/article/details/52625666">别处</a>搬来一个中间人攻击的例子，来认识证书是如何保证我们的数据安全的。<br>对于一个正常的网络请求，其流程通常如下：<br><img src="https://raw.githubusercontent.com/zhpanvip/Resource/master/image/1203.jfif"></p><p>但是，如果有黑客在通信过程中拦截了这个请求。试想在客户端和服务端中间有一个中间人，两者之间的传输对中间人来说是透明的，那么中间人完全可以获取两端之间的任何数据并加以修改，然后转发给两端。其流程如下图：<br><img src="https://raw.githubusercontent.com/zhpanvip/Resource/master/image/1204.jfif"></p><p>此时恶意服务端完全可以发起双向攻击：对上可以欺骗服务端，对下可以欺骗客户端，更严重的是客户端段和服务端完全感知不到已经被攻击了。这就是所谓的中间人攻击。</p><blockquote><p>中间人攻击（MITM攻击）是指，黑客拦截并篡改网络中的通信数据。又分为被动MITM和主动MITM，被动MITM只窃取通信数据而不修改，而主动MITM不但能窃取数据，还会篡改通信数据。最常见的中间人攻击常常发生在公共wifi或者公共路由上。</p></blockquote><p>现在可以看看使用证书是怎么样提高安全性，避免中间人攻击的，用一张简单的流程图来说明：</p><p><img src="https://raw.githubusercontent.com/zhpanvip/Resource/master/image/1205.jfif"></p><h2 id="四、HTTPS单项认证"><a href="#四、HTTPS单项认证" class="headerlink" title=" 四、HTTPS单项认证"></a> 四、HTTPS单项认证</h2><p>所谓单项认证只要服务端配置证书，客户端在请求服务端时验证服务器的证书即可。我们上述讲到的内容其实都是说的HTTPS单项认证。通常来说对于安全性要求不高的网站单项认证就可以满足我们的需求了。因此我们访问的HTTPS网站大部分都是单项认证。</p><p><strong>1.关于HTTPS的使用存在的误区</strong><br>由于我们对安全性的认识不够重视，通常对于HTTPS存在一些误区，这些误区可能直接给我们带来一些安全隐患。<br>*<strong>误区（1）：对于CA机构颁发的证书客户端无须内置***<br>上面提到访问HTTPS服务器是需要在客户端配置服务器证书的。有些小伙伴可能就纳闷了，说我们用的就是HTTPS但是并没有在客户端配置证书呢？比如请求百度的网站<a href="https://www.baidu.com/%EF%BC%8C%E5%92%8C%E8%AF%B7%E6%B1%82HTTP%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%B2%A1%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%E3%80%82%E5%85%B6%E5%AE%9E%E8%BF%99%E6%98%AF%E5%9B%A0%E4%B8%BA%E5%9C%A8Android%E7%B3%BB%E7%BB%9F%E4%B8%AD%E5%B7%B2%E7%BB%8F%E5%86%85%E7%BD%AE%E4%BA%86%E6%89%80%E6%9C%89CA%E6%9C%BA%E6%9E%84%E7%9A%84%E6%A0%B9%E8%AF%81%E4%B9%A6%EF%BC%8C%E4%B9%9F%E5%B0%B1%E6%98%AF%E5%8F%AA%E8%A6%81%E6%98%AFCA%E6%9C%BA%E6%9E%84%E9%A2%81%E5%8F%91%E7%9A%84%E8%AF%81%E4%B9%A6%EF%BC%8CAndroid%E6%98%AF%E7%9B%B4%E6%8E%A5%E4%BF%A1%E4%BB%BB%E7%9A%84%E3%80%82%E5%AF%B9%E4%BA%8E%E6%AD%A4%E7%A7%8D%E6%83%85%E5%86%B5%EF%BC%8C%E8%99%BD%E7%84%B6%E5%8F%AF%E4%BB%A5%E6%AD%A3%E5%B8%B8%E8%AE%BF%E9%97%AE%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%8C%E4%BD%86%E6%98%AF%E4%BB%8D%E7%84%B6%E5%AD%98%E5%9C%A8%E5%AE%89%E5%85%A8%E9%9A%90%E6%82%A3%E3%80%82%E5%81%87%E5%A6%82%E9%BB%91%E5%AE%A2%E8%87%AA%E5%AE%B6%E6%90%AD%E5%BB%BA%E4%BA%86%E4%B8%80%E4%B8%AA%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%B9%B6%E7%94%B3%E8%AF%B7%E5%88%B0%E4%BA%86CA%E8%AF%81%E4%B9%A6%EF%BC%8C%E7%94%B1%E4%BA%8E%E6%88%91%E4%BB%AC%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%B2%A1%E6%9C%89%E5%86%85%E7%BD%AE%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AF%81%E4%B9%A6%EF%BC%8C%E9%BB%98%E8%AE%A4%E4%BF%A1%E4%BB%BB%E6%89%80%E6%9C%89CA%E8%AF%81%E4%B9%A6%EF%BC%88%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%8F%AF%E4%BB%A5%E8%AE%BF%E9%97%AE%E6%89%80%E6%9C%89%E6%8C%81%E6%9C%89%E7%94%B1CA%E6%9C%BA%E6%9E%84%E9%A2%81%E5%8F%91%E7%9A%84%E8%AF%81%E4%B9%A6%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%89%EF%BC%8C%E9%82%A3%E4%B9%88%E9%BB%91%E5%AE%A2%E4%BB%8D%E7%84%B6%E5%8F%AF%E4%BB%A5%E5%8F%91%E8%B5%B7%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB%E5%8A%AB%E6%8C%81%E6%88%91%E4%BB%AC%E7%9A%84%E8%AF%B7%E6%B1%82%E5%88%B0%E9%BB%91%E5%AE%A2%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%8C%E5%AE%9E%E9%99%85%E4%B8%8A%E5%B0%B1%E6%88%90%E4%BA%86%E6%88%91%E4%BB%AC%E7%9A%84%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%92%8C%E9%BB%91%E5%AE%A2%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BB%BA%E7%AB%8B%E8%B5%B7%E4%BA%86%E8%BF%9E%E6%8E%A5%E3%80%82">https://www.baidu.com/，和请求HTTP服务器没什么区别。其实这是因为在Android系统中已经内置了所有CA机构的根证书，也就是只要是CA机构颁发的证书，Android是直接信任的。对于此种情况，虽然可以正常访问到服务器，但是仍然存在安全隐患。假如黑客自家搭建了一个服务器并申请到了CA证书，由于我们客户端没有内置服务器证书，默认信任所有CA证书（客户端可以访问所有持有由CA机构颁发的证书的服务器），那么黑客仍然可以发起中间人攻击劫持我们的请求到黑客的服务器，实际上就成了我们的客户端和黑客的服务器建立起了连接。</a><br>*</strong>误区（2）：对于非CA机构颁发的证书和自签名证书，可以忽略证书校验***<br>另外一种情况，如果我们服务器的证书是非认证机构颁发的 (例如12306)或者自签名证书，那么我们是无法直接访问到服务器的，直接访问通常会抛出如下异常：</p><pre><code class="hljs css"><span class="hljs-selector-tag">javax</span><span class="hljs-selector-class">.net</span><span class="hljs-selector-class">.ssl</span><span class="hljs-selector-class">.SSLHandshakeException</span>:     <span class="hljs-selector-tag">java</span><span class="hljs-selector-class">.security</span><span class="hljs-selector-class">.cert</span><span class="hljs-selector-class">.CertPathValidatorException</span>:         <span class="hljs-selector-tag">Trust</span> <span class="hljs-selector-tag">anchor</span> <span class="hljs-selector-tag">for</span> <span class="hljs-selector-tag">certification</span> <span class="hljs-selector-tag">path</span> <span class="hljs-selector-tag">not</span> <span class="hljs-selector-tag">found</span>.</code></pre><p>网上很多解决SSLHandshakeException异常的方案是自定义TrustManager忽略证书校验。代码如下：</p><pre><code class="hljs aspectj"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-function">SSLSocketFactory <span class="hljs-title">getSSLSocketFactory</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">//创建一个不验证证书链的证书信任管理器。</span>        <span class="hljs-keyword">final</span> TrustManager[] trustAllCerts = <span class="hljs-keyword">new</span> TrustManager[]&#123;<span class="hljs-keyword">new</span> X509TrustManager() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> checkClientTrusted(                    java.security.cert.X509Certificate[] chain,                    String authType) <span class="hljs-keyword">throws</span> CertificateException &#123;            &#125;            <span class="hljs-meta">@Override</span>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> checkServerTrusted(                    java.security.cert.X509Certificate[] chain,                    String authType) <span class="hljs-keyword">throws</span> CertificateException &#123;            &#125;            <span class="hljs-meta">@Override</span>            <span class="hljs-keyword">public</span> java.security.cert.X509Certificate[] getAcceptedIssuers() &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> java.security.cert.X509Certificate[<span class="hljs-number">0</span>];            &#125;        &#125;&#125;;        <span class="hljs-comment">// Install the all-trusting trust manager</span>        <span class="hljs-keyword">final</span> SSLContext sslContext = SSLContext.getInstance(<span class="hljs-string">&quot;TLS&quot;</span>);        sslContext.init(<span class="hljs-keyword">null</span>, trustAllCerts,                <span class="hljs-keyword">new</span> java.security.SecureRandom());        <span class="hljs-comment">// Create an ssl socket factory with our all-trusting manager</span>        <span class="hljs-keyword">return</span> sslContext                .getSocketFactory();    &#125;  <span class="hljs-comment">//使用自定义SSLSocketFactory</span>  <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onHttps</span><span class="hljs-params">(OkHttpClient.Builder builder)</span> </span>&#123;       <span class="hljs-keyword">try</span> &#123;            builder.sslSocketFactory(getSSLSocketFactory()).hostnameVerifier(org.apache.http.conn.ssl.SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;</code></pre><p>对于这样的处理方式虽然解决了SSLHandshakeException异常，但是却存在更大的安全隐患。因为此种做法直接使我们的客户端信任了所有证书（包括CA机构颁发的证书和非CA机构颁发的证书以及自签名证书），因此，这样配置将比第一种情况危害更大。</p><p><strong>2.Retrofit绑定证书实现HTTPS单项认证</strong><br>对于上述两种情况中存在的安全隐患，我们应该如何应对？最简单的解决方案就是在客户端内置服务器的证书，我们在校验服务端证书的时候只比对和App内置的证书是否完全相同，如果不同则断开连接。那么此时再遭遇中间人攻击劫持我们的请求时由于黑客服务器没有相应的证书，此时HTTPS请求校验不通过，则无法与黑客的服务器建立起连接。</p><p>那么接下来我们就结合Retrofit以访问12306为例来实现HTTPS的单项认证。<br>首先从12306网站下载签名证书，并放置到我们项目资源目录raw下。然后根据证书构造SSLSocketFactory，代码如下：</p><pre><code class="hljs reasonml"><span class="hljs-comment">/**</span><span class="hljs-comment">    * 单项认证</span><span class="hljs-comment">    */</span>   public static SSLSocketFactory get<span class="hljs-constructor">SSLSocketFactoryForOneWay(InputStream<span class="hljs-operator">...</span> <span class="hljs-params">certificates</span>)</span> &#123;       <span class="hljs-keyword">try</span> &#123;           CertificateFactory certificateFactory = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">CertificateFactory</span>.</span></span>get<span class="hljs-constructor">Instance(CLIENT_TRUST_MANAGER, CLIENT_TRUST_PROVIDER)</span>;           KeyStore keyStore = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">KeyStore</span>.</span></span>get<span class="hljs-constructor">Instance(CLIENT_TRUST_KEYSTORE)</span>;           keyStore.load(null);           <span class="hljs-built_in">int</span> index = <span class="hljs-number">0</span>;           <span class="hljs-keyword">for</span> (InputStream certificate : certificates) &#123;               String certificateAlias = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Integer</span>.</span></span><span class="hljs-keyword">to</span><span class="hljs-constructor">String(<span class="hljs-params">index</span><span class="hljs-operator">++</span>)</span>;               keyStore.set<span class="hljs-constructor">CertificateEntry(<span class="hljs-params">certificateAlias</span>, <span class="hljs-params">certificateFactory</span>.<span class="hljs-params">generateCertificate</span>(<span class="hljs-params">certificate</span>)</span>);               <span class="hljs-keyword">try</span> &#123;                   <span class="hljs-keyword">if</span> (certificate != null)                       certificate.close<span class="hljs-literal">()</span>;               &#125; catch (IOException e) &#123;                   e.print<span class="hljs-constructor">StackTrace()</span>;               &#125;           &#125;           SSLContext sslContext = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">SSLContext</span>.</span></span>get<span class="hljs-constructor">Instance(CLIENT_AGREEMENT)</span>;           TrustManagerFactory trustManagerFactory =                   <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">TrustManagerFactory</span>.</span></span>get<span class="hljs-constructor">Instance(TrustManagerFactory.<span class="hljs-params">getDefaultAlgorithm</span>()</span>);           trustManagerFactory.init(keyStore);           sslContext.init(null, trustManagerFactory.get<span class="hljs-constructor">TrustManagers()</span>, <span class="hljs-keyword">new</span> <span class="hljs-constructor">SecureRandom()</span>);           return sslContext.get<span class="hljs-constructor">SocketFactory()</span>;       &#125; catch (Exception e) &#123;           e.print<span class="hljs-constructor">StackTrace()</span>;       &#125;       return null;   &#125;</code></pre><p>接下来为OKHttpClient设置SslSocketFactory以及hostnameVerifier，代码如下：</p><pre><code class="hljs reasonml">InputStream certificate12306 = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Utils</span>.</span></span>get<span class="hljs-constructor">Context()</span>.get<span class="hljs-constructor">Resources()</span>.<span class="hljs-keyword">open</span><span class="hljs-constructor">RawResource(R.<span class="hljs-params">raw</span>.<span class="hljs-params">srca</span>)</span>;        OkHttpClient okHttpClient = <span class="hljs-keyword">new</span> OkHttpClient.<span class="hljs-constructor">Builder()</span>                .read<span class="hljs-constructor">Timeout(Constants.DEFAULT_TIMEOUT, TimeUnit.MILLISECONDS)</span>                .connect<span class="hljs-constructor">Timeout(Constants.DEFAULT_TIMEOUT, TimeUnit.MILLISECONDS)</span>                .add<span class="hljs-constructor">Interceptor(<span class="hljs-params">interceptor</span>)</span>                .add<span class="hljs-constructor">Interceptor(<span class="hljs-params">new</span> HttpHeaderInterceptor()</span>)                .add<span class="hljs-constructor">NetworkInterceptor(<span class="hljs-params">new</span> HttpCacheInterceptor()</span>)                .ssl<span class="hljs-constructor">SocketFactory(SslContextFactory.<span class="hljs-params">getSSLSocketFactoryForOneWay</span>(<span class="hljs-params">certificate12306</span>)</span>)                  .hostname<span class="hljs-constructor">Verifier(<span class="hljs-params">new</span> SafeHostnameVerifier()</span>)                .cache(cache)                .build<span class="hljs-literal">()</span>;</code></pre><p>上述代码中hostnameVerifier是对服务器的校验，SafeHostnameVerifier代码如下：</p><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SafeHostnameVerifier</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HostnameVerifier</span> </span>&#123;       <span class="hljs-meta">@Override</span>       <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">verify</span><span class="hljs-params">(String hostname, SSLSession session)</span> </span>&#123;           <span class="hljs-keyword">if</span> (Constants.IP.equals(hostname)) &#123;<span class="hljs-comment">//校验hostname是否正确，如果正确则建立连接</span>               <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;           &#125;           <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;       &#125;   &#125;</code></pre><p>verify方法中对比了请求的IP和服务器的IP是否一致，一致则返回true表示校验通过，否则返回false，检验不通过，断开连接。对于网上有些处理是直接返回true，即不对请求的服务器IP做校验，我们不推荐这样使用。而且现在谷歌应用商店已经对此种做法做了限制，禁止在verify方法中直接返回true的App上线。</p><h2 id="五、HTTPS双向认证"><a href="#五、HTTPS双向认证" class="headerlink" title=" 五、HTTPS双向认证"></a> 五、HTTPS双向认证</h2><p>对于HTTPS双向认证，用到的情况不多。但是对于像金融行业等对安全性要求较高的企业，通常都会使用双向认证。所谓双向认证就是客户端校验服务器证书，同时服务器也需要校验客户端的证书。因此，双向认证就另需一张证书放到客户端待服务端去验证。</p><blockquote><p>单项认证保证了我们自己的客户端只能访问我们自己的服务器，但并不能保证我们自己的服务器只能被我们自己的客户端访问（第三方客户端忽略证书校验即可）。那么双向认证则保证了我们的客户端只能访问我们自己的服务器，同时我们的服务器也只能被我们自己的客户端访问。因此双向认证可以说相比单项认证安全性足足提高一个等级。</p></blockquote><p><strong>1.双向认证流程</strong><br>接下来我们来了解下双向认证的流程，以加深对双向认证的理解：</p><blockquote><p>a. 客户端发送一个连接请求给服务器。<br>　　b. 服务器将自己的证书，以及同证书相关的信息发送给客户端。<br>　　c. 客户端检查服务器送过来的证书是否和App内置证书相同。如果是，就继续执行协议；如果不是则终止此次请求。<br>　　d. 接着客户端比较证书里的消息，例如域名和公钥，与服务器刚刚发送的相关消息是否一致，如果是一致的，客户端认可这个服务器的合法身份。<br>　　e. 服务器要求客户发送客户自己的证书。收到后，服务器验证客户端的证书，如果没有通过验证，拒绝连接；如果通过验证，服务器获得用户的公钥。<br>　　f. 客户端告诉服务器自己所能够支持的通讯对称密码方案。<br>　　g. 服务器从客户发送过来的密码方案中，选择一种加密程度最高的密码方案，用客户的公钥加过密后通知客户端。<br>　　h. 客户端针对这个密码方案，选择一个通话密钥，接着用服务器的公钥加过密后发送给服务器。<br>　　i. 服务器接收到客户端送过来的消息，用自己的私钥解密，获得通话密钥。<br>　　j. 服务器通过密钥解密客户端发送的被加密数据，得到明文数据。</p></blockquote><p><strong>2.Retrofit实现HTTPS双向认证</strong><br>对于双向认证，我们以华为北向平台登录接口为例来进行学习。想了解华为北向API<a href="http://developer.huawei.com/ict/cn/doc/site-oceanconnect-northbound_api_reference-zh/index.html/zh-cn_topic_0087306564">请戳此处</a><br>我们直接通过浏览器访问登录接口可以看到如下情景：<br><img src="https://raw.githubusercontent.com/zhpanvip/Resource/master/image/1206.jfif"></p><p>哈，惊喜不？直接被拒绝了！这就是双向认证，没有证书想访问服务器门都没有。那么对于双向认证我们应该做怎样的配置？我们可以参考华为开源出来的代码<a href="https://github.com/Huawei/IoT_OceanConnect_North_GUI_APPDemo">戳此处</a><br>源码中由两个证书文件ca.jks和outgoing.CertwithKey.pkcs12，其中ca.jks是在客户端配置的证书，outgoing.CertwithKey.pkcs12是在服务端配置的证书。因为我们当前客户端是Android系统，由于Android系统不支持jks格式的证书，因此需要把jks转成Android支持的bks格式。转换方式不再贴出，可自行查阅。<br>有了证书，接下来看获取SSLSocketFactory的代码：</p><pre><code class="hljs reasonml"><span class="hljs-comment">/**</span><span class="hljs-comment">   * 双向认证</span><span class="hljs-comment">   *</span><span class="hljs-comment">   * @return SSLSocketFactory</span><span class="hljs-comment">   */</span>  public static SSLSocketFactory get<span class="hljs-constructor">SSLSocketFactoryForTwoWay()</span> &#123;      <span class="hljs-keyword">try</span> &#123;          InputStream certificate = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Utils</span>.</span></span>get<span class="hljs-constructor">Context()</span>.get<span class="hljs-constructor">Resources()</span>.<span class="hljs-keyword">open</span><span class="hljs-constructor">RawResource(R.<span class="hljs-params">raw</span>.<span class="hljs-params">capk</span>)</span>;          <span class="hljs-comment">//  CertificateFactory certificateFactory = CertificateFactory.getInstance(&quot;X.509&quot;, &quot;BC&quot;);</span>          KeyStore keyStore = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">KeyStore</span>.</span></span>get<span class="hljs-constructor">Instance(CLIENT_TRUST_KEY)</span>;          keyStore.load(certificate, <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">SELF_CERT_PWD</span>.</span></span><span class="hljs-keyword">to</span><span class="hljs-constructor">CharArray()</span>);          KeyManagerFactory kmf = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">KeyManagerFactory</span>.</span></span>get<span class="hljs-constructor">Instance(KeyManagerFactory.<span class="hljs-params">getDefaultAlgorithm</span>()</span>);          kmf.init(keyStore, <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">SELF_CERT_PWD</span>.</span></span><span class="hljs-keyword">to</span><span class="hljs-constructor">CharArray()</span>);          <span class="hljs-keyword">try</span> &#123;              <span class="hljs-keyword">if</span> (certificate != null)                  certificate.close<span class="hljs-literal">()</span>;          &#125; catch (IOException e) &#123;              e.print<span class="hljs-constructor">StackTrace()</span>;          &#125;          <span class="hljs-comment">//初始化keystore</span>          KeyStore clientKeyStore = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">KeyStore</span>.</span></span>get<span class="hljs-constructor">Instance(CLIENT_TRUST_KEYSTORE)</span>;          clientKeyStore.load(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Utils</span>.</span></span>get<span class="hljs-constructor">Context()</span>.get<span class="hljs-constructor">Resources()</span>.<span class="hljs-keyword">open</span><span class="hljs-constructor">RawResource(R.<span class="hljs-params">raw</span>.<span class="hljs-params">cabks</span>)</span>, <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">TRUST_CA_PWD</span>.</span></span><span class="hljs-keyword">to</span><span class="hljs-constructor">CharArray()</span>);          SSLContext sslContext = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">SSLContext</span>.</span></span>get<span class="hljs-constructor">Instance(CLIENT_AGREEMENT)</span>;          TrustManagerFactory trustManagerFactory = TrustManagerFactory.                  get<span class="hljs-constructor">Instance(TrustManagerFactory.<span class="hljs-params">getDefaultAlgorithm</span>()</span>);          trustManagerFactory.init(clientKeyStore);          KeyManagerFactory keyManagerFactory = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">KeyManagerFactory</span>.</span></span>get<span class="hljs-constructor">Instance(KeyManagerFactory.<span class="hljs-params">getDefaultAlgorithm</span>()</span>);          keyManagerFactory.init(clientKeyStore, <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">SELF_CERT_PWD</span>.</span></span><span class="hljs-keyword">to</span><span class="hljs-constructor">CharArray()</span>);          sslContext.init(kmf.get<span class="hljs-constructor">KeyManagers()</span>, trustManagerFactory.get<span class="hljs-constructor">TrustManagers()</span>, <span class="hljs-keyword">new</span> <span class="hljs-constructor">SecureRandom()</span>);          return sslContext.get<span class="hljs-constructor">SocketFactory()</span>;      &#125; catch (Exception e) &#123;          e.print<span class="hljs-constructor">StackTrace()</span>;      &#125;      return null;  &#125;</code></pre><p>接下来同样需要配置OKHttpClient，代码如下：</p><pre><code class="hljs reasonml">OkHttpClient okHttpClient = <span class="hljs-keyword">new</span> OkHttpClient.<span class="hljs-constructor">Builder()</span>                .read<span class="hljs-constructor">Timeout(Constants.DEFAULT_TIMEOUT, TimeUnit.MILLISECONDS)</span>                .connect<span class="hljs-constructor">Timeout(Constants.DEFAULT_TIMEOUT, TimeUnit.MILLISECONDS)</span>                .add<span class="hljs-constructor">Interceptor(<span class="hljs-params">interceptor</span>)</span>                .add<span class="hljs-constructor">Interceptor(<span class="hljs-params">new</span> HttpHeaderInterceptor()</span>)                .add<span class="hljs-constructor">NetworkInterceptor(<span class="hljs-params">new</span> HttpCacheInterceptor()</span>)                .ssl<span class="hljs-constructor">SocketFactory(SslContextFactory.<span class="hljs-params">getSSLSocketFactoryForTwoWay</span>()</span>)                 .hostname<span class="hljs-constructor">Verifier(<span class="hljs-params">new</span> SafeHostnameVerifier()</span>)                .cache(cache)                .build<span class="hljs-literal">()</span>;</code></pre><p>这样就完成了HTTPS的配置，接下来就可以愉快的访问HTTPS 双向认证的接口了。由于北向登录接口中需要appId和secret两个参数，因此，登录相关代码就不再贴出。</p><p>好了，到此关于HTTPS的学习就结束了，如果有不明白的地方可以参看文末源码。以上内容纯属个人对HTTPS的一些认识，如果文中有错误之处还请多多包涵，欢迎留言指正。</p><p>本文写成参考了大量的相关文章，在此表示感谢。</p><p><a href="https://github.com/zhpanvip/Retrofit2/tree/master/idea/src/main/java/com/zhpan/idea/net/https">源码参考</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://blog.jobbole.com/86660/">大型网站的 HTTPS 实践（1）：HTTPS 协议和原理</a><br><a href="http://blog.csdn.net/dd864140130/article/details/52625666">Retrofit中如何正确的使用https？</a><br><a href="http://blog.csdn.net/lmj623565791/article/details/48129405">Android Https相关完全解析 当OkHttp遇到Https</a><br><a href="https://www.jianshu.com/p/f2097616e65e">HTTPS原理及OKHTTP对HTTPS的支持</a></p><h3 id="好库推荐"><a href="#好库推荐" class="headerlink" title="好库推荐"></a>好库推荐</h3><p>给大家推荐一下<a href="https://github.com/zhpanvip/BannerViewPager">BannerViewPager</a>。这是一个基于ViewPager实现的具有强大功能的无限轮播库。通过<a href="https://github.com/zhpanvip/BannerViewPager">BannerViewPager</a>可以实现腾讯视频、QQ音乐、酷狗音乐、支付宝、天猫、淘宝、优酷视频、喜马拉雅、网易云音乐、哔哩哔哩等APP的Banner样式以及指示器样式。</p><p>欢迎大家到github关注<a href="https://github.com/zhpanvip/BannerViewPager">BannerViewPager</a>！</p>]]></content>
    
    
    
    <tags>
      
      <tag>https</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>追根溯源--探究Handler的实现原理</title>
    <link href="/2017/09/10/%E8%BF%BD%E6%A0%B9%E6%BA%AF%E6%BA%90-%E6%8E%A2%E7%A9%B6Handler%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <url>/2017/09/10/%E8%BF%BD%E6%A0%B9%E6%BA%AF%E6%BA%90-%E6%8E%A2%E7%A9%B6Handler%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="一、初识Handler"><a href="#一、初识Handler" class="headerlink" title="一、初识Handler"></a>一、初识Handler</h2><p>要分析一个框架的源码，首先需要了解它的使用。我们就从最基础的知识开始吧！</p><h3 id="场景1：将数据从子线程发送到主线程。"><a href="#场景1：将数据从子线程发送到主线程。" class="headerlink" title="场景1：将数据从子线程发送到主线程。"></a>场景1：将数据从子线程发送到主线程。</h3><p>我们知道Android系统中更新UI只能在主线程中进行。而通常网络请求实在子线程中进行的。在获取到服务器数据后我们需要切换到主线程来更新UI。通常在这种情况下我们会考虑使用Handler来进行线程切换。我们来模拟一个网络请求，并通过Handler将数据发送出去：</p><pre><code class="hljs java"><span class="hljs-keyword">private</span> Handler mHandler = <span class="hljs-keyword">new</span> Handler()&#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dispatchMessage</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Message msg)</span> </span>&#123;            <span class="hljs-keyword">super</span>.dispatchMessage(msg);            updateUI(msg);        &#125;    &#125;;<span class="hljs-comment">// 或者可以通过传入Handler.Callback的参数</span>Handler mHandler = <span class="hljs-keyword">new</span> Handler(<span class="hljs-keyword">new</span> Handler.Callback() &#123;       <span class="hljs-meta">@Override</span>       <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">handleMessage</span><span class="hljs-params">(Message msg)</span> </span>&#123;updateUI(msg);           <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;       &#125;   &#125;);    <span class="hljs-comment">// 模拟网络请求</span> <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fetchData</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">new</span> Thread()&#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                <span class="hljs-keyword">super</span>.run();                Message message = mHandler.obtainMessage();                message.obj=<span class="hljs-string">&quot;data from server&quot;</span>;                mHandler.sendMessage(message);            &#125;        &#125;.start();    &#125;</code></pre><p>我们通过子线程模拟网络请求，并将获取的数据通过Handler的sendMessage方法将数据发送了出去。而在Handler的dispatchMessage方法中便可收到刚刚发送的message。并且此时dispatchMessage处于主线程，因此可以直接在dispatchMessage方法中更新UI了。</p><h3 id="场景2：延迟发送Runnable"><a href="#场景2：延迟发送Runnable" class="headerlink" title="场景2：延迟发送Runnable"></a>场景2：延迟发送Runnable</h3><p>场景1是Handler很典型的一个应用，除此之外，我们还经常会通过Handler延迟发送一个Runnable，在delayMillis时间之后会执行Runnable的run方法。代码示例如下：</p><pre><code class="hljs java"><span class="hljs-comment">// 假设是运行在Activity中的代码</span><span class="hljs-keyword">private</span> Handler mHandler = <span class="hljs-keyword">new</span> Handler();<span class="hljs-keyword">private</span> Runnable mRunnable = <span class="hljs-keyword">new</span> Runnable() &#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;            handleMessage();        &#125;    &#125;; <span class="hljs-meta">@Override</span>   <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> </span>&#123;       <span class="hljs-keyword">super</span>.onCreate(savedInstanceState); <span class="hljs-keyword">new</span> Thread()&#123;           <span class="hljs-meta">@Override</span>           <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;               <span class="hljs-keyword">super</span>.run();               mHandler.postDelayed(mRunnable,<span class="hljs-number">1000</span>);           &#125;       &#125;.start();&#125;</code></pre><h3 id="场景3：在子线程中初始化Handler"><a href="#场景3：在子线程中初始化Handler" class="headerlink" title="场景3：在子线程中初始化Handler"></a>场景3：在子线程中初始化Handler</h3><pre><code class="hljs java">Handler mHandler;<span class="hljs-keyword">new</span> Thread()&#123;           <span class="hljs-meta">@Override</span>           <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;               <span class="hljs-keyword">super</span>.run();               mHandler=<span class="hljs-keyword">new</span> Handler();           &#125;       &#125;.start();</code></pre><p>此时，运行程序我们会发现程序Crash掉了，并且抛出了以下错误日志：</p><blockquote><p>java.lang.RuntimeException: Can’t create handler inside thread that has not called Looper.prepare()</p></blockquote><p>日志信息提示我们在子线程中创建Handler需要调用Looper.prepare()方法。</p><p>(注:以上场景均未考虑内存泄露问题)</p><p>那么针对以上三个应用场景，有些同学可能表示会有问题：</p><p><strong>问题1：</strong> 在场景1中Handler在子线程中发送出来的消息为什么到了dispatchMessage方法就变成了主线程呢？</p><p><strong>问题2：</strong> 在场景2的代码中我故意在子线程中调用了Handler的postDelayed方法，那么此时通过postDelayed方法发出来的Runnable究竟是运行在主线程还是子线程呢？</p><p><strong>问题3：</strong>  为什么在主线程中直接创建Handler可以正常运行而在子线程中创建Handler需要调用Looper.prepare()方法呢？</p><p>如果想要解开以上几个疑惑，就需要我们对Handler的源码有深入的了解。那么接下来我们就进入Handler的源码分析环节吧！</p><h2 id="二、Handler源码溯源历程"><a href="#二、Handler源码溯源历程" class="headerlink" title="二、Handler源码溯源历程"></a>二、Handler源码溯源历程</h2><h3 id="1-从实例化一个Handler说起"><a href="#1-从实例化一个Handler说起" class="headerlink" title="1.从实例化一个Handler说起"></a>1.从实例化一个Handler说起</h3><p>在使用Handler的第一步就需要我们先实例化一个Handler。那么，我们就从new Handler()着手，看看在初始化Handler的时候做了哪些操作：</p><pre><code class="hljs java"><span class="hljs-keyword">final</span> Looper mLooper;   <span class="hljs-keyword">final</span> MessageQueue mQueue;<span class="hljs-keyword">final</span> Callback mCallback;   <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> mAsynchronous;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Handler</span><span class="hljs-params">()</span> </span>&#123;       <span class="hljs-keyword">this</span>(<span class="hljs-keyword">null</span>, <span class="hljs-keyword">false</span>);   &#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Handler</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> Callback callback, <span class="hljs-keyword">boolean</span> async)</span> </span>&#123;        <span class="hljs-keyword">if</span> (FIND_POTENTIAL_LEAKS) &#123;            <span class="hljs-keyword">final</span> Class&lt;? extends Handler&gt; klass = getClass();            <span class="hljs-keyword">if</span> ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;                    (klass.getModifiers() &amp; Modifier.STATIC) == <span class="hljs-number">0</span>) &#123;                Log.w(TAG, <span class="hljs-string">&quot;The following Handler class should be static or leaks might occur: &quot;</span> +                    klass.getCanonicalName());            &#125;        &#125;        mLooper = Looper.myLooper();        <span class="hljs-keyword">if</span> (mLooper == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(                <span class="hljs-string">&quot;Can&#x27;t create handler inside thread &quot;</span> + Thread.currentThread()                        + <span class="hljs-string">&quot; that has not called Looper.prepare()&quot;</span>);        &#125;        mQueue = mLooper.mQueue;        mCallback = callback;        mAsynchronous = async;    &#125;</code></pre><p>可以看到，调用Handler的无参构造方法实例化Handler最终调用了Handler(@Nullable Callback callback, boolean async)的构造方法，而在这个构造方法中的逻辑似乎也很简单，通过调用Looper.myLooper()方法得到了一个Looper对象，如果此时mLooper为null，则会抛出一个RuntimeException。仔细看看发现这个异常信息不就是我们在第一章场景三中在子线程中初始化Handler的时候抛出来的异常吗？那么，什么时候通过Looper.myPrepare()方法得到的Handler会是空呢？要解决这个问题怕是要到Looper中一探究竟了。</p><p>首先来看下Looper.myPrepare()方法的源码：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-meta">@Nullable</span> <span class="hljs-function">Looper <span class="hljs-title">myLooper</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> sThreadLocal.get();&#125;</code></pre><p>这是Looper中的一个静态方法，这个方法简单到只有一行代码，即调用了ThreadLocal的get()方法来得到一个Looper。ThreadLocal是Java中的一个类，它是一个泛型类，有set(T)和T get()两个方法。ThreadLocal的神奇之处在于它可以在指定线程中存储数据，什么意思呢？即你在某个线程中存储的数据只能在该线程中获取的到。关于ThreadLocal我们只需要了解这些就够了，其实现原理不做深究，有兴趣的可以自从查阅源码。</p><p>既然了解了ThreadLocal的作用，那么在Looper内部一定事先调用了ThreadLocal的set方法。通过全局搜索sThreadLocal，发现了prepare()方法，其源码如下：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">prepare</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> quitAllowed)</span> </span>&#123;     <span class="hljs-keyword">if</span> (sThreadLocal.get() != <span class="hljs-keyword">null</span>) &#123;         <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;Only one Looper may be created per thread&quot;</span>);     &#125;     sThreadLocal.set(<span class="hljs-keyword">new</span> Looper(quitAllowed)); &#125;</code></pre><p>果真如我们预料的那样，在Looper的prepare方法中实例化了Looper，并将其放入到了ThreadLocal中。而如果没有调用Looper.prepare()方法，那么获取到的Looper一定是null。到这里似乎解释了第一章的场景三在子线程中实例化Handler需要事先调用Looper.prepare()方法。但是，到这里我们似乎还是没有解释清楚疑惑三，为什么在主线程中直接实例化Handler却没有抛出异常呢？其实，当程序启动的时候会同时启动主线程，我们知道Java程序的入口是main方法。而在Android程序启动的入口同样是main方法。我们在ActivityThread中找到main方法，源码如下：</p><pre><code class="hljs java"># ActivityThread<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        ...        Looper.prepareMainLooper();...        Looper.loop();        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;Main thread loop unexpectedly exited&quot;</span>);    &#125; # Looper <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">prepareMainLooper</span><span class="hljs-params">()</span> </span>&#123;        prepare(<span class="hljs-keyword">false</span>);        <span class="hljs-keyword">synchronized</span> (Looper.class) &#123;            <span class="hljs-keyword">if</span> (sMainLooper != <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">&quot;The main Looper has already been prepared.&quot;</span>);            &#125;            sMainLooper = myLooper();        &#125;    &#125;</code></pre><p>在main方法中调用了Looper.prepareMauinLooper()方法，而Looper.prepareMauinLooper()中又调用了prepare方法。因此，我们可以在主线程中直接实例化Handler而不用担心抛出异常。</p><h3 id="2-Handler的postXXX-或sendXXX"><a href="#2-Handler的postXXX-或sendXXX" class="headerlink" title="2.Handler的postXXX()或sendXXX"></a>2.Handler的postXXX()或sendXXX</h3><p>实例化Handler后，我们通常会通过Handler提供的方法来发送一个消息。在第一章节中列举了Handler的sendMessage()和postDelay()方法，其实除了这两个方法之外，Handler还提供了一系列的sendXXX()和postXXX()的方法。但追踪源码发现这些方法最终都会调用到sendMessageAtTime方法。</p><p>我们就以postDelayed方法为例来分析。首先，来看postDelayed的源码：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">postDelayed</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Runnable r, <span class="hljs-keyword">long</span> delayMillis)</span> </span>&#123;        <span class="hljs-keyword">return</span> sendMessageDelayed(getPostMessage(r), delayMillis);    &#125;</code></pre><p>在postDelayed中调用了sendMessageDelayed方法，这个方法的第一个参数接收一个Message，这里通过getPostMessage(r)方法得到了Message对象，getPostMessage(r)源码如下：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Message <span class="hljs-title">getPostMessage</span><span class="hljs-params">(Runnable r)</span> </span>&#123;        Message m = Message.obtain();        m.callback = r;        <span class="hljs-keyword">return</span> m;    &#125;</code></pre><p>可以看到，在getPostMessage方法中将Runnable赋值给了Message.callback，此处我们先立一个Flag。</p><p>接下来追溯到sendMessageDelayed方法中：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">sendMessageDelayed</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Message msg, <span class="hljs-keyword">long</span> delayMillis)</span> </span>&#123;        <span class="hljs-keyword">if</span> (delayMillis &lt; <span class="hljs-number">0</span>) &#123;            delayMillis = <span class="hljs-number">0</span>;        &#125;        <span class="hljs-keyword">return</span> sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);    &#125;</code></pre><p>在这个方法中我们终于看到了sendMessageAtTime方法，其源码如下：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">sendMessageAtTime</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Message msg, <span class="hljs-keyword">long</span> uptimeMillis)</span> </span>&#123;        MessageQueue queue = mQueue;        <span class="hljs-keyword">if</span> (queue == <span class="hljs-keyword">null</span>) &#123;            RuntimeException e = <span class="hljs-keyword">new</span> RuntimeException(                    <span class="hljs-keyword">this</span> + <span class="hljs-string">&quot; sendMessageAtTime() called with no mQueue&quot;</span>);            Log.w(<span class="hljs-string">&quot;Looper&quot;</span>, e.getMessage(), e);            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        <span class="hljs-keyword">return</span> enqueueMessage(queue, msg, uptimeMillis);    &#125;</code></pre><p>这个方法中的代码逻辑很简单，仅仅调用了enqueueMessage方法，源码如下：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">enqueueMessage</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> MessageQueue queue, <span class="hljs-meta">@NonNull</span> Message msg,</span></span><span class="hljs-function"><span class="hljs-params">            <span class="hljs-keyword">long</span> uptimeMillis)</span> </span>&#123;        msg.target = <span class="hljs-keyword">this</span>;        msg.workSourceUid = ThreadLocalWorkSource.getUid();        <span class="hljs-keyword">if</span> (mAsynchronous) &#123;            msg.setAsynchronous(<span class="hljs-keyword">true</span>);        &#125;        <span class="hljs-keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);    &#125;</code></pre><p>在这个方法中我们需要注意的一点– msg.target = this，把当前Handler的对象赋值给了Message.target。紧接着调用了MessageQueue的enqueueMessage方法。MessageQueue这个类我们在上边已经碰到过了。即在实例化Handler的时候将mLooper.mQueue赋值给了Handler的mQueue.那么现在是时候来认识一下MessageQueue了。</p><h3 id="3-MessageQueue"><a href="#3-MessageQueue" class="headerlink" title="3.MessageQueue"></a>3.MessageQueue</h3><p>上一小节中我们在Handler的构造方法中看到了将mLooper.mQueue赋值给了Handler中的mQueue。而MessageQueue从名字上似乎也可以看出来它是一个存储消息的队列。并且在Handler的enqueueMessage方法中通过MessageQueue的enqueueMessage将消息添加到了MessageQueue中。接下来，我们看下enqueueMessage的源码：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">enqueueMessage</span><span class="hljs-params">(Message msg, <span class="hljs-keyword">long</span> when)</span> </span>&#123;        <span class="hljs-keyword">if</span> (msg.target == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;Message must have a target.&quot;</span>);        &#125;        <span class="hljs-keyword">if</span> (msg.isInUse()) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(msg + <span class="hljs-string">&quot; This message is already in use.&quot;</span>);        &#125;        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;            <span class="hljs-keyword">if</span> (mQuitting) &#123;                IllegalStateException e = <span class="hljs-keyword">new</span> IllegalStateException(                        msg.target + <span class="hljs-string">&quot; sending message to a Handler on a dead thread&quot;</span>);                Log.w(TAG, e.getMessage(), e);                msg.recycle();                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            &#125;            msg.markInUse();            msg.when = when;            Message p = mMessages;            <span class="hljs-keyword">boolean</span> needWake;            <span class="hljs-keyword">if</span> (p == <span class="hljs-keyword">null</span> || when == <span class="hljs-number">0</span> || when &lt; p.when) &#123;                <span class="hljs-comment">// New head, wake up the event queue if blocked.</span>                msg.next = p;                mMessages = msg;                needWake = mBlocked;            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-comment">// Inserted within the middle of the queue.  Usually we don&#x27;t have to wake</span>                <span class="hljs-comment">// up the event queue unless there is a barrier at the head of the queue</span>                <span class="hljs-comment">// and the message is the earliest asynchronous message in the queue.</span>                needWake = mBlocked &amp;&amp; p.target == <span class="hljs-keyword">null</span> &amp;&amp; msg.isAsynchronous();                Message prev;                <span class="hljs-keyword">for</span> (;;) &#123;                    prev = p;                    p = p.next;                    <span class="hljs-keyword">if</span> (p == <span class="hljs-keyword">null</span> || when &lt; p.when) &#123;                        <span class="hljs-keyword">break</span>;                    &#125;                    <span class="hljs-keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;                        needWake = <span class="hljs-keyword">false</span>;                    &#125;                &#125;                msg.next = p; <span class="hljs-comment">// invariant: p == prev.next</span>                prev.next = msg;            &#125;            <span class="hljs-comment">// We can assume mPtr != 0 because mQuitting is false.</span>            <span class="hljs-keyword">if</span> (needWake) &#123;                nativeWake(mPtr);            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;</code></pre><p>emmmmmm…阅读源码发现MessageQueue是一个用单项链表实现的队列，为什么是用链表？其实细想一下也不奇怪，因为我们可能频繁的将Message进行插入和删除。而使用链表性能上很明显要优于顺序表。这一段代码就是一个将Message插入到链表的一个过程，其实也没什么可以解释的。</p><p>既然有插入消息，那必然也会有取出消息。我们进入MessageQueue的源码，发现在MessageQueue中发现还有另外一个叫next的方法：</p><pre><code class="hljs java"><span class="hljs-function">Message <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// Return here if the message loop has already quit and been disposed.</span>        <span class="hljs-comment">// This can happen if the application tries to restart a looper after quit</span>        <span class="hljs-comment">// which is not supported.</span>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> ptr = mPtr;        <span class="hljs-keyword">if</span> (ptr == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;        <span class="hljs-keyword">int</span> pendingIdleHandlerCount = -<span class="hljs-number">1</span>; <span class="hljs-comment">// -1 only during first iteration</span>        <span class="hljs-keyword">int</span> nextPollTimeoutMillis = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (;;) &#123;            <span class="hljs-keyword">if</span> (nextPollTimeoutMillis != <span class="hljs-number">0</span>) &#123;                Binder.flushPendingCommands();            &#125;            nativePollOnce(ptr, nextPollTimeoutMillis);            <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;                <span class="hljs-comment">// Try to retrieve the next message.  Return if found.</span>                <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> now = SystemClock.uptimeMillis();                Message prevMsg = <span class="hljs-keyword">null</span>;                Message msg = mMessages;                <span class="hljs-keyword">if</span> (msg != <span class="hljs-keyword">null</span> &amp;&amp; msg.target == <span class="hljs-keyword">null</span>) &#123;                    <span class="hljs-comment">// Stalled by a barrier.  Find the next asynchronous message in the queue.</span>                    <span class="hljs-keyword">do</span> &#123;                        prevMsg = msg;                        msg = msg.next;                    &#125; <span class="hljs-keyword">while</span> (msg != <span class="hljs-keyword">null</span> &amp;&amp; !msg.isAsynchronous());                &#125;                <span class="hljs-keyword">if</span> (msg != <span class="hljs-keyword">null</span>) &#123;                    <span class="hljs-keyword">if</span> (now &lt; msg.when) &#123;                        <span class="hljs-comment">// Next message is not ready.  Set a timeout to wake up when it is ready.</span>                        nextPollTimeoutMillis = (<span class="hljs-keyword">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);                    &#125; <span class="hljs-keyword">else</span> &#123;                        <span class="hljs-comment">// Got a message.</span>                        mBlocked = <span class="hljs-keyword">false</span>;                        <span class="hljs-keyword">if</span> (prevMsg != <span class="hljs-keyword">null</span>) &#123;                            prevMsg.next = msg.next;                        &#125; <span class="hljs-keyword">else</span> &#123;                            mMessages = msg.next;                        &#125;                        msg.next = <span class="hljs-keyword">null</span>;                        <span class="hljs-keyword">if</span> (DEBUG) Log.v(TAG, <span class="hljs-string">&quot;Returning message: &quot;</span> + msg);                        msg.markInUse();                        <span class="hljs-keyword">return</span> msg;                    &#125;                &#125; <span class="hljs-keyword">else</span> &#123;                    <span class="hljs-comment">// No more messages.</span>                    nextPollTimeoutMillis = -<span class="hljs-number">1</span>;                &#125;                <span class="hljs-comment">// Process the quit message now that all pending messages have been handled.</span>                <span class="hljs-keyword">if</span> (mQuitting) &#123;                    dispose();                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;                &#125;                <span class="hljs-comment">// If first time idle, then get the number of idlers to run.</span>                <span class="hljs-comment">// Idle handles only run if the queue is empty or if the first message</span>                <span class="hljs-comment">// in the queue (possibly a barrier) is due to be handled in the future.</span>                <span class="hljs-keyword">if</span> (pendingIdleHandlerCount &lt; <span class="hljs-number">0</span>                        &amp;&amp; (mMessages == <span class="hljs-keyword">null</span> || now &lt; mMessages.when)) &#123;                    pendingIdleHandlerCount = mIdleHandlers.size();                &#125;                <span class="hljs-keyword">if</span> (pendingIdleHandlerCount &lt;= <span class="hljs-number">0</span>) &#123;                    <span class="hljs-comment">// No idle handlers to run.  Loop and wait some more.</span>                    mBlocked = <span class="hljs-keyword">true</span>;                    <span class="hljs-keyword">continue</span>;                &#125;                <span class="hljs-keyword">if</span> (mPendingIdleHandlers == <span class="hljs-keyword">null</span>) &#123;                    mPendingIdleHandlers = <span class="hljs-keyword">new</span> IdleHandler[Math.max(pendingIdleHandlerCount, <span class="hljs-number">4</span>)];                &#125;                mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);            &#125;            <span class="hljs-comment">// Run the idle handlers.</span>            <span class="hljs-comment">// We only ever reach this code block during the first iteration.</span>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; pendingIdleHandlerCount; i++) &#123;                <span class="hljs-keyword">final</span> IdleHandler idler = mPendingIdleHandlers[i];                mPendingIdleHandlers[i] = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// release the reference to the handler</span>                <span class="hljs-keyword">boolean</span> keep = <span class="hljs-keyword">false</span>;                <span class="hljs-keyword">try</span> &#123;                    keep = idler.queueIdle();                &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;                    Log.wtf(TAG, <span class="hljs-string">&quot;IdleHandler threw exception&quot;</span>, t);                &#125;                <span class="hljs-keyword">if</span> (!keep) &#123;                    <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;                        mIdleHandlers.remove(idler);                    &#125;                &#125;            &#125;            <span class="hljs-comment">// Reset the idle handler count to 0 so we do not run them again.</span>            pendingIdleHandlerCount = <span class="hljs-number">0</span>;            <span class="hljs-comment">// While calling an idle handler, a new message could have been delivered</span>            <span class="hljs-comment">// so go back and look again for a pending message without waiting.</span>            nextPollTimeoutMillis = <span class="hljs-number">0</span>;        &#125;    &#125;</code></pre><p>这个方法的返回值是一个Message，很显然，这个方法就是从MessageQueue中取出消息的。我们注意到第12行代码，这里是一个for(;;)死循环。如果在MessageQueue中有Message的时候，next会将这个Message移除并返回。而当MessageQueue为空时，next方法将会被阻塞。</p><h3 id="4-回归Looper"><a href="#4-回归Looper" class="headerlink" title="4.回归Looper"></a>4.回归Looper</h3><p>我们了解了MessageQueue的插入和删除，但直到此时还没有看到在什么地方调用了MessageQueue的next方法将消息取出的。此时，我们将目光再次回归到Looper中。如果你刚才留意了ActivityThread中的main方法的话，应该注意到了main方法中的Looper.loop()方法,没错，一切将从这里开始，只有调用loop方法后消息循环系统才会真正运作起来，我们们来看loop的源码：</p><pre><code class="hljs reasonml"><span class="hljs-comment">/**</span><span class="hljs-comment">    * Run the message queue in this thread. Be sure to call</span><span class="hljs-comment">    * &#123;@link #quit()&#125; to end the loop.</span><span class="hljs-comment">    */</span>   public static void loop<span class="hljs-literal">()</span> &#123;       final Looper me = my<span class="hljs-constructor">Looper()</span>;       <span class="hljs-keyword">if</span> (me<span class="hljs-operator"> == </span>null) &#123;           throw <span class="hljs-keyword">new</span> <span class="hljs-constructor">RuntimeException(<span class="hljs-string">&quot;No Looper; Looper.prepare() wasn&#x27;t called on this thread.&quot;</span>)</span>;       &#125;       final MessageQueue queue = me.mQueue;       <span class="hljs-comment">// Make sure the identity of this thread is that of the local process,</span>       <span class="hljs-comment">// and keep track of what that identity token actually is.</span>       <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Binder</span>.</span></span>clear<span class="hljs-constructor">CallingIdentity()</span>;       final long ident = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Binder</span>.</span></span>clear<span class="hljs-constructor">CallingIdentity()</span>;       <span class="hljs-keyword">for</span> (;;) &#123;           Message msg = queue.next<span class="hljs-literal">()</span>; <span class="hljs-comment">// might block</span>           <span class="hljs-keyword">if</span> (msg<span class="hljs-operator"> == </span>null) &#123;               <span class="hljs-comment">// No message indicates that the message queue is quitting.</span>               return;           &#125;           <span class="hljs-comment">// This must be in a local variable, in case a UI event sets the logger</span>           final Printer logging = me.mLogging;           <span class="hljs-keyword">if</span> (logging != null) &#123;               logging.println(<span class="hljs-string">&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot;</span> + msg.target + <span class="hljs-string">&quot; &quot;</span> +                       msg.callback + <span class="hljs-string">&quot;: &quot;</span> + msg.what);           &#125;           final long traceTag = me.mTraceTag;           <span class="hljs-keyword">if</span> (traceTag != <span class="hljs-number">0</span><span class="hljs-operator"> &amp;&amp; </span><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Trace</span>.</span></span>is<span class="hljs-constructor">TagEnabled(<span class="hljs-params">traceTag</span>)</span>) &#123;               <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Trace</span>.</span></span>trace<span class="hljs-constructor">Begin(<span class="hljs-params">traceTag</span>, <span class="hljs-params">msg</span>.<span class="hljs-params">target</span>.<span class="hljs-params">getTraceName</span>(<span class="hljs-params">msg</span>)</span>);           &#125;           <span class="hljs-keyword">try</span> &#123;               msg.target.dispatch<span class="hljs-constructor">Message(<span class="hljs-params">msg</span>)</span>;           &#125; finally &#123;               <span class="hljs-keyword">if</span> (traceTag != <span class="hljs-number">0</span>) &#123;                   <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Trace</span>.</span></span>trace<span class="hljs-constructor">End(<span class="hljs-params">traceTag</span>)</span>;               &#125;           &#125;           <span class="hljs-keyword">if</span> (logging != null) &#123;               logging.println(<span class="hljs-string">&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot;</span> + msg.target + <span class="hljs-string">&quot; &quot;</span> + msg.callback);           &#125;           <span class="hljs-comment">// Make sure that during the course of dispatching the</span>           <span class="hljs-comment">// identity of the thread wasn&#x27;t corrupted.</span>           final long newIdent = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Binder</span>.</span></span>clear<span class="hljs-constructor">CallingIdentity()</span>;           <span class="hljs-keyword">if</span> (ident != newIdent) &#123;               <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Log</span>.</span></span>wtf(TAG, <span class="hljs-string">&quot;Thread identity changed from 0x&quot;</span>                       + <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Long</span>.</span></span><span class="hljs-keyword">to</span><span class="hljs-constructor">HexString(<span class="hljs-params">ident</span>)</span> + <span class="hljs-string">&quot; to 0x&quot;</span>                       + <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Long</span>.</span></span><span class="hljs-keyword">to</span><span class="hljs-constructor">HexString(<span class="hljs-params">newIdent</span>)</span> + <span class="hljs-string">&quot; while dispatching to &quot;</span>                       + msg.target.get<span class="hljs-constructor">Class()</span>.get<span class="hljs-constructor">Name()</span> + <span class="hljs-string">&quot; &quot;</span>                       + msg.callback + <span class="hljs-string">&quot; what=&quot;</span> + msg.what);           &#125;           msg.recycle<span class="hljs-constructor">Unchecked()</span>;       &#125;   &#125;</code></pre><p>这里的loop方法同样也是一个死循环。只有当MessageQueue.next()返回null时才会跳出循环。上一小节中我们分析了Message.next方法是一个阻塞操作当MessageQueue中没有消息时next方法会一直被阻塞，因此也致使loop方法被阻塞。而当MessageQueue中添加了一条消息后，loop方法则会立即通过MessageQueue.next方法将消息取出并处理。可以看到通过调用msg.target.dispatchMessage(msg)处理消息。而msg.target是什么呢？我们回过头来看本章第二小节，在Handler的enqueueMessage中将Handler赋值给了msg.target,我们从Message的源码中也可以得到印证：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Message</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Parcelable</span> </span>&#123;...  <span class="hljs-comment">/*package*/</span> Handler target;...&#125;</code></pre><p>也就是此时的target其实就是Handler本身，此时我们找到Handler的dispatchMessage方法，源码如下：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dispatchMessage</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Message msg)</span> </span>&#123;       <span class="hljs-keyword">if</span> (msg.callback != <span class="hljs-keyword">null</span>) &#123;           handleCallback(msg);       &#125; <span class="hljs-keyword">else</span> &#123;           <span class="hljs-keyword">if</span> (mCallback != <span class="hljs-keyword">null</span>) &#123;               <span class="hljs-keyword">if</span> (mCallback.handleMessage(msg)) &#123;                   <span class="hljs-keyword">return</span>;               &#125;           &#125;           handleMessage(msg);       &#125;   &#125;</code></pre><p>看到这里想必大家应该就都明白了，上述代码首先检查了Message的callback是否为null，不为null就通过handleCallback来处理消息。Message的callback是一个Runnable对象，实际上就是Handler的post方法传递的Runnable参数，此时对应的是我们在第一章中的场景二。handleCallback方法代码如下：</p><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleCallback</span><span class="hljs-params">(Message message)</span> </span>&#123;        message.callback.<span class="hljs-built_in">run</span>();    &#125;</code></pre><p>emmmm….原来我们post出来的Runnable的run方法就是在这里被调用的呀！</p><p>接着检查mCallback是否为null，不为null就调用mCallback的handleMessage方法处理消息，这里对应的是我们在实例化Handler时传入的Callback参数。如果mCallback也为null的话则调用了Handler中的handleMessage(msg)方法。这不正对应了我们第一章的场景一嘛！因此现在再来看下面的代码会不会豁然开朗呢？</p><pre><code class="hljs aspectj"><span class="hljs-comment">//实例化Handler对象 传入Callback参数并重写handleMessage(Message msg)</span> <span class="hljs-keyword">static</span> Handler mHandler1 = <span class="hljs-keyword">new</span> Handler(<span class="hljs-keyword">new</span> Handler.Callback() &#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">handleMessage</span><span class="hljs-params">(Message msg)</span> </span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;    &#125;);<span class="hljs-comment">//实例化Handler对象 并重写Handler中的handleMessage(Message msg)</span>handleMessage(Message msg) <span class="hljs-keyword">static</span> Handler mHandler = <span class="hljs-keyword">new</span> Handler()&#123;  <span class="hljs-meta">@Override</span>        <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">handleMessage</span><span class="hljs-params">(Message msg)</span> </span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;&#125;;</code></pre><p>到这里我们总算把Handler的消息机制给串联了起来。</p><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p> Handler、Looper和MessageQueue三者共支撑了Android中的消息机制。在使用的时候我们通常只需要和Handler打交道，通过Handler将消息发送出来。而在Handler内部的MessageQueue通过equeueMessage方法将Handler发送的消息以队列的形式进行存储。而Looper则作为一个消息泵，通过loop方法不断的调用MessageQueue的next方法将消息取出并进行处理，依次完成了整个的消息循环。同时，我们还应该特别强调ThreadLocal，正是有了它的存在，才使得我们能够轻松的进行切换线程。</p><p>整个过程当如下图所示：</p><p><img src="https://raw.githubusercontent.com/zhpanvip/Resource/master/image/1101.jfif"></p><p>看到这里，在第一章中提到的几点疑惑相信你心中应该也已经有了答案。我们不妨再来总结一下：</p><p><strong>问题1：</strong> 在场景1中Handler在子线程中发送出来的消息为什么到了dispatchMessage方法就变成了主线程呢？<br>虽然post消息是在子线程，但因为Handler是在主线程中被实例化的，由于在ActivityThread的main方法中调用了Looper.prepare(),因此，通过ThreadLocal将Looper缓存到了主线程中，而MessageQueue是Looper的成员变量，所以其也应是在主线程中。同时，Looper.loop方法将Message取出并通过Message.target.handlerMessage方法最终调用了dispatchMessage方法，所以dispatchMessage方法当然也是在主线程了。</p><p><strong>问题2：</strong> 在场景2的代码中我故意在子线程中调用了Handler的postDelayed方法，那么此时通过postDelayed方法发出来的Runnable究竟是运行在主线程还是子线程呢？</p><p>这个问题其实和问题1本质上是同一个问题，就无需多言了！</p><p><strong>问题3</strong>在文中已经给出了答案，这里也不再赘述。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Android夜间模式实现方案</title>
    <link href="/2017/07/27/Android%E5%A4%9C%E9%97%B4%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88/"/>
    <url>/2017/07/27/Android%E5%A4%9C%E9%97%B4%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<p>对于一款阅读类的软件，夜间模式是不可缺少的。最初看到这个需求时候觉得无从下手，没有一点头绪。后来通过查阅资料发现Android官方在Support Library 23.2.0中已经加入了夜间主题。也就是只需要通过更换主题便可实现日间模式和夜间模式的切换。下面截取项目实现的夜间模式效果图：<br><img src="https://raw.githubusercontent.com/zhpanvip/Resource/master/image/1001.jfif"></p><p>效果看起来还比较nice，没有闪屏，过度也比较平滑。那么项目中的这个日间、夜间模式切换效果是如何实现的呢？下面将从以下几个方面来讲解：</p><ul><li>一 实现夜间模式需要的配置</li><li>二 实现白天和夜间模式的切换</li><li>三 实现夜间模式时遇到的问题及解决方案</li></ul><p>一、实现夜间模式需要的配置<br>1.首先在gradel中引入以下依赖</p><pre><code class="hljs apache"><span class="hljs-attribute">compile</span> &#x27;com.android.support:appcompat-v<span class="hljs-number">7</span>:<span class="hljs-number">25</span>.<span class="hljs-number">3</span>.<span class="hljs-number">1</span>&#x27;</code></pre><p>2.让我们项目的主题继承夜间模式主题，在style中设置如下主题：</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;AppTheme&quot;</span> <span class="hljs-attr">parent</span>=<span class="hljs-string">&quot;Theme.AppCompat.DayNight&quot;</span>&gt;</span><span class="xml">       <span class="hljs-comment">&lt;!-- Customize your theme here. --&gt;</span></span><span class="xml">       <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;colorPrimary&quot;</span>&gt;</span>@color/colorPrimary<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><span class="xml">       <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;colorPrimaryDark&quot;</span>&gt;</span>@color/colorPrimaryDark<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><span class="xml">       <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;colorAccent&quot;</span>&gt;</span>@color/colorAccent<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span>   <span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></code></pre><p>3.新建drawable-night和values-night的资源目录。如果要适配不同分辨率的屏幕则可新建drawable-night-hdip、drawable-night-xhdpi等目录来存放不同分辨率的图片资源。values-night目录下存放与夜间模式相关的value文件。本篇文章讲解仅以夜间模式和日间模式的颜色为例，在values-night目录下新建color.xml文件。</p><p>（1）新建values-night目录，如下：</p><p><img src="https://raw.githubusercontent.com/zhpanvip/Resource/master/image/1002.jfif"></p><p><img src="https://raw.githubusercontent.com/zhpanvip/Resource/master/image/1003.jfif"></p><p>（2）在values-night目录下新建colors文件，如下：<br><img src="https://raw.githubusercontent.com/zhpanvip/Resource/master/image/1004.jfif"></p><p><img src="https://raw.githubusercontent.com/zhpanvip/Resource/master/image/1005.jfif"></p><p>接下来只需要在对应的colors文件下写不同的颜色值(夜间颜色值和白天颜色值)即可。至此关于实现夜间模式的配置已经基本完成。</p><p>二、实现白天和夜间模式的切换<br>1.启动App时检测是否处于夜间模式，如果是则切换至夜间主题。这个需要在自己项目的Application中实现。可在自己项目的Application中添加以下代码：</p><pre><code class="hljs arduino"><span class="hljs-comment">/**</span><span class="hljs-comment">  * 初始化夜间模式</span><span class="hljs-comment">  */</span>   <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setNightMode</span><span class="hljs-params">()</span> </span>&#123;       <span class="hljs-keyword">boolean</span> nightMode = UserInfoTools.isNightMode(<span class="hljs-keyword">this</span>);       AppCompatDelegate.setDefaultNightMode(nightMode ?               AppCompatDelegate.MODE_NIGHT_YES : AppCompatDelegate.MODE_NIGHT_NO);   &#125;</code></pre><p>这里需要介绍一下有关夜间模式的几个常量值。AppCompatDelegate.setDefaultNightMode(mode),其中mode有一下四个值：</p><ul><li>MODE_NIGHT_NO： 亮色(light)主题，不使用夜间模式</li><li>MODE_NIGHT_YES：暗色(dark)主题，使用夜间模式</li><li>MODE_NIGHT_AUTO：根据当前时间自动切换 亮色(light)/暗色(dark)主题（22：00-07：00时间段内自动切换为夜间模式）</li><li>MODE_NIGHT_FOLLOW_SYSTEM(默认选项)：设置为跟随系统，通常为MODE_NIGHT_NO<br>2.接下来需要我们在设置页面点击ToggleButton时切换白天/夜间模式。<br>具体实现如下：<pre><code class="hljs jboss-cli">private void <span class="hljs-keyword">set</span>NightMode<span class="hljs-params">()</span> &#123;         <span class="hljs-string">//</span>  获取当前模式        int currentNightMode = getResources<span class="hljs-params">()</span><span class="hljs-string">.getConfiguration</span><span class="hljs-params">()</span><span class="hljs-string">.uiMode</span> &amp; Configuration.UI_MODE_NIGHT_MASK;        <span class="hljs-string">//</span>  将是否为夜间模式保存到SharedPreferences        UserInfoTools.<span class="hljs-keyword">set</span>NightMode<span class="hljs-params">(this, <span class="hljs-attr">currentNightMode</span> == Configuration.UI_MODE_NIGHT_NO)</span>;        <span class="hljs-string">//</span>  切换模式        getDelegate<span class="hljs-params">()</span><span class="hljs-string">.setDefaultNightMode</span><span class="hljs-params">(<span class="hljs-attr">currentNightMode</span> == Configuration.UI_MODE_NIGHT_NO ?</span><span class="hljs-params">                AppCompatDelegate.MODE_NIGHT_YES : AppCompatDelegate.MODE_NIGHT_NO)</span>;        UserInfoTools.<span class="hljs-keyword">set</span>ChangeNightMode<span class="hljs-params">(this,true)</span>;        <span class="hljs-string">//</span>  重启Activity        recreate<span class="hljs-params">()</span>;    &#125;private void <span class="hljs-keyword">set</span>Listener<span class="hljs-params">()</span> &#123;        mToggleButton.<span class="hljs-keyword">set</span>OnClickListener<span class="hljs-params">((View v)</span> -&gt; &#123;            <span class="hljs-keyword">set</span>NightMode<span class="hljs-params">()</span>;        &#125;);    &#125;</code></pre>注意，上面代码中设置白天/夜间模式的代码的最后调用了recreate()方法重启了当前Activity。但这样写切换模式时会有闪屏问题，体验比较差。具体优化将在下一节中实现。</li></ul><p>三 、实现夜间模式时遇到的问题及解决方案<br>利用谷歌官方提供的这个方案实现夜间模式的过程中遇到了不少的问题。且网上资料较少，大多文章讲解仅仅以一个简单的demo为例。但在用到实际项目中时会遇到很多的麻烦。这里主要总结了笔者曾经遇到过的难以解决的几个问题。<br>1.白天/夜间模式切换时闪屏问题<br>上一节中已经提到了在调用recreate()方法时会有闪屏问题。其实闪屏问题的解决比较简单。我们大可以不掉用recreate()方法，而是自己重启当前activity并为activity设置启动和退出动画即可！实现代码如下：</p><pre><code class="hljs groovy"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> setNightMode() &#123;       <span class="hljs-comment">//  获取当前模式</span>       <span class="hljs-keyword">int</span> currentNightMode = getResources().getConfiguration().uiMode &amp; Configuration.UI_MODE_NIGHT_MASK;       <span class="hljs-comment">//  将是否为夜间模式保存到SharedPreferences</span>       UserInfoTools.setNightMode(<span class="hljs-built_in">this</span>, currentNightMode == Configuration.UI_MODE_NIGHT_NO);       <span class="hljs-comment">//  切换模式</span>       getDelegate().setDefaultNightMode(currentNightMode == Configuration.UI_MODE_NIGHT_NO ?               AppCompatDelegate.MODE_NIGHT_YES : AppCompatDelegate.MODE_NIGHT_NO);       UserInfoTools.setChangeNightMode(<span class="hljs-built_in">this</span>,<span class="hljs-literal">true</span>);              <span class="hljs-comment">//recreate();</span>       startActivity(<span class="hljs-keyword">new</span> Intent(<span class="hljs-built_in">this</span>,SettingActivity.<span class="hljs-keyword">class</span>));       overridePendingTransition(R.anim.animo_alph_close, R.anim.animo_alph_close);       finish();   &#125;</code></pre><p>如上代码，我们自行调用startActivity启动了设置页面并为其添加了一个透明渐变的启动动画。最后调用finish结束掉旧的设置页面。这样闪屏问题便迎刃而解。模式切换也变得流畅自然。<br> 2.切换夜间模式后返回MainActivity,MainActivity页面没有更新。解决这个问题可以在切换模式后从设置页面发送一个广播，然后在MainActivity中接收到这个广播后重启MainActivity即可。根据官方的推荐更换夜间模式后需要调用recreate()方法刷新页面。但是recreate()方法巨坑无比，调用recreate()方法引起了诸多问题。详见问题3、4、5。因此解决这个问题笔者并没有在MainActivity调用中调用recreate()方法。而是在SettingActivity中定义了一个boolean值来标记是否切换了夜间模式。然后重写了onKeyDown()方法。如果切换了夜间模式则在返回时发出一个广播结束掉MainActivity,然后调用startActivity()重启了MainActivity并添加了启动动画，让用户感觉是只是返回了主页面。其实思想跟解决问题1有些类似。还是结合代码来看吧。</p><p>SettingActivity中的代码</p><pre><code class="hljs reasonml">@Override   public boolean on<span class="hljs-constructor">KeyDown(<span class="hljs-params">int</span> <span class="hljs-params">keyCode</span>, KeyEvent <span class="hljs-params">event</span>)</span> &#123;       <span class="hljs-keyword">if</span> (keyCode<span class="hljs-operator"> == </span>KeyEvent.KEYCODE_BACK<span class="hljs-operator"> &amp;&amp; </span>event.get<span class="hljs-constructor">Action()</span><span class="hljs-operator"> == </span>KeyEvent.ACTION_DOWN) &#123;           go<span class="hljs-constructor">Back()</span>;           return <span class="hljs-literal">true</span>;       &#125;       return super.on<span class="hljs-constructor">KeyDown(<span class="hljs-params">keyCode</span>, <span class="hljs-params">event</span>)</span>;   &#125;   <span class="hljs-keyword">private</span> void go<span class="hljs-constructor">Back()</span> &#123;       <span class="hljs-keyword">if</span> (isChangeNightMode) &#123;  <span class="hljs-comment">//  如果改变了夜间模式，则重启MainActivity</span>           <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">EventBus</span>.</span></span>get<span class="hljs-constructor">Default()</span>.post(<span class="hljs-keyword">new</span> <span class="hljs-constructor">NightModeEvent()</span>);           Intent intent = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Intent(<span class="hljs-params">this</span>, MainActivity.<span class="hljs-params">class</span>)</span>;           intent.put<span class="hljs-constructor">Extra(<span class="hljs-string">&quot;nightMode&quot;</span>, <span class="hljs-params">true</span>)</span>;           start<span class="hljs-constructor">Activity(<span class="hljs-params">intent</span>)</span>;           override<span class="hljs-constructor">PendingTransition(R.<span class="hljs-params">anim</span>.<span class="hljs-params">animo_alph_close</span>, R.<span class="hljs-params">anim</span>.<span class="hljs-params">activity_close</span>)</span>;       &#125;       finish<span class="hljs-literal">()</span>;   &#125;</code></pre><p>MainActivity中的代码：</p><pre><code class="hljs reasonml"> @Override   public void on<span class="hljs-constructor">Create(Bundle <span class="hljs-params">savedInstanceState</span>)</span> &#123;       super.on<span class="hljs-constructor">Create(<span class="hljs-params">savedInstanceState</span>)</span>;       set<span class="hljs-constructor">ContentView(R.<span class="hljs-params">layout</span>.<span class="hljs-params">activity_main</span>)</span>;              re<span class="hljs-constructor">StartActivity()</span>   &#125;<span class="hljs-comment">//  改变夜间模式后返回时重启Activity</span>   <span class="hljs-keyword">private</span> void re<span class="hljs-constructor">StartActivity()</span> &#123;       Intent intent = get<span class="hljs-constructor">Intent()</span>;       boolean nightMode = intent.get<span class="hljs-constructor">BooleanExtra(<span class="hljs-string">&quot;nightMode&quot;</span>, <span class="hljs-params">false</span>)</span>;       <span class="hljs-keyword">if</span>(nightMode&amp;&amp;<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">UserInfoTools</span>.</span></span>get<span class="hljs-constructor">IsLogin(<span class="hljs-params">this</span>)</span>)&#123;           <span class="hljs-comment">//  自动切换到“我的”页面</span>           mRbMe.perform<span class="hljs-constructor">Click()</span>;       &#125;   &#125;<span class="hljs-comment">/**</span><span class="hljs-comment">    * 接收到夜间模式改变的事件后结束当前Activity</span><span class="hljs-comment">    * @param event</span><span class="hljs-comment">    */</span> @Subscribe   public void set<span class="hljs-constructor">NightMode(NightModeEvent <span class="hljs-params">event</span>)</span> &#123;       finish<span class="hljs-literal">()</span>;   &#125;</code></pre><p>最后还有点问题需要说明，由问题1我们可以知道，改变模式后，我们重启了SettingActivity。因此在该类中定义的一个标记是否切换了夜间模式的boolean值并不能起到作用。解决办法是将这个值保存到SharedPreference中。然后重启SettingActivity后再取出该值。可以看代码，这点真心有点绕啊。。。<br>注意问题1中的setNightMode()方法中有一句代码 UserInfoTools.setChangeNightMode(this,true);将改变了夜间模式设置为了true并保存到了SharedPreferences中，然后在onCreate()中有以下代码来初始化isChangeNightMode的值。</p><pre><code class="hljs reasonml">@Override   public void on<span class="hljs-constructor">Create(Bundle <span class="hljs-params">savedInstanceState</span>)</span> &#123;       super.on<span class="hljs-constructor">Create(<span class="hljs-params">savedInstanceState</span>)</span>;       set<span class="hljs-constructor">ContentView(R.<span class="hljs-params">layout</span>.<span class="hljs-params">activity_main</span>)</span>;                isChangeNightMode=<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">UserInfoTools</span>.</span></span>is<span class="hljs-constructor">ChangeNightMode(<span class="hljs-params">this</span>)</span>;       <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">UserInfoTools</span>.</span></span>set<span class="hljs-constructor">ChangeNightMode(<span class="hljs-params">this</span>,<span class="hljs-params">false</span>)</span>;   &#125;</code></pre><p>3.设置白天/夜间模式后出现无故闪退问题<br>这个问题说来比较奇怪，原因是切换了夜间模式后在MainActivity中调用了recreate()方法。具体原因笔者也没有弄清楚，调试了好一阵子也没有找出个所以然来。后来果断放弃了在MainActivity中调用recreate()方法，而是换成了startActivity()重新启动了MainActivity。之后这个问题便不复存在了。</p><p>4.点击ToggleButton切换模式后应用黑屏，随后挂掉。这个问题的最终原因还是因为recreate()方法引起的。如果你用了ToggleButton切换白天/夜间模式，并且为ToggleButton设置了setOnCheckChangedListener()方法，那么你将有很大概率碰到这个问题。引起这个问题的原因是因为调用了recreate()方法后Activity重新启动，但是新启动的Activity保存了之前Activity的状态。因此在重启时候重新设置了TouggleButton，继而调用了又setOnCheckChangedListener()方法，结果悲剧了。。。一个死循环产生了，程序不黑屏才怪。因此最简单的办法是放弃recreate()方法，改用问题1中的方法！（其实细心的小伙伴应该已经发现了，我的代码中仅仅是为ToggleButton设置了setOnClickListener()….机智如我啊）如果你有强迫症必须要使用setOnCheckChangedListener和recreate()方法那么也不是没有解决方案。可以定义一个boolean成员变量，然后在onCreate()方法中判断savedInstanceState是否为null，然后给这个boolean成员变量赋值，并在setOnCheckChangedListener()方法中根据这个boolean成员变量的值去调用设置夜间模式的方法即可。</p><p>5.设置夜间模式后MainActivity调用recreate()方法，MainActivity中的”发现“页面没有加载出来。发现页面如下面图片所示，也就是一个Fragment中嵌套了一个ViewPager。调用recreate()后整个ViewPager消失了。。。没有加载出来！！！<br><img src="https://raw.githubusercontent.com/zhpanvip/Resource/master/image/1006.jfif"></p><p>解决方案，放弃使用recreate()，改用问题1中的方法！</p><p>万恶的recreate()方法！难道是我使用的姿势不对？</p><h3 id="好库推荐"><a href="#好库推荐" class="headerlink" title="好库推荐"></a>好库推荐</h3><p>给大家推荐一下<a href="https://github.com/zhpanvip/BannerViewPager">BannerViewPager</a>。这是一个基于ViewPager实现的具有强大功能的无限轮播库。通过<a href="https://github.com/zhpanvip/BannerViewPager">BannerViewPager</a>可以实现腾讯视频、QQ音乐、酷狗音乐、支付宝、天猫、淘宝、优酷视频、喜马拉雅、网易云音乐、哔哩哔哩等APP的Banner样式以及指示器样式。</p><p>欢迎大家到github关注<a href="https://github.com/zhpanvip/BannerViewPager">BannerViewPager</a>！</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>RxJava+Retrofit之token自动刷新（二）</title>
    <link href="/2017/07/27/RxJava-Retrofit%E4%B9%8Btoken%E8%87%AA%E5%8A%A8%E5%88%B7%E6%96%B0%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <url>/2017/07/27/RxJava-Retrofit%E4%B9%8Btoken%E8%87%AA%E5%8A%A8%E5%88%B7%E6%96%B0%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p><a href="http://blog.csdn.net/qq_20521573/article/details/70991850"> 上篇文章</a>主要对Retrofit做了封装，使之使用起来更加方便。在之前的封装中token过期再次刷新token后需要手动调用之前的请求，这种处理方式不够优雅，因此，在原有的基础上，本篇文章将基于上篇文章的封装并优化Token验证机制。使之能够实现过期自动刷新并重新调用请求。<br>接下来将通过以下几个小节来学习如何实现token验证。</p><ul><li>为什么要引入token机制</li><li>token机制的验证流程</li><li>RxJava+Retrofit封装实现token验证</li></ul><h1 id="一、为什么引入token机制"><a href="#一、为什么引入token机制" class="headerlink" title="一、为什么引入token机制"></a>一、为什么引入token机制</h1><h1 id="1-token是什么？"><a href="#1-token是什么？" class="headerlink" title="1.token是什么？"></a>1.token是什么？</h1><p>token意为令牌，通常是由客户端携带IMEI/Mac到服务器，服务器根据客户端的IMEI/Mac生成一段字符串并返回给客户端，并为其设置有效期。以此作为客户端和服务端交互的令牌。客户端每次请求都会携带token到服务器来代替用户名和密码。服务端验证token有效后则返回数据给客户端，否则返回特定的错误码给客户端。客户端根据错误码去做相应的处理。</p><h2 id="2-那么为什么引入token机制呢？"><a href="#2-那么为什么引入token机制呢？" class="headerlink" title="2.那么为什么引入token机制呢？"></a>2.那么为什么引入token机制呢？</h2><p>主要有以下两个原因：<br>（1）保证安全性。如果不引入token机制，那么我们每次请求数据都要携带用户名和密码。也就是每次请求数据用户名和密码都会在网络上传输。这样大大增加了安全风险，很容易被黑客截取。因此引入token机制也一定程度上保证了安全性。<br>（2）减小服务器压力。在引入token机制前，我们需要通过用户名和密码到服务器去验证用户身份是否合法。服务器认证用户名和密码是一个查询操作，如果用户量大，那么就会相应增加服务器的压力。而引入token机制后，服务器就可以将token作为一个用户的唯一标识来验证用户身份是否合法。这样可以大大减少服务器的压力。</p><h2 id="二、token机制的验证流程"><a href="#二、token机制的验证流程" class="headerlink" title="二、token机制的验证流程"></a>二、token机制的验证流程</h2><p>token的验证流程并非唯一的，至于使用怎样的验证流程可以自行确定。本文中采用OAuth2.0协议实现token验证机制。<br>主要步骤如下：</p><ol><li>通过用户名和密码登录成功获取token和refreshToken并保存到本地。</li><li>token的有效期为2小时，refreshToken的有效期为15天。</li><li>每次网络请求都需要带上token，而不必带上refreshToken。</li><li>如果服务器端判断token过期，则返回对应的错误码，客户端判断错误码后调用刷新token接口,重新获取token和refreshToken并存储。</li><li>如果连续15天未使用app或者用户修改了密码，则refreshToken过期，需要重新登录获取token和refreshToken。</li></ol><h1 id="三、RxJava-Retrofit封装实现token自动刷新"><a href="#三、RxJava-Retrofit封装实现token自动刷新" class="headerlink" title="三、RxJava+Retrofit封装实现token自动刷新"></a>三、RxJava+Retrofit封装实现token自动刷新</h1><p>有了以上两节的基础，我们就可以来自己实现token机制的验证了。在这里我们使用<a href="http://blog.csdn.net/qq_20521573/article/details/70991850">上篇文章</a>中封装的RxJava和Retrofit来实现token机制。</p><h2 id="1-登录认证，获取token和refresh-token"><a href="#1-登录认证，获取token和refresh-token" class="headerlink" title="1.登录认证，获取token和refresh_token"></a>1.登录认证，获取token和refresh_token</h2><p>登录时我们需要两个参数：用户名username、密码password以及appkey作为一个唯一id，每次登录成功服务器会返回token和refreshToken。登录请求的实体类LoginRequest如下：</p><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginRequest</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BaseRequest</span></span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> userId;    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> password;&#125;</code></pre><p>接下来我们就可以来调用登录接口获取token了。登录成功后我们可将token和refreshToekn存储到本地。以提交表单为例，代码如下：</p><pre><code class="hljs reasonml">public void login<span class="hljs-literal">()</span> &#123;         Map&lt;String, Object&gt; map = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">MapUtils</span>.</span></span>entity<span class="hljs-constructor">ToMap(<span class="hljs-params">new</span> BaseRequest()</span>);        map.put(<span class="hljs-string">&quot;userId&quot;</span>,<span class="hljs-string">&quot;123456&quot;</span>);        map.put(<span class="hljs-string">&quot;password&quot;</span>,<span class="hljs-string">&quot;123123&quot;</span>);        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">IdeaApi</span>.</span></span>get<span class="hljs-constructor">ApiService()</span>                .login(map)                .subscribe<span class="hljs-constructor">On(Schedulers.<span class="hljs-params">io</span>()</span>)                .compose(activity.&lt;BasicResponse&lt;LoginResponse&gt;&gt;bind<span class="hljs-constructor">ToLifecycle()</span>)                .observe<span class="hljs-constructor">On(AndroidSchedulers.<span class="hljs-params">mainThread</span>()</span>)                .subscribe(<span class="hljs-keyword">new</span> DefaultObserver&lt;BasicResponse&lt;LoginResponse&gt;&gt;(activity) &#123;                    @Override                    public void on<span class="hljs-constructor">Success(BasicResponse&lt;LoginResponse&gt; <span class="hljs-params">response</span>)</span> &#123;                        LoginResponse results = response.get<span class="hljs-constructor">Results()</span>;                        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ToastUtils</span>.</span></span>show(<span class="hljs-string">&quot;登录成功！获取到token&quot;</span> + results.get<span class="hljs-constructor">Token()</span> + <span class="hljs-string">&quot;,可以存储到本地了&quot;</span>);                        <span class="hljs-comment">/**</span><span class="hljs-comment">                         * 可以将这些数据存储到User中，User存储到本地数据库</span><span class="hljs-comment">                         */</span>                        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">SharedPreferencesHelper</span>.</span></span>put(activity, <span class="hljs-string">&quot;token&quot;</span>, results.get<span class="hljs-constructor">Token()</span>);                        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">SharedPreferencesHelper</span>.</span></span>put(activity, <span class="hljs-string">&quot;refresh_token&quot;</span>, results.get<span class="hljs-constructor">Refresh_token()</span>);                        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">SharedPreferencesHelper</span>.</span></span>put(activity, <span class="hljs-string">&quot;refresh_secret&quot;</span>, results.get<span class="hljs-constructor">Refresh_secret()</span>);                    &#125;                &#125;);    &#125;</code></pre><h2 id="2-明确需求，抛出异常"><a href="#2-明确需求，抛出异常" class="headerlink" title="2.明确需求，抛出异常"></a>2.明确需求，抛出异常</h2><p>由于token的有效期较短，因此我们需要经常刷新token来保证token的有效性。在请求网络的时候如果token过期或者无效服务器会给我们返回对应的错误码。我们需要根据状态码来判断token是否失效。如果失效则调用刷新token接口重新获取token。如果refreshToekn也过期那么我们需要重新登录。</p><p>现在，我们的需求是要实现token过期后自动刷新，刷新成功后自动调用原来的请求，如果refreshToken也过期，则退出登录。基于此，我们可以联想到RxJava的retryWhen操作符，我们可以通过retryWhen操作符判断token过期并自动刷新。</p><p>那么，接下来我们首要任务是如何判断token和refreshToken过期。还记得上篇文章中我们修改GsonResponseBodyConverter类来根据后台响应码来获取data中的数据。显然在此处判断token是否过期是比较合适的。接下来看GsonResponseBodyConverter中的代码：</p><pre><code class="hljs reasonml">@Override public Object convert(ResponseBody value) throws IOException &#123;     <span class="hljs-keyword">try</span> &#123;         BasicResponse response = (BasicResponse) adapter.from<span class="hljs-constructor">Json(<span class="hljs-params">value</span>.<span class="hljs-params">charStream</span>()</span>);         <span class="hljs-keyword">if</span> (response.get<span class="hljs-constructor">Code()</span><span class="hljs-operator"> == </span>SUCCESS) &#123;             <span class="hljs-keyword">if</span> (response.get<span class="hljs-constructor">Data()</span><span class="hljs-operator"> == </span>null)                 throw <span class="hljs-keyword">new</span> <span class="hljs-constructor">ServerNoDataException(0, <span class="hljs-string">&quot;&quot;</span>)</span>;             return response.get<span class="hljs-constructor">Data()</span>;         &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (response.get<span class="hljs-constructor">Code()</span><span class="hljs-operator"> == </span>TOKEN_EXPIRED) &#123;             throw <span class="hljs-keyword">new</span> <span class="hljs-constructor">TokenExpiredException(<span class="hljs-params">response</span>.<span class="hljs-params">getCode</span>()</span>, response.get<span class="hljs-constructor">Message()</span>);         &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (response.get<span class="hljs-constructor">Code()</span><span class="hljs-operator"> == </span>REFRESH_TOKEN_EXPIRED) &#123;             throw <span class="hljs-keyword">new</span> <span class="hljs-constructor">RefreshTokenExpiredException(<span class="hljs-params">response</span>.<span class="hljs-params">getCode</span>()</span>, response.get<span class="hljs-constructor">Message()</span>);         &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (response.get<span class="hljs-constructor">Code()</span> != SUCCESS) &#123;             <span class="hljs-comment">// 特定 API 的错误，在相应的 DefaultObserver 的 onError 的方法中进行处理</span>             throw <span class="hljs-keyword">new</span> <span class="hljs-constructor">ServerResponseException(<span class="hljs-params">response</span>.<span class="hljs-params">getCode</span>()</span>, response.get<span class="hljs-constructor">Message()</span>);         &#125;     &#125; finally &#123;         value.close<span class="hljs-literal">()</span>;     &#125;     return null; &#125;</code></pre><p>上面代码中我们自定义了几个异常，在判断对应的错误码后抛出对应的异常。此处我们可以着重关心下TokenExpiredException和RefreshTokenExpiredException，分别代表了token过期和refreshToken过期。</p><h2 id="3-添加代理，实现token过期自动刷新"><a href="#3-添加代理，实现token过期自动刷新" class="headerlink" title="3.添加代理，实现token过期自动刷新"></a>3.添加代理，实现token过期自动刷新</h2><p>因为几乎所有的请求都需要验证token是否过期，因此需要做统一处理。我们可以采用代理类来对Retrofit的API做统一的代理处理。代码如下：</p><pre><code class="hljs reasonml">public <span class="hljs-keyword">class</span> IdeaApiProxy implements IGlobalManager &#123;    @<span class="hljs-constructor">SuppressWarnings(<span class="hljs-string">&quot;unchecked&quot;</span>)</span>    public &lt;T&gt; T get<span class="hljs-constructor">ApiService(Class&lt;T&gt; <span class="hljs-params">tClass</span>,String <span class="hljs-params">baseUrl</span>)</span> &#123;        T t = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">RetrofitService</span>.</span></span>get<span class="hljs-constructor">RetrofitBuilder(<span class="hljs-params">baseUrl</span>)</span>                .build<span class="hljs-literal">()</span>.create(tClass);        return (T) <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Proxy</span>.</span></span><span class="hljs-keyword">new</span><span class="hljs-constructor">ProxyInstance(<span class="hljs-params">tClass</span>.<span class="hljs-params">getClassLoader</span>()</span>, <span class="hljs-keyword">new</span> Class&lt;?&gt;<span class="hljs-literal">[]</span> &#123; tClass &#125;, <span class="hljs-keyword">new</span> <span class="hljs-constructor">ProxyHandler(<span class="hljs-params">t</span>, <span class="hljs-params">this</span>)</span>);    &#125;    @Override    public void exit<span class="hljs-constructor">Login()</span> &#123;    &#125;&#125;</code></pre><p>这样，我们就需要通过IdeaApiProxy 中的getApiService方法来创建API请求。其中的ProxyHandler则是实现了InvocationHandler。ProxyHandler类是我们处理token自动刷新的核心类。思想就是针对 method 的调用，做以 retryWhen 的包装，在retryWhen 中获取相应的异常信息来做处理，看 retryWhen 的代码：</p><pre><code class="hljs php">@Override  <span class="hljs-keyword">public</span> <span class="hljs-keyword">Object</span> invoke(<span class="hljs-keyword">Object</span> proxy, <span class="hljs-keyword">final</span> Method method, <span class="hljs-keyword">final</span> <span class="hljs-keyword">Object</span>[] args) throws <span class="hljs-built_in">Throwable</span> &#123;      <span class="hljs-keyword">return</span> Observable.just(<span class="hljs-literal">true</span>).flatMap(<span class="hljs-keyword">new</span> <span class="hljs-function"><span class="hljs-keyword">Function</span>&lt;<span class="hljs-title">Object</span>, <span class="hljs-title">ObservableSource</span>&lt;?&gt;&gt;(<span class="hljs-params"></span>) </span>&#123;          @Override          <span class="hljs-keyword">public</span> ObservableSource<span class="hljs-meta">&lt;?</span>&gt; apply(<span class="hljs-keyword">Object</span> o) throws <span class="hljs-built_in">Exception</span> &#123;              <span class="hljs-keyword">try</span> &#123;                  <span class="hljs-keyword">try</span> &#123;                      <span class="hljs-keyword">if</span> (mIsTokenNeedRefresh) &#123;                          updateMethodToken(method, args);                      &#125;                      <span class="hljs-keyword">return</span> (Observable<span class="hljs-meta">&lt;?</span>&gt;) method.invoke(mProxyObject, args);                  &#125; <span class="hljs-keyword">catch</span> (InvocationTargetException e) &#123;                      e.printStackTrace();                  &#125;              &#125; <span class="hljs-keyword">catch</span> (IllegalAccessException e) &#123;                  e.printStackTrace();              &#125;              <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;          &#125;      &#125;).retryWhen(<span class="hljs-keyword">new</span> <span class="hljs-function"><span class="hljs-keyword">Function</span>&lt;<span class="hljs-title">Observable</span>&lt;<span class="hljs-title">Throwable</span>&gt;, <span class="hljs-title">ObservableSource</span>&lt;?&gt;&gt;(<span class="hljs-params"></span>) </span>&#123;          @Override          <span class="hljs-keyword">public</span> ObservableSource<span class="hljs-meta">&lt;?</span>&gt; apply(Observable&lt;<span class="hljs-built_in">Throwable</span>&gt; observable) throws <span class="hljs-built_in">Exception</span> &#123;              <span class="hljs-keyword">return</span> observable.flatMap(<span class="hljs-keyword">new</span> <span class="hljs-function"><span class="hljs-keyword">Function</span>&lt;<span class="hljs-title">Throwable</span>, <span class="hljs-title">ObservableSource</span>&lt;?&gt;&gt;(<span class="hljs-params"></span>) </span>&#123;                  @Override                  <span class="hljs-keyword">public</span> ObservableSource<span class="hljs-meta">&lt;?</span>&gt; apply(<span class="hljs-built_in">Throwable</span> <span class="hljs-built_in">throwable</span>) throws <span class="hljs-built_in">Exception</span> &#123;                      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">throwable</span> <span class="hljs-keyword">instanceof</span> TokenExpiredException) &#123;<span class="hljs-comment">// token过期</span>                          <span class="hljs-keyword">return</span> refreshTokenWhenTokenInvalid();                      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">throwable</span> <span class="hljs-keyword">instanceof</span> RefreshTokenExpiredException) &#123;                          <span class="hljs-comment">// RefreshToken过期，执行退出登录的操作。</span>                          mGlobalManager.logout();                          <span class="hljs-keyword">return</span> Observable.<span class="hljs-built_in">error</span>(<span class="hljs-built_in">throwable</span>);                      &#125;                      <span class="hljs-keyword">return</span> Observable.<span class="hljs-built_in">error</span>(<span class="hljs-built_in">throwable</span>);                  &#125;              &#125;);          &#125;      &#125;);  &#125;</code></pre><p>这里针对 token 过期的 TokenExpiredException的异常，执行刷新 token 的操作，刷新 token 的操作则是直接调用 Retrofit 的方法，而不需要走代理了。另外它必须是个同步的代码块，一起来看refreshTokenWhenTokenInvalid方法中的代码：</p><pre><code class="hljs reasonml"><span class="hljs-keyword">private</span> Observable&lt;?&gt; refresh<span class="hljs-constructor">TokenWhenTokenInvalid()</span> &#123;        synchronized (<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ProxyHandler</span>.</span></span><span class="hljs-keyword">class</span>) &#123;            <span class="hljs-comment">// Have refreshed the token successfully in the valid time.</span>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">new</span> <span class="hljs-constructor">Date()</span>.get<span class="hljs-constructor">Time()</span> - tokenChangedTime &lt; REFRESH_TOKEN_VALID_TIME) &#123;   <span class="hljs-comment">//  防止重复刷新token</span>                mIsTokenNeedRefresh = <span class="hljs-literal">true</span>;                return <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Observable</span>.</span></span>just(<span class="hljs-literal">true</span>);            &#125; <span class="hljs-keyword">else</span> &#123;                Map&lt;String, Object&gt; map = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">MapUtils</span>.</span></span>entity<span class="hljs-constructor">ToMap(<span class="hljs-params">new</span> BaseRequestData()</span>);                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">RetrofitHelper</span>.</span></span>get<span class="hljs-constructor">ApiService()</span>                        .refresh<span class="hljs-constructor">Token(<span class="hljs-params">map</span>)</span>                        <span class="hljs-comment">//.observeOn(AndroidSchedulers.mainThread())</span>                        .subscribe(<span class="hljs-keyword">new</span> DefaultObserver&lt;RefreshTokenResponse&gt;<span class="hljs-literal">()</span> &#123;                            @Override                            public void on<span class="hljs-constructor">Success(RefreshTokenResponse <span class="hljs-params">response</span>)</span> &#123;                                <span class="hljs-keyword">if</span> (response != null) &#123;                                    <span class="hljs-comment">// 保存数据到本地</span>                                    mGlobalManager.token<span class="hljs-constructor">Refresh(<span class="hljs-params">response</span>)</span>;                                    mIsTokenNeedRefresh = <span class="hljs-literal">true</span>;                                    tokenChangedTime = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Date()</span>.get<span class="hljs-constructor">Time()</span>;                                &#125;                            &#125;                            @Override                            public void on<span class="hljs-constructor">Error(Throwable <span class="hljs-params">e</span>)</span> &#123;                                super.on<span class="hljs-constructor">Error(<span class="hljs-params">e</span>)</span>;                                mRefreshTokenError = e;                            &#125;                        &#125;);                <span class="hljs-keyword">if</span> (mRefreshTokenError != null) &#123;                    return <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Observable</span>.</span></span>error(mRefreshTokenError);                &#125; <span class="hljs-keyword">else</span> &#123;                    return <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Observable</span>.</span></span>just(<span class="hljs-literal">true</span>);                &#125;            &#125;        &#125;    &#125;</code></pre><h2 id="4-刷新token成功后替换旧的token"><a href="#4-刷新token成功后替换旧的token" class="headerlink" title="4.刷新token成功后替换旧的token"></a>4.刷新token成功后替换旧的token</h2><p>当token刷新成功之后，我们将旧的token替换掉呢？java8中的method类，已经支持了动态获取方法名称，而之前的Java版本则是不支持的。那这里怎么办呢？通过看retrofit的调用，可以知道retrofit是可以将接口中的方法转换成API请求，并需要封装参数的。那就需要看一下Retrofit是如何实现的呢？最后发现重头戏是在Retrofit对每个方法添加的@interface的注解，通过Method类中的getParameterAnnotations来进行获取，主要的代码实现如下：</p><pre><code class="hljs crystal"><span class="hljs-keyword">private</span> void updateMethodToken(Method method, Object[] args) &#123;        ServerKey serverKey = RealmDatabaseHelper.queryFirstFrom(ServerKey.<span class="hljs-keyword">class</span>);        String token = serverKey.getToken();        <span class="hljs-keyword">if</span> (mIsTokenNeedRefresh &amp;&amp; !TextUtils.isEmpty(token)) &#123;            Annotation[][] annotationsArray = method.getParameterAnnotations();            Annotation[] annotations;            <span class="hljs-keyword">if</span> (annotationsArray != null &amp;&amp; annotationsArray.length &gt; <span class="hljs-number">0</span>) &#123;                <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; annotationsArray.length; i++) &#123;                    annotations = annotationsArray[i];                    <span class="hljs-keyword">for</span> (Annotation <span class="hljs-keyword">annotation</span> : <span class="hljs-title">annotations</span>) &#123;                        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">annotation</span> <span class="hljs-title">instanceof</span> <span class="hljs-title">FieldMap</span>||<span class="hljs-title">annotation</span> <span class="hljs-title">instanceof</span> <span class="hljs-title">QueryMap</span>) &#123;// 以<span class="hljs-title">Map</span>方式提交表单                            <span class="hljs-keyword">if</span> (args[i] instanceof Map)                                ((Map&lt;String, Object&gt;) args[i]).put(TOKEN, token);                        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">annotation</span> <span class="hljs-title">instanceof</span> <span class="hljs-title">Query</span>) &#123;                            <span class="hljs-keyword">if</span> (TOKEN.equals(((Query) <span class="hljs-keyword">annotation</span>).<span class="hljs-title">value</span>())) &#123;                                args[i] = token;                            &#125;                        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">annotation</span> <span class="hljs-title">instanceof</span> <span class="hljs-title">Field</span>) &#123;                            <span class="hljs-keyword">if</span> (TOKEN.equals(((Field) <span class="hljs-keyword">annotation</span>).<span class="hljs-title">value</span>())) &#123;                                args[i] = token;                            &#125;                        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-keyword">annotation</span> <span class="hljs-title">instanceof</span> <span class="hljs-title">Part</span>)&#123;   //  上传文件                            <span class="hljs-keyword">if</span> (TOKEN.equals(((Part) <span class="hljs-keyword">annotation</span>).<span class="hljs-title">value</span>())) &#123;                                RequestBody tokenBody = RequestBody.create(MediaType.parse(<span class="hljs-string">&quot;multipart/form-data&quot;</span>), token);                                args[i] = tokenBody;                            &#125;                        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-keyword">annotation</span> <span class="hljs-title">instanceof</span> <span class="hljs-title">Body</span>)&#123;// <span class="hljs-title">Post</span>提交<span class="hljs-title">json</span>数据                            <span class="hljs-keyword">if</span>(args[i] instanceof BaseRequest)&#123;                                BaseRequest requestData= (BaseRequest) args[i];                                requestData.setToken(token);                                args[i]=requestData;                            &#125;                        &#125;                    &#125;                &#125;            &#125;            mIsTokenNeedRefresh = <span class="hljs-literal">false</span>;        &#125;    &#125;</code></pre><p>这里我们遍历所有的token字段，并将其替换成新的token。但上述方法仅仅适用于get请求和post请求以表单格式提交。如果是post请求且提交格式为json可以自行添加。另外此种方法不适用于token放在请求头的方式。</p><p><a href="https://blog.csdn.net/qq_20521573/article/details/70991850">（一）Rxjava2+Retrofit完美封装</a><br><a href="https://blog.csdn.net/qq_20521573/article/details/76100558">（二）Rxjava2+Retrofit之Token自动刷新</a><br><a href="https://blog.csdn.net/qq_20521573/article/details/78356747">（三）Rxjava2+Retrofit实现文件上传与下载</a></p><p>参考<br><a href="http://alighters.com/blog/2016/08/22/rxjava-plus-retrofitshi-xian-zhi-demo/">RxJava+Retrofit实现全局过期token自动刷新Demo篇</a> </p><p><a href="https://github.com/zhpanvip/Retrofit2/tree/token">源码下载</a></p><h3 id="好库推荐"><a href="#好库推荐" class="headerlink" title="好库推荐"></a>好库推荐</h3><p>给大家推荐一下<a href="https://github.com/zhpanvip/BannerViewPager">BannerViewPager</a>。这是一个基于ViewPager实现的具有强大功能的无限轮播库。通过<a href="https://github.com/zhpanvip/BannerViewPager">BannerViewPager</a>可以实现腾讯视频、QQ音乐、酷狗音乐、支付宝、天猫、淘宝、优酷视频、喜马拉雅、网易云音乐、哔哩哔哩等APP的Banner样式以及指示器样式。</p><p>欢迎大家到github关注<a href="https://github.com/zhpanvip/BannerViewPager">BannerViewPager</a>！</p>]]></content>
    
    
    
    <tags>
      
      <tag>RxJava</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RxJava+Retrofit完美封装（一）</title>
    <link href="/2017/04/30/RxJava-Retrofit%E5%AE%8C%E7%BE%8E%E5%B0%81%E8%A3%85%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/2017/04/30/RxJava-Retrofit%E5%AE%8C%E7%BE%8E%E5%B0%81%E8%A3%85%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p><strong><em>本篇文章已授权微信公众号 guolin_blog （郭霖）独家发布</em></strong></p><p>要说2016年最火的Android技术是什么，毫无疑问肯定是RxJava+Retrofit+Mvp。现如今2017年也已经过了快一半了。相信做android开发的小伙伴对RxJava和Retrofit也不再陌生。即使没有刻意的去学习过，也应该对RxJava和Retrofit有个一知半解。去年的时候学习了Rxjava和Retrofit的基本用法，但一直没有在实际项目中运用。今年开做新项目，果断在新项目中引入了RxJava和Retrofit。本篇文章将介绍笔者在项目中对Retrofit的封装。<br>先来看一下封装过后的Retrofit如何使用。</p><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">RetrofitHelper</span>.</span></span>get<span class="hljs-constructor">ApiService()</span>                .get<span class="hljs-constructor">Article()</span>                .compose(RxUtil.&lt;ArticleWrapper&gt;rx<span class="hljs-constructor">SchedulerHelper(<span class="hljs-params">this</span>)</span>)                .subscribe(<span class="hljs-keyword">new</span> DefaultObserver&lt;ArticleWrapper&gt;<span class="hljs-literal">()</span> &#123;                    @Override                    public void on<span class="hljs-constructor">Success(ArticleWrapper <span class="hljs-params">response</span>)</span> &#123;                        show<span class="hljs-constructor">Toast(<span class="hljs-string">&quot;Request Success，size is：&quot;</span> + <span class="hljs-params">response</span>.<span class="hljs-params">getDatas</span>()</span>.size<span class="hljs-literal">()</span>);                    &#125;                &#125;);</code></pre><p>没错，就是这么简洁的一个链式调用，可以显示加载动画，还加入了Retrofit生命周期的管理。<br>开始之前需要先在module项目里的Gradle文件中添加用到的依赖库</p><pre><code class="hljs gradle"><span class="hljs-keyword">compile</span> <span class="hljs-string">&quot;io.reactivex.rxjava2:rxjava:$rootProject.ext.rxjava2Version&quot;</span>   <span class="hljs-keyword">compile</span> <span class="hljs-string">&quot;com.squareup.retrofit2:retrofit:$rootProject.ext.retrofit2Version&quot;</span>   <span class="hljs-keyword">compile</span> <span class="hljs-string">&quot;com.squareup.retrofit2:converter-scalars:$rootProject.ext.retrofit2Version&quot;</span>   <span class="hljs-keyword">compile</span> <span class="hljs-string">&quot;com.squareup.retrofit2:converter-gson:$rootProject.ext.retrofit2Version&quot;</span>   <span class="hljs-keyword">compile</span> <span class="hljs-string">&quot;com.squareup.retrofit2:adapter-rxjava2:$rootProject.ext.retrofit2Version&quot;</span>   <span class="hljs-keyword">compile</span> <span class="hljs-string">&#x27;com.jakewharton.retrofit:retrofit2-rxjava2-adapter:1.0.0&#x27;</span>   <span class="hljs-keyword">compile</span> <span class="hljs-string">&#x27;io.reactivex.rxjava2:rxandroid:2.0.1&#x27;</span>   <span class="hljs-keyword">compile</span> <span class="hljs-string">&#x27;com.squareup.okhttp3:logging-interceptor:3.4.1&#x27;</span>   <span class="hljs-keyword">compile</span> <span class="hljs-string">&quot;com.trello.rxlifecycle2:rxlifecycle:$rootProject.ext.rxlifecycle&quot;</span>   <span class="hljs-comment">//compile &quot;com.trello.rxlifecycle2:rxlifecycle-android:$rootProject.ext.rxlifecycle&quot;</span>   <span class="hljs-keyword">compile</span> <span class="hljs-string">&quot;com.trello.rxlifecycle2:rxlifecycle-components:$rootProject.ext.rxlifecycle&quot;</span></code></pre><p>为了方便依赖库版本的修改我们采用”io.reactivex.rxjava2:rxjava:$rootProject.ext.rxjava2Version”这中方式添加依赖，因此需要在project的build.gradle文件的加上以下内容：</p><pre><code class="hljs lsl">ext &#123;    supportLibVersion = &#x27;<span class="hljs-number">25.1</span><span class="hljs-number">.0</span>&#x27;    butterknifeVersion = &#x27;<span class="hljs-number">8.5</span><span class="hljs-number">.1</span>&#x27;    rxjava2Version = &#x27;<span class="hljs-number">2.0</span><span class="hljs-number">.8</span>&#x27;    retrofit2Version = &#x27;<span class="hljs-number">2.2</span><span class="hljs-number">.0</span>&#x27;    rxlifecycle=&#x27;<span class="hljs-number">2.1</span><span class="hljs-number">.0</span>&#x27;    gsonVersion = &#x27;<span class="hljs-number">2.8</span><span class="hljs-number">.0</span>&#x27;&#125;</code></pre><p>下面将通过几个小节对本次封装作详细的解析：</p><ul><li>服务器响应数据的基类BasicResponse</li><li>构建初始化Retrofit的工具类IdeaApi</li><li>通过GsonConverterFactory获取真实响应数据</li><li>封装DefaultObserver处理服务器响应</li><li>处理加载Loading</li><li>管理Retrofit生命周期</li><li>如何使用封装</li><li>小结</li></ul><h2 id="一-服务器响应数据的基类BasicResponse。"><a href="#一-服务器响应数据的基类BasicResponse。" class="headerlink" title="一.服务器响应数据的基类BasicResponse。"></a>一.服务器响应数据的基类BasicResponse。</h2><p>假定服务器返回的Json数据格式如下：</p><pre><code class="hljs clojure">&#123; <span class="hljs-string">&quot;code&quot;</span>: <span class="hljs-number">200</span>, <span class="hljs-string">&quot;message&quot;</span>: <span class="hljs-string">&quot;成功&quot;</span>, <span class="hljs-string">&quot;content&quot;</span>: &#123;...&#125;&#125;</code></pre><p>根据Json数据格式构建我们的BasicResponse（BasicResponse中的字段内容需要根据自己服务器返回的数据确定）。代码如下：</p><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BasicResponse</span>&lt;T&gt; &#123;</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> code;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">String</span> message;    <span class="hljs-keyword">private</span> T content;...此处省去<span class="hljs-built_in">get</span>、<span class="hljs-built_in">set</span>方法。</code></pre><h2 id="二-构建初始化Retrofit的工具类IdeaApi。"><a href="#二-构建初始化Retrofit的工具类IdeaApi。" class="headerlink" title="二.构建初始化Retrofit的工具类IdeaApi。"></a>二.构建初始化Retrofit的工具类IdeaApi。</h2><p>该类通过RetrofitUtils来获取ApiService的实例。代码如下：</p><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IdeaApi</span> &#123;</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">getApiService</span><span class="hljs-params">(Class&lt;T&gt; cls,<span class="hljs-keyword">String</span> baseUrl)</span> </span>&#123;        Retrofit retrofit = RetrofitUtils .getRetrofitBuilder(baseUrl).build();        <span class="hljs-keyword">return</span> retrofit.create(cls);    &#125;&#125;</code></pre><p>RetrofitUtils用来构建Retrofit.Builder，并对OkHttp做以下几个方面的配置：</p><ol><li>设置日志拦截器，拦截服务器返回的json数据。Retrofit将请求到json数据直接转换成了实体类，但有时候我们需要查看json数据，Retrofit并没有提供直接获取json数据的功能。因此我们需要自定义一个日志拦截器拦截json数据，并输入到控制台。</li><li>设置Http请求头。给OkHttp 添加请求头拦截器，配置请求头信息。还可以为接口统一添加请求头数据。例如，把用户名、密码（或者token）统一添加到请求头。后续每个接口的请求头中都会携带用户名、密码（或者token）数据，避免了为每个接口单独添加。</li><li>为OkHttp配置缓存。同样可以同过拦截器实现缓存处理。包括控制缓存的最大生命值，控制缓存的过期时间。</li><li>如果采用https，我们还可以在此处理证书校验以及服务器校验。</li><li>为Retrofit添加GsonConverterFactory。此处是一个比较重要的环节，将在后边详细讲解。<br>RetrofitUtils 代码如下：<pre><code class="hljs reasonml">public <span class="hljs-keyword">class</span> RetrofitUtils &#123;    public static OkHttpClient.Builder get<span class="hljs-constructor">OkHttpClientBuilder()</span> &#123;        HttpLoggingInterceptor loggingInterceptor = <span class="hljs-keyword">new</span> <span class="hljs-constructor">HttpLoggingInterceptor(<span class="hljs-params">new</span> HttpLoggingInterceptor.Logger()</span> &#123;            @Override            public void log(String message) &#123;                <span class="hljs-keyword">try</span> &#123;                    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">LogUtils</span>.</span></span>e(<span class="hljs-string">&quot;OKHttp-----&quot;</span>, <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">URLDecoder</span>.</span></span>decode(message, <span class="hljs-string">&quot;utf-8&quot;</span>));                &#125; catch (UnsupportedEncodingException e) &#123;                    e.print<span class="hljs-constructor">StackTrace()</span>;                    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">LogUtils</span>.</span></span>e(<span class="hljs-string">&quot;OKHttp-----&quot;</span>, message);                &#125;            &#125;        &#125;);        loggingInterceptor.set<span class="hljs-constructor">Level(HttpLoggingInterceptor.Level.BODY)</span>;        File cacheFile = <span class="hljs-keyword">new</span> <span class="hljs-constructor">File(Utils.<span class="hljs-params">getContext</span>()</span>.get<span class="hljs-constructor">CacheDir()</span>, <span class="hljs-string">&quot;cache&quot;</span>);        Cache cache = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Cache(<span class="hljs-params">cacheFile</span>, 1024 <span class="hljs-operator">*</span> 1024 <span class="hljs-operator">*</span> 100)</span>; <span class="hljs-comment">//100Mb</span>        return <span class="hljs-keyword">new</span> OkHttpClient.<span class="hljs-constructor">Builder()</span>                .read<span class="hljs-constructor">Timeout(Constants.DEFAULT_TIMEOUT, TimeUnit.MILLISECONDS)</span>                .connect<span class="hljs-constructor">Timeout(Constants.DEFAULT_TIMEOUT, TimeUnit.MILLISECONDS)</span>                .add<span class="hljs-constructor">Interceptor(<span class="hljs-params">loggingInterceptor</span>)</span>                .add<span class="hljs-constructor">Interceptor(<span class="hljs-params">new</span> HttpHeaderInterceptor()</span>)                .add<span class="hljs-constructor">NetworkInterceptor(<span class="hljs-params">new</span> HttpCacheInterceptor()</span>)               <span class="hljs-comment">// .sslSocketFactory(SslContextFactory.getSSLSocketFactoryForTwoWay())  // https认证 如果要使用https且为自定义证书 可以去掉这两行注释，并自行配制证书。</span>               <span class="hljs-comment">// .hostnameVerifier(new SafeHostnameVerifier())</span>                .cache(cache);    &#125;    public static Retrofit.Builder get<span class="hljs-constructor">RetrofitBuilder(String <span class="hljs-params">baseUrl</span>)</span> &#123;        Gson gson = <span class="hljs-keyword">new</span> <span class="hljs-constructor">GsonBuilder()</span>.set<span class="hljs-constructor">DateFormat(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>)</span>.serialize<span class="hljs-constructor">Nulls()</span>.create<span class="hljs-literal">()</span>;        OkHttpClient okHttpClient = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">RetrofitUtils</span>.</span></span>get<span class="hljs-constructor">OkHttpClientBuilder()</span>.build<span class="hljs-literal">()</span>;        return <span class="hljs-keyword">new</span> Retrofit.<span class="hljs-constructor">Builder()</span>                .client(okHttpClient)                .add<span class="hljs-constructor">ConverterFactory(GsonConverterFactory.<span class="hljs-params">create</span>(<span class="hljs-params">gson</span>)</span>)                .add<span class="hljs-constructor">CallAdapterFactory(RxJava2CallAdapterFactory.<span class="hljs-params">create</span>()</span>)                .base<span class="hljs-constructor">Url(<span class="hljs-params">baseUrl</span>)</span>;    &#125;&#125;</code></pre></li></ol><h2 id="三-通过GsonConverterFactory获取真实响应数据"><a href="#三-通过GsonConverterFactory获取真实响应数据" class="headerlink" title="三.通过GsonConverterFactory获取真实响应数据"></a>三.通过GsonConverterFactory获取真实响应数据</h2><p>在第一节中我们构建了服务器响应数据BasicResponse，BasicResponse由code、message、和content三个字段。其中code为服务器返回的错误码。我们会事先和服务器约定成功时的code值，比如200表示请求成功。但通常在请求服务器数据过程中免不了会出现各种错误。例如用户登录时密码错误、请求参数错误的情况。此时服务器会根据错误情况返回对应的错误码。一般来说，我们只关心成功时即code为200时的content数据。而对于code不为200时我们只需要给出对应的Toast提示即可。事实上我们对我们有用的仅仅时code为200时的content数据。因此我们可以考虑过滤掉code和message，在请求成功的回调中只返回content的内容。<br>在此种情况下就需要我们通过自定义GsonConverterFactory来实现了。我们可以直接从Retrofit的源码中copy出GsonConverterFactory的三个相关类来做修改。<br>其中最终要的一部分是修改GsonResponseBodyConverter中的convert方法。在该方法中拿到服务器响应数据并判断code是否为200。如果是，则获取到content并返回，如果不是，则在此处可以抛出对应的自定义的异常。然后再Observer中统一处理异常情况。GsonResponseBodyConverter代码如下：</p><pre><code class="hljs angelscript"><span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-symbol">GsonResponseBodyConverter</span>&lt;<span class="hljs-symbol">T</span>&gt; <span class="hljs-symbol">implements</span> <span class="hljs-symbol">Converter</span>&lt;<span class="hljs-symbol">ResponseBody, <span class="hljs-symbol">Object</span></span>&gt; &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> TypeAdapter&lt;T&gt; adapter;    GsonResponseBodyConverter(TypeAdapter&lt;T&gt; adapter) &#123;        <span class="hljs-keyword">this</span>.adapter = adapter;    &#125;    @Override    <span class="hljs-keyword">public</span> Object convert(ResponseBody value) throws IOException &#123;        <span class="hljs-keyword">try</span> &#123;            BasicResponse response = (BasicResponse) adapter.fromJson(value.charStream());            <span class="hljs-keyword">if</span> (response.getCode()==<span class="hljs-number">200</span>) &#123;            <span class="hljs-keyword">return</span> response.getResults();            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-comment">// 特定 API 的错误，在相应的 DefaultObserver 的 onError 的方法中进行处理</span>                throw new ServerResponseException(response.getCode(), response.getMessage());            &#125;        &#125; finally &#123;            value.close();        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;    &#125;&#125;</code></pre><h2 id="四-构建DefaultObserver处理服务器响应。"><a href="#四-构建DefaultObserver处理服务器响应。" class="headerlink" title="四.构建DefaultObserver处理服务器响应。"></a>四.构建DefaultObserver处理服务器响应。</h2><p>上一节中我们讲到了在请求服务器时可能出现的一些例如密码错误、参数错误的情况，服务器给我们返回了对应的错误码，我们根据错误码抛出了对应自定义异常。除此之外在我们发起网络请求时还可能发生一些异常情况。例如没有网络、请求超时或者服务器返回了数据但在解析时出现了数据解析异常等。对于这样的情况我们也要进行统一处理的。那么我们就需要自定义一个DefaultObserver类继承Observer，并重写相应的方法。<br>该类中最重要的两个方法时onNext和onError。<br><strong>1.在服务器返回数据成功的情况下会回调到onNext方法。</strong>因此我们可以在DefaultObserver中定义一个抽象方法onSuccess(T response)，在调用网络时重写onSuccess方法即可。<br><strong>2.如果在请求服务器过程中出现任何异常，都会回调到onError方法中。</strong>包括上节中我们自己抛出的异常都会回调到onError。因此我们的重头戏就是处理onError。在onError中我们根据异常信息给出对应的Toast提示即可。<br>DefaultObserver类的代码如下：</p><pre><code class="hljs reasonml">public abstract <span class="hljs-keyword">class</span> DefaultObserver&lt;T&gt; implements Observer&lt;T&gt; &#123;    @Override    public void on<span class="hljs-constructor">Subscribe(Disposable <span class="hljs-params">d</span>)</span> &#123;    &#125;    @Override    public void on<span class="hljs-constructor">Next(T <span class="hljs-params">response</span>)</span> &#123;        on<span class="hljs-constructor">Success(<span class="hljs-params">response</span>)</span>;        on<span class="hljs-constructor">Finish()</span>;    &#125;    @Override    public void on<span class="hljs-constructor">Error(Throwable <span class="hljs-params">e</span>)</span> &#123;        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">LogUtils</span>.</span></span>e(<span class="hljs-string">&quot;Retrofit&quot;</span>, e.get<span class="hljs-constructor">Message()</span>);        <span class="hljs-keyword">if</span> (e instanceof HttpException) &#123;     <span class="hljs-comment">//   HTTP错误</span>            on<span class="hljs-constructor">Exception(ExceptionReason.BAD_NETWORK)</span>;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e instanceof ConnectException<span class="hljs-operator">                || </span>e instanceof UnknownHostException) &#123;   <span class="hljs-comment">//   连接错误</span>            on<span class="hljs-constructor">Exception(ExceptionReason.CONNECT_ERROR)</span>;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e instanceof InterruptedIOException) &#123;   <span class="hljs-comment">//  连接超时</span>            on<span class="hljs-constructor">Exception(ExceptionReason.CONNECT_TIMEOUT)</span>;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e instanceof JsonParseException<span class="hljs-operator">                || </span>e instanceof JSONException<span class="hljs-operator">                || </span>e instanceof ParseException) &#123;   <span class="hljs-comment">//  解析错误</span>            on<span class="hljs-constructor">Exception(ExceptionReason.PARSE_ERROR)</span>;        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(e instanceof ServerResponseException)&#123;            on<span class="hljs-constructor">Fail(<span class="hljs-params">e</span>.<span class="hljs-params">getMessage</span>()</span>);        &#125; <span class="hljs-keyword">else</span> &#123;            on<span class="hljs-constructor">Exception(ExceptionReason.UNKNOWN_ERROR)</span>;        &#125;        on<span class="hljs-constructor">Finish()</span>;    &#125;    @Override    public void on<span class="hljs-constructor">Complete()</span> &#123;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 请求成功</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * @param response 服务器返回的数据</span><span class="hljs-comment">     */</span>    abstract public void on<span class="hljs-constructor">Success(T <span class="hljs-params">response</span>)</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 服务器返回数据，但响应码不为200</span><span class="hljs-comment">     *</span><span class="hljs-comment">     */</span>    public void on<span class="hljs-constructor">Fail(String <span class="hljs-params">message</span>)</span> &#123;        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ToastUtils</span>.</span></span>show(message);    &#125;        public void on<span class="hljs-constructor">Finish()</span>&#123;&#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 请求异常</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * @param reason</span><span class="hljs-comment">     */</span>    public void on<span class="hljs-constructor">Exception(ExceptionReason <span class="hljs-params">reason</span>)</span> &#123;        switch (reason) &#123;            case CONNECT_ERROR:                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ToastUtils</span>.</span></span>show(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">R</span>.</span></span><span class="hljs-built_in">string</span>.connect_error, Toast.LENGTH_SHORT);                break;            case CONNECT_TIMEOUT:                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ToastUtils</span>.</span></span>show(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">R</span>.</span></span><span class="hljs-built_in">string</span>.connect_timeout, Toast.LENGTH_SHORT);                break;            case BAD_NETWORK:                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ToastUtils</span>.</span></span>show(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">R</span>.</span></span><span class="hljs-built_in">string</span>.bad_network, Toast.LENGTH_SHORT);                break;            case PARSE_ERROR:                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ToastUtils</span>.</span></span>show(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">R</span>.</span></span><span class="hljs-built_in">string</span>.parse_error, Toast.LENGTH_SHORT);                break;            case UNKNOWN_ERROR:            default:                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ToastUtils</span>.</span></span>show(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">R</span>.</span></span><span class="hljs-built_in">string</span>.unknown_error, Toast.LENGTH_SHORT);                break;        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 请求网络失败原因</span><span class="hljs-comment">     */</span>    public enum ExceptionReason &#123;        <span class="hljs-comment">/**</span><span class="hljs-comment">         * 解析数据失败</span><span class="hljs-comment">         */</span>        PARSE_ERROR,        <span class="hljs-comment">/**</span><span class="hljs-comment">         * 网络问题</span><span class="hljs-comment">         */</span>        BAD_NETWORK,        <span class="hljs-comment">/**</span><span class="hljs-comment">         * 连接错误</span><span class="hljs-comment">         */</span>        CONNECT_ERROR,        <span class="hljs-comment">/**</span><span class="hljs-comment">         * 连接超时</span><span class="hljs-comment">         */</span>        CONNECT_TIMEOUT,        <span class="hljs-comment">/**</span><span class="hljs-comment">         * 未知错误</span><span class="hljs-comment">         */</span>        UNKNOWN_ERROR,    &#125;&#125;</code></pre><h2 id="五-处理加载Loading"><a href="#五-处理加载Loading" class="headerlink" title="五.处理加载Loading"></a>五.处理加载Loading</h2><p>关于Loading我们可以通过RxJava的compose操作符来做一个非常优雅的处理。首先定义一个ProgressUtils工具类，然后通过RxJava的ObservableTransformer做一个变换来处理Loading。想要显示Loading，只需要加上.compose(ProgressUtils.&lt; T &gt;applyProgressBar(this))即可。<br>ProgressUtils代码如下：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProgressUtils</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">ObservableTransformer&lt;T, T&gt; <span class="hljs-title">applyProgressBar</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">            <span class="hljs-meta">@NonNull</span> <span class="hljs-keyword">final</span> Activity activity, String msg)</span> </span>&#123;        <span class="hljs-keyword">final</span> WeakReference&lt;Activity&gt; activityWeakReference = <span class="hljs-keyword">new</span> WeakReference&lt;&gt;(activity);        <span class="hljs-keyword">final</span> DialogUtils dialogUtils = <span class="hljs-keyword">new</span> DialogUtils();        dialogUtils.showProgress(activityWeakReference.get());        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ObservableTransformer&lt;T, T&gt;() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> ObservableSource&lt;T&gt; <span class="hljs-title">apply</span><span class="hljs-params">(Observable&lt;T&gt; upstream)</span> </span>&#123;                <span class="hljs-keyword">return</span> upstream.doOnSubscribe(<span class="hljs-keyword">new</span> Consumer&lt;Disposable&gt;() &#123;                    <span class="hljs-meta">@Override</span>                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">accept</span><span class="hljs-params">(Disposable disposable)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                    &#125;                &#125;).doOnTerminate(<span class="hljs-keyword">new</span> Action() &#123;                    <span class="hljs-meta">@Override</span>                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                        Activity context;                        <span class="hljs-keyword">if</span> ((context = activityWeakReference.get()) != <span class="hljs-keyword">null</span>                                &amp;&amp; !context.isFinishing()) &#123;                            dialogUtils.dismissProgress();                        &#125;                    &#125;                &#125;).doOnSubscribe(<span class="hljs-keyword">new</span> Consumer&lt;Disposable&gt;() &#123;                    <span class="hljs-meta">@Override</span>                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">accept</span><span class="hljs-params">(Disposable disposable)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;                        <span class="hljs-comment">/*Activity context;</span><span class="hljs-comment">                        if ((context = activityWeakReference.get()) != null</span><span class="hljs-comment">                                &amp;&amp; !context.isFinishing()) &#123;</span><span class="hljs-comment">                            dialogUtils.dismissProgress();</span><span class="hljs-comment">                        &#125;*/</span>                    &#125;                &#125;);            &#125;        &#125;;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">ObservableTransformer&lt;T, T&gt; <span class="hljs-title">applyProgressBar</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">            <span class="hljs-meta">@NonNull</span> <span class="hljs-keyword">final</span> Activity activity)</span> </span>&#123;        <span class="hljs-keyword">return</span> applyProgressBar(activity, <span class="hljs-string">&quot;&quot;</span>);    &#125;&#125;</code></pre><p>至此关于RxJava和Retrofit的二次封装已经基本完成。但是我们不能忽略了很重要的一点，就是网络请求的生命周期。我们将在下一节中详细讲解。</p><h2 id="六、管理Retrofit生命周期"><a href="#六、管理Retrofit生命周期" class="headerlink" title="六、管理Retrofit生命周期"></a>六、管理Retrofit生命周期</h2><p>当activity被销毁时，网络请求也应该随之终止的。要不然就可能造成内存泄漏。会严重影到响App的性能！因此Retrofit生命周期的管理也是比较重要的一点内容。在这里我们使用 **<a href="https://github.com/trello/RxLifecycle">RxLifecycle</a>**来对Retrofit进行生命周期管理。其使用流程如下：</p><p><strong>1.在gradel中添加依赖如下：</strong></p><pre><code class="hljs apache"><span class="hljs-attribute">compile</span> &#x27;com.trello.rxlifecycle<span class="hljs-number">2</span>:rxlifecycle:<span class="hljs-number">2</span>.<span class="hljs-number">1</span>.<span class="hljs-number">0</span>&#x27;<span class="hljs-attribute">compile</span> &#x27;com.trello.rxlifecycle<span class="hljs-number">2</span>:rxlifecycle-components:<span class="hljs-number">2</span>.<span class="hljs-number">1</span>.<span class="hljs-number">0</span>&#x27;</code></pre><p><strong>2.让我们的BaseActivity继承RxAppCompatActivity。</strong><br>具体代码如下：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RxAppCompatActivity</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> </span>&#123;        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState);        setContentView(getLayoutId());        init(savedInstanceState);    &#125;    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">showToast</span><span class="hljs-params">(String msg)</span> </span>&#123;        ToastUtils.show(msg);    &#125;    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-meta">@LayoutRes</span> <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getLayoutId</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(Bundle savedInstanceState)</span></span>;&#125;</code></pre><p>同样我们项目的BaseFragment继承RxFragment（注意使用继承V4包下的RxFragment），如下：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseFragment</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RxFragment</span> </span>&#123;    <span class="hljs-keyword">public</span> View rootView;    <span class="hljs-keyword">public</span> LayoutInflater inflater;    <span class="hljs-meta">@Nullable</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> View <span class="hljs-title">onCreateView</span><span class="hljs-params">(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState)</span> </span>&#123;        <span class="hljs-keyword">super</span>.onCreateView(inflater, container, savedInstanceState);        <span class="hljs-keyword">this</span>.inflater = inflater;        <span class="hljs-keyword">if</span> (rootView == <span class="hljs-keyword">null</span>) &#123;            rootView = inflater.inflate(<span class="hljs-keyword">this</span>.getLayoutId(), container, <span class="hljs-keyword">false</span>);            init(savedInstanceState);        &#125;        ViewGroup parent = (ViewGroup) rootView.getParent();        <span class="hljs-keyword">if</span> (parent != <span class="hljs-keyword">null</span>) &#123;            parent.removeView(rootView);        &#125;        <span class="hljs-keyword">return</span> rootView;    &#125;    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getLayoutId</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(Bundle savedInstanceState)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">showToast</span><span class="hljs-params">(String msg)</span> </span>&#123;        ToastUtils.show(msg);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onResume</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">super</span>.onResume();    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onPause</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">super</span>.onPause();    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onDestroyView</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">super</span>.onDestroyView();    &#125;&#125;</code></pre><p>3.使用compose操作符管理Retrofit生命周期了:</p><pre><code class="hljs css"><span class="hljs-selector-tag">myObservable</span>            <span class="hljs-selector-class">.compose</span>(<span class="hljs-selector-tag">bindToLifecycle</span>())            <span class="hljs-selector-class">.subscribe</span>();或者<span class="hljs-selector-tag">myObservable</span>    <span class="hljs-selector-class">.compose</span>(<span class="hljs-selector-tag">RxLifecycle</span><span class="hljs-selector-class">.bindUntilEvent</span>(<span class="hljs-selector-tag">lifecycle</span>, <span class="hljs-selector-tag">ActivityEvent</span><span class="hljs-selector-class">.DESTROY</span>))    <span class="hljs-selector-class">.subscribe</span>();</code></pre><p>关于RxLifecycle的详细使用方法可以参考 <strong><a href="https://github.com/trello/RxLifecycle">RxLifecycle官网</a></strong></p><h2 id="七-如何使用封装"><a href="#七-如何使用封装" class="headerlink" title="七.如何使用封装"></a>七.如何使用封装</h2><p>前面几节内容讲解了如何RxJava进行二次封装，封装部分的代码可以放在我们项目的Library模块中。那么封装好之后我们应该如何在app模块中使用呢？<br><strong>1.定义一个接口来存放我们项目的API</strong></p><pre><code class="hljs less"><span class="hljs-selector-tag">public</span> <span class="hljs-selector-tag">interface</span> <span class="hljs-selector-tag">IdeaApiService</span> &#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 此接口服务器响应数据BasicResponse的泛型T应该是List&lt;MeiZi&gt;</span><span class="hljs-comment">     * 即BasicResponse&lt;List&lt;MeiZi&gt;&gt;</span><span class="hljs-comment">     * @return BasicResponse&lt;List&lt;MeiZi&gt;&gt;</span><span class="hljs-comment">     */</span>    <span class="hljs-variable">@Headers</span>(<span class="hljs-string">&quot;Cache-Control: public, max-age=10&quot;</span>)<span class="hljs-comment">//设置缓存 缓存时间为100s</span>    <span class="hljs-variable">@GET</span>(<span class="hljs-string">&quot;福利/10/1&quot;</span>)    Observable&lt;List&lt;MeiZi&gt;&gt; getMezi();    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 登录 接口为假接口 并不能返回数据</span><span class="hljs-comment">     * @return</span><span class="hljs-comment">     */</span>    <span class="hljs-variable">@POST</span>(<span class="hljs-string">&quot;login.do&quot;</span>)    Observable&lt;LoginResponse&gt; login(<span class="hljs-variable">@Body</span> LoginRequest request);    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 刷新token 接口为假接口 并不能返回数据</span><span class="hljs-comment">     * @return</span><span class="hljs-comment">     */</span>    <span class="hljs-variable">@POST</span>(<span class="hljs-string">&quot;refresh_token.do&quot;</span>)    Observable&lt;RefreshTokenResponseBean&gt; refreshToken(<span class="hljs-variable">@Body</span> RefreshTokenRequest request);    <span class="hljs-variable">@Multipart</span>    <span class="hljs-variable">@POST</span>(<span class="hljs-string">&quot;upload/uploadFile.do&quot;</span>)    Observable&lt;BasicResponse&gt; uploadFiles(<span class="hljs-variable">@Part</span> List&lt;MultipartBody.Part&gt; partList);&#125;</code></pre><p><strong>2.定义一个RetrofitHelper 类，通过IdeaApi来获取IdeaApiService的实例。</strong></p><pre><code class="hljs cpp"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RetrofitHelper</span> &#123;</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> IdeaApiService mIdeaApiService;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> IdeaApiService <span class="hljs-title">getApiService</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> mIdeaApiService;    &#125;    <span class="hljs-keyword">static</span> &#123;       mIdeaApiService= IdeaApi.getApiService(IdeaApiService.class, Constants.API_SERVER_URL);    &#125;&#125;</code></pre><p><strong>3.在Activity或者Fragment中发起网络请求</strong></p><pre><code class="hljs reasonml"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Get请求</span><span class="hljs-comment"> * @param view</span><span class="hljs-comment"> */</span>public void get<span class="hljs-constructor">Data(View <span class="hljs-params">view</span>)</span> &#123;    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">RetrofitHelper</span>.</span></span>get<span class="hljs-constructor">ApiService()</span>            .get<span class="hljs-constructor">Mezi()</span>            .compose(this.&lt;List&lt;MeiZi&gt;&gt;bind<span class="hljs-constructor">ToLifecycle()</span>)            .compose(ProgressUtils.&lt;List&lt;MeiZi&gt;&gt;apply<span class="hljs-constructor">ProgressBar(<span class="hljs-params">this</span>)</span>)            .subscribe<span class="hljs-constructor">On(Schedulers.<span class="hljs-params">io</span>()</span>)            .observe<span class="hljs-constructor">On(AndroidSchedulers.<span class="hljs-params">mainThread</span>()</span>)            .subscribe(<span class="hljs-keyword">new</span> DefaultObserver&lt;List&lt;MeiZi&gt;&gt;<span class="hljs-literal">()</span> &#123;                @Override                public void on<span class="hljs-constructor">Success(List&lt;MeiZi&gt; <span class="hljs-params">response</span>)</span> &#123;                    show<span class="hljs-constructor">Toast(<span class="hljs-string">&quot;请求成功，妹子个数为&quot;</span> + <span class="hljs-params">response</span>.<span class="hljs-params">size</span>()</span>);                &#125;            &#125;);&#125;</code></pre><h2 id="八-小结"><a href="#八-小结" class="headerlink" title="八.小结"></a>八.小结</h2><p>本篇文章主要讲解了Rxjava和Retrofit的二次封装。以上内容也是笔者参考多方面的资料经过长时间的改动优化而来。但鉴于本人能力有限，其中也避免不了出现不当之处。还请大家多多包涵。另外，在投稿郭神公众号时文章可能还存在很多处理不优雅的地方，比如对响应数据的处理以及对Loading的处理。在投稿被推送后收到了很多小伙伴的建议，因此笔者也参考了大家的意见并做了优化，在此感谢大家。最后如果有疑问欢迎在文章留言评论。</p><p><a href="https://blog.csdn.net/qq_20521573/article/details/76100558">（二）Rxjava2+Retrofit之Token自动刷新</a><br><a href="https://blog.csdn.net/qq_20521573/article/details/78356747">（三）Rxjava2+Retrofit实现文件上传与下载</a></p><p><a href="https://github.com/zhpanvip/Retrofit2"> 源码传送门</a></p><h3 id="好库推荐"><a href="#好库推荐" class="headerlink" title="好库推荐"></a>好库推荐</h3><p>给大家推荐一下<a href="https://github.com/zhpanvip/BannerViewPager">BannerViewPager</a>。这是一个基于ViewPager实现的具有强大功能的无限轮播库。通过<a href="https://github.com/zhpanvip/BannerViewPager">BannerViewPager</a>可以实现腾讯视频、QQ音乐、酷狗音乐、支付宝、天猫、淘宝、优酷视频、喜马拉雅、网易云音乐、哔哩哔哩等APP的Banner样式以及指示器样式。</p><p>欢迎大家到github关注<a href="https://github.com/zhpanvip/BannerViewPager">BannerViewPager</a>！</p>]]></content>
    
    
    
    <tags>
      
      <tag>RxJava</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BaseActivity中封装通用的Toolbar</title>
    <link href="/2017/04/28/BaseActivity%E4%B8%AD%E5%B0%81%E8%A3%85%E9%80%9A%E7%94%A8%E7%9A%84Toolbar/"/>
    <url>/2017/04/28/BaseActivity%E4%B8%AD%E5%B0%81%E8%A3%85%E9%80%9A%E7%94%A8%E7%9A%84Toolbar/</url>
    
    <content type="html"><![CDATA[<p>之前写过一篇关于如何使用Toolbar的文章，最近在搭建新项目时对Toolbar做了封装。封装的预期目标是只在BaseActivity中引入Toolbar，然后子Activity通过继承BaseActivity就能显示Toolbar。接下来就看看如何实现这样的功能。<br>因为我们使用toolbar作为titlebar，因此首先需要去掉Actionbar。在style文件下修改默认Theme的parent为Theme.AppCompat.Light.NoActionBar便可以去掉默认的Actionbar，如下：</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;AppTheme&quot;</span> <span class="hljs-attr">parent</span>=<span class="hljs-string">&quot;Theme.AppCompat.Light.NoActionBar&quot;</span>&gt;</span><span class="xml">    <span class="hljs-comment">&lt;!-- Customize your theme here. --&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;colorPrimary&quot;</span>&gt;</span>@color/colorPrimary<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;colorPrimaryDark&quot;</span>&gt;</span>@color/colorPrimaryDark<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;colorAccent&quot;</span>&gt;</span>@color/colorAccent<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></code></pre><p>然后定义一个toolbar_layout的xml文件，在toolbar中加入俩个TextView作为标题和子标题，如下：</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">android.support.v7.widget.Toolbar</span></span><span class="hljs-tag">    <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/toolbar&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">android:background</span>=<span class="hljs-string">&quot;@color/colorPrimary&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">android:minHeight</span>=<span class="hljs-string">&quot;?attr/actionBarSize&quot;</span>&gt;</span>    <span class="hljs-comment">&lt;!--自定义toolbar的title 和subtitle --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span></span><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/tv_right&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;@style/TextAppearance.AppCompat.Widget.ActionBar.Subtitle&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:maxLines</span>=<span class="hljs-string">&quot;1&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:textColor</span>=<span class="hljs-string">&quot;@color/white&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;right&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:paddingRight</span>=<span class="hljs-string">&quot;10dp&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:layout_gravity</span>=<span class="hljs-string">&quot;right&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span></span><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/tv_title&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;@style/TextAppearance.AppCompat.Widget.ActionBar.Title&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:lines</span>=<span class="hljs-string">&quot;1&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:ellipsize</span>=<span class="hljs-string">&quot;end&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;title&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:scrollHorizontally</span>=<span class="hljs-string">&quot;true&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:textColor</span>=<span class="hljs-string">&quot;@color/white&quot;</span></span><span class="hljs-tag">        <span class="hljs-attr">android:layout_gravity</span>=<span class="hljs-string">&quot;center&quot;</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">android.support.v7.widget.Toolbar</span>&gt;</span></code></pre><p>接着在BaseActivity的布局文件中include进toolbar_layout，如下：</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">LinearLayout</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><span class="hljs-tag">    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">layout</span>=<span class="hljs-string">&quot;@layout/toolbar_layout&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">LinearLayout</span>&gt;</span></code></pre><p>这样BaseActivity中就可以正常显示出Toolbar了。那么如何实现子Activity继承BaseActivity而显示toolbar呢？其实我们可以在BaseActivity中做文章。<br>首先在BaseActivity中声明一个LinearLayout,然后把BaseActivity的布局文件添加到该LinearLayout中。我们知道子Activity通过setContentView()方法来关联布局文件，因此我们可以在BaseActivity中去重写setContentView()方法，在重写的setContentView中把子类的布局文件也添加到事先声明的LinearLayout中，接下来应该解决如何将这个LinearLayout与Activity关联。查阅相关资料可以知道，可以通过 findViewById(android.R.id.content)拿到window的ViewGroup然后将刚才声明的LinearLayout添加到这个ViewGroup中，这样就可以在子Activity中显示出BaseActivity中的Toolbar了。（具体原因可以查阅android.R.id.content和 DecorView）代码如下：</p><pre><code class="hljs smali">public<span class="hljs-keyword"> abstract</span> class BaseActivity extends AppCompatActivity&#123;     //the container of this activity layout<span class="hljs-built_in"> and </span>sub-activity layout   <span class="hljs-keyword"> private</span> <span class="hljs-class">LinearLayout parentLinearLayout;</span>        @Override   <span class="hljs-keyword"> public</span> void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        initContentView(R.layout.activity_base);        setContentView(getLayoutId());        initToolBar();        init();    &#125;//  overwrite the function in<span class="hljs-built_in"> sub-activity </span>and<span class="hljs-built_in"> return </span>the layout id of<span class="hljs-built_in"> sub-activity </span>  <span class="hljs-keyword"> protected</span><span class="hljs-keyword"> abstract</span><span class="hljs-built_in"> int </span>getLayoutId(); <span class="hljs-keyword"> private</span> void initContentView(@LayoutRes<span class="hljs-built_in"> int </span>layoutResID) &#123;        ViewGroup viewGroup = (ViewGroup) findViewById(android.R.id.content);        viewGroup.removeAllViews();        parentLinearLayout =<span class="hljs-built_in"> new </span>LinearLayout(this);        parentLinearLayout.setOrientation(<span class="hljs-class">LinearLayout.VERTICAL);</span>// <span class="hljs-built_in"> add </span>parentLinearLayout in viewGroup        viewGroup.addView(parent<span class="hljs-class">LinearLayout);</span>        // <span class="hljs-built_in"> add </span>the layout of BaseActivity in parentLinearLayout        LayoutInflater.from(this).inflate(layoutResID, parent<span class="hljs-class">LinearLayout, true);</span>    &#125;   /**     * @param layoutResID  layout id of sub-activity     */    @Override   <span class="hljs-keyword"> public</span> void setContentView(@LayoutRes<span class="hljs-built_in"> int </span>layoutResID) &#123;        //  added the<span class="hljs-built_in"> sub-activity </span>layout id in parentLinearLayout        LayoutInflater.from(this).inflate(layoutResID, parent<span class="hljs-class">LinearLayout, true);</span>    &#125;&#125;</code></pre><p>上述代码通过initContentView()方法将BaseActivity中的布局文件添加到了声明的parentLinearLayout中，通过setContentView()方法将子Activity的布局也添加到了parentLinearLayout中，然后又将parentLinearLayout添加到了viewGroup中实现了Activity与布局文件的关联。至此我们完成了第一步，使子Activity可以显示出BaseActivity中的Toolbar布局。<br>接下来，我们需要在BaseActivity中对Toolbar进行封装，使其能够更加方便的在子Activity中使用。比如添加toolbar回退键的监听，添加是否显示回退键的方法等。完整的BaseActivity如下：</p><pre><code class="hljs reasonml">public abstract <span class="hljs-keyword">class</span> BaseActivity extends AppCompatActivity&#123;    <span class="hljs-comment">//the container of this activity layout and sub-activity layout </span>    <span class="hljs-keyword">private</span> LinearLayout parentLinearLayout;    <span class="hljs-keyword">private</span> TextView mTvTitle;    <span class="hljs-keyword">private</span> TextView mTvRight;    <span class="hljs-keyword">private</span> Toolbar mToolbar;    @Override    public void on<span class="hljs-constructor">Create(Bundle <span class="hljs-params">savedInstanceState</span>)</span> &#123;        super.on<span class="hljs-constructor">Create(<span class="hljs-params">savedInstanceState</span>)</span>;        init<span class="hljs-constructor">ContentView(R.<span class="hljs-params">layout</span>.<span class="hljs-params">activity_base</span>)</span>;              set<span class="hljs-constructor">ContentView(<span class="hljs-params">getLayoutId</span>()</span>);        init<span class="hljs-constructor">ToolBar()</span>;        set<span class="hljs-constructor">BackIcon()</span>;        init<span class="hljs-literal">()</span>;    &#125;<span class="hljs-comment">//  overwrite the function in sub-activity and return the layout id of sub-activity </span> protected abstract <span class="hljs-built_in">int</span> get<span class="hljs-constructor">LayoutId()</span>; <span class="hljs-keyword">private</span> void init<span class="hljs-constructor">ContentView(@LayoutRes <span class="hljs-params">int</span> <span class="hljs-params">layoutResID</span>)</span> &#123;        ViewGroup viewGroup = (ViewGroup) find<span class="hljs-constructor">ViewById(<span class="hljs-params">android</span>.R.<span class="hljs-params">id</span>.<span class="hljs-params">content</span>)</span>;        viewGroup.remove<span class="hljs-constructor">AllViews()</span>;        parentLinearLayout = <span class="hljs-keyword">new</span> <span class="hljs-constructor">LinearLayout(<span class="hljs-params">this</span>)</span>;        parentLinearLayout.set<span class="hljs-constructor">Orientation(LinearLayout.VERTICAL)</span>;        viewGroup.add<span class="hljs-constructor">View(<span class="hljs-params">parentLinearLayout</span>)</span>;        <span class="hljs-comment">//  add the layout of BaseActivity in parentLinearLayout</span>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">LayoutInflater</span>.</span></span>from(this).inflate(layoutResID, parentLinearLayout, <span class="hljs-literal">true</span>);    &#125;   <span class="hljs-comment">/**</span><span class="hljs-comment">     * @param layoutResID  the layout id of sub Activity</span><span class="hljs-comment">     */</span>    @Override    public void set<span class="hljs-constructor">ContentView(@LayoutRes <span class="hljs-params">int</span> <span class="hljs-params">layoutResID</span>)</span> &#123;        <span class="hljs-comment">//  added the sub-activity layout id in parentLinearLayout</span>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">LayoutInflater</span>.</span></span>from(this).inflate(layoutResID, parentLinearLayout, <span class="hljs-literal">true</span>);    &#125;<span class="hljs-keyword">private</span> void set<span class="hljs-constructor">BackIcon()</span>&#123;        <span class="hljs-keyword">if</span> (null != get<span class="hljs-constructor">Toolbar()</span><span class="hljs-operator"> &amp;&amp; </span>is<span class="hljs-constructor">ShowBacking()</span>) &#123;            get<span class="hljs-constructor">Toolbar()</span>.set<span class="hljs-constructor">NavigationIcon(R.<span class="hljs-params">drawable</span>.<span class="hljs-params">icon_back</span>)</span>;            get<span class="hljs-constructor">Toolbar()</span>.set<span class="hljs-constructor">NavigationOnClickListener((<span class="hljs-params">v</span>)</span> -&gt; on<span class="hljs-constructor">BackPressed()</span>);        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * @return TextView in center</span><span class="hljs-comment">     */</span>    public TextView get<span class="hljs-constructor">ToolbarTitle()</span> &#123;        return mTvTitle;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * @return TextView on the right</span><span class="hljs-comment">     */</span>    public TextView get<span class="hljs-constructor">SubTitle()</span> &#123;        return mTvRight;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * set Title</span><span class="hljs-comment">     * @param title</span><span class="hljs-comment">     */</span>    public void set<span class="hljs-constructor">ToolBarTitle(CharSequence <span class="hljs-params">title</span>)</span> &#123;        <span class="hljs-keyword">if</span> (mTvTitle != null) &#123;            mTvTitle.set<span class="hljs-constructor">Text(<span class="hljs-params">title</span>)</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            get<span class="hljs-constructor">Toolbar()</span>.set<span class="hljs-constructor">Title(<span class="hljs-params">title</span>)</span>;            set<span class="hljs-constructor">SupportActionBar(<span class="hljs-params">getToolbar</span>()</span>);        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * the toolbar of this Activity</span><span class="hljs-comment">     * @return support.v7.widget.Toolbar.</span><span class="hljs-comment">     */</span>    public Toolbar get<span class="hljs-constructor">Toolbar()</span> &#123;        return (Toolbar) find<span class="hljs-constructor">ViewById(R.<span class="hljs-params">id</span>.<span class="hljs-params">toolbar</span>)</span>;    &#125;        <span class="hljs-comment">/**</span><span class="hljs-comment">     * is show back icon,default is none。</span><span class="hljs-comment">     * you can override the function in subclass and return to true show the back icon</span><span class="hljs-comment">     * @return</span><span class="hljs-comment">     */</span>    protected boolean is<span class="hljs-constructor">ShowBacking()</span> &#123;        return <span class="hljs-literal">true</span>;    &#125;&#125;</code></pre><p>最后我们可以在子Activity中去使用toolbar了。<br>我们让MainActivity继承BaseActivity,并在布局文件中添加一个button，切布局文件中没有添加标题栏，布局文件的代码就不再贴出了。然后 重写isShowBacing()方法，使其返回false，隐藏MainActivity的回退键。<br>代码如下：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BaseActivity</span> </span>&#123;    <span class="hljs-meta">@BindView(R.id.btn)</span>    Button mBtn1;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getLayoutId</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> R.layout.activity_main;    &#125; <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isShowBacking</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;<span class="hljs-meta">@OnClick(&#123;R.id.btn&#125;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Onclick</span><span class="hljs-params">(View view)</span></span>&#123;        <span class="hljs-keyword">switch</span> (view.getId())&#123;            <span class="hljs-keyword">case</span> R.id.btn:                startActivity(<span class="hljs-keyword">new</span> Intent(<span class="hljs-keyword">this</span>,TestActivity.class));                <span class="hljs-keyword">break</span>;        &#125;    &#125;&#125;</code></pre><p>创建TestActivity并继承BaseActivity，TestActivity的布局文件中不添加任何view。然后在TestActivity中给toolbar设置内容，如下：</p><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BaseActivity</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">protected</span> int getLayoutId() &#123;        <span class="hljs-keyword">return</span> <span class="hljs-type">R</span>.layout.activity_test;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">protected</span> void init() &#123;        getToolbarTitle().setText(<span class="hljs-string">&quot;中间标题&quot;</span>);        getSubTitle().setText(<span class="hljs-string">&quot;右边标题&quot;</span>);        <span class="hljs-type">Toolbar</span> toolbar = getToolbar();        toolbar.setLogo(<span class="hljs-type">R</span>.mipmap.ic_launcher);        toolbar.setNavigationIcon(<span class="hljs-type">R</span>.drawable.back_white);    &#125;&#125;</code></pre><p>效果如下图所示</p><p><img src="https://raw.githubusercontent.com/zhpanvip/Resource/master/image/0701.jfif"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>自定义View之颜色渐变折线图</title>
    <link href="/2017/03/16/%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B9%8B%E9%A2%9C%E8%89%B2%E6%B8%90%E5%8F%98%E6%8A%98%E7%BA%BF%E5%9B%BE/"/>
    <url>/2017/03/16/%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B9%8B%E9%A2%9C%E8%89%B2%E6%B8%90%E5%8F%98%E6%8A%98%E7%BA%BF%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<p>首先看下要实现的效果图。<br><img src="https://raw.githubusercontent.com/zhpanvip/Resource/master/image/0601.gif"></p><p>折线图的绘制主要有一下几个步骤。<br>一、定义LineChartView类并继承View。<br>二、添加自定义属性。以在value目录下创建attrs.xml文件,文件中我们可以定义一些用到的属性，比如折线颜色、字体大小等属性。文件内容如下：</p><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">declare-styleable</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;LineChartView&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">attr</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;axesColor&quot;</span> <span class="hljs-attr">format</span>=<span class="hljs-string">&quot;color&quot;</span>/&gt;</span> <span class="hljs-comment">&lt;!--坐标轴颜色--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">attr</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;axesWidth&quot;</span> <span class="hljs-attr">format</span>=<span class="hljs-string">&quot;dimension&quot;</span>/&gt;</span><span class="hljs-comment">&lt;!--坐标轴宽度--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">attr</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;textColor&quot;</span> <span class="hljs-attr">format</span>=<span class="hljs-string">&quot;color&quot;</span>/&gt;</span> <span class="hljs-comment">&lt;!--字体颜色--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">attr</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;textSize&quot;</span> <span class="hljs-attr">format</span>=<span class="hljs-string">&quot;dimension&quot;</span>/&gt;</span> <span class="hljs-comment">&lt;!--字体大小--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">attr</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;lineColor&quot;</span> <span class="hljs-attr">format</span>=<span class="hljs-string">&quot;color&quot;</span>/&gt;</span> <span class="hljs-comment">&lt;!--折线颜色--&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">declare-styleable</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span></code></pre><p>接下来在LineChartView的构造方法中解析自定义属性的值并做相应的处理。在构造方法里还初始化了渐变颜色、折线数据的List集合以及初始化画笔等操作代码如下：</p><pre><code class="hljs reasonml">public <span class="hljs-constructor">LineChartView(Context <span class="hljs-params">context</span>, AttributeSet <span class="hljs-params">attrs</span>, <span class="hljs-params">int</span> <span class="hljs-params">defStyleAttr</span>)</span> &#123;       super(context, attrs, defStyleAttr);       TypedArray typedArray = context.obtain<span class="hljs-constructor">StyledAttributes(<span class="hljs-params">attrs</span>, R.<span class="hljs-params">styleable</span>.LineChartView)</span>;       mAxesColor = typedArray.get<span class="hljs-constructor">Color(R.<span class="hljs-params">styleable</span>.LineChartView_axesColor, Color.<span class="hljs-params">parseColor</span>(<span class="hljs-string">&quot;#CCCCCC&quot;</span>)</span>);       mAxesWidth = typedArray.get<span class="hljs-constructor">Dimension(R.<span class="hljs-params">styleable</span>.LineChartView_axesWidth, 1)</span>;       mTextColor = typedArray.get<span class="hljs-constructor">Color(R.<span class="hljs-params">styleable</span>.LineChartView_textColor, Color.<span class="hljs-params">parseColor</span>(<span class="hljs-string">&quot;#ABABAB&quot;</span>)</span>);       mTextSize = typedArray.get<span class="hljs-constructor">Dimension(R.<span class="hljs-params">styleable</span>.LineChartView_textSize, 32)</span>;       mLineColor = typedArray.get<span class="hljs-constructor">Color(R.<span class="hljs-params">styleable</span>.LineChartView_lineColor, Color.RED)</span>;       typedArray.recycle<span class="hljs-literal">()</span>;       <span class="hljs-comment">//  初始化渐变色</span>       shadeColors = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span><span class="hljs-literal">[]</span>&#123;               <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Color</span>.</span></span>argb(<span class="hljs-number">100</span>, <span class="hljs-number">255</span>, <span class="hljs-number">86</span>, <span class="hljs-number">86</span>), <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Color</span>.</span></span>argb(<span class="hljs-number">15</span>, <span class="hljs-number">255</span>, <span class="hljs-number">86</span>, <span class="hljs-number">86</span>),               <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Color</span>.</span></span>argb(<span class="hljs-number">0</span>, <span class="hljs-number">255</span>, <span class="hljs-number">86</span>, <span class="hljs-number">86</span>)&#125;;     <span class="hljs-comment">//  初始化折线数据</span>       mValues = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;<span class="hljs-literal">()</span>;       mMargin10 = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">DensityUtils</span>.</span></span>dp2px(context, <span class="hljs-number">10</span>);       init<span class="hljs-literal">()</span>;   &#125;</code></pre><p>三、初始化画笔和路径。代码如下：</p><pre><code class="hljs reasonml"><span class="hljs-keyword">private</span> void init<span class="hljs-literal">()</span> &#123;        <span class="hljs-comment">//  初始化坐标轴画笔</span>        mPaintAxes = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Paint()</span>;        mPaintAxes.set<span class="hljs-constructor">Color(<span class="hljs-params">mAxesColor</span>)</span>;        mPaintAxes.set<span class="hljs-constructor">StrokeWidth(<span class="hljs-params">mAxesWidth</span>)</span>;        <span class="hljs-comment">//  初始化文字画笔</span>        mPaintText = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Paint()</span>;        mPaintText.set<span class="hljs-constructor">Style(Paint.Style.FILL)</span>;        mPaintText.set<span class="hljs-constructor">AntiAlias(<span class="hljs-params">true</span>)</span>; <span class="hljs-comment">//抗锯齿</span>        mPaintText.set<span class="hljs-constructor">TextSize(<span class="hljs-params">mTextSize</span>)</span>;        mPaintText.set<span class="hljs-constructor">Color(<span class="hljs-params">mTextColor</span>)</span>;        mPaintText.set<span class="hljs-constructor">TextAlign(Paint.Align.LEFT)</span>;        <span class="hljs-comment">//  初始化折线画笔</span>        mPaintLine = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Paint()</span>;        mPaintLine.set<span class="hljs-constructor">Style(Paint.Style.STROKE)</span>;        mPaintLine.set<span class="hljs-constructor">AntiAlias(<span class="hljs-params">true</span>)</span>;        mPaintLine.set<span class="hljs-constructor">StrokeWidth(<span class="hljs-params">mAxesWidth</span> <span class="hljs-operator">/</span> 2)</span>;        mPaintLine.set<span class="hljs-constructor">Color(<span class="hljs-params">mLineColor</span>)</span>;        <span class="hljs-comment">//  初始化折线路径</span>        mPath = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Path()</span>;        mPathShader = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Path()</span>;        <span class="hljs-comment">//  阴影画笔</span>        mPaintShader = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Paint()</span>;        mPaintShader.set<span class="hljs-constructor">AntiAlias(<span class="hljs-params">true</span>)</span>;        mPaintShader.set<span class="hljs-constructor">StrokeWidth(2f)</span>;    &#125;</code></pre><p>四、重写onLayout方法。在onLayout方法中获取控件的宽高、初始化原点坐标以及设置控件的背景。代码如下：</p><pre><code class="hljs reasonml">@Override   protected void on<span class="hljs-constructor">Layout(<span class="hljs-params">boolean</span> <span class="hljs-params">changed</span>, <span class="hljs-params">int</span> <span class="hljs-params">left</span>, <span class="hljs-params">int</span> <span class="hljs-params">top</span>, <span class="hljs-params">int</span> <span class="hljs-params">right</span>, <span class="hljs-params">int</span> <span class="hljs-params">bottom</span>)</span> &#123;       super.on<span class="hljs-constructor">Layout(<span class="hljs-params">changed</span>, <span class="hljs-params">left</span>, <span class="hljs-params">top</span>, <span class="hljs-params">right</span>, <span class="hljs-params">bottom</span>)</span>;       <span class="hljs-keyword">if</span> (changed) &#123;           mWidth = get<span class="hljs-constructor">Width()</span>;           mHeight = get<span class="hljs-constructor">Height()</span>;           timeWidth = (<span class="hljs-built_in">int</span>) mPaintText.measure<span class="hljs-constructor">Text(<span class="hljs-params">startTime</span>)</span>;           <span class="hljs-comment">//  初始化原点坐标</span>           xOrigin = <span class="hljs-number">0</span> + mMargin10;           yOrigin = (mHeight - mTextSize - mMargin10);        &#125;   &#125;</code></pre><p>五、重写onDraw方法。在onDraw方法中完成折线图的绘制。代码如下：</p><pre><code class="hljs reasonml">@Override   protected void on<span class="hljs-constructor">Draw(Canvas <span class="hljs-params">canvas</span>)</span> &#123;       super.on<span class="hljs-constructor">Draw(<span class="hljs-params">canvas</span>)</span>;       <span class="hljs-comment">//  Y轴坐标间距</span>       yInterval = (max - min)<span class="hljs-operator"> / </span>(yOrigin - mMargin10);<span class="hljs-comment">//  X轴坐标间距</span>       xInterval = (mWidth - xOrigin)<span class="hljs-operator"> / </span>(mItems.size<span class="hljs-literal">()</span> - <span class="hljs-number">1</span>);       <span class="hljs-comment">//  画坐标轴</span>       draw<span class="hljs-constructor">Axes(<span class="hljs-params">canvas</span>)</span>;       <span class="hljs-comment">//  画文字</span>       draw<span class="hljs-constructor">Text(<span class="hljs-params">canvas</span>)</span>;       <span class="hljs-comment">//  画折线</span>       draw<span class="hljs-constructor">Line(<span class="hljs-params">canvas</span>)</span>;<span class="hljs-comment">//  绘制路径</span>       draw<span class="hljs-constructor">Path(<span class="hljs-params">canvas</span>)</span>;   &#125;</code></pre><p>折线图的绘制可以分三部分：1.绘制坐标轴。2.绘制View上的文字。3.绘制折线。</p><p>1.坐标轴绘制的是第一象限，即左下角的点为原点。绘制坐标轴代码如下：</p><pre><code class="hljs reasonml"><span class="hljs-comment">//  画坐标轴</span>    <span class="hljs-keyword">private</span> void draw<span class="hljs-constructor">Axes(Canvas <span class="hljs-params">canvas</span>)</span> &#123;        <span class="hljs-comment">//  绘制X轴</span>        canvas.draw<span class="hljs-constructor">Line(<span class="hljs-params">xOrigin</span>, <span class="hljs-params">yOrigin</span>, <span class="hljs-params">mWidth</span> - <span class="hljs-params">mMargin10</span>, <span class="hljs-params">yOrigin</span>, <span class="hljs-params">mPaintAxes</span>)</span>;        <span class="hljs-comment">//  绘制X中轴线</span>        canvas.draw<span class="hljs-constructor">Line(<span class="hljs-params">xOrigin</span>, <span class="hljs-params">yOrigin</span> <span class="hljs-operator">/</span> 2, <span class="hljs-params">mWidth</span> - <span class="hljs-params">mMargin10</span>, <span class="hljs-params">yOrigin</span> <span class="hljs-operator">/</span> 2, <span class="hljs-params">mPaintAxes</span>)</span>;        <span class="hljs-comment">//  绘制X上边线</span>        canvas.draw<span class="hljs-constructor">Line(<span class="hljs-params">xOrigin</span>, <span class="hljs-params">mMargin10</span>, <span class="hljs-params">mWidth</span> - <span class="hljs-params">mMargin10</span>, <span class="hljs-params">mMargin10</span>, <span class="hljs-params">mPaintAxes</span>)</span>;        <span class="hljs-comment">//  绘制画Y轴</span>        canvas.draw<span class="hljs-constructor">Line(<span class="hljs-params">xOrigin</span>, <span class="hljs-params">yOrigin</span>, <span class="hljs-params">xOrigin</span>, <span class="hljs-params">mMargin10</span>, <span class="hljs-params">mPaintAxes</span>)</span>;        <span class="hljs-comment">//  绘制Y右边线</span>        canvas.draw<span class="hljs-constructor">Line(<span class="hljs-params">mWidth</span> - <span class="hljs-params">mMargin10</span>, <span class="hljs-params">mMargin10</span>, <span class="hljs-params">mWidth</span> - <span class="hljs-params">mMargin10</span>, <span class="hljs-params">yOrigin</span>, <span class="hljs-params">mPaintAxes</span>)</span>;    &#125;</code></pre><p>2.绘制文字，代码如下：</p><pre><code class="hljs reasonml"><span class="hljs-keyword">private</span> void draw<span class="hljs-constructor">Text(Canvas <span class="hljs-params">canvas</span>)</span> &#123;        <span class="hljs-comment">//  绘制最大值</span>        canvas.draw<span class="hljs-constructor">Text(String.<span class="hljs-params">format</span>(<span class="hljs-string">&quot;%.2f&quot;</span>, <span class="hljs-params">max</span> <span class="hljs-operator">*</span> 100 <span class="hljs-operator">/</span> 100.0)</span> + <span class="hljs-string">&quot;%&quot;</span>, xOrigin + <span class="hljs-number">6</span>, <span class="hljs-number">2</span><span class="hljs-operator"> * </span>mMargin10, mPaintText);        <span class="hljs-comment">//  绘制最小值</span>        canvas.draw<span class="hljs-constructor">Text(String.<span class="hljs-params">format</span>(<span class="hljs-string">&quot;%.2f&quot;</span>, <span class="hljs-params">min</span> <span class="hljs-operator">*</span> 100 <span class="hljs-operator">/</span> 100.0)</span> + <span class="hljs-string">&quot;%&quot;</span>, xOrigin + <span class="hljs-number">6</span>, yOrigin - <span class="hljs-number">6</span>, mPaintText);        <span class="hljs-comment">//  绘制中间值</span>        canvas.draw<span class="hljs-constructor">Text((String.<span class="hljs-params">format</span>(<span class="hljs-string">&quot;%.2f&quot;</span>, (<span class="hljs-params">min</span> + <span class="hljs-params">max</span>)</span><span class="hljs-operator"> * </span><span class="hljs-number">100</span><span class="hljs-operator"> / </span><span class="hljs-number">200.0</span>) + <span class="hljs-string">&quot;%&quot;</span>), xOrigin + <span class="hljs-number">6</span>, (yOrigin + mMargin10)<span class="hljs-operator"> / </span><span class="hljs-number">2</span>, mPaintText);        <span class="hljs-comment">//  绘制开始日期</span>        canvas.draw<span class="hljs-constructor">Text(<span class="hljs-params">startTime</span>, <span class="hljs-params">xOrigin</span>, <span class="hljs-params">mHeight</span> - <span class="hljs-params">mMargin10</span>, <span class="hljs-params">mPaintText</span>)</span>;        <span class="hljs-comment">//  绘制结束日期</span>        canvas.draw<span class="hljs-constructor">Text(<span class="hljs-params">endTime</span>, <span class="hljs-params">mWidth</span> - <span class="hljs-params">timeWidth</span> - <span class="hljs-params">mMargin10</span>, <span class="hljs-params">mHeight</span> - <span class="hljs-params">mMargin10</span>, <span class="hljs-params">mPaintText</span>)</span>;    &#125;</code></pre><p>3.绘制折线及渐变填充</p><pre><code class="hljs reasonml"><span class="hljs-keyword">private</span> void draw<span class="hljs-constructor">Line(Canvas <span class="hljs-params">canvas</span>)</span> &#123;        <span class="hljs-comment">//  画坐标点</span>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; mValues.size<span class="hljs-literal">()</span>; i++) &#123;            <span class="hljs-built_in">float</span> x = i<span class="hljs-operator"> * </span>xInterval + xOrigin + mAxesWidth;            <span class="hljs-keyword">if</span> (i<span class="hljs-operator"> == </span><span class="hljs-number">0</span>) &#123;                mPathShader.move<span class="hljs-constructor">To(<span class="hljs-params">x</span>, <span class="hljs-params">yOrigin</span> - (<span class="hljs-params">mValues</span>.<span class="hljs-params">get</span>(<span class="hljs-params">i</span>)</span> - min)<span class="hljs-operator"> / </span>yInterval);                mPath.move<span class="hljs-constructor">To(<span class="hljs-params">x</span>, <span class="hljs-params">yOrigin</span> - (<span class="hljs-params">mValues</span>.<span class="hljs-params">get</span>(<span class="hljs-params">i</span>)</span> - min)<span class="hljs-operator"> / </span>yInterval);            &#125; <span class="hljs-keyword">else</span> &#123;                mPath.line<span class="hljs-constructor">To(<span class="hljs-params">x</span> - <span class="hljs-params">mMargin10</span> - <span class="hljs-params">mAxesWidth</span>, <span class="hljs-params">yOrigin</span> - (<span class="hljs-params">mValues</span>.<span class="hljs-params">get</span>(<span class="hljs-params">i</span>)</span> - min)<span class="hljs-operator"> / </span>yInterval);                mPathShader.line<span class="hljs-constructor">To(<span class="hljs-params">x</span> - <span class="hljs-params">mMargin10</span> - <span class="hljs-params">mAxesWidth</span>, <span class="hljs-params">yOrigin</span> - (<span class="hljs-params">mValues</span>.<span class="hljs-params">get</span>(<span class="hljs-params">i</span>)</span> - min)<span class="hljs-operator"> / </span>yInterval);                <span class="hljs-keyword">if</span> (i<span class="hljs-operator"> == </span>mValues.size<span class="hljs-literal">()</span> - <span class="hljs-number">1</span>) &#123;                    mPathShader.line<span class="hljs-constructor">To(<span class="hljs-params">x</span> - <span class="hljs-params">mMargin10</span> - <span class="hljs-params">mAxesWidth</span>, <span class="hljs-params">yOrigin</span>)</span>;                    mPathShader.line<span class="hljs-constructor">To(<span class="hljs-params">xOrigin</span>, <span class="hljs-params">yOrigin</span>)</span>;                    mPathShader.close<span class="hljs-literal">()</span>;                &#125;            &#125;        &#125;        <span class="hljs-keyword">if</span> (null<span class="hljs-operator"> == </span>mShadeColors) &#123;            mPaintShader.set<span class="hljs-constructor">Color(Color.<span class="hljs-params">argb</span>(0, 0, 0, 0)</span>);        &#125; <span class="hljs-keyword">else</span> &#123;            Shader mShader = <span class="hljs-keyword">new</span> <span class="hljs-constructor">LinearGradient(0, 0, 0, <span class="hljs-params">getHeight</span>()</span>, mShadeColors, null, Shader.TileMode.CLAMP);            mPaintShader.set<span class="hljs-constructor">Shader(<span class="hljs-params">mShader</span>)</span>;        &#125;        canvas.draw<span class="hljs-constructor">Path(<span class="hljs-params">mPathShader</span>, <span class="hljs-params">mPaintShader</span>)</span>;    &#125;</code></pre><p>六、折线图添加动画。</p><p>1.折线图的动画使用属性动画，首先需要计算动画的进度，因此需要先添加setPercentage方法，当动画开始时，我们可以在该方法中拿到percentage的值</p><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Animate this property. It is the percentage of the path that is drawn.</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * @param percentage float the percentage of the path.</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setPercentage</span><span class="hljs-params">(<span class="hljs-keyword">float</span> percentage)</span> </span>&#123;    <span class="hljs-keyword">if</span> (percentage &lt; <span class="hljs-number">0.0f</span> || percentage &gt; <span class="hljs-number">1.0f</span>) &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(                <span class="hljs-string">&quot;setPercentage not between 0.0f and 1.0f&quot;</span>);    &#125;    mProgress = percentage;    invalidate();&#125;</code></pre><p>2.通过Path来绘制折线路径，代码如下：</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">drawPath</span><span class="hljs-params">(Canvas canvas)</span> </span>&#123;       PathMeasure measure = <span class="hljs-keyword">new</span> PathMeasure(mPath, <span class="hljs-literal">false</span>);       <span class="hljs-keyword">float</span> pathLength = measure.getLength();       PathEffect effect = <span class="hljs-keyword">new</span> DashPathEffect(<span class="hljs-keyword">new</span> <span class="hljs-keyword">float</span>[]&#123;pathLength,               pathLength&#125;, pathLength - pathLength * mProgress);       mPaintLine.setPathEffect(effect);       canvas.drawPath(mPath, mPaintLine);   &#125;</code></pre><p>3.通过ObjectAnimator 开启动画，注意ObjectAnimator.ofFloat(lineChartView, “percentage”, 0.0f, 1.0f)中第二个参数必须为“percentage”，对应前那边的setPercentage方法，属性动画会根据“percentage”参数通过反射调用setPercentage：</p><pre><code class="hljs reasonml"><span class="hljs-comment">/**</span><span class="hljs-comment">   * @param lineChartView</span><span class="hljs-comment">   * @param duration      动画持续时间</span><span class="hljs-comment">   */</span>  public void start<span class="hljs-constructor">Anim(LineChartView <span class="hljs-params">lineChartView</span>, <span class="hljs-params">long</span> <span class="hljs-params">duration</span>)</span> &#123;      ObjectAnimator anim = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ObjectAnimator</span>.</span></span><span class="hljs-keyword">of</span><span class="hljs-constructor">Float(<span class="hljs-params">lineChartView</span>, <span class="hljs-string">&quot;percentage&quot;</span>, 0.0f, 1.0f)</span>;      anim.set<span class="hljs-constructor">Duration(<span class="hljs-params">duration</span>)</span>;      anim.set<span class="hljs-constructor">Interpolator(<span class="hljs-params">new</span> LinearInterpolator()</span>);      anim.start<span class="hljs-literal">()</span>;  &#125;</code></pre><p>至此，折线图的绘制已经全部完成。最后还可以添加get() set()方法，暴露出属性接口，以供外部调用。代码就不再贴出来了。</p><p>七、使用LineChartView<br>1.在布局文件中添加LineChartView,可设置折线颜色、字体颜色、等属性，如下：</p><pre><code class="hljs routeros">&lt;com.example.zhpan.linechartview.LineChartView        android:<span class="hljs-attribute">id</span>=<span class="hljs-string">&quot;@+id/lcv&quot;</span>        android:<span class="hljs-attribute">layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span>        android:<span class="hljs-attribute">layout_height</span>=<span class="hljs-string">&quot;200dp&quot;</span>        android:<span class="hljs-attribute">layout_marginBottom</span>=<span class="hljs-string">&quot;20dp&quot;</span>        android:<span class="hljs-attribute">layout_marginLeft</span>=<span class="hljs-string">&quot;15dp&quot;</span>        android:<span class="hljs-attribute">layout_marginRight</span>=<span class="hljs-string">&quot;15dp&quot;</span>        android:<span class="hljs-attribute">layout_marginTop</span>=<span class="hljs-string">&quot;15dp&quot;</span>        app:<span class="hljs-attribute">lineColor</span>=<span class="hljs-string">&quot;#FF0000&quot;</span>        app:<span class="hljs-attribute">textColor</span>=<span class="hljs-string">&quot;#ABABAB&quot;</span>        app:<span class="hljs-attribute">textSize</span>=<span class="hljs-string">&quot;12dp&quot;</span>/&gt;</code></pre><p>2.在Activity中为LineChartView设置数据，也可以通过代码为其设置属性。</p><pre><code class="hljs angelscript"><span class="hljs-keyword">private</span> <span class="hljs-built_in">void</span> initData() &#123;        <span class="hljs-comment">//  初始化折线数据</span>        List&lt;Float&gt; listValues = new ArrayList&lt;&gt;();        Random random = new Random();        <span class="hljs-built_in">float</span> startValue = random.nextFloat() * <span class="hljs-number">10</span>;        listValues.add(startValue);        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">30</span>; i++) &#123;            startValue += random.nextFloat() * <span class="hljs-number">10</span> - <span class="hljs-number">5</span>;            listValues.add(startValue);        &#125;        List&lt;Integer&gt; listShadeColors = new ArrayList&lt;&gt;();        listShadeColors.add(Color.argb(<span class="hljs-number">100</span>, <span class="hljs-number">255</span>, <span class="hljs-number">86</span>, <span class="hljs-number">86</span>));        listShadeColors.add(Color.argb(<span class="hljs-number">15</span>, <span class="hljs-number">255</span>, <span class="hljs-number">86</span>, <span class="hljs-number">86</span>));        listShadeColors.add(Color.argb(<span class="hljs-number">0</span>, <span class="hljs-number">255</span>, <span class="hljs-number">86</span>, <span class="hljs-number">86</span>));        <span class="hljs-comment">//  设置折线数据</span>        mLineChartView.setValues(listValues);        <span class="hljs-comment">//  设置渐变颜色</span>        mLineChartView.setShadeColors(listShadeColors);        <span class="hljs-comment">//  设置动画插值器</span>        mLineChartView.setInterpolator(new DecelerateInterpolator());        mLineChartView.setAxisMinValue(<span class="hljs-number">-30</span>);        mLineChartView.setAxisMaxValue(<span class="hljs-number">30</span>);        mLineChartView.setStartTime(<span class="hljs-string">&quot;2017-03-15&quot;</span>);        mLineChartView.setEndTime(<span class="hljs-string">&quot;2017-04-14&quot;</span>);        <span class="hljs-comment">//  开启动画</span>        mLineChartView.startAnim(<span class="hljs-number">2500</span>);    &#125;</code></pre><p><a href="https://github.com/zhpanvip/CustomView">源码下载</a></p><h3 id="好库推荐"><a href="#好库推荐" class="headerlink" title="好库推荐"></a>好库推荐</h3><p>给大家推荐一下<a href="https://github.com/zhpanvip/BannerViewPager">BannerViewPager</a>。这是一个基于ViewPager实现的具有强大功能的无限轮播库。通过<a href="https://github.com/zhpanvip/BannerViewPager">BannerViewPager</a>可以实现腾讯视频、QQ音乐、酷狗音乐、支付宝、天猫、淘宝、优酷视频、喜马拉雅、网易云音乐、哔哩哔哩等APP的Banner样式以及指示器样式。</p><p>欢迎大家到github关注<a href="https://github.com/zhpanvip/BannerViewPager">BannerViewPager</a>！</p>]]></content>
    
    
    
    <tags>
      
      <tag>自定义View</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android搜索关键字高亮显示及开发中遇到的坑</title>
    <link href="/2016/12/15/Android%E6%90%9C%E7%B4%A2%E5%85%B3%E9%94%AE%E5%AD%97%E9%AB%98%E4%BA%AE%E6%98%BE%E7%A4%BA%E5%8F%8A%E5%BC%80%E5%8F%91%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/"/>
    <url>/2016/12/15/Android%E6%90%9C%E7%B4%A2%E5%85%B3%E9%94%AE%E5%AD%97%E9%AB%98%E4%BA%AE%E6%98%BE%E7%A4%BA%E5%8F%8A%E5%BC%80%E5%8F%91%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/</url>
    
    <content type="html"><![CDATA[<p>公司项目中有一个搜索功能，需求是要把搜索关键字高亮显示出来。本来觉得是一个很简单的问题，开发过程也比较顺利。但在测试阶段还是出了些Bug。而且有些问题还挺莫名其妙！<br>最初的想法，定义一个工具类，然后封装一个处理高亮的方法，需要高亮显示的直接调用这个工具类就行了。工具类封装了一个matcherSearchContent()的静态方法，然后用SpannableStringBuilder去处理关键字高亮显示，处理完成后方法返回处理好的SpannableStringBuilder。然后就可以直接给TextView去set处理好的SpannableStringBuilder。具体代码如下：</p><pre><code class="hljs">public class TextHighLight &#123;    public static SpannableStringBuilder matcherSearchContent(String text,String[] keyword)&#123;        SpannableStringBuilder spannable=new SpannableStringBuilder(text);        CharacterStyle span=null;        for(int i=0;i&lt;keyword.length;i++)&#123;            Pattern pattern=Pattern.compile(keyword[i]);            Matcher matcher=pattern.matcher(text);            while(m.find())&#123;                span=new ForegroundColorSpan(Color.parseColor(&quot;#ff5656&quot;));                            spannable.setSpan(span,m.start(),matcher.end(), Spannable.SPAN_MARK_MARK);            &#125;        &#125;        return spannable;    &#125;&#125;</code></pre><p>但是后来需求说字母是要忽略大小写的。这个该怎么实现啊，用逻辑实现还是很麻烦的。还好，可以用到正则表达式来完成加上一行代码 “(?i)” + keyword[i] 就可以了。修改后代码如下：</p><pre><code class="hljs reasonml">public <span class="hljs-keyword">class</span> TextHighLight &#123;    public static SpannableStringBuilder matcher<span class="hljs-constructor">SearchContent(String <span class="hljs-params">text</span>,String[] <span class="hljs-params">keyword</span>)</span>&#123;        SpannableStringBuilder spannable=<span class="hljs-keyword">new</span> <span class="hljs-constructor">SpannableStringBuilder(<span class="hljs-params">text</span>)</span>;        CharacterStyle span=null;        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;keyword.length;i++)&#123;            wordReg = <span class="hljs-string">&quot;(?i)&quot;</span> + keyword<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>;   <span class="hljs-comment">//忽略字母大小写</span>            Pattern pattern = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Pattern</span>.</span></span>compile(wordReg);            Matcher matcher=pattern.matcher(text);            <span class="hljs-keyword">while</span>(m.find<span class="hljs-literal">()</span>)&#123;                span=<span class="hljs-keyword">new</span> <span class="hljs-constructor">ForegroundColorSpan(Color.<span class="hljs-params">parseColor</span>(<span class="hljs-string">&quot;#ff5656&quot;</span>)</span>);                spannable.set<span class="hljs-constructor">Span(<span class="hljs-params">span</span>,<span class="hljs-params">m</span>.<span class="hljs-params">start</span>()</span>,matcher.<span class="hljs-keyword">end</span><span class="hljs-literal">()</span>, Spannable.SPAN_MARK_MARK);            &#125;        &#125;        return spannable;    &#125;&#125;</code></pre><p>嗯 这个解决的比较轻松。接下来测试阶段出现的问题。当输入特殊字符比如“*”时，程序出现异常闪退。调试发现原因是因为“*”号导致。在正则表达式中“*”是通配符，因此在匹配正则表达式时出现了异常。。解决办法也比较简单吗，就是判读如果包含“<em>”号的话就加上一个“&quot;转义一下就行了嘛！于是就有了下面的代码（因为测试的时候只有搜索“\</em>“、”(“、”)”时出现闪退，因此只对这三个字符作了处理）</p><pre><code class="hljs reasonml">public <span class="hljs-keyword">class</span> TextHighLight &#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     *   关键字高亮显示</span><span class="hljs-comment">     *   </span><span class="hljs-comment">     *   @param text 文字</span><span class="hljs-comment">     *      </span><span class="hljs-comment">     *   @param keyword1 文字中的关键字数组</span><span class="hljs-comment">     *              </span><span class="hljs-comment">     *   @return</span><span class="hljs-comment">     *  </span><span class="hljs-comment">     */</span>    public static SpannableStringBuilder matcher<span class="hljs-constructor">SearchContent(String <span class="hljs-params">text</span>, String[] <span class="hljs-params">keyword</span>)</span> &#123;        SpannableStringBuilder spannable = <span class="hljs-keyword">new</span> <span class="hljs-constructor">SpannableStringBuilder(<span class="hljs-params">text</span>)</span>;        CharacterStyle span;        String wordReg;        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; keyword.length; i++) &#123;            String key = <span class="hljs-string">&quot;&quot;</span>;            <span class="hljs-comment">//  处理通配符问题</span>            <span class="hljs-keyword">if</span> (keyword<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>.contains(<span class="hljs-string">&quot;*&quot;</span>)<span class="hljs-operator"> || </span>keyword<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>.contains(<span class="hljs-string">&quot;(&quot;</span>)<span class="hljs-operator"> || </span>keyword<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>.contains(<span class="hljs-string">&quot;)&quot;</span>)) &#123;                <span class="hljs-built_in">char</span><span class="hljs-literal">[]</span> chars = keyword<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>.<span class="hljs-keyword">to</span><span class="hljs-constructor">CharArray()</span>;                <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> k = <span class="hljs-number">0</span>; k &lt; chars.length; k++) &#123;                    <span class="hljs-keyword">if</span> (chars<span class="hljs-literal">[<span class="hljs-identifier">k</span>]</span><span class="hljs-operator"> == </span><span class="hljs-character">&#x27;*&#x27;</span><span class="hljs-operator"> || </span>chars<span class="hljs-literal">[<span class="hljs-identifier">k</span>]</span><span class="hljs-operator"> == </span><span class="hljs-character">&#x27;(&#x27;</span><span class="hljs-operator"> || </span>chars<span class="hljs-literal">[<span class="hljs-identifier">k</span>]</span><span class="hljs-operator"> == </span><span class="hljs-character">&#x27;)&#x27;</span>) &#123;                        key = key + <span class="hljs-string">&quot;\\&quot;</span> + <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">String</span>.</span></span>value<span class="hljs-constructor">Of(<span class="hljs-params">chars</span>[<span class="hljs-params">k</span>])</span>;                    &#125; <span class="hljs-keyword">else</span> &#123;                        key = key + <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">String</span>.</span></span>value<span class="hljs-constructor">Of(<span class="hljs-params">chars</span>[<span class="hljs-params">k</span>])</span>;                    &#125;                &#125;                keyword<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span> = key;            &#125;            wordReg = <span class="hljs-string">&quot;(?i)&quot;</span> + keyword<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>;   <span class="hljs-comment">//忽略字母大小写</span>            Pattern pattern = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Pattern</span>.</span></span>compile(wordReg);            Matcher matcher = pattern.matcher(text);            <span class="hljs-keyword">while</span> (matcher.find<span class="hljs-literal">()</span>) &#123;                span = <span class="hljs-keyword">new</span> <span class="hljs-constructor">ForegroundColorSpan(Color.<span class="hljs-params">parseColor</span>(<span class="hljs-string">&quot;#ff5656&quot;</span>)</span>);                spannable.set<span class="hljs-constructor">Span(<span class="hljs-params">span</span>, <span class="hljs-params">matcher</span>.<span class="hljs-params">start</span>()</span>, matcher.<span class="hljs-keyword">end</span><span class="hljs-literal">()</span>, Spannable.SPAN_MARK_MARK);            &#125;        &#125;        return spannable;    &#125;&#125;</code></pre><p>上边代码先判断了字符串中是否包含“*”、”（”、”)”号，如果包含的话就遍历字符串然后在“*、”（”、”)”号前边加上“&quot;转义。嗯 这次一定没问题了。然后运行测试，跑起来看效果。嗯，果真正常了！以为这样就完了那就太天真了。当在一级搜索页面测试的时候一个很奇怪的问题出现了！！输入“*”搜索时发现“*”竟然没有高亮显示！效果图如下：</p><table><thead><tr><th>一级搜索页面</th><th>二级搜索页面</th></tr></thead><tbody><tr><td><img src="https://raw.githubusercontent.com/zhpanvip/Resource/master/image/0501.jfif"></td><td><img src="https://raw.githubusercontent.com/zhpanvip/Resource/master/image/0502.jfif"></td></tr></tbody></table><p>很诡异，有木有！两个页面调用的同一个Adapter，调用的同一个处理高亮的方法，为什么一个显示了高亮效果而一个却不正常显示呢！接下来经过漫长的调试、打log、对比两个页面。看下面的log日志信息：</p><p><img src="https://raw.githubusercontent.com/zhpanvip/Resource/master/image/0503.jfif"></p><p>嗯？要匹配的字符串怎么变成了“\ \ *”了？正常来说应该匹配“\<em>“ 的这样在正则表达式中”\</em>“正好被转义成“<em>”的，难怪出现没有匹配高亮显示，问题就出在了上边的for循环添加”&quot;那段代码。看上边代码发现经过处理转义字符后将keyword[i]进行了一次重新赋值，而调用处理高亮的方法时传过来的参数关键字数组仅仅是一个引用，而实际的数组是在堆内存中存储的，因此重新赋值致使堆内存数据发生了改变！<br>既然找到了问题所在就应该分析引起问题的原因，为什么转义字符会被添加了两次？<br>调试的时候发现getView()方法确实是被重复执行了多次。这个原因就很奇怪了，按理说getView()方法的调用应该是跟ListView条目对应的。即有多少条数据，getView()就会被调用多少次。但是为什么在这个页面getView()会被重复执行，而在另一个页面getView()却只调用了一次？后来通过查阅资料发现是由于ListView的布局原因引起的。**</em>当ListView的layout_height属性设置为wrap_content的时候，getView()就会出现被重复调用的问题！，而layout_height设置位match_parent的时候getView()的调用则是正常的***，现在再会过头来看两个页面的布局，上边第一张图片是出现问题的布局，因为该页面有多个ListView，因此单个ListView的layout_height都被定义成了wrap_content从而出现了上述getView()被重复调用问题。而第二张图片中只有一个ListView,layout_height属性设置的是match_parent,因此这个页面getView()只被调用了一次，所以高亮显示也就正常了！</p><p>问题原因找到了，也就好解决了。解决的方案有两个，第一就是更改ListView()的layout_height属性，给其设置为定值。第二就是在matcherSearchContent（）的方法里复制出来关键字的数组，然后再去匹配。这里采用的是第二种方案。修改后代码如下：</p><pre><code class="hljs reasonml">public <span class="hljs-keyword">class</span> TextHighLight &#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     *   关键字高亮显示</span><span class="hljs-comment">     *   </span><span class="hljs-comment">     *   @param text 文字</span><span class="hljs-comment">     *      </span><span class="hljs-comment">     *   @param keyword1 文字中的关键字数组</span><span class="hljs-comment">     *              </span><span class="hljs-comment">     *   @return</span><span class="hljs-comment">     *  </span><span class="hljs-comment">     */</span>    public static SpannableStringBuilder matcher<span class="hljs-constructor">SearchContent(String <span class="hljs-params">text</span>, String[] <span class="hljs-params">keyword1</span>)</span> &#123;        String<span class="hljs-literal">[]</span> keyword = <span class="hljs-keyword">new</span> String<span class="hljs-literal">[<span class="hljs-identifier">keyword1</span>.<span class="hljs-identifier">length</span>]</span>;        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>arraycopy(keyword1, <span class="hljs-number">0</span>, keyword, <span class="hljs-number">0</span>, keyword1.length);        SpannableStringBuilder spannable = <span class="hljs-keyword">new</span> <span class="hljs-constructor">SpannableStringBuilder(<span class="hljs-params">text</span>)</span>;        CharacterStyle span;        String wordReg;        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; keyword.length; i++) &#123;            String key = <span class="hljs-string">&quot;&quot;</span>;            <span class="hljs-comment">//  处理通配符问题</span>            <span class="hljs-keyword">if</span> (keyword<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>.contains(<span class="hljs-string">&quot;*&quot;</span>)<span class="hljs-operator"> || </span>keyword<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>.contains(<span class="hljs-string">&quot;(&quot;</span>)<span class="hljs-operator"> || </span>keyword<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>.contains(<span class="hljs-string">&quot;)&quot;</span>)) &#123;                <span class="hljs-built_in">char</span><span class="hljs-literal">[]</span> chars = keyword<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>.<span class="hljs-keyword">to</span><span class="hljs-constructor">CharArray()</span>;                <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> k = <span class="hljs-number">0</span>; k &lt; chars.length; k++) &#123;                    <span class="hljs-keyword">if</span> (chars<span class="hljs-literal">[<span class="hljs-identifier">k</span>]</span><span class="hljs-operator"> == </span><span class="hljs-character">&#x27;*&#x27;</span><span class="hljs-operator"> || </span>chars<span class="hljs-literal">[<span class="hljs-identifier">k</span>]</span><span class="hljs-operator"> == </span><span class="hljs-character">&#x27;(&#x27;</span><span class="hljs-operator"> || </span>chars<span class="hljs-literal">[<span class="hljs-identifier">k</span>]</span><span class="hljs-operator"> == </span><span class="hljs-character">&#x27;)&#x27;</span>) &#123;                        key = key + <span class="hljs-string">&quot;\\&quot;</span> + <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">String</span>.</span></span>value<span class="hljs-constructor">Of(<span class="hljs-params">chars</span>[<span class="hljs-params">k</span>])</span>;                    &#125; <span class="hljs-keyword">else</span> &#123;                        key = key + <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">String</span>.</span></span>value<span class="hljs-constructor">Of(<span class="hljs-params">chars</span>[<span class="hljs-params">k</span>])</span>;                    &#125;                &#125;                keyword<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span> = key;            &#125;            wordReg = <span class="hljs-string">&quot;(?i)&quot;</span> + keyword<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>;   <span class="hljs-comment">//忽略字母大小写</span>            Pattern pattern = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Pattern</span>.</span></span>compile(wordReg);            Matcher matcher = pattern.matcher(text);            <span class="hljs-keyword">while</span> (matcher.find<span class="hljs-literal">()</span>) &#123;                span = <span class="hljs-keyword">new</span> <span class="hljs-constructor">ForegroundColorSpan(Color.<span class="hljs-params">parseColor</span>(<span class="hljs-string">&quot;#ff5656&quot;</span>)</span>);                spannable.set<span class="hljs-constructor">Span(<span class="hljs-params">span</span>, <span class="hljs-params">matcher</span>.<span class="hljs-params">start</span>()</span>, matcher.<span class="hljs-keyword">end</span><span class="hljs-literal">()</span>, Spannable.SPAN_MARK_MARK);            &#125;        &#125;        return spannable;    &#125;&#125;</code></pre><p>到这里关于关键字高亮的所有问题总算是解决了。</p><h3 id="好库推荐"><a href="#好库推荐" class="headerlink" title="好库推荐"></a>好库推荐</h3><p>给大家推荐一下<a href="https://github.com/zhpanvip/BannerViewPager">BannerViewPager</a>。这是一个基于ViewPager实现的具有强大功能的无限轮播库。通过<a href="https://github.com/zhpanvip/BannerViewPager">BannerViewPager</a>可以实现腾讯视频、QQ音乐、酷狗音乐、支付宝、天猫、淘宝、优酷视频、喜马拉雅、网易云音乐、哔哩哔哩等APP的Banner样式以及指示器样式。</p><p>欢迎大家到github关注<a href="https://github.com/zhpanvip/BannerViewPager">BannerViewPager</a>！</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>RecyclerView/ListView嵌套CheckBox选中状态错乱解决方案</title>
    <link href="/2016/09/25/RecyclerView-ListView%E5%B5%8C%E5%A5%97CheckBox%E9%80%89%E4%B8%AD%E7%8A%B6%E6%80%81%E9%94%99%E4%B9%B1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <url>/2016/09/25/RecyclerView-ListView%E5%B5%8C%E5%A5%97CheckBox%E9%80%89%E4%B8%AD%E7%8A%B6%E6%80%81%E9%94%99%E4%B9%B1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<p>在讨论这个问题之前应该先了解ListView的复用机制<br>ListView复用的原理：ListView中的每一个Item显示都需要Adapter调用一次getView的方法，这个方法会传入一个convertView的参数，返回的View就是这个Item显示的View。如果当Item的数量足够大，再为每一个Item都创建一个View对象，必将占用很多内存，创建View对象（mInflater.inflate(R.layout.lv_item, null);从xml中生成View，这是属于IO操作）也是耗时操作，所以必将影响性能。<br>Android提供了一个叫做Recycler(反复循环器)的构件，就是当ListView的Item从上方滚出屏幕视角之外，对应Item的View会被缓存到Recycler中，相应的会从下方生成一个Item，而此时调用的getView中的convertView参数就是滚出屏幕的Item的View，所以说如果能重用这个convertView，就会大大改善性能。<br>如果一个屏幕最多显示7个Item，当Item1滑出屏幕，此时Item1 的View被添加进Recycler中，相应的在下部要产生一个Item8，这时调用getView方法，convertView参数就是Item1 的View。 其原理图如下：<br><img src="https://raw.githubusercontent.com/zhpanvip/Resource/master/image/0401.jfif"></p><p>ListView的复用虽然大大提升了性能，但是却也带来很多问题。比如在加载图片时，由于下边的item复用了上边的item，造成下边item刚加载出来时显示的还是上边被复用的item的图片，等到这个新的item加载图片完毕时才会正常显示，这就是convert view复用造成listview图片加载错乱的问题。<br>与上边问题相似，在listview的item中存在CheckBox时也会由于复用convert view导致CheckBox的选中状态错乱，本片内容将解决由于复用导致CheckBox选中状态错乱的问题。<br>先看下存在问题的效果图<br><img src="https://raw.githubusercontent.com/zhpanvip/Resource/master/image/0402.jfif"></p><p>上图中只选中了北京市和天津市，当下滑ListView时发现下边的河南省和山东省也被选中了，再往下滑四川省和台湾省也被选中。其实可以发现一个规律，每一屏都会有两个条目被选中，其实这两个被选中的条目就是因为复用了第一屏的两个被选中的条目所导致的。<br>先看下ListView没有优化前的代码：</p><pre><code class="hljs routeros">public class MainActivity extends AppCompatActivity &#123;    private ListView mListView;    private List&lt;String&gt; mStringList;    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        <span class="hljs-attribute">mStringList</span>=new ArrayList&lt;&gt;();        mStringList.<span class="hljs-builtin-name">add</span>(<span class="hljs-string">&quot;北京市&quot;</span>);mStringList.<span class="hljs-builtin-name">add</span>(<span class="hljs-string">&quot;天津市&quot;</span>);mStringList.<span class="hljs-builtin-name">add</span>(<span class="hljs-string">&quot;上海市&quot;</span>);mStringList.<span class="hljs-builtin-name">add</span>(<span class="hljs-string">&quot;重庆市&quot;</span>);        mStringList.<span class="hljs-builtin-name">add</span>(<span class="hljs-string">&quot;河北省&quot;</span>);mStringList.<span class="hljs-builtin-name">add</span>(<span class="hljs-string">&quot;山西省&quot;</span>);mStringList.<span class="hljs-builtin-name">add</span>(<span class="hljs-string">&quot;辽宁省&quot;</span>);mStringList.<span class="hljs-builtin-name">add</span>(<span class="hljs-string">&quot;河南省&quot;</span>);        mStringList.<span class="hljs-builtin-name">add</span>(<span class="hljs-string">&quot;山东省&quot;</span>);mStringList.<span class="hljs-builtin-name">add</span>(<span class="hljs-string">&quot;湖北省&quot;</span>);mStringList.<span class="hljs-builtin-name">add</span>(<span class="hljs-string">&quot;湖南省&quot;</span>);mStringList.<span class="hljs-builtin-name">add</span>(<span class="hljs-string">&quot;江西省&quot;</span>);        mStringList.<span class="hljs-builtin-name">add</span>(<span class="hljs-string">&quot;福建省&quot;</span>);mStringList.<span class="hljs-builtin-name">add</span>(<span class="hljs-string">&quot;陕西省&quot;</span>);mStringList.<span class="hljs-builtin-name">add</span>(<span class="hljs-string">&quot;四川省&quot;</span>);mStringList.<span class="hljs-builtin-name">add</span>(<span class="hljs-string">&quot;台湾省&quot;</span>);        mListView= (ListView) findViewById(R.id.lv_main);        MyAdapter <span class="hljs-attribute">adapter</span>=new MyAdapter(this,mStringList);        mListView.setAdapter(adapter);    &#125;&#125;</code></pre><p>MainActivity中的代码为ListView适配数据和适配Adapter，不作过多解释。</p><pre><code class="hljs reasonml"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Created by zhpan on 2016/9/24.</span><span class="hljs-comment"> */</span>public <span class="hljs-keyword">class</span> MyAdapter extends BaseAdapter &#123;    List&lt;String&gt; mStringList;    Context mContext;    public <span class="hljs-constructor">MyAdapter(Context <span class="hljs-params">context</span>, List&lt;String&gt; <span class="hljs-params">stringList</span>)</span> &#123;        mStringList = stringList;        mContext=context;    &#125;    @Override    public long get<span class="hljs-constructor">ItemId(<span class="hljs-params">int</span> <span class="hljs-params">position</span>)</span> &#123;        return <span class="hljs-number">0</span>;    &#125;    @Override    public View get<span class="hljs-constructor">View(<span class="hljs-params">final</span> <span class="hljs-params">int</span> <span class="hljs-params">position</span>, View <span class="hljs-params">convertView</span>, ViewGroup <span class="hljs-params">parent</span>)</span> &#123;        MyViewHolder holder;        <span class="hljs-keyword">if</span>(convertView==null)&#123;            convertView=<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">View</span>.</span></span>inflate(mContext,<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">R</span>.</span></span>layout.item,null);            holder=<span class="hljs-keyword">new</span> <span class="hljs-constructor">MyViewHolder()</span>;            holder.mTextView= (TextView) convertView.find<span class="hljs-constructor">ViewById(R.<span class="hljs-params">id</span>.<span class="hljs-params">tv_item</span>)</span>;            holder.mCheckBox= (CheckBox) convertView.find<span class="hljs-constructor">ViewById(R.<span class="hljs-params">id</span>.<span class="hljs-params">cb_item</span>)</span>;            convertView.set<span class="hljs-constructor">Tag(<span class="hljs-params">holder</span>)</span>;        &#125;<span class="hljs-keyword">else</span> &#123;            holder= (MyViewHolder) convertView.get<span class="hljs-constructor">Tag()</span>;        &#125;        holder.mTextView.set<span class="hljs-constructor">Text(<span class="hljs-params">mStringList</span>.<span class="hljs-params">get</span>(<span class="hljs-params">position</span>)</span>);        return convertView;    &#125;    @Override    public <span class="hljs-built_in">int</span> get<span class="hljs-constructor">Count()</span> &#123;        return mStringList.size<span class="hljs-literal">()</span>;    &#125;    @Override    public Object get<span class="hljs-constructor">Item(<span class="hljs-params">int</span> <span class="hljs-params">position</span>)</span> &#123;        return null;    &#125;    public static <span class="hljs-keyword">class</span>  MyViewHolder &#123;        TextView mTextView;        CheckBox mCheckBox;    &#125;&#125;</code></pre><p>在Adapter中只是复用了convertView,没有对CheckBox做任何处理，那么这样写的代码是存在上图中的CheckBox选中状态错乱问题的。为了解决这个问题我们需要对CheckBox的选中状态做下保存，可以在Adapter中声明一个Map集合用来保存被选中的CheckBox。修改后代码如下：</p><pre><code class="hljs arduino"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Created by zhpan on 2016/9/24.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyAdapter</span> <span class="hljs-title">extends</span> <span class="hljs-title">BaseAdapter</span> &#123;</span>    List&lt;<span class="hljs-keyword">String</span>&gt; mStringList;    Context mContext;    <span class="hljs-keyword">private</span> Map&lt;Integer,Boolean&gt; <span class="hljs-built_in">map</span>=<span class="hljs-keyword">new</span> HashMap&lt;&gt;();<span class="hljs-comment">// 存放已被选中的CheckBox</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyAdapter</span><span class="hljs-params">(Context context, List&lt;<span class="hljs-keyword">String</span>&gt; stringList)</span> </span>&#123;        mStringList = stringList;        mContext=context;    &#125;    @Override    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getItemId</span><span class="hljs-params">(<span class="hljs-keyword">int</span> <span class="hljs-built_in">position</span>)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    @Override    <span class="hljs-function"><span class="hljs-keyword">public</span> View <span class="hljs-title">getView</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-built_in">position</span>, View convertView, ViewGroup parent)</span> </span>&#123;        MyViewHolder holder;        <span class="hljs-keyword">if</span>(convertView==null)&#123;            convertView=View.inflate(mContext,R.layout.item,null);            holder=<span class="hljs-keyword">new</span> MyViewHolder();            holder.mTextView= (TextView) convertView.findViewById(R.id.tv_item);            holder.mCheckBox= (CheckBox) convertView.findViewById(R.id.cb_item);            convertView.setTag(holder);        &#125;<span class="hljs-keyword">else</span> &#123;            holder= (MyViewHolder) convertView.getTag();        &#125;        holder.mTextView.setText(mStringList.<span class="hljs-built_in">get</span>(<span class="hljs-built_in">position</span>));        holder.mCheckBox.setOnCheckedChangeListener(<span class="hljs-keyword">new</span> CompoundButton.OnCheckedChangeListener() &#123;            @Override            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> onCheckedChanged(CompoundButton buttonView, <span class="hljs-keyword">boolean</span> isChecked) &#123;                <span class="hljs-keyword">if</span>(isChecked==<span class="hljs-literal">true</span>)&#123;                    <span class="hljs-built_in">map</span>.<span class="hljs-built_in">put</span>(<span class="hljs-built_in">position</span>,<span class="hljs-literal">true</span>);                &#125;<span class="hljs-keyword">else</span> &#123;                    <span class="hljs-built_in">map</span>.<span class="hljs-built_in">remove</span>(<span class="hljs-built_in">position</span>);                &#125;            &#125;        &#125;);        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">map</span>!=null&amp;&amp;<span class="hljs-built_in">map</span>.containsKey(<span class="hljs-built_in">position</span>))&#123;            holder.mCheckBox.setChecked(<span class="hljs-literal">true</span>);        &#125;<span class="hljs-keyword">else</span> &#123;            holder.mCheckBox.setChecked(<span class="hljs-literal">false</span>);        &#125;        <span class="hljs-keyword">return</span> convertView;    &#125;    @Override    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getCount</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> mStringList.<span class="hljs-built_in">size</span>();    &#125;    @Override    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getItem</span><span class="hljs-params">(<span class="hljs-keyword">int</span> <span class="hljs-built_in">position</span>)</span> </span>&#123;        <span class="hljs-keyword">return</span> null;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span>  <span class="hljs-title">MyViewHolder</span> &#123;</span>        TextView mTextView;        CheckBox mCheckBox;    &#125;&#125;</code></pre><p>针对这个问题我们子Adapter中加入了一个Map集合，其中Map的key用来存储条被选中的checkbox的position，value用来存储checkbox被选中。代码中还添加了checkbox的监听事件，在监听事件中判断点击的checkbox是否被选中，如果被选中了则将position添加到集合，并设置状态未true，否则就将该checkbox从集合中移除。然后通过if语句判断集合中是否存在该checkbox，如果存在则证明是被选中的,遂将该checkbox设置为选中状态setChecked(true)，否则证明checkbox没有选中则设置setChecked(false)。这样就解决了checkbox选中状态错乱的问题。<br>看下优化后的效果图<br><img src="https://raw.githubusercontent.com/zhpanvip/Resource/master/image/0403.jfif"></p><p>可以看到优化后CheckBox的选中状态不会再出现错乱问题了。</p><p><a href="http://download.csdn.net/detail/qq_20521573/9639225">源码下载</a></p><h3 id="好库推荐"><a href="#好库推荐" class="headerlink" title="好库推荐"></a>好库推荐</h3><p>给大家推荐一下<a href="https://github.com/zhpanvip/BannerViewPager">BannerViewPager</a>。这是一个基于ViewPager实现的具有强大功能的无限轮播库。通过<a href="https://github.com/zhpanvip/BannerViewPager">BannerViewPager</a>可以实现腾讯视频、QQ音乐、酷狗音乐、支付宝、天猫、淘宝、优酷视频、喜马拉雅、网易云音乐、哔哩哔哩等APP的Banner样式以及指示器样式。</p><p>欢迎大家到github关注<a href="https://github.com/zhpanvip/BannerViewPager">BannerViewPager</a>！</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>浅析Java设计模式（三）</title>
    <link href="/2016/07/26/%E6%B5%85%E6%9E%90Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <url>/2016/07/26/%E6%B5%85%E6%9E%90Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>本篇文章继续来学习Java的设计模式，这篇文章来解析行为型模式种的几种比较常用的设计模式。</p><p>一、观察者模式<br>观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态发生变化时，会通知所有的观察者对象，使它们能够自动更新自己。以微信推送腾讯新闻为例，用户在微信订阅了腾讯新闻后，用户会收到腾讯的新闻推送。如果用户取消了新闻订阅，那么就不会再收到推送。<br>1.创建一个被观察者Observer 接口，接口中有update方法</p><pre><code class="hljs routeros">public<span class="hljs-built_in"> interface </span>Observer &#123;void update(String news);&#125;</code></pre><p>2.创建观察者Observable接口，接口中有订阅、取消订阅、通知三个方法。</p><pre><code class="hljs routeros">public<span class="hljs-built_in"> interface </span>Observable &#123;void subscribe(Observer observer);void unsubscribe(Observer observer);void notifyObserver();&#125;</code></pre><p>3.创建TencentNewsObservable并实现Observable接口</p><pre><code class="hljs haxe"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TencentNewsObservable</span> <span class="hljs-keyword"><span class="hljs-keyword">implements</span> <span class="hljs-type">Observable</span></span> </span>&#123;<span class="hljs-keyword">private</span> List&lt;Observer&gt; observers=<span class="hljs-keyword">new</span> <span class="hljs-type">ArrayList</span>&lt;Observer&gt;();<span class="hljs-keyword">private</span> <span class="hljs-keyword">String</span> <span class="hljs-keyword">new</span><span class="hljs-type">s</span>;@Override<span class="hljs-keyword">public</span> void subscribe(Observer observer) &#123;observers.add(observer);&#125;@Override<span class="hljs-keyword">public</span> void unsubscribe(Observer observer) &#123;observers.remove(observer);&#125;@Override<span class="hljs-keyword">public</span> void notifyObserver() &#123;<span class="hljs-keyword">for</span>(Observer observer:<span class="hljs-type">observers</span>) &#123;observer.update(<span class="hljs-keyword">new</span><span class="hljs-type">s</span>);&#125;&#125;<span class="hljs-keyword">public</span> void sendNews(<span class="hljs-keyword">String</span> <span class="hljs-keyword">new</span><span class="hljs-type">s</span>) &#123;<span class="hljs-built_in">this</span>.<span class="hljs-keyword">new</span><span class="hljs-type">s</span>=<span class="hljs-keyword">new</span><span class="hljs-type">s</span>;notifyObserver();&#125;&#125;</code></pre><p>4.定义一个UserObserver并实现Observer接口</p><pre><code class="hljs haxe"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserObserver</span> <span class="hljs-keyword"><span class="hljs-keyword">implements</span> <span class="hljs-type">Observer</span></span></span>&#123;<span class="hljs-keyword">private</span> <span class="hljs-keyword">String</span> name;<span class="hljs-keyword">public</span> UserObserver(<span class="hljs-keyword">String</span> name) &#123;<span class="hljs-built_in">this</span>.name=name;&#125;@Override<span class="hljs-keyword">public</span> void update(<span class="hljs-keyword">String</span> <span class="hljs-keyword">new</span><span class="hljs-type">s</span>) &#123;System.out.println(name+<span class="hljs-string">&quot;收到一条消息：&quot;</span>+<span class="hljs-keyword">new</span><span class="hljs-type">s</span>);&#125;&#125;</code></pre><p>5.编写测试类</p><pre><code class="hljs haxe"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ObserverTest</span> </span>&#123;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> void main(<span class="hljs-keyword">String</span>[] args) &#123;UserObserver mike=<span class="hljs-keyword">new</span> <span class="hljs-type">UserObserver</span>(<span class="hljs-string">&quot;Mike&quot;</span>);UserObserver lucy=<span class="hljs-keyword">new</span> <span class="hljs-type">UserObserver</span>(<span class="hljs-string">&quot;Lucy&quot;</span>);UserObserver kate=<span class="hljs-keyword">new</span> <span class="hljs-type">UserObserver</span>(<span class="hljs-string">&quot;Kate&quot;</span>);TencentNewsObservable observerable=<span class="hljs-keyword">new</span> <span class="hljs-type">TencentNewsObservable</span>();observerable.subscribe(mike);observerable.subscribe(lucy);observerable.subscribe(kate);observerable.sendNews(<span class="hljs-string">&quot;this is an ad&quot;</span>);&#125;&#125;</code></pre><p>运行结果：</p><blockquote><p>Mike收到一条消息：this is an advertisement<br>Lucy收到一条消息：this is an advertisement<br>Kate收到一条消息：this is an advertisement</p></blockquote><p>此时Mike收到推送打开后一看，竟然是一条广告，愤怒之下取消了订阅！</p><pre><code class="hljs abnf">System.out.println(<span class="hljs-string">&quot;Mike unsubscribe news&quot;</span>)<span class="hljs-comment">;</span>observerable.unsubscribe(mike)<span class="hljs-comment">;</span>observerable.sendNews(<span class="hljs-string">&quot;this is a news&quot;</span>)<span class="hljs-comment">;</span></code></pre><p>运行结果：</p><blockquote><p>Mike收到一条消息：this is an advertisement<br>Lucy收到一条消息：this is an advertisement<br>Kate收到一条消息：this is an advertisement<br>Mike unsubscribe news<br>Lucy收到一条消息：this is a news<br>Kate收到一条消息：this is a news</p></blockquote><p>取消订阅后Mike再也没有收到新闻推送。</p><p>二、策略模式<br>策略模式定义了一系列的算法，并将每一个算法封装起来，而且使他们可以相互替换，让算法独立于使用它的客户而独立变化。策略模式设计三个角色，环境(Context)角色、抽象策略(Strategy)角色以及具体策略(ConcreteStrategy)角色。<br>来看一个现实生活的例子，假设一个商场有三种会员（Strategy），分别为普通会员（StandardMemberStraegy）、白银会员（SilverMemberStrategy）以及黄金会员（GoldenMemberStrategy）。针对三种会员分别制定了不同的优方案。普通会员打九折、白银会员打八折、黄金会员打七折。来看如何用策略模式实现上述场景。<br>1.创建抽象策略类</p><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> abstract <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Strategy</span> &#123;</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">String</span> strategy;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">String</span> <span class="hljs-title">getStrategy</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> strategy;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Strategy</span><span class="hljs-params">(<span class="hljs-keyword">String</span> strategy)</span> </span>&#123;super();<span class="hljs-keyword">this</span>.strategy = strategy;&#125;<span class="hljs-function">abstract <span class="hljs-keyword">double</span> <span class="hljs-title">getPrice</span><span class="hljs-params">(<span class="hljs-keyword">double</span> normalPrice)</span></span>;&#125;</code></pre><p>2.创建环境类（Context）并持有抽象策略类</p><pre><code class="hljs reasonml">public <span class="hljs-keyword">class</span> Context &#123;<span class="hljs-keyword">private</span> Strategy mStrategy;public void set<span class="hljs-constructor">Strategy(Strategy <span class="hljs-params">strategy</span>)</span> &#123;mStrategy=strategy;&#125;public double execute<span class="hljs-constructor">Price(<span class="hljs-params">double</span> <span class="hljs-params">normalPrice</span>)</span> &#123;<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(mStrategy.get<span class="hljs-constructor">Strategy()</span>+<span class="hljs-string">&quot;Member，折后价：&quot;</span>+mStrategy.get<span class="hljs-constructor">Price(<span class="hljs-params">normalPrice</span>)</span>);return mStrategy.get<span class="hljs-constructor">Price(<span class="hljs-params">normalPrice</span>)</span>;&#125;&#125;</code></pre><p>3.创建三种会员策略类</p><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StandardMemberStraegy</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Strategy</span> </span>&#123;public <span class="hljs-type">StandardMemberStraegy</span>(<span class="hljs-type">String</span> strategy) &#123;<span class="hljs-keyword">super</span>(strategy);&#125;<span class="hljs-meta">@Override</span>public double getPrice(double normalPrice) &#123;<span class="hljs-keyword">return</span> <span class="hljs-number">0.9</span>*normalPrice;&#125;&#125;public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SilverMemberStrategy</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Strategy</span></span>&#123;public <span class="hljs-type">SilverMemberStrategy</span>(<span class="hljs-type">String</span> strategy) &#123;<span class="hljs-keyword">super</span>(strategy);&#125;<span class="hljs-meta">@Override</span>public double getPrice(double normalPrice) &#123;<span class="hljs-keyword">return</span> <span class="hljs-number">0.8</span>*normalPrice;&#125;&#125;public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GoldenMemberStrategy</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Strategy</span> </span>&#123;public <span class="hljs-type">GoldenMemberStrategy</span>(<span class="hljs-type">String</span> strategy) &#123;<span class="hljs-keyword">super</span>(strategy);&#125;<span class="hljs-meta">@Override</span>public double getPrice(double normalPrice) &#123;<span class="hljs-keyword">return</span> <span class="hljs-number">0.7</span>*normalPrice;&#125;&#125;</code></pre><p>4.创建策略模式测试类</p><pre><code class="hljs reasonml">public <span class="hljs-keyword">class</span> StrategyTest &#123;public static void main(String<span class="hljs-literal">[]</span> args) &#123;StandardMemberStraegy standar=<span class="hljs-keyword">new</span> <span class="hljs-constructor">StandardMemberStraegy(<span class="hljs-string">&quot;Standar&quot;</span>)</span>;SilverMemberStrategy silver=<span class="hljs-keyword">new</span> <span class="hljs-constructor">SilverMemberStrategy(<span class="hljs-string">&quot;Silver&quot;</span>)</span>;GoldenMemberStrategy golden=<span class="hljs-keyword">new</span> <span class="hljs-constructor">GoldenMemberStrategy(<span class="hljs-string">&quot;Golden&quot;</span>)</span>;Context context=<span class="hljs-keyword">new</span> <span class="hljs-constructor">Context()</span>;context.set<span class="hljs-constructor">Strategy(<span class="hljs-params">standar</span>)</span>;context.execute<span class="hljs-constructor">Price(100)</span>;context.set<span class="hljs-constructor">Strategy(<span class="hljs-params">silver</span>)</span>;context.execute<span class="hljs-constructor">Price(100)</span>;context.set<span class="hljs-constructor">Strategy(<span class="hljs-params">golden</span>)</span>;context.execute<span class="hljs-constructor">Price(100)</span>;&#125;&#125;</code></pre><p>运行结果：</p><blockquote><p>StandarMember，折后价：90.0<br>SilverMember，折后价：80.0<br>GoldenMember，折后价：70.0</p></blockquote><h3 id="好库推荐"><a href="#好库推荐" class="headerlink" title="好库推荐"></a>好库推荐</h3><p>给大家推荐一下<a href="https://github.com/zhpanvip/BannerViewPager">BannerViewPager</a>。这是一个基于ViewPager实现的具有强大功能的无限轮播库。通过<a href="https://github.com/zhpanvip/BannerViewPager">BannerViewPager</a>可以实现腾讯视频、QQ音乐、酷狗音乐、支付宝、天猫、淘宝、优酷视频、喜马拉雅、网易云音乐、哔哩哔哩等APP的Banner样式以及指示器样式。</p><p>欢迎大家到github关注<a href="https://github.com/zhpanvip/BannerViewPager">BannerViewPager</a>！</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>浅析Java设计模式（二）</title>
    <link href="/2016/07/25/%E6%B5%85%E6%9E%90Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <url>/2016/07/25/%E6%B5%85%E6%9E%90Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>上篇文章我们学习了几种创建型模式 的设计模式，那么本篇文章就继续来学习一下结构型模式的几个常用设计模式。</p><h2 id="一、代理模式（Proxy-Pattern）"><a href="#一、代理模式（Proxy-Pattern）" class="headerlink" title="一、代理模式（Proxy Pattern）"></a>一、代理模式（Proxy Pattern）</h2><p>代理模式即为其它对象提供一种代理控制对这个对象的访问。在代理模式中，一个类代表另一个类的功能。这种类型的设计模式属于结构型模式。在代理模式中，我们创建具有现有对象的对象，以便向外界提供功能接口。代理模式的机构图如下：<br><img src="https://raw.githubusercontent.com/zhpanvip/Resource/master/image/0201.png" alt="静态代理"></p><p>Subject类中定义一个抽象request()方法,RealSubject和Proxy共用接口，这样就在任何使用RealSubject的地方都可以使用Proxy。<br>1.Subject类代码如下：</p><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Subject</span> &#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">request</span>(<span class="hljs-params"></span>)</span>;&#125;</code></pre><p>2.RealSubject集成Subject类</p><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RealSubject</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Subject</span></span>&#123;<span class="hljs-meta">@Override</span>public void request() &#123;<span class="hljs-type">System</span>.out.println(<span class="hljs-string">&quot;Real Request&quot;</span>);&#125;&#125;</code></pre><p>3.Proxy实现Subject类</p><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Proxy</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Subject</span> </span>&#123;<span class="hljs-keyword">private</span> <span class="hljs-type">RealSubject</span> mRealSubject;<span class="hljs-meta">@Override</span>public void request() &#123;<span class="hljs-keyword">if</span>(mRealSubject==<span class="hljs-literal">null</span>) &#123;mRealSubject=<span class="hljs-keyword">new</span> <span class="hljs-type">RealSubject</span>();&#125;mRealSubject.request();&#125;&#125;</code></pre><p>4.代理测试类</p><pre><code class="hljs routeros">public class ProxyTest &#123;public static void main(String[] args) &#123;<span class="hljs-built_in">Proxy </span><span class="hljs-attribute">proxy</span>=new Proxy();proxy.request();&#125;&#125;</code></pre><p>输出结果：</p><blockquote><p>Real Request</p></blockquote><h2 id="二、装饰模式（Decorator-Pattern）"><a href="#二、装饰模式（Decorator-Pattern）" class="headerlink" title="二、装饰模式（Decorator Pattern）"></a>二、装饰模式（Decorator Pattern）</h2><p>装饰模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装。</p><p>我们将创建一个 Shape 接口和实现了 Shape 接口的实体类。然后我们创建一个实现了 Shape 接口的抽象装饰类 ShapeDecorator，并把 Shape 对象作为它的实例变量。RedShapeDecorator 是实现了 ShapeDecorator 的实体类。DecoratorPatternDemo，我们的演示类使用 RedShapeDecorator 来装饰 Shape 对象。UML图如下：<br><img src="https://raw.githubusercontent.com/zhpanvip/Resource/master/image/0202.jfif" alt="装饰模式"></p><p>1.创建Shape接口</p><pre><code class="hljs routeros">public<span class="hljs-built_in"> interface </span>Shape &#123;void draw();&#125;</code></pre><p>2.创建Circle类和Rectangle类并实现Shape接口</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Circle</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Shape</span> </span>&#123;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> </span>&#123;System.out.println(<span class="hljs-string">&quot;Draw Circle&quot;</span>);&#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rectangle</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Shape</span> </span>&#123;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> </span>&#123;System.out.println(<span class="hljs-string">&quot;Draw Rectangle&quot;</span>);&#125;&#125;</code></pre><p>3.创建实现了 Shape 接口的抽象装饰类</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShapeDecorator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Shape</span> </span>&#123;<span class="hljs-keyword">protected</span> Shape decoratedShape;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ShapeDecorator</span><span class="hljs-params">(Shape decoratedShape)</span> </span>&#123;<span class="hljs-keyword">this</span>.decoratedShape=decoratedShape;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> </span>&#123;decoratedShape.draw();&#125;&#125;</code></pre><p>4.创建RedShapeDecorator装饰类并继承ShapeDecorator</p><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedShapeDecorator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ShapeDecorator</span>  </span>&#123;public <span class="hljs-type">RedShapeDecorator</span>(<span class="hljs-type">Shape</span> decoratedShape) &#123;<span class="hljs-keyword">super</span>(decoratedShape);&#125;<span class="hljs-meta">@Override</span>public void draw() &#123;decoratedShape.draw();setRedBorder(decoratedShape);&#125;<span class="hljs-keyword">private</span> void setRedBorder(<span class="hljs-type">Shape</span> decoratedShape) &#123;<span class="hljs-type">System</span>.out.println(<span class="hljs-string">&quot;Red Border Corlor&quot;</span>);&#125;&#125;</code></pre><p>5.装饰模式测试类</p><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> DecoratorTest &#123;<span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) &#123;Shape <span class="hljs-type">circle</span>=<span class="hljs-built_in">new</span> Circle();Shape redCircle=<span class="hljs-built_in">new</span> RedShapeDecorator(<span class="hljs-built_in">new</span> Circle());Shape redRectangle=<span class="hljs-built_in">new</span> RedShapeDecorator(<span class="hljs-built_in">new</span> Rectangle());<span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;Circle with normal border&quot;);<span class="hljs-type">circle</span>.draw();<span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;Circle whit red border&quot;);redCircle.draw();<span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;Rectangle with red border&quot;);redRectangle.draw();&#125;&#125;</code></pre><p>输出结果：</p><blockquote><p>Circle with normal border<br>Draw Circle<br>Circle whit red border<br>Draw Circle<br>Red Border Corlor<br>Rectangle with red border<br>Draw Rectangle<br>Red Border Corlor</p></blockquote><h2 id="三、适配器模式"><a href="#三、适配器模式" class="headerlink" title="三、适配器模式"></a>三、适配器模式</h2><p>适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁。这种类型的设计模式属于结构型模式，它结合了两个独立接口的功能。通常来说，在软件开发中，系统的数据和行为都正确，但接口不符合时，我们应该考虑用适配器，目的是使控制范围之外的一个原有对象与某个接口匹配。</p><p>现在假定在我们的应用中使用了两种地图，分别是Google地图和Baidu地图。这两个地图接口对我们而言是隐藏不可修改的，但是由于我们应用的特殊需求，可能会使用两个地图获取位置。那么此时我们就可以用适配器模式来实现。<br>1.当前我们拥有百度地图和Google地图两个接口均可以获取地理位置。</p><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaiduMap</span> &#123;</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">String</span> <span class="hljs-title">getBaiduLocation</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;this is baidu location&quot;</span>;&#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GoogleMap</span> &#123;</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">String</span> <span class="hljs-title">getGoogleLocation</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;this is Google location&quot;</span>;&#125;&#125;</code></pre><p>2.创建一个Map接口</p><pre><code class="hljs routeros">public<span class="hljs-built_in"> interface </span>Map &#123;String getLocation(String mapType);&#125;</code></pre><p>3.创建LocationAdapter实现Map接口</p><pre><code class="hljs haxe"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LocationAdapter</span> <span class="hljs-keyword"><span class="hljs-keyword">implements</span> <span class="hljs-type">Map</span></span> </span>&#123;@Override<span class="hljs-keyword">public</span> <span class="hljs-keyword">String</span> getLocation(<span class="hljs-keyword">String</span> mapType) &#123;<span class="hljs-keyword">String</span> location=<span class="hljs-string">&quot;&quot;</span>;<span class="hljs-keyword">switch</span>(mapType) &#123;<span class="hljs-keyword">case</span> <span class="hljs-string">&quot;Baidu&quot;</span>:<span class="hljs-type"></span><span class="hljs-type">location</span>=<span class="hljs-keyword">new</span> <span class="hljs-type">BaiduMap</span>().getBaiduLocation();<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-string">&quot;Google&quot;</span>:<span class="hljs-type"></span><span class="hljs-type">location</span>=<span class="hljs-keyword">new</span> <span class="hljs-type">GoogleMap</span>().getGoogleLocation();<span class="hljs-keyword">break</span>;&#125;<span class="hljs-keyword">return</span> location;&#125;&#125;</code></pre><p>3.测试适配器模式</p><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AdapterTest</span> &#123;</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;LocationAdapter adapter=<span class="hljs-keyword">new</span> LocationAdapter();System.out.<span class="hljs-built_in">println</span>(adapter.getLocation(<span class="hljs-string">&quot;Baidu&quot;</span>));System.out.<span class="hljs-built_in">println</span>(adapter.getLocation(<span class="hljs-string">&quot;Google&quot;</span>));&#125;&#125;</code></pre><p>输出结果：</p><blockquote><p>this is baidu location<br>this is Google location</p></blockquote><h3 id="好库推荐"><a href="#好库推荐" class="headerlink" title="好库推荐"></a>好库推荐</h3><p>给大家推荐一下<a href="https://github.com/zhpanvip/BannerViewPager">BannerViewPager</a>。这是一个基于ViewPager实现的具有强大功能的无限轮播库。通过<a href="https://github.com/zhpanvip/BannerViewPager">BannerViewPager</a>可以实现腾讯视频、QQ音乐、酷狗音乐、支付宝、天猫、淘宝、优酷视频、喜马拉雅、网易云音乐、哔哩哔哩等APP的Banner样式以及指示器样式。</p><p>欢迎大家到github关注<a href="https://github.com/zhpanvip/BannerViewPager">BannerViewPager</a>！</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>浅析Java设计模式（一）</title>
    <link href="/2016/07/24/%E6%B5%85%E6%9E%90Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/2016/07/24/%E6%B5%85%E6%9E%90Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>设计模式可以分为三大类<br><strong>1.创建型模式</strong> 这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。该类设计模式有五种:</p><ul><li>简单工厂模式（Factory Pattern） </li><li>建造者模式（Builder Pattern）</li><li>单例模式（SingletonPattern）    </li><li>原型模式（Prototype Pattern）</li><li>抽象工厂模式（Abstract Factory Pattern） </li></ul><p><strong>2.结构型模式</strong> 这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。该类模式有五种：</p><ul><li>代理模式（Proxy Pattern）</li><li>装饰器模式（Decorator Pattern）  </li><li>适配器模式（Adapter Pattern）</li><li>组合模式（Composite Pattern）   </li><li>桥接模式（Bridge Pattern）  </li><li>外观模式（FacadePattern）   </li><li>过滤器模式（Filter、CriteriaPattern）  </li></ul><p><strong>3.行为型模式</strong>  这些设计模式特别关注对象之间的通信。</p><ul><li>观察者模式（Observer Pattern）</li><li>中介者模式（Mediator Pattern）</li><li>策略模式（Strategy Pattern）</li><li>责任链模式（Chain of Responsibility Pattern）</li><li>命令模式（Command Pattern）</li><li>解释器模式（Interpreter Pattern）</li><li>迭代器模式（Iterator Pattern）</li><li>备忘录模式（Memento Pattern）</li><li>状态模式（State Pattern）</li><li>空对象模式（Null Object Pattern）</li><li>模板模式（Template Pattern）</li><li>访问者模式（Visitor Pattern）<br>《浅析Java设计模式》将分为三篇分别对三类设计模式中比较常用且典型的几种模式做讲解。本篇文章是第一篇将从创建型模式中挑选简单工厂模式、单例模式以及建造者模式来解析。</li></ul><h2 id="一、简单工厂模式"><a href="#一、简单工厂模式" class="headerlink" title="一、简单工厂模式"></a>一、简单工厂模式</h2><p>简单工厂模式就是建立一个工厂类，对实现了同一接口的一些类进行实例的创建。简单工厂模式的实质是由一个工厂类根据传入的参数，动态决定应该创建哪一个产品类（这些产品类继承自一个父类或接口）的实例。<br>简单工厂模式UML<br>我们以画矩形、三角形以及圆为例，对于三种图形，可以抽象出来一个Shape，它们有共同的draw方法。并且让三种图形均实现Shape接口。简单工厂模式UML图如下所示：<br><img src="https://raw.githubusercontent.com/zhpanvip/Resource/master/image/0101.jfif" alt="简单工厂模式"></p><p>1.首先定义Shape接口，接口中有三种图形共有的draw方法：</p><pre><code class="hljs routeros">public<span class="hljs-built_in"> interface </span>Shape &#123;void draw();&#125;</code></pre><p>2.创建三种形状并实现Shape接口：<br>矩形类：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rectangle</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Shape</span> </span>&#123;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> </span>&#123;System.out.println(<span class="hljs-string">&quot;Draw a Rectangle&quot;</span>);&#125;&#125;</code></pre><p>三角形：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Triangle</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Shape</span> </span>&#123;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> </span>&#123;System.out.println(<span class="hljs-string">&quot;Draw a Triangle&quot;</span>);&#125;&#125;</code></pre><p>圆形：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Circle</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Shape</span> </span>&#123;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> </span>&#123;System.out.println(<span class="hljs-string">&quot;Draw a circle&quot;</span>);&#125;&#125;</code></pre><p>3.创建工厂类，并根据参数信息画出对应的图形：</p><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ShapFactory</span> &#123; <span class="hljs-comment">//使用 getShape 方法获取形状类型的对象</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> Shape <span class="hljs-title">getShape</span>(<span class="hljs-params">String shapeType</span>)</span>&#123;      <span class="hljs-keyword">if</span>(shapeType == <span class="hljs-literal">null</span>)&#123;         <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;      &#125;              <span class="hljs-keyword">if</span>(shapeType.<span class="hljs-keyword">equals</span>(<span class="hljs-string">&quot;Circle&quot;</span>))&#123;         <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Circle();      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(shapeType.<span class="hljs-keyword">equals</span>(<span class="hljs-string">&quot;Rectangle&quot;</span>))&#123;         <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Rectangle();      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(shapeType.<span class="hljs-keyword">equals</span>(<span class="hljs-string">&quot;Triangle&quot;</span>))&#123;         <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Triangle();      &#125;      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;   &#125;&#125;</code></pre><p>4.接下来，我们创建一个测试类：</p><pre><code class="hljs mipsasm">public class FactoryTest &#123;public static void main(String[] args) &#123;<span class="hljs-keyword">ShapFactory </span><span class="hljs-keyword">shapFactory </span>= new <span class="hljs-keyword">ShapFactory();</span><span class="hljs-keyword"></span><span class="hljs-keyword"></span><span class="hljs-keyword">Shape </span><span class="hljs-keyword">shapeCircle </span>= <span class="hljs-keyword">shapFactory.getShape(&quot;Circle&quot;);</span><span class="hljs-keyword"></span><span class="hljs-keyword">shapeCircle.draw();</span><span class="hljs-keyword"></span><span class="hljs-keyword"></span><span class="hljs-keyword">Shape </span><span class="hljs-keyword">shapeRectangle </span>= <span class="hljs-keyword">shapFactory.getShape(&quot;Rectangle&quot;);</span><span class="hljs-keyword"></span><span class="hljs-keyword">shapeRectangle.draw();</span><span class="hljs-keyword"></span><span class="hljs-keyword"></span><span class="hljs-keyword">Shape </span><span class="hljs-keyword">shapeTriangle </span>= <span class="hljs-keyword">shapFactory.getShape(&quot;Triangle&quot;);</span><span class="hljs-keyword"></span><span class="hljs-keyword">shapeTriangle.draw();</span><span class="hljs-keyword"></span><span class="hljs-keyword"></span><span class="hljs-keyword">Shape </span><span class="hljs-keyword">shapeSquare </span>= <span class="hljs-keyword">shapFactory.getShape(&quot;Square&quot;);</span><span class="hljs-keyword"></span>if (<span class="hljs-keyword">shapeSquare </span>== null) &#123;System.out.println(<span class="hljs-string">&quot;shapeSquare is null!&quot;</span>);&#125; else &#123;<span class="hljs-keyword">shapeSquare.draw();</span><span class="hljs-keyword"></span>&#125;&#125;&#125;</code></pre><p> 输出结果： </p><blockquote><p>Draw a circle<br>Draw a Rectangle<br> Draw a Triangle<br>shapeSquare isnull!</p></blockquote><h2 id="二、单例模式"><a href="#二、单例模式" class="headerlink" title="二、单例模式"></a>二、单例模式</h2><p>单例模式（Singleton Pattern），保证一个类仅有一个实例，并提供一个访问它的全局访问方法。单例模式需要我们把显示定义的构造方法私有化，不允许外部对它实例化。单例模式的结构图如下所示。</p><p><img src="https://raw.githubusercontent.com/zhpanvip/Resource/master/image/0102.png" alt="单例模式"></p><p><strong>1.一个简单的单例模式实现。</strong></p><pre><code class="hljs routeros">public class Singleton &#123;private static Singleton instance;private Singleton() &#123;&#125;public static Singleton getInstance() &#123;<span class="hljs-keyword">if</span>(<span class="hljs-attribute">instance</span>==null) &#123;<span class="hljs-built_in">instance </span>= new Singleton();&#125;return instance;&#125;public void openWindow() &#123;System.out.println(<span class="hljs-string">&quot;Open a Window&quot;</span>);&#125;&#125;</code></pre><p>上面就是一个最简单的单例模式，我们来写一个测试类：</p><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingleTest</span> &#123;</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;Singleton single1=Singleton.getInstance();Singleton single2=Singleton.getInstance();System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;single1.equals(single2)---&quot;</span>+single1.equals(single2));&#125;&#125;</code></pre><p>输出结果：</p><blockquote><p>single1.equals(single2)—true</p></blockquote><p>从输出结果可以看出两次调用getInstance得到的是同一个Singleton 实例。</p><p>上面仅仅是实现单例的一种方式，在调用时实例化对象我们称之为懒汉式，上面的代码有一个弊端，就是不支持多线程调用，在多线程调用的情况下可能会被实例化出多个实例，因此，严格来讲它并不是真正的单例模式！接下来我们继续来看几种单例模式的实现方法，并且来保证它的线程安全。<br><strong>2.线程安全的懒汉式单例模式</strong></p><pre><code class="hljs routeros">public class Singleton &#123;private static Singleton instance;private Singleton() &#123;&#125;public static synchronized  Singleton getInstance() &#123;<span class="hljs-keyword">if</span>(<span class="hljs-attribute">instance</span>==null) &#123;<span class="hljs-built_in">instance </span>= new Singleton();&#125;return instance;&#125;public void openWindow() &#123;System.out.println(<span class="hljs-string">&quot;Open a Window&quot;</span>);&#125;&#125;</code></pre><p>如上代码，我们仅仅在getInstance方法上加了一个synchronized 锁，从而保证了线程的安全。但是我们又不得不考虑一个问题，即每次调用getInstance的时候都会加锁，这种做法势必影响了程序的性能，所以还有待改良。<br><strong>3.双重锁定的单例模式</strong></p><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> &#123;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span>(<span class="hljs-params"></span>)</span> &#123;&#125;<span class="hljs-comment">//双重校验锁 线程安全  不用让线程每次都加锁，只有在未实例化时加锁，提高性能。</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton2 <span class="hljs-title">getInstance3</span>(<span class="hljs-params"></span>)</span> &#123;<span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<span class="hljs-comment">//先判断实例是否存在，不存在再加锁处理</span>synchronized (Singleton2.class) &#123;<span class="hljs-keyword">if</span>(instance==<span class="hljs-literal">null</span>) &#123;instance=<span class="hljs-keyword">new</span> Singleton2();&#125;&#125;&#125;<span class="hljs-keyword">return</span> instance;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">openWindow</span>(<span class="hljs-params"></span>)</span> &#123;System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;Open a Window&quot;</span>);&#125;&#125;</code></pre><p>上述代码中为什么两次判断instance是否为null？假如instance为null并且同时又两个线程调用getInstance()方法，它们将同时通过第一重instance==null的判断。然后由于锁机制，这两个线程只能有一个进入，另一个在外排队等候。等到第一个执行完后另一个线程才能进入。而此时如果没有第二重instance是否为空的判断，则第一个线程创建了实例，而第二个线程还是可以继续创建实例。这样没有达到单例的目的。<br><strong>4.饿汉式实现单例模式</strong><br>前三种我们讲解了懒汉式实现单例。那么还有一种在类加载时就创建对象的单例模式的实现方法我们称之为饿汉式。代码如下：</p><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> &#123;</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance=<span class="hljs-keyword">new</span> Singleton();<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> instance;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">openWindow</span><span class="hljs-params">()</span> </span>&#123;System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;Open a Window&quot;</span>);&#125;&#125;</code></pre><p>这种单例模式基于 classloader 机制避免了多线程的同步问题。但因为instance在类加载时就被实例化了，因此存在内存浪费的可能性。</p><h2 id="三、建造者模式"><a href="#三、建造者模式" class="headerlink" title="三、建造者模式"></a>三、建造者模式</h2><p>建造者模式是将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。<br>我们以画卡通人物为例，画一个卡通人物需要完成头、身体、手、腿的绘制。那么，我们就可以抽象出一个IDrawPerson的接口</p><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IDrawPerson</span> &#123; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">drawHead</span>(<span class="hljs-params"></span>)</span>;  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">drawBody</span>(<span class="hljs-params"></span>)</span>;  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">drawHand</span>(<span class="hljs-params"></span>)</span>;  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">drawLeg</span>(<span class="hljs-params"></span>)</span>;  <span class="hljs-function">Person <span class="hljs-title">buildPerson</span>(<span class="hljs-params"></span>)</span>;&#125;</code></pre><p>接下来，我想画一个比较瘦的卡通人物，那么定义PersonThinBuilder并实现IDrawPerson类</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<span class="hljs-keyword">private</span> String head;<span class="hljs-keyword">private</span> String body;<span class="hljs-keyword">private</span> String hand;<span class="hljs-keyword">private</span> String leg;...  <span class="hljs-comment">//省去get、set方法</span>&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PersonThinBuilder</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IDrawPerson</span> </span>&#123;<span class="hljs-keyword">private</span> Person mPerson;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PersonThinBuilder</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">super</span>();mPerson=<span class="hljs-keyword">new</span> Person();&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">drawHead</span><span class="hljs-params">()</span> </span>&#123;mPerson.setHead(<span class="hljs-string">&quot;draw head&quot;</span>);&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">drawBody</span><span class="hljs-params">()</span> </span>&#123;mPerson.setBody(<span class="hljs-string">&quot;draw thin body&quot;</span>);&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">drawHand</span><span class="hljs-params">()</span> </span>&#123;mPerson.setHand(<span class="hljs-string">&quot;draa hand&quot;</span>);&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">drawLeg</span><span class="hljs-params">()</span> </span>&#123;mPerson.setLeg(<span class="hljs-string">&quot;draw leg&quot;</span>);&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> Person <span class="hljs-title">buildPerson</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> mPerson;&#125;&#125;</code></pre><p>同样，如果我想再画一个胖人或者高个子都用类似代码实现这个类就可以了。</p><p>接下来看建造者模式中很重要的一个类，指挥者类，用这个类来控制建造过程或者隔离用户与建造过程的关联。</p><pre><code class="hljs reasonml">public <span class="hljs-keyword">class</span> PersonDirector &#123;public Person <span class="hljs-constructor">CreatePerson(IDrawPerson <span class="hljs-params">buildPerson</span>)</span> &#123;buildPerson.draw<span class="hljs-constructor">Head()</span>;buildPerson.draw<span class="hljs-constructor">Body()</span>;buildPerson.draw<span class="hljs-constructor">Hand()</span>;buildPerson.draw<span class="hljs-constructor">Leg()</span>;return buildPerson.build<span class="hljs-constructor">Person()</span>;&#125;&#125;</code></pre><p>最后来看创建一个建造者模式的测试类：</p><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BuildTest</span> &#123;</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;PersonDirector personDirector=<span class="hljs-keyword">new</span> PersonDirector();Person thinPerson=personDirector.CreatePerson(<span class="hljs-keyword">new</span> PersonThinBuilder());System.out.<span class="hljs-built_in">println</span>(thinPerson.getBody());&#125;&#125;</code></pre><p>输出结果：</p><blockquote><p>draw thin body</p></blockquote><h3 id="好库推荐"><a href="#好库推荐" class="headerlink" title="好库推荐"></a>好库推荐</h3><p>给大家推荐一下<a href="https://github.com/zhpanvip/BannerViewPager">BannerViewPager</a>。这是一个基于ViewPager实现的具有强大功能的无限轮播库。通过<a href="https://github.com/zhpanvip/BannerViewPager">BannerViewPager</a>可以实现腾讯视频、QQ音乐、酷狗音乐、支付宝、天猫、淘宝、优酷视频、喜马拉雅、网易云音乐、哔哩哔哩等APP的Banner样式以及指示器样式。</p><p>欢迎大家到github关注<a href="https://github.com/zhpanvip/BannerViewPager">BannerViewPager</a>！</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
