<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>浅析Java设计模式（三）</title>
    <link href="/2016/07/26/%E6%B5%85%E6%9E%90Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <url>/2016/07/26/%E6%B5%85%E6%9E%90Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>本篇文章继续来学习Java的设计模式，这篇文章来解析行为型模式种的几种比较常用的设计模式。</p><p>一、观察者模式<br>观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态发生变化时，会通知所有的观察者对象，使它们能够自动更新自己。以微信推送腾讯新闻为例，用户在微信订阅了腾讯新闻后，用户会收到腾讯的新闻推送。如果用户取消了新闻订阅，那么就不会再收到推送。<br>1.创建一个被观察者Observer 接口，接口中有update方法</p><pre><code class="hljs routeros">public<span class="hljs-built_in"> interface </span>Observer &#123;void update(String news);&#125;</code></pre><p>2.创建观察者Observable接口，接口中有订阅、取消订阅、通知三个方法。</p><pre><code class="hljs routeros">public<span class="hljs-built_in"> interface </span>Observable &#123;void subscribe(Observer observer);void unsubscribe(Observer observer);void notifyObserver();&#125;</code></pre><p>3.创建TencentNewsObservable并实现Observable接口</p><pre><code class="hljs haxe"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TencentNewsObservable</span> <span class="hljs-keyword"><span class="hljs-keyword">implements</span> <span class="hljs-type">Observable</span></span> </span>&#123;<span class="hljs-keyword">private</span> List&lt;Observer&gt; observers=<span class="hljs-keyword">new</span> <span class="hljs-type">ArrayList</span>&lt;Observer&gt;();<span class="hljs-keyword">private</span> <span class="hljs-keyword">String</span> <span class="hljs-keyword">new</span><span class="hljs-type">s</span>;@Override<span class="hljs-keyword">public</span> void subscribe(Observer observer) &#123;observers.add(observer);&#125;@Override<span class="hljs-keyword">public</span> void unsubscribe(Observer observer) &#123;observers.remove(observer);&#125;@Override<span class="hljs-keyword">public</span> void notifyObserver() &#123;<span class="hljs-keyword">for</span>(Observer observer:<span class="hljs-type">observers</span>) &#123;observer.update(<span class="hljs-keyword">new</span><span class="hljs-type">s</span>);&#125;&#125;<span class="hljs-keyword">public</span> void sendNews(<span class="hljs-keyword">String</span> <span class="hljs-keyword">new</span><span class="hljs-type">s</span>) &#123;<span class="hljs-built_in">this</span>.<span class="hljs-keyword">new</span><span class="hljs-type">s</span>=<span class="hljs-keyword">new</span><span class="hljs-type">s</span>;notifyObserver();&#125;&#125;</code></pre><p>4.定义一个UserObserver并实现Observer接口</p><pre><code class="hljs haxe"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserObserver</span> <span class="hljs-keyword"><span class="hljs-keyword">implements</span> <span class="hljs-type">Observer</span></span></span>&#123;<span class="hljs-keyword">private</span> <span class="hljs-keyword">String</span> name;<span class="hljs-keyword">public</span> UserObserver(<span class="hljs-keyword">String</span> name) &#123;<span class="hljs-built_in">this</span>.name=name;&#125;@Override<span class="hljs-keyword">public</span> void update(<span class="hljs-keyword">String</span> <span class="hljs-keyword">new</span><span class="hljs-type">s</span>) &#123;System.out.println(name+<span class="hljs-string">&quot;收到一条消息：&quot;</span>+<span class="hljs-keyword">new</span><span class="hljs-type">s</span>);&#125;&#125;</code></pre><p>5.编写测试类</p><pre><code class="hljs haxe"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ObserverTest</span> </span>&#123;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> void main(<span class="hljs-keyword">String</span>[] args) &#123;UserObserver mike=<span class="hljs-keyword">new</span> <span class="hljs-type">UserObserver</span>(<span class="hljs-string">&quot;Mike&quot;</span>);UserObserver lucy=<span class="hljs-keyword">new</span> <span class="hljs-type">UserObserver</span>(<span class="hljs-string">&quot;Lucy&quot;</span>);UserObserver kate=<span class="hljs-keyword">new</span> <span class="hljs-type">UserObserver</span>(<span class="hljs-string">&quot;Kate&quot;</span>);TencentNewsObservable observerable=<span class="hljs-keyword">new</span> <span class="hljs-type">TencentNewsObservable</span>();observerable.subscribe(mike);observerable.subscribe(lucy);observerable.subscribe(kate);observerable.sendNews(<span class="hljs-string">&quot;this is an ad&quot;</span>);&#125;&#125;</code></pre><p>运行结果：</p><blockquote><p>Mike收到一条消息：this is an advertisement<br>Lucy收到一条消息：this is an advertisement<br>Kate收到一条消息：this is an advertisement</p></blockquote><p>此时Mike收到推送打开后一看，竟然是一条广告，愤怒之下取消了订阅！</p><pre><code class="hljs abnf">System.out.println(<span class="hljs-string">&quot;Mike unsubscribe news&quot;</span>)<span class="hljs-comment">;</span>observerable.unsubscribe(mike)<span class="hljs-comment">;</span>observerable.sendNews(<span class="hljs-string">&quot;this is a news&quot;</span>)<span class="hljs-comment">;</span></code></pre><p>运行结果：</p><blockquote><p>Mike收到一条消息：this is an advertisement<br>Lucy收到一条消息：this is an advertisement<br>Kate收到一条消息：this is an advertisement<br>Mike unsubscribe news<br>Lucy收到一条消息：this is a news<br>Kate收到一条消息：this is a news</p></blockquote><p>取消订阅后Mike再也没有收到新闻推送。</p><p>二、策略模式<br>策略模式定义了一系列的算法，并将每一个算法封装起来，而且使他们可以相互替换，让算法独立于使用它的客户而独立变化。策略模式设计三个角色，环境(Context)角色、抽象策略(Strategy)角色以及具体策略(ConcreteStrategy)角色。<br>来看一个现实生活的例子，假设一个商场有三种会员（Strategy），分别为普通会员（StandardMemberStraegy）、白银会员（SilverMemberStrategy）以及黄金会员（GoldenMemberStrategy）。针对三种会员分别制定了不同的优方案。普通会员打九折、白银会员打八折、黄金会员打七折。来看如何用策略模式实现上述场景。<br>1.创建抽象策略类</p><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> abstract <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Strategy</span> &#123;</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">String</span> strategy;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">String</span> <span class="hljs-title">getStrategy</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> strategy;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Strategy</span><span class="hljs-params">(<span class="hljs-keyword">String</span> strategy)</span> </span>&#123;super();<span class="hljs-keyword">this</span>.strategy = strategy;&#125;<span class="hljs-function">abstract <span class="hljs-keyword">double</span> <span class="hljs-title">getPrice</span><span class="hljs-params">(<span class="hljs-keyword">double</span> normalPrice)</span></span>;&#125;</code></pre><p>2.创建环境类（Context）并持有抽象策略类</p><pre><code class="hljs reasonml">public <span class="hljs-keyword">class</span> Context &#123;<span class="hljs-keyword">private</span> Strategy mStrategy;public void set<span class="hljs-constructor">Strategy(Strategy <span class="hljs-params">strategy</span>)</span> &#123;mStrategy=strategy;&#125;public double execute<span class="hljs-constructor">Price(<span class="hljs-params">double</span> <span class="hljs-params">normalPrice</span>)</span> &#123;<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(mStrategy.get<span class="hljs-constructor">Strategy()</span>+<span class="hljs-string">&quot;Member，折后价：&quot;</span>+mStrategy.get<span class="hljs-constructor">Price(<span class="hljs-params">normalPrice</span>)</span>);return mStrategy.get<span class="hljs-constructor">Price(<span class="hljs-params">normalPrice</span>)</span>;&#125;&#125;</code></pre><p>3.创建三种会员策略类</p><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StandardMemberStraegy</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Strategy</span> </span>&#123;public <span class="hljs-type">StandardMemberStraegy</span>(<span class="hljs-type">String</span> strategy) &#123;<span class="hljs-keyword">super</span>(strategy);&#125;<span class="hljs-meta">@Override</span>public double getPrice(double normalPrice) &#123;<span class="hljs-keyword">return</span> <span class="hljs-number">0.9</span>*normalPrice;&#125;&#125;public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SilverMemberStrategy</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Strategy</span></span>&#123;public <span class="hljs-type">SilverMemberStrategy</span>(<span class="hljs-type">String</span> strategy) &#123;<span class="hljs-keyword">super</span>(strategy);&#125;<span class="hljs-meta">@Override</span>public double getPrice(double normalPrice) &#123;<span class="hljs-keyword">return</span> <span class="hljs-number">0.8</span>*normalPrice;&#125;&#125;public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GoldenMemberStrategy</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Strategy</span> </span>&#123;public <span class="hljs-type">GoldenMemberStrategy</span>(<span class="hljs-type">String</span> strategy) &#123;<span class="hljs-keyword">super</span>(strategy);&#125;<span class="hljs-meta">@Override</span>public double getPrice(double normalPrice) &#123;<span class="hljs-keyword">return</span> <span class="hljs-number">0.7</span>*normalPrice;&#125;&#125;</code></pre><p>4.创建策略模式测试类</p><pre><code class="hljs reasonml">public <span class="hljs-keyword">class</span> StrategyTest &#123;public static void main(String<span class="hljs-literal">[]</span> args) &#123;StandardMemberStraegy standar=<span class="hljs-keyword">new</span> <span class="hljs-constructor">StandardMemberStraegy(<span class="hljs-string">&quot;Standar&quot;</span>)</span>;SilverMemberStrategy silver=<span class="hljs-keyword">new</span> <span class="hljs-constructor">SilverMemberStrategy(<span class="hljs-string">&quot;Silver&quot;</span>)</span>;GoldenMemberStrategy golden=<span class="hljs-keyword">new</span> <span class="hljs-constructor">GoldenMemberStrategy(<span class="hljs-string">&quot;Golden&quot;</span>)</span>;Context context=<span class="hljs-keyword">new</span> <span class="hljs-constructor">Context()</span>;context.set<span class="hljs-constructor">Strategy(<span class="hljs-params">standar</span>)</span>;context.execute<span class="hljs-constructor">Price(100)</span>;context.set<span class="hljs-constructor">Strategy(<span class="hljs-params">silver</span>)</span>;context.execute<span class="hljs-constructor">Price(100)</span>;context.set<span class="hljs-constructor">Strategy(<span class="hljs-params">golden</span>)</span>;context.execute<span class="hljs-constructor">Price(100)</span>;&#125;&#125;</code></pre><p>运行结果：</p><blockquote><p>StandarMember，折后价：90.0<br>SilverMember，折后价：80.0<br>GoldenMember，折后价：70.0</p></blockquote><h3 id="好库推荐"><a href="#好库推荐" class="headerlink" title="好库推荐"></a>好库推荐</h3><p>给大家推荐一下<a href="https://github.com/zhpanvip/BannerViewPager">BannerViewPager</a>。这是一个基于ViewPager实现的具有强大功能的无限轮播库。通过<a href="https://github.com/zhpanvip/BannerViewPager">BannerViewPager</a>可以实现腾讯视频、QQ音乐、酷狗音乐、支付宝、天猫、淘宝、优酷视频、喜马拉雅、网易云音乐、哔哩哔哩等APP的Banner样式以及指示器样式。</p><p>欢迎大家到github关注<a href="https://github.com/zhpanvip/BannerViewPager">BannerViewPager</a>！</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>浅析Java设计模式（二）</title>
    <link href="/2016/07/25/%E6%B5%85%E6%9E%90Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <url>/2016/07/25/%E6%B5%85%E6%9E%90Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>上篇文章我们学习了几种创建型模式 的设计模式，那么本篇文章就继续来学习一下结构型模式的几个常用设计模式。</p><h2 id="一、代理模式（Proxy-Pattern）"><a href="#一、代理模式（Proxy-Pattern）" class="headerlink" title="一、代理模式（Proxy Pattern）"></a>一、代理模式（Proxy Pattern）</h2><p>代理模式即为其它对象提供一种代理控制对这个对象的访问。在代理模式中，一个类代表另一个类的功能。这种类型的设计模式属于结构型模式。在代理模式中，我们创建具有现有对象的对象，以便向外界提供功能接口。代理模式的机构图如下：<br><img src="https://raw.githubusercontent.com/zhpanvip/Resource/master/image/0201.png" alt="静态代理"></p><p>Subject类中定义一个抽象request()方法,RealSubject和Proxy共用接口，这样就在任何使用RealSubject的地方都可以使用Proxy。<br>1.Subject类代码如下：</p><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Subject</span> &#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">request</span>(<span class="hljs-params"></span>)</span>;&#125;</code></pre><p>2.RealSubject集成Subject类</p><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RealSubject</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Subject</span></span>&#123;<span class="hljs-meta">@Override</span>public void request() &#123;<span class="hljs-type">System</span>.out.println(<span class="hljs-string">&quot;Real Request&quot;</span>);&#125;&#125;</code></pre><p>3.Proxy实现Subject类</p><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Proxy</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Subject</span> </span>&#123;<span class="hljs-keyword">private</span> <span class="hljs-type">RealSubject</span> mRealSubject;<span class="hljs-meta">@Override</span>public void request() &#123;<span class="hljs-keyword">if</span>(mRealSubject==<span class="hljs-literal">null</span>) &#123;mRealSubject=<span class="hljs-keyword">new</span> <span class="hljs-type">RealSubject</span>();&#125;mRealSubject.request();&#125;&#125;</code></pre><p>4.代理测试类</p><pre><code class="hljs routeros">public class ProxyTest &#123;public static void main(String[] args) &#123;<span class="hljs-built_in">Proxy </span><span class="hljs-attribute">proxy</span>=new Proxy();proxy.request();&#125;&#125;</code></pre><p>输出结果：</p><blockquote><p>Real Request</p></blockquote><h2 id="二、装饰模式（Decorator-Pattern）"><a href="#二、装饰模式（Decorator-Pattern）" class="headerlink" title="二、装饰模式（Decorator Pattern）"></a>二、装饰模式（Decorator Pattern）</h2><p>装饰模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装。</p><p>我们将创建一个 Shape 接口和实现了 Shape 接口的实体类。然后我们创建一个实现了 Shape 接口的抽象装饰类 ShapeDecorator，并把 Shape 对象作为它的实例变量。RedShapeDecorator 是实现了 ShapeDecorator 的实体类。DecoratorPatternDemo，我们的演示类使用 RedShapeDecorator 来装饰 Shape 对象。UML图如下：<br><img src="https://raw.githubusercontent.com/zhpanvip/Resource/master/image/0202.jfif" alt="装饰模式"></p><p>1.创建Shape接口</p><pre><code class="hljs routeros">public<span class="hljs-built_in"> interface </span>Shape &#123;void draw();&#125;</code></pre><p>2.创建Circle类和Rectangle类并实现Shape接口</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Circle</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Shape</span> </span>&#123;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> </span>&#123;System.out.println(<span class="hljs-string">&quot;Draw Circle&quot;</span>);&#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rectangle</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Shape</span> </span>&#123;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> </span>&#123;System.out.println(<span class="hljs-string">&quot;Draw Rectangle&quot;</span>);&#125;&#125;</code></pre><p>3.创建实现了 Shape 接口的抽象装饰类</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShapeDecorator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Shape</span> </span>&#123;<span class="hljs-keyword">protected</span> Shape decoratedShape;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ShapeDecorator</span><span class="hljs-params">(Shape decoratedShape)</span> </span>&#123;<span class="hljs-keyword">this</span>.decoratedShape=decoratedShape;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> </span>&#123;decoratedShape.draw();&#125;&#125;</code></pre><p>4.创建RedShapeDecorator装饰类并继承ShapeDecorator</p><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedShapeDecorator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ShapeDecorator</span>  </span>&#123;public <span class="hljs-type">RedShapeDecorator</span>(<span class="hljs-type">Shape</span> decoratedShape) &#123;<span class="hljs-keyword">super</span>(decoratedShape);&#125;<span class="hljs-meta">@Override</span>public void draw() &#123;decoratedShape.draw();setRedBorder(decoratedShape);&#125;<span class="hljs-keyword">private</span> void setRedBorder(<span class="hljs-type">Shape</span> decoratedShape) &#123;<span class="hljs-type">System</span>.out.println(<span class="hljs-string">&quot;Red Border Corlor&quot;</span>);&#125;&#125;</code></pre><p>5.装饰模式测试类</p><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> DecoratorTest &#123;<span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) &#123;Shape <span class="hljs-type">circle</span>=<span class="hljs-built_in">new</span> Circle();Shape redCircle=<span class="hljs-built_in">new</span> RedShapeDecorator(<span class="hljs-built_in">new</span> Circle());Shape redRectangle=<span class="hljs-built_in">new</span> RedShapeDecorator(<span class="hljs-built_in">new</span> Rectangle());<span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;Circle with normal border&quot;);<span class="hljs-type">circle</span>.draw();<span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;Circle whit red border&quot;);redCircle.draw();<span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;Rectangle with red border&quot;);redRectangle.draw();&#125;&#125;</code></pre><p>输出结果：</p><blockquote><p>Circle with normal border<br>Draw Circle<br>Circle whit red border<br>Draw Circle<br>Red Border Corlor<br>Rectangle with red border<br>Draw Rectangle<br>Red Border Corlor</p></blockquote><h2 id="三、适配器模式"><a href="#三、适配器模式" class="headerlink" title="三、适配器模式"></a>三、适配器模式</h2><p>适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁。这种类型的设计模式属于结构型模式，它结合了两个独立接口的功能。通常来说，在软件开发中，系统的数据和行为都正确，但接口不符合时，我们应该考虑用适配器，目的是使控制范围之外的一个原有对象与某个接口匹配。</p><p>现在假定在我们的应用中使用了两种地图，分别是Google地图和Baidu地图。这两个地图接口对我们而言是隐藏不可修改的，但是由于我们应用的特殊需求，可能会使用两个地图获取位置。那么此时我们就可以用适配器模式来实现。<br>1.当前我们拥有百度地图和Google地图两个接口均可以获取地理位置。</p><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaiduMap</span> &#123;</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">String</span> <span class="hljs-title">getBaiduLocation</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;this is baidu location&quot;</span>;&#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GoogleMap</span> &#123;</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">String</span> <span class="hljs-title">getGoogleLocation</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;this is Google location&quot;</span>;&#125;&#125;</code></pre><p>2.创建一个Map接口</p><pre><code class="hljs routeros">public<span class="hljs-built_in"> interface </span>Map &#123;String getLocation(String mapType);&#125;</code></pre><p>3.创建LocationAdapter实现Map接口</p><pre><code class="hljs haxe"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LocationAdapter</span> <span class="hljs-keyword"><span class="hljs-keyword">implements</span> <span class="hljs-type">Map</span></span> </span>&#123;@Override<span class="hljs-keyword">public</span> <span class="hljs-keyword">String</span> getLocation(<span class="hljs-keyword">String</span> mapType) &#123;<span class="hljs-keyword">String</span> location=<span class="hljs-string">&quot;&quot;</span>;<span class="hljs-keyword">switch</span>(mapType) &#123;<span class="hljs-keyword">case</span> <span class="hljs-string">&quot;Baidu&quot;</span>:<span class="hljs-type"></span><span class="hljs-type">location</span>=<span class="hljs-keyword">new</span> <span class="hljs-type">BaiduMap</span>().getBaiduLocation();<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-string">&quot;Google&quot;</span>:<span class="hljs-type"></span><span class="hljs-type">location</span>=<span class="hljs-keyword">new</span> <span class="hljs-type">GoogleMap</span>().getGoogleLocation();<span class="hljs-keyword">break</span>;&#125;<span class="hljs-keyword">return</span> location;&#125;&#125;</code></pre><p>3.测试适配器模式</p><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AdapterTest</span> &#123;</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;LocationAdapter adapter=<span class="hljs-keyword">new</span> LocationAdapter();System.out.<span class="hljs-built_in">println</span>(adapter.getLocation(<span class="hljs-string">&quot;Baidu&quot;</span>));System.out.<span class="hljs-built_in">println</span>(adapter.getLocation(<span class="hljs-string">&quot;Google&quot;</span>));&#125;&#125;</code></pre><p>输出结果：</p><blockquote><p>this is baidu location<br>this is Google location</p></blockquote><h3 id="好库推荐"><a href="#好库推荐" class="headerlink" title="好库推荐"></a>好库推荐</h3><p>给大家推荐一下<a href="https://github.com/zhpanvip/BannerViewPager">BannerViewPager</a>。这是一个基于ViewPager实现的具有强大功能的无限轮播库。通过<a href="https://github.com/zhpanvip/BannerViewPager">BannerViewPager</a>可以实现腾讯视频、QQ音乐、酷狗音乐、支付宝、天猫、淘宝、优酷视频、喜马拉雅、网易云音乐、哔哩哔哩等APP的Banner样式以及指示器样式。</p><p>欢迎大家到github关注<a href="https://github.com/zhpanvip/BannerViewPager">BannerViewPager</a>！</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>浅析Java设计模式（一）</title>
    <link href="/2016/07/24/%E6%B5%85%E6%9E%90Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/2016/07/24/%E6%B5%85%E6%9E%90Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>设计模式可以分为三大类<br><strong>1.创建型模式</strong> 这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。该类设计模式有五种:</p><ul><li>简单工厂模式（Factory Pattern） </li><li>建造者模式（Builder Pattern）</li><li>单例模式（SingletonPattern）    </li><li>原型模式（Prototype Pattern）</li><li>抽象工厂模式（Abstract Factory Pattern） </li></ul><p><strong>2.结构型模式</strong> 这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。该类模式有五种：</p><ul><li>代理模式（Proxy Pattern）</li><li>装饰器模式（Decorator Pattern）  </li><li>适配器模式（Adapter Pattern）</li><li>组合模式（Composite Pattern）   </li><li>桥接模式（Bridge Pattern）  </li><li>外观模式（FacadePattern）   </li><li>过滤器模式（Filter、CriteriaPattern）  </li></ul><p><strong>3.行为型模式</strong>  这些设计模式特别关注对象之间的通信。</p><ul><li>观察者模式（Observer Pattern）</li><li>中介者模式（Mediator Pattern）</li><li>策略模式（Strategy Pattern）</li><li>责任链模式（Chain of Responsibility Pattern）</li><li>命令模式（Command Pattern）</li><li>解释器模式（Interpreter Pattern）</li><li>迭代器模式（Iterator Pattern）</li><li>备忘录模式（Memento Pattern）</li><li>状态模式（State Pattern）</li><li>空对象模式（Null Object Pattern）</li><li>模板模式（Template Pattern）</li><li>访问者模式（Visitor Pattern）<br>《浅析Java设计模式》将分为三篇分别对三类设计模式中比较常用且典型的几种模式做讲解。本篇文章是第一篇将从创建型模式中挑选简单工厂模式、单例模式以及建造者模式来解析。</li></ul><h2 id="一、简单工厂模式"><a href="#一、简单工厂模式" class="headerlink" title="一、简单工厂模式"></a>一、简单工厂模式</h2><p>简单工厂模式就是建立一个工厂类，对实现了同一接口的一些类进行实例的创建。简单工厂模式的实质是由一个工厂类根据传入的参数，动态决定应该创建哪一个产品类（这些产品类继承自一个父类或接口）的实例。<br>简单工厂模式UML<br>我们以画矩形、三角形以及圆为例，对于三种图形，可以抽象出来一个Shape，它们有共同的draw方法。并且让三种图形均实现Shape接口。简单工厂模式UML图如下所示：<br><img src="https://raw.githubusercontent.com/zhpanvip/Resource/master/image/0101.jfif" alt="简单工厂模式"></p><p>1.首先定义Shape接口，接口中有三种图形共有的draw方法：</p><pre><code class="hljs routeros">public<span class="hljs-built_in"> interface </span>Shape &#123;void draw();&#125;</code></pre><p>2.创建三种形状并实现Shape接口：<br>矩形类：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rectangle</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Shape</span> </span>&#123;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> </span>&#123;System.out.println(<span class="hljs-string">&quot;Draw a Rectangle&quot;</span>);&#125;&#125;</code></pre><p>三角形：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Triangle</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Shape</span> </span>&#123;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> </span>&#123;System.out.println(<span class="hljs-string">&quot;Draw a Triangle&quot;</span>);&#125;&#125;</code></pre><p>圆形：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Circle</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Shape</span> </span>&#123;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> </span>&#123;System.out.println(<span class="hljs-string">&quot;Draw a circle&quot;</span>);&#125;&#125;</code></pre><p>3.创建工厂类，并根据参数信息画出对应的图形：</p><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ShapFactory</span> &#123; <span class="hljs-comment">//使用 getShape 方法获取形状类型的对象</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> Shape <span class="hljs-title">getShape</span>(<span class="hljs-params">String shapeType</span>)</span>&#123;      <span class="hljs-keyword">if</span>(shapeType == <span class="hljs-literal">null</span>)&#123;         <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;      &#125;              <span class="hljs-keyword">if</span>(shapeType.<span class="hljs-keyword">equals</span>(<span class="hljs-string">&quot;Circle&quot;</span>))&#123;         <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Circle();      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(shapeType.<span class="hljs-keyword">equals</span>(<span class="hljs-string">&quot;Rectangle&quot;</span>))&#123;         <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Rectangle();      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(shapeType.<span class="hljs-keyword">equals</span>(<span class="hljs-string">&quot;Triangle&quot;</span>))&#123;         <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Triangle();      &#125;      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;   &#125;&#125;</code></pre><p>4.接下来，我们创建一个测试类：</p><pre><code class="hljs mipsasm">public class FactoryTest &#123;public static void main(String[] args) &#123;<span class="hljs-keyword">ShapFactory </span><span class="hljs-keyword">shapFactory </span>= new <span class="hljs-keyword">ShapFactory();</span><span class="hljs-keyword"></span><span class="hljs-keyword"></span><span class="hljs-keyword">Shape </span><span class="hljs-keyword">shapeCircle </span>= <span class="hljs-keyword">shapFactory.getShape(&quot;Circle&quot;);</span><span class="hljs-keyword"></span><span class="hljs-keyword">shapeCircle.draw();</span><span class="hljs-keyword"></span><span class="hljs-keyword"></span><span class="hljs-keyword">Shape </span><span class="hljs-keyword">shapeRectangle </span>= <span class="hljs-keyword">shapFactory.getShape(&quot;Rectangle&quot;);</span><span class="hljs-keyword"></span><span class="hljs-keyword">shapeRectangle.draw();</span><span class="hljs-keyword"></span><span class="hljs-keyword"></span><span class="hljs-keyword">Shape </span><span class="hljs-keyword">shapeTriangle </span>= <span class="hljs-keyword">shapFactory.getShape(&quot;Triangle&quot;);</span><span class="hljs-keyword"></span><span class="hljs-keyword">shapeTriangle.draw();</span><span class="hljs-keyword"></span><span class="hljs-keyword"></span><span class="hljs-keyword">Shape </span><span class="hljs-keyword">shapeSquare </span>= <span class="hljs-keyword">shapFactory.getShape(&quot;Square&quot;);</span><span class="hljs-keyword"></span>if (<span class="hljs-keyword">shapeSquare </span>== null) &#123;System.out.println(<span class="hljs-string">&quot;shapeSquare is null!&quot;</span>);&#125; else &#123;<span class="hljs-keyword">shapeSquare.draw();</span><span class="hljs-keyword"></span>&#125;&#125;&#125;</code></pre><p> 输出结果： </p><blockquote><p>Draw a circle<br>Draw a Rectangle<br> Draw a Triangle<br>shapeSquare isnull!</p></blockquote><h2 id="二、单例模式"><a href="#二、单例模式" class="headerlink" title="二、单例模式"></a>二、单例模式</h2><p>单例模式（Singleton Pattern），保证一个类仅有一个实例，并提供一个访问它的全局访问方法。单例模式需要我们把显示定义的构造方法私有化，不允许外部对它实例化。单例模式的结构图如下所示。</p><p><img src="https://raw.githubusercontent.com/zhpanvip/Resource/master/image/0102.png" alt="单例模式"></p><p><strong>1.一个简单的单例模式实现。</strong></p><pre><code class="hljs routeros">public class Singleton &#123;private static Singleton instance;private Singleton() &#123;&#125;public static Singleton getInstance() &#123;<span class="hljs-keyword">if</span>(<span class="hljs-attribute">instance</span>==null) &#123;<span class="hljs-built_in">instance </span>= new Singleton();&#125;return instance;&#125;public void openWindow() &#123;System.out.println(<span class="hljs-string">&quot;Open a Window&quot;</span>);&#125;&#125;</code></pre><p>上面就是一个最简单的单例模式，我们来写一个测试类：</p><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingleTest</span> &#123;</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;Singleton single1=Singleton.getInstance();Singleton single2=Singleton.getInstance();System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;single1.equals(single2)---&quot;</span>+single1.equals(single2));&#125;&#125;</code></pre><p>输出结果：</p><blockquote><p>single1.equals(single2)—true</p></blockquote><p>从输出结果可以看出两次调用getInstance得到的是同一个Singleton 实例。</p><p>上面仅仅是实现单例的一种方式，在调用时实例化对象我们称之为懒汉式，上面的代码有一个弊端，就是不支持多线程调用，在多线程调用的情况下可能会被实例化出多个实例，因此，严格来讲它并不是真正的单例模式！接下来我们继续来看几种单例模式的实现方法，并且来保证它的线程安全。<br><strong>2.线程安全的懒汉式单例模式</strong></p><pre><code class="hljs routeros">public class Singleton &#123;private static Singleton instance;private Singleton() &#123;&#125;public static synchronized  Singleton getInstance() &#123;<span class="hljs-keyword">if</span>(<span class="hljs-attribute">instance</span>==null) &#123;<span class="hljs-built_in">instance </span>= new Singleton();&#125;return instance;&#125;public void openWindow() &#123;System.out.println(<span class="hljs-string">&quot;Open a Window&quot;</span>);&#125;&#125;</code></pre><p>如上代码，我们仅仅在getInstance方法上加了一个synchronized 锁，从而保证了线程的安全。但是我们又不得不考虑一个问题，即每次调用getInstance的时候都会加锁，这种做法势必影响了程序的性能，所以还有待改良。<br><strong>3.双重锁定的单例模式</strong></p><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> &#123;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span>(<span class="hljs-params"></span>)</span> &#123;&#125;<span class="hljs-comment">//双重校验锁 线程安全  不用让线程每次都加锁，只有在未实例化时加锁，提高性能。</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton2 <span class="hljs-title">getInstance3</span>(<span class="hljs-params"></span>)</span> &#123;<span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<span class="hljs-comment">//先判断实例是否存在，不存在再加锁处理</span>synchronized (Singleton2.class) &#123;<span class="hljs-keyword">if</span>(instance==<span class="hljs-literal">null</span>) &#123;instance=<span class="hljs-keyword">new</span> Singleton2();&#125;&#125;&#125;<span class="hljs-keyword">return</span> instance;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">openWindow</span>(<span class="hljs-params"></span>)</span> &#123;System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;Open a Window&quot;</span>);&#125;&#125;</code></pre><p>上述代码中为什么两次判断instance是否为null？假如instance为null并且同时又两个线程调用getInstance()方法，它们将同时通过第一重instance==null的判断。然后由于锁机制，这两个线程只能有一个进入，另一个在外排队等候。等到第一个执行完后另一个线程才能进入。而此时如果没有第二重instance是否为空的判断，则第一个线程创建了实例，而第二个线程还是可以继续创建实例。这样没有达到单例的目的。<br><strong>4.饿汉式实现单例模式</strong><br>前三种我们讲解了懒汉式实现单例。那么还有一种在类加载时就创建对象的单例模式的实现方法我们称之为饿汉式。代码如下：</p><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> &#123;</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance=<span class="hljs-keyword">new</span> Singleton();<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> instance;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">openWindow</span><span class="hljs-params">()</span> </span>&#123;System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;Open a Window&quot;</span>);&#125;&#125;</code></pre><p>这种单例模式基于 classloader 机制避免了多线程的同步问题。但因为instance在类加载时就被实例化了，因此存在内存浪费的可能性。</p><h2 id="三、建造者模式"><a href="#三、建造者模式" class="headerlink" title="三、建造者模式"></a>三、建造者模式</h2><p>建造者模式是将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。<br>我们以画卡通人物为例，画一个卡通人物需要完成头、身体、手、腿的绘制。那么，我们就可以抽象出一个IDrawPerson的接口</p><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IDrawPerson</span> &#123; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">drawHead</span>(<span class="hljs-params"></span>)</span>;  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">drawBody</span>(<span class="hljs-params"></span>)</span>;  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">drawHand</span>(<span class="hljs-params"></span>)</span>;  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">drawLeg</span>(<span class="hljs-params"></span>)</span>;  <span class="hljs-function">Person <span class="hljs-title">buildPerson</span>(<span class="hljs-params"></span>)</span>;&#125;</code></pre><p>接下来，我想画一个比较瘦的卡通人物，那么定义PersonThinBuilder并实现IDrawPerson类</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<span class="hljs-keyword">private</span> String head;<span class="hljs-keyword">private</span> String body;<span class="hljs-keyword">private</span> String hand;<span class="hljs-keyword">private</span> String leg;...  <span class="hljs-comment">//省去get、set方法</span>&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PersonThinBuilder</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IDrawPerson</span> </span>&#123;<span class="hljs-keyword">private</span> Person mPerson;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PersonThinBuilder</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">super</span>();mPerson=<span class="hljs-keyword">new</span> Person();&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">drawHead</span><span class="hljs-params">()</span> </span>&#123;mPerson.setHead(<span class="hljs-string">&quot;draw head&quot;</span>);&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">drawBody</span><span class="hljs-params">()</span> </span>&#123;mPerson.setBody(<span class="hljs-string">&quot;draw thin body&quot;</span>);&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">drawHand</span><span class="hljs-params">()</span> </span>&#123;mPerson.setHand(<span class="hljs-string">&quot;draa hand&quot;</span>);&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">drawLeg</span><span class="hljs-params">()</span> </span>&#123;mPerson.setLeg(<span class="hljs-string">&quot;draw leg&quot;</span>);&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> Person <span class="hljs-title">buildPerson</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> mPerson;&#125;&#125;</code></pre><p>同样，如果我想再画一个胖人或者高个子都用类似代码实现这个类就可以了。</p><p>接下来看建造者模式中很重要的一个类，指挥者类，用这个类来控制建造过程或者隔离用户与建造过程的关联。</p><pre><code class="hljs reasonml">public <span class="hljs-keyword">class</span> PersonDirector &#123;public Person <span class="hljs-constructor">CreatePerson(IDrawPerson <span class="hljs-params">buildPerson</span>)</span> &#123;buildPerson.draw<span class="hljs-constructor">Head()</span>;buildPerson.draw<span class="hljs-constructor">Body()</span>;buildPerson.draw<span class="hljs-constructor">Hand()</span>;buildPerson.draw<span class="hljs-constructor">Leg()</span>;return buildPerson.build<span class="hljs-constructor">Person()</span>;&#125;&#125;</code></pre><p>最后来看创建一个建造者模式的测试类：</p><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BuildTest</span> &#123;</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;PersonDirector personDirector=<span class="hljs-keyword">new</span> PersonDirector();Person thinPerson=personDirector.CreatePerson(<span class="hljs-keyword">new</span> PersonThinBuilder());System.out.<span class="hljs-built_in">println</span>(thinPerson.getBody());&#125;&#125;</code></pre><p>输出结果：</p><blockquote><p>draw thin body</p></blockquote><h3 id="好库推荐"><a href="#好库推荐" class="headerlink" title="好库推荐"></a>好库推荐</h3><p>给大家推荐一下<a href="https://github.com/zhpanvip/BannerViewPager">BannerViewPager</a>。这是一个基于ViewPager实现的具有强大功能的无限轮播库。通过<a href="https://github.com/zhpanvip/BannerViewPager">BannerViewPager</a>可以实现腾讯视频、QQ音乐、酷狗音乐、支付宝、天猫、淘宝、优酷视频、喜马拉雅、网易云音乐、哔哩哔哩等APP的Banner样式以及指示器样式。</p><p>欢迎大家到github关注<a href="https://github.com/zhpanvip/BannerViewPager">BannerViewPager</a>！</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
