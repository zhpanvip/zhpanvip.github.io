<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>基于 Android 13 的 Activity 启动流程分析</title>
    <link href="/2023/03/18/51-activity-startup-process/"/>
    <url>/2023/03/18/51-activity-startup-process/</url>
    
    <content type="html"><![CDATA[<p>对于 Android 客户端开发者来说，Activity 是我们再熟悉不过的一个组件了。它是 Android 四大组件之一，是一个用于直接与用户交互的展示型 UI 组件。在开发过程中，启动并创建一个 Activity 流程非常简单，而在系统底层实际上做了大量的工作，之所以使用这么简单，得益于系统底层对于 Activity 的良好封装。本篇内容我们着重来分析一下 Framework 层 Activity 的启动与创建的过程。</p><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>在 《<a href="https://juejin.cn/post/6994057245113729038">不得不说的 Android Binder 机制与 AIDL</a>》这篇文章中我们了解了通过如何通过 Binder 与 AIDL 进行跨进程通信，在另一篇文章 《<a href="https://juejin.cn/post/7110625878320775204">反思 Android 消息机制的设计与实现</a>》深入探讨了 Handler 消息机制的实现原理。这两篇文章，尤其是通过 Binder 与 AIDL 跨进程通信这块内容是理解本篇文章的基础，如果现在还不了解的同学建议先去阅读这两篇文章。</p><p>在平时的开发中，启动一个新的 Activity 只需要在当前 Activity 中调用<code>startActivity</code>方法，并传入一个Intent 即可，例如，从 MainActivity 启动一个 TestActivity 代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Java">Intent intent = <span class="hljs-keyword">new</span> Intent(<span class="hljs-keyword">this</span>, TestActivity.class);<br>        startActivity(intent);<br></code></pre></td></tr></table></figure><p>两行看似简单的代码，实际上经历了与 system_service 进程的数次互相调用，才成功启动了一个 Activity。为方便理解，后文中我们把启动 Activity 的进程称为客户端，把 system_server 进程称为服务端。</p><h2 id="二、客户端的调用流程"><a href="#二、客户端的调用流程" class="headerlink" title="二、客户端的调用流程"></a>二、客户端的调用流程</h2><p>startActivity 的操作是由客户端发起的，因此当前的代码执行在客户端进程中。追进<code>startActivity</code>即可看到如下源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// frameworks/base/core/java/android/app/Activity.java</span><br><br>    ActivityThread mMainThread;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">startActivity</span><span class="hljs-params">(Intent intent)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.startActivity(intent, <span class="hljs-keyword">null</span>);<br>        &#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">startActivity</span><span class="hljs-params">(Intent intent, <span class="hljs-meta">@Nullable</span> Bundle options)</span> </span>&#123;<br>        getAutofillClientController().onStartActivity(intent, mIntent);<br>        <span class="hljs-keyword">if</span> (options != <span class="hljs-keyword">null</span>) &#123;<br>        startActivityForResult(intent, -<span class="hljs-number">1</span>, options);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// Note we want to go through this call for compatibility with</span><br>        <span class="hljs-comment">// applications that may have overridden the method.</span><br>        startActivityForResult(intent, -<span class="hljs-number">1</span>);<br>        &#125;<br>        &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">startActivityForResult</span><span class="hljs-params">(<span class="hljs-meta">@RequiresPermission</span> Intent intent, <span class="hljs-keyword">int</span> requestCode,</span></span><br><span class="hljs-function"><span class="hljs-params"><span class="hljs-meta">@Nullable</span> Bundle options)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (mParent == <span class="hljs-keyword">null</span>) &#123;<br>        options = transferSpringboardActivityOptions(options);<br>        Instrumentation.ActivityResult ar =<br>        mInstrumentation.execStartActivity(<br>        <span class="hljs-keyword">this</span>, mMainThread.getApplicationThread(), mToken, <span class="hljs-keyword">this</span>,<br>        intent, requestCode, options);<br>        <span class="hljs-keyword">if</span> (ar != <span class="hljs-keyword">null</span>) &#123;<br>        mMainThread.sendActivityResult(<br>        mToken, mEmbeddedID, requestCode, ar.getResultCode(),<br>        ar.getResultData());<br>        &#125;<br>        <span class="hljs-comment">// ...</span><br><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// ...</span><br>        &#125;<br>        &#125;<br></code></pre></td></tr></table></figure><p>可以看到，<code>startActivity</code> 方法最终会调用 <code>startActivityForResult</code> 方法，这个方法的核心代码是通过 <code>Instrumentation</code> 调用了 <code>execStartActivity</code>。而 <code>execStartActivity</code> 方法中的第二个参数为 <code>mMainThread.getApplicationThread()</code>，这里的 mMainThread 即为 ActivityThread，通过 ActivityThread 获取到了 ApplicationThread，ApplicationThread 是一个 Binder 类，这个类最终会被传到服务端，在服务端作为客户端的代理来调用客户端的代码，关于这个类后文还会分析。</p><p>继续跟进 Instrumentation 的 execStartActivity 方法，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// frameworks/base/core/java/android/app/Instrumentation.java</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> ActivityResult <span class="hljs-title">execStartActivity</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">        Context who, IBinder contextThread, IBinder token, Activity target,</span></span><br><span class="hljs-function"><span class="hljs-params">        Intent intent, <span class="hljs-keyword">int</span> requestCode, Bundle options)</span> </span>&#123;<br>        IApplicationThread whoThread = (IApplicationThread) contextThread;<br>        Uri referrer = target != <span class="hljs-keyword">null</span> ? target.onProvideReferrer() : <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">if</span> (referrer != <span class="hljs-keyword">null</span>) &#123;<br>        intent.putExtra(Intent.EXTRA_REFERRER, referrer);<br>        &#125;<br><br>        <span class="hljs-comment">// ...</span><br><br>        <span class="hljs-keyword">try</span> &#123;<br>        intent.migrateExtraStreamToClipData(who);<br>        intent.prepareToLeaveProcess(who);<br>        <span class="hljs-comment">// 通过 ActivityTaskManager 获取 Service 来启动 Activity</span><br>        <span class="hljs-keyword">int</span> result = ActivityTaskManager.getService().startActivity(whoThread,<br>        who.getOpPackageName(), who.getAttributionTag(), intent,<br>        intent.resolveTypeIfNeeded(who.getContentResolver()), token,<br>        target != <span class="hljs-keyword">null</span> ? target.mEmbeddedID : <span class="hljs-keyword">null</span>, requestCode, <span class="hljs-number">0</span>, <span class="hljs-keyword">null</span>, options);<br>        notifyStartActivityResult(result, options);<br>        <span class="hljs-comment">// 检查 Activity 的启动结果，例如是否在 AndroidManifest 文件中注册，没有则抛出异常</span><br>        checkStartActivityResult(result, intent);<br>        &#125; <span class="hljs-keyword">catch</span> (RemoteException e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;Failure from system&quot;</span>, e);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br></code></pre></td></tr></table></figure><p>上述方法的核心代码是通过 ActivityTaskManager 获取到了一个 Service，具体是一个什么 Service 这里并不能看出来，我们继续跟进 ActivityTaskManager 的 getService 可以看到如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// frameworks/base/core/java/android/app/ActivityTaskManager.java</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> IActivityTaskManager <span class="hljs-title">getService</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> IActivityTaskManagerSingleton.get();<br>        &#125;<br><br><span class="hljs-meta">@UnsupportedAppUsage(trackingBug = 129726065)</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Singleton&lt;IActivityTaskManager&gt; IActivityTaskManagerSingleton =<br>        <span class="hljs-keyword">new</span> Singleton&lt;IActivityTaskManager&gt;() &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> IActivityTaskManager <span class="hljs-title">create</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">final</span> IBinder b = ServiceManager.getService(Context.ACTIVITY_TASK_SERVICE);<br>        <span class="hljs-keyword">return</span> IActivityTaskManager.Stub.asInterface(b);<br>        &#125;<br>        &#125;;<br></code></pre></td></tr></table></figure><p>这里可以看到 getService 获取到的是一个 IActivityTaskManager，IActivityTaskManager 是什么呢？通过搜索源码，发现它其实是一个 AIDL 类，目录为： <code>frameworks/base/core/java/android/app/IActivityTaskManager.aidl</code>，因此，IActivityTaskManager#startActivity 在这里肯定是一个跨进程的操作，到这里代码就进入了服务端进程，即 system_server 进程。</p><h2 id="三、服务端的调用流程"><a href="#三、服务端的调用流程" class="headerlink" title="三、服务端的调用流程"></a>三、服务端的调用流程</h2><p>经过上一小节的分析，代码已经执行到了 system_server 进程，那在 system_server 进程中调用的是哪个类呢？熟悉 AIDL 的同学应该清楚，在编译完代码后 <code>IActivityTaskManager</code> 这个 AIDL 文件会生成一个 IActivityTaskManager.Stub 类，这个类继承自 Binder, 并且会有一个名为 <code>startActivity</code> 的抽象方法。因此接下来我们需要找到哪个类继承了 IActivityTaskManager.Stub 即可，通过全局搜索我们发现 ActivityTaskManagerService 继承了 IActivityTaskManager.Stub，其部分源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// frameworks/base/services/core/java/com/android/server/wm/ActivityTaskManagerService.java</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ActivityTaskManagerService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">IActivityTaskManager</span>.<span class="hljs-title">Stub</span> </span>&#123;<br>    <span class="hljs-comment">// ...</span><br><br>    <span class="hljs-keyword">private</span> ActivityStartController mActivityStartController;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">startActivity</span><span class="hljs-params">(IApplicationThread caller, String callingPackage,</span></span><br><span class="hljs-function"><span class="hljs-params">            String callingFeatureId, Intent intent, String resolvedType, IBinder resultTo,</span></span><br><span class="hljs-function"><span class="hljs-params">            String resultWho, <span class="hljs-keyword">int</span> requestCode, <span class="hljs-keyword">int</span> startFlags, ProfilerInfo profilerInfo,</span></span><br><span class="hljs-function"><span class="hljs-params">            Bundle bOptions)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> startActivityAsUser(caller, callingPackage, callingFeatureId, intent, resolvedType,<br>                resultTo, resultWho, requestCode, startFlags, profilerInfo, bOptions,<br>                UserHandle.getCallingUserId());<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">startActivityAsUser</span><span class="hljs-params">(IApplicationThread caller, String callingPackage,</span></span><br><span class="hljs-function"><span class="hljs-params">            String callingFeatureId, Intent intent, String resolvedType, IBinder resultTo,</span></span><br><span class="hljs-function"><span class="hljs-params">            String resultWho, <span class="hljs-keyword">int</span> requestCode, <span class="hljs-keyword">int</span> startFlags, ProfilerInfo profilerInfo,</span></span><br><span class="hljs-function"><span class="hljs-params">            Bundle bOptions, <span class="hljs-keyword">int</span> userId)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> startActivityAsUser(caller, callingPackage, callingFeatureId, intent, resolvedType,<br>                resultTo, resultWho, requestCode, startFlags, profilerInfo, bOptions, userId,<br>                <span class="hljs-keyword">true</span> <span class="hljs-comment">/*validateIncomingUser*/</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">startActivityAsUser</span><span class="hljs-params">(IApplicationThread caller, String callingPackage,</span></span><br><span class="hljs-function"><span class="hljs-params">            <span class="hljs-meta">@Nullable</span> String callingFeatureId, Intent intent, String resolvedType,</span></span><br><span class="hljs-function"><span class="hljs-params">            IBinder resultTo, String resultWho, <span class="hljs-keyword">int</span> requestCode, <span class="hljs-keyword">int</span> startFlags,</span></span><br><span class="hljs-function"><span class="hljs-params">            ProfilerInfo profilerInfo, Bundle bOptions, <span class="hljs-keyword">int</span> userId, <span class="hljs-keyword">boolean</span> validateIncomingUser)</span> </span>&#123;<br><br>        <span class="hljs-comment">// ... 省略配置项获取与校验</span><br><br><br>        userId = getActivityStartController().checkTargetUser(userId, validateIncomingUser,<br>                Binder.getCallingPid(), Binder.getCallingUid(), <span class="hljs-string">&quot;startActivityAsUser&quot;</span>);<br><br>        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Switch to user app stacks here.</span><br>        <span class="hljs-keyword">return</span> getActivityStartController().obtainStarter(intent, <span class="hljs-string">&quot;startActivityAsUser&quot;</span>)<br>                .setCaller(caller)<br>                .setCallingPackage(callingPackage)<br>                .setCallingFeatureId(callingFeatureId)<br>                .setResolvedType(resolvedType)<br>                .setResultTo(resultTo)<br>                .setResultWho(resultWho)<br>                .setRequestCode(requestCode)<br>                .setStartFlags(startFlags)<br>                .setProfilerInfo(profilerInfo)<br>                .setActivityOptions(opts)<br>                .setUserId(userId)<br>                .execute();<br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>可以看到，在这个类中 <code>startActivity</code> 最终调用了 <code>startActivityAsUser</code> 方法，这个方法中的代码也比较简单，就是通过 <code>getActivityStartController().obtainStarter</code> 来配置相关参数，并最终执行 <code>execute</code>。</p><p><code>getActivityStartController()</code> 获取到的是一个 ActivityStartController 对象，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-function">ActivityStartController <span class="hljs-title">getActivityStartController</span><span class="hljs-params">()</span> </span>&#123;<br>   <span class="hljs-keyword">return</span> mActivityStartController;<br>   &#125;<br></code></pre></td></tr></table></figure><p>接着调用了 ActivityStartController 的 obtainStarter，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/// ActivityStartController</span><br><span class="hljs-function">ActivityStarter <span class="hljs-title">obtainStarter</span><span class="hljs-params">(Intent intent, String reason)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> mFactory.obtain().setIntent(intent).setReason(reason);<br>        &#125;<br></code></pre></td></tr></table></figure><p>obtainStarter 返回的是一个 ActivityStarter 对象，忽略相关参数的配置，我们直接看 ActivityStarter 的 execute 方法，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// frameworks/base/services/core/java/com/android/server/wm/ActivityStarter.java</span><br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ActivityTaskSupervisor mSupervisor;<br><br>        <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">execute</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>        onExecutionStarted();<br><br>        <span class="hljs-comment">// ... </span><br><br>        <span class="hljs-keyword">int</span> res;<br><span class="hljs-keyword">synchronized</span> (mService.mGlobalLock) &#123;<br>        <span class="hljs-comment">// ...</span><br><br>        res = executeRequest(mRequest);<br><br>        <span class="hljs-comment">// ...</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> getExternalResult(res);<br>        &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>        onExecutionComplete();<br>        &#125;<br>        &#125;<br></code></pre></td></tr></table></figure><p><code>execute</code> 方法又调用了 <code>executeRequest</code> 方法，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// frameworks/base/services/core/java/com/android/server/wm/ActivityStarter.java</span><br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">executeRequest</span><span class="hljs-params">(Request request)</span> </span>&#123;<br><br><span class="hljs-comment">// ... 省略参数初始化及权限校验</span><br><br><span class="hljs-keyword">final</span> ActivityRecord r = <span class="hljs-keyword">new</span> ActivityRecord.Builder(mService)<br>        .setCaller(callerApp)<br>        .setLaunchedFromPid(callingPid)<br>        .setLaunchedFromUid(callingUid)<br>        .setLaunchedFromPackage(callingPackage)<br>        .setLaunchedFromFeature(callingFeatureId)<br>        .setIntent(intent)<br>        .setResolvedType(resolvedType)<br>        .setActivityInfo(aInfo)<br>        .setConfiguration(mService.getGlobalConfiguration())<br>        .setResultTo(resultRecord)<br>        .setResultWho(resultWho)<br>        .setRequestCode(requestCode)<br>        .setComponentSpecified(request.componentSpecified)<br>        .setRootVoiceInteraction(voiceSession != <span class="hljs-keyword">null</span>)<br>        .setActivityOptions(checkedOptions)<br>        .setSourceRecord(sourceRecord)<br>        .build();<br><br>        <span class="hljs-comment">// ...</span><br><br>        mLastStartActivityResult = startActivityUnchecked(r, sourceRecord, voiceSession,<br>        request.voiceInteractor, startFlags, <span class="hljs-keyword">true</span> <span class="hljs-comment">/* doResume */</span>, checkedOptions,<br>        inTask, inTaskFragment, restrictedBgActivity, intentGrants);<br><br>        <span class="hljs-keyword">if</span> (request.outActivity != <span class="hljs-keyword">null</span>) &#123;<br>        request.outActivity[<span class="hljs-number">0</span>] = mLastStartActivityRecord;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> mLastStartActivityResult;<br>        &#125;<br></code></pre></td></tr></table></figure><p>executeRequest 方法中的核心是实例化了 ActivityRecord，并调用 startActivityUnchecked，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// frameworks/base/services/core/java/com/android/server/wm/ActivityStarter.java</span><br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">startActivityUnchecked</span><span class="hljs-params">(<span class="hljs-keyword">final</span> ActivityRecord r, ActivityRecord sourceRecord,</span></span><br><span class="hljs-function"><span class="hljs-params">        IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span></span><br><span class="hljs-function"><span class="hljs-params">        <span class="hljs-keyword">int</span> startFlags, <span class="hljs-keyword">boolean</span> doResume, ActivityOptions options, Task inTask,</span></span><br><span class="hljs-function"><span class="hljs-params">        TaskFragment inTaskFragment, <span class="hljs-keyword">boolean</span> restrictedBgActivity,</span></span><br><span class="hljs-function"><span class="hljs-params">        NeededUriGrants intentGrants)</span> </span>&#123;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>        mService.deferWindowLayout();<br>        <span class="hljs-keyword">try</span> &#123;<br>        result = startActivityInner(r, sourceRecord, voiceSession, voiceInteractor,<br>        startFlags, doResume, options, inTask, inTaskFragment, restrictedBgActivity,<br>        intentGrants);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// ...</span><br>        &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>        mService.continueWindowLayout();<br>        &#125;<br>        postStartActivityProcessing(r, result, startedActivityRootTask);<br><br>        <span class="hljs-keyword">return</span> result;<br>        &#125;`java<br><br></code></pre></td></tr></table></figure><p><code>startActivityUnchecked</code> 方法中又调用了 <code>startActivityInner</code>，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// frameworks/base/services/core/java/com/android/server/wm/ActivityStarter.java</span><br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> RootWindowContainer mRootWindowContainer;<br><br>        <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">startActivityInner</span><span class="hljs-params">(<span class="hljs-keyword">final</span> ActivityRecord r, ActivityRecord sourceRecord,</span></span><br><span class="hljs-function"><span class="hljs-params">        IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span></span><br><span class="hljs-function"><span class="hljs-params">        <span class="hljs-keyword">int</span> startFlags, <span class="hljs-keyword">boolean</span> doResume, ActivityOptions options, Task inTask,</span></span><br><span class="hljs-function"><span class="hljs-params">        TaskFragment inTaskFragment, <span class="hljs-keyword">boolean</span> restrictedBgActivity,</span></span><br><span class="hljs-function"><span class="hljs-params">        NeededUriGrants intentGrants)</span> </span>&#123;<br>        setInitialState(r, options, inTask, inTaskFragment, doResume, startFlags, sourceRecord,<br>        voiceSession, voiceInteractor, restrictedBgActivity);<br><br>        <span class="hljs-comment">// 处理 Intent 中携带的 flags</span><br>        computeLaunchingTaskFlags();<br><br>        <span class="hljs-comment">// 获取启动 Activity 的任务栈，这里即获取 MainActivity 所在的任务栈 </span><br>        computeSourceRootTask();<br><br><span class="hljs-comment">// ...</span><br><br><span class="hljs-comment">// 查找可用的任务栈</span><br><span class="hljs-keyword">final</span> Task reusedTask = getReusableTask();<br><br><span class="hljs-comment">// ...</span><br><br><span class="hljs-comment">// 如果 reusedTask 不空，则使用 reusedTask 任务栈，否则寻找目标任务栈</span><br><span class="hljs-keyword">final</span> Task targetTask = reusedTask != <span class="hljs-keyword">null</span> ? reusedTask : computeTargetTask();<br><span class="hljs-comment">// 目标任务栈为空，则标记为使用新任务栈，需要新建任务栈</span><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> newTask = targetTask == <span class="hljs-keyword">null</span>;<br><br>        mTargetTask = targetTask;<br><br>        computeLaunchParams(r, sourceRecord, targetTask);<br><br><br>        <span class="hljs-keyword">if</span> (newTask) &#123;<br><span class="hljs-comment">// 创建一个新的任务栈</span><br><span class="hljs-keyword">final</span> Task taskToAffiliate = (mLaunchTaskBehind &amp;&amp; mSourceRecord != <span class="hljs-keyword">null</span>)<br>        ? mSourceRecord.getTask() : <span class="hljs-keyword">null</span>;<br>        <span class="hljs-comment">// 将 Activity 放入新建的任务栈        </span><br>        setNewTask(taskToAffiliate);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mAddingToTask) &#123;<br>        <span class="hljs-comment">// 加入已有的任务栈</span><br>        addOrReparentStartingActivity(targetTask, <span class="hljs-string">&quot;adding to task&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// ...</span><br><br>        <span class="hljs-keyword">if</span> (mDoResume) &#123;<br>        <span class="hljs-comment">// ...</span><br>        mRootWindowContainer.resumeFocusedTasksTopActivities(<br>        mTargetRootTask, mStartActivity, mOptions, mTransientLaunch);<br>        &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> START_SUCCESS;<br>        &#125;<br><br></code></pre></td></tr></table></figure><p>startActivityInner 方法中的代码比较复杂。经过了简化处理后，可以看到这个方法里主要是处理任务栈相关的逻辑，如果找到可用的任务栈则直接使用这个任务栈，如果没有找到，则新建一个任务栈。 在完成任务栈的处理之后通过<code>mRootWindowContainer.resumeFocusedTasksTopActivities</code>继续 Activity 的启动流程，这里的 mRootWindowContainer 是 RootWindowContainer 的实例，resumeFocusedTasksTopActivities 代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// frameworks/base/services/core/java/com/android/server/wm/RootWindowContainer.java</span><br><br> <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">resumeFocusedTasksTopActivities</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">            Task targetRootTask, ActivityRecord target, ActivityOptions targetOptions,</span></span><br><span class="hljs-function"><span class="hljs-params">            <span class="hljs-keyword">boolean</span> deferPause)</span> </span>&#123;<br>        <span class="hljs-comment">// ...</span><br>        <br>        <span class="hljs-keyword">boolean</span> result = <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">if</span> (targetRootTask != <span class="hljs-keyword">null</span> &amp;&amp; (targetRootTask.isTopRootTaskInDisplayArea()<br>                || getTopDisplayFocusedRootTask() == targetRootTask)) &#123;<br>            result = targetRootTask.resumeTopActivityUncheckedLocked(target, targetOptions,deferPause);<br>        &#125;<br>        <br>        <span class="hljs-comment">// ...</span><br><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br></code></pre></td></tr></table></figure><p>这个方法中将启动相关的代码交给了 Task 的 <code>resumeTopActivityUncheckedLocked</code> 方法。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java">frameworks/base/services/core/java/com/android/server/wm/Task.java<br><br><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">resumeTopActivityUncheckedLocked</span><span class="hljs-params">(ActivityRecord prev, ActivityOptions options,</span></span><br><span class="hljs-function"><span class="hljs-params">            <span class="hljs-keyword">boolean</span> deferPause)</span> </span>&#123;<br>        <span class="hljs-comment">// ...</span><br><br>        <span class="hljs-keyword">boolean</span> someActivityResumed = <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// Protect against recursion.</span><br>            mInResumeTopActivity = <span class="hljs-keyword">true</span>;<br><br>            <span class="hljs-keyword">if</span> (isLeafTask()) &#123;<br>                <span class="hljs-keyword">if</span> (isFocusableAndVisible()) &#123;<br>                    someActivityResumed = resumeTopActivityInnerLocked(prev, options, deferPause);<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                       <span class="hljs-comment">// ...</span><br>                   &#125;<br>            &#125;<br><br>        <span class="hljs-comment">// ...</span><br><br>        <span class="hljs-keyword">return</span> someActivityResumed;<br>    &#125;<br>    <br>    <br><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">resumeTopActivityUncheckedLocked</span><span class="hljs-params">(ActivityRecord prev, ActivityOptions options)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> resumeTopActivityUncheckedLocked(prev, options, <span class="hljs-keyword">false</span> <span class="hljs-comment">/* skipPause */</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@GuardedBy(&quot;mService&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">resumeTopActivityInnerLocked</span><span class="hljs-params">(ActivityRecord prev, ActivityOptions options,</span></span><br><span class="hljs-function"><span class="hljs-params">            <span class="hljs-keyword">boolean</span> deferPause)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!mAtmService.isBooting() &amp;&amp; !mAtmService.isBooted()) &#123;<br>            <span class="hljs-comment">// Not ready yet!</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>        <span class="hljs-comment">// 任务栈栈顶正在运行的 Activity </span><br>        <span class="hljs-keyword">final</span> ActivityRecord topActivity = topRunningActivity(<span class="hljs-keyword">true</span> <span class="hljs-comment">/* focusableOnly */</span>);<br>        <span class="hljs-keyword">if</span> (topActivity == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">// 空任务栈 There are no activities left in this task, let&#x27;s look somewhere else.</span><br>            <span class="hljs-keyword">return</span> resumeNextFocusableActivityWhenRootTaskIsEmpty(prev, options);<br>        &#125;<br><br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span>[] resumed = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">final</span> TaskFragment topFragment = topActivity.getTaskFragment();<br>        resumed[<span class="hljs-number">0</span>] = topFragment.resumeTopActivity(prev, options, deferPause);<br>        <span class="hljs-comment">// ...</span><br>        <span class="hljs-keyword">return</span> resumed[<span class="hljs-number">0</span>];<br>    &#125;<br>    <br></code></pre></td></tr></table></figure><p>在 Task 的 resumeTopActivityUncheckedLocked 方法中进而又调用了resumeTopActivityUncheckedLocked，在 resumeTopActivityInnerLocked 中通过 TaskFragment 调用了 resumeTopActivity，接着来看 TaskFragment 中的实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs java">frameworks/base/services/core/java/com/android/server/wm/TaskFragment.java<br><br><span class="hljs-keyword">final</span> ActivityTaskSupervisor mTaskSupervisor;<br><br><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">resumeTopActivity</span><span class="hljs-params">(ActivityRecord prev, ActivityOptions options,</span></span><br><span class="hljs-function"><span class="hljs-params">            <span class="hljs-keyword">boolean</span> deferPause)</span> </span>&#123;<br>        ActivityRecord next = topRunningActivity(<span class="hljs-keyword">true</span> <span class="hljs-comment">/* focusableOnly */</span>);<br>         <span class="hljs-comment">// ...</span><br>         <br>         <span class="hljs-keyword">if</span> (mResumedActivity != <span class="hljs-keyword">null</span>) &#123;<br>             <span class="hljs-comment">// 暂停栈顶的Activity</span><br>            pausing |= startPausing(mTaskSupervisor.mUserLeaving, <span class="hljs-keyword">false</span> <span class="hljs-comment">/* uiSleeping */</span>, next, <span class="hljs-string">&quot;resumeTopActivity&quot;</span>);<br>        &#125;<br>         <br>        <span class="hljs-comment">// ... </span><br>           <br>        <span class="hljs-comment">// 要启动的 Activity 已存在，且不需要重新创建，例如设置了 singleTask 或 singleTop启动模式</span><br>        <span class="hljs-keyword">if</span> (next.attachedToProcess()) &#123;<br>            <span class="hljs-comment">// ...</span><br><br>            ActivityRecord lastResumedActivity =<br>                    lastFocusedRootTask == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">null</span><br>                            : lastFocusedRootTask.getTopResumedActivity();<br>            <span class="hljs-keyword">final</span> ActivityRecord.State lastState = next.getState();<br><br>            mAtmService.updateCpuStats();<br><br>            next.setState(RESUMED, <span class="hljs-string">&quot;resumeTopActivity&quot;</span>);<br><br>            <span class="hljs-comment">// Have the window manager re-evaluate the orientation of</span><br>            <span class="hljs-comment">// the screen based on the new activity order.</span><br>            <span class="hljs-keyword">boolean</span> notUpdated = <span class="hljs-keyword">true</span>;<br><br>            <span class="hljs-comment">// ...</span><br><br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 开启一个事务</span><br>                <span class="hljs-keyword">final</span> ClientTransaction transaction =<br>                        ClientTransaction.obtain(next.app.getThread(), next.token);<br>                 <span class="hljs-comment">// ...</span><br><br>                <span class="hljs-keyword">if</span> (next.newIntents != <span class="hljs-keyword">null</span>) &#123;<br>                    <span class="hljs-comment">// 添加 onNewIntent 的 callback ，最终会在APP端执行 onNewIntent()</span><br>                    transaction.addCallback(<br>                            NewIntentItem.obtain(next.newIntents, <span class="hljs-keyword">true</span> <span class="hljs-comment">/* resume */</span>));<br>                &#125;<br><br>                <span class="hljs-comment">// ...</span><br>               <br>                <span class="hljs-comment">// 设置 Activity 最终的生命周期状态为 Resume</span><br>                transaction.setLifecycleStateRequest(<br>                        ResumeActivityItem.obtain(next.app.getReportedProcState(),<br>                                dc.isNextTransitionForward()));<br>                <span class="hljs-comment">// Flag1：开始执行事务                </span><br>                mAtmService.getLifecycleManager().scheduleTransaction(transaction);<br><br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                <span class="hljs-comment">// ...</span><br>                <br>                <span class="hljs-comment">// Resume 异常，重新启动</span><br>                mTaskSupervisor.startSpecificActivity(next, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>);<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125;<br><br>           <span class="hljs-comment">// ...</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// ...</span><br>            <br>            <span class="hljs-comment">// 启动 Activity</span><br>            mTaskSupervisor.startSpecificActivity(next, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">true</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p>resumeTopActivity 方法中主要有两部分内容。</p><ul><li>next.attachedToProcess() 为 true，即要启动的这个 Activity 已经存在，并且设置了像“singleInstance” 的启动模式，无需重新创建 Activity 的情况下，则先通过 ClientTransaction 添加了一个 NewIntentItem 的 callback，接下来通过 setLifecycleStateRequest 设置了一个 ResumeActivityItem 对象。</li><li>next.attachedToProcess() 为 false ，则继续执行 Activity 的启动流程</li></ul><p>第一部分中的 ClientTransaction 是什么？ scheduleTransaction 又是做了什么？这里先不做探讨，留一个Flag，后边再来分析。</p><p>接着继续看主线流程，在 <code>next.attachedToProcess()</code> 返回 false 之后，通过 ActivityTaskSupervisor 调用了 <code>startSpecificActivity</code>，这里是 Activity 正常启动的流程，查看 <code>startSpecificActivity</code> 源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs java">frameworks/base/services/core/java/com/android/server/wm/ActivityTaskSupervisor.java<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">startSpecificActivity</span><span class="hljs-params">(ActivityRecord r, <span class="hljs-keyword">boolean</span> andResume, <span class="hljs-keyword">boolean</span> checkConfig)</span> </span>&#123;<br>        <span class="hljs-comment">// Is this activity&#x27;s application already running?</span><br>        <span class="hljs-keyword">final</span> WindowProcessController wpc =<br>                mService.getProcessController(r.processName, r.info.applicationInfo.uid);<br><br>        <span class="hljs-keyword">boolean</span> knownToBeDead = <span class="hljs-keyword">false</span>;<br>        <br>        <span class="hljs-keyword">if</span> (wpc != <span class="hljs-keyword">null</span> &amp;&amp; wpc.hasThread()) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                realStartActivityLocked(r, wpc, andResume, checkConfig);<br>                <span class="hljs-keyword">return</span>;<br>            &#125; <span class="hljs-keyword">catch</span> (RemoteException e) &#123;<br>               <span class="hljs-comment">// ...</span><br>            &#125;<br><br>            <span class="hljs-comment">// ...</span><br>        &#125;<br><br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>    <br>   <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">realStartActivityLocked</span><span class="hljs-params">(ActivityRecord r, WindowProcessController proc,</span></span><br><span class="hljs-function"><span class="hljs-params">            <span class="hljs-keyword">boolean</span> andResume, <span class="hljs-keyword">boolean</span> checkConfig)</span> <span class="hljs-keyword">throws</span> RemoteException </span>&#123;<br><br>        <span class="hljs-comment">// ...</span><br><br>        <span class="hljs-keyword">final</span> Task task = r.getTask();<br>        <span class="hljs-keyword">final</span> Task rootTask = task.getRootTask();<br><br>        <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// ...</span><br><br>                <span class="hljs-comment">// 创建启动 Activity 的事务</span><br>                <span class="hljs-keyword">final</span> ClientTransaction clientTransaction = ClientTransaction.obtain(<br>                        proc.getThread(), r.token);<br><br>                <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> isTransitionForward = r.isTransitionForward();<br>                <span class="hljs-keyword">final</span> IBinder fragmentToken = r.getTaskFragment().getFragmentToken();<br>                <br>                <span class="hljs-comment">// 添加启动 Activity 的 callback，执行launchActivity</span><br>                clientTransaction.addCallback(LaunchActivityItem.obtain(<span class="hljs-keyword">new</span> Intent(r.intent),<br>                        System.identityHashCode(r), r.info,<br>                        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Have this take the merged configuration instead of separate global</span><br>                        <span class="hljs-comment">// and override configs.</span><br>                        mergedConfiguration.getGlobalConfiguration(),<br>                        mergedConfiguration.getOverrideConfiguration(), r.compat,<br>                        r.getFilteredReferrer(r.launchedFromPackage), task.voiceInteractor,<br>                        proc.getReportedProcState(), r.getSavedState(), r.getPersistentSavedState(),<br>                        results, newIntents, r.takeOptions(), isTransitionForward,<br>                        proc.createProfilerInfoIfNeeded(), r.assistToken, activityClientController,<br>                        r.shareableActivityToken, r.getLaunchedFromBubble(), fragmentToken));<br><br>                <span class="hljs-comment">// Activity 启动后最终的生命周期状态</span><br>                <span class="hljs-keyword">final</span> ActivityLifecycleItem lifecycleItem;<br>                <span class="hljs-keyword">if</span> (andResume) &#123;<br>                    <span class="hljs-comment">// 将最终生命周期设置为 Resume 状态</span><br>                    lifecycleItem = ResumeActivityItem.obtain(isTransitionForward);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// 将最终生命周期设置为 Pause 状态</span><br>                    lifecycleItem = PauseActivityItem.obtain();<br>                &#125;<br>                <span class="hljs-comment">// 设置 Activity 启动后最终的生命周期状态</span><br>                clientTransaction.setLifecycleStateRequest(lifecycleItem);<br><br>                <span class="hljs-comment">// 开启事务</span><br>                mService.getLifecycleManager().scheduleTransaction(clientTransaction);<br><br>               <span class="hljs-comment">// ...</span><br><br>            &#125; <span class="hljs-keyword">catch</span> (RemoteException e) &#123;<br>                <span class="hljs-comment">// ...</span><br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">// ...</span><br>        &#125;<br><br>        <span class="hljs-comment">// ...</span><br><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br> <br></code></pre></td></tr></table></figure><p><code>startSpecificActivity</code> 方法中最核心的逻辑是调用了 <code>realStartActivityLocked</code> ，这个方法中同样是获取了一个 ClientTransaction 实例，并调用了它的 addCallback 方法，与上边不同的是，这里添加了一个 LaunchActivityItem 实例。</p><p>这里与上边 Flag 处的代码逻辑是一样，只是添加的 callback 不同，那 ClientTransaction 是什么？它与 Activity 的启动又有什么关系呢？</p><h4 id="1-ClientTransaction"><a href="#1-ClientTransaction" class="headerlink" title="1. ClientTransaction"></a>1. ClientTransaction</h4><p>ClientTransaction 是包含了一系列要执行的事务项的事务。我们可以通过调用它的 <code>addCallback</code>方法来添加一个事务项，你也可以多次调用来添加多个事务项。addCallback 接收的参数类型为 ClientTransactionItem，而这个 ClientTransactionItem 有多个子类，例如上边已经出现过的 NewIntentItem、LaunchActivityItem 等都是其子类。</p><p>另外可以通过 ClientTransactionItem 的 <code>setLifecycleStateRequest</code> 方法设置 Activity 执行完后最终的生命周期状态，其参数的类型为 ActivityLifecycleItem。ActivityLifecycleItem 也是继承自 ClientTransactionItem。同时，ActivityLifecycleItem 也有多个子类，它的每个子类都对应了 Activity 的一个生命周期事件。</p><p>在完成 callback 与 lifeCycleStateRequest 的设置之后，便通过调用 <code>mService.getLifecycleManager().scheduleTransaction(clientTransaction)</code>方法开启事务项的执行。</p><p>这里的 mService.getLifecycleManager() 获取到的是什么呢？跟踪 ActivityTaskManagerService 源码我们可以找到 getLifecycleManager 的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// frameworks/base/services/core/java/com/android/server/wm/ActivityTaskManagerService.java</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ClientLifecycleManager mLifecycleManager;<br>    <br>    <span class="hljs-function">ClientLifecycleManager <span class="hljs-title">getLifecycleManager</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> mLifecycleManager;<br>    &#125;<br><br></code></pre></td></tr></table></figure><p>可以看到，getLifecycleManager 返回了一个 ClientLifecycleManager 的实例，并调用了 scheduleTransaction 方法，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// frameworks/base/services/core/java/com/android/server/wm/ClientLifecycleManager.java</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">scheduleTransaction</span><span class="hljs-params">(ClientTransaction transaction)</span> <span class="hljs-keyword">throws</span> RemoteException </span>&#123;<br>        <span class="hljs-keyword">final</span> IApplicationThread client = transaction.getClient();<br>        transaction.schedule();<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br><br></code></pre></td></tr></table></figure><p>上述方法的核心代码是调用了 ClientTransaction 的 schedule 方法，schedule 方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// frameworks/base/core/java/android/app/servertransaction/ClientTransaction.java</span><br><br><span class="hljs-keyword">private</span> IApplicationThread mClient;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">schedule</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> RemoteException </span>&#123;<br>        mClient.scheduleTransaction(<span class="hljs-keyword">this</span>);<br>   &#125;<br></code></pre></td></tr></table></figure><p>在 schedule 方法中通过 mClient 调用了 scheduleTransaction，<br>这里的 mClient 即为 IApplicationThread，也就是我们在第二章中提到的客户端的 Binder。这个参数是在实例化 ClientTransaction 时传进来的，IApplicationThread 是一个AIDL 类，那么通过编译后它会生成一个 IApplicationThread.Stub 类，上文中提到的 <strong>ActivityThread#ApplicationThread</strong> 就是继承了IApplicationThread.Stub。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// frameworks/base/core/java/android/app/ActivityThread#ApplicationThread </span><br><br><span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ApplicationThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">IApplicationThread</span>.<span class="hljs-title">Stub</span> </span>&#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>既然我们已经知道了 IApplicationThread 是客户端 Binder 在服务端的代理， 那么这里实际上是就是调用了客户端 ApplicationThread 中的 scheduleTransaction 方法。</p><p>至此，代码最终又回到了客户端的 ApplicationThread 中。但是，关于 ClientTransaction 的分析到这里还未结束。可以看到的是，此时的代码又通过 scheduleTransaction 方法回到了客户端，并且将 ClientTransaction 作为参数传了过去。那么，ClientTransaction 的执行逻辑实际上在客户端中执行的。</p><h2 id="四、再探客户端的调用流程"><a href="#四、再探客户端的调用流程" class="headerlink" title="四、再探客户端的调用流程"></a>四、再探客户端的调用流程</h2><p>通过 Binder IPC，代码的调用流程又回到了客户端，来看 ApplicationThread 中 scheduleTransaction 方法的实现，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// frameworks/base/core/java/android/app/ActivityThread#ApplicationThread</span><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">scheduleTransaction</span><span class="hljs-params">(ClientTransaction transaction)</span> <span class="hljs-keyword">throws</span> RemoteException </span>&#123;<br>        ActivityThread.<span class="hljs-keyword">this</span>.scheduleTransaction(transaction);<br>    &#125;<br></code></pre></td></tr></table></figure><p>这个方法中又调用了 ActivityThread 的 scheduleTransaction 。而 scheduleTransaction 的源码在ActivityThread 的父类 ClientTransactionHandler 中， 如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// frameworks/base/core/java/android/app/ClientTransactionHandler.java</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">scheduleTransaction</span><span class="hljs-params">(ClientTransaction transaction)</span> </span>&#123;<br>        transaction.preExecute(<span class="hljs-keyword">this</span>);<br>        sendMessage(ActivityThread.H.EXECUTE_TRANSACTION, transaction);<br>    &#125;<br></code></pre></td></tr></table></figure><p>这里将 transaction 作为参数调用了 sendMessage 方法。sendMessage 方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs Java"><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sendMessage</span><span class="hljs-params">(<span class="hljs-keyword">int</span> what, Object obj)</span> </span>&#123;<br>    sendMessage(what, obj, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-keyword">false</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendMessage</span><span class="hljs-params">(<span class="hljs-keyword">int</span> what, Object obj, <span class="hljs-keyword">int</span> arg1)</span> </span>&#123;<br>    sendMessage(what, obj, arg1, <span class="hljs-number">0</span>, <span class="hljs-keyword">false</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendMessage</span><span class="hljs-params">(<span class="hljs-keyword">int</span> what, Object obj, <span class="hljs-keyword">int</span> arg1, <span class="hljs-keyword">int</span> arg2)</span> </span>&#123;<br>    sendMessage(what, obj, arg1, arg2, <span class="hljs-keyword">false</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendMessage</span><span class="hljs-params">(<span class="hljs-keyword">int</span> what, Object obj, <span class="hljs-keyword">int</span> arg1, <span class="hljs-keyword">int</span> arg2, <span class="hljs-keyword">boolean</span> async)</span> </span>&#123;<br>    <br>    Message msg = Message.obtain();<br>    msg.what = what;<br>    msg.obj = obj;<br>    msg.arg1 = arg1;<br>    msg.arg2 = arg2;<br>    <span class="hljs-keyword">if</span> (async) &#123;<br>        <span class="hljs-comment">// 设置异步消息，会优先执行</span><br>        msg.setAsynchronous(<span class="hljs-keyword">true</span>);<br>    &#125;<br>    mH.sendMessage(msg);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，这里最终将 ClientTransaction 与 EXECUTE_TRANSACTION 打包成一个 Message ,并且将这个 Message 设置成了异步消息，最终通过 mH 发送了出去，这里的 mH 是一个继承自 Handler 的 <code>H</code> 类，位于 ActivityThread 类的内部。</p><blockquote><p>Message 被设置为异步消息后具有优先执行权，因为 Activity 的启动涉及到 Activity 的创建以及生命周期的调用，所有这里发送出来的 Message 不应该被其他 Message 阻塞，不然肯定会影响到 Activity 的启动，造成卡顿问题。具体分析可以参见 《<a href="https://juejin.cn/post/7110625878320775204">反思 Android 消息机制的设计与实现</a>》 这篇文章。</p></blockquote><p>接下来看一下在 H 类的内部是如何处理这条消息的，我们搜索 <code>EXECUTE_TRANSACTION</code> 可以看到如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// frameworks/base/core/java/android/app/ActivityThread#H</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleMessage</span><span class="hljs-params">(Message msg)</span> </span>&#123;<br>    <span class="hljs-keyword">switch</span> (msg.what) &#123;<br>    <span class="hljs-keyword">case</span> EXECUTE_TRANSACTION:<br>            <span class="hljs-keyword">final</span> ClientTransaction transaction = (ClientTransaction) msg.obj;<br>            mTransactionExecutor.execute(transaction);<br>            <span class="hljs-comment">// ...</span><br>             <span class="hljs-keyword">break</span>;<br>    <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的代码很简单，通过 Message 拿到 ClientTransaction 后，然后通过 TransactionExecutor 的 execute 方法来执行 ClientTransaction。</p><p>在上一章中，我们只是对 ClientTransaction 做了简单的介绍。虽然 ClientTransaction 的实例化是在服务端，但其执行流程却是在客户端。看一下 TransactionExecutor 中 execute 源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// frameworks/base/core/java/android/app/servertransaction/TransactionExecutor.java</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(ClientTransaction transaction)</span> </span>&#123;<br><br>       <span class="hljs-comment">// ...</span><br>        <br>        <span class="hljs-comment">// 执行 callback</span><br>        executeCallbacks(transaction);<br>        <span class="hljs-comment">// 执行 lifecycleState</span><br>        executeLifecycleState(transaction);<br>        <br>        mPendingActions.clear();<br>       <br>    &#125;   <br></code></pre></td></tr></table></figure><p>这个方法里的执行逻辑可以分为两部分：</p><ul><li>通过 executeCallbacks 方法执行所有被添加进来的 ClientTransactionItem</li><li>通过 executeLifecycleState 方法将 Activity 的生命周期执行到指定的状态</li></ul><h3 id="1-executeCallbacks-方法分析"><a href="#1-executeCallbacks-方法分析" class="headerlink" title="1. executeCallbacks 方法分析"></a>1. executeCallbacks 方法分析</h3><p>executeCallbacks 方法中的逻辑比较简单，其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">executeCallbacks</span><span class="hljs-params">(ClientTransaction transaction)</span> </span>&#123;<br>        <span class="hljs-comment">// ...</span><br>        <br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> size = callbacks.size();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; ++i) &#123;<br>            <span class="hljs-comment">// ...</span><br>            <span class="hljs-keyword">final</span> ClientTransactionItem item = callbacks.get(i);<br>            item.execute(mTransactionHandler, token, mPendingActions);<br>            <span class="hljs-comment">// ...</span><br>            <br>            cycleToPath(r, postExecutionState, shouldExcludeLastTransition, transaction);<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>在 executeCallbacks 中遍历了所有的 ClientTransactionItem 并执行了 ClientTransactionItem 的 execute 方法。上一章我们分析了，当 Activity 正常启动时，通过 addCallback 添加的是一个 LaunchActivityItem 的实例。以此为例，这里就会首先执行 LaunchActivityItem 的 execute 方法，进而执行 Activity 的实例化及 onCreate 生命周期的调用。这块源码留作后边再来分析。</p><h3 id="2-ClientTransactionItem"><a href="#2-ClientTransactionItem" class="headerlink" title="2. ClientTransactionItem"></a>2. ClientTransactionItem</h3><p>我们上文提到过 ClientTransactionItem 有多个实现类，这些实现类对应了 Activity 中不同的执行流程。例如在 Activity 启动时如果不需要重新创建 Activity ，则会通过 addCallback 添加了一个 NewIntentItem 来执行 Activity 的 onNewIntennt 方法。而当需要重新创建 Activity 时，则传入的是一个 LaunchActivityItem，用来创建并启动Activity。</p><p>ClientTransactionItem 的所有子类或相关类均在 frameworks/base/core/java/android/app/servertransaction/ 目录下，如下图所示：</p><p><img src="https://raw.githubusercontent.com/zhpanvip/images/master/project/article/framework/5101.webp" alt="image.png"></p><p>上文中提到的 ActivityLifecycleItem 继承自 ClientTransactionItem ，且其子类均为 Activity 生命周相关的实现，例如，StartActivityItem、ResumeActivityItem、DestroyActivityItem 等。显而易见的是，这里将 Activity 的生命周期以及其它相关方法以面向对象的思想封装成了一个个的对象来执行。相比早些年的 Android 版本代码，所有生命周期以及相关方法都通过 Handler 的 sendMessage 的方式发送出来，这种面向对象的思想的逻辑更加清晰，且代码更容易维护。</p><h3 id="3-executeLifecycleState-方法分析"><a href="#3-executeLifecycleState-方法分析" class="headerlink" title="3. executeLifecycleState 方法分析"></a>3. executeLifecycleState 方法分析</h3><p>接着来看 executeCallbacks 中的 executeLifecycleState 方法，前面提到过，这里会将 Activity 执行到指定的生命周期状态。上边的代码中我们看到在 Activity 启动时，setLifecycleStateRequest 设置的是一个 ResumeActivityItem，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">// 设置 Activity 最终的生命周期状态为 Resume</span><br>transaction.setLifecycleStateRequest(<br>       ResumeActivityItem.obtain(next.app.getReportedProcState(),<br>              dc.isNextTransitionForward()));<br></code></pre></td></tr></table></figure><p>设置了 ResumeActivityItem后，接下来的代码会怎么执行呢？来看 <code>executeLifecycleState</code> 方法的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">executeLifecycleState</span><span class="hljs-params">(ClientTransaction transaction)</span> </span>&#123;<br>     <span class="hljs-keyword">final</span> ActivityLifecycleItem lifecycleItem = transaction.getLifecycleStateRequest();<br>     <span class="hljs-comment">// ...</span><br><br>     <span class="hljs-comment">// 第二个参数为执行完时的生命周状态</span><br>     cycleToPath(r, lifecycleItem.getTargetState(), <span class="hljs-keyword">true</span> <span class="hljs-comment">/* excludeLastState */</span>, transaction);<br><br>     <span class="hljs-comment">// Execute the final transition with proper parameters.</span><br>     lifecycleItem.execute(mTransactionHandler, token, mPendingActions);<br>     <br>     lifecycleItem.postExecute(mTransactionHandler, token, mPendingActions);<br> &#125;<br></code></pre></td></tr></table></figure><p>这段代码的关键点在于 <code>cycleToPath</code> 。同时，通过 lifecycleItem.getTargetState() 作为结束时的生命周期状态。由于此时设置的是一个 ResumeActivityItem，它的 getTargetState 返回的是一个 ON_RESUME 的值，代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">// frameworks/base/core/java/android/app/servertransaction/ResumeActivityItem.java</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getTargetState</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> ON_RESUME;<br>    &#125;<br>    <br>    <br>    <span class="hljs-meta">@Retention(RetentionPolicy.SOURCE)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> LifecycleState&#123;&#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> UNDEFINED = -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> PRE_ON_CREATE = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> ON_CREATE = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> ON_START = <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> ON_RESUME = <span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> ON_PAUSE = <span class="hljs-number">4</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> ON_STOP = <span class="hljs-number">5</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> ON_DESTROY = <span class="hljs-number">6</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> ON_RESTART = <span class="hljs-number">7</span>;<br><br></code></pre></td></tr></table></figure><p>可以看到 ON_RESUME 的值为 3。接着来看 cycleToPath 源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">cycleToPath</span><span class="hljs-params">(ActivityClientRecord r, <span class="hljs-keyword">int</span> finish, <span class="hljs-keyword">boolean</span> excludeLastState,</span></span><br><span class="hljs-function"><span class="hljs-params">            ClientTransaction transaction)</span> </span>&#123;<br>        <span class="hljs-comment">// 获取当前 Activity 的生命周期状态，即开始时的状态    </span><br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> start = r.getLifecycleState();<br>        <span class="hljs-comment">// 获取要执行的生命周期数组</span><br>        <span class="hljs-keyword">final</span> IntArray path = mHelper.getLifecyclePath(start, finish, excludeLastState);<br>        <span class="hljs-comment">// 按顺序执行 Activity 的生命周期</span><br>        performLifecycleSequence(r, path, transaction);<br>    &#125;<br><br></code></pre></td></tr></table></figure><p>在这个方法中，首先获取了当前 Activity 生命周期状态，即开始执行 getLifecyclePath 时 Activity 的生命周期状态，由于 executeLifecycleState 方法是在 executeCallback 之后执行的，上面我们已经提到此时的 Activity 已经执行完了创建流程，并执行过了 onCreate 的生命周期。因此，这里的 start 应该是 ON_CREATE 状态，ON_CREATE 的值为 1。</p><p>那么接下来，这里的关键点就在于 getLifecyclePath 做了什么。我们看一下源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">// frameworks/base/core/java/android/app/servertransaction/TransactionExecutorHelper.java</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> IntArray <span class="hljs-title">getLifecyclePath</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> finish, <span class="hljs-keyword">boolean</span> excludeLastState)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (start == UNDEFINED || finish == UNDEFINED) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;Can&#x27;t resolve lifecycle path for undefined state&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (start == ON_RESTART || finish == ON_RESTART) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<br>                    <span class="hljs-string">&quot;Can&#x27;t start or finish in intermittent RESTART state&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (finish == PRE_ON_CREATE &amp;&amp; start != finish) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;Can only start in pre-onCreate state&quot;</span>);<br>        &#125;<br><br>        mLifecycleSequence.clear();<br>        <span class="hljs-comment">// Activity 启动 时，执行到这里的 start 状态为 ON_CREATE，结束状态为 ON_RESUME</span><br>        <span class="hljs-keyword">if</span> (finish &gt;= start) &#123;<br>            <span class="hljs-keyword">if</span> (start == ON_START &amp;&amp; finish == ON_STOP) &#123;<br>                <span class="hljs-comment">// A case when we from start to stop state soon, we don&#x27;t need to go</span><br>                <span class="hljs-comment">// through the resumed, paused state.</span><br>                mLifecycleSequence.add(ON_STOP);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 会走到这里的逻辑，将 ON_START 与 ON_RESUME 添加到数组</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = start + <span class="hljs-number">1</span>; i &lt;= finish; i++) &#123;<br>                    mLifecycleSequence.add(i);<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// finish &lt; start, can&#x27;t just cycle down</span><br>            <span class="hljs-keyword">if</span> (start == ON_PAUSE &amp;&amp; finish == ON_RESUME) &#123;<br>                <span class="hljs-comment">// Special case when we can just directly go to resumed state.</span><br>                mLifecycleSequence.add(ON_RESUME);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (start &lt;= ON_STOP &amp;&amp; finish &gt;= ON_START) &#123;<br>                <span class="hljs-comment">// Restart and go to required state.</span><br><br>                <span class="hljs-comment">// Go to stopped state first.</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = start + <span class="hljs-number">1</span>; i &lt;= ON_STOP; i++) &#123;<br>                    mLifecycleSequence.add(i);<br>                &#125;<br>                <span class="hljs-comment">// Restart</span><br>                mLifecycleSequence.add(ON_RESTART);<br>                <span class="hljs-comment">// Go to required state</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = ON_START; i &lt;= finish; i++) &#123;<br>                    mLifecycleSequence.add(i);<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// Relaunch and go to required state</span><br><br>                <span class="hljs-comment">// Go to destroyed state first.</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = start + <span class="hljs-number">1</span>; i &lt;= ON_DESTROY; i++) &#123;<br>                    mLifecycleSequence.add(i);<br>                &#125;<br>                <span class="hljs-comment">// Go to required state</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = ON_CREATE; i &lt;= finish; i++) &#123;<br>                    mLifecycleSequence.add(i);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// Remove last transition in case we want to perform it with some specific params.</span><br>        <span class="hljs-keyword">if</span> (excludeLastState &amp;&amp; mLifecycleSequence.size() != <span class="hljs-number">0</span>) &#123;<br>            mLifecycleSequence.remove(mLifecycleSequence.size() - <span class="hljs-number">1</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> mLifecycleSequence;<br>    &#125;<br></code></pre></td></tr></table></figure><p>根据上边分析，此时的 start 为 ON_CREATE（值为 1），而 finish 的值为 ON_RESUME(值为 2)。因此，执行完 getLifecyclePath 后，会得到一个包含了 ON_START 与 ON_RESUME 的数组。</p><p>接下来看<code>performLifecycleSequence</code> 中的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">/** Transition the client through previously initialized state sequence. */</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">performLifecycleSequence</span><span class="hljs-params">(ActivityClientRecord r, IntArray path,</span></span><br><span class="hljs-function"><span class="hljs-params">        ClientTransaction transaction)</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> size = path.size();<br>    <span class="hljs-comment">// 遍历数组，执行 Activity 的生命周</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, state; i &lt; size; i++) &#123;<br>        state = path.get(i);<br><br>        <span class="hljs-keyword">switch</span> (state) &#123;<br>            <span class="hljs-keyword">case</span> ON_CREATE:<br>                mTransactionHandler.handleLaunchActivity(r, mPendingActions,<br>                        <span class="hljs-keyword">null</span> <span class="hljs-comment">/* customIntent */</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> ON_START:<br>                mTransactionHandler.handleStartActivity(r, mPendingActions,<br>                        <span class="hljs-keyword">null</span> <span class="hljs-comment">/* activityOptions */</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> ON_RESUME:<br>                mTransactionHandler.handleResumeActivity(r, <span class="hljs-keyword">false</span> <span class="hljs-comment">/* finalStateRequest */</span>,<br>                        r.isForward, <span class="hljs-string">&quot;LIFECYCLER_RESUME_ACTIVITY&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> ON_PAUSE:<br>                mTransactionHandler.handlePauseActivity(r, <span class="hljs-keyword">false</span> <span class="hljs-comment">/* finished */</span>,<br>                        <span class="hljs-keyword">false</span> <span class="hljs-comment">/* userLeaving */</span>, <span class="hljs-number">0</span> <span class="hljs-comment">/* configChanges */</span>,<br>                        <span class="hljs-keyword">false</span> <span class="hljs-comment">/* autoEnteringPip */</span>, mPendingActions,<br>                        <span class="hljs-string">&quot;LIFECYCLER_PAUSE_ACTIVITY&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> ON_STOP:<br>                mTransactionHandler.handleStopActivity(r, <span class="hljs-number">0</span> <span class="hljs-comment">/* configChanges */</span>,<br>                        mPendingActions, <span class="hljs-keyword">false</span> <span class="hljs-comment">/* finalStateRequest */</span>,<br>                        <span class="hljs-string">&quot;LIFECYCLER_STOP_ACTIVITY&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> ON_DESTROY:<br>                mTransactionHandler.handleDestroyActivity(r, <span class="hljs-keyword">false</span> <span class="hljs-comment">/* finishing */</span>,<br>                        <span class="hljs-number">0</span> <span class="hljs-comment">/* configChanges */</span>, <span class="hljs-keyword">false</span> <span class="hljs-comment">/* getNonConfigInstance */</span>,<br>                        <span class="hljs-string">&quot;performLifecycleSequence. cycling to:&quot;</span> + path.get(size - <span class="hljs-number">1</span>));<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> ON_RESTART:<br>                mTransactionHandler.performRestartActivity(r, <span class="hljs-keyword">false</span> <span class="hljs-comment">/* start */</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">default</span>:<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;Unexpected lifecycle state: &quot;</span> + state);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 <code>performLifecycleSequence</code> 方法中则是遍历了这个数组。因为此时的数组中有只有 ON_START 与 ON_RESUME 两个值，因此，这里分别先后执行了 <code>mTransactionHandler.handleStartActivity</code> 与 <code>mTransactionHandler.handleResumeActivity</code>，即调用了 ApplicationThread 的 handleStartActivity 与 handleResumeActivity 来执行 Activity 的 onStart 与 onResume 的生命周期。</p><h2 id="五、Activity-的创建与生命周期的执行"><a href="#五、Activity-的创建与生命周期的执行" class="headerlink" title="五、Activity 的创建与生命周期的执行"></a>五、Activity 的创建与生命周期的执行</h2><p>通过前面几个章节的分析我们已经知道，Activity 的启动是在服务端通过添加一个 LaunchActivityItem 到 ClientTransaction 中实现的，然后通过 IApplicationThread 跨进程将 ClientTransaction 传到了客户端来执行的。客户端通过遍历 ClientTransaction 中的所有 ClientTransactionItem，并执行了它的 execute 方法进而来执行 Activity 的创建过程。那接下来我们就来看一下 LaunchActivityItem 的 execute 方法调用后到底是如何执行的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">// frameworks/base/core/java/android/app/servertransaction/LaunchActivityItem.java</span><br><br><span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(ClientTransactionHandler client, IBinder token,</span></span><br><span class="hljs-function"><span class="hljs-params">            PendingTransactionActions pendingActions)</span> </span>&#123;<br>        <br>        ActivityClientRecord r = <span class="hljs-keyword">new</span> ActivityClientRecord(token, mIntent, mIdent, mInfo,<br>                mOverrideConfig, mCompatInfo, mReferrer, mVoiceInteractor, mState, mPersistentState,<br>                mPendingResults, mPendingNewIntents, mActivityOptions, mIsForward, mProfilerInfo,<br>                client, mAssistToken, mShareableActivityToken, mLaunchedFromBubble,<br>                mTaskFragmentToken);<br>                <br>        client.handleLaunchActivity(r, pendingActions, <span class="hljs-keyword">null</span> <span class="hljs-comment">/* customIntent */</span>);<br>    &#125;<br></code></pre></td></tr></table></figure><p>LaunchActivityItem 的 execute 方法调用了 ClientTransactionHandler 的 <code>handleLaunchActivity</code>，而这里的 ClientTransactionHandler 就是 ActivityThread。 ActivityThread 中 handleLaunchActivity 的源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">// frameworks/base/core/java/android/app/ActivityThread.java</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> Activity <span class="hljs-title">handleLaunchActivity</span><span class="hljs-params">(ActivityClientRecord r,</span></span><br><span class="hljs-function"><span class="hljs-params">            PendingTransactionActions pendingActions, Intent customIntent)</span> </span>&#123;<br>        <span class="hljs-comment">// If we are getting ready to gc after going to the background, well</span><br>        <span class="hljs-comment">// we are back active so skip it.</span><br>        unscheduleGcIdler();<br>        mSomeActivitiesChanged = <span class="hljs-keyword">true</span>;<br><br>        <span class="hljs-comment">// ...</span><br><br>        <span class="hljs-comment">// 初始化 WindowManagerGlobal</span><br>        WindowManagerGlobal.initialize();<br><br>       <br>        <span class="hljs-comment">// 调用 performLaunchActivity 执行 Activity 的创建流程</span><br>        <span class="hljs-keyword">final</span> Activity a = performLaunchActivity(r, customIntent);<br><br>        <span class="hljs-comment">// ...</span><br><br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br></code></pre></td></tr></table></figure><p>在 handleLaunchActivity 方法中首先去初始化了 WindowManagerGlobal，紧接着调用了 performLaunchActivity 并返回了一个 Activity 实例，那么 Activity 的实例化必定是在  performLaunchActivity 中完成的。</p><h3 id="1-Activity-的实例化与-onCreate-的调用"><a href="#1-Activity-的实例化与-onCreate-的调用" class="headerlink" title="1. Activity 的实例化与 onCreate 的调用"></a>1. Activity 的实例化与 onCreate 的调用</h3><p>看下 performLaunchActivity 的源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">// frameworks/base/core/java/android/app/ActivityThread.java</span><br><br><span class="hljs-function"><span class="hljs-keyword">private</span> Activity <span class="hljs-title">performLaunchActivity</span><span class="hljs-params">(ActivityClientRecord r, Intent customIntent)</span> </span>&#123;<br>        ActivityInfo aInfo = r.activityInfo;<br>        <span class="hljs-comment">// ...</span><br><br>        ContextImpl appContext = createBaseContextForActivity(r);<br>        Activity activity = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 在 Instrumentation 中通过反射实例化 Activity </span><br>            java.lang.ClassLoader cl = appContext.getClassLoader();<br>            activity = mInstrumentation.newActivity(<br>                    cl, component.getClassName(), r.intent);<br>            StrictMode.incrementExpectedActivityCount(activity.getClass());<br>            r.intent.setExtrasClassLoader(cl);<br>            r.intent.prepareToEnterProcess(isProtectedComponent(r.activityInfo),<br>                    appContext.getAttributionSource());<br>            <span class="hljs-keyword">if</span> (r.state != <span class="hljs-keyword">null</span>) &#123;<br>                r.state.setClassLoader(cl);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            <span class="hljs-keyword">if</span> (!mInstrumentation.onException(activity, e)) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<br>                    <span class="hljs-string">&quot;Unable to instantiate activity &quot;</span> + component<br>                    + <span class="hljs-string">&quot;: &quot;</span> + e.toString(), e);<br>            &#125;<br>        &#125;<br><br>       <span class="hljs-comment">// ... 省略后半部分执行 Activity 生命周期的代码</span><br><br>        <span class="hljs-keyword">return</span> activity;<br>    &#125;<br><br></code></pre></td></tr></table></figure><p>这个方法中的主要逻辑可以分为两部分，第一部分是实例化 Activity；第二部分是执行 Activity 的 onCreate 的生命周期。由于代码比较长，这里我们只截取了第一部分的代码。可以看到这里通过 Instrumentation 的 newActivity 获取到一个 Activity 实例，newActivity 的参数传入了一个 ClassLoader 和 Activity 的 className。因此，这里实例化 Activity 的过程一定是通过反射实现的。看代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Activity <span class="hljs-title">newActivity</span><span class="hljs-params">(Class&lt;?&gt; clazz, Context context, </span></span><br><span class="hljs-function"><span class="hljs-params">        IBinder token, Application application, Intent intent, ActivityInfo info, </span></span><br><span class="hljs-function"><span class="hljs-params">        CharSequence title, Activity parent, String id,</span></span><br><span class="hljs-function"><span class="hljs-params">        Object lastNonConfigurationInstance)</span> <span class="hljs-keyword">throws</span> InstantiationException,</span><br><span class="hljs-function">        IllegalAccessException </span>&#123;<br>    Activity activity = (Activity)clazz.newInstance();<br>    ActivityThread aThread = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-comment">// Activity.attach expects a non-null Application Object.</span><br>    <span class="hljs-keyword">if</span> (application == <span class="hljs-keyword">null</span>) &#123;<br>        application = <span class="hljs-keyword">new</span> Application();<br>    &#125;<br>    activity.attach(context, aThread, <span class="hljs-keyword">this</span>, token, <span class="hljs-number">0</span> <span class="hljs-comment">/* ident */</span>, application, intent,<br>            info, title, parent, id,<br>            (Activity.NonConfigurationInstances)lastNonConfigurationInstance,<br>            <span class="hljs-keyword">new</span> Configuration(), <span class="hljs-keyword">null</span> <span class="hljs-comment">/* referrer */</span>, <span class="hljs-keyword">null</span> <span class="hljs-comment">/* voiceInteractor */</span>,<br>            <span class="hljs-keyword">null</span> <span class="hljs-comment">/* window */</span>, <span class="hljs-keyword">null</span> <span class="hljs-comment">/* activityCallback */</span>, <span class="hljs-keyword">null</span> <span class="hljs-comment">/*assistToken*/</span>,<br>            <span class="hljs-keyword">null</span> <span class="hljs-comment">/*shareableActivityToken*/</span>);<br>    <span class="hljs-keyword">return</span> activity;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>newActivity 中通过反射实例化了 Activity，接着调用了 Activity 的 attach 方法。</p><p>接下来看 performLaunchActivity 方法的后半部分的逻辑。在实例化了 Activity 之后是如何调用 Activity 的 onCreate 生命周期的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">private</span> Activity <span class="hljs-title">performLaunchActivity</span><span class="hljs-params">(ActivityClientRecord r, Intent customIntent)</span> </span>&#123;<br>        ActivityInfo aInfo = r.activityInfo;<br>        <span class="hljs-comment">// ...</span><br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 获取 Application </span><br>            Application app = r.packageInfo.makeApplicationInner(<span class="hljs-keyword">false</span>, mInstrumentation);<br><br>            <span class="hljs-comment">// ...</span><br><br>            <span class="hljs-keyword">if</span> (activity != <span class="hljs-keyword">null</span>) &#123;<br>                CharSequence title = r.activityInfo.loadLabel(appContext.getPackageManager());<br>                Configuration config =<br>                        <span class="hljs-keyword">new</span> Configuration(mConfigurationController.getCompatConfiguration());<br>                <span class="hljs-comment">// ...</span><br><br>                <span class="hljs-comment">// Activity resources must be initialized with the same loaders as the</span><br>                <span class="hljs-comment">// application context.</span><br>                appContext.getResources().addLoaders(<br>                        app.getResources().getLoaders().toArray(<span class="hljs-keyword">new</span> ResourcesLoader[<span class="hljs-number">0</span>]));<br><br>                appContext.setOuterContext(activity);<br>                <span class="hljs-comment">// 再次执行 Activity 的 attach 方法</span><br>                activity.attach(appContext, <span class="hljs-keyword">this</span>, getInstrumentation(), r.token,<br>                        r.ident, app, r.intent, r.activityInfo, title, r.parent,<br>                        r.embeddedID, r.lastNonConfigurationInstances, config,<br>                        r.referrer, r.voiceInteractor, window, r.activityConfigCallback,<br>                        r.assistToken, r.shareableActivityToken);<br><br>                <span class="hljs-keyword">if</span> (customIntent != <span class="hljs-keyword">null</span>) &#123;<br>                    activity.mIntent = customIntent;<br>                &#125;<br>                r.lastNonConfigurationInstances = <span class="hljs-keyword">null</span>;<br>                checkAndBlockForNetworkAccess();<br>                activity.mStartedActivity = <span class="hljs-keyword">false</span>;<br>                <span class="hljs-keyword">int</span> theme = r.activityInfo.getThemeResource();<br>                <span class="hljs-keyword">if</span> (theme != <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-comment">// 设置 Activity 主题</span><br>                    activity.setTheme(theme);<br>                &#125;<br><br>                <span class="hljs-keyword">if</span> (r.mActivityOptions != <span class="hljs-keyword">null</span>) &#123;<br>                    activity.mPendingOptions = r.mActivityOptions;<br>                    r.mActivityOptions = <span class="hljs-keyword">null</span>;<br>                &#125;<br>                activity.mLaunchedFromBubble = r.mLaunchedFromBubble;<br>                activity.mCalled = <span class="hljs-keyword">false</span>;<br>                <span class="hljs-comment">// Assigning the activity to the record before calling onCreate() allows</span><br>                <span class="hljs-comment">// ActivityThread#getActivity() lookup for the callbacks triggered from</span><br>                <span class="hljs-comment">// ActivityLifecycleCallbacks#onActivityCreated() or</span><br>                <span class="hljs-comment">// ActivityLifecycleCallback#onActivityPostCreated().</span><br>                r.activity = activity;<br>                <span class="hljs-comment">// 调用 Activity 的 onCreate 方法</span><br>                <span class="hljs-keyword">if</span> (r.isPersistable()) &#123;<br>                    mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    mInstrumentation.callActivityOnCreate(activity, r.state);<br>                &#125;<br>                <span class="hljs-comment">// ...</span><br>            &#125;<br>            r.setState(ON_CREATE);<br><br>        &#125; <span class="hljs-keyword">catch</span> (SuperNotCalledException e) &#123;<br>           <span class="hljs-comment">// ...</span><br>        &#125; <br><br>        <span class="hljs-keyword">return</span> activity;<br>    &#125;<br><br></code></pre></td></tr></table></figure><p>上述方法中首先获取 Activity 的 title 以及 Configuration 等相关参数，然后再次调用 Activity 的 attach 方法，并将这些参数传入。接着通过 Instrumentation 执行了 Activity 的 performCreate 方法，代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">callActivityOnCreate</span><span class="hljs-params">(Activity activity, Bundle icicle)</span> </span>&#123;<br>    prePerformCreate(activity);<br>    activity.performCreate(icicle);<br>    postPerformCreate(activity);<br>&#125;<br><br><br></code></pre></td></tr></table></figure><p>而 Activity 的 performCreate 方法中最终会调用 Activity 的 onCreate方法。至此，我们在 Activity 的 onCreate 方法中写的逻辑才会被调用。performCreate 方法的代码这里就不再贴出，有兴趣的可以自行查看。</p><h3 id="2-onStart-方法的执行"><a href="#2-onStart-方法的执行" class="headerlink" title="2. onStart 方法的执行"></a>2. onStart 方法的执行</h3><p>在第四章的第 3 小节中，中我们已经分析了创建完 Activity 后如何执行后续的生命周期流程。我们知道 onStart 是通过 ActivityThread 的 handleStartActivity 来执行的，其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// frameworks/base/core/java/android/app/ActivityThread.java</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleStartActivity</span><span class="hljs-params">(ActivityClientRecord r,</span></span><br><span class="hljs-function"><span class="hljs-params">            PendingTransactionActions pendingActions, ActivityOptions activityOptions)</span> </span>&#123;<br>        <span class="hljs-keyword">final</span> Activity activity = r.activity;<br>        <span class="hljs-keyword">if</span> (!r.stopped) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">&quot;Can&#x27;t start activity that is not stopped.&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (r.activity.mFinished) &#123;<br>            <span class="hljs-comment">// TODO(lifecycler): How can this happen?</span><br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        unscheduleGcIdler();<br>        <span class="hljs-keyword">if</span> (activityOptions != <span class="hljs-keyword">null</span>) &#123;<br>            activity.mPendingOptions = activityOptions;<br>        &#125;<br><br>        <span class="hljs-comment">// 调用 Activity 的 performStart 进而执行 onStart</span><br>        activity.performStart(<span class="hljs-string">&quot;handleStartActivity&quot;</span>);<br>        <br>        <span class="hljs-comment">// 将生命周状态设置为 ON_START</span><br>        r.setState(ON_START);<br><br>       <span class="hljs-comment">// ...</span><br>    &#125;<br></code></pre></td></tr></table></figure><p>handleStartActivity 的逻辑比较简单，就是调用了 Activity 的 performStart 方法，进而调用了 onStart 方法。这里也不再贴出 performStart 方法的源码，感兴趣的同学自行查看。</p><h3 id="3-onResume-方法的调用"><a href="#3-onResume-方法的调用" class="headerlink" title="3. onResume 方法的调用"></a>3. onResume 方法的调用</h3><p>onResume 方法是通过 ActivityThread 的 handleResumeActivity 来执行的，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// frameworks/base/core/java/android/app/ActivityThread.java</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleResumeActivity</span><span class="hljs-params">(ActivityClientRecord r, <span class="hljs-keyword">boolean</span> finalStateRequest,</span></span><br><span class="hljs-function"><span class="hljs-params">            <span class="hljs-keyword">boolean</span> isForward, <span class="hljs-keyword">boolean</span> shouldSendCompatFakeFocus, String reason)</span> </span>&#123;<br>        <span class="hljs-comment">// If we are getting ready to gc after going to the background, well</span><br>        <span class="hljs-comment">// we are back active so skip it.</span><br>        unscheduleGcIdler();<br>        mSomeActivitiesChanged = <span class="hljs-keyword">true</span>;<br><br>        <span class="hljs-comment">// TODO Push resumeArgs into the activity for consideration</span><br>        <span class="hljs-comment">// skip below steps for double-resume and r.mFinish = true case.</span><br>        <span class="hljs-keyword">if</span> (!performResumeActivity(r, finalStateRequest, reason)) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <br>       <span class="hljs-comment">// ... 省略 Window 的添加逻辑</span><br>    &#125;<br></code></pre></td></tr></table></figure><p>handleResumeActivity 方法中的逻辑比较复杂，但核心主要有两点：</p><ul><li>调用 performResumeActivity 执行 onResume 的生命周期</li><li>将 DecorView 添加到 Window 中</li></ul><p>上述代码中我们省略了 decorView 添加到 Window 部分的代码，后边再来分析。先来看 performResumeActivity，其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">performResumeActivity</span><span class="hljs-params">(ActivityClientRecord r, <span class="hljs-keyword">boolean</span> finalStateRequest,</span></span><br><span class="hljs-function"><span class="hljs-params">           String reason)</span> </span>&#123;<br>       <br>       <span class="hljs-keyword">if</span> (r.activity.mFinished) &#123;<br>           <span class="hljs-comment">// 如果 Activity 已经是finish状态，直接return false</span><br>           <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>       &#125;<br>       <span class="hljs-keyword">if</span> (r.getLifecycleState() == ON_RESUME) &#123;<br>           <span class="hljs-comment">// 如果已经是 Resume 状态 直接return false，避免重复执行</span><br>           <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>       &#125;<br><br>       <span class="hljs-keyword">try</span> &#123;<br>          <span class="hljs-comment">// ...</span><br>          <br>           <span class="hljs-comment">// 执行 Activity 的 performResume 进而执行 onResume</span><br>           r.activity. performResume(r.startsNotResumed, reason);<br><br>           r.state = <span class="hljs-keyword">null</span>;<br>           r.persistentState = <span class="hljs-keyword">null</span>;<br>           <span class="hljs-comment">// 设置 Activity 的状态 为 ON_RESUME</span><br>           r.setState(ON_RESUME);<br><br>           reportTopResumedActivityChanged(r, r.isTopResumedActivity, <span class="hljs-string">&quot;topWhenResuming&quot;</span>);<br>       &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>           <span class="hljs-keyword">if</span> (!mInstrumentation.onException(r.activity, e)) &#123;<br>               <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;Unable to resume activity &quot;</span><br>                       + r.intent.getComponent().toShortString() + <span class="hljs-string">&quot;: &quot;</span> + e.toString(), e);<br>           &#125;<br>       &#125;<br>       <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>   &#125;<br><br></code></pre></td></tr></table></figure><p>performResumeActivity 中先对 Activity 的状态进行了判断，如果状态符合，则会调用 Activity 的 performResume 方法，进而执行 Activity 的 onResume。performResume 方法的源码不再贴出。</p><p>在完成了 performResume 的调用后，performResumeActivity 方法中接着执行了将 DecorView 添加到 Window 的过。代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// frameworks/base/core/java/android/app/ActivityThread.java</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleResumeActivity</span><span class="hljs-params">(ActivityClientRecord r, <span class="hljs-keyword">boolean</span> finalStateRequest,</span></span><br><span class="hljs-function"><span class="hljs-params">            <span class="hljs-keyword">boolean</span> isForward, <span class="hljs-keyword">boolean</span> shouldSendCompatFakeFocus, String reason)</span> </span>&#123;<br>        <span class="hljs-comment">// ...</span><br>        <br><br>        <span class="hljs-keyword">final</span> Activity a = r.activity;<br><br>        <span class="hljs-keyword">if</span> (r.window == <span class="hljs-keyword">null</span> &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123;<br>            <span class="hljs-comment">// PhoneWindow</span><br>            r.window = r.activity.getWindow();<br>            <span class="hljs-comment">// 获取 DecorView</span><br>            View decor = r.window.getDecorView();<br>            <span class="hljs-comment">// 先设置 DecorView 不可见</span><br>            decor.setVisibility(View.INVISIBLE);<br>            <span class="hljs-comment">// 获取 WindowManager</span><br>            ViewManager wm = a.getWindowManager();<br>            <span class="hljs-comment">// 获取 Window 的属性参数</span><br>            WindowManager.LayoutParams l = r.window.getAttributes();<br>            a.mDecor = decor;<br>            l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION;<br>            l.softInputMode |= forwardBit;<br>            <span class="hljs-comment">// ...</span><br>            <span class="hljs-keyword">if</span> (a.mVisibleFromClient) &#123;<br>                <span class="hljs-keyword">if</span> (!a.mWindowAdded) &#123;<br>                    a.mWindowAdded = <span class="hljs-keyword">true</span>;<br>                    <span class="hljs-comment">// 通过 WindowManager 将 DecorView添加到窗口</span><br>                    wm.addView(decor, l);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// The activity will get a callback for this &#123;@link LayoutParams&#125; change</span><br>                    <span class="hljs-comment">// earlier. However, at that time the decor will not be set (this is set</span><br>                    <span class="hljs-comment">// in this method), so no action will be taken. This call ensures the</span><br>                    <span class="hljs-comment">// callback occurs with the decor set.</span><br>                    a.onWindowAttributesChanged(l);<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-comment">// If the window has already been added, but during resume</span><br>            <span class="hljs-comment">// we started another activity, then don&#x27;t yet make the</span><br>            <span class="hljs-comment">// window visible.</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!willBeVisible) &#123;<br>            <span class="hljs-keyword">if</span> (localLOGV) Slog.v(TAG, <span class="hljs-string">&quot;Launch &quot;</span> + r + <span class="hljs-string">&quot; mStartedActivity set&quot;</span>);<br>            r.hideForNow = <span class="hljs-keyword">true</span>;<br>        &#125;<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br></code></pre></td></tr></table></figure><p>可以看到，上述方法的的核心是 <code>wm.addView(decor, l)</code> 这行代码，即通过 ViewManager 的 addView 方法将 DecorView 添加到了窗口中。窗口的添加过程会完成 DecorView 的布局、测量与绘制。当完成窗口的添加后 Activity 的 View 才被显示出来，且有了宽高。这也是为什么我们在 onResume 中获取不到 View 宽高的原因。</p><p>另外需要注意到是，将 View 添加到 Window 的过程也是一个相当复杂的过程，这个过程也多次涉及到跨进程调用。这也是为什么在本文的开头提到 Activity 启动是一个数次跨进程调用的过程的原因。关于 Window 的添加过程，这里就不再赘述了，后边会单独写一篇文章来详细分析 Window 的添加。</p><h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>通过本篇文章我们详细的了解了 Activity 的启动流程，虽然在开发中启动一个 Activity 只需要我们调用一行代码，但通过追踪源码我们发现 startActivity 方法的调用栈非常深，且中间涉及了两次跨进程的调用，如果不了解 Binder 与 AIDL 是比较难以读懂的。另外，由于 Activity 的启动过程比较复杂，文章中不能面面俱到，忽略了很多支线逻辑，比如当启动 Activity 时，Activity 所在的进程不存在时的逻辑，本文章并没有去分析，感兴趣的同学可以自行查看源码。</p>]]></content>
    
    
    <categories>
      
      <category>Framework</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Android 架构思想与 MVVM 框架封装</title>
    <link href="/2022/08/20/50-android-architecture/"/>
    <url>/2022/08/20/50-android-architecture/</url>
    
    <content type="html"><![CDATA[<p>关于Android项目架构也是一个老生常谈的话题了，网上关于Android架构的文章不胜枚举，但是通过Google检索关键字，首页的热门文章多数是对于MVC、MVP及MVVM等架构的概念介绍，概念性的文章对于不了解Android架构的同学来说并不一定能起到很好的帮助。本篇文章其实源自笔者在公司内部的技术分享，稍作修改后作为文章发布出来。文章内容涉及从<br>MVC、MVP 到 MVVM 的演化，同时为便于理解，每种架构都做了代码演示，最后基于 Jetpack 提供的组件封装了 MVVM<br>架构。文章内容比较基础，几乎没有晦涩难懂的知识，对于想要了解Android架构的同学会有很大的帮助。</p><h2 id="一、Android-项目架构的演化"><a href="#一、Android-项目架构的演化" class="headerlink" title="一、Android 项目架构的演化"></a>一、Android 项目架构的演化</h2><p>首先，我们应该明白一点，对于架构而言并不分平台。不管MVC、MVP 还是 MVVM<br>都不是Android平台独有的，甚至由于Android平台起步较晚，Android项目的架构或多或少的参考了前端的架构实现。</p><p>对于前端或者Android端项目而言代码可以分为三部分，分别为UI部分、业务逻辑部分以及数据控制部分。这三部分流转的起点来自于用户输入，即用户通过操作UI调起对应的业务逻辑获取数据，并最终将数据反馈到UI界面上，其流转图如下图所示。</p><p><img src="https://raw.githubusercontent.com/zhpanvip/images/master/project/article/5001.webp" alt="image.png"></p><p>根据这三部分内容，我们可以将代码分为三层，即最初的MVC架构分层。但是随着项目的业务逐渐复杂，MVC架构的弊端显露，不能够支撑已有的业务。于是在此背景下衍生出了MVP架构来弥补MVC的不足。甚至后来谷歌官方推出的部分Jetpack组件来专门解决Android架构问题，从主推MVVM，到如今主推的MVI架构。但是不管架构如何演变，都脱离不了上述提到的三层逻辑，只不过新的架构在已有的基础上弥补了老架构的不足，让项目代码更容易维护。</p><p>接下来的内容我们主要探讨Android项目架构从MVC到MVVM的演化。</p><ol><li><h3 id="MVC-简介"><a href="#MVC-简介" class="headerlink" title="MVC 简介"></a>MVC 简介</h3></li></ol><p>基于上面提到的三层逻辑，最初的Android项目采用的是MVC架构。MVC是 <strong>Model-View-Controller</strong><br>的简称。简单来说MVC是用户操作View，View调用Controller去操作Model层，然后Model层将数据返回给View层展示。</p><ul><li>模型层(Model) 负责与数据库和网络层通信，并获取和存储应用的数据；</li><li>视图层(View) 负责将 Model 层的数据做可视化的处理，同时处理与用户的交互；</li><li>控制层(Controller) 用于建立Model层与View层的联系，负责处理主要的业务逻辑，并根据用户操作更新 Model 层数据。</li></ul><p>MVC 的结构图如下图所示。</p><p><img src="https://raw.githubusercontent.com/zhpanvip/images/master/project/article/5002.webp" alt="image.png"></p><p>在 Android 项目的 MVC 架构中由于 Activity 同时充当了 View 层与 Controller 层两个角色，所以 Android 中的 MVC 更像下面的这种结构：</p><p><img src="https://raw.githubusercontent.com/zhpanvip/images/master/project/article/5003.webp" alt="image.png"></p><p>基于上图，我们可以以APP的登录流程为例实现 Android 中 MVC 架构的代码。</p><h4 id="（1）Model-层代码实现"><a href="#（1）Model-层代码实现" class="headerlink" title="（1）Model 层代码实现"></a>（1）Model 层代码实现</h4><p>Model 层用于处理登录请求并从服务器获取登录相关数据，成功后通知 View 层更新界面。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginModel</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">login</span><span class="hljs-params">(String username, String password, LoginListener listener)</span> </span>&#123;<br>        RetrofitManager.getApiService()<br>                .login(username, password)<br>                .enqueue(<span class="hljs-keyword">new</span> Callback&lt;User&gt;() &#123;<br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onResponse</span><span class="hljs-params">(Call&lt;User&gt; call, Response&lt;User&gt; response)</span> </span>&#123;<br>                        listener.onSuccess(response.data);<br>                    &#125;<br><br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onFailed</span><span class="hljs-params">(Exception e)</span> </span>&#123;<br>                        listener.onFailed(e.getMessage());<br>                    &#125;<br>                &#125;);<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码通过 LoginListener 来通知 View 层更新UI，LoginListener 是一个接口，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">LoginListener</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onSuccess</span><span class="hljs-params">(User data)</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onFailed</span><span class="hljs-params">(String msg)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（2）Controller-View-代码实现"><a href="#（2）Controller-View-代码实现" class="headerlink" title="（2）Controller/View 代码实现"></a>（2）Controller/View 代码实现</h4><p>由于 Android 的 MVC 架构中 Controller 与 View 层都是由 Activity 负责的，因此 Activity 需要实现 LoginListener 用来更新<br>UI。其代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AppCompactActivity</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">LoginListener</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> LoginModel loginModel;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState);<br>        setContentView(R.layout.activity_main);<br>        model = <span class="hljs-keyword">new</span> LoginModel();<br>        findViewbyId(R.id.btn_fetch_data).setOnClickListener(view -&gt; &#123;<br>                    String username = findViewById(R.id.et_username).getText().toString();<br>                    String password = findViewById(R.id.et_password).getText().toString();<br>                    loginModel.login(username, password, <span class="hljs-keyword">this</span>);<br>                &#125;<br>        );<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onSuccess</span><span class="hljs-params">(User data)</span> </span>&#123;<br>        <span class="hljs-comment">// Update UI</span><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onFailed</span><span class="hljs-params">(String msg)</span> </span>&#123;<br>        <span class="hljs-comment">// Update UI</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>从上述代码中可以看到，Android中的MVC代码对于分层并不明确，导致了Controller层与View层混为一体。与此同时，大家在写Android代码的时候一般不会刻意的再去抽出一个Model层，而是将<br>Model 层的代码也一股脑的塞到 Activity 中实现，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AppCompactActivity</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">LoginListener</span>, <span class="hljs-title">View</span>.<span class="hljs-title">OnClickListener</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> LoginModel loginModel;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState);<br>        setContentView(R.layout.activity_main);<br>        model = <span class="hljs-keyword">new</span> LoginModel();<br><br>        findViewbyId(R.id.btn_fetch_data).setOnClickListener(view -&gt; &#123;<br>                    showLoading();<br>                    String username = findViewById(R.id.et_username).getText().toString();<br>                    String password = findViewById(R.id.et_password).getText().toString();<br>                    RetrofitManager.getApiService()<br>                            .login(username, password)<br>                            .enqueue(<span class="hljs-keyword">new</span> Callback&lt;User&gt;() &#123;<br>                                <span class="hljs-meta">@Override</span><br>                                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onResponse</span><span class="hljs-params">(Call&lt;User&gt; call, Response&lt;User&gt; response)</span> </span>&#123;<br>                                    onSuccess(response.data);<br>                                &#125;<br><br>                                <span class="hljs-meta">@Override</span><br>                                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onFailed</span><span class="hljs-params">(Exception e)</span> </span>&#123;<br>                                    listener.onFailed(e.getMessage());<br>                                &#125;<br>                            &#125;);<br>                &#125;<br>        );<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onSuccess</span><span class="hljs-params">(User data)</span> </span>&#123;<br>        dismissLoading();<br>        <span class="hljs-comment">// Update UI</span><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onFailed</span><span class="hljs-params">(String msg)</span> </span>&#123;<br>        dismissLoading();<br>        <span class="hljs-comment">// Update UI</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">showLoading</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dismissLoading</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样的代码分层变得更加模糊，同时也使得代码的结构层次更加混乱。致使一些业务比较复杂的页面 Activity 中的代码可能多达数千行。由此可以看出 Android 项目中的 MVC<br>架构是存在很多问题的。总结主要有如下几点：</p><ul><li>Activity/Fragment 同时承担了 View 层与 Controller 层的工作，违背了单一职责；</li><li>Model 层与 View 层存在耦合，存在相互依赖关系；</li><li>开发时不注重分层，Model层代码也被塞进了Activity/Fragment，使得代码层次更加混乱。</li></ul><ol start="2"><li><h3 id="MVP-简介"><a href="#MVP-简介" class="headerlink" title="MVP 简介"></a>MVP 简介</h3></li></ol><p>针对以上MVC架构中存在的问题，我们可以在MVC的基础上进行优化解决。即从Activity中剥离出控制层的逻辑，并阻断Model层与View层的耦合，Model层不直接与View通信，而是在数据改变时让<br>Model通知控制控制层，控制层再通知View层去做界面更新，这就是MVP的架构思想。MVP 是 <strong>Model-View-Presenter</strong> 的简称。 简单来说 MVP 就是将 MVC 的<br>Controller 改为 Presenter，即把逻辑层的代码从 Activity 中抽离到了 Presenter 中，这样代码层次变得更加清晰，其次 Model 层不再持有 View<br>层，代码更加解耦。</p><ul><li>模型层(Model) 与MVC中的一致，同样是负责与数据库和网络层通信，并获取和存储应用的数据，区别在于Model层不再与View层直接通信，而是与Presenter层通信。</li><li>视图层(View) 负责将 Model 层的数据做可视化的处理，同时与Presenter层交互。跟MVC相比，MVP的View层与Model层不再耦合。</li><li>控制层(Presenter) 主要负责处理业务逻辑，并监听Model层数据改变，然后调用View层刷新UI。</li></ul><p>MVP 的结构图如下图所示。</p><p><img src="https://raw.githubusercontent.com/zhpanvip/images/master/project/article/5004.webp" alt="image.png"></p><p>从上图中可以看出，View直接与Presenter层通信，当View层接收到用户操作后会调用<br>Presenter层去处理业务逻辑。接着Presenter层通过Model去获取数据，Model层获取到数据后又将最新的数据传回 Presenter。<br>由于Presenter层又持有View层的引用，进而将数据传给<code>View</code>层进行展示。</p><p>下面我们我们仍然以登录为例通过代码来演示MVP架构的实现。</p><h4 id="（1）Model-层代码实现-1"><a href="#（1）Model-层代码实现-1" class="headerlink" title="（1）Model 层代码实现"></a>（1）Model 层代码实现</h4><p>MVP中的Model层与MVC中的Model层是一致的，代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginModel</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">login</span><span class="hljs-params">(String username, String password, LoginListener listener)</span> </span>&#123;<br>        RetrofitManager.getApiService()<br>                .login(username, password)<br>                .enqueue(<span class="hljs-keyword">new</span> Callback&lt;User&gt;() &#123;<br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onResponse</span><span class="hljs-params">(Call&lt;User&gt; call, Response&lt;User&gt; response)</span> </span>&#123;<br>                        listener.onSuccess(response.data);<br>                    &#125;<br><br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onFailed</span><span class="hljs-params">(Exception e)</span> </span>&#123;<br>                        listener.onFailed(e.getMessage());<br>                    &#125;<br>                &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在登录接口返回结果后通过 LoginListener 将结果回调出来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">LoginListener</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onSuccess</span><span class="hljs-params">(User user)</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onFailed</span><span class="hljs-params">(String errorInfo)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（2）Presenter-层代码实现"><a href="#（2）Presenter-层代码实现" class="headerlink" title="（2）Presenter 层代码实现"></a>（2）Presenter 层代码实现</h4><p>由于 Presenter 需要通知 View 层更新UI，因此需要持有View，这里可以抽象出一个 View 接口。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ILoginView</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">showLoading</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dismissLoading</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">loginSuccess</span><span class="hljs-params">(User data)</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">loginFailer</span><span class="hljs-params">(String errorMsg)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>另外，Presenter也需要与Model层通信，因此Presenter层也会持有Model层，在用户触发登录操作后，调用Presenter的登录逻辑，Presenter通过Model进行登录操作，登录成功后再将结果反馈给View层更新界面。代码实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginPresenter</span> </span>&#123;<br><br>    <span class="hljs-comment">// Model 层 </span><br>    <span class="hljs-keyword">private</span> LoginModel model;<br><br>    <span class="hljs-comment">// View 层 </span><br>    <span class="hljs-keyword">private</span> ILoginView view;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LoginPresenter</span><span class="hljs-params">(LoginView view)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.model = <span class="hljs-keyword">new</span> LoginModel();<br>        <span class="hljs-keyword">this</span>.view = view;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">login</span><span class="hljs-params">(String username, String password)</span> </span>&#123;<br>        view.showLoading();<br>        model.login(username, password, <span class="hljs-keyword">new</span> LoginListener() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onSuccess</span><span class="hljs-params">(User user)</span> </span>&#123;<br>                view.loginSuccess(user);<br>                view.dismissLoading();<br>            &#125;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onFailed</span><span class="hljs-params">(String msg)</span> </span>&#123;<br>                view.loginFailer(msg);<br>                view.dismissLoading();<br>            &#125;<br>        &#125;);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onDestory</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// recycle instance.</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="（3）View-层代码实现"><a href="#（3）View-层代码实现" class="headerlink" title="（3）View 层代码实现"></a>（3）View 层代码实现</h4><p>Activity作为View层需要实现上述ILoginView接口，且View层需要持有Presenter来处理业务逻辑。View层的代码实现就变得非常简单了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AppCompatActivity</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ILoginView</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> LoginPresenter presenter;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState);<br>        setContentView(R.layout.activity_main);<br><br>        presenter = <span class="hljs-keyword">new</span> LoginPresenter(<span class="hljs-keyword">this</span>);<br>        findViewById(R.id.button).setOnClickListener(v -&gt; &#123;<br>            String username = findViewById(R.id.et_username).getText().toString();<br>            String password = findViewById(R.id.et_password).getText().toString();<br>            presenter.login(username, password);<br>        &#125;);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">loginSuccess</span><span class="hljs-params">(User user)</span> </span>&#123;<br>        <span class="hljs-comment">// Update UI.</span><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">loginFailer</span><span class="hljs-params">(String msg)</span> </span>&#123;<br>        <span class="hljs-comment">// Update UI.</span><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onDestroy</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.onDestroy();<br>        presenter.onDestroy();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">showLoading</span><span class="hljs-params">()</span> </span>&#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dismissLoading</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>MVP的本质是面向接口编程，实现依赖倒置原则。可以看得出来MVP架构在分层上相比 MVC更加清晰明确，且解耦了Model层与View层。但MVP也存在一些弊端，列举如下：</p><ul><li>引入大量的 IView、IPresenter接口实现类，增加项目的复杂度。</li><li>View 层与 Presenter 相互持有，存在耦合。</li></ul><ol start="3"><li><h3 id="MVVM-简介"><a href="#MVVM-简介" class="headerlink" title="MVVM 简介"></a>MVVM 简介</h3></li></ol><p>MVP相比于MVC无疑有很多优点，但其自身也并非无懈可击，再加之MVP也并非Google官方推荐的架构，因此也只能算得上程序员对于Android项目架构优化的野路子。从2015年开始，Google官方开始对Android项目架构做出指导，随后推出DataBinding组件以及后边一系列的Jetpack组件来帮助开发者优化项目架构。Google官方给出的这一套指导架构就是MVVM。MVVM是 **<br>Model-View-ViewModel** 的简称。这一架构在一定程度上解决了MVP架构中存在的问题。虽然近期官方的指导架构由MVVM变为了MVI，但MVVM依然是目前Android项目的主流架构。</p><ul><li>模型层(Model) 与MVP中的Model层一致，负责与数据库和网络层通信，获取并存储数据。与MVP的区别在于Model层不再通过回调通知业务逻辑层数据改变，而是通过观察者模式实现。</li><li>视图(View) 负责将Model层的数据做可视化的处理，同时与ViewModel层交互。</li><li>视图模型(ViewModel) 主要负责业务逻辑的处理，同时与 Model 层 和 View层交互。与MVP的Presenter相比，ViewModel不再依赖View，使得解耦更加彻底。</li></ul><p>MVVM 架构的结构图如下。</p><p><img src="https://raw.githubusercontent.com/zhpanvip/images/master/project/article/5005.webp" alt="image.png"></p><p>MVVM架构的本质是数据驱动，它的最大的特点是单向依赖。MVVM架构通过观察者模式让ViewModel与View解耦，实现了View依赖ViewModel，ViewModel依赖Model的单向依赖。</p><p>接下来我们仍然以登录为例，通过观察者模式来实现MVVM的架构代码。</p><h4 id="（1）观察者模式"><a href="#（1）观察者模式" class="headerlink" title="（1）观察者模式"></a>（1）观察者模式</h4><p>由于 MVVM 架构需要将 ViewModel 与 View 解耦。因此，这里可以使用观察者模式来实现。下面实现观察者模式的代码。</p><ul><li>实现观察者接口</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Observer</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-comment">// 成功的回调</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onSuccess</span><span class="hljs-params">(T data)</span></span>;<br><br>    <span class="hljs-comment">// 失败的回调</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onFailed</span><span class="hljs-params">(String msg)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>抽象被观察者</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Observable</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-comment">// 注册观察者</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">register</span><span class="hljs-params">(Observer observer)</span></span>;<br><br>    <span class="hljs-comment">// 取消注册</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">unregister</span><span class="hljs-params">(Observer observer)</span></span>;<br><br>    <span class="hljs-comment">// 数据改变（设置成功数据）</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setValue</span><span class="hljs-params">(T data)</span> </span>&#123;<br><br>    &#125;<br><br>    <span class="hljs-comment">// 失败，设置失败原因</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onFailed</span><span class="hljs-params">(String msg)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里我们需要注意被观察者Observable中的setValue方法被设置成了protect。意味着如果View层拿到的是Observable实例，则无法调用setValue来设置数据，以此来保证代码的安全性。</p><ul><li>被观察者具体实现</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginObservable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Observable</span>&lt;<span class="hljs-title">User</span>&gt; </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> List&lt;Observer&lt;User&gt;&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><br>    <span class="hljs-keyword">private</span> User user;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">register</span><span class="hljs-params">(Observer&lt;User&gt; observer)</span> </span>&#123;<br>        list.add(observer);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unregister</span><span class="hljs-params">(Observer&lt;User&gt; observer)</span> </span>&#123;<br>        liset.remove(observer);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setValue</span><span class="hljs-params">(User user)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.user = user;<br>        <span class="hljs-keyword">for</span> (Observer observer : list) &#123;<br>            observer.onSuccess(user);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onFailed</span><span class="hljs-params">(String msg)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (Observer observer : list) &#123;<br>            observer.onFailed(msg);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在被观察者的实现类中setValue方法被设置为了public，意味着如果是LoginObservable，那么可以通过setValue来对其设置数据。</p><h4 id="（2）Model-层代码实现"><a href="#（2）Model-层代码实现" class="headerlink" title="（2）Model 层代码实现"></a>（2）Model 层代码实现</h4><p>Model层代码与MVP/MVC的实现基本一致，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginModel</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">login</span><span class="hljs-params">(String username, String password, LoginObservable observable)</span> </span>&#123;<br>        RetrofitManager.getApiService()<br>                .login(username, password)<br>                .enqueue(<span class="hljs-keyword">new</span> Callback&lt;User&gt;() &#123;<br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onResponse</span><span class="hljs-params">(Call&lt;User&gt; call, Response&lt;User&gt; response)</span> </span>&#123;<br>                        observable.setValue(response.data);<br>                    &#125;<br><br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onFailed</span><span class="hljs-params">(Exception e)</span> </span>&#123;<br>                        observable.onFailed(e.getMessage());<br>                    &#125;<br>                &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>需要注意的是LoginModel的login方法中接收的是LoginObservable类型，因此这里可以通过setValue来设置数据。</p><h4 id="（3）ViewModel-层实现"><a href="#（3）ViewModel-层实现" class="headerlink" title="（3）ViewModel 层实现"></a>（3）ViewModel 层实现</h4><p>ViewModel层需要持有Model层，并且ViewModel层持有一个LoginObservable，并开放一个getObservable的方法供View层使用。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginViewModel</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> LoginObservable observable;<br><br>    <span class="hljs-keyword">private</span> LoginModel loginModel;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LoginViewModel</span><span class="hljs-params">()</span> </span>&#123;<br>        loginModel = <span class="hljs-keyword">new</span> LoginModel();<br>        observable = <span class="hljs-keyword">new</span> LoginObservable();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">login</span><span class="hljs-params">(String username, String password)</span> </span>&#123;<br>        loginModel.login(username, password, observable);<br>    &#125;<br><br>    <span class="hljs-comment">// 这里返回值是父类Observable，即View层得到的Observable无法调用setValue</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Observable <span class="hljs-title">getObservable</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> observable;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里需要注意的是getObservable方法的返回值是Observable，意味着View层只能调用register方法来观察数据改变，而无法通过setValue来设置数据。</p><h4 id="（4）View-层代码实现"><a href="#（4）View-层代码实现" class="headerlink" title="（4）View 层代码实现"></a>（4）View 层代码实现</h4><p>View层持有ViewModel，用户触发登录事件通过View层交给Model处理，Model层在登录成后将数据交给ViewModel中的观察者。因此，View层只需要获取到ViewModel层的观察者并观察到数据改变后更新UI即可。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AppCompatActivity</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Observer</span>&lt;<span class="hljs-title">User</span>&gt; </span>&#123;<br><br>    <span class="hljs-keyword">private</span> LoginViewModel viewModel;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState);<br>        setContentView(R.layout.activity_main);<br><br>        viewModel = <span class="hljs-keyword">new</span> LoginViewModel();<br>        viewModel.getObservable().register(<span class="hljs-keyword">this</span>);<br>        findViewById(R.id.button).setOnClickListener(v -&gt; &#123;<br>            String username = findViewById(R.id.et_username).getText().toString();<br>            String password = findViewById(R.id.et_password).getText().toString();<br>            viewModel.login(username, password);<br>        &#125;);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onDestroy</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.onDestory();<br>        viewModel.getObservable().unregister(<span class="hljs-keyword">this</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onSuccess</span><span class="hljs-params">(User user)</span> </span>&#123;<br>        <span class="hljs-comment">// fetch data success,update UI.</span><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onFailed</span><span class="hljs-params">(String message)</span> </span>&#123;<br>        <span class="hljs-comment">// fetch data failed,update UI.</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到我们通过观察者模式实现了View-&gt;ViewModel-&gt;<br>Model的单向依赖。相比于MVP，MVVM解耦的更加纯粹。但是，上边的观察者模式是我们自己实现的，如果直接用到项目中肯定是不稳妥的。上面我们提到Google已经为我们提供了一套Jetpack组件来帮助开发者实现MVVM架构。那接下来我们就来认识一下通过Jetpack实现的MVVM架构。</p><h2 id="二、使用-Jetpack-组件封装-MVVM-架构"><a href="#二、使用-Jetpack-组件封装-MVVM-架构" class="headerlink" title="二、使用 Jetpack 组件封装 MVVM 架构"></a>二、使用 Jetpack 组件封装 MVVM 架构</h2><p>如果你已经看到这里了，相信你对项目架构已经有了一定的认识。这里需要再强调一点架构是一种思想，它与我们使用什么工具来实现没有关系。就像上一章中我们通过自己写的观察者模式来实现MVVM一样，只要遵循了这个架构思想，那它就属于这一架构。Google官方推出的这些组件可以更高效的帮助我们来实现MVVM。</p><h3 id="1-Jetpack-MVVM-简介"><a href="#1-Jetpack-MVVM-简介" class="headerlink" title="1. Jetpack MVVM 简介"></a>1. Jetpack MVVM 简介</h3><p>MVVM 是 Google 官方推荐的框架。为此，Google 提供了一系列实现 MVVM 的工具，这些工具都被包含在Jetpack 组件中，例如 LiveData、ViewModel以及<br>DataBinding 等。下面是官方给的一个通过Jetpack组件实现的 MVVM 架构图。</p><p><img src="https://raw.githubusercontent.com/zhpanvip/images/master/project/article/5006.webp"></p><p>这张图与我们上一章的MVVM结构图是一致的，只不过这里融入了Jetpack组件。可以看到图中的箭头都是单向的，View层指向了ViewModel层，表示View层持有ViewModel层的引用，但ViewModel层不持有View层。ViewModel层持有Repository层，但Repository层不会持有ViewModel。这张图与MVVM的对应关系如下：</p><ul><li>视图(View) 对应图中的Activity/Fragment，包含了布局文件等于界面相关的东西；</li><li>视图模型(ViewModel) 对应图中的Jetpack ViewModel<br>与LiveData，用于持有与UI相关的数据，且能保证在旋转屏幕后不丢失数据。另外还提供了给View层调用的接口以及和Repository通信的接口；</li><li>模型层(Model) 对应图中的 Repository，包含本地数据与服务端数据。</li></ul><h3 id="2-MVVM-框架代码封装"><a href="#2-MVVM-框架代码封装" class="headerlink" title="2. MVVM 框架代码封装"></a>2. MVVM 框架代码封装</h3><p>在了解了Jetpack MVVM后，为了更加高效的开发我们通常会做一些基础封装。例如如何结合网络请求与数据库来获取数据、Loading的显示逻辑等。本章内容要求读者对Jetpack<br>ViewModel、LiveData等组件有一定的了解。</p><h4 id="2-1-网络层封装"><a href="#2-1-网络层封装" class="headerlink" title="2.1 网络层封装"></a>2.1 网络层封装</h4><p>针对服务器返回的数据进行封装，可以抽出来一个带有泛型的Response基类。如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseResponse</span>&lt;<span class="hljs-type">T</span>&gt;</span>(<br>    <span class="hljs-keyword">var</span> errorCode: <span class="hljs-built_in">Int</span> = -<span class="hljs-number">1</span>,<br>    <span class="hljs-keyword">var</span> errorMsg: String? = <span class="hljs-literal">null</span>,<br>    <span class="hljs-keyword">var</span> <span class="hljs-keyword">data</span>: T? = <span class="hljs-literal">null</span>,<br>    <span class="hljs-keyword">var</span> dataState: DataState? = <span class="hljs-literal">null</span>,<br>    <span class="hljs-keyword">var</span> exception: Throwable? = <span class="hljs-literal">null</span>,<br>) &#123;<br>    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> &#123;<br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> ERROR_CODE_SUCCESS = <span class="hljs-number">0</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">val</span> success: <span class="hljs-built_in">Boolean</span><br>        <span class="hljs-keyword">get</span>() = errorCode == ERROR_CODE_SUCCESS<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 网络请求状态</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">enum</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DataState</span> </span>&#123;<br>    STATE_LOADING, <span class="hljs-comment">// 开始请求</span><br>    STATE_SUCCESS, <span class="hljs-comment">// 服务器请求成功</span><br>    STATE_EMPTY, <span class="hljs-comment">// 服务器返回数据为null</span><br>    STATE_FAILED, <span class="hljs-comment">// 接口请求成功但是服务器返回error</span><br>    STATE_ERROR, <span class="hljs-comment">// 请求失败</span><br>    STATE_FINISH, <span class="hljs-comment">// 请求结束</span><br>&#125;<br></code></pre></td></tr></table></figure><p>对应网络请求的异常情况一般我们都会进行统一处理。这里我们可以放在Observer中进行。 对LiveData 的 Observer进行封装，从而实现Response与异常的统一处理。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ResponseObserver</span>&lt;<span class="hljs-type">T</span>&gt; : <span class="hljs-type">Observer</span>&lt;<span class="hljs-type">BaseResponse&lt;T</span>&gt;&gt; </span>&#123;<br>    <br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onChanged</span><span class="hljs-params">(response: <span class="hljs-type">BaseResponse</span>&lt;<span class="hljs-type">T</span>&gt;?)</span></span> &#123;<br>        response?.let &#123;<br>            <span class="hljs-keyword">when</span> (response.dataState) &#123;<br>                DataState.STATE_SUCCESS, DataState.STATE_EMPTY -&gt; &#123;<br>                    onSuccess(response.<span class="hljs-keyword">data</span>)<br>                &#125;<br>                DataState.STATE_FAILED -&gt; &#123;<br>                    onFailure(response.errorMsg, response.errorCode)<br>                &#125;<br>                DataState.STATE_ERROR -&gt; &#123;<br>                    onException(response.exception)<br>                &#125;<br>                <span class="hljs-keyword">else</span> -&gt; &#123;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onException</span><span class="hljs-params">(exception: <span class="hljs-type">Throwable</span>?)</span></span> &#123;<br>        ToastUtils.showToast(exception.toString())<br>    &#125;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 请求成功</span><br><span class="hljs-comment">     *  <span class="hljs-doctag">@param</span>  data 请求数据</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">abstract</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onSuccess</span><span class="hljs-params">(<span class="hljs-keyword">data</span>: <span class="hljs-type">T</span>?)</span></span><br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 请求失败</span><br><span class="hljs-comment">     *  <span class="hljs-doctag">@param</span>  errorCode 错误码</span><br><span class="hljs-comment">     *  <span class="hljs-doctag">@param</span>  errorMsg 错误信息</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">open</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onFailure</span><span class="hljs-params">(errorMsg: <span class="hljs-type">String</span>?, errorCode: <span class="hljs-type">Int</span>)</span></span> &#123;<br>        ToastUtils.showToast(<span class="hljs-string">&quot;Login Failed,errorCode:<span class="hljs-variable">$errorCode</span>,errorMsg:<span class="hljs-variable">$errorMsg</span>&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>封装 RetrofitCreator 用来创建 API Service。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">object</span> RetrofitCreator &#123;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> mOkClient = OkHttpClient.Builder()<br>        .callTimeout(Config.DEFAULT_TIMEOUT, TimeUnit.MILLISECONDS)<br>        .connectTimeout(Config.DEFAULT_TIMEOUT, TimeUnit.MILLISECONDS)<br>        .readTimeout(Config.DEFAULT_TIMEOUT, TimeUnit.MILLISECONDS)<br>        .writeTimeout(Config.DEFAULT_TIMEOUT, TimeUnit.MILLISECONDS)<br>        .retryOnConnectionFailure(<span class="hljs-literal">true</span>)<br>        .followRedirects(<span class="hljs-literal">false</span>)<br>        .addInterceptor(HttpHeaderInterceptor())<br>        .addInterceptor(LogInterceptor())<br>        .build()<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getRetrofitBuilder</span><span class="hljs-params">(baseUrl: <span class="hljs-type">String</span>)</span></span>: Retrofit.Builder &#123;<br>        <span class="hljs-keyword">return</span> Retrofit.Builder()<br>            .baseUrl(baseUrl)<br>            .client(mOkClient)<br>            .addConverterFactory(GsonConverterFactory.create())<br>    &#125;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Create Api service</span><br><span class="hljs-comment">     *  <span class="hljs-doctag">@param</span>  cls Api Service</span><br><span class="hljs-comment">     *  <span class="hljs-doctag">@param</span>  baseUrl Base Url</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">getApiService</span><span class="hljs-params">(cls: <span class="hljs-type">Class</span>&lt;<span class="hljs-type">T</span>&gt;, baseUrl: <span class="hljs-type">String</span>)</span></span>: T &#123;<br>        <span class="hljs-keyword">val</span> retrofit = getRetrofitBuilder(<br>            baseUrl<br>        ).build()<br>        <span class="hljs-keyword">return</span> retrofit.create(cls)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-2-Model-层封装"><a href="#2-2-Model-层封装" class="headerlink" title="2.2 Model 层封装"></a>2.2 Model 层封装</h4><p>官方代码中的 Model 层是通过Repository实现的，为了减少模板代码，我们可以封装 BaseRepository 来处理网络请求。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">open</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseRepository</span> </span>&#123;<br>    <br>    <span class="hljs-comment">// Loading 状态的 LiveData</span><br>    <span class="hljs-keyword">val</span> loadingStateLiveData: MutableLiveData&lt;LoadingState&gt; <span class="hljs-keyword">by</span> lazy &#123;<br>        MutableLiveData&lt;LoadingState&gt;()<br>    &#125;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 发起请求</span><br><span class="hljs-comment">     *  <span class="hljs-doctag">@param</span>  block 真正执行的函数回调</span><br><span class="hljs-comment">     *  <span class="hljs-doctag">@param</span> responseLiveData 观察请求结果的LiveData</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T : Any&gt;</span> <span class="hljs-title">executeRequest</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">        block: <span class="hljs-type">suspend</span> () -&gt; <span class="hljs-type">BaseResponse</span>&lt;<span class="hljs-type">T</span>&gt;,</span></span><br><span class="hljs-function"><span class="hljs-params">        responseLiveData: <span class="hljs-type">ResponseMutableLiveData</span>&lt;<span class="hljs-type">T</span>&gt;,</span></span><br><span class="hljs-function"><span class="hljs-params">        showLoading: <span class="hljs-type">Boolean</span> = <span class="hljs-literal">true</span>,</span></span><br><span class="hljs-function"><span class="hljs-params">        loadingMsg: <span class="hljs-type">String</span>? = <span class="hljs-literal">null</span>,</span></span><br><span class="hljs-function"><span class="hljs-params">    )</span></span> &#123;<br>        <span class="hljs-keyword">var</span> response = BaseResponse&lt;T&gt;()<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span> (showLoading) &#123;<br>                loadingStateLiveData.postValue(LoadingState(loadingMsg, DataState.STATE_LOADING))<br>            &#125;<br>            response = block.invoke()<br>            <span class="hljs-keyword">if</span> (response.errorCode == BaseResponse.ERROR_CODE_SUCCESS) &#123;<br>                <span class="hljs-keyword">if</span> (isEmptyData(response.<span class="hljs-keyword">data</span>)) &#123;<br>                    response.dataState = DataState.STATE_EMPTY<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    response.dataState = DataState.STATE_SUCCESS<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                response.dataState = DataState.STATE_FAILED<br><span class="hljs-comment">// throw ServerResponseException(response.errorCode, response.errorMsg)</span><br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (e: Exception) &#123;<br>            response.dataState = DataState.STATE_ERROR<br>            response.exception = e<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            responseLiveData.postValue(response)<br>            <span class="hljs-keyword">if</span> (showLoading) &#123;<br>                loadingStateLiveData.postValue(LoadingState(loadingMsg, DataState.STATE_FINISH))<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">isEmptyData</span><span class="hljs-params">(<span class="hljs-keyword">data</span>: <span class="hljs-type">T</span>?)</span></span>: <span class="hljs-built_in">Boolean</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">data</span> == <span class="hljs-literal">null</span> || <span class="hljs-keyword">data</span> <span class="hljs-keyword">is</span> List&lt;*&gt; &amp;&amp; (<span class="hljs-keyword">data</span> <span class="hljs-keyword">as</span> List&lt;*&gt;).isEmpty()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-3-ViewModel-层封装"><a href="#2-3-ViewModel-层封装" class="headerlink" title="2.3 ViewModel 层封装"></a>2.3 ViewModel 层封装</h4><p>如果不做封装，ViewModel层也会有模板代码。这里将通用代码在 BaseViewModel 中完成。BaseViewModel 需要持有 Repository。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseViewModel</span>&lt;<span class="hljs-type">T : BaseRepository</span>&gt; : <span class="hljs-type">ViewModel</span></span>() &#123;<br>    <span class="hljs-keyword">val</span> repository: T <span class="hljs-keyword">by</span> lazy &#123;<br>        createRepository()<br>    &#125;<br>    <br>    <span class="hljs-keyword">val</span> loadingDataState: LiveData&lt;LoadingState&gt; <span class="hljs-keyword">by</span> lazy &#123;<br>        repository.loadingStateLiveData<br>    &#125;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 创建Repository</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Suppress(<span class="hljs-meta-string">&quot;UNCHECKED_CAST&quot;</span>)</span><br>    <span class="hljs-keyword">open</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">createRepository</span><span class="hljs-params">()</span></span>: T &#123;<br>        <span class="hljs-keyword">val</span> baseRepository = findActualGenericsClass&lt;T&gt;(BaseRepository::<span class="hljs-keyword">class</span>.java)<br>            ?: <span class="hljs-keyword">throw</span> NullPointerException(<span class="hljs-string">&quot;Can not find a BaseRepository Generics in <span class="hljs-subst">$&#123;javaClass.simpleName&#125;</span>&quot;</span>)<br>        <span class="hljs-keyword">return</span> baseRepository.newInstance()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-4-View-层封装"><a href="#2-4-View-层封装" class="headerlink" title="2.4 View 层封装"></a>2.4 View 层封装</h4><p>BaseActivity/BaseFragment 中持有 ViewModel，同时根据 LoadingState 处理 Loading 的显示与隐藏。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseActivity</span>&lt;<span class="hljs-type">VM : BaseViewModel&lt;*</span>&gt;, <span class="hljs-type">VB : ViewBinding&gt; : AppCompatActivity</span></span>() &#123;<br>    <br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">val</span> viewModel <span class="hljs-keyword">by</span> lazy &#123;<br>        createViewModel()<br>    &#125;<br>    <br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">val</span> binding <span class="hljs-keyword">by</span> lazy &#123;<br>        createViewBinding()<br>    &#125;<br>    <br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)<br>        setContentView(binding.root)<br>        viewModel.loadingDataState.observe(<span class="hljs-keyword">this</span>) &#123;<br>            <span class="hljs-keyword">when</span> (it.state) &#123;<br>                DataState.STATE_LOADING -&gt;<br>                    showLoading(it.msg)<br>                <span class="hljs-keyword">else</span> -&gt;<br>                    dismissLoading()<br>            &#125;<br>        &#125;<br>        onActivityCreated(savedInstanceState)<br>    &#125;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Activity content view created.</span><br><span class="hljs-comment">     *  <span class="hljs-doctag">@param</span>  savedInstanceState savedInstanceState</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">abstract</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onActivityCreated</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span><br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 显示Loading</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">open</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">showLoading</span><span class="hljs-params">(msg: <span class="hljs-type">String</span>? = <span class="hljs-literal">null</span>)</span></span> &#123;<br>        ToastUtils.showToast(<span class="hljs-string">&quot;showLoading&quot;</span>)<br>    &#125;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 隐藏Loading</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">open</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">dismissLoading</span><span class="hljs-params">()</span></span> &#123;<br>        ToastUtils.showToast(<span class="hljs-string">&quot;hideLoading&quot;</span>)<br>    &#125;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Create ViewBinding</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Suppress(<span class="hljs-meta-string">&quot;UNCHECKED_CAST&quot;</span>)</span><br>    <span class="hljs-keyword">open</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">createViewBinding</span><span class="hljs-params">()</span></span>: VB &#123;<br>        <span class="hljs-keyword">val</span> actualGenericsClass = findActualGenericsClass&lt;VB&gt;(ViewBinding::<span class="hljs-keyword">class</span>.java)<br>            ?: <span class="hljs-keyword">throw</span> NullPointerException(<span class="hljs-string">&quot;Can not find a ViewBinding Generics in <span class="hljs-subst">$&#123;javaClass.simpleName&#125;</span>&quot;</span>)<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">val</span> inflate = actualGenericsClass.getDeclaredMethod(<span class="hljs-string">&quot;inflate&quot;</span>, LayoutInflater::<span class="hljs-keyword">class</span>.java)<br>            <span class="hljs-keyword">return</span> inflate.invoke(<span class="hljs-literal">null</span>, layoutInflater) <span class="hljs-keyword">as</span> VB<br>        &#125; <span class="hljs-keyword">catch</span> (e: NoSuchMethodException) &#123;<br>            e.printStackTrace()<br>        &#125; <span class="hljs-keyword">catch</span> (e: IllegalAccessException) &#123;<br>            e.printStackTrace()<br>        &#125; <span class="hljs-keyword">catch</span> (e: InvocationTargetException) &#123;<br>            e.printStackTrace()<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Create ViewModel</span><br><span class="hljs-comment">     *  <span class="hljs-doctag">@return</span>  ViewModel</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Suppress(<span class="hljs-meta-string">&quot;UNCHECKED_CAST&quot;</span>)</span><br>    <span class="hljs-keyword">open</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">createViewModel</span><span class="hljs-params">()</span></span>: VM &#123;<br>        <span class="hljs-keyword">val</span> actualGenericsClass = findActualGenericsClass&lt;VM&gt;(BaseViewModel::<span class="hljs-keyword">class</span>.java)<br>            ?: <span class="hljs-keyword">throw</span> NullPointerException(<span class="hljs-string">&quot;Can not find a ViewModel Generics in <span class="hljs-subst">$&#123;javaClass.simpleName&#125;</span>&quot;</span>)<br>        <span class="hljs-keyword">if</span> (Modifier.isAbstract(actualGenericsClass.modifiers)) &#123;<br>            <span class="hljs-keyword">throw</span> IllegalStateException(<span class="hljs-string">&quot;<span class="hljs-variable">$actualGenericsClass</span> is an abstract class,abstract ViewModel class can not create a instance!&quot;</span>)<br>        &#125;<br>        <span class="hljs-comment">// 判断如果是 BaseAndroidViewModel，则使用 AppViewModelFactory 来生成</span><br>        <span class="hljs-keyword">if</span> (BaseAndroidViewModel::<span class="hljs-keyword">class</span>.java.isAssignableFrom(actualGenericsClass)) &#123;<br>            <span class="hljs-keyword">return</span> ViewModelProvider(<span class="hljs-keyword">this</span>, AppViewModelFactory(application))[actualGenericsClass]<br>        &#125;<br>        <span class="hljs-keyword">return</span> ViewModelProvider(<span class="hljs-keyword">this</span>)[actualGenericsClass]<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>创建 ViewModel 的过程是在 BaseActivity 中根据子类的泛型自动生成的。这里使用了反射的方式来实现。如果觉得影响性能可以在子类中重写<code>createViewModel</code>函数来自行生成<br>ViewModel。</p><p>另外，如果需要使用带有 Application 的ViewModel，可以继承 BaseAndroidViewModel,它的实现参照了 AndroidViewModel。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseAndroidViewModel</span>&lt;<span class="hljs-type">T : BaseRepository</span>&gt;</span>(<span class="hljs-meta">@field:SuppressLint</span>(<span class="hljs-string">&quot;StaticFieldLeak&quot;</span>) <span class="hljs-keyword">var</span> application: Application) : BaseViewModel&lt;T&gt;()<br></code></pre></td></tr></table></figure><p>这里创建 BaseAndroidViewModel 需要用到 AppViewModelFactory。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppViewModelFactory</span></span>(<span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> application: Application) : ViewModelProvider.NewInstanceFactory() &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T : ViewModel&gt;</span> <span class="hljs-title">create</span><span class="hljs-params">(modelClass: <span class="hljs-type">Class</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span>: T &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">if</span> (BaseAndroidViewModel::<span class="hljs-keyword">class</span>.java.isAssignableFrom(modelClass)) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                modelClass.getConstructor(Application::<span class="hljs-keyword">class</span>.java).newInstance(application)<br>            &#125; <span class="hljs-keyword">catch</span> (e: NoSuchMethodException) &#123;<br>                <span class="hljs-keyword">throw</span> IllegalStateException(<span class="hljs-string">&quot;Cannot create an instance of <span class="hljs-variable">$modelClass</span>&quot;</span>, e)<br>            &#125; <span class="hljs-keyword">catch</span> (e: IllegalAccessException) &#123;<br>                <span class="hljs-keyword">throw</span> IllegalStateException(<span class="hljs-string">&quot;Cannot create an instance of <span class="hljs-variable">$modelClass</span>&quot;</span>, e)<br>            &#125; <span class="hljs-keyword">catch</span> (e: InstantiationException) &#123;<br>                <span class="hljs-keyword">throw</span> IllegalStateException(<span class="hljs-string">&quot;Cannot create an instance of <span class="hljs-variable">$modelClass</span>&quot;</span>, e)<br>            &#125; <span class="hljs-keyword">catch</span> (e: InvocationTargetException) &#123;<br>                <span class="hljs-keyword">throw</span> IllegalStateException(<span class="hljs-string">&quot;Cannot create an instance of <span class="hljs-variable">$modelClass</span>&quot;</span>, e)<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">super</span>.create(modelClass)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>假如 LoginViewModel 实现了 BaseAndroidViewModel ，那么使用 ViewModelProvider 创建 LoginViewModel 时必须传入<br>AppViewModelFactory 参数，而不是Jetpack ViewModel 库中的 AndroidViewModelFactory。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">ViewModelProvider(<span class="hljs-keyword">this</span>, AppViewModelFactory(application))[LoginViewModel::<span class="hljs-keyword">class</span>.java]<br></code></pre></td></tr></table></figure><h3 id="3-MVVM-封装后的实例应用"><a href="#3-MVVM-封装后的实例应用" class="headerlink" title="3. MVVM 封装后的实例应用"></a>3. MVVM 封装后的实例应用</h3><p>在完成上述封装后，我们来看下如何实现登录的逻辑。</p><h4 id="3-1-实现-Repository"><a href="#3-1-实现-Repository" class="headerlink" title="3.1 实现 Repository"></a>3.1 实现 Repository</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginRepository</span> : <span class="hljs-type">BaseRepository</span></span>() &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Login</span><br><span class="hljs-comment">     *  <span class="hljs-doctag">@param</span>  username 用户名</span><br><span class="hljs-comment">     *  <span class="hljs-doctag">@param</span>  password 密码</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">login</span><span class="hljs-params">(username: <span class="hljs-type">String</span>, password: <span class="hljs-type">String</span>, responseLiveData: <span class="hljs-type">ResponseMutableLiveData</span>&lt;<span class="hljs-type">LoginResponse</span>&gt;, showLoading: <span class="hljs-type">Boolean</span> = <span class="hljs-literal">true</span>)</span></span> &#123;<br>        executeRequest(&#123;<br>            RetrofitManager.apiService.login(username, password)<br>        &#125;, responseLiveData, showLoading)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>RetrofitManager 用来创建管理 API Service：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">object</span> RetrofitManager &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> BASE_URL = <span class="hljs-string">&quot;https://www.wanandroid.com/&quot;</span><br>    <br>    <span class="hljs-keyword">val</span> apiService: ApiService <span class="hljs-keyword">by</span> lazy &#123;<br>        RetrofitCreator.createApiService(<br>            ApiService::<span class="hljs-keyword">class</span>.java, BASE_URL<br>        )<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-2-ViewModel-实例"><a href="#3-2-ViewModel-实例" class="headerlink" title="3.2 ViewModel 实例"></a>3.2 ViewModel 实例</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginViewModel</span> : <span class="hljs-type">BaseViewModel</span>&lt;<span class="hljs-type">LoginRepository</span>&gt;</span>() &#123;<br>    <span class="hljs-comment">// 提供给Model层设置数据</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> _loginLiveData: ResponseMutableLiveData&lt;LoginResponse&gt; = ResponseMutableLiveData()<br>    <br>    <span class="hljs-comment">// 提供给View层观察数据</span><br>    <span class="hljs-keyword">val</span> loginLiveData: ResponseLiveData&lt;LoginResponse&gt; = _loginLiveData<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Login</span><br><span class="hljs-comment">     *  <span class="hljs-doctag">@param</span>  username 用户名</span><br><span class="hljs-comment">     *  <span class="hljs-doctag">@param</span>  password 密码</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">login</span><span class="hljs-params">(username: <span class="hljs-type">String</span>, password: <span class="hljs-type">String</span>)</span></span> &#123;<br>        viewModelScope.launch &#123;<br>            repository.login(username, password, _loginLiveData)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-3-Activity-Fragment-实例"><a href="#3-3-Activity-Fragment-实例" class="headerlink" title="3.3 Activity/Fragment 实例"></a>3.3 Activity/Fragment 实例</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginActivity</span> : <span class="hljs-type">BaseActivity</span>&lt;<span class="hljs-type">LoginViewModel, ActivityBizAMainBinding</span>&gt;</span>() &#123;<br>    <br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onActivityCreated</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> &#123;<br>        binding.tvLogin.setOnClickListener &#123;<br>            viewModel.login(<span class="hljs-string">&quot;110120&quot;</span>, <span class="hljs-string">&quot;123456&quot;</span>)<br>        &#125;<br>        <br>        viewModel.loginLiveData.observe(<span class="hljs-keyword">this</span>, <span class="hljs-keyword">object</span> : ResponseObserver&lt;LoginResponse&gt;() &#123;<br>            <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onSuccess</span><span class="hljs-params">(<span class="hljs-keyword">data</span>: <span class="hljs-type">LoginResponse</span>?)</span></span> &#123;<br>                <span class="hljs-comment">// Update UI</span><br>            &#125;<br>        &#125;)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里需要注意的是，在Activity里边需要使用不可变的 LiveData,防止开发时候在View层通过 LiveData<br>来setValue/postValue，造成错误的UI更新问题。因此，这里对LiveData做了一些改动,如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ResponseLiveData</span>&lt;<span class="hljs-type">T</span>&gt; : <span class="hljs-type">LiveData</span>&lt;<span class="hljs-type">BaseResponse&lt;T</span>&gt;&gt; </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Creates a MutableLiveData initialized with the given `value`.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     *  <span class="hljs-doctag">@param</span>  value initial value</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">constructor</span>(value: BaseResponse&lt;T&gt;?) : <span class="hljs-keyword">super</span>(value)<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Creates a MutableLiveData with no value assigned to it.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">constructor</span>() : <span class="hljs-keyword">super</span>()<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Adds the given observer to the observers list within the lifespan of the given owner.</span><br><span class="hljs-comment">     * The events are dispatched on the main thread. If LiveData already has data set, it</span><br><span class="hljs-comment">     * will be delivered to the observer.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">observe</span><span class="hljs-params">(owner: <span class="hljs-type">LifecycleOwner</span>, observer: <span class="hljs-type">ResponseObserver</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.observe(owner, observer)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>ResponseLiveData 继承自 LiveData，因此ResponseLiveData是不可变的。除此之外还定义了一个 ResponseMutableLiveData ，这是一个可变的<br>LiveData，代码如下:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ResponseMutableLiveData</span>&lt;<span class="hljs-type">T</span>&gt; : <span class="hljs-type">ResponseLiveData</span>&lt;<span class="hljs-type">T</span>&gt; </span>&#123;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Creates a MutableLiveData initialized with the given `value`.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     *  <span class="hljs-doctag">@param</span>  value initial value</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">constructor</span>(value: BaseResponse&lt;T&gt;?) : <span class="hljs-keyword">super</span>(value)<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Creates a MutableLiveData with no value assigned to it.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">constructor</span>() : <span class="hljs-keyword">super</span>()<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">postValue</span><span class="hljs-params">(value: <span class="hljs-type">BaseResponse</span>&lt;<span class="hljs-type">T</span>&gt;?)</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.postValue(value)<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">setValue</span><span class="hljs-params">(value: <span class="hljs-type">BaseResponse</span>&lt;<span class="hljs-type">T</span>&gt;?)</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.setValue(value)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>至此关于Jetpack MVVM的封装及使用就结束了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇文章比较详细的讲解了Android项目架构从MVC、MVP到MVVM的演化，对三种架构都列举了详细的实现例子。同时针对目前主流的Jetpack<br>MVVM架构进行了封装。当然，由于每个人对于架构的理解并不一定相同，所有文章中避免不了会有与读者理解不一致的地方，欢迎留言讨论。</p>]]></content>
    
    
    <categories>
      
      <category>Android进阶</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MVC</tag>
      
      <tag>MVP</tag>
      
      <tag>MVVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>反思 Android 消息机制设计与实现</title>
    <link href="/2022/06/17/49-analyze-android-message-mechanism/"/>
    <url>/2022/06/17/49-analyze-android-message-mechanism/</url>
    
    <content type="html"><![CDATA[<p><a href="https://juejin.cn/post/6994057245113729038">上篇文章</a>介绍了 Android 中的 Binder 机制。Binder 在 Android 系统中占有着举足轻重的地位，它是 Android 系统中跨进程通信最重要的方式。而另外一个重要的且能与Binder相提并论的角色便是本文要分析的 Handler。Binder 支撑起了 Android 系统进程间的通信，而 Handler 支撑起的则是进程内线程间的通信。同时，Android 应用程序的运行皆依靠 Handler 的消息机制驱动，这其中就包括触摸事件的分发、View的绘制流程、屏幕的刷新机制以及Activity的生命周期等等。</p><p>关于 Handler 其实早在几年前笔者就写过一篇<a href="https://blog.csdn.net/qq_20521573/article/details/77919141?spm=1001.2014.3001.5502">《追根溯源—— 探究Handler的实现原理》</a>的文章。 但是鉴于当时对于 Handler 的理解并不那么深刻，所以这篇文章的内容与网上大多数写 Handler 的文章一样仅仅是源码分析，对 Android 消息机制没有一个深刻的理解和认识。当然，并不是说这样的文章不好，对于初学者来说更适合阅读这样的文章的。所以，如果你对于 Handler 还没有太熟悉的话，不妨先读一读。</p><p>如今，作为一个已有多年 Android 开发经验的从业者，在阅读了大量的 framework 源码之后，对于 Android 的消息机制有了一些更加深刻的认识，这是要写这篇文章的原因。</p><h2 id="一、从“生产者-消费者”模型说起"><a href="#一、从“生产者-消费者”模型说起" class="headerlink" title="一、从“生产者-消费者”模型说起"></a>一、从“生产者-消费者”模型说起</h2><p>关注笔者比较久的同学可能看过我之前写过的一篇文章 <a href="https://juejin.cn/post/6980002998361522190">《深入理解Java线程的等待与唤醒机制》</a>。在这篇文章中为了分析 synchronized 锁的等待与唤醒机制，举了一个 “生产者-消费者” 问题的例子。</p><blockquote><p>“生产者-消费者” 问题又称有限缓冲问题（Bounded-buffer problem），是一个多线程同步问题的经典案例。该问题描述了共享固定大小缓冲区的两个线程——即所谓的“生产者”和“消费者”——在实际运行时会发生的问题。生产者的主要作用是生成一定量的数据放到缓冲区中，然后重复此过程。与此同时，消费者会在缓冲区消耗这些数据。该问题的关键就是要保证生产者不会在缓冲区满时加入数据，消费者也不会在缓冲区中空时消耗数据。<br>”生产者-消费者“模型图如下：</p></blockquote><p><img src="https://raw.githubusercontent.com/zhpanvip/images/master/project/article/thread/wait_notify.png" alt="生产者-消费者"></p><p>可以看得出来，图中的 “生产者”和”消费者”处于两个不同的线程，但是他们共用了同一个队列。生产者在完成数据的生产后会通过 notify 方法唤醒消费者线程，当队列满的时候，生产者线程会调用 wait 方法来阻塞自身。同时，消费者线程在被唤醒后则会从队列中取出数据，并通过 notify 方法唤醒生产者线程继续生产数据。当队列中的数据被取空的时候，消费者线程同样会调用 wait 方法阻塞自身。</p><p>我们仍然拿生产面包的例子来看。首先需要有一个存放面包的容器（缓冲队列），可以将其命名为BreadContainer，提供放入面包和取出面包的方法。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BreadContainer</span> </span>&#123;<br><br>    LinkedList&lt;Bread&gt; list = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>    <span class="hljs-comment">// 容器容量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> CAPACITY = <span class="hljs-number">10</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 放入面包</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(Bread bread)</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (list.size() == CAPACITY) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 如果容器已满，则阻塞生产者线程</span><br>                wait();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>        list.add(bread);<br>        <span class="hljs-comment">// 面包生产成功后通知消费者线程</span><br>        notify();<br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; product a bread&quot;</span> + bread.toString() + <span class="hljs-string">&quot; size = &quot;</span> + list.size());<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 取出面包</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> Bread <span class="hljs-title">take</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (list.isEmpty()) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 如果容器为空，则阻塞消费者线程</span><br>                wait();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>        Bread bread = list.removeFirst();<br>        <span class="hljs-comment">// 消费后通知生产者生产面包</span><br>        notify();<br>        System.out.println(<span class="hljs-string">&quot;Consumer &quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot; consume a bread&quot;</span> + bread.toString() + <span class="hljs-string">&quot; size = &quot;</span> + list.size());<br>        <span class="hljs-keyword">return</span> bread;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来实现生产者，让生产者来生产面包，并提供面包容器。</p><p>来生产面包，并提供面包容器。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">// 生产者</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Producer</span> &#123;</span><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> BreadContainer container;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Producer</span><span class="hljs-params">()</span> </span>&#123;<br>        container = <span class="hljs-keyword">new</span> BreadContainer();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> BreadContainer <span class="hljs-title">getContainer</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> container;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">makeBread</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 生产者生产面包</span><br>        container.<span class="hljs-built_in">put</span>(<span class="hljs-keyword">new</span> Bread());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>实现消费者则负责从面包容器中取出面包进行消费</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-comment">// 消费者</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Consumer</span> </span>&#123;<br>    BreadContainer <span class="hljs-keyword">container</span>;<br><br>    <span class="hljs-keyword">public</span> Consumer(BreadContainer <span class="hljs-keyword">container</span>)&#123;<br>        <span class="hljs-keyword">this</span>.<span class="hljs-keyword">container</span> = <span class="hljs-keyword">container</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> takeBread() &#123;<br>        <span class="hljs-keyword">for</span> (; ; ) &#123;<br>            Bread bread = <span class="hljs-keyword">container</span>.take();<br>            bread.eat();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>完成生产者与消费者两个角色后，我们可以一个测试代码，如下:</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public static void main(String<span class="hljs-literal">[]</span> args) &#123;<br><br>    <span class="hljs-comment">// 实例化生产者</span><br>    Producer producer = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Producer()</span>;<br>    <span class="hljs-comment">// 实例化消费者</span><br>    Consumer consumer = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Consumer(<span class="hljs-params">producer</span>.<span class="hljs-params">getContainer</span>()</span>);<br>    <span class="hljs-comment">// 开启生产者线程</span><br>    <span class="hljs-keyword">new</span> <span class="hljs-constructor">Thread(()</span> -&gt; &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100000</span>; i++) &#123;<br>            producer.make<span class="hljs-constructor">Bread()</span>;<br>        &#125;<br>    &#125;).start<span class="hljs-literal">()</span>;<br><br>    <span class="hljs-comment">// 消费者在主线程消费   </span><br>    consumer.take<span class="hljs-constructor">Bread()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>看到上边这段代码是否有种似曾相识的感觉？如果没有那么不妨去看看Android源码中ActivityThread 的main方法的实现，你一定会恍然大悟！</p><p>”生产者-消费者“模型的案例在平时的开发中是很常见的。例如 Rxjava 的流控制就是典型的”生产者-消费者“模型，除此之外还有线程池的内部实现，以及 Android 系统中输入事件的采集与派发都是基于”生产者-消费者“模型设计的。</p><p>上文提到”生产者-消费者“模型解决的是多个线程共享内存的有限缓冲问题。但其实它还解决了另外一个重要问题，即实现了线程间的通信。在生产与消费的过程中由于共用了同一个缓冲队列，”生产者“产生的数据从生产者线程传递给了消费者线程，对缓冲队列内的数据而言就实现了线程的切换。</p><p>了解了“生产者-消费者”模型之后对于 Android 理解消息机制的设计思想会有很大的帮助。</p><h2 id="二、设计消息机制的框架"><a href="#二、设计消息机制的框架" class="headerlink" title="二、设计消息机制的框架"></a>二、设计消息机制的框架</h2><p>现在让我们回到 Android 来想一下 Android 中的场景。在文章开头已经提到 Android 应用中触摸事件的分发、View的绘制、屏幕的刷新以及 Activity 的生命周期等都是基于消息实现的。这意味着在 Android 应用中随时都在产生大量的 Message，同时也有大量的 Message 被消费掉。</p><p>另外我们都知道在 Android 系统中，UI更新只能在主线程中进行。因此，为了更流畅的页面渲染，所有的耗时操作包括网络请求、文件读写、资源文件的解析等都应该放到子线程中。在这一场景下，线程间的通信就显得尤为重要。因为我们需要在网络请求、文件读写或者资源解析后将得到的数据交给主线程去进行页面渲染。</p><p>那在这样的背景下如果让我们作为 Android 系统的设计者，会如何设计并实现 Android 的消息机制，让其即满足具有缓冲功能又能实现线程切换的能力呢？</p><p>有了第一章的知识后我想你一定会很自然的想到使用”生产者-消费者“模型来实现。因为这一模型既能解决数据缓冲问题，又实现了数据在线程间的切换。</p><p>没错，Android系统的设计者也是这么想的，于是便诞生 Handler 这一杰作！接下来让我们跟随消息机制设计者们的思维来看一下如何实现这一功能。</p><h3 id="1-设计消息缓冲区–MessageQueue"><a href="#1-设计消息缓冲区–MessageQueue" class="headerlink" title="1.设计消息缓冲区–MessageQueue"></a>1.设计消息缓冲区–MessageQueue</h3><p>由于系统中无时无刻都在产生消息，因此我们首先需要有一个消息缓冲区，用来存放各个生产者线程所产生的消息，我们将这个缓冲区命名为 MessageQueue。作为一个消息队列，其内部需要有一个存放消息的容器。同时需要对外提供插入消息和取出消息的接口，将这两个接口方法分别命名为 <code>enqueueMessage(Message msg)</code> 与 <code>next()</code>。MessageQueue 伪代码实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessageQueue</span> </span>&#123;<br>    <span class="hljs-comment">// 消息容器，暂且使用 LinkedList。</span><br>    <span class="hljs-keyword">private</span> LinkedList&lt;Message&gt; list = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">enqueueMessage</span><span class="hljs-params">(Message msg)</span> </span>&#123;<br>        list.add(msg);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> Message <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>&#123;<br>    <br>         <span class="hljs-keyword">while</span> (list.isEmpty()) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 如果容器为空，则阻塞消费者线程</span><br>                wait();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>       <br>        <span class="hljs-keyword">return</span> list.removeFirst()  <br>     &#125;<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>在 MessageQueue 中维护了一个集合，当插入消息时将消息存入这个集合，取出消息时，将消息从集合中移除并返回。</p><p>有了消息队列之后，还需要有”生产者“与”消费者“这两个角色，生产者负责向 MessageQueue 中插入消息，而消费者负责从 MessageQueue 中取出消息并进行消费。</p><h3 id="2-设计消息机制的”生产者“–Handler"><a href="#2-设计消息机制的”生产者“–Handler" class="headerlink" title="2.设计消息机制的”生产者“–Handler"></a>2.设计消息机制的”生产者“–Handler</h3><p>系统各处产生的消息需要存入到消息队列中，等待消费者取出消息并将其消费。因此我们可以设计一个包装类来实现消息插入到消息队列，将这个包装类命名为 Handler。既然作为消息队列的包装， Handler 肯定要持有 MessageQueue，以便于向消息队列中插入消息。同时还需要对外提供插入消息的API，可以将这个插入消息的API命名为 <code>sendMessage(Message msg)</code>,在这个方法内实现把 Message 插入到 MessageQueue 的逻辑。</p><p>另外，作为Handler的使用方，在通过 Handler 将消息插入到 MessageQueue 后，肯定迫切的需要知道消息何时被消费者处理。因此，还需要在 Handler 中添加一个处理消息的回调方法，以便于使用方重写该方法，并完成需要的逻辑。我们将这个方法命名为<code>dispatchMessage</code>。至此，”生产者“的设计就完成了。Handler 的伪代码实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Handler</span> </span>&#123;<br><br>   <span class="hljs-keyword">private</span> MessageQueue mQueue;<br>   <br>   <span class="hljs-comment">// 这里的 MessageQueue 应当与消费者的 MessageQueue 是同一个</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Handler</span><span class="hljs-params">(MessageQueue queue)</span></span>&#123;<br>       mQueue = queue;<br>   &#125;<br>   <br>   <span class="hljs-comment">// 处理消息的回调</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dispatchMessage</span><span class="hljs-params">(Message msg)</span></span>&#123;<br>       <br>   &#125;<br>   <br>   <span class="hljs-comment">// 向消息队列中插入消息</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendMessage</span><span class="hljs-params">(Message msg)</span> </span>&#123;<br>       <span class="hljs-comment">// Message 中需要持有Handler，以便回调 dispatchMessage 方法。</span><br>       msg.target = <span class="hljs-keyword">this</span>;<br>       mQueue.enqueueMessage(msg);<br>   &#125;<br>   <br>   <span class="hljs-comment">// ... 另外还可以实现多个 sendMessage 的重载方法，以适用不同的需求。</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-设计消息机制的信使–-Message"><a href="#3-设计消息机制的信使–-Message" class="headerlink" title="3.设计消息机制的信使– Message"></a>3.设计消息机制的信使– Message</h3><p>Message 应该充当的是信使的作用，即 Message 需要携带调用方赋予的数据。而这一数据类型并不确定，因此我们可以将它声明为 Object 类型。另外，在消息被消费者处理的时候需要通知调用方消息被处理了。因此可以让 Message 持有一个 Handler,以便在消息被处理后回调给Handler。我们将这个 Handler 命名为 target。于是 Message 的伪代码就可以有如下实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Message</span></span>&#123;<br>    <span class="hljs-comment">// 携带的消息</span><br>    Object obj;<br>    <span class="hljs-comment">// 持有 Handler</span><br>    Handler target;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-设计消息机制的”消费者“–Looper"><a href="#4-设计消息机制的”消费者“–Looper" class="headerlink" title="4.设计消息机制的”消费者“–Looper"></a>4.设计消息机制的”消费者“–Looper</h3><p>在完成了消息队列、生产者、以及消息信使的设计之后，我们还需要实现消费者这一角色。作为消费者，它的职责就是从 MessageQueue 中取出 Message ，并将其消费。值得注意的是这个 MessageQueue 必须是与生产者所共用的。这里我们将”消费者“这一角色命名为 Looper。Looper作为”消费者“，其职责就是需要不断的从 MessageQueue 中取出消息并进行消费。那么我们就将这个取消息的方法命名为 loop(),因为需要不断的从 MessageQueue 中取出消息，所以这个方法应该被设计成一个死循环，没有消息的时候就阻塞执行。因此 Looper 的伪代码实现如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Looper</span> </span>&#123;<br><br>    <span class="hljs-comment">// 在 Looper 中实例化消息队列，并提供给Handler，实现生产者与消费者共享</span><br>    MessageQueue mQueu = <span class="hljs-keyword">new</span> MessageQueue();<br>    <br>    <span class="hljs-comment">// 从消息队列中取出消息并消费</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">loop</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">for</span>(;;) &#123;<br>            <span class="hljs-comment">// 静态方法，需要获取Looper的实例</span><br>            Message msg = myLooper().mQueue.next();<br>            <span class="hljs-keyword">if</span>(msg == <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-comment">// 回调到 Handler</span><br>            msg.target.dispatchMessage(mgs);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 这里假设通过myLooper方法拿到looper的实例</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Looper <span class="hljs-title">myLooper</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Looper();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过”生产者-消费者“模型，我们可以很轻松的写出 Android 消息机制的大体框架.而接下来我们要思考的是在这个实现过程中会面临什么样的问题，以及该如何去解决。</p><h2 id="三、完善消息机制的实现逻辑"><a href="#三、完善消息机制的实现逻辑" class="headerlink" title="三、完善消息机制的实现逻辑"></a>三、完善消息机制的实现逻辑</h2><p>上一章中，我们搭建起了消息机制的大体框架，下一步就是要实现具体的逻辑了。仔细想一想会发现我们面临着不少的问题，我列举出了以下几个，不妨来思考思考。</p><ul><li>线程切换是消息机制的一个重要功能，应该如何实现？</li><li>一个线程可以有多个 Looper 实例吗？如果不可以，那应该如何保证线程级别的 Looper 单例？</li><li>APP 在运行时会产生大量的 Message，每次都通过 “new” 关键字实例化 Message 可行吗 ？</li><li>系统发送的某些消息具有较高的优先级，如何才能保证其优先执行？</li></ul><h3 id="1-实现线程切换"><a href="#1-实现线程切换" class="headerlink" title="1.实现线程切换"></a>1.实现线程切换</h3><p>消息机制一个很重要的需求，即在子线程中获取到的数据需要发送给主线程进行页面渲染。这个让数据从子线程切换到主线程的功能该如何实现呢？</p><p>这其实是一个很简单的问题，只需要在主线程中实例化 Looper，同时在实例化 Handler 的时候在 Handler 构造方法中传入 Looper 持有的 MessageQueue 即可。这样 Looper 和 Handler 共享了同一个 MessageQueue。不管 Handler 在哪个线程发送消息，最终 Looper 都会在主线程中取出消息并执行。看一下代码的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyActivityThread</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>    <br>        <span class="hljs-comment">// 实例化一个 Looper</span><br>        Looper looper = Looper.myLooper();<br>        <br>        <span class="hljs-comment">// 实例化 Handler,并传入 Looper 持有的 MessageQueue</span><br>        Handler handler = <span class="hljs-keyword">new</span> Handler(looper.mQueue) &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dispatchMessage</span><span class="hljs-params">(Message msg)</span></span>&#123;<br>                <span class="hljs-comment">// 在主线程中得到了 Message</span><br>            &#125;<br>        &#125;;<br>        <br>        <span class="hljs-comment">// 开启一个子线程</span><br>        <span class="hljs-keyword">new</span> Thread() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;<br>                <span class="hljs-comment">// 在子线程中通过 Handler 发出一个消息</span><br>                handler.sendMessage(<span class="hljs-keyword">new</span> Message());<br>            &#125;<br>        <br>        &#125;<br>        <br>        <span class="hljs-comment">// 调用loop,开启循环不断的从MessageQueue中取出消息，没有消息就会被阻塞。</span><br>        <span class="hljs-comment">// 通过这样的方式，导致 main 方法不会被执行完而退出程序，Android 系统源码也是</span><br>        <span class="hljs-comment">// 这样实现的，这也是为什么 Android 中的 APP 不会像java程序一样，执行完逻辑就结束掉。</span><br>        looper.loop();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当然，这里举的是子线程与主线程的例子，对于子线程与子线程的切换是与之类似的。</p><h3 id="2-实现线程级别的-Looper-单例"><a href="#2-实现线程级别的-Looper-单例" class="headerlink" title="2.实现线程级别的 Looper 单例"></a>2.实现线程级别的 Looper 单例</h3><p>先来看这个问题，一个线程可以有多个 Looper 实例吗？一个线程中有多个 Looper 站在逻辑的角度来看显然是没什么问题的。但是如果站在 Android 系统的角度来考虑，一个线程有多个Looper实例显然有很大的问题！因为 Looper 的 loop() 方法是一个阻塞方法。如果在一个线程中实例化了多个 Looper，并且都调用了它的 loop 方法，那么一定只有第一个调用 loop 方法的 Looper 实例会运行，其他的 Looper 会被阻塞永远也执行不了。</p><p>因此，作为消息机制的设计者，我们应该保证单个线程只能实例化一个 Looper。而不能寄托于使用者，要求他们在使用 Looper 的时候只实例化一次。</p><p>那么这个时候再来回顾一下上一章我们对 Looper 的设计，似乎是有很大缺陷的。因为此时的Looper可以在主线程中通过 myLooper 方法实例化出任意多个 Looper 对象。显然这是不符合我们的需求的。有的同学说可以将 Looper 设计成单例，这样就不会被实例化出多个 Looper 了。但这样显然也是不符合需求的，我们需要的是在同一个线程里边只能有一个 Looper 实例，但多个线程可以有多个 Looper 实例。也就是说这个 Looper 应该是一个线程级别的单例。那应该怎么实现呢？</p><p>说到这里，java基础掌握比较好的同学应该已经想到了，可以使用 ThreadLocal来实现！</p><p>ThreadLocal提供了线程级别的数据存储能力。即在A线程中使用 ThreadLocal 存储了一个数据，那么这个数据只对A线程可见，只有在A线程中才能取出，其他线程无法取到。关于 ThreadLocal 了解这么多就足够了，这里不再赘述 ThreadLocal 的实现原理，如果你对 ThreadLocal 比较感兴趣可以参考我之前写的一篇文章<a href="https://juejin.cn/post/6986301941269659656">《Java并发系列番外篇：ThreadLocal原理其实很简单》</a></p><p>有了以上理论的支持，我们就可以重构 Looper 的实现逻辑了。修改后的 Looper 代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Looper</span> </span>&#123;<br><br>    <span class="hljs-comment">// 使用 ThreadLocal 存储Looper</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ThreadLocal&lt;Looper&gt; sThreadLocal = <span class="hljs-keyword">new</span> ThreadLocal&lt;Looper&gt;();<br>    <br>    MessageQueue mQueu;<br>    <br>    <span class="hljs-comment">// 私有化构造方法，避免单个线程中被多次实例化</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Looper</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 实例化 MessageQueue</span><br>        mQueue = <span class="hljs-keyword">new</span> MessageQueue();<br>    &#125;<br>    <br>    <span class="hljs-comment">// 添加一个 prepare 方法来实例化 Looper,并将其存储到 TheadLocal</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">prepare</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 需要保证Looper是线程唯一的</span><br>        <span class="hljs-keyword">if</span> (sThreadLocal.get() != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">// 走到这里说明该线程已经实例化过 Looper 了，抛出异常终止程序执行</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;Only one Looper may be created per thread&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">// 将 Looper 实例存入到 ThreadLocal</span><br>        sThreadLocal.set(<span class="hljs-keyword">new</span> Looper());<br>    &#125;<br>    <br>    <span class="hljs-comment">// 从 ThreadLocal 中取出 Looper 实例</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Looper <span class="hljs-title">myLooper</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> sThreadLocal.get();<br>    &#125;<br><br>    <span class="hljs-comment">// 从消息队列中取出消息并消费</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">loop</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">for</span>(;;) &#123;<br>            Message msg = myLooper().mQueue.next();<br>            <span class="hljs-keyword">if</span>(msg == <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            msg.target.dispatchMessage(mgs);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过以上代码，我们实现了一个线程级别的单例，保证了每个线程只能创建一个 Looper，多次创建就会导致程序崩溃。</p><h3 id="3-Message-对象池"><a href="#3-Message-对象池" class="headerlink" title="3.Message 对象池"></a>3.Message 对象池</h3><p>Android APP 在运行的时候会有大量的 Message 由系统插入到 MessageQueue 中，前面已经提到过的 View 的绘制过程、事件分发过程、Activity 启动过程等等都会向 MessageQueue 插入消息。这就意味着会有大量的 Message 被实例化。如果每次用到 Message 的时候都通过 “new” 关键字来实例化实现 Message 对象，那么肯定会导致严重的内存抖动问题。</p><p>因此，为了避免 Message 的频繁实例化，我们可以对获取 Message 对象的过程做一些优化。通常避免频繁的创建对象的解决方案都是使用对象池。也就是维护一个 Message 对象池，在用完之将后将 Message 的数据进行重置，并将其放入到对象池中，等待下次复用。这样就避免了频繁实例化 Message 可能导致的内存抖动问题。主要是了解一下池化思想，这里就直接 copy 系统的源码了，系统源码中 Message 是一个拥有链表结构的类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Message</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Parcelable</span> </span>&#123;<br>    <br>    <span class="hljs-keyword">public</span> Object obj;<br>    <br>    Message next;<br>    <br>    <span class="hljs-comment">// 对象池中有空闲对象直接使用，没有则实例化Message</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Message <span class="hljs-title">obtain</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">synchronized</span> (sPoolSync) &#123;<br>            <span class="hljs-keyword">if</span> (sPool != <span class="hljs-keyword">null</span>) &#123;<br>                Message m = sPool;<br>                sPool = m.next;<br>                m.next = <span class="hljs-keyword">null</span>;<br>                m.flags = <span class="hljs-number">0</span>; <span class="hljs-comment">// clear in-use flag</span><br>                sPoolSize--;<br>                <span class="hljs-keyword">return</span> m;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Message();<br>    &#125;<br><br>    <span class="hljs-comment">// 回收 Message，并加入到对象池</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">recycle</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (isInUse()) &#123;<br>            <span class="hljs-keyword">if</span> (gCheckRecycle) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">&quot;This message cannot be recycled because it &quot;</span><br>                        + <span class="hljs-string">&quot;is still in use.&quot;</span>);<br>            &#125;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        recycleUnchecked();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">recycleUnchecked</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// Mark the message as in use while it remains in the recycled object pool.</span><br>        <span class="hljs-comment">// Clear out all other details.</span><br>        flags = FLAG_IN_USE;<br>        what = <span class="hljs-number">0</span>;<br>        arg1 = <span class="hljs-number">0</span>;<br>        arg2 = <span class="hljs-number">0</span>;<br>        obj = <span class="hljs-keyword">null</span>;<br>        replyTo = <span class="hljs-keyword">null</span>;<br>        sendingUid = UID_NONE;<br>        workSourceUid = UID_NONE;<br>        when = <span class="hljs-number">0</span>;<br>        target = <span class="hljs-keyword">null</span>;<br>        callback = <span class="hljs-keyword">null</span>;<br>        data = <span class="hljs-keyword">null</span>;<br><br>        <span class="hljs-keyword">synchronized</span> (sPoolSync) &#123;<br>            <span class="hljs-keyword">if</span> (sPoolSize &lt; MAX_POOL_SIZE) &#123;<br>                next = sPool;<br>                sPool = <span class="hljs-keyword">this</span>;<br>                sPoolSize++;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Message</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br>   <br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到 Message 实现对象池的两个核心方法就是 obtain() 与 recycle()，obtain负责从对象池中取出 Message，如果对象池没有空闲的 Message，则直接实例化 Message，而 recycle() 则是回收用完的Message，并将其插入到复用链表中。这里所谓的对象池其实就是一个空闲的 Message 链表。</p><h3 id="4-无界队列-MessageQueue"><a href="#4-无界队列-MessageQueue" class="headerlink" title="4. 无界队列 MessageQueue"></a>4. 无界队列 MessageQueue</h3><p>在上一小节中我们已经知道 Message 其实是一个拥有链表结构的类。因此 MessageQueue 中的容器其实并非像第二章第1小节中写的那样是一个 LinkedList，而是一个 Message 链表。</p><p>通常来说”生产者-消费者“模型中的缓冲队列是有特定的容量的，在缓冲队列填满的时候就会阻塞生产者继续添加数据,即出现所谓的<strong>背压</strong>问题。因此，一个标准的”生产者-消费者“模型必然要考虑<strong>背压策略</strong>，就比如大家所熟知的 RxJava 由于内部使用的是有界队列，因此当队列的容量不足时就会抛出 <code>MissingBackpressureException</code>。而 Rxjava 也给出了多个背压策略，例如丢弃事件、扩容、或者直接抛出异常。与之类似的是线程池的实现，区别是线程池内不叫背压策略，而是叫<strong>拒绝策略</strong>。</p><p>但是作为接收系统消息的 MessageQueue 如果被设计成有界队列合适吗？显然是不合适的，因为系统发送的消息多是一些中要的消息，任何事件的丢失都可能会导致严重的系统 bug。所以作为消息机制设计者一定会把 MessageQueue 设计成一个无界队列。这样插入消息永远不会被阻塞，也不用考虑所谓的背压策略了。这是消息机制与标准的 ”生产者-消费者“ 模型的区别之一。</p><p>关于 MessageQueue 插入消息与取出消息的实现，前面我们只是简单写了伪代码，而且是使用集合实现的。由于我们已经知道系统源码中的 Message 是一个链表结构的类。因此，我们可以使用链表的结构来实现插消息和取消息。</p><p>因为这两个方法的实现还是比较复杂的，因此现在我们跳出设计者的身份，跟随 Android 系统源码来解读这两个方法的实现。</p><h4 id="（1）插入消息的实现"><a href="#（1）插入消息的实现" class="headerlink" title="（1）插入消息的实现"></a>（1）插入消息的实现</h4><p>MessageQueue 插入消息的逻辑是在 enqueueMessage 方法中实现的， 简化后的源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">enqueueMessage</span><span class="hljs-params">(Message msg, <span class="hljs-keyword">long</span> when)</span> </span>&#123;<br><br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br><br>        msg.when = when;<br>        <br>        Message p = mMessages;<br>        <span class="hljs-keyword">boolean</span> needWake;<br>       <br>        <span class="hljs-keyword">if</span> (p == <span class="hljs-keyword">null</span> || when == <span class="hljs-number">0</span> || when &lt; p.when) &#123;<br>            <span class="hljs-comment">// 如果队列为空，或者该消息不是延迟消息，或者是延迟消息</span><br>            <span class="hljs-comment">// 但执行的时间比头消息早，则将消息插入到队列的头部</span><br>            <span class="hljs-comment">// New head, wake up the event queue if blocked.</span><br>            msg.next = p;<br>            mMessages = msg;<br>            needWake = mBlocked;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 这种情况下说明要插入的消息时延迟消息，遍历链表找到合适的插入位置</span><br>        <br>            Message prev;<br>            <span class="hljs-keyword">for</span> (;;) &#123;<br>                prev = p;<br>                p = p.next;<br>                <span class="hljs-comment">// 如果已经遍历到队列尾部了或者在队列中找到了比要插入的消</span><br>                <span class="hljs-comment">// 息延迟时间更长的消息则终止循环，即找到了合适的插入位置</span><br>                <span class="hljs-keyword">if</span> (p == <span class="hljs-keyword">null</span> || when &lt; p.when) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;<br>                    needWake = <span class="hljs-keyword">false</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 将消息插入到这个合适的位置</span><br>            msg.next = p; <span class="hljs-comment">// invariant: p == prev.next</span><br>            prev.next = msg;<br>        &#125;<br><br>        <span class="hljs-comment">// We can assume mPtr != 0 because mQuitting is false.</span><br>        <span class="hljs-keyword">if</span> (needWake) &#123;<br>            <span class="hljs-comment">// 唤醒线程</span><br>            nativeWake(mPtr);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>enqueueMessage 的逻辑其实并不难理解，就是把 Message 插入到链表中去，同时插入链表的位置是根据消息 delay 的时间决定的，delay 的时间越长，插入队列时就越靠后，即越晚执行。最后根据是否要唤醒线程来调用 nativeWake， 这个方法是在 native 层实现的。可以把他理解为”生产者-消费者”模型中 通过 notify 唤醒线程的操作。</p><h4 id="（2）取出消息的实现"><a href="#（2）取出消息的实现" class="headerlink" title="（2）取出消息的实现"></a>（2）取出消息的实现</h4><p>取出消息是通过 MessageQueue 的 next 方法实现的，简化后的 next 方法的源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">Message <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-keyword">int</span> pendingIdleHandlerCount = -<span class="hljs-number">1</span>; <span class="hljs-comment">// -1 only during first iteration</span><br>    <span class="hljs-keyword">int</span> nextPollTimeoutMillis = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br><br>        <span class="hljs-comment">// 阻塞线程</span><br>        nativePollOnce(ptr, nextPollTimeoutMillis);<br><br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>        <br>            <span class="hljs-comment">// ... 省略异步消息的处理</span><br>            <br>            <span class="hljs-keyword">if</span> (msg != <span class="hljs-keyword">null</span>) &#123;<br>              <br>                <span class="hljs-keyword">if</span> (now &lt; msg.when) &#123; <span class="hljs-comment">// 根据delay的时间判断该Message是否可以执行</span><br>                    <span class="hljs-comment">// 未到执行时间则走到下一次循环调用nativePollOnce阻塞该方法</span><br>                    nextPollTimeoutMillis = (<span class="hljs-keyword">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// 从链表取出消息</span><br>                    mBlocked = <span class="hljs-keyword">false</span>;<br>                    <span class="hljs-keyword">if</span> (prevMsg != <span class="hljs-keyword">null</span>) &#123;<br>                        prevMsg.next = msg.next;<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        mMessages = msg.next;<br>                    &#125;<br>                    msg.next = <span class="hljs-keyword">null</span>;<br>                    msg.markInUse();<br>                    <span class="hljs-comment">// 将消息返回</span><br>                    <span class="hljs-keyword">return</span> msg;<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 消息队列为空，阻塞时间设置于为-1，表示一直阻塞</span><br>                nextPollTimeoutMillis = -<span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 省略 IdelHandler 的处理逻辑</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里暂时忽略 next 方法的异步消息处理逻辑以及 IdleHandler 的处理逻辑。简化后的代码并也容易理解。首先是一个用 for 实现的死循环，循环中先调用 nativePollOnce 对线程进行阻塞，这个方法也是一个 native 方法，可以将它理解为”生产者-消费者“模型中阻塞线程的 wait 方法。这个方法的第二个参数表示阻塞的时间，如果是正数，则表示阻塞这个值的毫秒时长，如果是0表示不阻塞，如果小于0，则会一直阻塞。</p><p>接下来的逻辑则是判断消息是不是到了该执行的时间了，如果没到，则继续 for 循环执行 nativePollOnce 来阻塞方法，如果消息到了执行的时间就将消息从链表中取出并返回给 Looper，交给 Looper 对消息进行消费。</p><h3 id="5-Message-的优先级"><a href="#5-Message-的优先级" class="headerlink" title="5.Message 的优先级"></a>5.Message 的优先级</h3><p>在标准的”生产者-消费者“模型中消息是没有优先级之分的。即按照标准的队列执行先进先出的逻辑。但是在 Android 消息机制中是需要对消息进行优先级划分的，普通消息应该将优先执行的权利让给那些会影响程序性能的消息，比如 View 绘制的消息、屏幕刷新的消息以及Activity启动的消息等。这是消息机制与标准的”生产者-消费者“模型的又一重要区别。</p><p>就我的理解而言，消息机制中的消息一共被划分了四个优先级。优先级由高到低分别是<strong>异步消息</strong>、<strong>普通消息</strong>、<strong>IDleHandler</strong> 以及<strong>延迟消息</strong>。</p><h4 id="（1）异步消息"><a href="#（1）异步消息" class="headerlink" title="（1）异步消息"></a>（1）异步消息</h4><p>在 Message 的源码中为开发者提供了一个 setAsynchronous 的方法，这个方法是对外开放的。通过这个方法会为消息设置一个异步标记。使用代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Message message = Message.obtain();<br><span class="hljs-comment">// 设置异步消息</span><br>message.setAsynchronous(<span class="hljs-keyword">true</span>);<br></code></pre></td></tr></table></figure><p>异步消息拥有最高的执行优先级，但是仅仅将其设置为异步消息并没有什么作用。它需要配合同步屏障消息来执行。什么是同步屏障消息呢？其实就是一个 Message.target 为 null 的消息。它的实现逻辑在 MessageQueue 的 postSyncBarrier 方法中。源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// MessageQueue</span><br><br><span class="hljs-meta">@UnsupportedAppUsage</span> <span class="hljs-comment">// 不支持APP调用</span><br><span class="hljs-meta">@TestApi</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">postSyncBarrier</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> postSyncBarrier(SystemClock.uptimeMillis());<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">postSyncBarrier</span><span class="hljs-params">(<span class="hljs-keyword">long</span> when)</span> </span>&#123;<br>    <span class="hljs-comment">// Enqueue a new sync barrier token.</span><br>    <span class="hljs-comment">// We don&#x27;t need to wake the queue because the purpose of a barrier is to stall it.</span><br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> token = mNextBarrierToken++;<br>        <span class="hljs-keyword">final</span> Message msg = Message.obtain();<br>        msg.markInUse();<br>        msg.when = when;<br>        msg.arg1 = token;<br><br>        Message prev = <span class="hljs-keyword">null</span>;<br>        Message p = mMessages;<br>        <span class="hljs-keyword">if</span> (when != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">while</span> (p != <span class="hljs-keyword">null</span> &amp;&amp; p.when &lt;= when) &#123;<br>                prev = p;<br>                p = p.next;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (prev != <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// invariant: p == prev.next</span><br>            msg.next = p;<br>            prev.next = msg;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            msg.next = p;<br>            mMessages = msg;<br>        &#125;<br>        <span class="hljs-keyword">return</span> token;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到 postSyncBarrier 方法被 <code>@UnsupportedAppUsage</code> 注解所修饰，意味着这个方法对开发者是不可见的。而 postSyncBarrier 中的逻辑其实就是向链表的头部插入了一条 Message。而这个 Message 与普通消息不同的是，它的 target 并没有被赋值。在上一节中分析 MessageQueue 的 next 方法时我们忽略了异步消息的处理逻辑。现在来具体看一下这段代码的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">Message <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-keyword">int</span> pendingIdleHandlerCount = -<span class="hljs-number">1</span>; <span class="hljs-comment">// -1 only during first iteration</span><br>    <span class="hljs-keyword">int</span> nextPollTimeoutMillis = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br><br>        <span class="hljs-comment">// 阻塞线程</span><br>        nativePollOnce(ptr, nextPollTimeoutMillis);<br><br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>            <span class="hljs-comment">// 消息队列头</span><br>            Message msg = mMessages;<br>            <span class="hljs-comment">// 如果 msg 不为 null,并且 msg.target 为 null，则执行if中的逻辑</span><br>            <span class="hljs-keyword">if</span> (msg != <span class="hljs-keyword">null</span> &amp;&amp; msg.target == <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-comment">// 走到这里说明读取到了同步屏障消息</span><br>                <span class="hljs-comment">// 通过 do...while 循环遍历message链表，找到异步消息</span><br>                <span class="hljs-keyword">do</span> &#123;<br>                    prevMsg = msg;<br>                    msg = msg.next;<br>                &#125; <span class="hljs-keyword">while</span> (msg != <span class="hljs-keyword">null</span> &amp;&amp; !msg.isAsynchronous());<br>            &#125;<br>        <br>            <span class="hljs-comment">// ... 省略取消息逻辑</span><br>        &#125;<br>        <br>        <span class="hljs-comment">// 省略 IdelHandler 的处理逻辑</span><br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到这里首先判断如果 msg 不为 null,并且 msg.target 为 null，则执行if中的逻辑，而if中则通过 do…while 循环来遍历 message 链表，直到找到异步消息才会终止do…while。然后取出异步消息执行下边的消息处理逻辑。不难看出，当遇到同步屏障消息之后就会阻塞普通消息的执行。然后遍历 Message 链表找到被标记为异步的消息优先执行。</p><p>但是有个问题，同步屏障消息是在什么时候被插件 MessageQueue 的呢？答案是在ViewRootImpl 中当计划开始遍历 View 树的时候。看下 ViewRootImpl 的 requestLayout 方法，其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ViewRootImpl.java</span><br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">requestLayout</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!mHandlingLayoutInLayoutRequest) &#123;<br>        <span class="hljs-comment">// 检查是否是在主线程中，如果不是主线程则直接抛出异常</span><br>        checkThread();<br>        <span class="hljs-comment">// mLayoutRequested标记设置为true，在同一个Vsync周期内，执行多次requestLayout的流程</span><br>        mLayoutRequested = <span class="hljs-keyword">true</span>;<br>        <span class="hljs-comment">// 计划遍历View树</span><br>        scheduleTraversals();<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">scheduleTraversals</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!mTraversalScheduled) &#123;<br>        <span class="hljs-comment">// 保证一次 requestLayout 只执行一次View树的遍历</span><br>        mTraversalScheduled = <span class="hljs-keyword">true</span>;<br>        <span class="hljs-comment">// 通过Handler发送同步屏障阻塞同步消息</span><br>        mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();<br>        <span class="hljs-comment">// 通过Choreographer发出一个mTraversalRunnable，会在这里执行</span><br>        mChoreographer.postCallback(<br>        Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, <span class="hljs-keyword">null</span>);<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到在调用 ViewRootImpl 的 requestLayout 方法后，会执行scheduleTraversals方法，在这个方法中通过 <code>mHandler.getLooper().getQueue().postSyncBarrier()</code>调用了 MessageQueue 的同步屏障方法，从而插入了一个同步屏障消息。</p><p>如果你对 Android 的屏幕绘制流程有一定了解的话，应该知道 Vsync 信号与 Choreographer。 Choreographer 会向系统底层订阅 Vsync 信号,系统底层会间隔大约16ms（60hz刷新率的屏幕）发送一次 Vsync信号。等到接收到 Vsync 信号后，Choreographer 会回调 ViewRootImpl 的 doTraversal 方法开始 View 树真正的遍历与绘制。doTraversal 源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ViewRootImpl</span><br><br><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TraversalRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>      doTraversal();<br>   &#125;<br>&#125;<br><br>   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">doTraversal</span><span class="hljs-params">()</span> </span>&#123;<br>      <span class="hljs-keyword">if</span> (mTraversalScheduled) &#123;<br>         mTraversalScheduled = <span class="hljs-keyword">false</span>;<br>         <span class="hljs-comment">// 移除同步屏障</span><br>         mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier);<br><br>         <span class="hljs-keyword">if</span> (mProfile) &#123;<br>            Debug.startMethodTracing(<span class="hljs-string">&quot;ViewAncestor&quot;</span>);<br>         &#125;<br>         <span class="hljs-comment">//  通过该方法开启View的绘制流程，会调用performMeasure方法、performLayout方法和performDraw方法。</span><br>         performTraversals();<br><br>         <span class="hljs-keyword">if</span> (mProfile) &#123;<br>            Debug.stopMethodTracing();<br>            mProfile = <span class="hljs-keyword">false</span>;<br>         &#125;<br>      &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><p>可以看到在doTraversal方法中会将同步屏障消息移除掉，之后普通消息又会得到执行的机会。其实到这里也很容易理解为什么 postSyncBarrier 方法不允许开发者调用了。因为一旦开发者执行这个方法，且没有及时移除同步屏障就会导致普通消息再也没有被执行的机会。</p><h4 id="（2）普通消息和延迟消息"><a href="#（2）普通消息和延迟消息" class="headerlink" title="（2）普通消息和延迟消息"></a>（2）普通消息和延迟消息</h4><p>关于普通消息和延迟消息其实没有什么可说的，普通消息的优先级比异步消息低毋庸置疑。而延迟消息由于在插入消息队列时会根据延迟时间确定插入到队列中的位置，即延迟越久的消息在队列中的位置越靠后。因此延迟消息的优先级是最低的。</p><h4 id="（3）IdleHandler"><a href="#（3）IdleHandler" class="headerlink" title="（3）IdleHandler"></a>（3）IdleHandler</h4><p>除了以上消息的优先级外，还有一种叫 IdelHandler 的消息(这里冒昧的称它为消息)，IdelHandler 从本质上来说并不是一个 Message，而是一个接口，其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IdleHandler</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Called when the message queue has run out of messages and will now</span><br><span class="hljs-comment">     * wait for more.  Return true to keep your idle handler active, false</span><br><span class="hljs-comment">     * to have it removed.  This may be called if there are still messages</span><br><span class="hljs-comment">     * pending in the queue, but they are all scheduled to be dispatched</span><br><span class="hljs-comment">     * after the current time.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">queueIdle</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过注释可以看得出来 queueIdle 方法是在 MessageQueue 中的消息执行完后或者有延迟消息在等待执行时才会被调用。因此可以看得出 IdleHandler 执行的优先级是比异步消息和普通消息低的，但要比延迟消息优先级高。接下来我们看一下IdleHandler的具体源码实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessageQueue</span> </span>&#123;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ArrayList&lt;IdleHandler&gt; mIdleHandlers = <span class="hljs-keyword">new</span> ArrayList&lt;IdleHandler&gt;();<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addIdleHandler</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> IdleHandler handler)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (handler == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException(<span class="hljs-string">&quot;Can&#x27;t add a null IdleHandler&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>            mIdleHandlers.add(handler);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removeIdleHandler</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> IdleHandler handler)</span> </span>&#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>            mIdleHandlers.remove(handler);<br>        &#125;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到在 MessageQueue 中有一个泛型为 IdleHandler 的 ArrayList 的成员变量，并且提供了addIdleHandler 方法可以向 mIdleHandlers 中添加 IdelHandler,同时也提供了 removeIdleHandler 来移除 IdleHandler。</p><p>那接下来继续看 MessageQueue 的 next 方法中对于 IdleHandler 的处理逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">Message <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// pendingIdleHandlerCount 默认是-1，小于0</span><br>    <span class="hljs-keyword">int</span> pendingIdleHandlerCount = -<span class="hljs-number">1</span>; <span class="hljs-comment">// -1 only during first iteration</span><br>    <span class="hljs-keyword">int</span> nextPollTimeoutMillis = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-comment">// ...</span><br>        <br>        <span class="hljs-keyword">int</span> pendingIdleHandlerCount = -<span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>         <br><br>            <span class="hljs-comment">// ... 省略异步消息与普通消息的处理逻辑</span><br><br>            <span class="hljs-comment">// 如果第一次调用next方法，pendingIdleHandlerCount 一定小于0</span><br>            <span class="hljs-comment">// mMessage == null 说明消息队列中没有消息</span><br>            <span class="hljs-comment">// now &lt; mMessages.when 说明有延迟消息，但是还没有到执行的时间</span><br>            <span class="hljs-keyword">if</span> (pendingIdleHandlerCount &lt; <span class="hljs-number">0</span><br>                    &amp;&amp; (mMessages == <span class="hljs-keyword">null</span> || now &lt; mMessages.when)) &#123;<br>                <span class="hljs-comment">// 获取IdleHandler的个数    </span><br>                pendingIdleHandlerCount = mIdleHandlers.size();<br>            &#125;<br>            <span class="hljs-comment">// 说明没有 IdleHandler</span><br>            <span class="hljs-keyword">if</span> (pendingIdleHandlerCount &lt;= <span class="hljs-number">0</span>) &#123;<br>                mBlocked = <span class="hljs-keyword">true</span>;<br>                跳过下面的逻辑，继续执行<span class="hljs-keyword">for</span>循环<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (mPendingIdleHandlers == <span class="hljs-keyword">null</span>) &#123;<br>                mPendingIdleHandlers = <span class="hljs-keyword">new</span> IdleHandler[Math.max(pendingIdleHandlerCount, <span class="hljs-number">4</span>)];<br>            &#125;<br>            <span class="hljs-comment">// 将mIdleHandlers中的数据复制到mPendingIdleHandlers数组中</span><br>            mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);<br>        &#125;<br><br>        <span class="hljs-comment">// 遍历 mPendingIdleHandlers 数组</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; pendingIdleHandlerCount; i++) &#123;<br>            <span class="hljs-comment">// 取出遍历到的IdleHandler</span><br>            <span class="hljs-keyword">final</span> IdleHandler idler = mPendingIdleHandlers[i];<br>            <span class="hljs-comment">// 将以取出的位置设置为null</span><br>            mPendingIdleHandlers[i] = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// release the reference to the handler</span><br><br>            <span class="hljs-keyword">boolean</span> keep = <span class="hljs-keyword">false</span>;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 执行Idler.queueIdle方法</span><br>                keep = idler.queueIdle();<br>            &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>                Log.wtf(TAG, <span class="hljs-string">&quot;IdleHandler threw exception&quot;</span>, t);<br>            &#125;<br>            <span class="hljs-comment">// 这里可以看出 queueIdle 如果返回false,则会将这个IdleHandler从集合中移除，下次就不会再执行了。</span><br>            <span class="hljs-keyword">if</span> (!keep) &#123;<br>                <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>                    mIdleHandlers.remove(idler);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>代码中的注释已经写得非常详细了，可以看得出来 IdleHandler 只有在 MessageQueue 没有消息时或者延迟消息没有到执行时间时才会执行 IdleHandler 的 queueIdle 方法。并且 queueIdle 方法的返回值确定了是否会将这个 IdleHandler 从集合中移除。</p><p>消息机制的设计者设计 IdelHandler 的目的就是为了执行一些不那么紧急的任务，在异步消息和普通消息执行完后，处于空闲时间时才会开始执行 IdleHandler。</p><p>而 IdleHandler 在 Framework 的源码中也是被频繁用到的。典型的用法是 Activity 的 onDestroy 生命周期的调用，就是通过向 MessageQueue 中添加 IdleHandler 来实现的。也就是说当 Activity 执行了 finish 方法后并不会立即执行 onDestory 方法，而是要等到消息队列空闲时 onDestory 才会被调用。</p><p>如果是这样的话，在Activity调用 finish 时，不断的向 MessageQueue 中插入消息，是不是会导致 Activity 的 onDestory 一直不会被调用呢？理论上是这样的，但是在系统的源码中做了一个兜底，即如果finish之后过了十秒 Activity 依然没有被销毁则会主动调用 Activity 的 onDestory 来执行销毁逻辑。</p><p>关于 onDestory 部分的源码分析可以参考路遥的一篇文章<a href="https://juejin.cn/post/6898588053451833351">《面试官：为什么 Activity.finish() 之后 10s 才 onDestroy ？》</a>，这里就不做过多解读了。</p><h2 id="四、Handler-的设计思想在开发中的应用"><a href="#四、Handler-的设计思想在开发中的应用" class="headerlink" title="四、Handler 的设计思想在开发中的应用"></a>四、Handler 的设计思想在开发中的应用</h2><h3 id="1-Handler-与卡顿监控"><a href="#1-Handler-与卡顿监控" class="headerlink" title="1.Handler 与卡顿监控"></a>1.Handler 与卡顿监控</h3><p>导致卡顿的原因一般是因为主线程里有耗时操作。由于主线程中只有一个Looper,且主线程是被 Looper.loop()阻塞着的。所以可以通过监控主线程的 Message 执行时间来找出耗时的地方。</p><p>在Looper 的 loop 方法中有这样一段代码：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">loop</span><span class="hljs-params">()</span> </span>&#123;<br>    ...<br><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        ...<br><br>        <span class="hljs-comment">// This must be in a local variable, in case a UI event sets the logger</span><br>        Printer logging = me.mLogging;<br>        <span class="hljs-keyword">if</span> (logging != <span class="hljs-keyword">null</span>) &#123;<br>            logging.println(<span class="hljs-string">&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot;</span> + msg.<span class="hljs-keyword">target</span> + <span class="hljs-string">&quot; &quot;</span> +<br>                    msg.callback + <span class="hljs-string">&quot;: &quot;</span> + msg.what);<br>        &#125;<br><br>        msg.<span class="hljs-keyword">target</span>.dispatchMessage(msg);<br><br>        <span class="hljs-keyword">if</span> (logging != <span class="hljs-keyword">null</span>) &#123;<br>            logging.println(<span class="hljs-string">&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot;</span> + msg.<span class="hljs-keyword">target</span> + <span class="hljs-string">&quot; &quot;</span> + msg.callback);<br>        &#125;<br><br>        ...<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果想要监控 Message 的执行耗时，只需要自定义一个Printer即可：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> LooperMonitor implements Printer &#123;  <br>    <br>    <span class="hljs-keyword">private</span> boolean mPrintingStarted = <span class="hljs-literal">false</span>;  <br>  <br>    @Override<br>    public void println(String x) &#123;<br>        <span class="hljs-keyword">if</span> (!mStartedPrinting) &#123;<br>            mStartTimeMillis = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>current<span class="hljs-constructor">TimeMillis()</span>;<br>            mStartThreadTimeMillis = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">SystemClock</span>.</span></span>current<span class="hljs-constructor">ThreadTimeMillis()</span>;<br>            mStartedPrinting = <span class="hljs-literal">true</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            final long endTime = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>current<span class="hljs-constructor">TimeMillis()</span>;<br>            mStartedPrinting = <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">if</span> (is<span class="hljs-constructor">Block(<span class="hljs-params">endTime</span>)</span>) &#123;<br>                notify<span class="hljs-constructor">BlockEvent(<span class="hljs-params">endTime</span>)</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> boolean is<span class="hljs-constructor">Block(<span class="hljs-params">long</span> <span class="hljs-params">endTime</span>)</span> &#123;<br>        return endTime - mStartTimeMillis &gt; mBlockThresholdMillis;<br>    &#125;<br>&#125;    <br>    <br></code></pre></td></tr></table></figure><p>然后将这个自定义的 Printer 设置到主线程的 Looper 中，就可以监控到所有主线程消息的耗时了。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Looper</span>.</span></span>get<span class="hljs-constructor">MainLooper()</span>.set<span class="hljs-constructor">MessageLogging(<span class="hljs-params">mainLooperPrinter</span>)</span>;<br></code></pre></td></tr></table></figure><h3 id="2-捕获异常，让-APP不再Crash"><a href="#2-捕获异常，让-APP不再Crash" class="headerlink" title="2.捕获异常，让 APP不再Crash."></a>2.捕获异常，让 APP不再Crash.</h3><p>为什么Android程序发生空指针等异常时，会导致应用会崩溃？</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs processing">publicclass RuntimeInit &#123;<br>    finalstatic <span class="hljs-keyword">String</span> TAG = <span class="hljs-string">&quot;AndroidRuntime&quot;</span>;<br>  <br>    ....<br>      <br>    privatestaticclass LoggingHandler implements Thread.UncaughtExceptionHandler &#123;<br>        publicvolatileboolean mTriggered = <span class="hljs-keyword">false</span>;<br><br>        @Override<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> uncaughtException(Thread t, Throwable e) &#123;<br>            mTriggered = <span class="hljs-keyword">true</span>;<br><br>            <span class="hljs-keyword">if</span> (mCrashing) <span class="hljs-keyword">return</span>;<br>                <span class="hljs-comment">//打印异常日志</span><br>            <span class="hljs-keyword">if</span> (mApplicationObject == <span class="hljs-keyword">null</span> &amp;&amp; (Process.SYSTEM_UID == Process.myUid())) &#123;<br>                Clog_e(TAG, <span class="hljs-string">&quot;*** FATAL EXCEPTION IN SYSTEM PROCESS: &quot;</span> + t.getName(), e);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                StringBuilder message = <span class="hljs-keyword">new</span> StringBuilder();<br>                message.<span class="hljs-built_in">append</span>(<span class="hljs-string">&quot;FATAL EXCEPTION: &quot;</span>).<span class="hljs-built_in">append</span>(t.getName()).<span class="hljs-built_in">append</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>                <span class="hljs-keyword">final</span> <span class="hljs-keyword">String</span> processName = ActivityThread.currentProcessName();<br>                <span class="hljs-keyword">if</span> (processName != <span class="hljs-keyword">null</span>) &#123;<br>                    message.<span class="hljs-built_in">append</span>(<span class="hljs-string">&quot;Process: &quot;</span>).<span class="hljs-built_in">append</span>(processName).<span class="hljs-built_in">append</span>(<span class="hljs-string">&quot;, &quot;</span>);<br>                &#125;<br>                message.<span class="hljs-built_in">append</span>(<span class="hljs-string">&quot;PID: &quot;</span>).<span class="hljs-built_in">append</span>(Process.myPid());<br>                Clog_e(TAG, message.toString(), e);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    privatestaticclass KillApplicationHandler implements Thread.UncaughtExceptionHandler &#123;<br>        privatefinal LoggingHandler mLoggingHandler;<br>        <span class="hljs-keyword">public</span> KillApplicationHandler(LoggingHandler loggingHandler) &#123;<br>            <span class="hljs-keyword">this</span>.mLoggingHandler = Objects.requireNonNull(loggingHandler);<br>        &#125;<br><br>        @Override<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> uncaughtException(Thread t, Throwable e) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                ensureLogging(t, e);<br><br>                <span class="hljs-keyword">if</span> (mCrashing) <span class="hljs-keyword">return</span>;<br>                mCrashing = <span class="hljs-keyword">true</span>;<br>                <span class="hljs-keyword">if</span> (ActivityThread.currentActivityThread() != <span class="hljs-keyword">null</span>) &#123;<br>                    ActivityThread.currentActivityThread().stopProfiling();<br>                &#125;<br><br>                ActivityManager.getService().handleApplicationCrash(<br>                        mApplicationObject, <span class="hljs-keyword">new</span> ApplicationErrorReport.ParcelableCrashInfo(e));<br>            &#125; <span class="hljs-keyword">catch</span> (Throwable t2) &#123;<br>                <span class="hljs-keyword">if</span> (t2 <span class="hljs-keyword">instanceof</span> DeadObjectException) &#123;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        Clog_e(TAG, <span class="hljs-string">&quot;Error reporting crash&quot;</span>, t2);<br>                    &#125; <span class="hljs-keyword">catch</span> (Throwable t3) &#123;<br>                    &#125;<br>                &#125;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                <span class="hljs-comment">//杀死进程</span><br>                Process.killProcess(Process.myPid());<br>                System.<span class="hljs-built_in">exit</span>(<span class="hljs-number">10</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> ensureLogging(Thread t, Throwable e) &#123;<br>            <span class="hljs-keyword">if</span> (!mLoggingHandler.mTriggered) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    mLoggingHandler.uncaughtException(t, e);<br>                &#125; <span class="hljs-keyword">catch</span> (Throwable loggingThrowable) &#123;<br>                &#125;<br>            &#125;<br>        &#125;<br>    <br>      ....<br>    &#125;<br>  <br>  <br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> commonInit() &#123;<br>                <span class="hljs-comment">//设置异常处理回调</span><br>        LoggingHandler loggingHandler = <span class="hljs-keyword">new</span> LoggingHandler();<br>        Thread.setUncaughtExceptionPreHandler(loggingHandler);<br>        Thread.setDefaultUncaughtExceptionHandler(<span class="hljs-keyword">new</span> KillApplicationHandler(loggingHandler));<br>      <br>                ....<br>    &#125;<br></code></pre></td></tr></table></figure><p><code>RuntimeInit</code>有两个的内部类，<code>LoggingHandler</code>和<code>KillApplicationHandler</code>。<code>LoggingHandler</code>的作用是打印异常日志，而<code>KillApplicationHandler</code>就是App发生<code>Crash</code>的真正原因，其内部调用了<code>Process.killProcess(Process.myPid())</code>来杀死发生<code>Uncaught</code>异常的进程。</p><p>这两个内部类都实现了<code>Thread.UncaughtExceptionHandler</code>接口。分别通过<code>Thread.setUncaughtExceptionPreHandler</code>和<code>Thread.setDefaultUncaughtExceptionHandler</code>方法进行注册</p><ul><li>Thread.setUncaughtExceptionPreHandler，覆盖所有线程，会在回调DefaultUncaughtExceptionHandler之前调用，只能在Android Framework内部调用该方法</li><li>Thread.setDefaultUncaughtExceptionHandler，如果在任意线程中调用即可覆盖所有线程的异常，可以在应用层调用，每次调用传入的Thread.UncaughtExceptionHandler都会覆盖上一次的，即我们可以手动覆盖系统实现的KillApplicationHandler</li><li>new Thread().setUncaughtExceptionHandler()，只可以覆盖当前线程的异常，如果某个Thread有定义UncaughtExceptionHandler，则忽略全局DefaultUncaughtExceptionHandler</li></ul><p>Uncaught异常发生时会终止线程，此时，系统便会通知<code>UncaughtExceptionHandler</code>，告诉它被终止的线程以及对应的异常， 然后便会调用<code>uncaughtException</code>函数。如果该UncaughtExceptionHandler没有被显式设置，则会调用对应线程组的默认UncaughtExceptionHandlerr。如果我们要捕获该异常，必须实现我们自己的handler</p><p>应用层调用<code>Thread.setDefaultUncaughtExceptionHandler</code>来实现所有线程的<code>Uncaught</code>异常的监听，并且会覆盖系统的默认实现的<code>KillApplicationHandler</code>，这样就可以做到让线程发生Uncaught异常的时候只是当前杀死线程，而不会杀死整个进程。这适用于子线程发生Uncaught异常。如果主线程发生Uncaught异常呢？主线程都被销毁了，这和Crash似乎就没什么区别的。那么有办法让主线程发生Uncaught异常也不会发生Crash吗？</p><p>由于整个系统都是基于消息机制，主线程的异常一定会经过Looper.loop()，所以其实只要try catch Looper.loop()即可捕获主线程异常。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">publicclass CrashCatch &#123;<br><br>    <span class="hljs-keyword">private</span> CrashHandler mCrashHandler;<br><br>    privatestatic CrashCatch mInstance;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-constructor">CrashCatch()</span>&#123;<br><br>    &#125;<br><br>    <span class="hljs-keyword">private</span> static CrashCatch get<span class="hljs-constructor">Instance()</span>&#123;<br>        <span class="hljs-keyword">if</span>(mInstance<span class="hljs-operator"> == </span>null)&#123;<br>            synchronized (<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">CrashCatch</span>.</span></span><span class="hljs-keyword">class</span>)&#123;<br>                <span class="hljs-keyword">if</span>(mInstance<span class="hljs-operator"> == </span>null)&#123;<br>                    mInstance = <span class="hljs-keyword">new</span> <span class="hljs-constructor">CrashCatch()</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        return mInstance;<br>    &#125;<br><br>    public static void init(CrashHandler crashHandler)&#123;<br>        get<span class="hljs-constructor">Instance()</span>.set<span class="hljs-constructor">CrashHandler(<span class="hljs-params">crashHandler</span>)</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> void set<span class="hljs-constructor">CrashHandler(CrashHandler <span class="hljs-params">crashHandler</span>)</span>&#123;<br><br>        mCrashHandler = crashHandler;<br>        <span class="hljs-comment">//主线程异常拦截</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-constructor">Handler(Looper.<span class="hljs-params">getMainLooper</span>()</span>).post(<span class="hljs-keyword">new</span> <span class="hljs-constructor">Runnable()</span> &#123;<br>            @Override<br>            public void run<span class="hljs-literal">()</span> &#123;<br>                <span class="hljs-keyword">for</span> (;;) &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Looper</span>.</span></span>loop<span class="hljs-literal">()</span>;<br>                    &#125; catch (Throwable e) &#123;<br>                        <span class="hljs-keyword">if</span> (mCrashHandler != null) &#123;<br>                          <span class="hljs-comment">//处理异常</span><br>                    mCrashHandler.handler<span class="hljs-constructor">Exception(Looper.<span class="hljs-params">getMainLooper</span>()</span>.get<span class="hljs-constructor">Thread()</span>, e);<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;);<br>      <br>         <span class="hljs-comment">//所有线程异常拦截，由于主线程的异常都被我们catch住了，所以下面的代码拦截到的都是子线程的异常</span><br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>set<span class="hljs-constructor">DefaultUncaughtExceptionHandler(<span class="hljs-params">new</span> Thread.UncaughtExceptionHandler()</span> &#123;<br>            @Override<br>            public void uncaught<span class="hljs-constructor">Exception(Thread <span class="hljs-params">t</span>, Throwable <span class="hljs-params">e</span>)</span> &#123;<br>                <span class="hljs-keyword">if</span>(mCrashHandler!=null)&#123;<br>                  <span class="hljs-comment">//处理异常</span><br>                   mCrashHandler.handler<span class="hljs-constructor">Exception(<span class="hljs-params">t</span>,<span class="hljs-params">e</span>)</span>;<br>                &#125;<br>            &#125;<br>        &#125;);<br>    &#125;<br><br>    publicinterface CrashHandler&#123;<br>        void handler<span class="hljs-constructor">Exception(Thread <span class="hljs-params">t</span>,Throwable <span class="hljs-params">e</span>)</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>本篇文章的内容比较长，文章从 ”生产者-消费者“模型来对比Android消息机制的实现，并尝试站在设计者的角度分析应该怎样设计系统的消息机制，还尝试分析了在实现过程中碰到的问题及解决方案。如果你能细心的看完这篇文章，一定会有所收获，并且会对 Android 的消息机制有一个全新的理解。</p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><p><a href="https://blog.csdn.net/qq_20521573/article/details/77919141?spm=1001.2014.3001.5502">《追根溯源—— 探究Handler的实现原理》</a></p><p><a href="https://juejin.cn/post/6986301941269659656">《Java并发系列番外篇：ThreadLocal原理其实很简单》</a></p><p><a href="https://juejin.cn/post/6980002998361522190">《深入理解Java线程的等待与唤醒机制》</a></p><p><a href="https://juejin.cn/post/6898588053451833351">《面试官：为什么 Activity.finish() 之后 10s 才 onDestroy ？》</a></p><p><a href="https://mp.weixin.qq.com/s/cHXrB582Op1lu3ZlrLKYcg">你知道 Android 为什么会 Crash 吗</a></p>]]></content>
    
    
    <categories>
      
      <category>Framework</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Handler</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浅析 Java 中的动态代理</title>
    <link href="/2021/08/22/48-dynamic-proxy/"/>
    <url>/2021/08/22/48-dynamic-proxy/</url>
    
    <content type="html"><![CDATA[<p>在之前的一篇文章<a href="https://juejin.cn/post/6844904003524886536">《静态代理这么用？聊一聊ViewPagerIndicator重构的一些经验》</a>中详细的介绍了 java 中的静态代理，并且使用静态代理对<a href="https://link.juejin.cn/?target=https://github.com/zhpanvip/viewpagerindicator">IndicatorView</a>进行了重构。静态代理的优点不必多说，它可以让代码具有扩展性，也可以让代码解耦。但在现实开发中，静态代理有时候也存在很多弊端，列举如下：</p><ul><li>当接口需要增加、删除、修改方法时，被代理类与代理类都需要修改，不易维护。</li><li>由于代理类要实现与被代理类一致的接口，当有多个类需要被代理时，会存在以下问题：<ul><li>如果让代理类实现所有被代理类的接口，这样会使代理类过于庞大；</li><li>如果使用多个代理类，每个代理类只代理一个类，这样会需要构造多个代理类。</li></ul></li></ul><p>对于以上问题都可以使用动态代理来解决。<strong>动态代理会在运行时根据被代理接口生成对应的代理类的字节码，然后加载到JVM中，并创建这个接口的实例的过程。</strong></p><p>本篇文章就来学习以下动态代理的使用，以及深入的理解动态代理的本质。</p><p>开始之前先给大家推荐一下<a href="https://github.com/zhpanvip/AndroidNote">AndroidNote</a>这个GitHub仓库，这里是我的学习笔记，同时也是我文章初稿的出处。这个仓库中汇总了大量的java进阶和Android进阶知识。是一个比较系统且全面的Android知识库。对于准备面试的同学也是一份不可多得的面试宝典，欢迎大家到GitHub的仓库主页关注。</p><h2 id="一、从-Retrofit-源码看动态代理"><a href="#一、从-Retrofit-源码看动态代理" class="headerlink" title="一、从 Retrofit 源码看动态代理"></a>一、从 Retrofit 源码看动态代理</h2><p>Retrofit 是一个封装了 OKHttp 的网络请求框架，它的使用非常简单。 只需要定义一个接口，然后创建一个Retrofit实例，通过Retrofit实例便可以生成接口的代理对象用来进行网络请求了。</p><p>简单的看下Retrofit的使用步骤：</p><h3 id="1-Retrofit-使用"><a href="#1-Retrofit-使用" class="headerlink" title="1.Retrofit 使用"></a>1.Retrofit 使用</h3><h4 id="1）定义接口"><a href="#1）定义接口" class="headerlink" title="1）定义接口"></a>1）定义接口</h4><p>首先，定义一个名为GitHub的接口，并在接口中添加一个API方法，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">GitHub</span> </span>&#123;<br>  <span class="hljs-meta">@GET(&quot;/repos/&#123;owner&#125;/&#123;repo&#125;/contributors&quot;)</span><br>  Call&lt;List&lt;Contributor&gt;&gt; contributors(<span class="hljs-meta">@Path(&quot;owner&quot;)</span> String owner, <span class="hljs-meta">@Path(&quot;repo&quot;)</span> String repo);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2）创建Retrofit实例"><a href="#2）创建Retrofit实例" class="headerlink" title="2）创建Retrofit实例"></a>2）创建Retrofit实例</h4><p>Retrofit完美的封装让我们可以通过一个简单的链式调用，就可以生成一个Retrofit实例。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Retrofit retrofit =<br>    <span class="hljs-keyword">new</span> Retrofit.Builder()<br>        .baseUrl(API_URL)<br>        .addConverterFactory(GsonConverterFactory.create())<br>        .build();<br></code></pre></td></tr></table></figure><h4 id="3）生成API接口代理"><a href="#3）生成API接口代理" class="headerlink" title="3）生成API接口代理"></a>3）生成API接口代理</h4><p>使用Retrofit实例生成GitHub接口的代理实例，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">GitHub github = retrofit.create(GitHub.class);<br></code></pre></td></tr></table></figure><h4 id="4）发起网络请求"><a href="#4）发起网络请求" class="headerlink" title="4）发起网络请求"></a>4）发起网络请求</h4><p>使用GitHub接口的代理，调用contributors方法发起网络请求，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">github.contributors(<span class="hljs-string">&quot;square&quot;</span>, <span class="hljs-string">&quot;retrofit&quot;</span>).enqueue(<span class="hljs-keyword">new</span> Callback&lt;List&lt;Contributor&gt;&gt;() &#123;<br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onResponse</span><span class="hljs-params">(Call&lt;List&lt;Contributor&gt;&gt; call, Response&lt;List&lt;Contributor&gt;&gt; response)</span> </span>&#123;<br><br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onFailure</span><span class="hljs-params">(Call&lt;List&lt;Contributor&gt;&gt; call, Throwable t)</span> </span>&#123;<br><br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>在上述代码中，我们仅仅是定义了一个GitHub接口，Retrofit内部究竟是怎么生成 GitHub 实例的呢？其实这里就是用到了动态代理来实现的。</p><h3 id="Retrofit-动态代理"><a href="#Retrofit-动态代理" class="headerlink" title="Retrofit 动态代理"></a>Retrofit 动态代理</h3><p>Retrofit 的 create 方法接受一个 <code>Class&lt;T&gt;</code>类型的参数，并且会返回一个这个<code>Class&lt;T&gt;</code>对应的实例对象。这里就是使用动态代理来创建<code>Class&lt;T&gt;</code>的实例的。看下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">create</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Class&lt;T&gt; service)</span> </span>&#123;<br>  <span class="hljs-comment">// 校验 service 是否合法</span><br>  validateServiceInterface(service);<br>  <span class="hljs-keyword">return</span> (T)<br>      Proxy.newProxyInstance(  <span class="hljs-comment">// 通过 Proxy.newProxyInstance 生成 service 的实例对象</span><br>          service.getClassLoader(), <span class="hljs-comment">// 类加载器</span><br>          <span class="hljs-keyword">new</span> Class&lt;?&gt;[] &#123;service&#125;, <span class="hljs-comment">// 被代理的接口</span><br>          <span class="hljs-keyword">new</span> InvocationHandler() &#123; <span class="hljs-comment">// 一个匿名内部类，是被代理方法真正执行的逻辑</span><br>            <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Platform platform = Platform.get();<br>            <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Object[] emptyArgs = <span class="hljs-keyword">new</span> Object[<span class="hljs-number">0</span>];<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-meta">@Nullable</span> <span class="hljs-function">Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, <span class="hljs-meta">@Nullable</span> Object[] args)</span></span><br><span class="hljs-function">                <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br><br>                <span class="hljs-comment">// ...</span><br><br>              <span class="hljs-keyword">return</span> loadServiceMethod(method).invoke(args);<br>            &#125;<br>          &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码我进行了简化，抛开被代理方法的执行逻辑来着重看静态代理的实现。首先再次明确一下 create 方法返回的是一个 GitHub 接口的代理对象. 这个对象是通过 Proxy.newProxyInstance 方法生成的。newProxyInstance 方法接收三个参数，分别为类加载器、被代理的接口，以及一个InvocationHandler的匿名内部类。</p><p>到这里可能有些同学还是没明白到底是怎么回事。让我们再来看一下动态代理的定义 ：<strong>动态代理会在运行时根据被代理接口生成对应的代理类的字节码，然后加载到JVM中，并创建这个接口的实例的过程。</strong></p><p>结合create的代码来说就是这个方法会在运行时通过Proxy.newProxyInstance生成一个代理类，并且会将这个代理类加载到JVM中，并生成代理的实例。 当通过代理接口调用接口中的中的方法时，实际会执行InvocationHandler 的 invoke 方法。</p><p>所以，到这里代理与被代理的关系其实应该很清晰了。即 Proxy.newProxyInstance 生成的这个类（也就是本章第1节，第3小节中的github实例）是代理类，而匿名内部类 InvocationHandler 中的 invoke 方法是被代理的方法。所以真正的执行逻辑就在这个 invoke 方法中。</p><h2 id="二、实现一个动态代理"><a href="#二、实现一个动态代理" class="headerlink" title="二、实现一个动态代理"></a>二、实现一个动态代理</h2><p>上一章我们了解了retrofit中的动态代理。本章内容，我们来自己完成一个动态代理的例子，加深对动态代理的理解。仍然以<a href="https://juejin.cn/post/6844904003524886536">《静态代理这么用？聊一聊ViewPagerIndicator重构的一些经验》</a> 这篇文章中的场景为例：</p><blockquote><p>Ryan想在上海买一套房子，但是他又不懂房地产的行情，于是委托了中介（Proxy）来帮助他买房子。</p></blockquote><h3 id="1-实现动态代理"><a href="#1-实现动态代理" class="headerlink" title="1.实现动态代理"></a>1.实现动态代理</h3><h4 id="1）定义代理接口"><a href="#1）定义代理接口" class="headerlink" title="1）定义代理接口"></a>1）定义代理接口</h4><p>毫无疑问，应该首先定义一个Buy House 的接口，如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IPersonBuyHouse</span> </span>&#123;<br>    <span class="hljs-comment">// 特意加了一个返回值，表示是否成功购买</span><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">buyHouse</span><span class="hljs-params">(String name)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2）使用动态代理"><a href="#2）使用动态代理" class="headerlink" title="2）使用动态代理"></a>2）使用动态代理</h4><p>模仿retrofit中create方法的代码，来实现动态代理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">InvocationHandler handler = (proxy, method, args1) -&gt; &#123;<br>    <span class="hljs-keyword">if</span> (method.getName().equals(<span class="hljs-string">&quot;buyHouse&quot;</span>)) &#123;<br>        System.out.println(args1[<span class="hljs-number">0</span>] + <span class="hljs-string">&quot; will buy a house.&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 返回true，表示购买成功</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;;<br><span class="hljs-comment">// 通过 Proxy.newProxyInstance 生成代理对象</span><br>IPersonBuyHouse proxy = (IPersonBuyHouse)Proxy<br>        .newProxyInstance(IPersonBuyHouse.class.getClassLoader(), // ClassLoader<br>                <span class="hljs-keyword">new</span> Class[]&#123;IPersonBuyHouse.class&#125;, // 传入要实现的接口<br>                handler); <span class="hljs-comment">// 传入处理调用方法的InvocationHandler</span><br></code></pre></td></tr></table></figure><h4 id="3）执行代理"><a href="#3）执行代理" class="headerlink" title="3）执行代理"></a>3）执行代理</h4><p>生成代理后，便可以调用代理中的方法来买房子了，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">boolean</span> success = proxy.buyHouse(<span class="hljs-string">&quot;Ryan&quot;</span>);<br></code></pre></td></tr></table></figure><p>执行上述代码会得到如下日志：</p><blockquote><p>Ryan will buy a house.</p></blockquote><p>即 InvocationHandler 的 invoke 方法中输出的日志。</p><h3 id="2-动态代理的本质"><a href="#2-动态代理的本质" class="headerlink" title="2. 动态代理的本质"></a>2. 动态代理的本质</h3><p>其实，在第一章中关于动态代理的本质已经解释的很清楚了。Proxy.newProxyInstance 会生成一个IPersonBuyHouse的代理对象。执行代理对象的方法就是执行了InvocationHandler的invoke方法。也就是InvocationHandler其实是被代理的对象。</p><p>如果将上一节中的动态代理代码改成静态代理，其实就是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Proxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IPersonBuyHouse</span> </span>&#123;<br>    <span class="hljs-comment">// 这里可以理解为被代理类 Ryan</span><br>    InvocationHandler handler = <span class="hljs-keyword">new</span> InvocationHandler() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> </span>&#123;<br>            <span class="hljs-keyword">if</span> (method.getName().equals(<span class="hljs-string">&quot;buyHouse&quot;</span>)) &#123;<br>                System.out.println(args[<span class="hljs-number">0</span>] + <span class="hljs-string">&quot; will buy a house.&quot;</span>);<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>    &#125;;<br><br>    <span class="hljs-comment">// 代理方法</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">buyHouse</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 反射获取buyHouse这个Method</span><br>            Method buyHouseMethod = IPersonBuyHouse.class.getDeclaredMethod(&quot;buyHouse&quot;, String.class);<br>            <span class="hljs-comment">// 将buyHouse的参数封装成一个Object数组</span><br>            Object[] params = <span class="hljs-keyword">new</span> Object[<span class="hljs-number">1</span>];<br>            params[<span class="hljs-number">0</span>] = name;<br>            <span class="hljs-comment">// 实际调用了InvocationHandler的invoke方法</span><br>            <span class="hljs-keyword">return</span> (<span class="hljs-keyword">boolean</span>) handler.invoke(<span class="hljs-keyword">this</span>, buyHouseMethod, params);<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试代码直接实例化Proxy并调用buyHouse即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> Proxy().buyHouse(<span class="hljs-string">&quot;Ryan&quot;</span>);<br></code></pre></td></tr></table></figure><p>打印结果与使用动态代理打印结果一致：</p><blockquote><p>Ryan will buy a house.</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇文章详细且深入的讲解了动态代理的使用以及动态代理的本质。动态代理使用Proxy.newProxyInstance来生成代理类，解决了静态代理中不能同时代理多个类的弊端。被代理类在动态代理中也没有被显示声明，而是以InvocationHandler的形式来实现。调用代理类的方法实则调用了InvocationHandler的invoke方法。真正的执行逻辑就是在这个invoke方法中。</p><p>最后贴下本篇文章的初稿：<a href="https://github.com/zhpanvip/AndroidNote/wiki/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86">AndroidNote#动态代理</a>,同时，欢迎关注<a href="https://github.com/zhpanvip/AndroidNote">AndroidNote</a>,你会有意想不到的收获。</p>]]></content>
    
    
    <categories>
      
      <category>Java进阶</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
      <tag>动态代理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>不得不说的 Android Binder 机制与 AIDL</title>
    <link href="/2021/08/06/47-binder-aidl/"/>
    <url>/2021/08/06/47-binder-aidl/</url>
    
    <content type="html"><![CDATA[<p>说起Android的进程间通信，想必大家都会不约而同的想起Android中的Binder机制。而提起Binder，想必也有不少同学会想起初学Android时被Binder和AIDL支配的恐惧感。但是作为一个Android开发者，Binder是我们必须掌握的知识。因为它是构架整个Android大厦的钢筋和混凝土，连接了Android各个系统服务和上层应用。只有了解了Binder机制才能更加深入的理解Android开发和Android Framework。这也是为什么无论是《Android开发艺术探索》还是《深入理解Android内核涉及思想》这些进阶类书籍把进程间通信和Binder机制放到靠前章节的原因，它太重要了，重要到整个Android Framework都离不开Binder的身影。</p><p>本篇文章我们暂且不去探讨Binder的底层实现，因为就目前而言，笔者掌握的程度也不足以去输出Binder实现原理的的内容。因此，为了不误导大家，这里就来写一写Binder的基础用法以及AIDL。虽然关于Binder和AIDL的基础用法网上的内容比比皆是。但是能把Binder和AIDL写的浅显易懂的文章并不多见。也就导致了很多人觉得Binder跟AIDL的使用都很难。</p><p>本篇文章，我将通过我自己的学习思路来带大家认识Binder机制和AIDL。</p><p>开始之前先给大家推荐一下<a href="https://github.com/zhpanvip/AndroidNote">AndroidNote</a>这个GitHub仓库，这里是我的学习笔记，同时也是我文章初稿的出处。这个仓库中汇总了大量的java进阶和Android进阶知识。是一个比较系统且全面的Android知识库。对于准备面试的同学也是一份不可多得的面试宝典，欢迎大家到GitHub的仓库主页关注。</p><h2 id="一、进程间通信"><a href="#一、进程间通信" class="headerlink" title="一、进程间通信"></a>一、进程间通信</h2><p>在操作系统中，每个进程都有一块独立的内存空间。为了保证程序的的安全性，操作系统都会有一套严格的安全机制来禁止进程间的非法访问。毕竟，如果你的APP能访问到别的APP的运行空间，或者别的APP可以轻而易举的访问到你APP的运行空间，想象一下你是不是崩溃的心都有了。所以，操作系统层面会对应用进程进行内存隔离，以保证APP的运行安全。但是，很多情况下进程间也是需要相互通信的，例如剪贴板的功能，可以从一个程序中复制信息到另一个程序。这就是进程间通信诞生的背景。</p><blockquote><p>广义的讲，进程间通信（Inter-process communication,简称IPC）是指运行在不同进程中的若干线程间的数据交换。</p></blockquote><p>操作系统中常见的进程间通信方式有共享内存、管道、UDS以及Binder等。关于这些进程间的通信方式本篇文章我们不做深究，了解即可。</p><ul><li><p><strong>共享内存（Shared Memory)</strong> 共享内存方式实现进程间通信依靠的是申请一块内存区域，让后将这块内存映射到进程空间中，这样两个进程都可以直接访问这块内存。在进行进程间通信时，两个进程可以利用这块内存空间进行数据交换。通过这样的方式，减少了数据的赋值操作，因此共享内存实现进程间通信在速度上有明显优势。</p></li><li><p><strong>管道（Pipe）</strong> 管道也是操作系统中常见的一种进程间通信方式，Windows系统进程间的通信依赖于此中方式实现。在进行进程间通信时，会在两个进程间建立一根拥有读（read）写(write)功能的管道,一个进程写数据，另一个进程可以读取数据，从而实现进程间通信问题。</p></li><li><p><strong>UDS（UNIX Domain Socket）</strong> UDS也被称为IPC Socket，但它有别于network 的Socket。UDS的内部实现不依赖于TCP/IP协议，而是基于本机的“安全可靠操作”实现。UDS这种进程间通信方式在Android中用到的也是比较多的。</p></li><li><p><strong>Binder</strong> Binder是Android中独有的一种进程间通信方式。它底层依靠mmap,只需要一次数据拷贝，把一块物理内存同时映射到内核和目标进程的用户空间。</p></li></ul><p>本篇文章，我们重点就是了解如何使用Binder实现进程间通信。Binder仅仅从名字来看就给人一种很神秘的感觉，就因为这个名字可能就会吓走不少初学者。但其实Binder本身并没有很神秘，它仅仅是Android系统提供给开发者的一种进程间通信方式。</p><p>而从上述几种进程间通信方式来看，无论是哪种进程间通信，都是需要一个进程提供数据，一个进程获取数据。因此，我们可以把提供数据的一端称为<strong>服务端</strong>，把获取数据的一端称为<strong>客户端</strong>。从这个角度来看Binder是不是就有点类似于HTTP协议了？所以，你完全可以把Binder当成是一种HTTP协议，客户端通过Binder来获取服务端的数据。认识到这一点，再看Binder的使用就会简单多了。</p><h2 id="二、使用Binder实现进程间通信"><a href="#二、使用Binder实现进程间通信" class="headerlink" title="二、使用Binder实现进程间通信"></a>二、使用Binder实现进程间通信</h2><p>使用Binder完成进程间通信其实非常简单。我们举一个查询成绩的例子，服务端提供根据学生姓名查询学生成绩的接口，客户端连接服务端通过学生姓名来查询成绩，而客户端与服务端的媒介就是Binder。</p><h3 id="1-服务端的实现"><a href="#1-服务端的实现" class="headerlink" title="1.服务端的实现"></a>1.服务端的实现</h3><p>服务端自然是要提供服务的，因此就需要我们开启一个Service等待客户端的连接。关于Android的Service这里就不用多说了吧，我们实现一个GradeService并继承Service，来提供成绩查询接口。代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GradeService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Service</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> REQUEST_CODE=<span class="hljs-number">1000</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Binder mBinder = <span class="hljs-keyword">new</span> Binder() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">onTransact</span><span class="hljs-params">(<span class="hljs-keyword">int</span> code, <span class="hljs-meta">@NonNull</span> Parcel data, <span class="hljs-meta">@Nullable</span> Parcel reply, <span class="hljs-keyword">int</span> flags)</span> <span class="hljs-keyword">throws</span> RemoteException </span>&#123;<br>            <span class="hljs-keyword">if</span> (code == REQUEST_CODE) &#123;<br>                String name = data.readString();<br>                <span class="hljs-comment">// 根据姓名查询学生成绩并将成绩写入到返回数据</span><br>                <span class="hljs-keyword">int</span> studentGrade = getStudentGrade(name);<br>                <span class="hljs-keyword">if</span> (reply != <span class="hljs-keyword">null</span>)<br>                    reply.writeInt(studentGrade);<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.onTransact(code, data, reply, flags);<br>        &#125;<br>        <span class="hljs-comment">// 根据姓名查询学生成绩</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getStudentGrade</span><span class="hljs-params">(String name)</span> </span>&#123;         <br>            <span class="hljs-keyword">return</span> StudentMap.getStudentGrade(name);<br>        &#125;<br>    &#125;;<br><br>    <span class="hljs-meta">@Nullable</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> IBinder <span class="hljs-title">onBind</span><span class="hljs-params">(Intent intent)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> mBinder;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>因为我们要实现的是跨进程通信，因此，我们将这个服务端的Service设置到远程进程中，在AndroidManifest文件中如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">service</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;com.zhpan.sample.binder.server.GradeService&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:process</span>=<span class="hljs-string">&quot;:server&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">intent-filter</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">action</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.intent.action.server.gradeservice&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">intent-filter</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">service</span>&gt;</span><br></code></pre></td></tr></table></figure><p>就这样，一个远程的，提供成绩查询的服务就完成了。</p><h3 id="2-客户端的实现"><a href="#2-客户端的实现" class="headerlink" title="2.客户端的实现"></a>2.客户端的实现</h3><p>客户端自然而然的是要连接服务端进程成绩查询。因此，我们在客户端的Activity中取绑定GradeService进行成绩查询。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BinderActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AppCompatActivity</span> </span>&#123;<br>    <span class="hljs-comment">// 远程服务的Binder代理</span><br>    <span class="hljs-keyword">private</span> IBinder mRemoteBinder;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ServiceConnection mServiceConnection = <span class="hljs-keyword">new</span> ServiceConnection() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onServiceConnected</span><span class="hljs-params">(ComponentName componentName, IBinder iBinder)</span> </span>&#123;<br>            <span class="hljs-comment">// 获取远程服务的Binder代理</span><br>            mRemoteBinder = iBinder;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onServiceDisconnected</span><span class="hljs-params">(ComponentName componentName)</span> </span>&#123;<br>            mRemoteBinder = <span class="hljs-keyword">null</span>;<br>        &#125;<br>    &#125;;<br><br><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState);<br>        setContentView(R.layout.activity_binder);<br>        <span class="hljs-comment">// 绑定服务</span><br>        findViewById(R.id.btn_bind_service).setOnClickListener(view -&gt; bindGradeService());<br>        <span class="hljs-comment">// 查询学生成绩</span><br>        findViewById(R.id.btn_find_grade).setOnClickListener(view -&gt; getStudentGrade(<span class="hljs-string">&quot;Anna&quot;</span>));<br>    &#125;<br>    <span class="hljs-comment">// 绑定远程服务</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bindGradeService</span><span class="hljs-params">()</span> </span>&#123;<br>        String action = <span class="hljs-string">&quot;android.intent.action.server.gradeservice&quot;</span>;<br>        Intent intent = <span class="hljs-keyword">new</span> Intent(action);<br>        intent.setPackage(getPackageName());<br>        bindService(intent, mServiceConnection, BIND_AUTO_CREATE);<br>    &#125;<br>    <span class="hljs-comment">// 从远程服务查询学生成绩</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getStudentGrade</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        Parcel data = Parcel.obtain();<br>        Parcel reply = Parcel.obtain();<br>        <span class="hljs-keyword">int</span> grade = <span class="hljs-number">0</span>;<br>        data.writeString(name);<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span> (mRemoteBinder == <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">&quot;Need Bind Remote Server...&quot;</span>);<br>            &#125;<br>            mRemoteBinder.transact(REQUEST_CODE, data, reply, <span class="hljs-number">0</span>);<br>            grade = reply.readInt();<br>        &#125; <span class="hljs-keyword">catch</span> (RemoteException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> grade;<br>    &#125;<br></code></pre></td></tr></table></figure><p>客户端的代码就是通过绑定远程服务，然后获取到服务的Binder代理，来查询学生成绩。可见，使用Binder实现进程间通信是非常简单的，可以说简单的有点出乎所料。那我们之前写的AIDL是什么呢？AIDL生成的那一堆是什么玩意儿？我们且往下看。</p><h2 id="三、代理模式优化Binder使用"><a href="#三、代理模式优化Binder使用" class="headerlink" title="三、代理模式优化Binder使用"></a>三、代理模式优化Binder使用</h2><p>虽然上一章中的代码已经非常简单了，但是还是有可以优化的空间。我们可以通过设计模式来进行优化，让代码更加简洁。</p><p>首先需要定义一个接口查询成绩的接口IGradeInterface，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IGradeInterface</span> </span>&#123;<br>    <span class="hljs-comment">// 查询成绩接口</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getStudentGrade</span><span class="hljs-params">(String name)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-服务端代码优化"><a href="#1-服务端代码优化" class="headerlink" title="1.服务端代码优化"></a>1.服务端代码优化</h3><p>接着，对服务端的代码进行优化。我们实现一个自定义的GradeBinder，并实现上述接口，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GradeBinder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Binder</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IGradeInterface</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getStudentGrade</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> StudentMap.getStudentGrade(name);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">onTransact</span><span class="hljs-params">(<span class="hljs-keyword">int</span> code, <span class="hljs-meta">@NonNull</span> Parcel data, <span class="hljs-meta">@Nullable</span> Parcel reply, <span class="hljs-keyword">int</span> flags)</span> <span class="hljs-keyword">throws</span> RemoteException </span>&#123;<br>        <span class="hljs-keyword">if</span> (code == REQUEST_CODE) &#123;<br>            String name = data.readString();<br>            <span class="hljs-keyword">int</span> studentGrade = getStudentGrade(name);<br>            <span class="hljs-keyword">if</span> (reply != <span class="hljs-keyword">null</span>)<br>                reply.writeInt(studentGrade);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.onTransact(code, data, reply, flags);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码将查询成绩的相关逻辑从Service搬到了GradeBinder中。因此，此时Service中只需要在onBind的时候返回GradeBinder的实例即可。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GradeService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Service</span> </span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> REQUEST_CODE=<span class="hljs-number">1000</span>;<br><br>    <span class="hljs-meta">@Nullable</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> IBinder <span class="hljs-title">onBind</span><span class="hljs-params">(Intent intent)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> GradeBinder();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-客户端代码优化"><a href="#2-客户端代码优化" class="headerlink" title="2.客户端代码优化"></a>2.客户端代码优化</h3><p>客户端优化的思路是在连接到远程服务时候实例化一个代理类，代理类持有Binder，让代理类行使Binder的权利。首先来看代理类的代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BinderProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IGradeInterface</span> </span>&#123;<br>    <span class="hljs-comment">// 被代理的Binder</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> IBinder mBinder;<br>    <span class="hljs-comment">// 私有化构造方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">BinderProxy</span><span class="hljs-params">(IBinder binder)</span> </span>&#123;<br>        mBinder = binder;<br>    &#125;<br><br>    <span class="hljs-comment">// 通过Binde读取成绩</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getStudentGrade</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        Parcel data = Parcel.obtain();<br>        Parcel reply = Parcel.obtain();<br>        <span class="hljs-keyword">int</span> grade = <span class="hljs-number">0</span>;<br>        data.writeString(name);<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span> (mBinder == <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">&quot;Need Bind Remote Server...&quot;</span>);<br>            &#125;<br>            mBinder.transact(REQUEST_CODE, data, reply, <span class="hljs-number">0</span>);<br>            grade = reply.readInt();<br>        &#125; <span class="hljs-keyword">catch</span> (RemoteException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> grade;<br>    &#125;<br><br>    <span class="hljs-comment">// 实例化Binder代理类的对象</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> IGradeInterface <span class="hljs-title">asInterface</span><span class="hljs-params">(IBinder iBinder)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (iBinder == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125; <br>        <br>        <span class="hljs-keyword">if</span> (iBinder <span class="hljs-keyword">instanceof</span> IGradeInterface) &#123;<br>            LogUtils.e(<span class="hljs-string">&quot;当前进程&quot;</span>);<br>            <span class="hljs-comment">// 如果是同一个进程的请求，则直接返回Binder</span><br>            <span class="hljs-keyword">return</span> (IGradeInterface) iBinder;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            LogUtils.e(<span class="hljs-string">&quot;远程进程&quot;</span>);<br>            <span class="hljs-comment">// 如果是跨进程查询则返回Binder的代理对象</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> BinderProxy(iBinder);<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>BinderProxy类的构造方法被设置成了private。同时提供了一个asInterface方法中，这个方法通过判断Binder是不是IGradeInterface类型从而确定是不是跨进程的通信。如果不是跨进程通信，则返回当前这个Binder，否则就返回Binder的这个代理类。</p><p>接下来客户端连接上远程服务的时候使用BinderProxy获取Binder或者BinderProxy实例。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BinderProxyActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BaseViewBindingActivity</span>&lt;<span class="hljs-title">ActivityBinderBinding</span>&gt; </span>&#123;<br>    <span class="hljs-comment">// 此处可能是BinderProxy也可能是GradeBinder</span><br>    <span class="hljs-keyword">private</span> IGradeInterface mBinderProxy;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ServiceConnection mServiceConnection = <span class="hljs-keyword">new</span> ServiceConnection() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onServiceConnected</span><span class="hljs-params">(ComponentName componentName, IBinder iBinder)</span> </span>&#123;<br>            <span class="hljs-comment">// 连接服务成功，根据是否跨进程获取BinderProxy或者GradeBinder实例</span><br>            mBinderProxy = BinderProxy.asInterface(iBinder);<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onServiceDisconnected</span><span class="hljs-params">(ComponentName componentName)</span> </span>&#123;<br>            mBinderProxy = <span class="hljs-keyword">null</span>;<br>        &#125;<br>    &#125;;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState);<br>        binding.btnBindService.setOnClickListener(view -&gt; bindGradeService());<br>      <span class="hljs-comment">// 查询学生成绩点击事件，通过mBinderProxy查询成绩</span><br>        binding.btnFindGrade.setOnClickListener(view -&gt; ToastUtils.showShort(<span class="hljs-string">&quot;Anna grade is &quot;</span> + mBinderProxy.getStudentGrade(<span class="hljs-string">&quot;Anna&quot;</span>)));<br>    &#125;<br><br>    <span class="hljs-comment">// 绑定服务</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bindGradeService</span><span class="hljs-params">()</span> </span>&#123;<br>        String action = <span class="hljs-string">&quot;android.intent.action.server.gradeservice&quot;</span>;<br>        Intent intent = <span class="hljs-keyword">new</span> Intent(action);<br>        intent.setPackage(getPackageName());<br>        bindService(intent, mServiceConnection, BIND_AUTO_CREATE);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，此时的代码相比第一章的代码整洁了不少。但是，代码写起来似乎还没有第一章中的方便。主要是因为要我们增加一个IGradeInterface接口，还要自定义一个GradeBinder，同时，还需要写代理类的相关代码，感觉非常繁琐。那么有没有办法让代码简洁，写起来还不繁琐呢？答案是肯定的，使用AIDL就可以实现。</p><h2 id="四、AIDL"><a href="#四、AIDL" class="headerlink" title="四、AIDL"></a>四、AIDL</h2><p>AIDL是Android Interface Description Languaged 简写。用于描写客户端/服务端通信接口的一种描述语言。提起AIDL相信很多人都会觉得头大，定义一个AIDL接口，生成了那么多不知所云的代码，看起来简直就是灾难。先别担心，如果你看懂了第三章的内容，那么其实你已经完全掌握了AIDL。没错，说白了AIDL生成的那一坨代码其实就是我们第三章中写的代码。即AIDL的原理其实就是使用了代理模式对Binder的使用进行了优化，使用AIDL保证了代码的整洁，同时也省去了自己编写繁琐的代理类相关代码。</p><p>关于AIDL的使用就非常简单了。</p><h3 id="1-创建AIDL接口"><a href="#1-创建AIDL接口" class="headerlink" title="1.创建AIDL接口"></a>1.创建AIDL接口</h3><p>首先，在要创建AIDL的目录上右键-&gt;New-&gt;AIDL-&gt;AIDl File 来创建一个AIDL文件，如下图所示：</p><p><img src="https://raw.githubusercontent.com/zhpanvip/images/master/project/article/framework/4701.webp" alt="截屏2021-08-06 上午12.29.39.png"></p><p>创建一个名为IGradeService的AIDL文件，并添加一个getStudentGrade的方法。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// IGradeService.aidl</span><br><span class="hljs-keyword">package</span> com.zhpan.sample.binder.aidl;<br><br><span class="hljs-comment">// Declare any non-default types here with import statements</span><br><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IGradeService</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Demonstrates some basic types that you can use as parameters</span><br><span class="hljs-comment">     * and return values in AIDL.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">basicTypes</span><span class="hljs-params">(<span class="hljs-keyword">int</span> anInt, <span class="hljs-keyword">long</span> aLong, <span class="hljs-keyword">boolean</span> aBoolean, <span class="hljs-keyword">float</span> aFloat,</span></span><br><span class="hljs-function"><span class="hljs-params">            <span class="hljs-keyword">double</span> aDouble, String aString)</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getStudentGrade</span><span class="hljs-params">(String name)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>接着Rebuild一下项目后IDE就会自动生成AIDL的代码了。</p><h3 id="2-AIDL生成的代码"><a href="#2-AIDL生成的代码" class="headerlink" title="2.AIDL生成的代码"></a>2.AIDL生成的代码</h3><p>在项目的build目录下com.zhpan.sample.binder.aidl包中会看到自动生成的一个名为IGradeService的接口，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 这个接口相当于上一章中的IGradeInterface接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IGradeService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">android</span>.<span class="hljs-title">os</span>.<span class="hljs-title">IInterface</span> </span>&#123;<br>  <br>  ...<br>  <br>  <span class="hljs-comment">// Stub是一个Binder，相当于上一章中的GradeBinder</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Stub</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">android</span>.<span class="hljs-title">os</span>.<span class="hljs-title">Binder</span></span><br><span class="hljs-class">      <span class="hljs-keyword">implements</span> <span class="hljs-title">com</span>.<span class="hljs-title">zhpan</span>.<span class="hljs-title">sample</span>.<span class="hljs-title">binder</span>.<span class="hljs-title">aidl</span>.<span class="hljs-title">IGradeService</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> java.lang.String DESCRIPTOR = <span class="hljs-string">&quot;com.zhpan.sample.binder.aidl.IGradeService&quot;</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Stub</span><span class="hljs-params">()</span> </span>&#123;<br>      <span class="hljs-keyword">this</span>.attachInterface(<span class="hljs-keyword">this</span>, DESCRIPTOR);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> IGradeService <span class="hljs-title">asInterface</span><span class="hljs-params">(android.os.IBinder obj)</span> </span>&#123;<br>      <br>      <span class="hljs-keyword">if</span> ((obj == <span class="hljs-keyword">null</span>)) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>      &#125;<br>      android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);<br>      <span class="hljs-keyword">if</span> (((iin != <span class="hljs-keyword">null</span>) &amp;&amp; (iin <span class="hljs-keyword">instanceof</span> com.zhpan.sample.binder.aidl.IGradeService))) &#123;<br>        <span class="hljs-comment">// 如果是当前进程则直接返回当前Binder对象</span><br>        <span class="hljs-keyword">return</span> ((com.zhpan.sample.binder.aidl.IGradeService) iin);<br>      &#125;<br>      <span class="hljs-comment">// 跨进程则返回Binder的代理对象</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> com.zhpan.sample.binder.aidl.IGradeService.Stub.Proxy(obj);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span> <span class="hljs-keyword">public</span> android.os.<span class="hljs-function">IBinder <span class="hljs-title">asBinder</span><span class="hljs-params">()</span> </span>&#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">onTransact</span><span class="hljs-params">(<span class="hljs-keyword">int</span> code, android.os.Parcel data, android.os.Parcel reply, <span class="hljs-keyword">int</span> flags)</span></span><br><span class="hljs-function">        <span class="hljs-keyword">throws</span> android.os.RemoteException </span>&#123;<br>      java.lang.String descriptor = DESCRIPTOR;<br>      <span class="hljs-keyword">switch</span> (code) &#123;<br>        <span class="hljs-keyword">case</span> INTERFACE_TRANSACTION: &#123;<br>          reply.writeString(descriptor);<br>          <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">case</span> TRANSACTION_basicTypes: &#123;<br>          data.enforceInterface(descriptor);<br>          <span class="hljs-keyword">int</span> _arg0;<br>          _arg0 = data.readInt();<br>          <span class="hljs-keyword">long</span> _arg1;<br>          _arg1 = data.readLong();<br>          <span class="hljs-keyword">boolean</span> _arg2;<br>          _arg2 = (<span class="hljs-number">0</span> != data.readInt());<br>          <span class="hljs-keyword">float</span> _arg3;<br>          _arg3 = data.readFloat();<br>          <span class="hljs-keyword">double</span> _arg4;<br>          _arg4 = data.readDouble();<br>          java.lang.String _arg5;<br>          _arg5 = data.readString();<br>          <span class="hljs-keyword">this</span>.basicTypes(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5);<br>          reply.writeNoException();<br>          <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">case</span> TRANSACTION_getStudentGrade: &#123;<br>          data.enforceInterface(descriptor);<br>          java.lang.String _arg0;<br>          _arg0 = data.readString();<br>          <span class="hljs-keyword">int</span> _result = <span class="hljs-keyword">this</span>.getStudentGrade(_arg0);<br>          reply.writeNoException();<br>          reply.writeInt(_result);<br>          <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">default</span>: &#123;<br>          <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.onTransact(code, data, reply, flags);<br>        &#125;<br>      &#125;<br>    &#125;<br>    <span class="hljs-comment">// Binder的代理类，相当于上一章中的BinderProxy</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Proxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">com</span>.<span class="hljs-title">zhpan</span>.<span class="hljs-title">sample</span>.<span class="hljs-title">binder</span>.<span class="hljs-title">aidl</span>.<span class="hljs-title">IGradeService</span> </span>&#123;<br>      <span class="hljs-keyword">private</span> android.os.IBinder mRemote;<br><br>      Proxy(android.os.IBinder remote) &#123;<br>        mRemote = remote;<br>      &#125;<br><br>      <span class="hljs-meta">@Override</span> <span class="hljs-keyword">public</span> android.os.<span class="hljs-function">IBinder <span class="hljs-title">asBinder</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> mRemote;<br>      &#125;<br><br>      <span class="hljs-keyword">public</span> java.lang.<span class="hljs-function">String <span class="hljs-title">getInterfaceDescriptor</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> DESCRIPTOR;<br>      &#125;<br><br>      <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">basicTypes</span><span class="hljs-params">(<span class="hljs-keyword">int</span> anInt, <span class="hljs-keyword">long</span> aLong, <span class="hljs-keyword">boolean</span> aBoolean, <span class="hljs-keyword">float</span> aFloat,</span></span><br><span class="hljs-function"><span class="hljs-params">          <span class="hljs-keyword">double</span> aDouble, java.lang.String aString)</span> <span class="hljs-keyword">throws</span> android.os.RemoteException </span>&#123;<br>        android.os.Parcel _data = android.os.Parcel.obtain();<br>        android.os.Parcel _reply = android.os.Parcel.obtain();<br>        <span class="hljs-keyword">try</span> &#123;<br>          _data.writeInterfaceToken(DESCRIPTOR);<br>          _data.writeInt(anInt);<br>          _data.writeLong(aLong);<br>          _data.writeInt(((aBoolean) ? (<span class="hljs-number">1</span>) : (<span class="hljs-number">0</span>)));<br>          _data.writeFloat(aFloat);<br>          _data.writeDouble(aDouble);<br>          _data.writeString(aString);<br>          <span class="hljs-keyword">boolean</span> _status = mRemote.transact(Stub.TRANSACTION_basicTypes, _data, _reply, <span class="hljs-number">0</span>);<br>          <span class="hljs-keyword">if</span> (!_status &amp;&amp; getDefaultImpl() != <span class="hljs-keyword">null</span>) &#123;<br>            getDefaultImpl().basicTypes(anInt, aLong, aBoolean, aFloat, aDouble, aString);<br>            <span class="hljs-keyword">return</span>;<br>          &#125;<br>          _reply.readException();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>          _reply.recycle();<br>          _data.recycle();<br>        &#125;<br>      &#125;<br><br>      <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getStudentGrade</span><span class="hljs-params">(java.lang.String name)</span></span><br><span class="hljs-function">          <span class="hljs-keyword">throws</span> android.os.RemoteException </span>&#123;<br>        android.os.Parcel _data = android.os.Parcel.obtain();<br>        android.os.Parcel _reply = android.os.Parcel.obtain();<br>        <span class="hljs-keyword">int</span> _result;<br>        <span class="hljs-keyword">try</span> &#123;<br>          _data.writeInterfaceToken(DESCRIPTOR);<br>          _data.writeString(name);<br>          <span class="hljs-keyword">boolean</span> _status = mRemote.transact(Stub.TRANSACTION_getStudentGrade, _data, _reply, <span class="hljs-number">0</span>);<br>          <span class="hljs-keyword">if</span> (!_status &amp;&amp; getDefaultImpl() != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> getDefaultImpl().getStudentGrade(name);<br>          &#125;<br>          _reply.readException();<br>          _result = _reply.readInt();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>          _reply.recycle();<br>          _data.recycle();<br>        &#125;<br>        <span class="hljs-keyword">return</span> _result;<br>      &#125;<br><br>      <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> com.zhpan.sample.binder.aidl.IGradeService sDefaultImpl;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> TRANSACTION_basicTypes = (android.os.IBinder.FIRST_CALL_TRANSACTION + <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> TRANSACTION_getStudentGrade = (android.os.IBinder.FIRST_CALL_TRANSACTION + <span class="hljs-number">1</span>);<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">setDefaultImpl</span><span class="hljs-params">(com.zhpan.sample.binder.aidl.IGradeService impl)</span> </span>&#123;<br>      <span class="hljs-keyword">if</span> (Stub.Proxy.sDefaultImpl == <span class="hljs-keyword">null</span> &amp;&amp; impl != <span class="hljs-keyword">null</span>) &#123;<br>        Stub.Proxy.sDefaultImpl = impl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>      &#125;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> com.zhpan.sample.binder.aidl.<span class="hljs-function">IGradeService <span class="hljs-title">getDefaultImpl</span><span class="hljs-params">()</span> </span>&#123;<br>      <span class="hljs-keyword">return</span> Stub.Proxy.sDefaultImpl;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * Demonstrates some basic types that you can use as parameters</span><br><span class="hljs-comment">   * and return values in AIDL.</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">basicTypes</span><span class="hljs-params">(<span class="hljs-keyword">int</span> anInt, <span class="hljs-keyword">long</span> aLong, <span class="hljs-keyword">boolean</span> aBoolean, <span class="hljs-keyword">float</span> aFloat, <span class="hljs-keyword">double</span> aDouble,</span></span><br><span class="hljs-function"><span class="hljs-params">      java.lang.String aString)</span> <span class="hljs-keyword">throws</span> android.os.RemoteException</span>;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getStudentGrade</span><span class="hljs-params">(java.lang.String name)</span> <span class="hljs-keyword">throws</span> android.os.RemoteException</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>瞥一眼代码会发现IGradeService接口中有一个名为Stub的内部类，它继承了Binder，并实现了IGradeService接口，并且它的内部有一个asInterface的方法，这个方法与我们上一章BinderProxy中的asInterface一致，只是写的位置不同而已。另外在Stub的onTranscation方法的TRANSACTION_getStudentGrade条件中的代码与GradeBinder的onTranscation方法代码是一样的。</p><p>接着，Stub类中还有一个名为Proxy的内部类。Proxy类与上一章的BinderProxy相对应。可以看到Proxy类的构造方法并没有修饰符，而BinderProxy的构造方法被声明成了private，都可以防止外部通过构造方法区实例化代理类的对象。Proxy的getStudentGrade方法与BinderProxy中的getStudentGrade一样，通过Binder去读取服务端的写入数据。</p><p>有了上述代码之后，我们的服务端Service的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AidlGradeService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Service</span> </span>&#123;<br>    <span class="hljs-comment">// 实现 Stub 的 getStudentGrade 方法</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> IBinder mBinder = <span class="hljs-keyword">new</span> IGradeService.Stub() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">basicTypes</span><span class="hljs-params">(<span class="hljs-keyword">int</span> anInt, <span class="hljs-keyword">long</span> aLong, <span class="hljs-keyword">boolean</span> aBoolean, <span class="hljs-keyword">float</span> aFloat, <span class="hljs-keyword">double</span> aDouble, String aString)</span> <span class="hljs-keyword">throws</span> RemoteException </span>&#123;<br><br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getStudentGrade</span><span class="hljs-params">(String name)</span> <span class="hljs-keyword">throws</span> RemoteException </span>&#123;<br>            <span class="hljs-keyword">return</span> StudentMap.getStudentGrade(name);<br>        &#125;<br>    &#125;;<br><br>    <span class="hljs-meta">@Nullable</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> IBinder <span class="hljs-title">onBind</span><span class="hljs-params">(Intent intent)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> mBinder;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-AIDL客户端"><a href="#3-AIDL客户端" class="headerlink" title="3.AIDL客户端"></a>3.AIDL客户端</h3><p>使用AIDL的客户端实现几乎与第三章中的代码一致。只不过是在连接到服务端后通过IGradeService.Stub下的asInterface方法来获取Binder或者Binder的代理对象。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AidlActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BaseViewBindingActivity</span>&lt;<span class="hljs-title">ActivityBinderBinding</span>&gt; </span>&#123;<br><br>    <span class="hljs-keyword">private</span> IGradeService mBinderProxy;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ServiceConnection mServiceConnection = <span class="hljs-keyword">new</span> ServiceConnection() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onServiceConnected</span><span class="hljs-params">(ComponentName componentName, IBinder iBinder)</span> </span>&#123;<br>            <span class="hljs-comment">// 连接服务后，根据是否跨进程获取Binder或者Binder的代理对象</span><br>            mBinderProxy = IGradeService.Stub.asInterface(iBinder);<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onServiceDisconnected</span><span class="hljs-params">(ComponentName componentName)</span> </span>&#123;<br>            mBinderProxy = <span class="hljs-keyword">null</span>;<br>        &#125;<br>    &#125;;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState);<br>        binding.btnBindService.setOnClickListener(view -&gt; bindGradeService());<br>      <span class="hljs-comment">// 查询学生成绩</span><br>        binding.btnFindGrade.setOnClickListener(view -&gt; getStudentGrade(<span class="hljs-string">&quot;Anna&quot;</span>));<br>    &#125;<br>  <br>    <span class="hljs-comment">// 绑定服务</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bindGradeService</span><span class="hljs-params">()</span> </span>&#123;<br>        String action = <span class="hljs-string">&quot;android.intent.action.server.aidl.gradeservice&quot;</span>;<br>        Intent intent = <span class="hljs-keyword">new</span> Intent(action);<br>        intent.setPackage(getPackageName());<br>        bindService(intent, mServiceConnection, BIND_AUTO_CREATE);<br>    &#125;<br>  <br>    <span class="hljs-comment">// 查询成绩</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getStudentGrade</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> grade = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            grade = mBinderProxy.getStudentGrade(name);<br>        &#125; <span class="hljs-keyword">catch</span> (RemoteException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        ToastUtils.showShort(<span class="hljs-string">&quot;Anna grade is &quot;</span> + grade);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>到这里，关于AIDL的介绍就结束了。有没有惊奇的发现AIDL原来这么简单！</p><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>本篇文章主要带大家认识了进程间通信和Binder与AIDL的使用。通过本篇文章的学习可以发现Binder与AIDL其实是非常简单的。了解了Binder之后，我们就可以去更加深入的学习Android Framework层的知识了。</p><p><a href="https://github.com/zhpanvip/AndroidSample">AndroidSample</a></p>]]></content>
    
    
    <categories>
      
      <category>Framework</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Binder</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>用BVP一比一还原自如客APP裸眼3D效果（Android原生）</title>
    <link href="/2021/08/02/46-banner-3d/"/>
    <url>/2021/08/02/46-banner-3d/</url>
    
    <content type="html"><![CDATA[<p>前几天，<a href="https://juejin.cn/post/6989227733410644005">自如大前端</a>开源了一个裸眼3D效果的Banner轮播图的实现方案。看着非常有意思，于是趁着空闲时间结合我的开源库<a href="https://github.com/zhpanvip/BannerViewPager">BannerViewPager</a>码了一个自如裸眼3D效果的demo。demo基本实现了自如APP的Banner效果。</p><p>关于实现原理，<a href="https://juejin.cn/post/6989227733410644005">自如客APP裸眼3D效果的实现</a>这篇文章已经写得很清楚了，本篇文章就不再赘述了，这里主要看一下代码实现。</p><h2 id="一、监听传感器的ViewSensorLayout"><a href="#一、监听传感器的ViewSensorLayout" class="headerlink" title="一、监听传感器的ViewSensorLayout"></a>一、监听传感器的ViewSensorLayout</h2><p>裸眼3D效果的核心其实就是SensorLayout的实现，这个View通过监听传感器来计算View的位移，然后通过Scroller进行滑动。首先，在构造方法中设置传感器的监听事件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SensorLayout</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Context context, <span class="hljs-meta">@Nullable</span> AttributeSet attrs, <span class="hljs-keyword">int</span> defStyleAttr)</span> </span>&#123;<br>    <span class="hljs-keyword">super</span>(context, attrs, defStyleAttr);<br>    mScroller = <span class="hljs-keyword">new</span> Scroller(context);<br>    mSensorManager = (SensorManager) getContext().getSystemService(Context.SENSOR_SERVICE);<br>    <span class="hljs-comment">// 重力传感器</span><br>    <span class="hljs-keyword">if</span> (mSensorManager != <span class="hljs-keyword">null</span>) &#123;<br>        Sensor accelerateSensor = mSensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER);<br>        <span class="hljs-comment">// 地磁场传感器</span><br>        Sensor magneticSensor = mSensorManager.getDefaultSensor(Sensor.TYPE_MAGNETIC_FIELD);<br>        mSensorManager.registerListener(<span class="hljs-keyword">this</span>, accelerateSensor, SensorManager.SENSOR_DELAY_GAME);<br>        mSensorManager.registerListener(<span class="hljs-keyword">this</span>, magneticSensor, SensorManager.SENSOR_DELAY_GAME);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后，在传感器发生变化的时候通过Scroller来移动View，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onSensorChanged</span><span class="hljs-params">(SensorEvent event)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (event.sensor.getType() == Sensor.TYPE_ACCELEROMETER) &#123;<br>        mAccelerateValues = event.values;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (event.sensor.getType() == Sensor.TYPE_MAGNETIC_FIELD) &#123;<br>        mMagneticValues = event.values;<br>    &#125;<br>    <span class="hljs-keyword">float</span>[] values = <span class="hljs-keyword">new</span> <span class="hljs-keyword">float</span>[<span class="hljs-number">3</span>];<br>    <span class="hljs-keyword">float</span>[] R = <span class="hljs-keyword">new</span> <span class="hljs-keyword">float</span>[<span class="hljs-number">9</span>];<br>    <span class="hljs-keyword">if</span> (mMagneticValues != <span class="hljs-keyword">null</span> &amp;&amp; mAccelerateValues != <span class="hljs-keyword">null</span>)<br>        SensorManager.getRotationMatrix(R, <span class="hljs-keyword">null</span>, mAccelerateValues, mMagneticValues);<br>    SensorManager.getOrientation(R, values);<br>    <span class="hljs-comment">// x轴的偏转角度</span><br>    values[<span class="hljs-number">1</span>] = (<span class="hljs-keyword">float</span>) Math.toDegrees(values[<span class="hljs-number">1</span>]);<br>    <span class="hljs-comment">// y轴的偏转角度</span><br>    values[<span class="hljs-number">2</span>] = (<span class="hljs-keyword">float</span>) Math.toDegrees(values[<span class="hljs-number">2</span>]);<br>    <span class="hljs-keyword">double</span> degreeX = values[<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">double</span> degreeY = values[<span class="hljs-number">2</span>];<br>    <span class="hljs-keyword">if</span> (degreeY &lt;= <span class="hljs-number">0</span> &amp;&amp; degreeY &gt; mDegreeYMin) &#123;<br>        hasChangeX = <span class="hljs-keyword">true</span>;<br>        scrollX = (<span class="hljs-keyword">int</span>) (degreeY / Math.abs(mDegreeYMin) * mXMoveDistance * mDirection);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (degreeY &gt; <span class="hljs-number">0</span> &amp;&amp; degreeY &lt; mDegreeYMax) &#123;<br>        hasChangeX = <span class="hljs-keyword">true</span>;<br>        scrollX = (<span class="hljs-keyword">int</span>) (degreeY / Math.abs(mDegreeYMax) * mXMoveDistance * mDirection);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (degreeX &lt;= <span class="hljs-number">0</span> &amp;&amp; degreeX &gt; mDegreeXMin) &#123;<br>        hasChangeY = <span class="hljs-keyword">true</span>;<br>        scrollY = (<span class="hljs-keyword">int</span>) (degreeX / Math.abs(mDegreeXMin) * mYMoveDistance * mDirection);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (degreeX &gt; <span class="hljs-number">0</span> &amp;&amp; degreeX &lt; mDegreeXMax) &#123;<br>        hasChangeY = <span class="hljs-keyword">true</span>;<br>        scrollY = (<span class="hljs-keyword">int</span>) (degreeX / Math.abs(mDegreeXMax) * mYMoveDistance * mDirection);<br>    &#125;<br>    smoothScroll(hasChangeX ? scrollX : mScroller.getFinalX(), hasChangeY ? scrollY : mScroller.getFinalY());<br>&#125;<br></code></pre></td></tr></table></figure><p>代码中的mDirection表示的是移动的方向，这个参数会开放给外面，来设置跟随传感器移动还是与传感器反向移动。<br>而smoothScroll通过Scroller实现弹性滑动，代码如下：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public void smooth<span class="hljs-constructor">Scroll(<span class="hljs-params">int</span> <span class="hljs-params">destX</span>, <span class="hljs-params">int</span> <span class="hljs-params">destY</span>)</span> &#123;<br>    <span class="hljs-built_in">int</span> scrollY = get<span class="hljs-constructor">ScrollY()</span>;<br>    <span class="hljs-built_in">int</span> delta = destY - scrollY;<br>    mScroller.start<span class="hljs-constructor">Scroll(<span class="hljs-params">destX</span>, <span class="hljs-params">scrollY</span>, 0, <span class="hljs-params">delta</span>, 200)</span>;<br>    invalidate<span class="hljs-literal">()</span>;<br>&#125;<br><br>@Override<br>public void compute<span class="hljs-constructor">Scroll()</span> &#123;<br>    <span class="hljs-keyword">if</span> (mScroller.compute<span class="hljs-constructor">ScrollOffset()</span>) &#123;<br>        scroll<span class="hljs-constructor">To(<span class="hljs-params">mScroller</span>.<span class="hljs-params">getCurrX</span>()</span>, mScroller.get<span class="hljs-constructor">CurrY()</span>);<br>        post<span class="hljs-constructor">Invalidate()</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述的代码核心来自<a href="https://juejin.cn/post/6989227733410644005">自如客APP裸眼3D效果的实现</a>。通过一下布局，便可以实现裸眼3D的效果了。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">FrameLayout</span> <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">com.zhpan.sample.banner3d.SensorLayout</span></span><br><span class="hljs-tag">      <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;match_parent&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ImageView</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/iv_background&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:scaleType</span>=<span class="hljs-string">&quot;centerCrop&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:scaleX</span>=<span class="hljs-string">&quot;1.3&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;match_parent&quot;</span> /&gt;</span><br><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">com.zhpan.sample.banner3d.SensorLayout</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">ImageView</span></span><br><span class="hljs-tag">      <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/iv_mid&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">android:scaleType</span>=<span class="hljs-string">&quot;fitXY&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">android:layout_marginEnd</span>=<span class="hljs-string">&quot;@dimen/dp_16&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">android:layout_marginStart</span>=<span class="hljs-string">&quot;@dimen/dp_16&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">android:layout_gravity</span>=<span class="hljs-string">&quot;bottom&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;@dimen/dp_100&quot;</span> /&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">com.zhpan.sample.banner3d.SensorLayout</span></span><br><span class="hljs-tag">      <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/sensor_layout&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">android:layout_gravity</span>=<span class="hljs-string">&quot;bottom&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ImageView</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/iv_foreground&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:scaleType</span>=<span class="hljs-string">&quot;fitXY&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_marginStart</span>=<span class="hljs-string">&quot;@dimen/dp_16&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_marginEnd</span>=<span class="hljs-string">&quot;@dimen/dp_16&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;@dimen/dp_100&quot;</span> /&gt;</span><br><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">com.zhpan.sample.banner3d.SensorLayout</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">FrameLayout</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/zhpanvip/images/master/project/article/4601.gif" alt="123.gif"></p><h2 id="二、BannerViewPager实现裸眼3D轮播图"><a href="#二、BannerViewPager实现裸眼3D轮播图" class="headerlink" title="二、BannerViewPager实现裸眼3D轮播图"></a>二、BannerViewPager实现裸眼3D轮播图</h2><p>自如APP的Banner是两个Banner叠加在一起来实现的。这里我稍微做了一些优化，即背景层使用ImageView也可以达到一样的效果，而前景层使用<a href="https://github.com/zhpanvip/BannerViewPager">BannerViewPager</a>实现无线轮播。布局文件代码如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">FrameLayout</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:app</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:tools</span>=<span class="hljs-string">&quot;http://schemas.android.com/tools&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">tools:context</span>=<span class="hljs-string">&quot;.MainActivity&quot;</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">com.zhpan.sample.banner3d.SensorLayout</span></span><br><span class="hljs-tag">      <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/sensor_layout&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;@dimen/dp_200&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ImageView</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/iv_background&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:scaleType</span>=<span class="hljs-string">&quot;centerCrop&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:scaleX</span>=<span class="hljs-string">&quot;1.3&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;match_parent&quot;</span> /&gt;</span><br><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">com.zhpan.sample.banner3d.SensorLayout</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">com.zhpan.bannerview.BannerViewPager</span></span><br><span class="hljs-tag">      <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/bvp_foreground&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;@dimen/dp_220&quot;</span> /&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">FrameLayout</span>&gt;</span><br></code></pre></td></tr></table></figure><p>Activity中实现轮播图的代码如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">mBannerForeground.apply &#123;<br>  <span class="hljs-comment">// 为BannerViewPager设置Adapter</span><br>  adapter = ForegroundAdapter()<br>  <span class="hljs-comment">// 设置自动轮播</span><br>  setAutoPlay(<span class="hljs-literal">true</span>)<br>  <span class="hljs-comment">// 设置指示器相关样式</span><br>  setIndicatorStyle(IndicatorStyle.ROUND_RECT)<br>  setIndicatorSlideMode(IndicatorSlideMode.SCALE)<br>  setIndicatorSliderWidth(<br>    resources.getDimensionPixelOffset(R.dimen.dp_7),<br>    resources.getDimensionPixelOffset(R.dimen.dp_10)<br>  )<br>  setIndicatorMargin(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, resources.getDimensionPixelOffset(R.dimen.dp_16), <span class="hljs-number">0</span>)<br>  setIndicatorSliderColor(<br>    resources.getColor(R.color.gray_88),<br>    resources.getColor(R.color.dark_gray)<br>  )<br>  setIndicatorGravity(IndicatorGravity.END)<br>  setScrollDuration(<span class="hljs-number">800</span>)<br>  setIndicatorSliderGap(resources.getDimensionPixelOffset(R.dimen.dp_3))<br>&#125; <span class="hljs-comment">// 页面切换的监听</span><br>.registerOnPageChangeCallback(<span class="hljs-keyword">object</span> : OnPageChangeCallback() &#123;<br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onPageSelected</span><span class="hljs-params">(position: <span class="hljs-type">Int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">val</span> banner3DData = mBannerForeground.<span class="hljs-keyword">data</span>[position]<br>    <span class="hljs-comment">// 切换页面后改变背景</span><br>    mIvBackGround.setImageResource(banner3DData?.background!!)<br>  &#125;<br>&#125;).create(arrayList)<br></code></pre></td></tr></table></figure><p><a href="https://github.com/zhpanvip/BannerViewPager">BannerViewPager</a>的使用非常简单，可以轻松实现一个带有指示器的，且能无限轮播的Banner。如果你不了解<a href="https://github.com/zhpanvip/BannerViewPager">BannerViewPager</a>，可以到GitHub主页查看使用步骤。</p><p>最终，实现的效果几乎与自如APP一模一样。如下图：</p><p><img src="https://raw.githubusercontent.com/zhpanvip/images/master/project/article/4602.gif" alt="ezgif-3-aa7e1b542b89.gif"></p><p>注：图片来源自如APP</p><p>最后，相关代码我已提交至GitHub：<a href="https://github.com/zhpanvip/AndroidSample/tree/master/app/src/main/java/com/zhpan/sample/banner3d">AndroidSample</a></p><p>同时，欢迎关注<a href="https://github.com/zhpanvip/BannerViewPager">BannerViewPager</a>轮播图库。</p>]]></content>
    
    
    <categories>
      
      <category>自定义View</category>
      
    </categories>
    
    
    <tags>
      
      <tag>自定义View</tag>
      
      <tag>BVP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java并发系列番外篇：ThreadLocal原理其实很简单</title>
    <link href="/2021/07/19/45-ThreadLocal/"/>
    <url>/2021/07/19/45-ThreadLocal/</url>
    
    <content type="html"><![CDATA[<p>多线程并发是Java语言中非常重要的一块内容，同时，也是Java基础的一个难点。说它重要是因为多线程是日常开发中频繁用到的知识，说它难是因为多线程并发涉及到的知识点非常之多，想要完全掌握Java的并发相关知识并非易事。也正因此，Java并发成了Java面试中最高频的知识点之一。本系列文章将从Java内存模型、volatile关键字、synchronized关键字、ReetrantLock、Atomic并发类以及线程池等方面来系统的认识Java的并发知识。通过本系列文章的学习你将深入理解volatile关键字的作用，了解到synchronized实现原理、AQS和CLH队列锁，清晰的认识自旋锁、偏向锁、乐观锁、悲观锁…等等一系列让人眼花缭乱的并发知识。</p><p>多线程并发系列文章：</p><p><a href="https://zhangpan.site/2021/05/30/37-jmm-volatile/">这一次，彻底搞懂Java内存模型与volatile关键字</a></p><p><a href="https://zhangpan.site/2021/06/14/39-synchronized/">这一次，彻底搞懂Java中的synchronized关键字</a></p><p><a href="https://zhangpan.site/2021/06/19/40-reentranlock/">这一次，彻底搞懂Java中的ReentrantLock实现原理</a></p><p><a href="https://zhangpan.site/2021/06/26/41-atomic-cas/">这一次，彻底搞懂Java并发包中的Atomic原子类</a></p><p><a href="https://zhangpan.site/2021/07/02/42-wait-notify1/">深入理解Java线程的等待与唤醒机制（一）</a></p><p><a href="https://zhangpan.site/2021/07/03/43-wait-notify2/">深入理解Java线程的等待与唤醒机制（二）</a></p><p><a href="https://zhangpan.site/2021/07/10/44-thread-pool/">Java并发系列终结篇：彻底搞懂Java线程池的工作原理</a></p><p><a href="https://zhangpan.site/2021/07/19/45-ThreadLocal/">Java并发系列番外篇：ThreadLocal原理其实很简单</a></p><p>多线程并发时要解决的一个最重要的问题是多线程共享内存变量同步的问题。前几篇文章无论是volatile、synchronized又或是ReentrantLock和Atomic类无不是解决这一问题。而很多情况下我们只希望某个变量对其他线程不可见，只允许某一个线程访问，而ThreadLocal就提供了这样的能力。本文章是Java并发系列的一个扩展篇，来详细的认识一下ThreadLocal及它的实现原理。</p><h2 id="一、ThreadLocal基础知识"><a href="#一、ThreadLocal基础知识" class="headerlink" title="一、ThreadLocal基础知识"></a>一、ThreadLocal基础知识</h2><p>在平时开发中用到ThreadLocal地方可能并不多，很多同学可能觉得ThreadLocal无足轻重。但事实并非如此，ThreadLocal的地位远比我们认为的重要的多。做Android开发的同学应该都比较了解Android消息机制中的Looper,Looper的底层实现就依赖于ThreadLocal。而Android系统的运行是靠Message驱动的，驱动Message的核心就是Handler和Looper，这意味着Looper支撑了整个Android系统的运行。在后端开发中，ThreadLocal也有它的应用场景，Spring采用Threadlocal的方式，来保证单个线程中的数据库操作使用的是同一个数据库连接。由此可见ThreadLocal在Java体系中占有着举足轻重的地位。</p><h3 id="1-ThreadLocal的使用"><a href="#1-ThreadLocal的使用" class="headerlink" title="1.ThreadLocal的使用"></a>1.ThreadLocal的使用</h3><p>ThreadLocal是一个泛型类，泛型表示ThreadLocal可以存储的类型，它的使用非常简单。举个例子，在子线程中用ThreadLcoal存储一个数字，然后分别在子线程和主线程将中来获取这个值，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    ThreadLocal&lt;Integer&gt; threadLocal = <span class="hljs-keyword">new</span> ThreadLocal&lt;&gt;();<br><br>    <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>        threadLocal.set(<span class="hljs-number">10</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; value = &quot;</span> + threadLocal.get());<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;).start();<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        Thread.sleep(<span class="hljs-number">1000</span>);<br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; value = &quot;</span> + threadLocal.get());<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码的打印结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Thread-<span class="hljs-number">0</span> value = <span class="hljs-number">10</span><br>main value = <span class="hljs-keyword">null</span><br></code></pre></td></tr></table></figure><p>可以看到，我们在子线程中通过ThreadLocal存储了一个10，则子线程中可以取到这个值。而主线程中取到的却是null。这意味着通过某个线程通过ThreadLocal存储的数据，只有在这个线程中才能访问的到。</p><p>除此之外，ThreadLocal可以设置全局的初始值，代码如下：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">ThreadLocal&lt;Integer&gt; threadLocal = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ThreadLocal</span>.</span></span><span class="hljs-keyword">with</span><span class="hljs-constructor">Initial(()</span> -&gt; <span class="hljs-number">10</span>);<br></code></pre></td></tr></table></figure><p>通过ThreadLocal的withInitial方法指定初始值为10，接着分别从子线程和主线程中取值，打印结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Thread-<span class="hljs-number">0</span> value = <span class="hljs-number">10</span><br>main value = <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><p>除了set和get方法之外，ThreadLocal还提供了remove方法，使用很简单这里就不再列举代码了。</p><h2 id="二、ThreadLocal的实现原理"><a href="#二、ThreadLocal的实现原理" class="headerlink" title="二、ThreadLocal的实现原理"></a>二、ThreadLocal的实现原理</h2><p>ThreadLocal究竟是如何做到存储的数据只被设置数据的线程可见的呢？想要搞清楚原因就需要我们分析ThreadLocal是如何实现的了。</p><p>我们从ThreadLocal的set方法着手来看。</p><h3 id="1-ThreadLocal的set过程"><a href="#1-ThreadLocal的set过程" class="headerlink" title="1.ThreadLocal的set过程"></a>1.ThreadLocal的set过程</h3><p>set方法的源码比较简单，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(T value)</span> </span>&#123;<br>    <span class="hljs-comment">// 获取当前线程</span><br>    Thread t = Thread.currentThread();<br>    <span class="hljs-comment">// 获取线程中的ThreadLocalMap</span><br>    ThreadLocalMap map = getMap(t);<br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-comment">// 将值存储到ThreadLocalMap中</span><br>        map.set(<span class="hljs-keyword">this</span>, value);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 创建ThreadLocalMap，并存储值</span><br>        createMap(t, value);<br>    &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">createMap</span><span class="hljs-params">(Thread t, T firstValue)</span> </span>&#123;<br>    <span class="hljs-comment">// 实例化当前线程中的ThreadLocalMap</span><br>    t.threadLocals = <span class="hljs-keyword">new</span> ThreadLocalMap(<span class="hljs-keyword">this</span>, firstValue);<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码首先获取到了当前线程，然后从当前线程中获取ThreadLocalMap，ThreadLocalMap是一个存储K-V的集合，我们后边分析。如果此时ThreadLocalMap不为空，那么就通过ThreadLocalMap的set方法将值存储到当前线程对应的ThreadLocalMap中。如果ThreadLocalMap为空，那么就创建ThreadLcoalMap，然后将值存储到ThreadLocalMap中。并且，这里我们注意到ThreadLocalMap的key是当前的ThreadLocal。</p><h3 id="2-ThreadLocal的get过程"><a href="#2-ThreadLocal的get过程" class="headerlink" title="2.ThreadLocal的get过程"></a>2.ThreadLocal的get过程</h3><p>接下来我们看如何从ThreadLocal中取出数据，get方法的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 获取当前线程</span><br>    Thread t = Thread.currentThread();<br>    <span class="hljs-comment">// 获取当前线程对应的ThreadLocalMap</span><br>    ThreadLocalMap map = getMap(t);<br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-comment">// 从ThreadLocalMap中取出值</span><br>        ThreadLocalMap.Entry e = map.getEntry(<span class="hljs-keyword">this</span>);<br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>            T result = (T)e.value;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 如果值为空则返回初始值</span><br>    <span class="hljs-keyword">return</span> setInitialValue();<br>&#125;<br><span class="hljs-comment">// 为ThreadLocal设置初始值</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> T <span class="hljs-title">setInitialValue</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 初始值为null</span><br>    T value = initialValue();<br>    Thread t = Thread.currentThread();<br>    ThreadLocalMap map = getMap(t);<br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-keyword">null</span>) &#123;<br>        map.set(<span class="hljs-keyword">this</span>, value);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 创建ThreadLocalMap</span><br>        createMap(t, value);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> <span class="hljs-keyword">instanceof</span> TerminatingThreadLocal) &#123;<br>        TerminatingThreadLocal.register((TerminatingThreadLocal&lt;?&gt;) <span class="hljs-keyword">this</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> value;<br>&#125;<br><span class="hljs-comment">// 初始值为空</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> T <span class="hljs-title">initialValue</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，get方法依然是先获取到当前线程，然后拿到当前线程的ThreadLocalMap，并通过ThreadLocalMap的getEntry方法将这个ThreadLocal作为key来取值。如果ThreadLocalMap为null，则会通过setInitialValue方法返回了一个null值。</p><p>总的来看，set方法将value放到了当前线程的ThreadLocalMap中，而key是当前的这个ThreadLocal。而get方法则是获取当前线程中的ThreadLcoalMap，然后将这个ThreadLocal作为key来取出value。到这里其实我们已经能够解答为什么ThreadLocal中的值只能被设置这个值的线程可见了。但是似乎又有点只见树木不见森林的感觉，毕竟ThreadLocalMap是什么东西呢？</p><h3 id="3-ThreadLocalMap"><a href="#3-ThreadLocalMap" class="headerlink" title="3.ThreadLocalMap"></a>3.ThreadLocalMap</h3><p>从前两小节其实我们已经知道，ThreadLocalMap是一个存储K-V类型的数据结构，并且Thread类中维护了一个ThreadLocalMap的成员变量。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Thread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br><br>    ThreadLocal.ThreadLocalMap threadLocals = <span class="hljs-keyword">null</span>;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到ThreadLocalMap是ThreadLocal的内部类,ThreadLocalMap的类结构如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadLocalMap</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> Entry[] table;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> size = <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>ThreadLocalMap内部维护了一个Entry数组，和一个int类型的size。Entry是ThreadLocalMap的内部类，它就是对我们设置的value的封装，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Entry</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WeakReference</span>&lt;<span class="hljs-title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;<br>    Object value;<br><br>    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;<br>        <span class="hljs-keyword">super</span>(k);<br>        value = v;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到Entry类的结构很简单，它继承了WeakReference，并且内部维护了一个Object类型的value。而WeakReference中维护了一个referent的成员，在Entry中就是指ThreadLocal。也就是说Entry中维护了一个ThreadLocal作为key和一个Object的value作为value。</p><p>接下来看ThreadLocalMap的set方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;<br><br><br>    Entry[] tab = table;<br>    <span class="hljs-keyword">int</span> len = tab.length;<br>    <span class="hljs-comment">// 获取key哈希值，作为在Entry数组中的位置</span><br>    <span class="hljs-keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="hljs-number">1</span>);<br>    <span class="hljs-comment">// 出现哈希冲突，这里使用的是线性探测再散列方法来处理</span><br>    <span class="hljs-keyword">for</span> (Entry e = tab[i];<br>         e != <span class="hljs-keyword">null</span>;<br>         e = tab[i = nextIndex(i, len)]) &#123;<br>        ThreadLocal&lt;?&gt; k = e.get();<br><br>        <span class="hljs-keyword">if</span> (k == key) &#123;<br>            e.value = value;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-keyword">null</span>) &#123;<br>            replaceStaleEntry(key, value, i);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 将key和value封装到Entry中，并放入Entry数组</span><br>    tab[i] = <span class="hljs-keyword">new</span> Entry(key, value);<br>    <span class="hljs-keyword">int</span> sz = ++size;<br>    <span class="hljs-keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)<br>        rehash();<br>&#125;<br></code></pre></td></tr></table></figure><p>通过ThreadLocalMap的set方法可以看出，ThreadLocalMap是一个哈希表结构。set方法是将value插入到哈希表中的操作。我们知道哈希表是会出现哈希冲突的，因此，上述代码首先使用线性探测再散列法进行哈希冲突的处理，然后再将value封装成Entry，插入到Entry数组中。如果你不了解哈希表和哈希冲突，可以参考我之前写过的一篇文章<a href="https://juejin.cn/post/6876105622274703368">《面试官：哈希表都不知道，你是怎么看懂HashMap的？》</a></p><p>接下来看ThreadLocalMap的getEntry方法，这里不用想也应该知道getEntry方法一定是从哈希表中取数据的。它的代码如下：</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">private</span> Entry getEntry(ThreadLocal&lt;?&gt; <span class="hljs-built_in">key</span>) &#123;<br>    <span class="hljs-built_in">int</span> i = <span class="hljs-built_in">key</span>.threadLocalHashCode &amp; (table.length - <span class="hljs-number">1</span>);<br>    Entry e = table[i];<br>    <span class="hljs-comment">// 不存在哈希冲突的情况，取到了值</span><br>    <span class="hljs-keyword">if</span> (e != <span class="hljs-keyword">null</span> &amp;&amp; e.<span class="hljs-built_in">get</span>() == <span class="hljs-built_in">key</span>)<br>        <span class="hljs-keyword">return</span> e;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-comment">// 存在哈希冲突的情况，则通过线性探测法来查找值</span><br>        <span class="hljs-keyword">return</span> getEntryAfterMiss(<span class="hljs-built_in">key</span>, i, e);<br>&#125;<br></code></pre></td></tr></table></figure><p>由于是从哈希表中取值，所有这个方法中一定存在两种情况，即存在哈希冲突和不存在哈希冲突。首先，如果不存在哈希冲突，那么直接从Entry数组中取出第i个元素即可。而如果存在哈希冲突，那么则需要继续线性探测来查找key的位置。getEntryAfterMiss就是线性探测的实现，无非就是循环遍历然后比较，这里就不再贴这个方法的代码了。</p><p>如果了解哈希表的话，看懂ThreadLocalMap的代码其实并不难。但是这里有一个问题，为什么ThreadLocalMap中的Entry要继承WeakReference呢？</p><h2 id="三、ThreadLocal内存泄漏问题"><a href="#三、ThreadLocal内存泄漏问题" class="headerlink" title="三、ThreadLocal内存泄漏问题"></a>三、ThreadLocal内存泄漏问题</h2><p>为什么ThreadLocalMap中的Entry要继承WeakReference，使ThreadLocal作为一个弱引用呢？我们知道，弱引用在发生GC时这个对象一定会被回收。通常来说使用弱引用是为了避免内存泄漏。这里也不例外，ThreadLocal使用弱引用可以避免内存泄漏问题的发生。</p><p>试想，如果将ThreadLocal声明为强引用，一旦ThreadLocal不再使用，就需要被回收。但是此时由于ThreadLocalMap中的Entry数组持有了ThreadLocal。导致ThreadLocal不能够被回收而出现内存泄漏。那么，如果将ThreadLocal声明为弱引用就可以避免这一问题的出现。</p><p>那么，是否意味着将Entry中的ThreadLocal声明为弱引用，我们就可以肆无忌惮的使用ThreadLocal也不会出现内存泄漏了？事实并非如此。</p><p>我们来看下面的分析。</p><p><img src="https://raw.githubusercontent.com/zhpanvip/images/master/project/article/thread/threadlocal1.png" alt="threadlocal.png"></p><p>如上图所示，在ThreadLocal中存在一个这样的引用连。如果Thread一直在运行，那么此时由于强引用的value不能被回收，故此种情况下也可能出现内存泄漏的问题。因此，通常来说，在不需要使用这个ThreadLocal变量的使用，需要调用remove方法来避免内存泄漏的问题。</p><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>从源码角度来看ThreadLocal,在了解哈希表的情况下，弄懂它的实现原理其实并不难。ThreadLocal的set方法会将自身作为key，连带value封装到Entry中。然后将这个Entry插入到当前线程的ThreadLocalMap中。这个ThreadLocalMap是一个哈希表结构，内部使用线性探测再散列来存储Entry。</p><p>当然，由于可能存在多个ThreadLocal的情况，如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">ThreadLocal&lt;Integer&gt; threadLocal = <span class="hljs-keyword">new</span> ThreadLocal&lt;&gt;();<br>ThreadLocal&lt;Integer&gt; threadLocal2 = <span class="hljs-keyword">new</span> ThreadLocal&lt;&gt;();<br><br>threadLocal.set(<span class="hljs-number">1</span>);<br>threadLocal2.set(<span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><p>因此，可以给出ThreadLocalMap的结构图如下：</p><p><img src="https://raw.githubusercontent.com/zhpanvip/images/master/project/article/thread/threadlocal2.png" alt="threadlocal2.png"></p>]]></content>
    
    
    <categories>
      
      <category>Java进阶</category>
      
    </categories>
    
    
    <tags>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java并发系列终结篇：彻底搞懂Java线程池的工作原理</title>
    <link href="/2021/07/10/44-thread-pool/"/>
    <url>/2021/07/10/44-thread-pool/</url>
    
    <content type="html"><![CDATA[<p>多线程并发是Java语言中非常重要的一块内容，同时，也是Java基础的一个难点。说它重要是因为多线程是日常开发中频繁用到的知识，说它难是因为多线程并发涉及到的知识点非常之多，想要完全掌握Java的并发相关知识并非易事。也正因此，Java并发成了Java面试中最高频的知识点之一。本系列文章将从Java内存模型、volatile关键字、synchronized关键字、ReetrantLock、Atomic并发类以及线程池等方面来系统的认识Java的并发知识。通过本系列文章的学习你将深入理解volatile关键字的作用，了解到synchronized实现原理、AQS和CLH队列锁，清晰的认识自旋锁、偏向锁、乐观锁、悲观锁…等等一系列让人眼花缭乱的并发知识。</p><p>多线程并发系列文章：</p><p><a href="https://zhangpan.site/2021/05/30/37-jmm-volatile/">这一次，彻底搞懂Java内存模型与volatile关键字</a></p><p><a href="https://zhangpan.site/2021/06/14/39-synchronized/">这一次，彻底搞懂Java中的synchronized关键字</a></p><p><a href="https://zhangpan.site/2021/06/19/40-reentranlock/">这一次，彻底搞懂Java中的ReentrantLock实现原理</a></p><p><a href="https://zhangpan.site/2021/06/26/41-atomic-cas/">这一次，彻底搞懂Java并发包中的Atomic原子类</a></p><p><a href="https://zhangpan.site/2021/07/02/42-wait-notify1/">深入理解Java线程的等待与唤醒机制（一）</a></p><p><a href="https://zhangpan.site/2021/07/03/43-wait-notify2/">深入理解Java线程的等待与唤醒机制（二）</a></p><p><a href="https://zhangpan.site/2021/07/10/44-thread-pool/">Java并发系列终结篇：彻底搞懂Java线程池的工作原理</a></p><p><a href="https://zhangpan.site/2021/07/19/45-ThreadLocal/">Java并发系列番外篇：ThreadLocal原理其实很简单</a></p><p>本篇文章是多线程并发系列的最后一篇，将深入分析Java中线程池的工作原理。个人认为线程池是Java并发中比较难已理解的一块知识，因为线程池内部实现使用到了大量的像ReentrantLock、AQS、AtomicInteger、CAS以及“生产者-消费者”模型等并发相关的知识，基本上涵盖了并发系列前几篇文章的大部分知识点。这也是为什么把线程池放到最后来写的原因。本篇文章权当是一个并发系列的综合练习，刚好巩固实践一下前面知识点的运用。</p><p>开始之前先给大家推荐一下<a href="https://github.com/zhpanvip/AndroidNote">AndroidNote</a>这个GitHub仓库，这里是我的学习笔记，同时也是我文章初稿的出处。这个仓库中汇总了大量的java进阶和Android进阶知识。是一个比较系统且全面的Android知识库。对于准备面试的同学也是一份不可多得的面试宝典，欢迎大家到GitHub的仓库主页关注。</p><h2 id="一、线程池基础知识"><a href="#一、线程池基础知识" class="headerlink" title="一、线程池基础知识"></a>一、线程池基础知识</h2><p>在Java语言中，虽然创建并启动一个线程非常方便，但是由于创建线程需要占用一定的操作系统资源，在高并发的情况下，频繁的创建和销毁线程会大量消耗CPU和内存资源，对程序性能造成很大的影响。为了避免这一问题，Java给我们提供了线程池。</p><p>线程池是一种基于池化技术思想来管理线程的工具。在线程池中维护了多个线程，由线程池统一的管理调配线程来执行任务。通过线程复用，减少了频繁创建和销毁线程的开销。</p><p>本章内容我们先来了解一下线程池的一些基础知识，学习如何使用线程池以及了解线程池的生命周期。</p><h3 id="1-线程池的使用"><a href="#1-线程池的使用" class="headerlink" title="1.线程池的使用"></a>1.线程池的使用</h3><p>线程池的使用和创建可以说非常的简单，这得益于JDK提供给我们良好封装的API。线程池的实现被封装到了ThreadPoolExecutor中，我们可以通过ThreadPoolExecutor的构造方法来实例化出一个线程池，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 实例化一个线程池</span><br>ThreadPoolExecutor executor = <span class="hljs-keyword">new</span> ThreadPoolExecutor(<span class="hljs-number">3</span>, <span class="hljs-number">10</span>, <span class="hljs-number">60</span>,<br>        TimeUnit.SECONDS, <span class="hljs-keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="hljs-number">20</span>));<br><span class="hljs-comment">// 使用线程池执行一个任务        </span><br>executor.execute(() -&gt; &#123;<br>    <span class="hljs-comment">// Do something</span><br>&#125;);<br><span class="hljs-comment">// 关闭线程池,会阻止新任务提交，但不影响已提交的任务</span><br>executor.shutdown();<br><span class="hljs-comment">// 关闭线程池，阻止新任务提交，并且中断当前正在运行的线程</span><br>executor.showdownNow();<br></code></pre></td></tr></table></figure><p>创建好线程池后直接调用execute方法并传入一个Runnable参数即可将任务交给线程池执行，通过shutdown/shutdownNow方法可以关闭线程池。</p><p>ThreadPoolExecutor的构造方法中参数众多，对于初学者而言在没有了解各个参数的作用的情况下很难去配置合适的线程池。因此Java还为我们提供了一个线程池工具类Executors来快捷的创建线程池。Executors提供了很多简便的创建线程池的方法，举两个例子，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 实例化一个单线程的线程池</span><br>ExecutorService singleExecutor = Executors.newSingleThreadExecutor();<br><span class="hljs-comment">// 创建固定线程个数的线程池</span><br>ExecutorService fixedExecutor = Executors.newFixedThreadPool(<span class="hljs-number">10</span>);<br><span class="hljs-comment">// 创建一个可重用固定线程数的线程池</span><br>ExecutorService executorService2 = Executors.newCachedThreadPool();<br></code></pre></td></tr></table></figure><p>但是，通常来说在实际开发中并不推荐直接使用Executors来创建线程池，而是需要根据项目实际情况配置适合自己项目的线程池，关于如何配置合适的线程池这是后话，需要我们理解线程池的各个参数以及线程池的工作原理之后才能有答案。</p><h3 id="2-线程池的生命周期"><a href="#2-线程池的生命周期" class="headerlink" title="2.线程池的生命周期"></a>2.线程池的生命周期</h3><p>线程池从诞生到死亡，中间会经历RUNNING、SHUTDOWN、STOP、TIDYING、TERMINATED五个生命周期状态。</p><ul><li><p><strong>RUNNING</strong> 表示线程池处于运行状态，能够接受新提交的任务且能对已添加的任务进行处理。RUNNING状态是线程池的初始化状态，线程池一旦被创建就处于RUNNING状态。</p></li><li><p><strong>SHUTDOWN</strong> 线程处于关闭状态，不接受新任务，但可以处理已添加的任务。RUNNING状态的线程池调用shutdown后会进入SHUTDOWN状态。</p></li><li><p><strong>STOP</strong> 线程池处于停止状态，不接收任务，不处理已添加的任务，且会中断正在执行任务的线程。RUNNING状态的线程池调用了shutdownNow后会进入STOP状态。</p></li><li><p><strong>TIDYING</strong> 当所有任务已终止，且任务数量为0时，线程池会进入TIDYING。当线程池处于SHUTDOWN状态时，阻塞队列中的任务被执行完了，且线程池中没有正在执行的任务了，状态会由SHUTDOWN变为TIDYING。当线程处于STOP状态时，线程池中没有正在执行的任务时则会由STOP变为TIDYING。</p></li><li><p><strong>TERMINATED</strong> 线程终止状态。处于TIDYING状态的线程执行terminated()后进入TERMINATED状态。</p></li></ul><p>根据上述线程池生命周期状态的描述，可以画出如下所示的线程池生命周期状态流程示意图。</p><p><img src="https://raw.githubusercontent.com/zhpanvip/images/master/project/article/thread/threadlocal1.png" alt="threadpoollifecycle.png"></p><h2 id="二、线程池的工作机制"><a href="#二、线程池的工作机制" class="headerlink" title="二、线程池的工作机制"></a>二、线程池的工作机制</h2><h3 id="1-ThreadPoolExecutor中的参数"><a href="#1-ThreadPoolExecutor中的参数" class="headerlink" title="1.ThreadPoolExecutor中的参数"></a>1.ThreadPoolExecutor中的参数</h3><p>上一小节中，我们使用ThreadPoolExecutor的构造方法来创建了一个线程池。其实在ThreadPoolExecutor中有多个构造方法，但是最终都调用到了下边代码中的这一个构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadPoolExecutor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractExecutorService</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> corePoolSize,</span></span><br><span class="hljs-function"><span class="hljs-params">                              <span class="hljs-keyword">int</span> maximumPoolSize,</span></span><br><span class="hljs-function"><span class="hljs-params">                              <span class="hljs-keyword">long</span> keepAliveTime,</span></span><br><span class="hljs-function"><span class="hljs-params">                              TimeUnit unit,</span></span><br><span class="hljs-function"><span class="hljs-params">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="hljs-function"><span class="hljs-params">                              ThreadFactory threadFactory,</span></span><br><span class="hljs-function"><span class="hljs-params">                              RejectedExecutionHandler handler)</span> </span>&#123;<br>        <span class="hljs-comment">// ...省略校验相关代码</span><br>        <br>        <span class="hljs-keyword">this</span>.corePoolSize = corePoolSize;<br>        <span class="hljs-keyword">this</span>.maximumPoolSize = maximumPoolSize;<br>        <span class="hljs-keyword">this</span>.workQueue = workQueue;<br>        <span class="hljs-keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);<br>        <span class="hljs-keyword">this</span>.threadFactory = threadFactory;<br>        <span class="hljs-keyword">this</span>.handler = handler;<br>    &#125;<br>    <br>    <span class="hljs-comment">// ...    </span><br><br>&#125;<br><br></code></pre></td></tr></table></figure><p>这个构造方法中有7个参数之多，我们逐个来看每个参数所代表的含义：</p><ul><li><p><strong>corePoolSize</strong> 表示线程池的核心线程数。当有任务提交到线程池时，如果线程池中的线程数小于corePoolSize,那么则直接创建新的线程来执行任务。</p></li><li><p><strong>workQueue</strong> 任务队列，它是一个阻塞队列，用于存储来不及执行的任务的队列。当有任务提交到线程池的时候，如果线程池中的线程数大于等于corePoolSize，那么这个任务则会先被放到这个队列中，等待执行。</p></li><li><p><strong>maximumPoolSize</strong> 表示线程池支持的最大线程数量。当一个任务提交到线程池时，线程池中的线程数大于corePoolSize,并且workQueue已满，那么则会创建新的线程执行任务，但是线程数要小于等于maximumPoolSize。</p></li><li><p><strong>keepAliveTime</strong> 非核心线程空闲时保持存活的时间。非核心线程即workQueue满了之后，再提交任务时创建的线程，因为这些线程不是核心线程，所以它空闲时间超过keepAliveTime后则会被回收。</p></li><li><p><strong>unit</strong> 非核心线程空闲时保持存活的时间的单位</p></li><li><p><strong>threadFactory</strong> 创建线程的工厂，可以在这里统一处理创建线程的属性</p></li><li><p><strong>handler</strong> 拒绝策略，当线程池中的线程达到maximumPoolSize线程数后且workQueue已满的情况下，再向线程池提交任务则执行对应的拒绝策略</p></li></ul><h3 id="2-线程池工作流程"><a href="#2-线程池工作流程" class="headerlink" title="2.线程池工作流程"></a>2.线程池工作流程</h3><p>线程池提交任务是从execute方法开始的，我们可以从execute方法来分析线程池的工作流程。</p><p>（1）当execute方法提交一个任务时，如果线程池中线程数小于corePoolSize,那么不管线程池中是否有空闲的线程，都会创建一个新的线程来执行任务。</p><p><img src="https://raw.githubusercontent.com/zhpanvip/images/master/project/article/thread/threadlocal1.png" alt="thread_pool1.png"></p><p>（2）当execute方法提交一个任务时，线程池中的线程数已经达到了corePoolSize,且此时没有空闲的线程，那么则会将任务存储到workQueue中。</p><p><img src="https://raw.githubusercontent.com/zhpanvip/images/master/project/article/thread/thread_pool2.png" alt="thread_pool2.png"><br>（3）如果execute提交任务时线程池中的线程数已经到达了corePoolSize,并且workQueue已满，那么则会创建新的线程来执行任务，但总线程数应该小于maximumPoolSize。<br><img src="https://raw.githubusercontent.com/zhpanvip/images/master/project/article/thread/thread_pool3.png" alt="thread_pool3.png"></p><p>（4）如果线程池中的线程执行完了当前的任务，则会尝试从workQueue中取出第一个任务来执行。如果workQueue为空则会阻塞线程。</p><p><img src="https://raw.githubusercontent.com/zhpanvip/images/master/project/article/thread/thread_pool4.png" alt="thread_pool4.png"></p><p>（5）如果execute提交任务时，线程池中的线程数达到了maximumPoolSize，且workQueue已满，此时会执行拒绝策略来拒绝接受任务。</p><p><img src="https://raw.githubusercontent.com/zhpanvip/images/master/project/article/thread/thread_pool5.png" alt="thread_pool5.png"></p><p>（6）如果线程池中的线程数超过了corePoolSize，那么空闲时间超过keepAliveTime的线程会被销毁，但程池中线程个数会保持为corePoolSize。</p><p><img src="https://raw.githubusercontent.com/zhpanvip/images/master/project/article/thread/thread_pool6.png" alt="thread_pool6.png"></p><p>（7）如果线程池存在空闲的线程，并且设置了allowCoreThreadTimeOut为true。那么空闲时间超过keepAliveTime的线程都会被销毁。</p><p><img src="https://raw.githubusercontent.com/zhpanvip/images/master/project/article/thread/thread_pool7.png" alt="thread_pool7.png"></p><h3 id="3-线程池的拒绝策略"><a href="#3-线程池的拒绝策略" class="headerlink" title="3.线程池的拒绝策略"></a>3.线程池的拒绝策略</h3><p>如果线程池中的线程数达到了maximumPoolSize，并且workQueue队列存储满的情况下，线程池会执行对应的拒绝策略。在JDK中提供了RejectedExecutionHandler接口来执行拒绝操作。实现RejectedExecutionHandler的类有四个，对应了四种拒绝策略。分别如下：</p><ul><li><p><strong>DiscardPolicy</strong> 当提交任务到线程池中被拒绝时，线程池会丢弃这个被拒绝的任务</p></li><li><p><strong>DiscardOldestPolicy</strong> 当提交任务到线程池中被拒绝时，线程池会丢弃等待队列中最老的任务。</p></li><li><p><strong>CallerRunsPolicy</strong> 当提交任务到线程池中被拒绝时，会在线程池当前正在运行的Thread线程中处理被拒绝额任务。即哪个线程提交的任务哪个线程去执行。</p></li><li><p><strong>AbortPolicy</strong> 当提交任务到线程池中被拒绝时，直接抛出RejectedExecutionException异常。</p></li></ul><h2 id="三、线程池源码分析"><a href="#三、线程池源码分析" class="headerlink" title="三、线程池源码分析"></a>三、线程池源码分析</h2><p>从上一章对线程池的工作流程解读来看，线程池的原理似乎并没有很难。但是开篇时我说过想要读懂线程池的源码并不容，主要原因是线程池内部运用到了大量并发相关知识，另外还与线程池中用到的位运算有关。</p><h3 id="1-线程池中的位运算（了解内容）"><a href="#1-线程池中的位运算（了解内容）" class="headerlink" title="1.线程池中的位运算（了解内容）"></a>1.线程池中的位运算（了解内容）</h3><p>在向线程池提交任务时有两个比较中要的参数会决定任务的去向，这两个参数分别是线程池的状态和线程池中的线程数。在ThreadPoolExecutor内部使用了一个AtomicInteger类型的整数ctl来表示这两个参数，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadPoolExecutor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractExecutorService</span> </span>&#123;<br>    <span class="hljs-comment">// Integer.SIZE = 32.所以 COUNT_BITS= 29</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="hljs-number">3</span>;<br>    <span class="hljs-comment">// 00011111 11111111 11111111 11111111 这个值可以表示线程池的最大线程容量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> COUNT_MASK = (<span class="hljs-number">1</span> &lt;&lt; COUNT_BITS) - <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 将-1左移29位得到RUNNING状态的值</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> RUNNING    = -<span class="hljs-number">1</span> &lt;&lt; COUNT_BITS;    <br>    <span class="hljs-comment">// 线程池运行状态和线程数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AtomicInteger ctl = <span class="hljs-keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="hljs-number">0</span>));<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">ctlOf</span><span class="hljs-params">(<span class="hljs-keyword">int</span> rs, <span class="hljs-keyword">int</span> wc)</span> </span>&#123; <span class="hljs-keyword">return</span> rs | wc; &#125;<br>    <br>    <span class="hljs-comment">// ...</span><br>&#125;    <br></code></pre></td></tr></table></figure><p>因为涉及多线程的操作，这里为了保证原子性，ctl参数使用了AtomicInteger类型，并且通过ctlOf方法来计算出了ctl的初始值。如果你不了解位运算大概很难理解上述代码的用意。</p><p>我们知道，int类型在Java中占用4byte的内存,一个byte占用8bit,所以Java中的int类型共占用32bit。对于这个32bit，我们可以进行高低位的拆分。做Android开发的同学应该都了解View测量流程中的MeasureSpec参数，这个参数将32bit的int拆分成了高2位和低30位，分别表示View的测量模式和测量值。而这里的ctl与MeasureSpec类似，ctl将32位的int拆分成了高3位和低29位，分别表示线程池的运行状态和线程池中的线程个数。</p><p>下面我们通过位运算来验证一下ctl是如何工作的，当然，如果你不理解这个位运算的过程对理解线程池的源码影响并不大，所以对以下验证内容不感兴趣的同学可以直接略过。</p><p>可以看到上述代码中RUNNING的值为-1左移29位，我们知道在计算机中<strong>负数是以其绝对值的补码来表示的，而补码是由反码加1得到。</strong>因此-1在计算机中存储形式为1的反码+1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">1</span>的原码：<span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000001</span><br>                                            +<br><span class="hljs-number">1</span>的反码：<span class="hljs-number">11111111</span> <span class="hljs-number">11111111</span> <span class="hljs-number">11111111</span> <span class="hljs-number">11111110</span><br>       ---------------------------------------<br>-<span class="hljs-number">1</span>存储： <span class="hljs-number">11111111</span> <span class="hljs-number">11111111</span> <span class="hljs-number">11111111</span> <span class="hljs-number">11111111</span><br><br></code></pre></td></tr></table></figure><p>接下来对-1左移29位可以得到RUNNING的值为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">// 高三位表示线程状态，即高三位为111表示RUNNING</span><br><span class="hljs-number">11100000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span><br></code></pre></td></tr></table></figure><p>而AtomicInteger初始线程数量是0，因此ctlOf方法中的“|”运算如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Java">RUNNING：  <span class="hljs-number">11100000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span><br>                                               |<br>线程数为<span class="hljs-number">0</span>:  <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span><br>          ---------------------------------------<br>得到ctl：   <span class="hljs-number">11100000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span><br><br></code></pre></td></tr></table></figure><p>通过RUNNING|0(线程数)即可得到ctl的初始值。同时还可以通过以下方法将ctl拆解成运行状态和线程数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 00011111 11111111 11111111 11111111</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> COUNT_MASK = (<span class="hljs-number">1</span> &lt;&lt; COUNT_BITS) - <span class="hljs-number">1</span>;<br><span class="hljs-comment">// 获取线程池运行状态</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">runStateOf</span><span class="hljs-params">(<span class="hljs-keyword">int</span> c)</span>     </span>&#123; <span class="hljs-keyword">return</span> c &amp; ~COUNT_MASK; &#125;<br><span class="hljs-comment">// 获取线程池中的线程数</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">workerCountOf</span><span class="hljs-params">(<span class="hljs-keyword">int</span> c)</span>  </span>&#123; <span class="hljs-keyword">return</span> c &amp; COUNT_MASK; &#125;<br></code></pre></td></tr></table></figure><p>假设此时线程池为RUNNING状态，且线程数为0，验证一下runStateOf是如何得到线程池的运行状态的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">COUNT_MASK:  <span class="hljs-number">00011111</span> <span class="hljs-number">11111111</span> <span class="hljs-number">11111111</span> <span class="hljs-number">11111111</span><br>                                                 <br>~COUNT_MASK: <span class="hljs-number">11100000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span><br>                                                  &amp;<br>ctl:         <span class="hljs-number">11100000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span><br>            ----------------------------------------<br>RUNNING:     <span class="hljs-number">11100000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span>            <br><br></code></pre></td></tr></table></figure><p>如果不理解上边的验证流程没有关系，只要知道通过runStateOf方法可以得到线程池的运行状态，通过workerCountOf可以得到线程池中的线程数即可。</p><p>接下来我们进入线程池的源码的源码分析环节。</p><h3 id="2-ThreadPoolExecutor的execute"><a href="#2-ThreadPoolExecutor的execute" class="headerlink" title="2.ThreadPoolExecutor的execute"></a>2.ThreadPoolExecutor的execute</h3><p>向线程池提交任务的方法是execute方法，execute方法是ThreadPoolExecutor的核心方法，以此方法为入口来进行剖析，execute方法的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(Runnable command)</span> </span>&#123;<br>     <span class="hljs-keyword">if</span> (command == <span class="hljs-keyword">null</span>)<br>         <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();<br>     <span class="hljs-comment">// 获取ctl的值</span><br>     <span class="hljs-keyword">int</span> c = ctl.get();<br>     <span class="hljs-comment">// 1.线程数小于corePoolSize</span><br>     <span class="hljs-keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;<br>         <span class="hljs-comment">// 线程池中线程数小于核心线程数，则尝试创建核心线程执行任务</span><br>         <span class="hljs-keyword">if</span> (addWorker(command, <span class="hljs-keyword">true</span>))<br>             <span class="hljs-keyword">return</span>;<br>         c = ctl.get();<br>     &#125;<br>     <span class="hljs-comment">// 2.到此处说明线程池中线程数大于核心线程数或者创建线程失败</span><br>     <span class="hljs-keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;<br>         <span class="hljs-comment">// 如果线程是运行状态并且可以使用offer将任务加入阻塞队列未满，</span><br>         <span class="hljs-comment">// offer是非阻塞操作。</span><br>         <span class="hljs-keyword">int</span> recheck = ctl.get();<br>         <span class="hljs-comment">// 重新检查线程池状态，因为上次检测后线程池状态可能发生改变，</span><br>         <span class="hljs-comment">// 如果非运行状态就移除任务并执行拒绝策略</span><br>         <span class="hljs-keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))<br>             reject(command);<br>         <span class="hljs-comment">// 如果是运行状态，并且线程数是0，则创建线程</span><br>         <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (workerCountOf(recheck) == <span class="hljs-number">0</span>)<br>             <span class="hljs-comment">// 线程数是0，则创建非核心线程，且不指定首次执行任务，这里的第二个参数其实没有实际意义</span><br>             addWorker(<span class="hljs-keyword">null</span>, <span class="hljs-keyword">false</span>);<br>     &#125;<br>     <span class="hljs-comment">// 3.阻塞队列已满，创建非核心线程执行任务</span><br>     <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!addWorker(command, <span class="hljs-keyword">false</span>))<br>         <span class="hljs-comment">// 如果失败，则执行拒绝策略</span><br>         reject(command);<br> &#125;<br></code></pre></td></tr></table></figure><p>execute方法中的逻辑可以分为三部分：</p><ul><li><p>1.如果线程池中的线程数小于核心线程，则直接调用addWorker方法创建新线程来执行任务。</p></li><li><p>2.如果线程池中的线程数大于核心线程数，则将任务添加到阻塞队列中，接着再次检验线程池的运行状态，因为上次检测过之后线程池状态有可能发生了变化，如果线程池关闭了，那么移除任务，执行拒绝策略。如果线程依然是运行状态，但是线程池中没有线程，那么就调用addWorker方法创建线程，注意此时传入任务参数是null，即不指定执行任务，因为任务已经加入了阻塞队列。创建完线程后从阻塞队列中取出任务执行。</p></li><li><p>3.如果第2步将任务添加到阻塞队列失败了，说明阻塞队列任务已满，那么则会执行第三步，即创建非核心线程来执行任务，如果非核心线程创建失败那么就执行拒绝策略。</p></li></ul><p>可以看到，代码的执行逻辑和我们在第二章中分析的线程池的工作流程是一样的。</p><p>接下来看下execute方法中创建线程的方法addWoker，addWoker方法承担了核心线程和非核心线程的创建，通过一个boolean参数core来区分是创建核心线程还是非核心线程。先来看addWorker方法前半部分的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 返回值表示是否成功创建了线程</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">addWorker</span><span class="hljs-params">(Runnable firstTask, <span class="hljs-keyword">boolean</span> core)</span> </span>&#123;<br>     <span class="hljs-comment">// 这里做了一个retry标记，相当于goto.</span><br>     retry:<br>     <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> c = ctl.get();;) &#123;<br>         <span class="hljs-comment">// Check if queue empty only if necessary.</span><br>         <span class="hljs-keyword">if</span> (runStateAtLeast(c, SHUTDOWN)<br>             &amp;&amp; (runStateAtLeast(c, STOP)<br>                 || firstTask != <span class="hljs-keyword">null</span><br>                 || workQueue.isEmpty()))<br>             <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br><br>         <span class="hljs-keyword">for</span> (;;) &#123;<br>             <span class="hljs-comment">// 根据core来确定创建最大线程数，超过最大值则创建线程失败，</span><br>             <span class="hljs-comment">// 注意这里的最大值可能有三个corePoolSize、maximumPoolSize和线程池线程的最大容量</span><br>             <span class="hljs-keyword">if</span> (workerCountOf(c)<br>                 &gt;= ((core ? corePoolSize : maximumPoolSize) &amp; COUNT_MASK))<br>                 <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>             <span class="hljs-comment">// 通过CAS来将线程数+1，如果成功则跳出循环，执行下边逻辑    </span><br>             <span class="hljs-keyword">if</span> (compareAndIncrementWorkerCount(c))<br>                 <span class="hljs-keyword">break</span> retry;<br>             c = ctl.get();  <span class="hljs-comment">// Re-read ctl</span><br>             <span class="hljs-comment">// 线程池的状态发生了改变，退回retry重新执行</span><br>             <span class="hljs-keyword">if</span> (runStateAtLeast(c, SHUTDOWN))<br>                 <span class="hljs-keyword">continue</span> retry;<br>         &#125;<br>     &#125;<br>     <br>     <span class="hljs-comment">// ...省略后半部分</span><br>    <br>     <span class="hljs-keyword">return</span> workerStarted;<br> &#125;<br></code></pre></td></tr></table></figure><p>这部分代码会通过是否创建核心线程来确定线程池中线程数的值，如果是创建核心线程，那么最大值不能超过corePoolSize,如果是创建非核心线程那么线程数不能超过maximumPoolSize，另外无论是创建核心线程还是非核心线程，最大线程数都不能超过线程池允许的最大线程数COUNT_MASK(有可能设置的maximumPoolSize大于COUNT_MASK)。如果线程数大于最大值就返回false，创建线程失败。</p><p>接下来通过CAS将线程数加1，如果成功那么就break retry结束无限循环，如果CAS失败了则就continue retry从新开始for循环，注意这里的retry不是Java的关键字，是一个可以任意命名的字符。</p><p>接下来，如果能继续向下执行则开始执行创建线程并执行任务的工作了，看下addWorker方法的后半部分代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">addWorker</span><span class="hljs-params">(Runnable firstTask, <span class="hljs-keyword">boolean</span> core)</span> </span>&#123;<br>     <br>     <span class="hljs-comment">// ...省略前半部分</span><br><br>     <span class="hljs-keyword">boolean</span> workerStarted = <span class="hljs-keyword">false</span>;<br>     <span class="hljs-keyword">boolean</span> workerAdded = <span class="hljs-keyword">false</span>;<br>     Worker w = <span class="hljs-keyword">null</span>;<br>     <span class="hljs-keyword">try</span> &#123;<br>         <span class="hljs-comment">// 实例化一个Worker,内部封装了线程</span><br>         w = <span class="hljs-keyword">new</span> Worker(firstTask);<br>         <span class="hljs-comment">// 取出新建的线程</span><br>         <span class="hljs-keyword">final</span> Thread t = w.thread;<br>         <span class="hljs-keyword">if</span> (t != <span class="hljs-keyword">null</span>) &#123;<br>             <span class="hljs-comment">// 这里使用ReentrantLock加锁保证线程安全</span><br>             <span class="hljs-keyword">final</span> ReentrantLock mainLock = <span class="hljs-keyword">this</span>.mainLock;<br>             mainLock.lock();<br>             <span class="hljs-keyword">try</span> &#123;<br>                 <span class="hljs-keyword">int</span> c = ctl.get();<br>                 <span class="hljs-comment">// 拿到锁湖重新检查线程池状态，只有处于RUNNING状态或者</span><br>                 <span class="hljs-comment">// 处于SHUTDOWN并且firstTask==null时候才会创建线程</span><br>                 <span class="hljs-keyword">if</span> (isRunning(c) ||<br>                     (runStateLessThan(c, STOP) &amp;&amp; firstTask == <span class="hljs-keyword">null</span>)) &#123;<br>                     <span class="hljs-comment">// 线程不是处于NEW状态，说明线程已经启动，抛出异常</span><br>                     <span class="hljs-keyword">if</span> (t.getState() != Thread.State.NEW)<br>                         <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalThreadStateException();<br>                     <span class="hljs-comment">// 将线程加入线程队列，这里的worker是一个HashSet   </span><br>                     workers.add(w);<br>                     workerAdded = <span class="hljs-keyword">true</span>;<br>                     <span class="hljs-keyword">int</span> s = workers.size();<br>                     <span class="hljs-keyword">if</span> (s &gt; largestPoolSize)<br>                         largestPoolSize = s;<br>                 &#125;<br>             &#125; <span class="hljs-keyword">finally</span> &#123;<br>                 mainLock.unlock();<br>             &#125;<br>             <span class="hljs-keyword">if</span> (workerAdded) &#123;<br>                 <span class="hljs-comment">// 开启线程执行任务</span><br>                 t.start();<br>                 workerStarted = <span class="hljs-keyword">true</span>;<br>             &#125;<br>         &#125;<br>     &#125; <span class="hljs-keyword">finally</span> &#123;<br>         <span class="hljs-keyword">if</span> (! workerStarted)<br>             addWorkerFailed(w);<br>     &#125;<br>     <span class="hljs-keyword">return</span> workerStarted;<br> &#125;<br></code></pre></td></tr></table></figure><p>这部分逻辑其实比较容易理解，就是创建Worker并开启线程执行任务的过程，Worker是对线程的封装，创建的worker会被添加到ThreadPoolExecutor中的HashSet中。也就是线程池中的线程都维护在这个名为workers的HashSet中并被ThreadPoolExecutor所管理，HashSet中的线程可能处于正在工作的状态，也可能处于空闲状态，一旦达到指定的空闲时间，则会根据条件进行回收线程。</p><p>我们知道，线程调用start后就会开始执行线程的逻辑代码，执行完后线程的生命周期就结束了，那么线程池是如何保证Worker执行完任务后仍然不结束的呢？当线程空闲超时或者关闭线程池又是怎样进行线程回收的呢？这个实现逻辑其实就在Worker中。看下Worker的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Worker</span></span><br><span class="hljs-class">       <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractQueuedSynchronizer</span></span><br><span class="hljs-class">       <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span><br><span class="hljs-class">   </span>&#123;<br>       <span class="hljs-comment">// 执行任务的线程</span><br>       <span class="hljs-keyword">final</span> Thread thread;<br>       <span class="hljs-comment">// 初始化Worker时传进来的任务，可能为null，如果不空，</span><br>       <span class="hljs-comment">// 则创建和立即执行这个task，对应核心线程创建的情况</span><br>       Runnable firstTask;<br><br>       Worker(Runnable firstTask) &#123;<br>           <span class="hljs-comment">// 初始化时设置setate为-1</span><br>           setState(-<span class="hljs-number">1</span>); <span class="hljs-comment">// inhibit interrupts until runWorker</span><br>           <span class="hljs-keyword">this</span>.firstTask = firstTask;<br>           <span class="hljs-comment">// 通过线程工程创建线程</span><br>           <span class="hljs-keyword">this</span>.thread = getThreadFactory().newThread(<span class="hljs-keyword">this</span>);<br>       &#125;<br>       <br>       <span class="hljs-comment">// 线程的真正执行逻辑</span><br>       <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>           runWorker(<span class="hljs-keyword">this</span>);<br>       &#125;<br>       <br>       <span class="hljs-comment">// 判断线程是否是独占状态，如果不是意味着线程处于空闲状态</span><br>       <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isHeldExclusively</span><span class="hljs-params">()</span> </span>&#123;<br>           <span class="hljs-keyword">return</span> getState() != <span class="hljs-number">0</span>;<br>       &#125;<br><br>       <span class="hljs-comment">// 获取锁</span><br>       <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryAcquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> unused)</span> </span>&#123;<br>           <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) &#123;<br>               setExclusiveOwnerThread(Thread.currentThread());<br>               <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>           &#125;<br>           <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>       &#125;<br>       <span class="hljs-comment">// 释放锁</span><br>       <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryRelease</span><span class="hljs-params">(<span class="hljs-keyword">int</span> unused)</span> </span>&#123;<br>           setExclusiveOwnerThread(<span class="hljs-keyword">null</span>);<br>           setState(<span class="hljs-number">0</span>);<br>           <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>       &#125;<br>       <span class="hljs-comment">// ...</span><br>   &#125;<br></code></pre></td></tr></table></figure><p>Worker是位于ThreadPoolExecutor中的一个内部类，它继承了AQS，使用AQS来实现了独占锁的功能，但是并没支持可重入。这里使用不可重入的特性来表示线程的执行状态，即可以通过isHeldExclusively方法来判断，如果是独占状态，说明线程正在执行任务，如果非独占状态，说明线程处于空闲状态。关于AQS我们前边文章中已经详细分析过了，不了解AQS的可以翻看前边ReentrantLock的文章。</p><p>另外，Worker还实现了Runnable接口，因此它的执行逻辑就是在run方法中，run方法调用的是线程池中的runWorker(this)方法。任务的执行逻辑就在runWorker方法中，它的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">runWorker</span><span class="hljs-params">(Worker w)</span> </span>&#123;<br>    Thread wt = Thread.currentThread();<br>    <span class="hljs-comment">// 取出Worker中的任务，可能为空</span><br>    Runnable task = w.firstTask;<br>    w.firstTask = <span class="hljs-keyword">null</span>;<br>    w.unlock(); <span class="hljs-comment">// allow interrupts</span><br>    <span class="hljs-keyword">boolean</span> completedAbruptly = <span class="hljs-keyword">true</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// task不为null或者阻塞队列中有任务，通过循环不断的从阻塞队列中取出任务执行</span><br>        <span class="hljs-keyword">while</span> (task != <span class="hljs-keyword">null</span> || (task = getTask()) != <span class="hljs-keyword">null</span>) &#123;<br>            w.lock();<br>            <span class="hljs-comment">// ...</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 任务执行前的hook点</span><br>                beforeExecute(wt, task);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">// 执行任务</span><br>                    task.run();<br>                    <span class="hljs-comment">// 任务执行后的hook点</span><br>                    afterExecute(task, <span class="hljs-keyword">null</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>                    afterExecute(task, ex);<br>                    <span class="hljs-keyword">throw</span> ex;<br>                &#125;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                task = <span class="hljs-keyword">null</span>;<br>                w.completedTasks++;<br>                w.unlock();<br>            &#125;<br>        &#125;<br>        completedAbruptly = <span class="hljs-keyword">false</span>;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// 超时没有取到任务，则回收空闲超时的线程</span><br>        processWorkerExit(w, completedAbruptly);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，runWorker的核心逻辑就是不断通过getTask方法从阻塞队列中获取任务并执行.通过这样的方式实现了线程的复用，避免了创建线程。这里要注意的是这里是一个“生产者-消费者”模式，getTask是从阻塞队列中取任务，所以如果阻塞队列中没有任务的时候就会处于阻塞状态。getTask中通过判断是否要回收线程而设置了等待超时时间，如果阻塞队列中一直没有任务，那么在等待keepAliveTime时间后会返回一个null。最终会走到上述代码的finally方法中，意味着有线程空闲时间超过了keepAliveTime时间，那么调用processWorkerExit方法移除Worker。processWorkerExit方法中没有复杂难以理解的逻辑，这里就不再贴代码了。我们重点看下getTask中是如何处理的，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">private</span> Runnable <span class="hljs-title">getTask</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">boolean</span> timedOut = <span class="hljs-keyword">false</span>; <span class="hljs-comment">// Did the last poll() time out?</span><br><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-keyword">int</span> c = ctl.get();<br>        <span class="hljs-comment">// ...</span><br>       <br><br>        <span class="hljs-comment">// Flag1. 如果配置了allowCoreThreadTimeOut==true或者线程池中的</span><br>        <span class="hljs-comment">// 线程数大于核心线程数，则timed为true，表示开启指定线程超时后被回收</span><br>        <span class="hljs-keyword">boolean</span> timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;<br>        <br>        <span class="hljs-comment">// ...</span><br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// Flag2. 取出阻塞队列中的任务,注意如果timed为true，则会调用阻塞队列的poll方法，</span><br>            <span class="hljs-comment">// 并设置超时时间为keepAliveTime，如果超时没有取到任务则会返回null。</span><br>            Runnable r = timed ?<br>                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :<br>                workQueue.take();<br>            <span class="hljs-keyword">if</span> (r != <span class="hljs-keyword">null</span>)<br>                <span class="hljs-keyword">return</span> r;<br>            timedOut = <span class="hljs-keyword">true</span>;<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException retry) &#123;<br>            timedOut = <span class="hljs-keyword">false</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>重点看getTask是如何处理空闲超时的逻辑的。我们知道，回收线程的条件是线程大于核心线程数或者配置了allowCoreThreadTimeOut为true,当线程空闲超时的情况下就会回收线程。上述代码在Flag1处先判断了如果线程池中的线程数大于核心线程数，或者开启了allowCoreThreadTimeOut，那么就需要开启线程空闲超时回收。所有在Flag2处，timed为true的情况下调用了阻塞队列的poll方法，并传入了超时时间为keepAliveTime，poll方法是一个阻塞方法，在没有任务时候回进行阻塞。如果在keepAliveTime时间内，没有获取到任务，那么poll方法就会返回null，结束runWorker的循环。进而执行runWorker方法中回收线程的操作。</p><p>这里需要我们理解阻塞队列poll方法的使用，poll方法接受一个时间参数，是一个阻塞操作，在给定的时间内没有获取到数据就返回null。poll方法的核心代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span> (count == <span class="hljs-number">0</span>) &#123; <br>  <span class="hljs-keyword">if</span> (nanos &lt;= <span class="hljs-number">0L</span>) <br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>; <br>  nanos = notEmpty.awaitNanos(nanos); <br>&#125;<br></code></pre></td></tr></table></figure><p>其实说白了，阻塞队列就是一个使用ReentrantLock实现的“生产者-消费者”模式，我们在<a href="https://juejin.cn/post/6980655421497278495/">深入理解Java线程的等待与唤醒机制（二）</a>这篇文章中使用ReentrantLock实现“生产者-消费者”模型其实就是一个简单的阻塞队列，与JDK中的BlockingQueue实现机制类似。感兴趣的同学可以自己查看ArrayBlockingQueue等阻塞队列的实现，限于文章篇幅，这里就不再赘述了。</p><h3 id="3-ThreadPoolExecutor的拒绝策略"><a href="#3-ThreadPoolExecutor的拒绝策略" class="headerlink" title="3.ThreadPoolExecutor的拒绝策略"></a>3.ThreadPoolExecutor的拒绝策略</h3><p>上一小节中我们多次提到线程池的拒绝策略，它是在reject方法中实现的。实现代码也非常简单,代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reject</span><span class="hljs-params">(Runnable command)</span> </span>&#123;<br>    handler.rejectedExecution(command, <span class="hljs-keyword">this</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>通过调用handler的rejectedExecution方法实现。这里其实就是运用了策略模式，handler是一个RejectedExecutionHandler类型的成员变量，RejectedExecutionHandler是一个接口，只有一个rejectedExecution方法。在实例化线程池时构造方法中传入对应的拒绝策略实例即可。前文已经提到了Java提供的几种默认实现分别为DiscardPolicy、DiscardOldestPolicy、CallerRunsPolicy以及AbortPolicy。</p><p>以AbortPolicy直接抛出异常为例，来看下代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbortPolicy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">RejectedExecutionHandler</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AbortPolicy</span><span class="hljs-params">()</span> </span>&#123; &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rejectedExecution</span><span class="hljs-params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RejectedExecutionException(<span class="hljs-string">&quot;Task &quot;</span> + r.toString() +<br>                                             <span class="hljs-string">&quot; rejected from &quot;</span> +<br>                                             e.toString());<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>可以看到直接在rejectedExecution方法中抛出了RejectedExecutionException来拒绝任务。其他的几个策略实现也都比较简单，有兴趣可以自己查阅代码。</p><h3 id="4-ThreadPoolExecutor的shutdown"><a href="#4-ThreadPoolExecutor的shutdown" class="headerlink" title="4.ThreadPoolExecutor的shutdown"></a>4.ThreadPoolExecutor的shutdown</h3><p>调用shutdown方法后，会将线程池标记为SHUTDOWN状态，上边execute的源码可以看出，只有线程池是RUNNING状态才接受任务，因此被标记位SHUTDOWN后，再提交任务会被线程池拒绝。shutdown的代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">shutdown</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> ReentrantLock mainLock = <span class="hljs-keyword">this</span>.mainLock;<br>    mainLock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">//检查是否可以关闭线程</span><br>        checkShutdownAccess();<br>        <span class="hljs-comment">// 将线程池状态置为SHUTDOWN状态</span><br>        advanceRunState(SHUTDOWN);<br>        <span class="hljs-comment">// 尝试中断空闲线程</span><br>        interruptIdleWorkers();<br>        <span class="hljs-comment">// 空方法，线程池关闭的hook点</span><br>        onShutdown(); <br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        mainLock.unlock();<br>    &#125;<br>    tryTerminate();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">interruptIdleWorkers</span><span class="hljs-params">()</span> </span>&#123;<br>    interruptIdleWorkers(<span class="hljs-keyword">false</span>);<br>&#125;    <br><br></code></pre></td></tr></table></figure><p>修改线程池为SHUTDOWN状态后，会调用interruptIdleWorkers去中断空闲线程线程，具体实现逻辑是在interruptIdleWorkers(boolean onlyOne)方法中，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">interruptIdleWorkers</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> onlyOne)</span> </span>&#123;<br>    <span class="hljs-keyword">final</span> ReentrantLock mainLock = <span class="hljs-keyword">this</span>.mainLock;<br>    mainLock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">for</span> (Worker w : workers) &#123;<br>            Thread t = w.thread;<br>            <span class="hljs-comment">// 尝试tryLock获取锁，如果拿锁成功说明线程是空闲状态</span><br>            <span class="hljs-keyword">if</span> (!t.isInterrupted() &amp;&amp; w.tryLock()) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">// 中断线程</span><br>                    t.interrupt();<br>                &#125; <span class="hljs-keyword">catch</span> (SecurityException ignore) &#123;<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    w.unlock();<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (onlyOne)<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        mainLock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>shutdown的逻辑比较简单，里边做了两件比较重要的事情，即先将线程池状态修改为SHUTDOWN，接着遍历所有Worker，将空闲的Worker进行中断。</p><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>本文深入的探究了线程池的工作流程和实现原理。就线程池的工作流程而言其实并不难以理解。但是在分析线程池的源码时，如果没有很好的并发基础的话，大概率是难以读懂线程池的源码的。因为线程池内部使用了大量并发知识，对任何一点用到的并发知识认识不到位都会造成理解偏差。写这篇文章参看了很多的其他线程池的相关文章，几乎没有找到一篇能够剖析清楚线程池源码的文章。归根结底还是没能系统的理解Atomic、Lock与AQS、CAS、阻塞队列等并发相关知识。</p><h2 id="参考-amp-推荐阅读"><a href="#参考-amp-推荐阅读" class="headerlink" title="参考&amp;推荐阅读"></a>参考&amp;推荐阅读</h2><p><a href="https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html">https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html</a></p>]]></content>
    
    
    <categories>
      
      <category>Java进阶</category>
      
    </categories>
    
    
    <tags>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入理解Java线程的等待与唤醒机制（二）</title>
    <link href="/2021/07/03/43-wait-notify2/"/>
    <url>/2021/07/03/43-wait-notify2/</url>
    
    <content type="html"><![CDATA[<p>多线程并发是Java语言中非常重要的一块内容，同时，也是Java基础的一个难点。说它重要是因为多线程是日常开发中频繁用到的知识，说它难是因为多线程并发涉及到的知识点非常之多，想要完全掌握Java的并发相关知识并非易事。也正因此，Java并发成了Java面试中最高频的知识点之一。本系列文章将从Java内存模型、volatile关键字、synchronized关键字、ReetrantLock、Atomic并发类以及线程池等方面来系统的认识Java的并发知识。通过本系列文章的学习你将深入理解volatile关键字的作用，了解到synchronized实现原理、AQS和CLH队列锁，清晰的认识自旋锁、偏向锁、乐观锁、悲观锁…等等一系列让人眼花缭乱的并发知识。</p><p>多线程并发系列文章：</p><p><a href="https://zhangpan.site/2021/05/30/37-jmm-volatile/">这一次，彻底搞懂Java内存模型与volatile关键字</a></p><p><a href="https://zhangpan.site/2021/06/14/39-synchronized/">这一次，彻底搞懂Java中的synchronized关键字</a></p><p><a href="https://zhangpan.site/2021/06/19/40-reentranlock/">这一次，彻底搞懂Java中的ReentrantLock实现原理</a></p><p><a href="https://zhangpan.site/2021/06/26/41-atomic-cas/">这一次，彻底搞懂Java并发包中的Atomic原子类</a></p><p><a href="https://zhangpan.site/2021/07/02/42-wait-notify1/">深入理解Java线程的等待与唤醒机制（一）</a></p><p><a href="https://zhangpan.site/2021/07/03/43-wait-notify2/">深入理解Java线程的等待与唤醒机制（二）</a></p><p><a href="https://zhangpan.site/2021/07/10/44-thread-pool/">Java并发系列终结篇：彻底搞懂Java线程池的工作原理</a></p><p><a href="https://zhangpan.site/2021/07/19/45-ThreadLocal/">Java并发系列番外篇：ThreadLocal原理其实很简单</a></p><p>本文是Java并发系列的第五篇文章，将深入分析Java的唤醒与等待机制。</p><p>上篇文章我们从“生产者-消费者”模型出发，深入的分析了wait和notify/notifyAll的底层实现。并且了解到生产者线程与消费者线程在调用wait时都会被加入到synchronized锁对象monitor的WaitSet队列中。那么在唤醒线程的时候就无法准确的唤醒某一类线程。而在<a href="https://zhangpan.site/2021/06/19/40-reentranlock/">这一次，彻底搞懂Java中的ReentrantLock实现原理</a>这一篇文章中我们认识了更为灵活地显式锁ReentrantLock。ReentrantLock与synchronized类似，也有一套类似wait与notify/notifyAll的等待唤醒机制–Condition。本篇文章我们就来深入的认识ReentrantLock的Condition与线程的等待与唤醒机制。</p><p>开始之前先给大家推荐一下<a href="https://github.com/zhpanvip/AndroidNote">AndroidNote</a>这个GitHub仓库，这里是我的学习笔记，同时也是我文章初稿的出处。这个仓库中汇总了大量的java进阶和Android进阶知识。是一个比较系统且全面的Android知识库。对于准备面试的同学也是一份不可多得的面试宝典，欢迎大家到GitHub的仓库主页关注。</p><h2 id="一、认识Lock的Condition"><a href="#一、认识Lock的Condition" class="headerlink" title="一、认识Lock的Condition"></a>一、认识Lock的Condition</h2><blockquote><p>注：下文中将会多次出现<strong>等待队列</strong>这一关键词，这里指得是调用了await方法后处于等待状态的队列，赢注意与上篇文章中AQS中的<strong>同步队列</strong>做区分。同时，这里的<strong>等待队列</strong>等同于synchronized中的 _WaitSet集合。</p></blockquote><p>在<a href="https://zhangpan.site/2021/06/19/40-reentranlock/">这一次，彻底搞懂Java中的ReentrantLock实现原理</a>中关于Condition其实也有所提及，在使用Lock来保证线程同步时，我们可以使用Condition来协调线程间的协作。相比synchronize的监视器锁，Condition提供了更加灵活和精确的线程控制。它的最大特点是可以为不同的线程建立多个Condition，从而达到精确控制某一些线程的休眠与唤醒。</p><p>Condition是一个接口，内部主要提供了一些线程休眠与唤醒相关的方法，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Condition</span> </span>&#123;<br>  <span class="hljs-comment">// 使当前线程进入等待状态,可以相应中断请求</span><br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">await</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException</span>;<br>  <span class="hljs-comment">// 使当前线程进入等待状态，不响应中断请求</span><br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">awaitUninterruptibly</span><span class="hljs-params">()</span></span>;<br>  <span class="hljs-comment">// 使当前线程进入等待状态，直到被唤醒或中断，或者经过指定的等待时间。nanosTimeout单位纳秒</span><br>  <span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">awaitNanos</span><span class="hljs-params">(<span class="hljs-keyword">long</span> nanosTimeout)</span> <span class="hljs-keyword">throws</span> InterruptedException</span>;<br>  <span class="hljs-comment">// 同awaitNanos方法，可以指定时间单位</span><br>  <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">await</span><span class="hljs-params">(<span class="hljs-keyword">long</span> time, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException</span>;<br>  <span class="hljs-comment">// 使线程进入等待状态，直到被被唤醒或者中断，或者到截止的时间</span><br>  <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">awaitUntil</span><span class="hljs-params">(Date deadline)</span> <span class="hljs-keyword">throws</span> InterruptedException</span>;<br>  <span class="hljs-comment">// 唤醒一个等待在Condition上的线程，与notify功能类似 </span><br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">signal</span><span class="hljs-params">()</span></span>;<br>  <span class="hljs-comment">// 唤醒所有等待在Condition上的线程，与notifyAll类似</span><br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">signalAll</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>Condition的实现类是在AQS中的ConditionObject，关于ConditionObject我们后边再看，接下来看下如何使用Condition来实现线程的等待与唤醒。</p><h3 id="Condition实现“生产者-消费者”模式"><a href="#Condition实现“生产者-消费者”模式" class="headerlink" title="Condition实现“生产者-消费者”模式"></a>Condition实现“生产者-消费者”模式</h3><p>仍然以“生产者-消费者”模式来看Condition的使用，沿用上篇文章生产面包的例子，稍加改动后的面包容器类如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BreadContainer</span> </span>&#123;<br>  LinkedList&lt;Bread&gt; list = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> CAPACITY = <span class="hljs-number">10</span>;<br>  Lock lock = <span class="hljs-keyword">new</span> ReentrantLock();<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Condition providerCondition = lock.newCondition();<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Condition consumerCondition = lock.newCondition();<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(Bread bread)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>      lock.lock();<br>      <span class="hljs-keyword">while</span> (list.size() == CAPACITY) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>          <span class="hljs-comment">// 如果容器已满，则阻塞生产者线程</span><br>          providerCondition.await();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>          e.printStackTrace();<br>        &#125;<br>      &#125;<br>      list.add(bread);<br>      <span class="hljs-comment">// 面包生产成功后通知消费者线程</span><br>      consumerCondition.signalAll();<br>      System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; product a bread&quot;</span> + bread.toString() + <span class="hljs-string">&quot; size = &quot;</span> + list.size());<br><br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>      e.printStackTrace();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>      lock.unlock();<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">take</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>      lock.lock();<br>      <span class="hljs-keyword">while</span> (list.isEmpty()) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>          <span class="hljs-comment">// 如果容器为空，则阻塞消费者线程</span><br>          consumerCondition.await();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>          e.printStackTrace();<br>        &#125;<br>      &#125;<br>      Bread bread = list.removeFirst();<br>      <span class="hljs-comment">// 消费后通知生产者生产面包</span><br>      providerCondition.signalAll();<br>      System.out.println(<span class="hljs-string">&quot;Consumer &quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot; consume a bread&quot;</span> + bread.toString() + <span class="hljs-string">&quot; size = &quot;</span> + list.size());<br><br><br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>      e.printStackTrace();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>      lock.unlock();<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，在上述代码中我们声明了两个Condition，一个生产者Condition，一个消费者Condition。在put方法中使用ReentrantLock来实现同步，同时，当容器满时调用生产者Condition的await方法使生产者线程进入等待状态。如果生产成功，则调用消费者Condition的signalAll方法来唤醒消费者线程。take方法与put类似，不再赘述。这里要注意的是在使用Condition前必须先获得锁。</p><p>生产者消费者类与synchronize的实现一致，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">// 生产者</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Producer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> BreadContainer container;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Producer</span><span class="hljs-params">(BreadContainer container)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.container = container;<br>  &#125;<br><br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>    container.put(<span class="hljs-keyword">new</span> Bread());<br>  &#125;<br>&#125;<br><span class="hljs-comment">// 消费者</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Consumer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> BreadContainer container;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Consumer</span><span class="hljs-params">(BreadContainer container)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.container = container;<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>    container.take();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>那接下来测试类我们仍然实例化多个生产者线程与多个消费者线程，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    BreadContainer container = <span class="hljs-keyword">new</span> BreadContainer();<br>    <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>        <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Producer(container)).start();<br>      &#125;<br>    &#125;).start();<br><br>    <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>        <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Consumer(container)).start();<br>      &#125;<br>    &#125;).start();<br><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行后生产者线程与消费者线程可以很好的实现线程协作。与使用synchronized不同的是这里有两个Condition，分别来控制生产者和消费者。</p><p>接下来，我们分析一下Condition的实现原理</p><h2 id="二、Condition实现原理"><a href="#二、Condition实现原理" class="headerlink" title="二、Condition实现原理"></a>二、Condition实现原理</h2><p>上一章中我们已经知道Condition仅仅是一个接口，它的具体实现是在AQS的内部类ConditionObject中。调用ReentrantLock的newCondition实际上就是实例化了一个ConditionObject，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ReentrantLock#Sync</span><br><span class="hljs-function"><span class="hljs-keyword">final</span> ConditionObject <span class="hljs-title">newCondition</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ConditionObject();<br>    &#125;<br></code></pre></td></tr></table></figure><p>可见，在第一章BreadContainer中的providerCondition与consumerCondition是两个不同的ConditionObject实例。</p><p>ConditionObject的类结构如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConditionObject</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Condition</span>, <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span> </span>&#123;<br>  <span class="hljs-comment">// 指向等待队列的头结点</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> Node firstWaiter;<br>  <span class="hljs-comment">// 指向等待队列的尾结点</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> Node lastWaiter;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ConditionObject</span><span class="hljs-params">()</span> </span>&#123; &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>ConditionObject的结构比较简单，它内部维护了一个Node类型<strong>等待队列</strong>。其中firstWaiter指向队列的头结点，而lastWaiter指向队列的尾结点。关于Node节点，在ReentrantLock那篇文章中已经详细介绍过了，它封装的是一个线程的节点，这里也不再赘述。在线程中调用了Condition的await方法后，线程就会被封装成一个Node节点，并将Node的waitStatus设置成CONDITION状态，然后插入到这个Condition的等待队列中。等到收到singal或者被中断、超时就会被从等待队列中移除。其结构示意图如下：</p><p><img src="https://raw.githubusercontent.com/zhpanvip/images/master/project/article/thread/condition_waitset.png" alt="condition_waitset.png"></p><p>接下来我们从源码的角度来分析Condition的实现。</p><h3 id="1-Condition的await方法"><a href="#1-Condition的await方法" class="headerlink" title="1.Condition的await方法"></a>1.Condition的await方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">await</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    <span class="hljs-comment">// 如果线程被标记位中断状态，则抛出中断异常</span><br>    <span class="hljs-keyword">if</span> (Thread.interrupted())<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InterruptedException();<br>    <span class="hljs-comment">// 将当前线程封装成一个Node节点，并添加到等待队列    </span><br>    Node node = addConditionWaiter();<br>    <span class="hljs-comment">// 释放锁</span><br>    <span class="hljs-keyword">int</span> savedState = fullyRelease(node);<br>    <span class="hljs-keyword">int</span> interruptMode = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 判断当前node是否在同步队列中，注意如果不在同步队列，则是一个阻塞的死循环</span><br>    <span class="hljs-keyword">while</span> (!isOnSyncQueue(node)) &#123;<br>        <span class="hljs-comment">// 不在同步队列中，则挂起线程</span><br>        LockSupport.park(<span class="hljs-keyword">this</span>);<br>        <span class="hljs-keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-comment">// 到这里说明节点已加入到同步队列中，调用acquireQueued开始排队竞争锁</span><br>    <span class="hljs-keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)<br>        interruptMode = REINTERRUPT;<br>    <span class="hljs-keyword">if</span> (node.nextWaiter != <span class="hljs-keyword">null</span>) <span class="hljs-comment">// clean up if cancelled</span><br>        <span class="hljs-comment">// 清理被标记为CANCLLED状态的节点</span><br>        unlinkCancelledWaiters();<br>    <span class="hljs-keyword">if</span> (interruptMode != <span class="hljs-number">0</span>)<br>        reportInterruptAfterWait(interruptMode);<br>&#125;<br></code></pre></td></tr></table></figure><p>在wait方法中首先会调用addConditionWaiter方法将线程封装成一个Node节点，并加入到等待队列中。addConditionWaiter的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> Node <span class="hljs-title">addConditionWaiter</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!isHeldExclusively())<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalMonitorStateException();<br>    Node t = lastWaiter;<br>    <span class="hljs-comment">// 清除CANCLLED状态的lastWaiter节点</span><br>    <span class="hljs-keyword">if</span> (t != <span class="hljs-keyword">null</span> &amp;&amp; t.waitStatus != Node.CONDITION) &#123;<br>        unlinkCancelledWaiters();<br>        t = lastWaiter;<br>    &#125;<br>    <span class="hljs-comment">// 实例化一个Node节点，并标记为CONDITION状态</span><br>    Node node = <span class="hljs-keyword">new</span> Node(Node.CONDITION);<br>    <span class="hljs-comment">// 将node加入到等待队列</span><br>    <span class="hljs-keyword">if</span> (t == <span class="hljs-keyword">null</span>)<br>        firstWaiter = node;<br>    <span class="hljs-keyword">else</span><br>        t.nextWaiter = node;<br>    lastWaiter = node;<br>    <span class="hljs-keyword">return</span> node;<br>&#125;<br></code></pre></td></tr></table></figure><p>addConditionWaiter方法的逻辑比较简单，就是将线程封装成Node并加入等待队列的操作。加入队列后，await方法又调用了fullyRelease去释放锁，在fullyRelease方法中会将state置为0，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">fullyRelease</span><span class="hljs-params">(Node node)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 获取AQS中的state</span><br>        <span class="hljs-keyword">int</span> savedState = getState();<br>        <span class="hljs-comment">// 调用release释放锁</span><br>        <span class="hljs-keyword">if</span> (release(savedState))<br>            <span class="hljs-keyword">return</span> savedState;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalMonitorStateException();<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>        <span class="hljs-comment">// 释放失败则将节点置为CANCELLED状态</span><br>        node.waitStatus = Node.CANCELLED;<br>        <span class="hljs-keyword">throw</span> t;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个方法主要是调用了release方法来释放锁，如果释放失败，则将节点置为CANCELLED状态。关于release这个方法在ReentrantLock中已经分析过，这里不再赘述。</p><p>释放锁之后，开启while来调用isOnSyncQueue方法，这个方法是用来判断当前节点是否在同步队列中。如果不在同步队列，则会进入自旋，并阻塞线程，等待节点进入同步队列。isOnSyncQueue的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isOnSyncQueue</span><span class="hljs-params">(Node node)</span> </span>&#123;<br>    <span class="hljs-comment">// 如果waitStatus是CONDITION状态或者node的前驱节点是null，说明该节点在等待队列中，而非同步队列。</span><br>    <span class="hljs-keyword">if</span> (node.waitStatus == Node.CONDITION || node.prev == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    <span class="hljs-comment">// 如果node.next不为null，则一定在同步队列    </span><br>    <span class="hljs-keyword">if</span> (node.next != <span class="hljs-keyword">null</span>) <br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    <span class="hljs-comment">// 如果前面没有确定node是否在同步队列，则遍历同步队列查看是否存在node节点</span><br>    <span class="hljs-keyword">return</span> findNodeFromTail(node);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">findNodeFromTail</span><span class="hljs-params">(Node node)</span> </span>&#123;<br>    <span class="hljs-comment">// tail即同步队列的队尾，从队尾遍历并与node对比</span><br>    <span class="hljs-keyword">for</span> (Node p = tail;;) &#123;<br>        <span class="hljs-keyword">if</span> (p == node)<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        <span class="hljs-keyword">if</span> (p == <span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        p = p.prev;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果isOnSyncQueue返回了true，那么说明该node节点已经进入同步队列中了，则会结束自旋并调用acquireQueued，关于acquireQueued在ReentrantLock文章中已经详细分析过了，它是一个判断当前node的前驱节点是不是head，如果不是head则挂起线程，如果是head则唤醒并尝试获取锁的操作。</p><p>总的来说，调用await方法会让线程进入等待队列，并释放锁。当等待队列中的节点被唤醒时，会将节点移入到同步队列，然后await结束自旋，并调用acquireQueued来获取锁。</p><h3 id="2-Condition的signal方法"><a href="#2-Condition的signal方法" class="headerlink" title="2.Condition的signal方法"></a>2.Condition的signal方法</h3><p>可以通过调用Condition的signal或者signalAll方法来唤醒线程。不同的是signalAll方法会唤醒所有等待状态的线程，而singal只会唤醒等待队列头部的线程节点。这里我们选用signal方法来分析，signal方法类似Object中的notify方法，调用signal方法会将等待队列的首节点移入同步队列并唤醒。它的实现相比await来说会比较容易理解，看下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">signal</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!isHeldExclusively())<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalMonitorStateException();<br>    Node first = firstWaiter;<br>    <span class="hljs-keyword">if</span> (first != <span class="hljs-keyword">null</span>)<br>        <span class="hljs-comment">// 唤醒等待队列的第一个节点</span><br>        doSignal(first);<br>&#125;<br></code></pre></td></tr></table></figure><p>在signal中会拿到等待队列的首节点并调用doSignal方法将其唤醒，doSignal代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doSignal</span><span class="hljs-params">(Node first)</span> </span>&#123;<br>    <span class="hljs-keyword">do</span> &#123;<br>        <span class="hljs-keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="hljs-keyword">null</span>)<br>            lastWaiter = <span class="hljs-keyword">null</span>;<br>        first.nextWaiter = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-comment">// 尝试唤醒等待队列的首节点，如果唤醒失败则继续尝试</span><br>    &#125; <span class="hljs-keyword">while</span> (!transferForSignal(first) &amp;&amp;<br>             (first = firstWaiter) != <span class="hljs-keyword">null</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>doSignal方法中是一个循环唤醒等待队列首节点的操作，核心方法是transferForSignal，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">transferForSignal</span><span class="hljs-params">(Node node)</span> </span>&#123;<br>    <span class="hljs-comment">// 如果当前节点状态为CONDITION，则CAS将状态改为0,准备加入同步队列，</span><br>    <span class="hljs-comment">// 如果状态不为CONDITION，则说明线程被中断，返回false，然后唤醒当前节点的后继节点</span><br>    <span class="hljs-keyword">if</span> (!node.compareAndSetWaitStatus(Node.CONDITION, <span class="hljs-number">0</span>))<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br><br>    <span class="hljs-comment">// 将节点加入到同步队列，并返回同步队列的先驱节点</span><br>    Node p = enq(node);<br>    <span class="hljs-keyword">int</span> ws = p.waitStatus;<br>    <span class="hljs-comment">// waitStatus&gt;0为取消状态，则CAS尝试修改成SINGAL状态</span><br>    <span class="hljs-keyword">if</span> (ws &gt; <span class="hljs-number">0</span> || !p.compareAndSetWaitStatus(ws, Node.SIGNAL))<br>        <span class="hljs-comment">// 如果修改状态失败，那么久直接唤醒当前线程</span><br>        LockSupport.unpark(node.thread);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> Node <span class="hljs-title">enq</span><span class="hljs-params">(Node node)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        Node oldTail = tail;<br>        <span class="hljs-keyword">if</span> (oldTail != <span class="hljs-keyword">null</span>) &#123;<br>            node.setPrevRelaxed(oldTail);<br>            <span class="hljs-keyword">if</span> (compareAndSetTail(oldTail, node)) &#123;<br>                oldTail.next = node;<br>                <span class="hljs-keyword">return</span> oldTail;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            initializeSyncQueue();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>transferForSignal实际上就是做了一个队列的转移，将node从等待队列移动到了同步队列。进入同步队列后，在wait方法中的自旋操作便能检测到node节点的状态，从而执行acquireQueued方法拿锁。</p><p>总的来说signal方法会从等待队列的队首开始，尝试唤醒队首线程，如果该节点是CANCELLED状态，则继续唤醒下一个节点。当节点被唤醒后会将其加入到同步队列，接着wait方法停止自旋执行acquireQueued方法。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过对Condition的await与signal方法的分析，可以看得出来这两个方法并非独立存在，而是一个相互配合的关系。await方法会将执行的线程封装成Node加入到等待队列，然后开启一个循环检测这个node看是否被加入到了同步队列，如果被加入到同步队列，那么调用acquireQueued开始排队竞争锁，如果没有被加入同步队列，则会一直挂起线程等待被唤醒。而signal方法则是将等待队列中的队首元素移动到同步队列，这样就触发了await方法的循环终结，继而能够执行acquireQueued方法。其流程如下图所示：</p><p><img src="https://raw.githubusercontent.com/zhpanvip/images/master/project/article/thread/await_singal.png" alt="await_singal.png"></p><p>关于Java线程的等待与唤醒机制，到这里就全部结束了，通过本篇文章的学习，更加深入的了解了线程等待与唤醒的原理，其实可以看得出来无论synchronized监视器锁的等待与唤醒还是Lock锁的等待与唤醒都有着类似的原理，只不过synchronized是虚拟机底层实现，而ReentrantLock是基于Java层的实现。</p>]]></content>
    
    
    <categories>
      
      <category>Java进阶</category>
      
    </categories>
    
    
    <tags>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入理解Java线程的等待与唤醒机制（一）</title>
    <link href="/2021/07/02/42-wait-notify1/"/>
    <url>/2021/07/02/42-wait-notify1/</url>
    
    <content type="html"><![CDATA[<p>多线程并发是Java语言中非常重要的一块内容，同时，也是Java基础的一个难点。说它重要是因为多线程是日常开发中频繁用到的知识，说它难是因为多线程并发涉及到的知识点非常之多，想要完全掌握Java的并发相关知识并非易事。也正因此，Java并发成了Java面试中最高频的知识点之一。本系列文章将从Java内存模型、volatile关键字、synchronized关键字、ReetrantLock、Atomic并发类以及线程池等方面来系统的认识Java的并发知识。通过本系列文章的学习你将深入理解volatile关键字的作用，了解到synchronized实现原理、AQS和CLH队列锁，清晰的认识自旋锁、偏向锁、乐观锁、悲观锁…等等一系列让人眼花缭乱的并发知识。</p><p>多线程并发系列文章：</p><p><a href="https://juejin.cn/post/6967739352784830494">这一次，彻底搞懂Java内存模型与volatile关键字</a></p><p><a href="https://juejin.cn/post/6973571891915128846">这一次，彻底搞懂Java中的synchronized关键字</a></p><p><a href="https://juejin.cn/post/6975435256111300621">这一次，彻底搞懂Java中的ReentranLock实现原理</a></p><p><a href="https://juejin.cn/post/6977993272538955806">这一次，彻底搞懂Java并发包中的Atomic原子类</a></p><p><a href="https://juejin.cn/post/6980002998361522190">深入理解Java线程的等待与唤醒机制（一）</a></p><p><a href="https://juejin.cn/post/6980655421497278495/">深入理解Java线程的等待与唤醒机制（二）</a></p><p><a href="https://juejin.cn/post/6983213662383112206/">Java并发系列终结篇：彻底搞懂Java线程池的工作原理</a></p><p><a href="https://juejin.cn/post/6986301941269659656">Java并发系列番外篇：ThreadLocal原理其实很简单</a></p><p>本文是Java并发系列的第五篇文章，将深入分析Java的唤醒与等待机制。</p><p>关于线程的等待与唤醒想必大家都不陌生，毕竟在初学Java基础时都是重点学习的内容。在前两篇分析synchronized与ReentranLock的文章中我们略过了线程的等待与唤醒相关内容，主要是因为想要深入的理解线程的等待与唤醒机制并不容易，因此将这一知识点单独写篇文章来分析。那么本篇文章我们将从synchronized与ReentranLock两个方面来深入分下线程的等待与唤醒。</p><p>开始之前先给大家推荐一下<a href="https://github.com/zhpanvip/AndroidNote">AndroidNote</a>这个GitHub仓库，这里是我的学习笔记，同时也是我文章初稿的出处。这个仓库中汇总了大量的java进阶和Android进阶知识。是一个比较系统且全面的Android知识库。对于准备面试的同学也是一份不可多得的面试宝典，欢迎大家到GitHub的仓库主页关注。</p><h2 id="一、从synchronized锁看线程等待与唤醒"><a href="#一、从synchronized锁看线程等待与唤醒" class="headerlink" title="一、从synchronized锁看线程等待与唤醒"></a>一、从synchronized锁看线程等待与唤醒</h2><p>初学Java的时候想必大家都用synchronized实现过“生产者-消费者”模型的代码，其中用到了几个Object中的方法如wait()、notify()、notifyAll()，不知道当时的你是否有些困惑，线程等待与唤醒相关的方法为什么会定义在Object类中呢？</p><p>什么？你连“生产者-消费者”模型都忘了是什么了？好吧，我们还是先来看下回顾一下“生产者-消费者”模型吧。</p><h3 id="1-“生产者-消费者”模型"><a href="#1-“生产者-消费者”模型" class="headerlink" title="1.“生产者-消费者”模型"></a>1.“生产者-消费者”模型</h3><p>“生产者-消费者”模型是一个典型的线程协作通信的例子。在这一模型中有两类角色，即若干个生产者线程和若干个消费者线程。生产者线程负责提交用户请求，消费者线程负责处理生产者提交的请求。很多情况下，生产者与消费者不能够达到一定的平衡，即有时候生产者生产的速度过快，消费之来不及消费；而有时候可能是消费者过于旺盛，生产者来不及生产。在此情况下就需要一个生产者与消费者共享的内存缓存区来平衡二者的协作。生产者与消费者之间通过共享内存缓存区进行通信，从而平衡生产者与消费者线程，并将生产者和消费者解耦。如下图所示：</p><p><img src="https://raw.githubusercontent.com/zhpanvip/images/master/project/article/thread/wait_notify.png" alt="1C2478F7-48B7-4ACA-A575-ABF8B71F40B9.png"></p><p>当队列容器中没有商品的时候，就需要让消费者处于等待状态，而当容器满了之后就需要生产者处于等待状态。而消费者每消费一个商品，又会通知正在等待的生产者可以进行生产了；当生产则生产一个商品，也会通知正在等待的消费者可以消费了。</p><h3 id="2-使用synchronized实现“生产者-消费者”模型"><a href="#2-使用synchronized实现“生产者-消费者”模型" class="headerlink" title="2.使用synchronized实现“生产者-消费者”模型"></a>2.使用synchronized实现“生产者-消费者”模型</h3><p>了解了“生产者-消费者”模型后，我们尝试使用synchronized关键字结合wait()与notifyAll()方法来实现一个”生产者-消费者“模型的例子。</p><p>我们选一个比较经典的生产面包的例子来看，首先需要一个面包容器类，容器类中有放入面包和取出面包两个操作，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BreadContainer</span> </span>&#123;<br><br>    LinkedList&lt;Bread&gt; list = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>    <span class="hljs-comment">// 容器容量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> CAPACITY = <span class="hljs-number">10</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 放入面包</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(Bread bread)</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (list.size() == CAPACITY) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 如果容器已满，则阻塞生产者线程</span><br>                wait();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>        list.add(bread);<br>        <span class="hljs-comment">// 面包生产成功后通知消费者线程</span><br>        notify();<br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; product a bread&quot;</span> + bread.toString() + <span class="hljs-string">&quot; size = &quot;</span> + list.size());<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 取出面包</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> Bread <span class="hljs-title">take</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (list.isEmpty()) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 如果容器为空，则阻塞消费者线程</span><br>                wait();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>        Bread bread = list.removeFirst();<br>        <span class="hljs-comment">// 消费后通知生产者生产面包</span><br>        notify();<br>        System.out.println(<span class="hljs-string">&quot;Consumer &quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot; consume a bread&quot;</span> + bread.toString() + <span class="hljs-string">&quot; size = &quot;</span> + list.size());<br>        <span class="hljs-keyword">return</span> bread;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上述代码的put方法会将生产好的面包放入到容器中。如果容器已经满了，那么需要阻塞生产者线程来停止生产，当生产者成功将面包放入容器后则需要尝试唤醒等待中的消费者线程进行消费。</p><p>而take方法则是取出面包的操作，当容器为空，则阻塞消费者线程，让其进行等待，如果成功消费面包后则通知生产者开始生产。</p><p>另外需要注意一下，这两个方法都使用了synchronized关键字，如果你看过<a href="https://zhangpan.site/2021/06/14/39-synchronized/">这一次，彻底搞懂Java中的synchronized关键字</a>这篇文章的话应该知道此时synchronized加锁的对象就是这两个方法所在的实例对象，即BreadContainer对象，而在这两个方法中调用的wait()和notify()两个方法同样属于BreadContainer对象。记住这段话，这里留个Flag,我们后边分析。</p><p>接下来生产者与消费者的实现就比较简单了，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 生产者</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Producer</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> BreadContainer container;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Producer</span><span class="hljs-params">()</span> </span>&#123;<br>        container = <span class="hljs-keyword">new</span> BreadContainer();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> BreadContainer <span class="hljs-title">getContainer</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> container;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 生产者生产面包</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">makeBread</span><span class="hljs-params">()</span> </span>&#123;<br>        container.put(<span class="hljs-keyword">new</span> Bread());<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 消费者</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Consumer</span> </span>&#123;<br>    BreadContainer container;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Consumer</span><span class="hljs-params">(BreadContainer container)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.container = container;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">takeBread</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (; ; ) &#123;<br>            Bread bread = container.take();<br>            bread.eat();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来在测试代码中，同时开启多个生产者线程与多个消费者线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>    <span class="hljs-comment">// 实例化生产者</span><br>    Producer producer = <span class="hljs-keyword">new</span> Producer();<br>    <span class="hljs-comment">// 实例化消费者</span><br>    Consumer consumer = <span class="hljs-keyword">new</span> Consumer(producer.getContainer());<br>    <span class="hljs-comment">// 开启生产者线程</span><br>    <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100000</span>; i++) &#123;<br>            producer.makeBread();<br>        &#125;<br>    &#125;).start();<br><br>    <span class="hljs-comment">// 消费者在主线程消费   </span><br>    consumer.takeBread();<br>&#125;<br></code></pre></td></tr></table></figure><p>此时运行main方法，生成者与消费者线程就可以很好的协同工作了。</p><p>注意，在main方法中我们实例化了一个BreadContainer对象，上边Flag处说的synchronized锁的对象即为这个container，调用的wait和notify方法也是container实例的方法。到这里不知道你是否会有疑问，究竟container的wait和notify方法对象成做了什么能让线程阻塞和唤醒呢？被阻塞的线程放到哪里去了？为什么要调用container对象中的wait和notify方法？如果换成调用其他对象的wait和notify是否可行呢？</p><h2 id="二、wait-与notify底层实现原理"><a href="#二、wait-与notify底层实现原理" class="headerlink" title="二、wait()与notify底层实现原理"></a>二、wait()与notify底层实现原理</h2><p>在<a href="https://zhangpan.site/2021/06/14/39-synchronized/">这一次，彻底搞懂Java中的synchronized关键字</a>中我们已经知道，使用synchronized关键字后，synchronized锁住的对象会关联一个monitor对象，当有一个线程获得synchronized锁后，monitor对象中的count就会被加1，并且会将这个线程的id存入到monitor的_ower中。此时，如果其他线程来尝试拿锁则会被放入到<code>_EntryList</code>队列中阻塞。</p><p>还记得上一节中我们立的一个Flag了吗？synchronized锁的是container对象，而wait和notify也是container对象的方法，这么一看我们上一节中留下的问题就有些眉目了。是不是调用wait方法的时候线程也会被加入到一个等待队列，而等到notify或者notifyAll的时候再从等待队列中将线程唤醒呢？关于这个问题在<a href="https://juejin.cn/post/6973571891915128846">这一次，彻底搞懂Java中的synchronized关键字</a>这篇文章中其实已经有解读了，就是调用wait方法的线程会被加入到一个<code>_WaitSet</code>集合中，并会将线程挂起。但是，这里要再次强调一下<code>_WaitSet</code>与<code>_EntryList</code>这两个集合。<code>_EntryList</code>集合中存放的是没有抢到锁，而被阻塞的线程，而_WaitSet集合中存放的是调用了wait方法后，处于等待状态的线程。**</p><p>想要证明上述的结论，就需要我们来看下wait和notify/notifyAll到底做了什么。</p><p>我们看下Object中wait、notify、notifyAll三个方法的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Object</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notify</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notifyAll</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">wait</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        wait(<span class="hljs-number">0L</span>);<br>    &#125; <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title">wait</span><span class="hljs-params">(<span class="hljs-keyword">long</span> timeoutMillis)</span> <span class="hljs-keyword">throws</span> InterruptedException</span>;    <br><br>&#125;<br></code></pre></td></tr></table></figure><p>很可惜，这几个方法都是native方法，也就是说这几个方法都是在虚拟机中使用C/C++实现的。既然如此，不妨扒一扒虚拟机的代码来一探究竟，毕竟口说无凭。</p><h3 id="1-虚拟机对wait的实现"><a href="#1-虚拟机对wait的实现" class="headerlink" title="1.虚拟机对wait的实现"></a>1.虚拟机对wait的实现</h3><p>承接上一节中”生产者-消费者“模型的代码来分析，当生产者线程往容器里边放面包的时候发现容器已经满了，则调用wait方法，那么此时这个线程就会释放锁并进入到阻塞状态。</p><p>Object 中 wait 方法的实现是在 <a href="https://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/782f3b88b5ba/src/share/vm/runtime/objectMonitor.cpp">objectMonitor.cpp</a> 中的 <code>ObjectMonitor::wait(jlong millis, bool interruptible, TRAPS)</code>函数中,ObjectMonitor::wait中的核心相关代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ObjectMonitor::wait</span><span class="hljs-params">(jlong <span class="hljs-built_in">millis</span>, <span class="hljs-keyword">bool</span> interruptible, TRAPS)</span> </span>&#123;<br>    <span class="hljs-comment">// ...省略其他代码</span><br>    <br>    <span class="hljs-comment">// 当前线程</span><br>    Thread * <span class="hljs-keyword">const</span> Self = THREAD ;<br>    <span class="hljs-comment">// 将线程封装成ObjectWaiter</span><br>    <span class="hljs-function">ObjectWaiter <span class="hljs-title">node</span><span class="hljs-params">(Self)</span></span>;<br>    <span class="hljs-comment">// 标记为Wait状态</span><br>    node.TState = ObjectWaiter::TS_WAIT ;<br>    Self-&gt;_ParkEvent-&gt;reset() ;<br><br>    Thread::SpinAcquire (&amp;_WaitSetLock, <span class="hljs-string">&quot;WaitSet - add&quot;</span>) ;<br>    <span class="hljs-comment">// 调用 AddWaiter 方法将线程加入到等待队列中</span><br>    AddWaiter (&amp;node) ;<br>    Thread::SpinRelease (&amp;_WaitSetLock) ;<br>    <br>    <span class="hljs-comment">// ...</span><br>    <br>    <span class="hljs-comment">// 释放 monitor 锁,并将自己挂起</span><br>    <span class="hljs-built_in">exit</span> (<span class="hljs-literal">true</span>, Self) ; <br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，调用 wait 函数后，线程被封装成了一个 ObjectWaiter 对象，并通过AddWaiter 函数将线程加入到等待队列中,先来看下 AddWaiter 函数的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ObjectMonitor::AddWaiter</span><span class="hljs-params">(ObjectWaiter* node)</span> </span>&#123;<br>    <span class="hljs-comment">// 如果 _WaitSet 还没有初始化，先初始化 _WaitSet</span><br>    <span class="hljs-keyword">if</span> (_WaitSet == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-comment">// 初始化 _WaitSet 的头结点,此时只有一个node元素</span><br>        _WaitSet = node;<br>        <span class="hljs-comment">// 可以看出ObjectWaiter是一个双向链表，这里将node的首尾相连，说明_WaitSet是一个循环链表</span><br>        node-&gt;_prev = node;<br>        node-&gt;_next = node;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// _WaitSet 的头结点</span><br>        ObjectWaiter* head = _WaitSet ;<br>        <span class="hljs-comment">// 环形链表头结点的prev就是尾结点</span><br>        ObjectWaiter* tail = head-&gt;_prev;<br>        assert(tail-&gt;_next == head, <span class="hljs-string">&quot;invariant check&quot;</span>);<br>        <span class="hljs-comment">// 将node插入到_WaitSet的尾结点中</span><br>        tail-&gt;_next = node;<br>        head-&gt;_prev = node;<br>        node-&gt;_next = head;<br>        node-&gt;_prev = tail;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>AddWaiter函数的实现其实比较简单，会初始化一个<code>_WaitSet</code>链表，并将node插入到<code>_WaitSet</code>的队尾，从代码中也可以看出这个 <code>_WaitSet</code> 链表是一个循环的双向链表。</p><p>完成线程的插入队列操作后，继续调用 exit 函数来释放 monito r锁,并挂起自己。关于这个方法，后边还会涉及到，源码后边再看。</p><h3 id="2-虚拟机对notify的实现"><a href="#2-虚拟机对notify的实现" class="headerlink" title="2.虚拟机对notify的实现"></a>2.虚拟机对notify的实现</h3><p>在生产者生产完面包后则会调用notifyAll来唤醒消费者线程。notifyAll 方法会唤醒所有线程，而 notify 只会唤醒一个线程。此处我们以notify为例来看<a href="https://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/782f3b88b5ba/src/share/vm/runtime/objectMonitor.cpp">objectMonitor.cpp</a>中 notify 函数是如何唤醒线程的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ObjectMonitor::notify</span><span class="hljs-params">(TRAPS)</span> </span>&#123;<br> <br>    <span class="hljs-keyword">int</span> Policy = Knob_MoveNotifyee ;<br>    <span class="hljs-comment">// DequeueWaiter是一个函数，会返回 _WaitSet 的头结点</span><br>    ObjectWaiter * iterator = DequeueWaiter() ;<br>    <span class="hljs-keyword">if</span> (iterator != <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-comment">// 将阻塞队列赋值给 List</span><br>        ObjectWaiter * List = _EntryList ;<br><br>        <span class="hljs-comment">// 根据策略执行不同的逻辑，Policy默认值为2</span><br>        <span class="hljs-keyword">if</span> (Policy == <span class="hljs-number">0</span>) &#123;       <span class="hljs-comment">// prepend to EntryList</span><br>            <span class="hljs-comment">// ...</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (Policy == <span class="hljs-number">1</span>) &#123;      <span class="hljs-comment">// append to EntryList</span><br>            <span class="hljs-comment">// ...</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (Policy == <span class="hljs-number">2</span>) &#123;      <span class="hljs-comment">// prepend to cxq</span><br>            <span class="hljs-comment">// prepend to cxq</span><br>            <span class="hljs-keyword">if</span> (List == <span class="hljs-literal">NULL</span>) &#123;<br>                <span class="hljs-comment">// iterator 的前驱与后继节点置空</span><br>                iterator-&gt;_next = iterator-&gt;_prev = <span class="hljs-literal">NULL</span> ;<br>                <span class="hljs-comment">// _EntryList指向这个节点，说明节点已被加入阻塞队列，等待获取锁</span><br>                _EntryList = iterator ;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                iterator-&gt;TState = ObjectWaiter::TS_CXQ ;<br>                <span class="hljs-keyword">for</span> (;;) &#123; <span class="hljs-comment">// 通过CAS将iterator插入到 _cxq 队列</span><br>                    ObjectWaiter * Front = _cxq ;<br>                    iterator-&gt;_next = Front ;<br>                    <span class="hljs-keyword">if</span> (Atomic::cmpxchg_ptr (iterator, &amp;_cxq, Front) == Front) &#123;<br>                        <span class="hljs-keyword">break</span> ;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (Policy == <span class="hljs-number">3</span>) &#123;      <span class="hljs-comment">// append to cxq</span><br>            <span class="hljs-comment">// ...</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在 notify 函数中首先调用了DequeueWaiter 函数， DequeueWaiter 函数的作用是取出<code>_WaitSet</code>链表的头结点，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">inline</span> ObjectWaiter* <span class="hljs-title">ObjectMonitor::DequeueWaiter</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// dequeue the very first waiter</span><br>    ObjectWaiter* waiter = _WaitSet;<br>    <span class="hljs-keyword">if</span> (waiter) &#123;<br>        DequeueSpecificWaiter(waiter);<br>    &#125;<br>    <span class="hljs-keyword">return</span> waiter;<br>&#125;<br><span class="hljs-comment">// 将头结点 从队列中断开</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ObjectMonitor::DequeueSpecificWaiter</span><span class="hljs-params">(ObjectWaiter* node)</span> </span>&#123;<br>  <span class="hljs-comment">// ...</span><br>  <br>  ObjectWaiter* next = node-&gt;_next;<br>  <span class="hljs-keyword">if</span> (next == node) &#123;<br>    <span class="hljs-comment">// 此时，队列中只有一个元素，因此取出后，队列就是NULL了</span><br>    _WaitSet = <span class="hljs-literal">NULL</span>;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    ObjectWaiter* prev = node-&gt;_prev;<br>    <span class="hljs-comment">// 这一操作就是将 node 从队列移除，并重新连接队列</span><br>    next-&gt;_prev = prev;<br>    prev-&gt;_next = next;<br>    <span class="hljs-keyword">if</span> (_WaitSet == node) &#123;<br>      _WaitSet = next;<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// 将 node 的前驱节点与后继节点置空</span><br>  node-&gt;_next = <span class="hljs-literal">NULL</span>;<br>  node-&gt;_prev = <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，DequeueWaiter 函数中又调用了 DequeueSpecificWaiter 函数，在这个函数中，如果队列只有一个节点，则将<code>_WaitSet</code>置空，即取出头结点后，队列中没有元素了。如果有多个节点，那么 会将头结点从队列中取出，并重新拼接好 <code>_WaitSet</code> 队列。然后将取出的这个节点的前驱节点和后继节点置空。</p><p>notify 函数接下来的代码判断如果 iterator 不为 NULL 说明存在等待状态的线程，需要将这个等待的线程转入阻塞线程的队列中去。接下来根据 Policy 来执行不同的逻辑，Policy 默认值为2，所以这里只关注默认情况情况。即当Policy为2时，接着将 <code>_EntryList</code>赋值给List，如果List等于NULL，说明此时没有阻塞状态的线程。那么就将 <code>_EntryList </code> 指向 iterator。标志着这个等待中的线程进入了阻塞状态，并且能够获取锁了，但此时线程还未被唤醒。如果List等于NULL，那么就通过CAS将等待状态的线程移入到了<code>_cxq</code> 队列，<code>_cxq</code>队列只是一个临时队列，在后边exit函数中最终还是会被移入<code>_EntryList</code>中。这里一定要注意区分<strong>阻塞状态</strong>与<strong>等待状态</strong>，以及<strong>等待队列</strong>和<strong>阻塞队列</strong>。</p><h3 id="3-虚拟机的exist函数"><a href="#3-虚拟机的exist函数" class="headerlink" title="3.虚拟机的exist函数"></a>3.虚拟机的exist函数</h3><p>可见notify函数中只是对线程进行了队列转移，并没有被实际唤醒。而实际唤醒线程的操作就是在本章第1小节中已经提到的exist中实现的。只不过此时exist函数的调用时机是在虚拟机读取到 monitorexist 指令之后。看下简化后的 exit 函数代码，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ObjectMonitor::exit</span><span class="hljs-params">(<span class="hljs-keyword">bool</span> not_suspended, TRAPS)</span> </span>&#123;<br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-comment">// 这里是一个死循环</span><br>  <span class="hljs-keyword">for</span> (;;) &#123;<br><br>        ObjectWaiter * w = <span class="hljs-literal">NULL</span> ;<br>        <span class="hljs-comment">// QMode默认值为0</span><br>        <span class="hljs-keyword">int</span> QMode = Knob_QMode ;<br>        <br>        <span class="hljs-keyword">if</span> (QMode == <span class="hljs-number">2</span> &amp;&amp; _cxq != <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-comment">// ... 这里从_cxq队列取头结点并唤醒，无关省略。</span><br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br><br>        <span class="hljs-comment">// ...</span><br>        <br>        w = _EntryList  ;<br>        <span class="hljs-comment">// 先查看_EntryList是否为空</span><br>        <span class="hljs-keyword">if</span> (w != <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-comment">// _EntryList不为空，通过ExitEpilog函数唤醒_EntryList队列的头结点</span><br>            ExitEpilog (Self, w) ;<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        <span class="hljs-comment">// 到这里说明_EntryList为空，将则将 w 指向 _cxq</span><br>        w = _cxq ;<br>        <span class="hljs-comment">// _cxq 是 NULL 说明没有等待状态的线程需要唤醒，则继续执行循环</span><br>        <span class="hljs-keyword">if</span> (w == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">continue</span> ;<br><br>        <span class="hljs-comment">// ...</span><br><br>        <span class="hljs-comment">// 走到这说明有处于等待状态，需要唤醒的线程</span><br>    <br>        <span class="hljs-keyword">if</span> (QMode == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-comment">// ...</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 如果走到此处说明_cxq队列不为空</span><br>            <span class="hljs-comment">// QMode == 0 or QMode == 2</span><br>            <span class="hljs-comment">// 此时_EntryList队列是空，将_EntryList指向_cxq队列</span><br>            _EntryList = w ;<br>            ObjectWaiter * q = <span class="hljs-literal">NULL</span> ;<br>            ObjectWaiter * p ;<br>            <span class="hljs-comment">// 将单向链表变成双向环链表</span><br>            <span class="hljs-keyword">for</span> (p = w ; p != <span class="hljs-literal">NULL</span> ; p = p-&gt;_next) &#123;<br>                guarantee (p-&gt;TState == ObjectWaiter::TS_CXQ, <span class="hljs-string">&quot;Invariant&quot;</span>) ;<br>                p-&gt;TState = ObjectWaiter::TS_ENTER ;<br>                p-&gt;_prev = q ;<br>                q = p ;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (_succ != <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">continue</span>;<br><br>        w = _EntryList  ;<br>        <span class="hljs-keyword">if</span> (w != <span class="hljs-literal">NULL</span>) &#123;<br>            guarantee (w-&gt;TState == ObjectWaiter::TS_ENTER, <span class="hljs-string">&quot;invariant&quot;</span>) ;<br>            <span class="hljs-comment">// 唤醒_EntryList的头结点</span><br>            ExitEpilog (Self, w) ;<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>    &#125;<br>    <br><span class="hljs-comment">// 释放锁并唤醒线程    </span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ObjectMonitor::ExitEpilog</span> <span class="hljs-params">(Thread * Self, ObjectWaiter * Wakee)</span> </span>&#123;<br>    assert (_owner == Self, <span class="hljs-string">&quot;invariant&quot;</span>) ;<br><br>    <span class="hljs-comment">// Exit protocol:</span><br>    <span class="hljs-comment">// 1. ST _succ = wakee</span><br>    <span class="hljs-comment">// 2. membar #loadstore|#storestore;</span><br>    <span class="hljs-comment">// 2. ST _owner = NULL</span><br>    <span class="hljs-comment">// 3. unpark(wakee)</span><br><br>    _succ = Knob_SuccEnabled ? Wakee-&gt;_thread : <span class="hljs-literal">NULL</span> ;<br>    ParkEvent * Trigger = Wakee-&gt;_event ;<br><br>    Wakee  = <span class="hljs-literal">NULL</span> ;<br><br>    <span class="hljs-comment">// 释放锁</span><br>    OrderAccess::release_store_ptr (&amp;_owner, <span class="hljs-literal">NULL</span>) ;<br>    OrderAccess::fence() ;                               <span class="hljs-comment">// ST _owner vs LD in unpark()</span><br>    <span class="hljs-comment">// 唤醒线程</span><br>    Trigger-&gt;unpark() ;<br><br>    <span class="hljs-comment">//...</span><br>&#125;    <br></code></pre></td></tr></table></figure><p>exist函数的代码比较繁杂，这里做了简化，由于QMode默认值是0，因此只讨论这种情况。</p><ul><li><p>首先，如果 <code>_EntryList</code> 不为NULL，那么直接调用 ExitEpilog 函数从 <code>_EntryList</code>中取出头结点并唤醒线程；</p></li><li><p>如果 <code>_EntryList</code> 为NULL,但是 <code>_cxq</code> 队列不为 NULL，说明有等待状态的线程被notify了，但是还没真正的被唤醒，那么将  <code>_cxq</code>队列中的所有元素移入<code>_EntryList</code>队列中，并将其改造成一个双向链表。然后通过 ExitEpilog 唤醒<code>_EntryList</code>的头结点。</p></li></ul><h2 id="三、小结"><a href="#三、小结" class="headerlink" title="三、小结"></a>三、小结</h2><p>本篇文章从一个简单的“生产者-消费者”模型着手，认识了Object中wait和notify/notifyAll方法，并且深入的分析了虚拟机底层对这两个方法的实现。Java代码中的 synchronized 关键字通过编译器编译成字节码的monitorenter/monitorexist指令，当虚拟机执行到相关指令后则会调用虚拟机底层相关的函数，进行拿锁和释放锁的操作。而由于锁对象Object关联了monitor对象，故可以调用这个Object对象中的 wait 和 notify/notifyAll 方法来阻塞和唤醒线程。而这两个方法亦是调用了虚拟机底层的相关函数，wait 函数会将线程封装成 WaitObject 并将其插入到等待队列中，而notify/notifyAll 则会将线程从等待队列中取出并转移到<code>_EntryList</code>队列或者转移到<code>_cxq</code>队列，等到持有锁的线程执行完毕并读取到 monitorexist 指令后调用了虚拟机的 exist 函数来释放锁并唤醒<code>_EntryList</code> 队列或者<code>_cxq</code>队列中的线程。</p><p>synchronized 锁的这种等待与唤醒机制很显然有一个弊端。仍然以”生产者-消费者“模型为例，由于生产者线程和消费者线程都会被加入到同一个WaitSet队列中，通过 notifyAll 方法并不能精确的控制唤醒哪一类线程。而在<a href="https://zhangpan.site/2021/06/19/40-reentranlock/">这一次，彻底搞懂Java中的ReentranLock实现原理</a>这篇文章中我们认识了ReentranLock，ReentranLock与 synchronized 相仿也有类似的等待与唤醒机制，并且能够精确的控制唤醒指定的线程。那么，ReentranLock是怎么实现的呢？我们下篇再议。</p><h2 id="参考-amp-推荐阅读"><a href="#参考-amp-推荐阅读" class="headerlink" title="参考&amp;推荐阅读"></a>参考&amp;推荐阅读</h2><p><a href="https://cgiirw.github.io/2018/10/17/Blocked03/">再谈阻塞(3)：cxq、EntryList与WaitSet</a></p>]]></content>
    
    
    <categories>
      
      <category>Java进阶</category>
      
    </categories>
    
    
    <tags>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>这一次，彻底搞懂Java并发包中的Atomic原子类</title>
    <link href="/2021/06/26/41-atomic-cas/"/>
    <url>/2021/06/26/41-atomic-cas/</url>
    
    <content type="html"><![CDATA[<p>多线程并发是Java语言中非常重要的一块内容，同时，也是Java基础的一个难点。说它重要是因为多线程是日常开发中频繁用到的知识，说它难是因为多线程并发涉及到的知识点非常之多，想要完全掌握Java的并发相关知识并非易事。也正因此，Java并发成了Java面试中最高频的知识点之一。本系列文章将从Java内存模型、volatile关键字、synchronized关键字、ReetrantLock、Atomic并发类以及线程池等方面来系统的认识Java的并发知识。通过本系列文章的学习你将深入理解volatile关键字的作用，了解到synchronized实现原理、AQS和CLH队列锁，清晰的认识自旋锁、偏向锁、乐观锁、悲观锁…等等一系列让人眼花缭乱的并发知识。</p><p>多线程并发系列文章：</p><p><a href="https://zhangpan.site/2021/05/30/37-jmm-volatile/">这一次，彻底搞懂Java内存模型与volatile关键字</a></p><p><a href="https://zhangpan.site/2021/06/14/39-synchronized/">这一次，彻底搞懂Java中的synchronized关键字</a></p><p><a href="https://zhangpan.site/2021/06/19/40-reentranlock/">这一次，彻底搞懂Java中的ReentrantLock实现原理</a></p><p><a href="https://zhangpan.site/2021/06/26/41-atomic-cas/">这一次，彻底搞懂Java并发包中的Atomic原子类</a></p><p><a href="https://zhangpan.site/2021/07/02/42-wait-notify1/">深入理解Java线程的等待与唤醒机制（一）</a></p><p><a href="https://zhangpan.site/2021/07/03/43-wait-notify2/">深入理解Java线程的等待与唤醒机制（二）</a></p><p><a href="https://zhangpan.site/2021/07/10/44-thread-pool/">Java并发系列终结篇：彻底搞懂Java线程池的工作原理</a></p><p><a href="https://zhangpan.site/2021/07/19/45-ThreadLocal/">Java并发系列番外篇：ThreadLocal原理其实很简单</a></p><p>本文是Java并发系列的第三篇文章，将详细的讲解Java中的Atomic并发类与CAS。</p><p>前两篇文章我们深入的讲解了synchronized关键字以及ReentrantLock，它们都是在并发过程中通过同步状态来确保只有一个线程操作共享变量的。而本篇文章我们将来认识一个无锁状态也能保证线程安全的方法，它就是JDK1.5中引入的并发包Atomic原子操作类。</p><h2 id="一、初始Atomic并发包"><a href="#一、初始Atomic并发包" class="headerlink" title="一、初始Atomic并发包"></a>一、初始Atomic并发包</h2><p>从JDK1.5开始，Java在java.util.concurrent.atomic包下引入了一些Atomic相关的原子操作类，这些类避免使用加锁来实现同步，从而更加方便、高效的实现原子操作。atomic包下的所有类如下图所示：</p><p><img src="https://raw.githubusercontent.com/zhpanvip/images/master/project/article/thread/atomic-class.png" alt="atomic-class"></p><p>Atomic包下所有的原子类都只适用于单个元素，即只能保证一个基本数据类型、对象、或者数组的原子性。根据使用范围，可以将这些类分为四种类型，分别为原子<strong>更新基本类型</strong>、<strong>原子更新数组</strong>、<strong>原子更新引用</strong>、<strong>原子更新属性</strong>。</p><h3 id="1-原子更新基本类型"><a href="#1-原子更新基本类型" class="headerlink" title="1.原子更新基本类型"></a>1.原子更新基本类型</h3><p>atomic包下原子更新基本数据类型包括AtomicInteger、AtomicLong、AtomicBoolean三个类，分别提供了原子更新整数类型、原子更新长整数类型和原子更新布尔类型的功能。这里，我们以AtomicInteger为例来学习如何使用。</p><p>AtomicInteger中提供了很多方法供我们调用，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">// 获取当前值，然后自加，相当于i++</span><br>getAndIncrement()<br><span class="hljs-comment">// 获取当前值，然后自减，相当于i--</span><br>getAndDecrement()<br><span class="hljs-comment">// 自加1后并返回，相当于++i</span><br>incrementAndGet()<br><span class="hljs-comment">// 自减1后并返回，相当于--i</span><br>decrementAndGet()<br><span class="hljs-comment">// 获取当前值，并加上预期值</span><br>getAndAdd(<span class="hljs-keyword">int</span> delta)<br><span class="hljs-comment">// 获取当前值，并设置新值</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getAndSet</span><span class="hljs-params">(<span class="hljs-keyword">int</span> newValue)</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-comment">// ...</span></span><br><span class="hljs-function"></span><br></code></pre></td></tr></table></figure><p>需要注意的是这些方法都是原子操作，在多线程下也能够保证原子性以incrementAndGet方法为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs Java">AtomicInteger atomicInteger = <span class="hljs-keyword">new</span> AtomicInteger();<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> index;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">increase</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) &#123;<br>            index = atomicInteger.incrementAndGet();<br>        &#125;<br>    &#125;).start();<br><br>    <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) &#123;<br>            index = atomicInteger.incrementAndGet();<br>        &#125;<br>    &#125;).start();<br><br>    Thread.sleep(<span class="hljs-number">1000</span>);<br>    System.out.println(<span class="hljs-string">&quot;-----&quot;</span> + index); <span class="hljs-comment">// 输出结果20000</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在increase方法中开启了两个线程并使用AtomicInteger对index进行自增操作，每次的输出结果都为20000.</p><h3 id="2-原子更新引用类型"><a href="#2-原子更新引用类型" class="headerlink" title="2.原子更新引用类型"></a>2.原子更新引用类型</h3><p>基本类型的原子类只能更新一个变量，如果需要原子更新多个变量，则需要使用引用类型原子类。引用类型的原子类包括AtomicReference、AtomicStampedReference、AtomicMarkableReference三个。</p><ul><li><strong>AtomicReference</strong> 引用原子类</li><li><strong>AtomicStampedReference</strong> 原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于解决原子的更新数据和数据的版本号，可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。（关于CAS及ABA问题后文详细分析）<ul><li><strong>AtomicMarkableReference</strong> 原子更新带有标记的引用类型。该类将 boolean 标记与引用关联起来。</li></ul></li></ul><p>接下来以AtomicReference为例来分析，首先看下AtomicReference的类结构：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AtomicReference</span>&lt;<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> V <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> value;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(V newValue)</span> </span>&#123;<br>        value = newValue;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">compareAndSet</span><span class="hljs-params">(V expectedValue, V newValue)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> VALUE.compareAndSet(<span class="hljs-keyword">this</span>, expectedValue, newValue);<br>    &#125;<br><br>    <span class="hljs-comment">// ...省略其他</span><br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到AtomicReference是一个泛型类，内部设置及更新引用类型数据的方法。以compareAndSet方法为例来看如何使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Book</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> String name;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> price;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Book</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> price)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.price = price;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Java">AtomicReference&lt;Book&gt; atomicReference = <span class="hljs-keyword">new</span> AtomicReference&lt;&gt;();<br>Book book1 = <span class="hljs-keyword">new</span> Book(<span class="hljs-string">&quot;三国演义&quot;</span>, <span class="hljs-number">42</span>);<br>atomicReference.set(book1);<br>Book book2 = <span class="hljs-keyword">new</span> Book(<span class="hljs-string">&quot;水浒传&quot;</span>, <span class="hljs-number">40</span>);<br>atomicReference.compareAndSet(book1, book2);<br>System.out.println(<span class="hljs-string">&quot;Book name is &quot;</span> + atomicReference.get().name + <span class="hljs-string">&quot;,价格是&quot;</span> + atomicReference.get().price);<br><br></code></pre></td></tr></table></figure><p>输出结果为：</p><blockquote><p>Book name is 水浒传,价格是40</p></blockquote><p>上述代码首先将book1关联AtomicReference，接着又实例化了book2。调用compareAndSet方法传入book1和book2两个参数，通过CAS更新book。首先判断期望的是不是book1，如果是则更新为book2.否则继续自旋知道更新成功。</p><h3 id="3-原子更新数组"><a href="#3-原子更新数组" class="headerlink" title="3.原子更新数组"></a>3.原子更新数组</h3><p>这里原子更新数组并不是对数组本身的原子操作，而是对数组中的元素。主要包括3个类：AtomicIntegerArray、AtomicLongArray及AtomicReferenceArray，分别表示原子更新整数数组的元素、原子更新长整数数组的元素以及原子更新引用类型数组的元素。我们以AtomicIntegerArray为例来看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AtomicIntegerArray</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span> </span>&#123;<br>    <span class="hljs-comment">// final类型的int数组</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span>[] array;<br>    <span class="hljs-comment">// 获取数组中第i个元素</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>)AA.getVolatile(array, i);<br>    &#125;<br>    <span class="hljs-comment">// 设置数组中第i个元素</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> newValue)</span> </span>&#123;<br>        AA.setVolatile(array, i, newValue);<br>    &#125;<br>    <span class="hljs-comment">// CAS更改第i个元素</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">compareAndSet</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> expectedValue, <span class="hljs-keyword">int</span> newValue)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> AA.compareAndSet(array, i, expectedValue, newValue);<br>    &#125;<br>    <span class="hljs-comment">// 获取第i个元素，并加1</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAndIncrement</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>)AA.getAndAdd(array, i, <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-comment">// 获取第i个元素并减1</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAndDecrement</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>)AA.getAndAdd(array, i, -<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-comment">// 对数组第i个元素加1后再获取</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">incrementAndGet</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>)AA.getAndAdd(array, i, <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">// 对数组第i个元素减1后再获取</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">decrementAndGet</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>)AA.getAndAdd(array, i, -<span class="hljs-number">1</span>) - <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">// ... 省略</span><br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，在AtomicIntegerArray内部维护了一个final修饰的int数组，且类中所有的操作都是针对数组元素的操作。同时，这些方法都是原子操作，可以保证多线程下数据的安全性。</p><h3 id="4-原子更新对象属性"><a href="#4-原子更新对象属性" class="headerlink" title="4.原子更新对象属性"></a>4.原子更新对象属性</h3><p>如果直选哟更新某个对象中的某个字段，可以使用更新对象字段的原子类。包括三个类，AtomicIntegerFieldUpdater、AtomicLongFieldUpdater以及AtomicReferenceFieldUpdater。需要注意的是这些类的使用需要满足以下条件才可。</p><ul><li>被操作的字段不能是static类型；</li><li>被操纵的字段不能是final类型；</li><li>被操作的字段必须是volatile修饰的；</li><li>属性必须对于当前的Updater所在区域是可见的。</li></ul><p>下面以AtomicIntegerFieldUpdater为例，结合前例中的Book类来更新Book的价格，注意将price用volatile修饰。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Book</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> String name;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> price;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Book</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> price)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.price = price;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Java">AtomicIntegerFieldUpdater&lt;Book&gt; updater = AtomicIntegerFieldUpdater.newUpdater(Book.class, &quot;price&quot;);<br>Book book = <span class="hljs-keyword">new</span> Book(<span class="hljs-string">&quot;三国演义&quot;</span>, <span class="hljs-number">42</span>);<br>updater.set(book, <span class="hljs-number">50</span>);<br>System.out.println( <span class="hljs-string">&quot;更新后的价格是&quot;</span> + updater.get(book));<br></code></pre></td></tr></table></figure><p>输出结果如下：</p><blockquote><p>更新后的价格是50</p></blockquote><p>实例化一个Book，价格为42，通过AtomicIntegerFieldUpdater可以将价格修改为50。</p><h2 id="二、CAS"><a href="#二、CAS" class="headerlink" title="二、CAS"></a>二、CAS</h2><p>前文中已经提到Atomic包下的类是无锁操作，无锁的实现就得益于CAS。在前几篇文章中CAS的概念都有提及。那么这里我们就来详细的认识一下什么是CAS。</p><p>CAS是Compare And Swap的简称，即比较并交换的意思。CAS是一种无锁算法，其算法思想如下：</p><blockquote><p>CAS的函数公式：compareAndSwap(V,E,N)； 其中V表示要更新的变量，E表示预期值，N表示期望更新的值。调用compareAndSwap函数来更新变量V，如果V的值等于期望值E，那么将其更新为N，如果V的值不等于期望值E，则说明有其它线程跟新了这个变量，此时不会执行更新操作，而是重新读取该变量的值再次尝试调用compareAndSwap来更新。</p></blockquote><p>可见CAS其实存在一个循环的过程，如果有多个线程在同时修改这一个变量V，在修改之前会先拿到这个变量的值，再和变量对比看是否相等，如果相等，则说明没有其它线程修改这个变量，自己更新变量即可。如果发现要修改的变量和期望值不一样，则说明再读取变量V的值后，有其它线程对变量V做了修改，那么，放弃本次更新，重新读变量V的值，并再次尝试修改，直到修改成功为止。这个循环过程一般也称作<strong>自旋</strong>，CAS操作的整个过程如下图所示：</p><p><img src="https://raw.githubusercontent.com/zhpanvip/images/master/project/article/thread/cas2.png" alt="cas.png"></p><h3 id="2-CAS存在的缺点"><a href="#2-CAS存在的缺点" class="headerlink" title="2.CAS存在的缺点"></a>2.CAS存在的缺点</h3><p>虽然通过CAS可以实现无锁同步，但是CAS也有其局限性和问题所在。</p><ul><li>（1）只能保证一个共享变量的原子性</li></ul><p>CAS不像synchronized和RetranLock一样可以保证一段代码和多个变量的同步。对于多个共享变量操作是CAS是无法保证的，这时候必须使用枷锁来是实现。</p><ul><li>（2）存在性能开销问题</li></ul><p>由于CAS是一个自旋操作，如果长时间的CAS不成功会给CPU带来很大的开销。</p><ul><li>（3）ABA问题</li></ul><p>因为CAS是通过检查值有没有发生改变来保证原子性的，假若一个变量V的值为A，线程1和线程2同时都读取到了这个变量的值A，此时线程1将V的值改为了B，然后又改回了A，期间线程2一直没有抢到CPU时间片。知道线程1将V的值改回A后线程2才得到执行。那么此时，线程2并不知道V的值曾经改变过。这个问题就被成为<strong>ABA问题</strong>。</p><p>ABA问题的解决其实也容易处理，即添加一个版本号，更次更新值同时也更新版本号即可。上文中提到的AtomicStampedReference就是用来解决ABA问题的。</p><h3 id="3-CPU对CAS的支持"><a href="#3-CPU对CAS的支持" class="headerlink" title="3.CPU对CAS的支持"></a>3.CPU对CAS的支持</h3><p>在操作系统中CAS是一种系统原语，原语由多条指令组成，且原语的执行是连续不可中断的。因此CAS实际上是一条CPU的原子指令，虽然看上去CAS是一个先比较再交换的操作，但实际上这个过程是由CPU保证了原子操作。</p><h3 id="4-CAS与Atomic原子类"><a href="#4-CAS与Atomic原子类" class="headerlink" title="4.CAS与Atomic原子类"></a>4.CAS与Atomic原子类</h3><p>了解了CAS，我们就来看下Atomic包中的原子类是如何使用CAS实现原子操作的。我们以AtomicInteger为例来看.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AtomicInteger</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Number</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> jdk.internal.misc.Unsafe U = jdk.internal.misc.Unsafe.getUnsafe();<br>&#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAndSet</span><span class="hljs-params">(<span class="hljs-keyword">int</span> newValue)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> U.getAndSetInt(<span class="hljs-keyword">this</span>, VALUE, newValue);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAndIncrement</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> U.getAndAddInt(<span class="hljs-keyword">this</span>, VALUE, <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAndDecrement</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> U.getAndAddInt(<span class="hljs-keyword">this</span>, VALUE, -<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAndAdd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> delta)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> U.getAndAddInt(<span class="hljs-keyword">this</span>, VALUE, delta);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">incrementAndGet</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> U.getAndAddInt(<span class="hljs-keyword">this</span>, VALUE, <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">decrementAndGet</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> U.getAndAddInt(<span class="hljs-keyword">this</span>, VALUE, -<span class="hljs-number">1</span>) - <span class="hljs-number">1</span>;<br>    &#125;<br><br></code></pre></td></tr></table></figure><p>可以看到在AtomicInteger类中，所有的操作都是通过一个类型为Unsafe的成员变量来实现的。Unsafe类是位于sun.misc包下的一个类，这个类中提供了用于执行低级别、不安全的操作方法，其中就包括了CAS的能力。</p><h2 id="三、CAS的实现类–Unsafe"><a href="#三、CAS的实现类–Unsafe" class="headerlink" title="三、CAS的实现类–Unsafe"></a>三、CAS的实现类–Unsafe</h2><p>Unsafe是一个神奇且鲜为人知的Java类，因为在平时开发中很少用到它。但是这个类中为我们提供了相当多的功能，它即可以让Java语言像C语言指针一样操作内存，同时还提供了CAS、内存屏障、线程调度、对象操作、数组操作等能力,如下图。<br><img src="https://raw.githubusercontent.com/zhpanvip/images/master/project/article/thread/cas_unsafe.webp" alt="cas_unsafe"></p><p>下面就来简单的认识一下Unsafe类。</p><h3 id="1-获取Unsafe实例"><a href="#1-获取Unsafe实例" class="headerlink" title="1.获取Unsafe实例"></a>1.获取Unsafe实例</h3><p>Unsafe类是一个单例，并且提供了一个getUnsafe的方法来获取Unsafe的实例。但是，这个方法只有在引导类加载器加载Unsafe类是调用才合法，否则会抛出一个SecurityException异常，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Java">Exception in thread <span class="hljs-string">&quot;main&quot;</span> java.lang.SecurityException: Unsafe<br>at jdk.unsupported/sun.misc.Unsafe.getUnsafe(Unsafe.java:<span class="hljs-number">99</span>)<br>at atomic.AtomicDemo.increase(AtomicDemo.java:<span class="hljs-number">28</span>)<br>at atomic.AtomicDemo.main(AtomicDemo.java:<span class="hljs-number">34</span>)<br></code></pre></td></tr></table></figure><p>因此，想要获取Unsafe类的实例就需要另辟蹊径了。使用反射来获取Unsafe实例是一个比较好的方案，实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">try</span> &#123;<br>    Field field = Unsafe.class.getDeclaredField(&quot;theUnsafe&quot;);<br>    field.setAccessible(<span class="hljs-keyword">true</span>);<br>    Unsafe unsafe = (Unsafe) field.get(<span class="hljs-keyword">null</span>);<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>    e.printStackTrace();<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="2-Unsafe类中的CAS"><a href="#2-Unsafe类中的CAS" class="headerlink" title="2.Unsafe类中的CAS"></a>2.Unsafe类中的CAS</h3><p>Unsafe类中与CAS相关的主要有以下几个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">// 第一个参数o为给定对象，offset为对象内存的偏移量，通过这个偏移量迅速定位字段并设置或获取该字段的值，expected表示期望值，x表示要设置的值，下面3个方法都通过CAS原子指令执行操作。</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">compareAndSetInt</span><span class="hljs-params">(Object o,<span class="hljs-keyword">long</span> offset,<span class="hljs-keyword">int</span> expected,<span class="hljs-keyword">int</span> x)</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">compareAndSetObject</span><span class="hljs-params">(Object o, <span class="hljs-keyword">long</span> offset,Object expected,Object x)</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">compareAndSetLong</span><span class="hljs-params">(Object o, <span class="hljs-keyword">long</span> offset,<span class="hljs-keyword">long</span> expected,<span class="hljs-keyword">long</span> x)</span></span>;<br></code></pre></td></tr></table></figure><p>可以看到，这些方法都是native方法，调用的底层代码实现。在JDK1.8中还引入了getAndAddInt、getAndAddLong、getAndSetInt、getAndSetLong、getAndSetObject等方法来支持不同类型CAS操作。</p><p>而AtomicInteger中也正是使用了这里的方法才实现的CAS操作。</p><h3 id="3-线程调度相关"><a href="#3-线程调度相关" class="headerlink" title="3.线程调度相关"></a>3.线程调度相关</h3><p>在Unsafe中提供了线程挂起、恢复及锁机制相关的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//取消阻塞线程</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unpark</span><span class="hljs-params">(Object thread)</span></span>;<br><span class="hljs-comment">//阻塞线程</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title">park</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> isAbsolute, <span class="hljs-keyword">long</span> time)</span></span>;<br><span class="hljs-comment">//获得对象锁（可重入锁）</span><br><span class="hljs-meta">@Deprecated</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title">monitorEnter</span><span class="hljs-params">(Object o)</span></span>;<br><span class="hljs-comment">//释放对象锁</span><br><span class="hljs-meta">@Deprecated</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title">monitorExit</span><span class="hljs-params">(Object o)</span></span>;<br><span class="hljs-comment">//尝试获取对象锁</span><br><span class="hljs-meta">@Deprecated</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryMonitorEnter</span><span class="hljs-params">(Object o)</span></span>;<br></code></pre></td></tr></table></figure><p>在上篇文章讲解RetranLock与AQS时涉及到线程挂起的操作其实也是调用的Unsafe的park方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// LockSupport</span><br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Unsafe U = Unsafe.getUnsafe();<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">park</span><span class="hljs-params">(Object blocker)</span> </span>&#123;<br>    Thread t = Thread.currentThread();<br>    setBlocker(t, blocker);<br>    U.park(<span class="hljs-keyword">false</span>, <span class="hljs-number">0L</span>);<br>    setBlocker(t, <span class="hljs-keyword">null</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>4.### 对象操作<br>Unsafe还提供了对象实例化及操作对象属性相关的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">//返回对象成员属性在内存地址相对于此对象的内存地址的偏移量</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">long</span> <span class="hljs-title">objectFieldOffset</span><span class="hljs-params">(Field f)</span></span>;<br><span class="hljs-comment">//获得给定对象的指定地址偏移量的值，与此类似操作还有：getInt，getDouble，getLong，getChar等</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> Object <span class="hljs-title">getObject</span><span class="hljs-params">(Object o, <span class="hljs-keyword">long</span> offset)</span></span>;<br><span class="hljs-comment">//给定对象的指定地址偏移量设值，与此类似操作还有：putInt，putDouble，putLong，putChar等</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title">putObject</span><span class="hljs-params">(Object o, <span class="hljs-keyword">long</span> offset, Object x)</span></span>;<br><span class="hljs-comment">//从对象的指定偏移量处获取变量的引用，使用volatile的加载语义</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> Object <span class="hljs-title">getObjectVolatile</span><span class="hljs-params">(Object o, <span class="hljs-keyword">long</span> offset)</span></span>;<br><span class="hljs-comment">//存储变量的引用到对象的指定的偏移量处，使用volatile的存储语义</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title">putObjectVolatile</span><span class="hljs-params">(Object o, <span class="hljs-keyword">long</span> offset, Object x)</span></span>;<br><span class="hljs-comment">//有序、延迟版本的putObjectVolatile方法，不保证值的改变被其他线程立即看到。只有在field被volatile修饰符修饰时有效</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title">putOrderedObject</span><span class="hljs-params">(Object o, <span class="hljs-keyword">long</span> offset, Object x)</span></span>;<br><span class="hljs-comment">//绕过构造方法、初始化代码来创建对象</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> Object <span class="hljs-title">allocateInstance</span><span class="hljs-params">(Class&lt;?&gt; cls)</span> <span class="hljs-keyword">throws</span> InstantiationException</span>;<br></code></pre></td></tr></table></figure><p>Unsafe中提供的allocateInstance方法可以绕过对象的构造方法直接创建对象，Gson解析json反序列化对象时就有用到这个方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 来自Gson#UnsafeAllocator</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">newInstance</span><span class="hljs-params">(Class&lt;T&gt; var1)</span> <span class="hljs-keyword">throws</span> Exception</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> UnsafeAllocator <span class="hljs-title">create</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Class&lt;?&gt; unsafeClass = Class.forName(<span class="hljs-string">&quot;sun.misc.Unsafe&quot;</span>);<br>            Field f = unsafeClass.getDeclaredField(<span class="hljs-string">&quot;theUnsafe&quot;</span>);<br>            f.setAccessible(<span class="hljs-keyword">true</span>);<br>            <span class="hljs-keyword">final</span> Object unsafe = f.get((Object)<span class="hljs-keyword">null</span>);<br>            <span class="hljs-keyword">final</span> Method allocateInstance = unsafeClass.getMethod(<span class="hljs-string">&quot;allocateInstance&quot;</span>, Class.class);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> UnsafeAllocator() &#123;<br>                <span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">newInstance</span><span class="hljs-params">(Class&lt;T&gt; c)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                    assertInstantiable(c);<br>                    <span class="hljs-keyword">return</span> allocateInstance.invoke(unsafe, c);<br>                &#125;<br>            &#125;;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception var6) &#123;<br>            <span class="hljs-comment">// ...省略异常处理</span><br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>关于Gson使用allocateInstance实例化对象的详细过程可以可以参考<a href="https://github.com/zhpanvip/AndroidNote/wiki/%E9%A1%B9%E7%9B%AE%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98">《一个非静态内部类引起的空指针》</a></p><p>5.### Unsafe的其它功能</p><p>除了CAS、线程调度、对象相关的功能外，Unsafe还提供了内存操作，可以实现堆外内存的分配。提供的数组相关的方法来定位数组中每个元素在内存中的位置，等等…由于不是本篇文章的重点，这里就不一一介绍了。感兴趣的可以自行查阅。</p><h2 id="参考-amp-推荐阅读"><a href="#参考-amp-推荐阅读" class="headerlink" title="参考&amp;推荐阅读"></a>参考&amp;推荐阅读</h2><p><a href="https://tech.meituan.com/2019/02/14/talk-about-java-magic-class-unsafe.html">Java魔法类：Unsafe应用解析</a></p><p><a href="https://blog.csdn.net/javazejian/article/details/72772470">Java并发编程-无锁CAS与Unsafe类及其并发包Atomic</a></p>]]></content>
    
    
    <categories>
      
      <category>Java进阶</category>
      
    </categories>
    
    
    <tags>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>这一次，彻底搞懂Java中的ReentrantLock实现原理</title>
    <link href="/2021/06/19/40-reentranlock/"/>
    <url>/2021/06/19/40-reentranlock/</url>
    
    <content type="html"><![CDATA[<p>多线程并发是Java语言中非常重要的一块内容，同时，也是Java基础的一个难点。说它重要是因为多线程是日常开发中频繁用到的知识，说它难是因为多线程并发涉及到的知识点非常之多，想要完全掌握Java的并发相关知识并非易事。也正因此，Java并发成了Java面试中最高频的知识点之一。本系列文章将从Java内存模型、volatile关键字、synchronized关键字、ReetrantLock、Atomic并发类以及线程池等方面来系统的认识Java的并发知识。通过本系列文章的学习你将深入理解volatile关键字的作用，了解到synchronized实现原理、AQS和CLH队列锁，清晰的认识自旋锁、偏向锁、乐观锁、悲观锁…等等一系列让人眼花缭乱的并发知识。</p><p>多线程并发系列文章：</p><p><a href="https://zhangpan.site/2021/05/30/37-jmm-volatile/">这一次，彻底搞懂Java内存模型与volatile关键字</a></p><p><a href="https://zhangpan.site/2021/06/14/39-synchronized/">这一次，彻底搞懂Java中的synchronized关键字</a></p><p><a href="https://zhangpan.site/2021/06/19/40-reentranlock/">这一次，彻底搞懂Java中的ReentrantLock实现原理</a></p><p><a href="https://zhangpan.site/2021/06/26/41-atomic-cas/">这一次，彻底搞懂Java并发包中的Atomic原子类</a></p><p><a href="https://zhangpan.site/2021/07/02/42-wait-notify1/">深入理解Java线程的等待与唤醒机制（一）</a></p><p><a href="https://zhangpan.site/2021/07/03/43-wait-notify2/">深入理解Java线程的等待与唤醒机制（二）</a></p><p><a href="https://zhangpan.site/2021/07/10/44-thread-pool/">Java并发系列终结篇：彻底搞懂Java线程池的工作原理</a></p><p><a href="https://zhangpan.site/2021/07/19/45-ThreadLocal/">Java并发系列番外篇：ThreadLocal原理其实很简单</a></p><p>本文是Java并发系列的第三篇文章，将详细的讲解ReentrantLockk与AQS的底层实现原理。</p><p>开始之前先给大家推荐一下<a href="https://github.com/zhpanvip/AndroidNote">AndroidNote</a>这个GitHub仓库，这里是我的学习笔记，同时也是我文章初稿的出处。这个仓库中汇总了大量的java进阶和Android进阶知识。是一个比较系统且全面的Android知识库。对于准备面试的同学也是一份不可多得的面试宝典，欢迎大家到GitHub的仓库主页关注。</p><h2 id="一、初识ReentrantLock"><a href="#一、初识ReentrantLock" class="headerlink" title="一、初识ReentrantLock"></a>一、初识ReentrantLock</h2><blockquote><p>注：下文中会多次出现<strong>同步队列</strong>这个关键词，这里的<strong>同步队列</strong>指的是没有获取到锁而处于阻塞状态的线程形成的队列。等同于上篇文章《这一次，彻底搞懂Java中的synchronized关键字》中提到的阻塞队列 _EntryList。</p></blockquote><p>上篇文章我们深入分析了synchronized关键字的实现原理。那么本篇文章我们来认识一下Java中另外一个同步机制–ReentrantLock。ReentrantLock是在JDK1.5的java.util.concurrent包中引入的。相比synchronized，ReentrantLock拥有更强大的并发功能。在深入分析ReentrantLock之前，我们先来了解一下ReentrantLock的使用。</p><h3 id="1-ReentrantLock使用"><a href="#1-ReentrantLock使用" class="headerlink" title="1.ReentrantLock使用"></a>1.ReentrantLock使用</h3><p>上篇文章介绍的synchronized关键字是一种隐式锁，即它的加锁与释放是自动的，无需我们关心。而ReentrantLock是一种显式锁，需要我们手动编写加锁和释放锁的代码。下面我们来看下ReentrantLock的使用方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReentrantLockDemo</span> </span>&#123;<br>    <span class="hljs-comment">// 实例化一个非公平锁，构造方法的参数为true表示公平锁，false为非公平锁。</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ReentrantLock lock = <span class="hljs-keyword">new</span> ReentrantLock(<span class="hljs-keyword">false</span>);<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> i;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testLock</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 拿锁，如果拿不到会一直等待</span><br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 再次尝试拿锁(可重入)，拿锁最多等待100毫秒</span><br>            <span class="hljs-keyword">if</span> (lock.tryLock(<span class="hljs-number">100</span>, TimeUnit.MILLISECONDS))<br>                i++;<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">// 释放锁</span><br>            lock.unlock(); <br>            lock.unlock();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码中lock.lock()会进行拿锁操作，如果拿不到锁则会一直等待。如果拿到锁之后则会执行try代码块中的代码。接下来在try代码块中又通过tryLock(100, TimeUnit.MILLISECONDS)方法尝试再次拿锁，此时，拿锁最多会等待100毫秒，如果在100毫秒内能获得锁，则tryLock方法返回true，拿锁成功，执行i++操作，如果返回false，获取锁失败，i++不会被执行。（因为第一次线程已经拿到锁了，由于ReentrantLock是可重入，因此，第二次必定能拿到锁。此处仅仅为了演示ReetranLock的使用，不必纠结）。</p><p>另外，要注意被ReentrantLock加锁区域必须用try代码块包裹，且释放锁需要在finally中来避免死锁。执行几次加锁，就需要几次释放锁。</p><h3 id="2-公平锁与非公平锁"><a href="#2-公平锁与非公平锁" class="headerlink" title="2.公平锁与非公平锁"></a>2.公平锁与非公平锁</h3><p>上一小节我们在代码中实例化了一个非公平的ReentrantLock锁，什么是公平锁与非公平锁呢？</p><blockquote><p><strong>公平锁</strong>是指多个线程按照申请锁的顺序来获取锁，线程直接进入同步队列中排队，队列中最先到的线程先获得锁。<strong>非公平锁</strong>是多个线程加锁时每个线程都会先去尝试获取锁，如果刚好获取到锁，那么线程无需等待，直接执行，如果获取不到锁才会被加入同步队列的队尾等待执行。</p></blockquote><p>当然，公平锁和非公平锁各有优缺点，适用于不同的场景。公平锁的优点在于各个线程公平平等，每个线程等待一段时间后，都有执行的机会，而它的缺点相较于于非公平锁整体执行速度更慢，吞吐量更低。同步队列中除第一个线程以外的所有线程都会阻塞，CPU唤醒阻塞线程的开销比非公平锁大。</p><p>而非公平锁非公平锁的优点是可以减少唤起线程的开销，整体的吞吐效率高，因为线程有几率不阻塞直接获得锁，CPU不必唤醒所有线程。它的缺点呢也比较明显，即队列中等待的线程可能一直或者长时间获取不到锁。</p><h3 id="3-可重入锁与非可重入锁"><a href="#3-可重入锁与非可重入锁" class="headerlink" title="3.可重入锁与非可重入锁"></a>3.可重入锁与非可重入锁</h3><p>在本章的第1小节同时也提到了可重入锁的概念：</p><blockquote><p><strong>可重入锁</strong>又名递归锁，是指同一个线程在获取外层同步方法锁的时候，再进入该线程的内层同步方法会自动获取锁（前提锁对象得是同一个对象或者class），不会因为之前已经获取过还没释放而阻塞。<strong>非可重入锁</strong>与可重入锁是对立的关系，即一个线程在获取到外层同步方法锁后，再进入该方法的内层同步方法无法获取到锁，即使锁是同一个对象。</p></blockquote><p>上篇文章讲到的synchronized与本篇讲的ReentrantLock都属于可重入锁。可重入锁可以有效避免死锁的产生。</p><h3 id="4-排他锁与共享锁"><a href="#4-排他锁与共享锁" class="headerlink" title="4.排他锁与共享锁"></a>4.排他锁与共享锁</h3><p>由于后文中还会涉及到排它锁与共享锁的概念，因此在这里一并解释了。</p><blockquote><p><strong>排他锁</strong>也叫独占锁，是指该锁一次只能被一个线程所持有。如果线程T对数据A加上排它锁后，则其他线程不能再对A加任何类型的锁。获得排它锁的线程即能读数据又能修改数据。<strong>共享锁</strong>是指该锁可被多个线程所持有。如果线程T对数据A加上共享锁后，则其他线程只能对A再加共享锁，不能加排它锁。获得共享锁的线程只能读数据，不能修改数据。</p></blockquote><h2 id="二、ReentrantLock源码简析"><a href="#二、ReentrantLock源码简析" class="headerlink" title="二、ReentrantLock源码简析"></a>二、ReentrantLock源码简析</h2><p>接下来我们来看一下ReentrantLock类的代码结构：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReentrantLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Lock</span>, <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Sync sync;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ReentrantLock</span><span class="hljs-params">()</span> </span>&#123;<br>        sync = <span class="hljs-keyword">new</span> NonfairSync();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ReentrantLock</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> fair)</span> </span>&#123;<br>        sync = fair ? <span class="hljs-keyword">new</span> FairSync() : <span class="hljs-keyword">new</span> NonfairSync();<br>    &#125;<br>    <br>    <span class="hljs-comment">// ...省略其它代码</span><br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，ReentrantLock的代码结构非常简单。它实现了Lock和Serializable两个接口，同时有两个构造方法，在无参构造方法中初始化了一个非公平锁，在有参构造方法中根据参数决定是初始化公平锁还是非公平锁。</p><p>接下来，我们看一下Lock接口的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Lock</span> </span>&#123;<br>    <span class="hljs-comment">// 获取锁</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-comment">// 获取可中断锁，即在拿锁过程中可中断，synchronized是不可中断锁。</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">lockInterruptibly</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException</span>;<br>    <span class="hljs-comment">// 尝试获取锁，成功返回true，失败返回false</span><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">tryLock</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-comment">// 在给定时间内尝试获取锁，成功返回true，失败返回false</span><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">tryLock</span><span class="hljs-params">(<span class="hljs-keyword">long</span> time, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException</span>;<br>    <span class="hljs-comment">// 释放锁</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-comment">// 等待与唤醒机制</span><br>    <span class="hljs-function">Condition <span class="hljs-title">newCondition</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到在Lock中定义了多个获取锁的方法，以及释放锁的方法。同时还有一个与等待与唤醒机制有关系的newCondition方法。本篇文章我们暂且不讨论Condition。</p><p>那么既然ReentrantLock实现Lock接口，它一定也实现了这些方法，看下ReentrantLock中的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReentrantLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Lock</span>, <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Sync sync;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span> </span>&#123;<br>        sync.acquire(<span class="hljs-number">1</span>);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lockInterruptibly</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        sync.acquireInterruptibly(<span class="hljs-number">1</span>);<br>    &#125;    <br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryLock</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> sync.nonfairTryAcquire(<span class="hljs-number">1</span>);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryLock</span><span class="hljs-params">(<span class="hljs-keyword">long</span> timeout, TimeUnit unit)</span></span><br><span class="hljs-function">            <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-keyword">return</span> sync.tryAcquireNanos(<span class="hljs-number">1</span>, unit.toNanos(timeout));<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">()</span> </span>&#123;<br>        sync.release(<span class="hljs-number">1</span>);<br>    &#125;<br>    <br>    <span class="hljs-comment">// ...省略其它代码</span><br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到ReentrantLock中对这几个方法的实现非常简单。都是调用了Sync中的相关方法。可见ReentrantLock所有拿锁和释放锁的操作都是通过Sync这个成员变量来实现的。Sync是ReentrantLock中的一个抽象内部类，它的源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractQueuedSynchronizer</span> </span>&#123;<br><br>    <span class="hljs-comment">// 尝试获取非公平锁</span><br>    <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">nonfairTryAcquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> acquires)</span> </span>&#123;<br>        <span class="hljs-keyword">final</span> Thread current = Thread.currentThread();<br>        <span class="hljs-keyword">int</span> c = getState();<br>        <span class="hljs-comment">// 未上锁状态</span><br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 通过CAS尝试拿锁</span><br>            <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, acquires)) &#123;                    <br>                <span class="hljs-comment">// 设置持有排他锁的线程</span><br>                setExclusiveOwnerThread(current);<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 如果是已上锁状态，判断持有锁的线程是不是自己，这里即可重入锁的实现</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (current == getExclusiveOwnerThread()) &#123;<br>            <span class="hljs-keyword">int</span> nextc = c + acquires;<br>            <span class="hljs-keyword">if</span> (nextc &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// overflow</span><br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>);<br>            setState(nextc);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>    <span class="hljs-comment">// 释放锁</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryRelease</span><span class="hljs-params">(<span class="hljs-keyword">int</span> releases)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> c = getState() - releases;<br>        <span class="hljs-keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalMonitorStateException();<br>        <span class="hljs-keyword">boolean</span> free = <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;<br>            free = <span class="hljs-keyword">true</span>;<br>            setExclusiveOwnerThread(<span class="hljs-keyword">null</span>);<br>        &#125;<br>        setState(c);<br>        <span class="hljs-keyword">return</span> free;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isHeldExclusively</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> getExclusiveOwnerThread() == Thread.currentThread();<br>    &#125;<br>    <span class="hljs-comment">// 获取持有锁的线程</span><br>    <span class="hljs-function"><span class="hljs-keyword">final</span> Thread <span class="hljs-title">getOwner</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> getState() == <span class="hljs-number">0</span> ? <span class="hljs-keyword">null</span> : getExclusiveOwnerThread();<br>    &#125;<br>    <span class="hljs-comment">// 获取持有锁线程重入的次数</span><br>    <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getHoldCount</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> isHeldExclusively() ? getState() : <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-comment">// 是否上锁状态</span><br>    <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isLocked</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> getState() != <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// ...省略其他代码</span><br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到Sync中的代码逻辑也并不复杂。通过nonfairTryAcquire方法实现非公平锁的拿锁操作，tryRelease则实现了释放锁的操作。其它还有几个与锁状态相关的方法。细心的同学会发现Sync对锁状态的判断都是通过state来实现的，state为0表示未加锁状态，state大于0表示加锁状态。关于state我们在后文中还会提及。</p><p>另外，由于Sync是一个抽象类，那必然有继承它的类。在ReentrantLock中有两个Sync的实现，分别为NonfairSync与FairSync。从名字上可以看到一个是非公平锁，一个是非公平锁。</p><p>首先来看下NonfairSync非公平锁的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NonfairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Sync</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">7316153563782823691L</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryAcquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> acquires)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> nonfairTryAcquire(acquires);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上边我们也提到了Sync中已经实现了非公平锁的逻辑了，所以NonfairSync的代码非常简单，仅仅在tryAcquire中直接调用了nonfairTryAcquire。</p><p>FairSync公平锁的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Sync</span> </span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryAcquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> acquires)</span> </span>&#123;<br>            <span class="hljs-keyword">final</span> Thread current = Thread.currentThread();<br>            <span class="hljs-keyword">int</span> c = getState();<br>            <span class="hljs-comment">// 未上锁状态</span><br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">// 首先判断没有等待节点时才会开启CAS去拿锁</span><br>                <span class="hljs-keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;<br>                    compareAndSetState(<span class="hljs-number">0</span>, acquires)) &#123;<br>                    <span class="hljs-comment">// 设置持有排他锁的线程</span><br>                    setExclusiveOwnerThread(current);<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 与非公平锁一样，持有锁线程是自己，则可重入</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (current == getExclusiveOwnerThread()) &#123;<br>                <span class="hljs-keyword">int</span> nextc = c + acquires;<br>                <span class="hljs-keyword">if</span> (nextc &lt; <span class="hljs-number">0</span>)<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>);<br>                setState(nextc);<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>可以看到在tryAcquire中实现了公平锁的操作，这段代码与与非公平锁的实现其实只有一句之差。即公平锁先去判断了同步队列中是否有在等待的线程，如果没有才会去进行拿锁操作。而非公平锁不会管是否有同步队列，先去拿了再说。</p><p>到这里，关于ReentrantLock的源码基本已经分析完了，但是我们并没有看到拿锁和释放锁的底层逻辑。而这些逻辑都在Sync的父类AbstractQueuedSynchronizer中实现。</p><h2 id="三、AbstractQueuedSynchronizer"><a href="#三、AbstractQueuedSynchronizer" class="headerlink" title="三、AbstractQueuedSynchronizer"></a>三、AbstractQueuedSynchronizer</h2><p>AbstractQueuedSynchronizer可以翻译为队列同步器，通常简称为AQS。国际惯例，还是先来看一下AbstractQueuedSynchronizer类的内部结构：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractQueuedSynchronizer</span></span><br><span class="hljs-class">    <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractOwnableSynchronizer</span></span><br><span class="hljs-class">    <span class="hljs-keyword">implements</span> <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span> </span>&#123;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-title">AbstractQueuedSynchronizer</span><span class="hljs-params">()</span> </span>&#123; &#125; <br>    <span class="hljs-comment">// 同步队列的头结点</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Node head;<br>    <span class="hljs-comment">// 同步队列的尾结点</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Node tail;<br>    <span class="hljs-comment">// 同步状态</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> state;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>AbstractQueuedSynchronizer类继承了AbstractOwnableSynchronizer，AbstractOwnableSynchronizer中的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractOwnableSynchronizer</span></span><br><span class="hljs-class">    <span class="hljs-keyword">implements</span> <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> Thread exclusiveOwnerThread;<br><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setExclusiveOwnerThread</span><span class="hljs-params">(Thread thread)</span> </span>&#123;<br>        exclusiveOwnerThread = thread;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> Thread <span class="hljs-title">getExclusiveOwnerThread</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> exclusiveOwnerThread;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到AbstractOwnableSynchronizer与AbstractQueuedSynchronizer中维护了四个成员，分别为：Thread类型的exclusiveOwnerThread，Node类型的head和tail以及一个int类型的state。</p><ul><li><strong>exclusiveOwnerThread</strong> 表示独占当前锁的线程</li><li><strong>head与tail</strong> 分别表示了等待线程队列的头结点和尾结点；</li><li><strong>state</strong> 表示同步的状态，为0时表示未加锁状态，而大于0时表示加锁状态。</li></ul><p>看到这里，不禁想起上篇文章讲到的synchronized锁中的monitor对象。在monitor对象中同样维护了一个_ower字段表示持有锁的线程，维护了一个_EntryList和_WaitSet的集合用来存放阻塞和等待的线程，以及一个计数器count表示锁的状态，为0时即为未加锁状态，大于0时则为加锁状态。</p><p>是不是惊奇的发现AQS与synchronized的monitor竟然有异曲同工之妙。但是AQS的功能却远不止如此。</p><h2 id="四、从AQS看ReentrantLock"><a href="#四、从AQS看ReentrantLock" class="headerlink" title="四、从AQS看ReentrantLock"></a>四、从AQS看ReentrantLock</h2><p>了解了AQS后，我们再回到ReentrantLock中来。</p><h3 id="1-ReentrantLock的lock方法"><a href="#1-ReentrantLock的lock方法" class="headerlink" title="1.ReentrantLock的lock方法"></a>1.ReentrantLock的lock方法</h3><p>以ReentrantLock的lock方法为例继续分析。我们知道lock方法调用了Sync的acquire：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">// ReentrantLock</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span> </span>&#123;<br>    sync.acquire(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>但Sync中并没有实现acquire方法，而是在Sync的父类AbstractQueuedSynchronizer中实现的。那么我们就来看下AbstractQueuedSynchronizer的acquire方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">// AbstractQueuedSynchronizer</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">acquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!tryAcquire(arg) &amp;&amp;<br>        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))<br>        selfInterrupt();<br>&#125;<br><br></code></pre></td></tr></table></figure><p>在AQS的acquire方法中首先调用了tryAcquire，而AQS中没有实现tryAcquire,而是抛出了一个异常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryAcquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException();<br>&#125;<br></code></pre></td></tr></table></figure><p>tryAcquire的实现在上一章的NonfairSync和FairSync类中已经分析过了，这个方法会通过CAS去尝试拿锁，返回值表示是否成功获取锁。最理想的情况是通过tryAcquire方法直接拿到了锁。但是如果没有拿到锁该怎么办呢？可以看到在tryAcquire返回false的时候接着又调用了addWaiter方法将其加入到了同步队列。这意味着线程进入到了阻塞状态，排队并且等待持有锁的线程释放锁，这一机制主要是依赖一个变形的CLH队列来实现的，同时唤醒线程就是在acquireQueued方法中，后边详细分析</p><h3 id="2-AQS与双向CLH队列"><a href="#2-AQS与双向CLH队列" class="headerlink" title="2.AQS与双向CLH队列"></a>2.AQS与双向CLH队列</h3><p>CLH队列是Craig、Landin and Hagersten队列的简称（Craig、Landin and Hagersten是三个人的名字），它是单向链表。而AQS中的队列是CLH变体的虚拟双向队列。在AQS中将所有请求锁失败的线程或者调用了await方法的线程封装成一个Node节点来实现锁的分配。关于Node节点，在上文中已经有所提及，来看一下Node中的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;<br>    <span class="hljs-comment">// 共享模式</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Node SHARED = <span class="hljs-keyword">new</span> Node();<br>    <span class="hljs-comment">// 独占模式</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Node EXCLUSIVE = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-comment">// 线程已处于结束状态的标记</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> CANCELLED =  <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 线程在等待被唤醒的标记</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> SIGNAL    = -<span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 条件状态</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> CONDITION = -<span class="hljs-number">2</span>;<br>    <span class="hljs-comment">// 共享模式下的状态</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> PROPAGATE = -<span class="hljs-number">3</span>;<br>    <span class="hljs-comment">// 表示等待状态，有以上四种</span><br>    <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> waitStatus;<br>    <span class="hljs-comment">// 同步队列的前驱节点</span><br>    <span class="hljs-keyword">volatile</span> Node prev;<br>    <span class="hljs-comment">// 同步队列的后继节点</span><br>    <span class="hljs-keyword">volatile</span> Node next;<br>    <span class="hljs-comment">// 阻塞状态或者等待状态的线程</span><br>    <span class="hljs-keyword">volatile</span> Thread thread;<br><br>    Node nextWaiter;<br>    <br>    Node() &#123;&#125;<br><br>    Node(Node nextWaiter) &#123;<br>        <span class="hljs-keyword">this</span>.nextWaiter = nextWaiter;<br>        THREAD.set(<span class="hljs-keyword">this</span>, Thread.currentThread());<br>    &#125;<br><br>    Node(<span class="hljs-keyword">int</span> waitStatus) &#123;<br>        WAITSTATUS.set(<span class="hljs-keyword">this</span>, waitStatus);<br>        THREAD.set(<span class="hljs-keyword">this</span>, Thread.currentThread());<br>    &#125;<br><br>   <span class="hljs-comment">// ...省略其他代码</span><br> <br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，在Node中封装了等待的线程和线程当前的状态，其中线程的状态有四种，分别为CANCELLED、SIGNAL、CONDITION和PROPAGATE，它们分别表示的含义如下：</p><ul><li><p><strong>CANCELLED</strong> 表示线程被取消的状态。同步队列中的线程等待超时或者被中断后会将waitStatus改为CANCELLED。</p></li><li><p><strong>SIGNAL</strong> 表示节点处于被唤醒状态，当其前驱结点释放了同步锁或者被取消后就会通知处于SIGNAL状态的后继节点的线程执行。</p></li><li><p><strong>CONDITION</strong> 调用了await方法后处于等待状态的线程节点会被标记为此种状态，当调用了Condition的singal方法后，CONDITION状态会变为SIGNAL状态，并且会在适当的时机从等待队列转移到同步队列中。</p></li><li><p><strong>PROPAGATE</strong> 这种状态与共享模式有关，在共享模式下，表示节点处于可运行状态。</p></li></ul><p>除此之外，Node中还维护了一个前驱节点和一个后继节点。接下来我们来看一下addWaiter方法是怎么将线程封装成Node并插入到同步队列的队尾的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">// 将当前线程封装成Node，并插入到队尾</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> Node <span class="hljs-title">addWaiter</span><span class="hljs-params">(Node mode)</span> </span>&#123;<br>    <span class="hljs-comment">// 实例化包含当前线程的Node节点</span><br>    Node node = <span class="hljs-keyword">new</span> Node(mode);<br>    <span class="hljs-comment">// 执行死循环</span><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        Node oldTail = tail;<br>        <span class="hljs-keyword">if</span> (oldTail != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">// 设置前驱节点为旧的尾结点</span><br>            node.setPrevRelaxed(oldTail);<br>            <span class="hljs-comment">// 用CAS执行尾部结点替换</span><br>            <span class="hljs-keyword">if</span> (compareAndSetTail(oldTail, node)) &#123;<br>                <span class="hljs-comment">// oldTail的next节点指向node</span><br>                oldTail.next = node;<br>                <span class="hljs-keyword">return</span> node;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 同步队列为空，初始化tail和head，初始化成功后会继续执行死循环，此时oldTail就不为null了</span><br>            initializeSyncQueue();<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 初始化头结点和尾结点</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initializeSyncQueue</span><span class="hljs-params">()</span> </span>&#123;<br>    Node h;<br>    <span class="hljs-comment">// 注意这里实例化了一个空的Node节点作为头结点</span><br>    <span class="hljs-keyword">if</span> (HEAD.compareAndSet(<span class="hljs-keyword">this</span>, <span class="hljs-keyword">null</span>, (h = <span class="hljs-keyword">new</span> Node())))<br>        <span class="hljs-comment">// 将尾结点指向头结点</span><br>        tail = h;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意，在aquire方法中调用addWaiter方法时传入的参数是Node.EXCLUSIVE，表示独占模式。通过new Node(mode)实例化Node时会设置当前线程。</p><p>接下来开启一个死循环进行node插入队尾的操作。如果队列不为空的话，那么通过CAS将node节点插入队尾，如果队列为空，则会去初始化队列，在初始化队列中又实例化了一个空的Node节点作为head，并将tail也指向这个头结点。初始化完成后会继续执行死循环进行node插入操作。从这里也可以看出同步队列的头结点是一个不存储任何数据的节点。</p><p>在将节点加入到同步队列后，节点就会开启自旋操作，并观察前驱节点的状态，等待满足执行的条件。这一操作是在acquire方法中的acquireQueued()方法中进行的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">acquireQueued</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node, <span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br>    <span class="hljs-keyword">boolean</span> interrupted = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 开启自旋</span><br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-comment">// 获取前驱节点</span><br>            <span class="hljs-keyword">final</span> Node p = node.predecessor();<br>            <span class="hljs-comment">// 如果前驱节点就是head节点了则执行tryAcquire尝试获取锁</span><br>            <span class="hljs-keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;<br>                <span class="hljs-comment">// 获取到同步状态后，将当前node设置为头结点</span><br>                setHead(node);<br>                <span class="hljs-comment">// 置空后继节点</span><br>                p.next = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// help GC</span><br>                <span class="hljs-keyword">return</span> interrupted;<br>            &#125;<br>            <span class="hljs-comment">// p不是头结点，则判断是否要挂起线程</span><br>            <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node))<br>                interrupted |= parkAndCheckInterrupt();<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>        cancelAcquire(node);<br>        <span class="hljs-keyword">if</span> (interrupted)<br>            selfInterrupt();<br>        <span class="hljs-keyword">throw</span> t;<br>    &#125;<br>&#125;<br> <br></code></pre></td></tr></table></figure><p>在acquireQueued方法中开启自旋操作，并查看node的前驱节点是不是头结点</p><p>如果node前驱节点是头结点，则尝试去获取同步状态，成功之后则可执行同步代码，此时的node节点其实已经无用，调用setHead方法将其设置为head节点（head节点是没有数据的空节点），并置空它的后继节点，以方便垃圾回收。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setHead</span><span class="hljs-params">(Node node)</span> </span>&#123;<br>    head = node;<br>    <span class="hljs-comment">// 置空当前线程</span><br>    node.thread = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-comment">// 置空前驱节点</span><br>    node.prev = <span class="hljs-keyword">null</span>;<br>&#125;  <br></code></pre></td></tr></table></figure><p>如果node的前驱节点不是头结点，那么则调用shouldParkAfterFailedAcquire方法判断是否要将线程挂起。如果是则调用parkAndCheckInterrupt将线程挂起。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">shouldParkAfterFailedAcquire</span><span class="hljs-params">(Node pred, Node node)</span> </span>&#123;<br>    <span class="hljs-comment">// 获取node的等待状态</span><br>    <span class="hljs-keyword">int</span> ws = pred.waitStatus;<br>    <span class="hljs-comment">// 如果状态是等待唤醒则返回true</span><br>    <span class="hljs-keyword">if</span> (ws == Node.SIGNAL)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    <span class="hljs-comment">// 状态大于0说明线程处于结束状态</span><br>    <span class="hljs-keyword">if</span> (ws &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 遍历前驱节点，知道找到线程不是结束状态的node</span><br>        <span class="hljs-keyword">do</span> &#123;<br>            node.prev = pred = pred.prev;<br>        &#125; <span class="hljs-keyword">while</span> (pred.waitStatus &gt; <span class="hljs-number">0</span>);<br>        pred.next = node;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 如果等待状态小于0却又不是SIGNAL状态,则CAS将其改为SIGNAL等待唤醒</span><br>        pred.compareAndSetWaitStatus(ws, Node.SIGNAL);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">parkAndCheckInterrupt</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 挂起线程</span><br>    LockSupport.park(<span class="hljs-keyword">this</span>);<br>    <span class="hljs-comment">// 返回线程的状态</span><br>    <span class="hljs-keyword">return</span> Thread.interrupted();<br>&#125;  <br></code></pre></td></tr></table></figure><p>通过lock拿锁的流程到此结束。</p><h3 id="3-可中断锁lockInterruptibly"><a href="#3-可中断锁lockInterruptibly" class="headerlink" title="3.可中断锁lockInterruptibly"></a>3.可中断锁lockInterruptibly</h3><p>在ReentrantLock中还支持可中断锁的获取，是通过lockInterruptibly()和tryLock()方法来实现的。我们以lockInterruptibly方法为例来看它与lock方法的区别。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">// ReentrantLock</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lockInterruptibly</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    sync.acquireInterruptibly(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>接着调用AQS的acquireInterruptibly方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// AbstractQueuedSynchronizer</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">acquireInterruptibly</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span></span><br><span class="hljs-function">        <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    <span class="hljs-comment">// 如果线程中断，则直接抛出异常</span><br>    <span class="hljs-keyword">if</span> (Thread.interrupted())<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InterruptedException();<br>    <span class="hljs-comment">// 尝试拿锁    </span><br>    <span class="hljs-keyword">if</span> (!tryAcquire(arg))<br>        <span class="hljs-comment">// 拿锁失败</span><br>        doAcquireInterruptibly(arg);<br>&#125;<br></code></pre></td></tr></table></figure><p>如果尝试拿锁失败后调用doAcquireInterruptibly方法(tryLock方法最终也是调用到了doAcquireInterruptibly方法)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doAcquireInterruptibly</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span></span><br><span class="hljs-function">    <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    <span class="hljs-keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-keyword">final</span> Node p = node.predecessor();<br>            <span class="hljs-keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;<br>                setHead(node);<br>                p.next = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// help GC</span><br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;<br>                parkAndCheckInterrupt())<br>                <span class="hljs-comment">// 线程中断抛出异常</span><br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InterruptedException();<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>        cancelAcquire(node);<br>        <span class="hljs-keyword">throw</span> t;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到这个方法与acquireQueued方法逻辑几乎一样，而差别在于检测到线程中断后直接抛出异常。</p><h3 id="4-锁的释放"><a href="#4-锁的释放" class="headerlink" title="4.锁的释放"></a>4.锁的释放</h3><p>ReentrantLock释放锁是通过它自身的unlock方法，而在unlock方法中同样调用了AQS的release方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">()</span> </span>&#123;<br>    sync.release(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>AQS中的release方法的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// AbstractQueuedSynchronizer</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">release</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br>    <span class="hljs-comment">// 尝试释放锁</span><br>    <span class="hljs-keyword">if</span> (tryRelease(arg)) &#123;<br>        Node h = head;<br>        <span class="hljs-keyword">if</span> (h != <span class="hljs-keyword">null</span> &amp;&amp; h.waitStatus != <span class="hljs-number">0</span>)<br>            <span class="hljs-comment">// 唤醒后继节点</span><br>            unparkSuccessor(h);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryRelease</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException();<br>&#125;    <br></code></pre></td></tr></table></figure><p>tryRelease是在AbstractQueuedSynchronizer的子类Sync中实现的，上文中我们已经有提及，即操控state，对state减去releases，如果state为0那么久释放锁，并且将排他线程设置为null,最后更新state。代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryRelease</span><span class="hljs-params">(<span class="hljs-keyword">int</span> releases)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> c = getState() - releases;<br>    <span class="hljs-keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalMonitorStateException();<br>    <span class="hljs-keyword">boolean</span> free = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;<br>        free = <span class="hljs-keyword">true</span>;<br>        setExclusiveOwnerThread(<span class="hljs-keyword">null</span>);<br>    &#125;<br>    setState(c);<br>    <span class="hljs-keyword">return</span> free;<br>&#125;<br></code></pre></td></tr></table></figure><p>释放锁成功之后则会调用unparkSuccessor来唤起后继节点。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">// AbstractQueuedSynchronizer</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unparkSuccessor</span><span class="hljs-params">(Node node)</span> </span>&#123;<br><br>        <span class="hljs-keyword">int</span> ws = node.waitStatus;<br>        <span class="hljs-comment">// 将节点状态修改为0</span><br>        <span class="hljs-keyword">if</span> (ws &lt; <span class="hljs-number">0</span>)<br>            node.compareAndSetWaitStatus(ws, <span class="hljs-number">0</span>);<br>        <span class="hljs-comment">// 拿到后继节点</span><br>        Node s = node.next;<br>        <span class="hljs-keyword">if</span> (s == <span class="hljs-keyword">null</span> || s.waitStatus &gt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 后继节点为null或者线程为取消状态</span><br>            s = <span class="hljs-keyword">null</span>;<br>            <span class="hljs-comment">// 从尾结点开始遍历</span><br>            <span class="hljs-keyword">for</span> (Node p = tail; p != node &amp;&amp; p != <span class="hljs-keyword">null</span>; p = p.prev)<br>                <span class="hljs-keyword">if</span> (p.waitStatus &lt;= <span class="hljs-number">0</span>) <span class="hljs-comment">// 说明该节点处于有效状态</span><br>                    s = p;<br>        &#125;<br>        <span class="hljs-comment">// 唤醒线程</span><br>        <span class="hljs-keyword">if</span> (s != <span class="hljs-keyword">null</span>)<br>            LockSupport.unpark(s.thread);<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>关于ReentrantLock与AQS的实现相对来说比较难以理解。本篇文章虽然写了很长的篇幅，但是也没有面面俱到的讲完ReentrantLock与AQS的全部知识点。本篇文章的分析仅仅涉及到了排它锁（独占锁），没有分析ReentrantLock共享锁的实现，关于Condition本篇文章并未涉及到，如果后边有时间，可以再写篇文章来分析Condition。</p><p>最后，不妨概括一下ReentrantLock独占锁拿锁和排队的流程：ReentrantLock内部通过FairSync和NonfairSync来实现公平锁和非公平锁。它们都是继承自AQS实现，在AQS内部通过state来标记同步状态，如果state为0，线程可以直接获取锁，如果state大于0，则线程会被封装成Node节点进入CLH队列并阻塞线程。AQS的CLH队列是一个双向的链表结构，头结点是一个空的Node节点。新来的node节点会被插入队尾并开启自旋去判断它的前驱节点是不是头结点。如果是头结点则尝试获取锁，如果不是头结点，则根据条件进行挂起操作。</p><p>画一个流程图大家可做参考：</p><p><img src="https://raw.githubusercontent.com/zhpanvip/images/master/project/article/thread/aqs.png" alt="aqs.png"></p><h2 id="参考-amp-推荐阅读"><a href="#参考-amp-推荐阅读" class="headerlink" title="参考&amp;推荐阅读"></a>参考&amp;推荐阅读</h2><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&mid=2651749434&idx=3&sn=5ffa63ad47fe166f2f1a9f604ed10091&chksm=bd12a5778a652c61509d9e718ab086ff27ad8768586ea9b38c3dcf9e017a8e49bcae3df9bcc8&scene=38#wechat_redirect">【基本功】不可不说的Java“锁”事</a></p><p><a href="https://blog.csdn.net/javazejian/article/details/75043422">深入剖析基于并发AQS的(独占锁)重入锁(ReetrantLock)及其Condition实现原理</a></p><p><a href="https://tech.meituan.com/2019/12/05/aqs-theory-and-apply.html">从ReentrantLock的实现看AQS的原理及应用</a></p>]]></content>
    
    
    <categories>
      
      <category>Java进阶</category>
      
    </categories>
    
    
    <tags>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>这一次，彻底搞懂Java中的synchronized关键字</title>
    <link href="/2021/06/14/39-synchronized/"/>
    <url>/2021/06/14/39-synchronized/</url>
    
    <content type="html"><![CDATA[<p>多线程并发是Java语言中非常重要的一块内容，同时，也是Java基础的一个难点。说它重要是因为多线程是日常开发中频繁用到的知识，说它难是因为多线程并发涉及到的知识点非常之多，想要完全掌握Java的并发相关知识并非易事。也正因此，Java并发成了Java面试中最高频的知识点之一。本系列文章将从Java内存模型、volatile关键字、synchronized关键字、ReetrantLock、Atomic并发类以及线程池等方面来系统的认识Java的并发知识。通过本系列文章的学习你将深入理解volatile关键字的作用，了解到synchronized实现原理、AQS和CLH队列锁，清晰的认识自旋锁、偏向锁、乐观锁、悲观锁…等等一系列让人眼花缭乱的并发知识。</p><p>多线程并发系列文章：</p><p><a href="https://zhangpan.site/2021/05/30/37-jmm-volatile/">这一次，彻底搞懂Java内存模型与volatile关键字</a></p><p><a href="https://zhangpan.site/2021/06/14/39-synchronized/">这一次，彻底搞懂Java中的synchronized关键字</a></p><p><a href="https://zhangpan.site/2021/06/19/40-reentranlock/">这一次，彻底搞懂Java中的ReentrantLock实现原理</a></p><p><a href="https://zhangpan.site/2021/06/26/41-atomic-cas/">这一次，彻底搞懂Java并发包中的Atomic原子类</a></p><p><a href="https://zhangpan.site/2021/07/02/42-wait-notify1/">深入理解Java线程的等待与唤醒机制（一）</a></p><p><a href="https://zhangpan.site/2021/07/03/43-wait-notify2/">深入理解Java线程的等待与唤醒机制（二）</a></p><p><a href="https://zhangpan.site/2021/07/10/44-thread-pool/">Java并发系列终结篇：彻底搞懂Java线程池的工作原理</a></p><p><a href="https://zhangpan.site/2021/07/19/45-ThreadLocal/">Java并发系列番外篇：ThreadLocal原理其实很简单</a></p><p>本文是Java并发系列的第二篇文章，将详细的讲解synchronized关键字以及其底层实现原理。</p><h2 id="一、synchronized基本使用"><a href="#一、synchronized基本使用" class="headerlink" title="一、synchronized基本使用"></a>一、synchronized基本使用</h2><p>上篇文章详细讲解了volatile关键字，我们知道volatile关键字可以保证共享变量的可见性和有序性，但并不能保证原子性。如果既想保证共享变量的可见性和有序性，又想保证原子性，那么synchronized关键字是一个不错的选择。</p><p>synchronized的使用很简单，可以用它来修饰实例方法和静态方法，也可以用来修饰代码块。值的注意的是synchronized是一个对象锁，也就是它锁的是一个对象。因此，无论使用哪一种方法，synchronized都需要有一个锁对象</p><h3 id="1-修饰实例方法"><a href="#1-修饰实例方法" class="headerlink" title="1.修饰实例方法"></a>1.修饰实例方法</h3><p>synchronized修饰实例方法只需要在方法上加上synchronized关键字即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">()</span></span>&#123;<br>       i++;<br>&#125;<br></code></pre></td></tr></table></figure><p>此时，synchronized加锁的对象就是这个方法所在实例的本身。</p><h3 id="2-修饰静态方法"><a href="#2-修饰静态方法" class="headerlink" title="2.修饰静态方法"></a>2.修饰静态方法</h3><p>synchronized修饰静态方法的使用与实例方法并无差别，在静态方法上加上synchronized关键字即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">()</span></span>&#123;<br>       i++;<br>&#125;<br></code></pre></td></tr></table></figure><p>此时，synchronized加锁的对象为当前静态方法所在类的Class对象。</p><h3 id="3-修饰代码块"><a href="#3-修饰代码块" class="headerlink" title="3.修饰代码块"></a>3.修饰代码块</h3><p>synchronized修饰代码块需要传入一个对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">()</span> </span>&#123;f<br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>        i++;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>很明显，此时synchronized加锁对象即为传入的这个对象实例。</p><p>到这里不是道你是否有个疑问，synchronized关键字是如何对一个对象加锁实现代码同步的呢？如果想弄清楚，那就不得不先了解一下Java对象的对象头了。</p><h2 id="二、Java对象头与Monitor对象"><a href="#二、Java对象头与Monitor对象" class="headerlink" title="二、Java对象头与Monitor对象"></a>二、Java对象头与Monitor对象</h2><p>在JVM中，对象在内存中存储的布局可以分为三个区域，分别是对象头、实例数据以及填充数据。</p><ul><li><strong>实例数据</strong> 存放类的属性数据信息，包括父类的属性信息，这部分内存按4字节对齐。</li><li><strong>填充数据</strong> 由于虚拟机要求对象起始地址必须是8字节的整数倍。填充数据不是必须存在的，仅仅是为了字节对齐。</li><li><strong>对象头</strong> 在HotSpot虚拟机中，对象头又被分为两部分，分别为：Mark Word(标记字段)、Class Pointer(类型指针)。如果是数组，那么还会有数组长度。对象头是本章内容的重点，下边详细讨论。</li></ul><h3 id="1-对象头"><a href="#1-对象头" class="headerlink" title="1.对象头"></a>1.对象头</h3><p>在对象头的Mark Word中主要存储了对象自身的运行时数据，例如哈希码、GC分代年龄、锁状态、线程持有的锁、偏向线程ID以及偏向时间戳等。同时，Mark Word也记录了对象和锁有关的信息。</p><p>当对象被synchronized关键字当成同步锁时，和锁相关的一系列操作都与Mark Word有关。由于在JDK1.6版本中对synchronized进行了锁优化，引入了偏向锁和轻量级锁（关于锁优化后边详情讨论）。Mark Word在不同锁状态下存储的内容有所不同。我们以32位JVM中对象头的存储内容如下图所示。</p><p><img src="https://raw.githubusercontent.com/zhpanvip/images/master/project/article/thread/object_header.png" alt="object_header.png"></p><p>从图中可以清楚的看到，Mark Word中有2bit的数据用来标记锁的状态。无锁状态和偏向锁标记位为01，轻量级锁的状态为00，重量级锁的状态为10。</p><ul><li>当对象为偏向锁时，Mark Word存储了偏向线程的ID；</li><li>当状态为轻量级锁时，Mark Word存储了指向线程栈中Lock Record的指针；</li><li>当状态为重量级锁时，Mark Word存储了指向堆中的Monitor对象的指针。</li></ul><p>当前我们只讨论重量级锁，因为重量级锁相当于对synchronized优化之前的状态。关于偏向锁和轻量级锁在后边锁优化章节中详细讲解。</p><p>可以看到，当为重量级锁时，对象头的MarkWord中存储了指向Monitor对象的指针。那么Monitor又是什么呢？</p><h3 id="2-Monitor对象"><a href="#2-Monitor对象" class="headerlink" title="2.Monitor对象"></a>2.Monitor对象</h3><p>Monitor对象被称为管程或者监视器锁。在Java中，每一个对象实例都会关联一个Monitor对象。这个Monitor对象既可以与对象一起创建销毁，也可以在线程试图获取对象锁时自动生成。当这个Monitor对象被线程持有后，它便处于锁定状态。</p><p>在HotSpot虚拟机中，Monitor是由<a href="https://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/782f3b88b5ba/src/share/vm/runtime/objectMonitor.hpp">ObjectMonitor</a>实现的,它是一个使用C++实现的类，主要数据结构如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++">ObjectMonitor() &#123;<br>    _header       = <span class="hljs-literal">NULL</span>;<br>    _count        = <span class="hljs-number">0</span>; <span class="hljs-comment">//记录个数</span><br>    _waiters      = <span class="hljs-number">0</span>,<br>    _recursions   = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 线程重入次数</span><br>    _object       = <span class="hljs-literal">NULL</span>;<br>    _owner        = <span class="hljs-literal">NULL</span>;<br>    _WaitSet      = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">//处于wait状态的线程，会被加入到_WaitSet</span><br>    _WaitSetLock  = <span class="hljs-number">0</span> ;<br>    _Responsible  = <span class="hljs-literal">NULL</span> ;<br>    _succ         = <span class="hljs-literal">NULL</span> ;<br>    _cxq          = <span class="hljs-literal">NULL</span> ;<br>    FreeNext      = <span class="hljs-literal">NULL</span> ;<br>    _EntryList    = <span class="hljs-literal">NULL</span> ; <span class="hljs-comment">//处于获取锁失败的线程，会被加入到该列表</span><br>    _SpinFreq     = <span class="hljs-number">0</span> ;<br>    _SpinClock    = <span class="hljs-number">0</span> ;<br>    OwnerIsThread = <span class="hljs-number">0</span> ;<br>  &#125;<br></code></pre></td></tr></table></figure><p>ObjectMonitor中有四个重要部分，分别为_ower,_WaitSet,_EntryList和count。</p><ul><li><strong>_ower</strong> 用来指向持有monitor的线程，它的初始值为NULL,表示当前没有任何线程持有monitor。当一个线程成功持有该锁之后会保存线程的ID标识，等到线程释放锁后_ower又会被重置为NULL。</li><li><strong>_EntryList</strong> 用于存放所有试图获取monitor而被阻塞的线程。</li><li><strong>_WaitSet</strong> 用于存放所有wait状态的线程。</li><li><strong>count</strong> 用于记录线程获取锁的次数，成功获取到锁后count会加1，释放锁时count减1。</li></ul><p>如果有多个线程同时访问同一段同步代码的时候，线程会首先进入_EntryList集合中。当线程获取到对象的monitor后，就会将monitor中的ower设置为该线程的ID，同时monitor中的count进行加1.如果线程调用wait()方法，线程会释放当前持有的monitor，owner变量被重置为NULL，且count减1,同时该线程会进入到_WaitSet集合中等待被唤醒。当然，如果这个线程的代码执行完后也会释放monitor对象，以便其他线程获取锁。</p><p>了解了对象头和Monitor，那么synchronized关键字到底是如何做到与monitor关联的呢？</p><h3 id="三、synchronized底层实现原理"><a href="#三、synchronized底层实现原理" class="headerlink" title="三、synchronized底层实现原理"></a>三、synchronized底层实现原理</h3><p>在Java代码中，我们只是使用了synchronized关键字就实现了同步效果。那他到底是怎么做到的呢？这就需要我们通过javap工具来反汇编出字节指令一探究竟了。</p><h3 id="1-同步代码块"><a href="#1-同步代码块" class="headerlink" title="1.同步代码块"></a>1.同步代码块</h3><p>通过javap -v来反汇编下面的一段代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>        i++;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以得到如下的字节码指令：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">com</span>.<span class="hljs-title">zhangpan</span>.<span class="hljs-title">text</span>.<span class="hljs-title">TestSync</span> </span>&#123;<br>  <span class="hljs-keyword">public</span> com.zhangpan.text.TestSync();<br>    Code:<br>       <span class="hljs-number">0</span>: aload_0<br>       1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V<br>       <span class="hljs-number">4</span>: <span class="hljs-keyword">return</span><br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">()</span></span>;<br>    Code:<br>       <span class="hljs-number">0</span>: aload_0<br>       <span class="hljs-number">1</span>: dup<br>       <span class="hljs-number">2</span>: astore_1<br>       <span class="hljs-number">3</span>: monitorenter    <span class="hljs-comment">// synchronized关键字的入口</span><br>       4: getstatic     #2                  // Field i:I<br>       <span class="hljs-number">7</span>: iconst_1<br>       <span class="hljs-number">8</span>: iadd<br>       9: putstatic     #2                  // Field i:I<br>      <span class="hljs-number">12</span>: aload_1<br>      <span class="hljs-number">13</span>: monitorexit  <span class="hljs-comment">// synchronized关键字的出口</span><br>      <span class="hljs-number">14</span>: goto          <span class="hljs-number">22</span><br>      <span class="hljs-number">17</span>: astore_2<br>      <span class="hljs-number">18</span>: aload_1<br>      <span class="hljs-number">19</span>: monitorexit <span class="hljs-comment">// synchronized关键字的出口</span><br>      <span class="hljs-number">20</span>: aload_2<br>      <span class="hljs-number">21</span>: athrow<br>      <span class="hljs-number">22</span>: <span class="hljs-keyword">return</span><br>    Exception table:<br>       from    to  target type<br>           <span class="hljs-number">4</span>    <span class="hljs-number">14</span>    <span class="hljs-number">17</span>   any<br>          <span class="hljs-number">17</span>    <span class="hljs-number">20</span>    <span class="hljs-number">17</span>   any<br>&#125;<br></code></pre></td></tr></table></figure><p>从字节码指令中可以看到add方法的第3条指令处和第13、19条指令处分别有monitorenter和moniterexit两条指令。另外第4、7、8、9、13这几条指令其实就是i++的指令。由此可以得出在字节码中会在同步代码块的入口和出口加上monitorenter和moniterexit指令。当执行到monitorenter指令时，线程就会去尝试获取该对象对应的Monitor的所有权，即尝试获得该对象的锁。</p><p>当该对象的 monitor 的计数器count为0时，那线程可以成功取得 monitor，并将计数器值设置为 1，取锁成功。如果当前线程已经拥有该对象monitor的持有权，那它可以重入这个 monitor ，计数器的值也会加 1。而当执行monitorexit指令时，锁的计数器会减1。</p><p>倘若其他线程已经拥有monitor 的所有权，那么当前线程获取锁失败将被阻塞并进入到_WaitSet中，直到等待的锁被释放为止。也就是说，当所有相应的monitorexit指令都被执行，计数器的值减为0，执行线程将释放 monitor(锁)，其他线程才有机会持有 monitor 。</p><h3 id="2-同步方法的实现"><a href="#2-同步方法的实现" class="headerlink" title="2.同步方法的实现"></a>2.同步方法的实现</h3><p>同步方法的字节码指令与同步代码块的字节指令有所差异。我们先来通过javap -v查看下面代码的字节码指令。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">()</span></span>&#123;<br>       i++;<br>&#125;<br></code></pre></td></tr></table></figure><p>反汇编后可得到如下的字节指令</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">()</span></span>;<br>   descriptor: ()V<br>   flags: (<span class="hljs-number">0x0021</span>) ACC_PUBLIC, ACC_SYNCHRONIZED<br>   Code:<br>     stack=<span class="hljs-number">3</span>, locals=<span class="hljs-number">1</span>, args_size=<span class="hljs-number">1</span><br>        <span class="hljs-number">0</span>: aload_0<br>        <span class="hljs-number">1</span>: dup<br>        2: getfield      #2                  // Field i:I<br>        <span class="hljs-number">5</span>: iconst_1<br>        <span class="hljs-number">6</span>: iadd<br>        7: putfield      #2                  // Field i:I<br>       <span class="hljs-number">10</span>: <span class="hljs-keyword">return</span><br>     LineNumberTable:<br>       line <span class="hljs-number">5</span>: <span class="hljs-number">0</span><br>       line <span class="hljs-number">6</span>: <span class="hljs-number">10</span><br><br></code></pre></td></tr></table></figure><p>可以看到这里并没有monitorenter和moniterexit两条指令，而是在方法的flag上加入了ACC_SYNCHRONIZED的标记位。这其实也容易理解，因为整个方法都是同步代码，因此就不需要标记同步代码的入口和出口了。当线程线程执行到这个方法时会判断是否有这个ACC_SYNCHRONIZED标志，如果有的话则会尝试获取monitor对象锁。执行步骤与同步代码块一致，这里就不再赘述了。</p><h2 id="四、重量级锁存在性能问题"><a href="#四、重量级锁存在性能问题" class="headerlink" title="四、重量级锁存在性能问题"></a>四、重量级锁存在性能问题</h2><p>在Linux系统架构中可以分为用户空间和内核，我们的程序都运行在用户空间，进入用户运行状态就是所谓的用户态。在用户态可能会涉及到某些操作如I/O调用，就会进入内核中运行，此时进程就被称为内核运行态，简称内核态。</p><p><img src="https://raw.githubusercontent.com/zhpanvip/images/master/project/article/thread/linux_kernel.png" alt="linux_kernel.png"></p><ul><li><strong>内核：</strong> 本质上可以理解为一种软件，控制计算机的硬件资源，并提供上层应用程序运行的环境。</li><li><strong>用户空间：</strong> 上层应用程序活动的空间。应用程序的执行必须依托于内核提供的资源，包括CPU资源、存储资源、I/O资源等。</li><li><strong>系统调用：</strong> 为了使上层应用能够访问到这些资源，内核必须为上层应用提供访问的接口：即系统调用。</li></ul><p>上边我们已经提到了使用monitor是重量级锁的加锁方式。在<a href="https://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/782f3b88b5ba/src/share/vm/runtime/objectMonitor.cpp">objectMonitor.cpp</a>中会涉及到Atomic::cmpxchg_ptr，Atomic::inc_ptr等内核函数，<br>执行同步代码块，没有竞争到锁的对象会park()被挂起，竞争到锁的线程会unpark()唤醒。这个时候就会存在操作系统用户态和内核态的转换，这种切换会消耗大量的系统资源。试想，如果程序中存在大量的锁竞争，那么会引起程序频繁的在用户态和内核态进行切换，严重影响到程序的性能。这也是为什么说synchronized效率低的原因</p><p>为了解决这一问题，在JDK1.6中引入了偏向锁和轻量级锁来优化synchronized。</p><h2 id="五、synchronized锁优化"><a href="#五、synchronized锁优化" class="headerlink" title="五、synchronized锁优化"></a>五、synchronized锁优化</h2><p>JDK1.6中引入偏向锁和轻量级锁对synchronized进行优化。此时的synchronized一共存在四个状态：无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态。锁着锁竞争激烈程度，锁的状态会出现一个升级的过程。即可以从偏向锁升级到轻量级锁，再升级到重量级锁。锁升级的过程是单向不可逆的，即一旦升级为重量级锁就不会再出现降级的情况。</p><h3 id="1-几种锁状态"><a href="#1-几种锁状态" class="headerlink" title="1.几种锁状态"></a>1.几种锁状态</h3><p>接下来我们来详细的认识一下这几种锁状态。</p><h4 id="1-偏向锁"><a href="#1-偏向锁" class="headerlink" title="1).偏向锁"></a>1).偏向锁</h4><p>经研究发现，<strong>在大多数情况下锁不仅不存在多线程竞争关系，而且大多数情况都是被同一线程多次获得</strong>。因此，为了减少同一线程获取锁的代价而引入了偏向锁的概念。</p><p>偏向锁的核心思想是，如果一个线程获得了锁，那么锁就进入偏向模式，此时Mark Word的结构也变为偏向锁结构，即将对象头中Mark Word的第30bit的值改为1，并且在Mark Word中记录该线程的ID。当这个线程再次请求锁时，无需再做任何同步操作，即可获取锁的过程，这样就省去了大量有关锁申请的操作，从而也就提升了程序的性能。所以，对于没有锁竞争的场合，偏向锁有很好的优化效果，毕竟极有可能连续多次是同一个线程申请相同的锁。</p><p>但是，对于锁竞争比较激烈的情况，偏向锁就有问题了。因为每次申请锁的都可能是不同线程。这种情况使用偏向锁就会得不偿失，此时就会升级为轻量级锁。</p><h4 id="2-轻量级锁"><a href="#2-轻量级锁" class="headerlink" title="2).轻量级锁"></a>2).轻量级锁</h4><p>轻量级锁优化性能的依据是<strong>对于大部分的锁，在整个同步生命周期内都不存在竞争。</strong> 当升级为轻量级锁之后，MarkWord的结构也会随之变为轻量级锁结构。JVM会利用CAS尝试把对象原本的Mark Word 更新为Lock Record的指针，成功就说明加锁成功，改变锁标志位为00，然后执行相关同步操作。</p><p>轻量级锁所适应的场景是线程交替执行同步块的场合，如果存在同一时间访问同一锁的场合，就会导致轻量级锁就会失效，进而膨胀为重量级锁。</p><h4 id="3-自旋锁"><a href="#3-自旋锁" class="headerlink" title="3).自旋锁"></a>3).自旋锁</h4><p>轻量级锁失败后，虚拟机为了避免线程真实地在操作系统层面挂起，还会进行一项称为自旋锁的优化手段。</p><p>自旋锁是基于<strong>在大多数情况下，线程持有锁的时间都不会太长</strong>。如果直接挂起操作系统层面的线程可能会得不偿失，毕竟操作系统实现线程之间的切换时需要从用户态转换到核心态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高，因此自旋锁会假设在不久将来，当前的线程可以获得锁，因此虚拟机会让当前想要获取锁的线程做几个空循环(这也是称为自旋的原因)，不断的尝试获取锁。空循环一般不会执行太多次，可能是50个循环或100循环，在经过若干次循环后，如果得到锁，就顺利进入同步代码。如果还不能获得锁，那就会将线程在操作系统层面挂起，即进入到重量级锁。</p><p>这就是自旋锁的优化方式，这种方式确实也是可以提升效率的。</p><h3 id="2-synchronized锁升级过程"><a href="#2-synchronized锁升级过程" class="headerlink" title="2.synchronized锁升级过程"></a>2.synchronized锁升级过程</h3><p>在了解了jdk1.6引入的这几种锁之后，我们来详细的看一下synchronized是怎么一步步进行锁升级的。</p><p>(1）当没有被当成锁时，这就是一个普通的对象，Mark Word记录对象的HashCode，锁标志位是01，是否偏向锁那一位是0;</p><p>(2）当对象被当做同步锁并有一个线程A抢到了锁时，锁标志位还是01，但是否偏向锁那一位改成1，前23bit记录抢到锁的线程id，表示进入偏向锁状态;</p><p>(3) 当线程A再次试图来获得锁时，JVM发现同步锁对象的标志位是01，是否偏向锁是1，也就是偏向状态，Mark Word中记录的线程id就是线程A自己的id，表示线程A已经获得了这个偏向锁，可以执行同步中的代码;</p><p>(4) 当线程B试图获得这个锁时，JVM发现同步锁处于偏向状态，但是Mark Word中的线程id记录的不是B，那么线程B会先用CAS操作试图获得锁，这里的获得锁操作是有可能成功的，因为线程A一般不会自动释放偏向锁。如果抢锁成功，就把Mark Word里的线程id改为线程B的id，代表线程B获得了这个偏向锁，可以执行同步代码。如果抢锁失败，则继续执行步骤5;</p><p>(5) 偏向锁状态抢锁失败，代表当前锁有一定的竞争，偏向锁将升级为轻量级锁。JVM会在当前线程的线程栈中开辟一块单独的空间，里面保存指向对象锁Mark Word的指针，同时在对象锁Mark Word中保存指向这片空间的指针。上述两个保存操作都是CAS操作，如果保存成功，代表线程抢到了同步锁，就把Mark Word中的锁标志位改成00，可以执行同步代码。如果保存失败，表示抢锁失败，竞争太激烈，继续执行步骤6;</p><p>(6) 轻量级锁抢锁失败，JVM会使用自旋锁，自旋锁不是一个锁状态，只是代表不断的重试，尝试抢锁。从JDK1.7开始，自旋锁默认启用，自旋次数由JVM决定。如果抢锁成功则执行同步代码，如果失败则继续执行步骤7;</p><p>(7) 自旋锁重试之后如果抢锁依然失败，同步锁会升级至重量级锁，锁标志位改为10。在这个状态下，未抢到锁的线程都会被阻塞。</p><h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>synchronized关键字的使用可以说非常简单，但是想要完全搞懂synchronized实际上并没有那么容易。因为它涉及到很多虚拟机底层的知识。同时，还要了解JDK1.6中对synchronized针对性的优化，其中牵扯到的东西又很多。比如，本篇文章并没有讲解什么是CAS，如果你不懂CAS，就很难理解锁升级的过程。需要不懂读者自行去查阅相关资料。本篇文章对于synchronized的讲解相对来说还是很全面的。希望你看完能有所收获。</p><h2 id="参考-amp-推荐阅读"><a href="#参考-amp-推荐阅读" class="headerlink" title="参考&amp;推荐阅读"></a>参考&amp;推荐阅读</h2><p><a href="https://blog.csdn.net/u012723673/article/details/102681942">深入理解Java中synchronized关键字的实现原理</a></p><p><a href="https://zicair.github.io/2020/07/13/synchronized%E5%BA%95%E5%B1%82monitor%E5%8E%9F%E7%90%86/">synchronized底层monitor原理</a></p><p><a href="https://www.cnblogs.com/LemonFive/p/11246086.html">盘一盘 synchronized （一）—— 从打印Java对象头说起</a></p>]]></content>
    
    
    <categories>
      
      <category>Java进阶</category>
      
    </categories>
    
    
    <tags>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>这一次，彻底搞懂SparseArray实现原理</title>
    <link href="/2021/06/13/38-sparsearray/"/>
    <url>/2021/06/13/38-sparsearray/</url>
    
    <content type="html"><![CDATA[<p>最近在整理SparseArray这一知识点的时候，发现网上大多数SparseArray原理分析的文章都存在很多问题（可以说很多作者并没有读懂SparseArray的源码），也正因此，才有了这篇SparseArray原理的文章。我们知道，SparseArray与ArrayMap是Android中高效存储K-V的数据结构，也是是Android面试中的常客，弄懂它们的实现原理是很有必要的，本篇文章就以SparseArray的源码为例进行深入分析。</p><h2 id="一、SparseArray的类结构"><a href="#一、SparseArray的类结构" class="headerlink" title="一、SparseArray的类结构"></a>一、SparseArray的类结构</h2><p>SparseArray可以翻译为<strong>稀疏数组</strong>，从字面上可以理解为松散不连续的数组。虽然叫做Array，但它却是存储K-V的一种数据结构。其中Key只能是int类型，而Value是Object类型。我们来看下它的类结构：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SparseArray</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">Cloneable</span> </span>&#123;<br>    <span class="hljs-comment">// 用来标记此处的值已被删除</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object DELETED = <span class="hljs-keyword">new</span> Object();<br>    <span class="hljs-comment">// 用来标记是否有元素被移除</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> mGarbage = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-comment">// 用来存储key的集合</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] mKeys;<br>    <span class="hljs-comment">// 用来存储value的集合</span><br>    <span class="hljs-keyword">private</span> Object[] mValues;<br>    <span class="hljs-comment">// 存入的元素个数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> mSize;<br><br>    <span class="hljs-comment">// 默认初始容量为10</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SparseArray</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>(<span class="hljs-number">10</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SparseArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span> initialCapacity)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (initialCapacity == <span class="hljs-number">0</span>) &#123;<br>            mKeys = EmptyArray.INT;<br>            mValues = EmptyArray.OBJECT;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            mValues = ArrayUtils.newUnpaddedObjectArray(initialCapacity);<br>            mKeys = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[mValues.length];<br>        &#125;<br>        mSize = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// ...省略其他代码</span><br><br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到SparseArray仅仅实现了Cloneable接口并没有实现Map接口，并且SparseArray内部维护了一个int数组和一个Object数组。在无参构造方法中调用了有参构造，并将其初始容量设置为了10。</p><h2 id="二、SparseArray的remove-方法"><a href="#二、SparseArray的remove-方法" class="headerlink" title="二、SparseArray的remove()方法"></a>二、SparseArray的remove()方法</h2><p>是不是觉得很奇怪？作为一个容器类，不先讲put方法怎么先将remove呢？这是因为remove方法的一些操作会影响到put的操作。只有先了解了remove才能更容易理解put方法。我们来看remove的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">// SparseArray</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>    delete(key);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> i = ContainerHelpers.binarySearch(mKeys, mSize, key);<br><br>    <span class="hljs-keyword">if</span> (i &gt;= <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (mValues[i] != DELETED) &#123;<br>            mValues[i] = DELETED;<br>            mGarbage = <span class="hljs-keyword">true</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到remove方法直接调用了delete方法。而在delete方法中会先通过二分查找（二分查找代码后边分析）找到key所在的位置，然后将这一位置的value值置为DELETE，注意，这里还将mGarbage设置为了true来标记集合中存在删除元素的情况。想象一下，在删除多个元素后这个集合中是不是就可能会出现不连续的情况？大概这也是SparseArray名字的由来吧。</p><h2 id="三、SparseArray的put-方法"><a href="#三、SparseArray的put-方法" class="headerlink" title="三、SparseArray的put()方法"></a>三、SparseArray的put()方法</h2><p>作为一个存储K-V类型的数据结构，put方法是key和value的入口。也是SparseArray中最重要的一个方法。先来看下put方法的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// SparseArray</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key, E value)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> i = ContainerHelpers.binarySearch(mKeys, mSize, key);<br><br>    <span class="hljs-keyword">if</span> (i &gt;= <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 意味着之前mKeys中已经有对应的key存在了,第i个位置对应的就是key。</span><br>        mValues[i] = value; <span class="hljs-comment">// 直接更新value</span><br>    &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 返回负数说明未在mKeys中查找到key</span><br><br>        <span class="hljs-comment">// 取反得到待插入key的位置</span><br>        i = ~i;<br><br><span class="hljs-comment">// 如果插入位置小于size,并且这个位置的value刚好是被删除掉的，那么直接将key和value分别插入mKeys和mValues的第i个位置</span><br>        <span class="hljs-keyword">if</span> (i &lt; mSize &amp;&amp; mValues[i] == DELETED) &#123;<br>            mKeys[i] = key;<br>            mValues[i] = value;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><span class="hljs-comment">// mGarbage为true说明有元素被移除了，此时mKeys已经满了，但是mKeys内部有被标记为DELETE的元素</span><br>        <span class="hljs-keyword">if</span> (mGarbage &amp;&amp; mSize &gt;= mKeys.length) &#123;<br>            <span class="hljs-comment">// 调用gc方法移动mKeys和mValues中的元素，这个方法可以后边分析</span><br>            gc();<br><br>            <span class="hljs-comment">// 由于gc方法移动了数组，因此插入位置可能有变化，所以需要重新计算插入位置</span><br>            i = ~ContainerHelpers.binarySearch(mKeys, mSize, key);<br>        &#125;<br><span class="hljs-comment">// GrowingArrayUtils的insert方法将会将插入位置之后的所有数据向后移动一位，然后将key和value分别插入到mKeys和mValue对应的第i个位置，如果数组空间不足还会开启扩容，后边分析这个insert方法</span><br>        mKeys = GrowingArrayUtils.insert(mKeys, mSize, i, key);<br>        mValues = GrowingArrayUtils.insert(mValues, mSize, i, value);<br>        mSize++;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>虽然这个方法只有寥寥数行，但是想要完全理解却并非易事，即使写了很详细的注释也不容易读懂。我们不妨来详细分析一下。第一行代码通过二分查找得到了一个index。看下二分查找的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ContainerHelpers</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] array, <span class="hljs-keyword">int</span> size, <span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> lo = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> hi = size - <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">while</span> (lo &lt;= hi) &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> mid = (lo + hi) &gt;&gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> midVal = array[mid];<br><br>        <span class="hljs-keyword">if</span> (midVal &lt; value) &#123;<br>            lo = mid + <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (midVal &gt; value) &#123;<br>            hi = mid - <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> mid;  <span class="hljs-comment">// value found</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ~lo;  <span class="hljs-comment">// value not present</span><br>&#125;<br></code></pre></td></tr></table></figure><p>关于二分查找相信大家都是比较熟悉的，这一算法用于在一组有序数组中查找某一元素所在位置的。如果数组中存在这一元素，则将这个元素对应的位置返回。如果不存在那么此时的lo就是这个元素的最佳存储位置。上述代码中将lo取反作为了返回值。因为lo一定是大于等于0的数，因此取反后的返回值必定小于等于0.明白了这一点，再来看put方法中的这个if…else是不是很容易理解了？</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// SparseArray</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span>(<span class="hljs-params"><span class="hljs-keyword">int</span> key, E <span class="hljs-keyword">value</span></span>)</span> &#123;<br><br>    <span class="hljs-keyword">if</span> (i &gt;= <span class="hljs-number">0</span>) &#123;<br>        mValues[i] = <span class="hljs-keyword">value</span>; <span class="hljs-comment">// 直接更新value</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        i = ~i;<br>        <span class="hljs-comment">// ... 省略其它代码</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果i&gt;=0,意味着当前的这个key已经存在于mKeys中了，那么此时put只需要将最新的value更新到mValues中即可。而如果i&lt;=0就意味着mKeys中之前没有对应的key。因此就需要将key和value分别插入到mKeys和mValues中。而插入的最佳位置就是对i取反。</p><p>得到插入位置之后，如果这个位置是被标记为删除的元素，那么久可以直接将其覆盖掉了，因此有以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key, E value)</span> </span>&#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">if</span> (i &gt;= <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// ...</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 如果i对应的位置是被删除掉的，可以直接将其覆盖</span><br>        <span class="hljs-keyword">if</span> (i &lt; mSize &amp;&amp; mValues[i] == DELETED) &#123;<br>            mKeys[i] = key;<br>            mValues[i] = value;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>如果上边条件不满足，那么继续往下看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key, E value)</span> </span>&#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">if</span> (i &gt;= <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// ...</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">// mGarbage为true说明有元素被移除了，此时mKeys已经满了，但是mKeys内部有被标记为DELETE的元素</span><br>        <span class="hljs-keyword">if</span> (mGarbage &amp;&amp; mSize &gt;= mKeys.length) &#123;<br>            <span class="hljs-comment">// 调用gc方法移动mKeys和mValues中的元素，这个方法可以后边分析</span><br>            gc();<br><br>            <span class="hljs-comment">// 由于gc方法移动了数组，因此插入位置可能有变化，所以需要重新计算插入位置</span><br>            i = ~ContainerHelpers.binarySearch(mKeys, mSize, key);<br>        &#125;<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>上边我们已经知道，在remove元素的时候mGarbage会被置为true，这段代码意味着有被移除的元素，被移除的位置并不是要插入的位置，并且如果mKeys已经满了，那么就调用gc方法来移动元素填充被移除的位置。由于mKeys中元素位置发生了变化，因此key插入的位置也可能改变，因此需要再次调用二分法来查找key的插入位置。</p><p>以上代码最终会确定key被插入的位置，接下来调用GrowingArrayUtils的insert方法来进行key的插入操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// SparseArray</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key, E value)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> i = ContainerHelpers.binarySearch(mKeys, mSize, key);<br><br>    <span class="hljs-keyword">if</span> (i &gt;= <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// ...</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>         <span class="hljs-comment">// ...</span><br><br><span class="hljs-comment">// GrowingArrayUtils的insert方法将会将插入位置之后的所有数据向后移动一位，然后将key和value分别插入到mKeys和mValue对应的第i个位置，如果数组空间不足还会开启扩容，后边分析这个insert方法</span><br>        mKeys = GrowingArrayUtils.insert(mKeys, mSize, i, key);<br>        mValues = GrowingArrayUtils.insert(mValues, mSize, i, value);<br>        mSize++;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>GrowingArrayUtils的insert方法代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// GrowingArrayUtils</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; T[] insert(T[] array, <span class="hljs-keyword">int</span> currentSize, <span class="hljs-keyword">int</span> index, T element) &#123;<br>    <span class="hljs-keyword">assert</span> currentSize &lt;= array.length;<br>    <span class="hljs-comment">// 如果插入后数组size小于数组长度，能进行插入操作</span><br>    <span class="hljs-keyword">if</span> (currentSize + <span class="hljs-number">1</span> &lt;= array.length) &#123;<br>        <span class="hljs-comment">// 将index之后的所有元素向后移动一位</span><br>        System.arraycopy(array, index, array, index + <span class="hljs-number">1</span>, currentSize - index);<br>        <span class="hljs-comment">// 将key插入到index的位置</span><br>        array[index] = element;<br>        <span class="hljs-keyword">return</span> array;<br>    &#125;<br><br>    <span class="hljs-comment">// 来到这里说明数组已满，需需要进行扩容操作。newArray即为扩容后的数组</span><br>    T[] newArray = ArrayUtils.newUnpaddedArray((Class&lt;T&gt;)array.getClass().getComponentType(),<br>            growSize(currentSize));<br>    System.arraycopy(array, <span class="hljs-number">0</span>, newArray, <span class="hljs-number">0</span>, index);<br>    newArray[index] = element;<br>    System.arraycopy(array, index, newArray, index + <span class="hljs-number">1</span>, array.length - index);<br>    <span class="hljs-keyword">return</span> newArray;<br>&#125;<br><br><span class="hljs-comment">// 返回扩容后的size</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">growSize</span><span class="hljs-params">(<span class="hljs-keyword">int</span> currentSize)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> currentSize &lt;= <span class="hljs-number">4</span> ? <span class="hljs-number">8</span> : currentSize * <span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>insert方法的代码比较容易理解，如果数组容量足够，那么就将index之后的元素向后移动一位，然后将key插入index的位置。如果数组容量不足，那么则需要进行扩容，然后再进行插入操作。</p><h2 id="四、SparseArray的gc-方法"><a href="#四、SparseArray的gc-方法" class="headerlink" title="四、SparseArray的gc()方法"></a>四、SparseArray的gc()方法</h2><p>这个方法其实很容易理解，我们知道Java虚拟机在内存不足时会进行GC操作，标记清除法在回收垃圾对象后为了避免内存碎片化，会将存活的对象向内存的一端移动。而SparseArray中的这个gc方法其实就是借鉴了垃圾收集整理碎片空间的思想。</p><p>关于mGarbage这个参数上边已经有提到过了，这个变量会在删除元素的时候被置为true。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">// SparseArray中所有移除元素的方法中都将mGarbage置为true</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">removeReturnOld</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> i = ContainerHelpers.binarySearch(mKeys, mSize, key);<br><br>    <span class="hljs-keyword">if</span> (i &gt;= <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (mValues[i] != DELETED) &#123;<br>            <span class="hljs-keyword">final</span> E old = (E) mValues[i];<br>            mValues[i] = DELETED;<br>            mGarbage = <span class="hljs-keyword">true</span>;<br>            <span class="hljs-keyword">return</span> old;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> i = ContainerHelpers.binarySearch(mKeys, mSize, key);<br><br>    <span class="hljs-keyword">if</span> (i &gt;= <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (mValues[i] != DELETED) &#123;<br>            mValues[i] = DELETED;<br>            mGarbage = <span class="hljs-keyword">true</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removeAt</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (index &gt;= mSize &amp;&amp; UtilConfig.sThrowExceptionForUpperArrayOutOfBounds) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ArrayIndexOutOfBoundsException(index);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (mValues[index] != DELETED) &#123;<br>        mValues[index] = DELETED;<br>        mGarbage = <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><p>而SparseArray中所有插入和查找元素的方法中都会判断如果mGarbage为true，并且mSize &gt;= mKeys.length时调用gc,以append方法为例，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">append</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key, E value)</span> </span>&#123;<br><br>    <span class="hljs-keyword">if</span> (mGarbage &amp;&amp; mSize &gt;= mKeys.length) &#123;<br>        gc();<br>    &#125;<br><br>   <span class="hljs-comment">// ... 省略无关代码</span><br>&#125;<br></code></pre></td></tr></table></figure><p>源码中调用gc方法的地方多达8处，都是与添加和查找元素相关的方法。例如put()、keyAt()、setValueAt()等方法中。gc的实现其实比较简单，就是将删除位置后的所有数据向前移动一下，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">gc</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// Log.e(&quot;SparseArray&quot;, &quot;gc start with &quot; + mSize);</span><br><br>    <span class="hljs-keyword">int</span> n = mSize;<br>    <span class="hljs-keyword">int</span> o = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span>[] keys = mKeys;<br>    Object[] values = mValues;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        Object val = values[i];<br><br>        <span class="hljs-keyword">if</span> (val != DELETED) &#123;<br>            <span class="hljs-keyword">if</span> (i != o) &#123;<br>                keys[o] = keys[i];<br>                values[o] = val;<br>                values[i] = <span class="hljs-keyword">null</span>;<br>            &#125;<br><br>            o++;<br>        &#125;<br>    &#125;<br><br>    mGarbage = <span class="hljs-keyword">false</span>;<br>    mSize = o;<br><br>    <span class="hljs-comment">// Log.e(&quot;SparseArray&quot;, &quot;gc end with &quot; + mSize);</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="五、SparseArray的get-方法"><a href="#五、SparseArray的get-方法" class="headerlink" title="五、SparseArray的get()方法"></a>五、SparseArray的get()方法</h2><p>这个方法就比较简单了，因为put的时候是维持了一个有序数组，因此通过二分查找可以直接确定key在数组中的位置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key, E valueIfKeyNotFound)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> i = ContainerHelpers.binarySearch(mKeys, mSize, key);<br><br>    <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || mValues[i] == DELETED) &#123;<br>        <span class="hljs-keyword">return</span> valueIfKeyNotFound;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> (E) mValues[i];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>可见SparseArray是一个使用起来很简单的数据结构，但是它的原理理解起来似乎却没那么容易。这也是网上大部分文章对应SparseArray的解析都是含糊不清的原因。相信通过本篇文章的学习一定对SparseArray的实现有了新的认识！</p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>集合</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>这一次，彻底搞懂Java内存模型与volatile关键字</title>
    <link href="/2021/05/30/37-jmm-volatile/"/>
    <url>/2021/05/30/37-jmm-volatile/</url>
    
    <content type="html"><![CDATA[<p>多线程并发是Java语言中非常重要的一块内容，同时，也是Java基础的一个难点。说它重要是因为多线程是日常开发中频繁用到的知识，说它难是因为多线程并发涉及到的知识点非常之多，想要完全掌握Java的并发相关知识并非易事。也正因此，Java并发成了Java面试中最高频的知识点之一。本系列文章将从Java内存模型、volatile关键字、synchronized关键字、ReetrantLock、Atomic并发类以及线程池等方面来系统的认识Java的并发知识。通过本系列文章的学习你将深入理解volatile关键字的作用，了解到synchronized实现原理、AQS和CLH队列锁，清晰的认识自旋锁、偏向锁、乐观锁、悲观锁…等等一系列让人眼花缭乱的并发知识。</p><p>多线程并发系列文章：</p><p><a href="https://zhangpan.site/2021/05/30/37-jmm-volatile/">这一次，彻底搞懂Java内存模型与volatile关键字</a></p><p><a href="https://zhangpan.site/2021/06/14/39-synchronized/">这一次，彻底搞懂Java中的synchronized关键字</a></p><p><a href="https://zhangpan.site/2021/06/19/40-reentranlock/">这一次，彻底搞懂Java中的ReentranLock实现原理</a></p><p><a href="https://zhangpan.site/2021/06/26/41-atomic-cas/">这一次，彻底搞懂Java并发包中的Atomic原子类</a></p><p><a href="https://zhangpan.site/2021/07/02/42-wait-notify1/">深入理解Java线程的等待与唤醒机制（一）</a></p><p><a href="https://zhangpan.site/2021/07/03/43-wait-notify2/">深入理解Java线程的等待与唤醒机制（二）</a></p><p><a href="https://zhangpan.site/2021/07/10/44-thread-pool/">Java并发系列终结篇：彻底搞懂Java线程池的工作原理</a></p><p><a href="https://zhangpan.site/2021/07/19/45-ThreadLocal/">Java并发系列番外篇：ThreadLocal原理其实很简单</a></p><p>本文是Java并发系列的第一篇文章，将详细的讲解Java内存模型与volatile关键字的作用。</p><h2 id="一、Java内存模型"><a href="#一、Java内存模型" class="headerlink" title="一、Java内存模型"></a>一、Java内存模型</h2><p>提到Java内存模型，很多同学首先想到的是Java的内存区域划分。在这里首先声明本节内容并非讲解Java内存区域。但是，了解Java的内存区域，对于理解Java的内存模型会有一定的帮助。如果你想了解Java内存区域，可以参考我之前写的一篇文章<a href="https://juejin.cn/post/6868340872698658830">深入JVM–Java运行时内存区域详解</a></p><p>Java内存模型英文为<strong>Java Memory Model</strong>，简称为JMM。JMM本身是一个抽象概念，并非真实存在于Java虚拟机中。它的目的仅仅是定义了程序中各种变量（指实例变量、静态字段和构成数组对象的元素，但不包括局部变量和方法参数，因为局部变量和方法参数是线程私有的，不会被线程共享）的访问规范，即关注在虚拟机中把变量存储到内存和从内存中取出变量值这样的底层细节。而在虚拟机中的运算单元就是线程，因此<strong>可以理解为JMM定义的就是线程访问共享变量的方式。</strong> 当然，这么解释JMM可能仍然很抽象和难以理解。关于JMM我们不妨先放一放，先来了解一下计算机的缓存一致性问题，了解缓存一致性问题将更有利于我们认识Java内存模型。</p><h3 id="1-缓存一致性"><a href="#1-缓存一致性" class="headerlink" title="1.缓存一致性"></a>1.缓存一致性</h3><p>我们知道，一个简单的计算机可以抽象为<strong>CPU</strong>、<strong>内存</strong>以及I/O设备，其中，CPU负责数据的处理与运算，内存则可以理解为存储CPU运算后的数据。CPU在运行时，会首先从内存中取出运算指令，然后解码并确定其类型和操作数，最后执行该指令。在指令执行完毕后，CPU会将计算所得数据写入内存。</p><p>然而，在计算机系统中存在一个CPU的运算速度与内存读写速度不匹配的问题，即CPU的运算速度远比内存的读写速度快。由于读写速度缓慢，严重拖累了计算机的运行效率。为了解决这一问题，现代计算机系统在CPU与内存之间加入了一层或多层<strong>高速缓存</strong>，而高速缓存的读写速度与CPU的运算速度几乎相当。在加入高速缓存后，CPU在执行指令前，需要先将要运算的数据从内存读取（即复制）到高速缓存中，接着CPU对数据进行处理，然后再将运算后的数据写入到高速缓存，最后再从缓存同步回内存中。</p><p>可以看到，基于高速缓存的存储交互很好的解决了单CPU与内存读写速度之间的矛盾。但在多CPU的计算机中却引来了新的问题。由于人们对计算机性能的追求，单CPU已经很难维持“摩尔定律”。目前市面上绝大部分都是多CPU的计算机。在多CPU的系统中，每个处理器都有自己的高速缓存，而它们又共享同一个主内存，如下图。当多个处理器的运算任务都涉及到同一块主内存区域时，将可能导致各自缓存数据不一致的问题。例如，处理器1与处理器2都从主内存读取了同一个数据分别存储到自己的高速缓存区域，然后，两个处理器都对这一数据进行了修改。那么再同步回主内存的时候应该以哪条数据为准呢？这一问题就是<strong>缓存一致性问题</strong></p><p>为了解决缓存一致性问题，设计者们为CPU制定了一个读写协议，并要求各个CPU在读写缓存时都要遵循这一协议。这类协议有MSI、MESI、MOSI等，被称为<strong>缓存一致性协议</strong>。只要CPU的读写遵循了缓存一致性协议就能很好的解决缓存一致性问题了。关于协议的具体实现，不是本篇文章的内容，这里不再赘述。</p><p><img src="https://raw.githubusercontent.com/zhpanvip/images/master/project/article/thread/volatile1.png" alt="0AC13792-79A8-420E-AD8D-F447E9AEC514.png"></p><h3 id="2-Java内存模型（JMM）"><a href="#2-Java内存模型（JMM）" class="headerlink" title="2.Java内存模型（JMM）"></a>2.Java内存模型（JMM）</h3><p>在了解了缓存一致性问题后，我们继续回到jMM。在本章开篇，我们为JMM下了一个比较抽象的定义。并且提到JMM可以简单的理解为线程访问共享变量的方式。可见JMM是Java并发编程的底层基础，想要深入了解并发编程，就需要先理解JMM。那么本节内容，我们就来具体的谈一谈JMM。</p><p><strong>JMM规定所有变量都存储在主内存中，每条线程还有自己的工作内存。线程的工作内存中保存了被线程使用的变量的主内存副本，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存中的数据。不同线程之间也无法直接访问对方的工作内存中的变量，线程间变量值的传递需要通过主内存来完成。</strong> 也就是说Java线程之间的通信采用的是共享内存。</p><p>看到这里是不是觉得似曾相识？没错，这里其实跟上一节<strong>缓存一致性</strong>中讲到的多CPU共享主内存是类似的。只不过在虚拟机中不是CPU，而是线程。每条线程都有自己的工作空间，而共享变量存储在共享内存中。线程在运行时会首先将共享内存中的数据读取到自己的工作内存，即在线程的工作内存中复制了一个共享变量的副本，然后对其进行计算，计算完成后线程会将自己工作内存中的这个共享变量副本同步回主内存。线程、工作内存、与主内存的关系如下图所示：<br><img src="https://raw.githubusercontent.com/zhpanvip/images/master/project/article/thread/volatile2.png" alt="FFC84BBD-0C24-42FE-A38C-99A40F967F72.png"></p><p>到这里，大家对于Java的内存模型应该都有了一个深入的了解。但是，很多同学还是会疑惑Java内存模型和Java的内存区域到底有什么关系？在<a href="https://juejin.cn/post/6868340872698658830">深入JVM–Java运行时内存区域详解</a>这一篇文章中有讲到虚拟机的内存被分为了程序计数器、Java堆、方法区以及虚拟机栈等几个内存区域，而在这几个内存区域中，虚拟机栈是线程所独有的。到这里，我想有些读者心里应该已经有了答案。其实，Java内存模型与Java内存区域并不是同一个层次对内存的划分，可以说两者并没有什么关系。但是它们之间也存在着比较明显的对应关系，即主内存对应Java堆中的实例数据部分，而工作内存则对应虚拟机栈中的一些区域。</p><p>到这里我们已经理清楚了Java内存模型的概念，但是似乎还少了点东西。我们知道多CPU的计算机的存在缓存一致性问题。那么对于Java内存模型来说，多个线程之间是不是也会存在一样的类似问题呢？那对于这一问题，Java又是怎么解决的呢？</p><h2 id="二、volatile关键字"><a href="#二、volatile关键字" class="headerlink" title="二、volatile关键字"></a>二、volatile关键字</h2><p>上一章中我们认识了Java内存模型，并且提出了Java内存模型中也会存在缓存一致性问题。而解决Java内存模型的缓存一致性问题靠的就是本章的主角–volatitle关键字。volatitle关键字是面试中的常客，虽然它的使用却很简单，但真正理解volatile关键字的人并不多。因为要理解volatile关键字，首先要搞懂Java的内存模型。本章内容，就在上章内容的基础上来认识volatile关键字。</p><p>在认识volatile之前，我们先来了解一下Java并发编程的三大性质即：是原子性、可见性以及有序性。</p><ul><li>原子性 原子在化学中反应上是不可在分割的粒子。因此原子性指的是一个不可以被分割的操作，即这个操作在执行过程中不能被中断，要么全部不执行，要么全部执行。且一旦开始执行，不会被其他线程打断。</li><li>可见性 指的是一个线程修改了共享变量后，另外线程能立即感知这个变量被修改。</li><li>有序性 指程序按照代码的先后顺序执行。有时候为了优化性能，编译器会对字节码指令进行重排序。但是能保证重排序后的执行结果与重排序之前是一致的。</li></ul><p>volatitle经常被用到并发编程的场景中。它的作用有两个，即：</p><ul><li>保证可见性；</li><li>保证有序性。</li></ul><p>但是，要注意volatile关键字并不能保证原子性。接下来我们对volatile的两个作用进行详细分析。</p><h3 id="1-volatile保证可见性"><a href="#1-volatile保证可见性" class="headerlink" title="1.volatile保证可见性"></a>1.volatile保证可见性</h3><p>在第一章中我们已经知道，由于每个线程都有自己的工作空间，导致多线程的场景下会出现缓存不一致性的问题。即，当两个线程共用一个共享变量时，如果其中一个线程修改了这个共享变量的值。但是由于另外一个线程在自己的工作内存中已经保留了一份该共享变量的副本，因此它无法感知该变量的值已经被修改。</p><p>看下面的一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VolatileDemo</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> ready;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;MyThread is running...&quot;</span>);<br>            <span class="hljs-keyword">while</span> (!ready) ; <span class="hljs-comment">// 如果ready为false，则死循环</span><br>            System.out.println(<span class="hljs-string">&quot;MyThread is end&quot;</span>);<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-keyword">new</span> MyThread().start();<br>        Thread.sleep(<span class="hljs-number">1000</span>);<br>        ready = <span class="hljs-keyword">true</span>;<br>        System.out.println(<span class="hljs-string">&quot;ready = &quot;</span> + ready);<br>        Thread.sleep(<span class="hljs-number">5000</span>);<br>        System.out.println(<span class="hljs-string">&quot;main thread is end.&quot;</span>);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>代码中定义了一个boolean类型的成员变量ready,其默认值为false。在MyThread线程中判断如果ready为false时则进行死循环。接下来在main方法中开启MyThread线程，并在睡眠1s后将ready修改为true。正常情况下ready修改为true后MyThread线程中的死循环则会停止，并打印“MyThread is end”。但是来看下运行效果跟我们猜想是否一致，打印日志如下：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs applescript">MyThread <span class="hljs-keyword">is</span> <span class="hljs-built_in">running</span>...<br>ready = <span class="hljs-literal">true</span><br>main thread <span class="hljs-keyword">is</span> <span class="hljs-keyword">end</span>.<br></code></pre></td></tr></table></figure><p>可以看见当ready被修改为true后，MyThread线程依然未结束。通过这一例子也证实了MyThread线程中的ready副本并没有得到及时的更新。</p><p>那么接下来我们将成员变量ready使用volatile关键字修饰后，再运行看打印日志：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs applescript">MyThread <span class="hljs-keyword">is</span> <span class="hljs-built_in">running</span>...<br>MyThread <span class="hljs-keyword">is</span> <span class="hljs-keyword">end</span><br>ready = <span class="hljs-literal">true</span><br>main thread <span class="hljs-keyword">is</span> <span class="hljs-keyword">end</span>.<br></code></pre></td></tr></table></figure><p>可见，当在主线程中修改了ready为true后，MyThread线程立即感知了ready的变化，并结束了死循环。从这个例子中也可以看见volatile确实能有效的保证多个线程共享变量的可见性。</p><h3 id="2-volatile保证有序性"><a href="#2-volatile保证有序性" class="headerlink" title="2.volatile保证有序性"></a>2.volatile保证有序性</h3><p>我们知道，编译器为了优化程序性能，可能会在编译时对字节码指令进行重排序。重排序后的指令在单线程中运行时没有问题的，但是如果在多线程中，重排序后的代码则可能会出现问题。因此，一般在多线程并发情况下我们都应该禁止指令重排序的优化。而volatile关键字就可以禁止编译器对字节码进行重排序。volatile保证有序性在我们平时开发中有一个很常见的例子，即双重锁校验的单例模式下需要使用volatile关键字来禁止指令重排序。我们来看下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DoubleCheckLock</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> DoubleCheckLock instance;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">DoubleCheckLock</span><span class="hljs-params">()</span></span>&#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> DoubleCheckLock <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;<br><br>        <span class="hljs-comment">//第一次检测</span><br>        <span class="hljs-keyword">if</span> (instance==<span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-comment">//同步</span><br>            <span class="hljs-keyword">synchronized</span> (DoubleCheckLock.class)&#123;<br>                <span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>)&#123;<br>                    <span class="hljs-comment">//多线程环境下可能会出现问题的地方</span><br>                    instance = <span class="hljs-keyword">new</span> DoubleCheckLock();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>如果上述代码中没有给instance加上volatile关键字会怎么呢？我们不妨来分析一下，首先我们应该清楚instance = new DoubleCheckLock();这一操作并不是一个原子操作，实例化对象的字节指令可以分为三步，如下：</p><ul><li>1.分配对象内存：memory = allocate();</li><li>2.初始化对象：instance(memory);</li><li>3.instance指向刚分配的内存地址：instance = memory;</li></ul><p>而由于编译器的指令重排序，以上指令可能会出现以下顺序：</p><ul><li>1.分配对象内存：memory = allocate();</li><li>2.instance指向刚分配的内存地址：instance = memory;</li><li>3.初始化对象：instance(memory);</li></ul><p>以优化后的字节码指令来看双重锁校验的代码是否有问题呢？不难发现，如果线程1第一次调用单例方法，在该线程的时间片轮转结束后执行到了优化后的第二个指令，即instance被赋值，但是还未被分配初始化对象。此时，线程2抢到了CPU时间片，同时调用了getInstance方法，第一次校验就发现instance不为null，遂将其返回。在得到这个单例后调用单例的方法，此时必定出现空指针异常。</p><p>因此，可见指令重排序在多线程并发的情况下是会出现问题的。此时，我们便可以通过volatile关键字来禁止编译器的优化，从而避免空指针的出现。</p><h3 id="3-volatile不能保证原子性"><a href="#3-volatile不能保证原子性" class="headerlink" title="3.volatile不能保证原子性"></a>3.volatile不能保证原子性</h3><p>对于原子操作，volatile关键字是无能为力的。如果需要保证原子操作，则需要使用synchronized关键字、Lock锁<br>或者Autom相关类来确保操作的原子性。关于这些内容本篇文章不再赘述，将会在后续文章中详细分析。</p><h2 id="参考-amp-推荐阅读"><a href="#参考-amp-推荐阅读" class="headerlink" title="参考&amp;推荐阅读"></a>参考&amp;推荐阅读</h2><p>《深入理解Java虚拟机》第3版，作者周志明</p><p>《现代操作系统》作者Andrews.Tanenbaum/Herber Bos</p><p><a href="https://blog.csdn.net/javazejian/article/details/72772461">全面理解Java内存模型(JMM)及volatile关键字</a></p><p><a href="https://blog.csdn.net/eff666/article/details/66479636">Java内存模型</a></p>]]></content>
    
    
    <categories>
      
      <category>Java进阶</category>
      
    </categories>
    
    
    <tags>
      
      <tag>多线程</tag>
      
      <tag>JMM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>详解Java中的泛型（Generics）</title>
    <link href="/2021/01/16/java-generics/"/>
    <url>/2021/01/16/java-generics/</url>
    
    <content type="html"><![CDATA[<p>Java泛型是在JDK1.5中引进来的一个概念。泛型意为泛化的参数类型，英文为<strong>Generics</strong> ，翻译过来其实就是通用类型的意思。泛型在平时开发中经常用到，例如常用的集合类、Class类等都是JDK给我们提供的泛型类，更多的时候我们还会使用自定义泛型。可见，泛型在Java体系中还是一个很重要的知识。那么，本篇文章我们就来系统的学习一下Java的泛型。</p><h2 id="一、为什么要引入泛型"><a href="#一、为什么要引入泛型" class="headerlink" title="一、为什么要引入泛型"></a>一、为什么要引入泛型</h2><p>上边已经提到，泛型是在JDK 1.5引进来的一个概念。我们知道，现在声明一个List集合是需要指定List的泛型的，指定了List的泛型后，List就只能接受我们指定的类型。而在JDK 1.5之前，由于没有泛型的概念，List集合接受的是一个Object类型。我们知道Object是Java中所有类的父类，那么这也就意味着声明一个List集合后这个集合可以用来存放任意类型的数据。</p><p>举个例子，我们声明一个没有泛型的List集合，并尝试添加不同的数据类型。代码如下：</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml">List list=new ArrayList();</span><br><span class="xml">      list.add(123);</span><br><span class="xml">      list.add(&quot;abc&quot;);</span><br><span class="xml">      list.add(new Object());</span><br><span class="xml">      for (Iterator iterator = list.iterator(); iterator.hasNext();) &#123;</span><br><span class="xml">Object object = (Object) iterator.next();</span><br><span class="xml">       System.out.println(object);</span><br><span class="xml">&#125;</span><br></code></pre></td></tr></table></figure><p>在上边代码中，我们在List的集合种添加了三种不同的数据类型，而这样的写法在IDE中是不会由任何错误提示的。并且可以正常运行程序并打印出数据。</p><blockquote><p>123<br>abc<br>java.lang.Object@4926097b</p></blockquote><p>这样的代码不用想也知道是非常危险的，假设我们期望在集合中存放的是Integer类型，但却在集合中存入了String，那么在使用集合数据的时候把数据都当成Integer处理，程序必然会崩溃。也就是在这样的情况下，为了提高Java语言的安全性以及程序的健壮性，Java在1.5的版本种提供了泛型的支持。有了泛型之后，便可以确保集合中存放的一定是我们所期望的类型。</p><p>修改上面的代码，将List泛型指定为Integer，当我们添加非整数类型的参数时IDE就会提示相应的错误。并且在编译时编译器也会抛出错误致使程序无法编译成字节码文件。如下图所示。</p><p>IDE提示异常：<br><img src="https://raw.githubusercontent.com/zhpanvip/images/master/project/article/generics/1.png" alt="IDE提示类型错误"><br>编译时编译器抛出异常：<br><img src="https://raw.githubusercontent.com/zhpanvip/images/master/project/article/generics/2.png" alt="编译器编译错误"><br>通过这一个例子可以认识到泛型在Java中有着多么重要的意义。当然，泛型的用途远不止这一点，比如我们可以通过自定义的泛型类结合多态来提高程序的可可扩展性等。</p><h2 id="二、泛型基本使用"><a href="#二、泛型基本使用" class="headerlink" title="二、泛型基本使用"></a>二、泛型基本使用</h2><p>既然泛型这么重要，那么先来学习一下泛型的使用。泛型可以定义在类、接口或者方法上。定义的地方不同，泛型的作用域也不同，比如将泛型定义在类上，那么这个泛型可以作用于整个类。而如果将泛型定义在方法上，那么这个泛型的作用域仅限于这个方法。</p><h3 id="1-泛型类"><a href="#1-泛型类" class="headerlink" title="1.泛型类"></a>1.泛型类</h3><p>首先，我们来看如何定义一个泛型类。</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml">public class Response<span class="hljs-tag">&lt;<span class="hljs-name">T</span>&gt;</span> &#123;</span><br><br><span class="xml">private T data;</span><br><br><span class="xml">public T getData() &#123;</span><br><span class="xml">return data;</span><br><span class="xml">&#125;</span><br><br><span class="xml">public void setData(T data) &#123;</span><br><span class="xml">this.data = data;</span><br><span class="xml">&#125;</span><br><br><span class="xml">&#125;</span><br></code></pre></td></tr></table></figure><p>上述代码我们定义了一个Response类，并为其声明了一个泛型参数T。那么在这个Response类中，我们就可以将T作为一个数据类型来使用。比如可将T当作一个成员变量声明在Response中；可以作为方法的返回值类型，也可以作为方法的参数。但是，至于这个T指代的是什么类型，此时还并不能确定，因为这需要我们在使用的时候来自行指定T的类型。</p><p>如下，我们在声明Response的时候将T指定为String类型，那么此时Response中的T就确定了，一定是一个String类型。</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml">Response<span class="hljs-tag">&lt;<span class="hljs-name">String</span>&gt;</span> response = new Response<span class="hljs-tag">&lt;&gt;</span>();</span><br><span class="xml">response.setData(&quot;abc&quot;);</span><br><span class="xml">String data = response.getData();</span><br></code></pre></td></tr></table></figure><p>指定泛型的类型后，我们便可以理所当然的把T当作String进行set和get，且无需再进行类型转换。</p><h3 id="2-泛型接口"><a href="#2-泛型接口" class="headerlink" title="2.泛型接口"></a>2.泛型接口</h3><p>泛型除了可以指定在类上也可以指定在接口上，使用方式和类泛型是一模一样的。</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml">public interface IResponse<span class="hljs-tag">&lt;<span class="hljs-name">T</span>&gt;</span> &#123;</span><br><span class="xml"></span><br><span class="xml">T getData();</span><br><span class="xml"></span><br><span class="xml">void setData(T t);</span><br><span class="xml">&#125;</span><br></code></pre></td></tr></table></figure><p>上边代码中我们定义了一个IResponse的接口，并为其声明了一个泛型，在接口中添加了两个抽象方法，分别将T作为方法的返回值类型，和参数类型。接着我们来看一下泛型接口的实现类：</p><p>假如说实现IResponse接口的类已经确定了泛型的类型。比如，事先我们已经知道返回的类型是一个String。则可有如下代码：</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml">public class StringResponse implements IResponse<span class="hljs-tag">&lt;<span class="hljs-name">String</span>&gt;</span> &#123;</span><br><br><span class="xml">@Override</span><br><span class="xml">public String getData() &#123;</span><br><span class="xml">return null;</span><br><span class="xml">&#125;</span><br><br><span class="xml">@Override</span><br><span class="xml">public void setData(String t) &#123;</span><br><span class="xml"></span><br><span class="xml">&#125;</span><br><br><span class="xml">&#125;</span><br></code></pre></td></tr></table></figure><p>上边代码我们定义了一个StringResponse 类并实现了IResponse接口，而IResponse指定了泛型为String。那么在StringResponse 类中重写getData和setData方法的返回值和参数类型都为String。</p><p>但是，假如我们现在不确定Response的是一个什么类型的数据，那么则可以继续声明一个Response的泛型类，并实现IResponse接口，并将接口的泛型指定为Response的泛型。代码如下：</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml">public class Response<span class="hljs-tag">&lt;<span class="hljs-name">T</span>&gt;</span> implements IResponse<span class="hljs-tag">&lt;<span class="hljs-name">T</span>&gt;</span>&#123;</span><br><br><span class="xml">private T data;</span><br><br><span class="xml">public T getData() &#123;</span><br><span class="xml">return data;</span><br><span class="xml">&#125;</span><br><br><span class="xml">public void setData(T data) &#123;</span><br><span class="xml">this.data = data;</span><br><span class="xml">&#125;</span><br><span class="xml">&#125;</span><br></code></pre></td></tr></table></figure><p>此时的代码其实就是声明了一个Response的泛型类，并将Response的泛型T作为了IResponse的泛型。</p><h3 id="3-泛型方法"><a href="#3-泛型方法" class="headerlink" title="3.泛型方法"></a>3.泛型方法</h3><p>除了在类和接口上可以声明泛型外，在方法上也是可以声明泛型的。前边提到了类和接口的泛型都是作用于整个类的。而在方法上声明泛型，泛型的作用于则只作用于这个方法。我们来看一个例子：</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml">public class Model &#123;</span><br><span class="xml">public <span class="hljs-tag">&lt;<span class="hljs-name">M</span>&gt;</span> void setData(M data) &#123;</span><br><span class="xml">System.out.println(data.toString());</span><br><span class="xml">&#125;</span><br><span class="xml">&#125;</span><br></code></pre></td></tr></table></figure><p>在Model中有一个setData的方法，由于该方法接受的参数类型不确定，因此我们将这个方法定义成了泛型方法。在调用Model的setData方法的时候需要指定这个方法接受的类型。如下：</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml">Model model=new Model();</span><br><span class="xml">model.<span class="hljs-tag">&lt;<span class="hljs-name">String</span>&gt;</span>setData(&quot;string&quot;);</span><br></code></pre></td></tr></table></figure><p>由于在Java8中对于泛型方法的调用做了优化，可以省略指定泛型的类型，直接传入参数即可。</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml">Model model=new Model();</span><br><span class="xml">model.setData(&quot;string&quot;);</span><br></code></pre></td></tr></table></figure><p>当然，这里其实编译器根据我们传入的参数做了类型推断。</p><p>有同学可能会有疑问，那我直接把泛型声明到类上，然后在这个方法中使用不行吗？当然是可以的，其实跟在方法上声明泛型是一样的效果。我们前文也已经提到了，方法上的泛型与类上的泛型只是作用于不同罢了。但是，如果这个泛型参数仅仅只在方法中使用了，我们是没必要把泛型声明到类上去的。</p><h4 id="4-限定泛型的类型"><a href="#4-限定泛型的类型" class="headerlink" title="4.限定泛型的类型"></a>4.限定泛型的类型</h4><p>我们仍以Response的场景为例，假如我希望Response类接受的参数不是任意类型的，而是希望Response接受的数据类型是BaseData或者BaseData的子类。这种情况下我们就需要在指定Response的泛型的时候对泛型参数做一个约束。</p><p>定义一个BaseData类，类中有一个token，如下：</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml">public class BaseData &#123;</span><br><span class="xml">private String token;</span><br><br><span class="xml">public String getToken() &#123;</span><br><span class="xml">return token;</span><br><span class="xml">&#125;</span><br><span class="xml">&#125;</span><br></code></pre></td></tr></table></figure><p>将Response的泛型声明为&lt;T extends BaseData&gt;</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml">public class Response<span class="hljs-tag">&lt;<span class="hljs-name">T</span> <span class="hljs-attr">extends</span> <span class="hljs-attr">BaseData</span>&gt;</span>&#123;</span><br><br><br><span class="xml">private T data;</span><br><br><span class="xml">public String getToken() &#123;</span><br><span class="xml">if(data!=null) &#123;</span><br><span class="xml">return data.getToken();</span><br><span class="xml">&#125;</span><br><span class="xml">return null;</span><br><span class="xml">&#125;</span><br><span class="xml">&#125;</span><br></code></pre></td></tr></table></figure><p>那么此时Response类中的成员变量T就只能是一个BaseData类型，并且T拥有BaseData的方法，如上代码可以直接通过T调用getToken方法。</p><p>接下来，我们来测试一下Response泛型的作用范围，将String作为Response的泛型参数，IDE则会提示mismatch的错误，并且无法通过编译。</p><p><img src="https://raw.githubusercontent.com/zhpanvip/images/master/project/article/generics/3.png" alt="在这里插入图片描述"><br>只有指定Response的泛型为BaseData或者其子类才能正常编译。</p><h3 id="5-泛型与通配符"><a href="#5-泛型与通配符" class="headerlink" title="5.泛型与通配符"></a>5.泛型与通配符</h3><p>Java中的通配符大家应该都不陌生，在Java中可以使用”?”来表示通配符，用来指代未知类型。而通配符与泛型的搭配也是开发中经常用到的。</p><p>众所周知，在Java中Object类是所有类的父类，例如String的顶级父类一定是Object。但是，并不能说List&lt;String&gt;的顶级父类是List&lt;Object&gt;。下面我们来看一个例子：</p><p>有Person、Student和Teacher三个类，它们的继承关系如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//  Person类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br><br>&#125;<br><br><span class="hljs-comment">// Student类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span></span>&#123;<br><br><br>&#125;<br><br><span class="hljs-comment">// Teacher类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Teacher</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span> </span>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>接下来分别实例化出Student与Teacher，并分别赋值给Person，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">Student student = <span class="hljs-keyword">new</span> Student();<br>Teacher teacher = <span class="hljs-keyword">new</span> Teacher();<br><br>Person person;<br>person = student;<br>person = teacher;<br></code></pre></td></tr></table></figure><p>熟悉Java多态的同学都应该知道上边的代码是没有任何错误的。那么再来看下边的代码：<br><img src="https://raw.githubusercontent.com/zhpanvip/images/master/project/article/generics/4.png" alt="在这里插入图片描述"></p><p>上述代码IDE却提示了一个mismatch的错误。但是如果我们就是希望personList能够接受studentList也能够接受teacherList应该怎么办呢？这种情况在现实开发中可是非常常见的。此时，我们就可以用通配符来解决，将personList的泛型修改为&lt;? extends Person&gt;即可，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;? extends Person&gt; personList;<br>List&lt;Student&gt; studentList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>List&lt;Teacher&gt; teacherList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><br>personList = studentList;<br>personList = teacherList;<br></code></pre></td></tr></table></figure><p>另外，我们还可以通过&lt;? super Student&gt;来指定接收Student或者Student的父类，代码如下：<br><img src="https://raw.githubusercontent.com/zhpanvip/images/master/project/article/generics/5.png" alt="在这里插入图片描述"><br>可以看到上述代码中listSuper的泛型声明为了&lt;? super Student&gt;，此时listSuper就只能接收Student以及其父类的集合。所以可以看到，代码中将studentList与personList以及ObjectList正常赋值给listSuper，但是teacherList赋值给listSuper则会报错。</p><h2 id="三、泛型的类型擦除"><a href="#三、泛型的类型擦除" class="headerlink" title="三、泛型的类型擦除"></a>三、泛型的类型擦除</h2><p>到这里关于泛型的基础知识差不多已经讲完了。可以发现，上边讲到的内容都是程序编译前的代码。程序中一旦有不符合规范的代码IDE都会提示错误，并且编译器在编译源代码时就会抛出异常。那接下来要讲的泛型擦除就是代码编译后的知识了。</p><p>前文已经提到，泛型是在JDK1.5中引入的概念，在JDK1.5之前的源码中像List这些泛型类都是使用Object来实现的。那问题来了，JDK1.5版本是否能够兼容JDK1.4或者之前的版本呢？答案是肯定的。之所以能够实现JDK的向下兼容就是因为在编译期间编译器进行了类型擦除。</p><p>我们应该怎么理解类型擦除呢？其实就是编译器在对源代码进行编译的时候将泛型换成了泛型指定的上限类，如果没有指定泛型的上限，编译器则会使用Object类替代。简单的说在编译完成后的字节码文件中其实是没有泛型的概念的，源代码中的泛型被编译器用Object或者泛型指定的类给替换掉了。这也是为什么JDK1.5能够向下兼容的原因。</p><p>我们可以通过javap的反汇编来证明编译期间的类型擦除。定一个Model类，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Model</span> </span>&#123;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>    List&lt;String&gt; list=<span class="hljs-keyword">new</span> ArrayList();<br>    list.add(<span class="hljs-string">&quot;abc&quot;</span>);<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span> </span>&#123;<br>    List list=<span class="hljs-keyword">new</span> ArrayList();<br>    list.add(<span class="hljs-string">&quot;abc&quot;</span>);<br>  &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，这个类中有两个方法，这两个方法不同的地方在于test方法中指定了List的泛型为String，而test2方法中未指定List的泛型。我们先将Model.java通过javac工具编译成Model.class文件，然后通过javap反汇编Model.class文件，得到结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java">$ javap -c Model.class<br>Compiled from <span class="hljs-string">&quot;Model.java&quot;</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">com</span>.<span class="hljs-title">test</span>.<span class="hljs-title">reflection</span>.<span class="hljs-title">Model</span> </span>&#123;<br><span class="hljs-keyword">public</span> com.test.reflection.Model();<br>    Code:<br>    <span class="hljs-number">0</span>: aload_0<br>    1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V<br>    <span class="hljs-number">4</span>: <span class="hljs-keyword">return</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>;<br>    Code:<br>    0: new           #2                  // class java/util/ArrayList<br>    <span class="hljs-number">3</span>: dup<br>    4: invokespecial #3                  // Method java/util/ArrayList.&quot;&lt;init&gt;&quot;:()V<br>    <span class="hljs-number">7</span>: astore_1<br>    <span class="hljs-number">8</span>: aload_1<br>    9: ldc           #4                  // String abc<br>    11: invokeinterface #5,  2            // InterfaceMethod java/util/List.add:(Ljava/lang/Object;)Z<br>    <span class="hljs-number">16</span>: pop<br>    <span class="hljs-number">17</span>: <span class="hljs-keyword">return</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span></span>;<br>    Code:<br>    0: new           #2                  // class java/util/ArrayList<br>    <span class="hljs-number">3</span>: dup<br>    4: invokespecial #3                  // Method java/util/ArrayList.&quot;&lt;init&gt;&quot;:()V<br>    <span class="hljs-number">7</span>: astore_1<br>    <span class="hljs-number">8</span>: aload_1<br>    9: ldc           #4                  // String abc<br>    11: invokeinterface #5,  2            // InterfaceMethod java/util/List.add:(Ljava/lang/Object;)Z<br>    <span class="hljs-number">16</span>: pop<br>    <span class="hljs-number">17</span>: <span class="hljs-keyword">return</span><br>    &#125;<br></code></pre></td></tr></table></figure><p>通过反汇编指令可以看到test1方法与test2方法并无任何区别，并且可以看到第18和30行的注释：</p><blockquote><p>// InterfaceMethod java/util/List.add:(Ljava/lang/Object;)Z</p></blockquote><p>都是向List集合中添加了一个Object对象。</p><p>另外，我们也可以通过反射证实类型擦除的存在。上篇文章<a href="https://blog.csdn.net/qq_20521573/article/details/111751156">《Java进阶–深入理解Java的反射机制》</a>我们学习了Java的反射，知道Class对象是在类加载时候生成的，并且反射是在程序运行时的操作。那我们来通过反射List的Class对象，并尝试添加向List中添加不同的类型看是否能够成功。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list=<span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>  list.add(<span class="hljs-string">&quot;abc&quot;</span>);<br><br>  Class&lt;List&gt; listClass=List.class;<br><br><span class="hljs-keyword">try</span> &#123;<br>          Method addMethod=listClass.getDeclaredMethod(<span class="hljs-string">&quot;add&quot;</span>, Object.class);<br>  addMethod.invoke(list, <span class="hljs-number">123</span>);<br><br>  &#125; <span class="hljs-keyword">catch</span> (NoSuchMethodException | SecurityException|IllegalAccessException<br>  | IllegalArgumentException | InvocationTargetException e) &#123;<br>  e.printStackTrace();<br>  &#125;<br><br>  System.out.println(<span class="hljs-string">&quot;list.size() = &quot;</span>+list.size());<br><br>  <span class="hljs-keyword">for</span> (Object obj : list) &#123;<br>  System.out.println(obj.toString());<br>  &#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">list.size() = <span class="hljs-number">2</span><br>    abc<br>    <span class="hljs-number">123</span><br></code></pre></td></tr></table></figure><p>上述代码我们声明了一个泛型为String的List集合，并向集合中添加了一个字符串“abc”，接着通过反射向集合list中添加了一个整数类型123，通过输出结果可以看到两个值都被添加到了集合中。这一结果也印证了泛型的类型擦除。</p><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>泛型是开发中使用频率非常高的一个技术点，泛型的引入使得Java语言更加安全，也增强程序的健壮性。通过本篇文章我们系统的学习Java的泛型。同时也明白了Java的泛型仅仅是在编译期间由IDE和编译器来进行检查和校验的。在编译后的字节码文件以及运行期间的JVM中是没有泛型的概念的。也正是因为这一原因，其实我们可以通过编辑字节码文件或者在运行时通过反射来绕过泛型的校验，完成代码编写期间不能实现的操作。</p>]]></content>
    
    
    <categories>
      
      <category>Java进阶</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java泛型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入理解Java的反射机制</title>
    <link href="/2021/01/14/36-java-reflection/"/>
    <url>/2021/01/14/36-java-reflection/</url>
    
    <content type="html"><![CDATA[<p>在上篇文章<a href="https://blog.csdn.net/qq_20521573/article/details/109193527">《深入JVM–探索Java虚拟机的类加载机制》</a>中我们深入探讨了JVM的类加载机制。我们知道，在实例化一个类时，如果这个类还没有被虚拟机加载，那么虚拟机会先执行类加载过程，将该类所对应的字节码读取到虚拟机，并生成一个与这个类对应的Class对象。而在类加载的过程中，由于有双亲委派机制的存在，虚拟机保证了同一个类会被同一个类加载器所加载，进而保证了在虚拟机中只存在一个被加载类所对应的Class实例。而这个Class实例与我们今天要讲的反射有着莫大的关系。</p><h2 id="一、Java反射机制概述"><a href="#一、Java反射机制概述" class="headerlink" title="一、Java反射机制概述"></a>一、Java反射机制概述</h2><p>在学习反射之前，我们先来搞清楚几个概念：</p><ul><li>Class类是什么？</li><li>Class对象是什么？</li><li>Class对象与我们的Java类有什么关系？</li></ul><p>假设现在有一个Person类，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.test.reflection;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> age;<br>    <span class="hljs-keyword">public</span> String sex;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Person</span><span class="hljs-params">()</span> </span>&#123;<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>();<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setSex</span><span class="hljs-params">(String sex)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.sex = sex;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testPrivateMethod</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;testPrivateMethod被调用&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>你是否能通过Person类来解释清楚上边提到的三个问题呢？我们不妨接着往下看。</p><h3 id="1-Class类与Class对象"><a href="#1-Class类与Class对象" class="headerlink" title="1.Class类与Class对象"></a>1.Class类与Class对象</h3><p>提到Class类，大家多多少少都应该有些接触，即使你没有使用过反射，也不可避免的接触到Class类。例如，在Android中进行Activity页面跳转的时候，我们需要一个Intent，而实例化Intent则需用到Intent的构造方法，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Intent</span><span class="hljs-params">(Context packageContext, Class&lt;?&gt; cls)</span> </span>&#123;<br>        mComponent = <span class="hljs-keyword">new</span> ComponentName(packageContext, cls);<br>    &#125;<br></code></pre></td></tr></table></figure><p>可以看到，Intent的构造方法中的第二个参数，接受的就是一个Class对象。到这里，我们应该都明白，Class就是JDK为我们提供的一个普普通通的Java类，它跟我们自己定义一个Person类其实并无任何本质上的区别。我们进入Class类的源码可以看到，Class类是一个泛型类，并且它实现了若干个接口，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Class</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span>,</span><br><span class="hljs-class">                              <span class="hljs-title">GenericDeclaration</span>,</span><br><span class="hljs-class">                              <span class="hljs-title">Type</span>,</span><br><span class="hljs-class">                              <span class="hljs-title">AnnotatedElement</span>,</span><br><span class="hljs-class">                              <span class="hljs-title">TypeDescriptor</span>.<span class="hljs-title">OfField</span>&lt;<span class="hljs-title">Class</span>&lt;?&gt;&gt;,</span><br><span class="hljs-class">                              <span class="hljs-title">Constable</span> </span>&#123;<br><span class="hljs-comment">// ...省略主体代码</span><br>&#125;<br></code></pre></td></tr></table></figure><p>既然Class就是一个普普通通的Java类，那在使用它的时候一定需要实例化出来一个Class对象。但奇怪的是，我们在平时写代码的时候好像从来没有通过new关键字来实例化过Class对象？那它到底是在哪里被实例化的呢？了解类加载机制的同学想必应该都清楚，当然，我们在文章开头也已经提到了，Class对象是在类加载的时候由虚拟机自动生成的。</p><p>我们以上边的Person类为例，当我们使用new关键字实例化Person对象的时候，如果Person类的字节码还没有被加载到虚拟机，那么虚拟机首先启动类加载器将Person类的字节码读取到虚拟机中，并为其生成一个Class&lt;Person&gt;的实例，而类加载器的双亲委派模型保证了虚拟机中只会生成一个Class&lt;Person&gt;的实例。而如果在实例化Person对象的时候，Person已经被加载到了虚拟机，则无需再进行Person的类加载过程，直接实例化Person即可。到这里，我们似乎可以感觉到Person对象跟Class&lt;Person&gt;一定存在着某种关系。我们接着往下看。</p><h3 id="2-Person类与Class-lt-Person-gt-对象的关系"><a href="#2-Person类与Class-lt-Person-gt-对象的关系" class="headerlink" title="2.Person类与Class&lt;Person&gt;对象的关系"></a>2.Person类与Class&lt;Person&gt;对象的关系</h3><p>现在，我们回想一下我们在进行Activity页面跳转的时候Intent构造方法的第二个参数传的是什么呢？是不是像下边这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Intent intent=<span class="hljs-keyword">new</span> Intent(<span class="hljs-keyword">this</span>,MainActivity.class);<br></code></pre></td></tr></table></figure><p>通过MainActivity.class我们可以得到MainActivity对应的Class对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Class&lt;MainActivity&gt; mainActivityClass = MainActivity.class;<br></code></pre></td></tr></table></figure><p>而mainActivityClass 对象就是虚拟机在加载MainActivity的时候生成的，并且虚拟机保证了mainActivityClass在虚拟机中是唯一的。<br>这一过程对于Person类也是一样的，我们可以通过Person .class来拿到虚拟机中唯一的一个Class&lt;Person&gt;实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Class&lt;Person&gt; personClass=Person.class;<br></code></pre></td></tr></table></figure><p>另外，我们还可以通过Person 的实例对象来获得Class&lt;Person&gt;对象，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Person person=<span class="hljs-keyword">new</span> Person();<br>Class&lt;Person&gt; personClass=(Class&lt;Person&gt;)person.getClass();<br></code></pre></td></tr></table></figure><p>当然，除了上述两种方法之外，我们还可以通过Person类的包名来获得Class&lt;Person&gt;的实例，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>Class&lt;Person&gt; personClass=(Class&lt;Person&gt;)Class.forName(<span class="hljs-string">&quot;com.test.reflection&quot;</span>);<br>&#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure><p>由于Class&lt;Person &gt;对象在虚拟机中是唯一的，那么上述三种方法获取到的Class&lt;Person &gt;一定是同一个实例。</p><h2 id="二、什么是反射？"><a href="#二、什么是反射？" class="headerlink" title="二、什么是反射？"></a>二、什么是反射？</h2><p>好了，上边啰嗦了这么多，终于到了正题了。那到底什么是反射呢？我们来看下百度百科给出的定义：</p><blockquote><p>Java的反射（reflection）机制是指在程序的运行状态中，可以构造任意一个类的对象，可以了解任意一个对象所属的类，可以了解任意一个类的成员变量和方法，可以调用任意一个对象的属性和方法。这种动态获取程序信息以及动态调用对象的功能称为Java语言的反射机制。</p></blockquote><p>虽然上述定义对反射的描述已经非常清楚。但是对于没有了解过反射的同学来说看了之后可能还是一头雾水。下面，在第一章的基础上来说下我来说下我对反射的理解：</p><p><strong>在Java中，所有已经被虚拟机的类加载器加载过的类（称为T）都会在虚拟机中生成一个唯一的与T类所对应的Class&lt;T&gt;对象。在程序运行时，通过这个Class&lt;T&gt;对象，我们可以实例化出来一个T对象；可以通过Class&lt;T&gt;对象访问T对象中的任意成员变量，调用T对象中的任意方法，甚至可以对T对象中的成员变量进行修改。我们将这一系列操作称为Java的反射机制。</strong></p><p>到这里我们发现，其实Java的反射也没有那么神秘了。说白了就是通过Class对象来操控我们的对象罢了。因此，接下来我们想要弄懂反射只需要来详细的认识一下Class这个类给我们提供的API即可。</p><h3 id="1-Java反射相关类"><a href="#1-Java反射相关类" class="headerlink" title="1.Java反射相关类"></a>1.Java反射相关类</h3><p>我们知道，一个Java类可以包含成员变量、构造方法、以及普通方法。同时，我们又知道Java是一种很纯粹的面向对象的语言。在Java语言中，万物皆对象，类的成员变量、构造方法以及普通方法在Java中也被封装成了对象。它们分别对应Field类、Constructor类以及Method类。这几个类与反射息息相关。因此，在开始之前，我们需要先了解下这几个与反射相关的类，如下图：<br><img src="https://raw.githubusercontent.com/zhpanvip/images/master/project/article/reflection/1.jpg" alt="在这里插入图片描述"></p><ul><li><strong>Field 类</strong>：位于Java.lang.reflect包下，在Java反射中Field用于获取某个类的属性或该属性的属性值。</li><li><strong>Constructor 类：</strong> 位于java.lang.reflect包下，它代表某个类的构造方法，用来管理所有的构造函数的类。</li><li><strong>Method 类：</strong> 位于java.lang.reflect包下,在Java反射中Method类描述的是类的方法信息（包括：方法修饰符、方法名称、参数列表等等）。</li><li><strong>Class 类：</strong> Class类在上文我们已经多次提到，它表示正在运行的 Java 应用程序中的类的实例。</li><li><strong>Object 类：</strong> Object类大家应该都比较熟悉了。它是所有 Java 类的父类。所有对象都默认实现了 Object 类的方法。在Object对象中，可以通过getClass()来获得该类对应的Class实例。</li></ul><h3 id="2-Java反射常用API"><a href="#2-Java反射常用API" class="headerlink" title="2.Java反射常用API"></a>2.Java反射常用API</h3><p>通过上文我们已经知道，所谓的反射，其实就是通过API操作Class对象。因此，在进行反射操作的第一步我们应该首先拿到Class的实例。在第一种中我们已经知道可以通过三种方式来获得Class的实例。以获取Person类的Class对象为例，三种方法分别如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 通过类的class获得Class实例</span><br>Class&lt;Person&gt; personClass=Person.class;<br><span class="hljs-comment">// 通过类的包名获得Class实例</span><br>Class&lt;Person&gt; personClass=(Class&lt;Person&gt;)Class.forName(<span class="hljs-string">&quot;com.test.reflection&quot;</span>);<br><span class="hljs-comment">// 通过对象获得Class实例</span><br>Person person=<span class="hljs-keyword">new</span> Person();<br>Class&lt;Person&gt; personClass=(Class&lt;Person&gt;)person.getClass();<br></code></pre></td></tr></table></figure><p>在拿到Person类的Class实例后，我们就可以通过Class实例获取到Person类中的任意成员，包括构造方法、普通方法、成员变量等。</p><h4 id="2-1获取所有构造方法"><a href="#2-1获取所有构造方法" class="headerlink" title="2.1获取所有构造方法"></a>2.1获取所有构造方法</h4><p> Class类中为我们提供了两个获取构造方法的API，这两个方法如下：</p><ul><li>Constructor[] getDeclaredConstructors() 用于获取当前类中所有构造方法。但不包括包括父类中的构造方法。</li><li>Constructor[]  getConstructors()  用于获取本类中所有public修饰的构造方法,不包括父类的构造方法。</li></ul><p><strong>（1）getDeclaredConstructors()</strong> </p><p>以Person类为例，我们来先来尝试getDeclaredConstructors方法的使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Class&lt;Person&gt; personClass=Person.class;<br>Constructor[] declaredConstructors= personClass.getDeclaredConstructors();<br><span class="hljs-keyword">for</span>(Constructor declaredConstructor:declaredConstructors) &#123;<br>System.out.println(declaredConstructor);<br>&#125;<br></code></pre></td></tr></table></figure><p>注意，我们在Person类中声明了两个构造方法，其中无参构造方法是一个私有的构造方法。我们来看下上述代码的打印结果：</p><blockquote><p>private com.test.reflection.Person()<br>public com.test.reflection.Person(java.lang.String,int)</p></blockquote><p>可以看到，getDeclaredConstructors方法可以获取到类中包括私有构造方法在内的所有构造方法。</p><p><strong>（2） getConstructors()</strong>  </p><p>接着我们将getDeclaredConstructors()方法换成getConstructors()方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Class&lt;Person&gt; personClass=Person.class;<br>Constructor[] declaredConstructors= personClass.getConstructors();<br><span class="hljs-keyword">for</span>(Constructor declaredConstructor:declaredConstructors) &#123;<br>System.out.println(declaredConstructor);<br>&#125;<br></code></pre></td></tr></table></figure><p>再来看输出结果：</p><blockquote><p>public com.test.reflection.Person(java.lang.String,int)</p></blockquote><p>此时，只有被声明了public的方法被打印了出来。</p><h4 id="2-2-获取指定构造方法"><a href="#2-2-获取指定构造方法" class="headerlink" title="2.2 获取指定构造方法"></a>2.2 获取指定构造方法</h4><p>在Class中同样提供了两个获取指定构造方法的API，如下：</p><ul><li>Constructor<T> getDeclaredConstructor(Class&lt;?&gt;… parameterTypes)  该方法用来获取类中任意的构造方法，包括private修饰的构造方法。无法通过该方法获取到父类的构造方法。</li><li>Constructor<T> getConstructor(Class&lt;?&gt;… parameterTypes)  该方法只能用来获取该类中public的构造方法。无法获取父类中的构造方法。</li></ul><p>我们可以尝试使用getDeclaredConstructor方法来获取Person的私有构造方法与public的有参构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>     Constructor&lt;Person&gt; declaredConstructor = personClass.getDeclaredConstructor();<br>     Constructor&lt;Person&gt; declaredConstructor2 = personClass.getDeclaredConstructor(String.class,<span class="hljs-keyword">int</span>.class);<br> &#125; <span class="hljs-keyword">catch</span> (NoSuchMethodException e) &#123;<br>     e.printStackTrace();<br> &#125;<br></code></pre></td></tr></table></figure><p>而如果使用getConstructor获取私有方法，则会抛出java.lang.NoSuchMethodException。</p><h4 id="2-3-使用反射实例化对象"><a href="#2-3-使用反射实例化对象" class="headerlink" title="2.3 使用反射实例化对象"></a>2.3 使用反射实例化对象</h4><p>通过反射实例化对象有多种途径，可以使用Class的newInstance方法，同时也可以使用Constructor类。</p><ul><li>通过Class的newInstance实例化Person</li><li>使用Constructor实例化对象</li></ul><p><strong>（1）通过Class的newInstance实例化对象</strong><br>这种方式使用起来非常简单，直接调用newInstance方法即可完成对象的实例化。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">Class&lt;Person&gt; personClass = Person.class;<br>      <span class="hljs-keyword">try</span> &#123;<br>          Person person = personClass.newInstance();<br>      &#125; <span class="hljs-keyword">catch</span> (IllegalAccessException | InstantiationException e) &#123;<br>          e.printStackTrace();<br>      &#125;<br></code></pre></td></tr></table></figure><p>但是，通过这一方法有一定的局限性。即只能实例化无参构造方法的类，同时这个无参构造方法不能使用private修饰。否则会抛出异常。这个方法在Java 9中已经被声明为Deprecated，并且推荐使用Constructor来实例化对象。</p><p><strong>（2） 使用Constructor实例化对象</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>           Constructor&lt;Person&gt; declaredConstructor = personClass.getDeclaredConstructor(String.class, <span class="hljs-keyword">int</span>.class);<br>           Person ryan = declaredConstructor.newInstance(<span class="hljs-string">&quot;Ryan&quot;</span>, <span class="hljs-number">18</span>);<br>           System.out.println(ryan.getName() + <span class="hljs-string">&quot;---&quot;</span> + ryan.getAge());<br>       &#125; <span class="hljs-keyword">catch</span> (NoSuchMethodException | InvocationTargetException<br>               | InstantiationException | IllegalAccessException e) &#123;<br>           e.printStackTrace();<br>       &#125;<br></code></pre></td></tr></table></figure><p>如上代码，我们通过Person的有参Constructor实例化出来一个Person类，并输出如下结果：</p><blockquote><p>Ryan—18</p></blockquote><p>而通过Constructor实例化私有的构造方法时，需要通过Constructor的setAccessible(true)来使Constructor可见，进而进行实例化。否则则会抛出IllegalAccessException异常。实例化私有构造方法的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>           Constructor&lt;Person&gt; declaredConstructor = personClass.getDeclaredConstructor();<br>           declaredConstructor.setAccessible(<span class="hljs-keyword">true</span>);<br>           Person ryan = declaredConstructor.newInstance();<br>       &#125; <span class="hljs-keyword">catch</span> (NoSuchMethodException | InvocationTargetException<br>               | InstantiationException | IllegalAccessException e) &#123;<br>           e.printStackTrace();<br>       &#125;<br></code></pre></td></tr></table></figure><h4 id="2-4-使用反射获取类的所有成员变量"><a href="#2-4-使用反射获取类的所有成员变量" class="headerlink" title="2.4 使用反射获取类的所有成员变量"></a>2.4 使用反射获取类的所有成员变量</h4><p>Class同样提供了两方法来获取类的成员变量，分别如下：</p><ul><li>getDeclaredFields()  获取该类中所有成员变量，无法获取到从父类中继承的成员变量。</li><li>getFields()  获取类中所有public的成员变量，包括从父类中继承的public的成员变量。</li></ul><p>（1）首先通过getDeclaredFields()来获取Person的成员变量，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Class&lt;Person&gt; personClass = Person.class;<br>      Field[] declaredFields = personClass.getDeclaredFields();<br>      <span class="hljs-keyword">for</span> (Field field : declaredFields) &#123;<br>          System.out.println(field.toString());<br>      &#125;<br></code></pre></td></tr></table></figure><p>输出结果为：</p><blockquote><p>private java.lang.String com.test.reflection.Person.name<br>protected int com.test.reflection.Person.age<br>public java.lang.String com.test.reflection.Person.sex</p></blockquote><p>可以看到，无论时private修饰的成员变量还是public修饰的成员变量都通过getDeclaredFields获取到。<br>（2）接着来看getFields()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Class&lt;Person&gt; personClass = Person.class;<br>      Field[] fields = personClass.getFields();<br>      <span class="hljs-keyword">for</span> (Field field : fields) &#123;<br>          System.out.println(field.toString());<br>      &#125;<br></code></pre></td></tr></table></figure><p>输出结果为：</p><blockquote><p>public java.lang.String com.test.reflection.Person.sex</p></blockquote><p>可以看到，通过getFields方法只获取到了Person类中public的成员变量。</p><h4 id="2-5-反射获取并修改类的成员变量"><a href="#2-5-反射获取并修改类的成员变量" class="headerlink" title="2.5 反射获取并修改类的成员变量"></a>2.5 反射获取并修改类的成员变量</h4><p>可以通过getDeclaredField方法与getField获取类中从成员变量，区别如下：</p><ul><li>getDeclaredField(String) 获取该类任意修饰符的成员变量，但不包括从父类中继承的成员变量。</li><li>getField(String) 获取该类任意public修饰的成员变量，包括从父类中继承的public的成员变量。</li></ul><p>获取Person类的私有成员变量，并通过反射来修改Person对象中的私有变量name,代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java">Class&lt;Person&gt; personClass = Person.class;<br>Person person = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;Ryan&quot;</span>, <span class="hljs-number">18</span>);<br><span class="hljs-keyword">try</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;反射修改前name为:&quot;</span> + person.getName());<br>    <span class="hljs-comment">// 获取Person中的私有成员变量name</span><br>    Field name = personClass.getDeclaredField(<span class="hljs-string">&quot;name&quot;</span>);<br>    <span class="hljs-comment">// 将name设置为可见</span><br>    name.setAccessible(<span class="hljs-keyword">true</span>);<br>    <span class="hljs-comment">// 修改person实例中name的值</span><br>    name.set(person, <span class="hljs-string">&quot;Helen&quot;</span>);<br>    System.out.println(<span class="hljs-string">&quot;反射修改后name为:&quot;</span> + person.getName());<br>&#125; <span class="hljs-keyword">catch</span> (NoSuchFieldException e) &#123;<br>    e.printStackTrace();<br>&#125; <span class="hljs-keyword">catch</span> (IllegalAccessException e) &#123;<br>    e.printStackTrace();<br>&#125;<br><br></code></pre></td></tr></table></figure><p>输出结果如下：</p><blockquote><p>反射修改前name为:Ryan<br>反射修改后name为:Helen</p></blockquote><h4 id="2-6-反射获取类中的所有方法"><a href="#2-6-反射获取类中的所有方法" class="headerlink" title="2.6 反射获取类中的所有方法"></a>2.6 反射获取类中的所有方法</h4><ul><li>getDeclaredMethods() 获取本类中所有方法，不包括从父类中继承的方法。</li><li>getMethods()  获取类中所有public方法，包括从父类中继承的public方法。</li></ul><p><strong>（1）getDeclaredMethods()</strong> </p><p>通过getDeclaredMethods获取Person中的所有方法（不包括父类）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">Class&lt;Person&gt; personClass = Person.class;<br><span class="hljs-comment">// 获取类中的所有方法，包括私有方法，但不包括父类中的方法。</span><br>Method[] declaredMethods = personClass.getDeclaredMethods();<br><span class="hljs-comment">// 遍历并打印方法信息</span><br><span class="hljs-keyword">for</span> (Method method :declaredMethods) &#123;<br>    System.out.println(<span class="hljs-string">&quot;getDeclaredMethods:&quot;</span>+method.toString());<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果如下：</p><blockquote><p>getDeclaredMethods:public java.lang.String com.test.reflection.Person.getName()<br>getDeclaredMethods:public int com.test.reflection.Person.getAge()<br>getDeclaredMethods:private void com.test.reflection.Person.testPrivateMethod()</p></blockquote><p><strong>（2）getMethods</strong></p><p>通过getMethods获取Person中的所有public方法（包括父类）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">Class&lt;Person&gt; personClass = Person.class;<br><span class="hljs-comment">//获取Person类中的所有方法，包括父类的方法</span><br>Method[] methods = personClass.getMethods();<br><span class="hljs-comment">// 遍历methods并打印方法信息</span><br><span class="hljs-keyword">for</span> (Method method : methods) &#123;<br>    System.out.println(<span class="hljs-string">&quot;getMethods:&quot;</span>+method.toString());<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果如下：</p><blockquote><p>getMethods:public java.lang.String com.test.reflection.Person.getName()<br>getMethods:public int com.test.reflection.Person.getAge()<br>getMethods:public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException<br>getMethods:public final void java.lang.Object.wait() throws java.lang.InterruptedException<br>getMethods:public final native void java.lang.Object.wait(long) throws java.lang.InterruptedException<br>getMethods:public boolean java.lang.Object.equals(java.lang.Object)<br>getMethods:public java.lang.String java.lang.Object.toString()<br>getMethods:public native int java.lang.Object.hashCode()<br>getMethods:public final native java.lang.Class java.lang.Object.getClass()<br>getMethods:public final native void java.lang.Object.notify()<br>getMethods:public final native void java.lang.Object.notifyAll()</p></blockquote><h4 id="2-7-使用反射调用对象的方法"><a href="#2-7-使用反射调用对象的方法" class="headerlink" title="2.7 使用反射调用对象的方法"></a>2.7 使用反射调用对象的方法</h4><p><strong>(1) 反射调用对象的私有方法</strong></p><p>通过反射调用Person类中的私有方法testPrivateMethod，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// 获取Person类中的私有方法testPrivateMethod</span><br>    Method testPrivateMethod = personClass.getDeclaredMethod(<span class="hljs-string">&quot;testPrivateMethod&quot;</span>);<br>    <span class="hljs-comment">// 将testPrivateMethod方法设置为可见</span><br>    testPrivateMethod.setAccessible(<span class="hljs-keyword">true</span>);<br>    <span class="hljs-comment">// 反射调用testPrivateMethod方法</span><br>    testPrivateMethod.invoke(person);<br>&#125; <span class="hljs-keyword">catch</span> (NoSuchMethodException e) &#123;<br>    e.printStackTrace();<br>&#125; <span class="hljs-keyword">catch</span> (IllegalAccessException e) &#123;<br>    e.printStackTrace();<br>&#125; <span class="hljs-keyword">catch</span> (InvocationTargetException e) &#123;<br>    e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果为：</p><blockquote><p>testPrivateMethod被调用</p></blockquote><h2 id="三、关于反射的一些问题"><a href="#三、关于反射的一些问题" class="headerlink" title="三、关于反射的一些问题"></a>三、关于反射的一些问题</h2><h3 id="1-是否可以通过反射修改final类型的成员变量？"><a href="#1-是否可以通过反射修改final类型的成员变量？" class="headerlink" title="1.是否可以通过反射修改final类型的成员变量？"></a>1.是否可以通过反射修改final类型的成员变量？</h3><p>在写Java代码的时候，如果我们将一个成员变量声明为了final类型，那么就必须在声明时候或者在构造方法中为其赋初始值，否则程序是无法编译通过的。那我们是否可以通过反射来修改final类型的成员变量呢？不妨来尝试一下。我们将Person中的sex改为private与final修饰，并为其赋初始值为“male”。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String sex =<span class="hljs-string">&quot;male&quot;</span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getSex</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> sex;<br>    &#125;<br><span class="hljs-comment">// ...省略其它代码</span><br>&#125;<br></code></pre></td></tr></table></figure><p>下面通过反射来尝试将sex的值修改为”female”，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">Class&lt;Person&gt; personClass = Person.class;<br>      Person person = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;Ryan&quot;</span>, <span class="hljs-number">18</span>);<br>      <span class="hljs-keyword">try</span> &#123;<br>          Field sex = personClass.getDeclaredField(<span class="hljs-string">&quot;sex&quot;</span>);<br>          System.out.println(<span class="hljs-string">&quot;修改性别前：&quot;</span> + person.getSex());<br>          sex.set(person, <span class="hljs-string">&quot;female&quot;</span>);<br>          System.out.println(<span class="hljs-string">&quot;修改性别后：&quot;</span> + person.getSex());<br>      &#125; <span class="hljs-keyword">catch</span> (NoSuchFieldException e) &#123;<br>          e.printStackTrace();<br>      &#125; <span class="hljs-keyword">catch</span> (IllegalAccessException e) &#123;<br>          e.printStackTrace();<br>      &#125;<br></code></pre></td></tr></table></figure><p>运行之后程序并未报错，输出结果如下：</p><blockquote><p>修改性别前：male<br>修改性别后：male</p></blockquote><p>可以看到，我们通过反射并没有成功修改sex的值，这意味着final修饰的成员变量无法通过反射修改吗？这倒未必。我们接着来看下边的代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Object mObject = <span class="hljs-keyword">new</span> Object();<br><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getObject</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> mObject ;<br>    &#125;<br><span class="hljs-comment">// ...省略其它代码</span><br>&#125;<br></code></pre></td></tr></table></figure><p>我们在Person中添加一个Object的成员变量，并将其声明为private final。接下来仍然通过反射来尝试修改mObject的值。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java">Class&lt;Person&gt; personClass = Person.class;<br>        Person person = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;Ryan&quot;</span>, <span class="hljs-number">18</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            Field object = personClass.getDeclaredField(<span class="hljs-string">&quot;mObject&quot;</span>);<br>            System.out.println(<span class="hljs-string">&quot;修改Object前：&quot;</span> + person.getObject().toString());<br>            Object newObject = <span class="hljs-keyword">new</span> Object();<br>            System.out.println(<span class="hljs-string">&quot;newObject：&quot;</span> + newObject.toString());<br>            object.setAccessible(<span class="hljs-keyword">true</span>);<br>            object.set(person, newObject);<br>            System.out.println(<span class="hljs-string">&quot;修改Object后：&quot;</span> + person.getObject().toString());<br>        &#125; <span class="hljs-keyword">catch</span> (NoSuchFieldException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">catch</span> (IllegalAccessException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br></code></pre></td></tr></table></figure><p>输出结果如下：</p><blockquote><p>修改Object前：java.lang.Object@4926097b<br>newObject：java.lang.Object@762efe5d<br>修改Object后：java.lang.Object@762efe5d</p></blockquote><p>有没有很奇怪？上边的String通过反射修改没有成功，而将代码换成Object之后，同样的代码，Object的成员变量却被修改成功了，这是怎么回事呢？其实，了解Java编译的同学应该比较清楚。编译器在编译Java文件的时候会将final修饰的基本类型和String优化为一个常量。我们来看下反编译后的class文件就明白了。我们将Person编译的class文件在AS中打开，如下图：<br><img src="https://raw.githubusercontent.com/zhpanvip/images/master/project/article/reflection/2.png" alt="在这里插入图片描述"></p><p>可以清楚的看到在class文件中getSex方法返回的是一个“male”字面量，而getObject返回的却是mObject。所以，即使通过代码将final修饰的String类型修改成功，在get的时候由于编译器的优化无法拿到修改后的值。</p><p>通过上边的例子<strong>可以确定通过反射是能够修改final修饰的成员变量的。只是如果该成员变量是基本数据类型或者String类型会被编译器优化成字面量，从而无法获得修改后的值。</strong></p><h3 id="2-为什么说反射会影响程序性能？"><a href="#2-为什么说反射会影响程序性能？" class="headerlink" title="2.为什么说反射会影响程序性能？"></a>2.为什么说反射会影响程序性能？</h3><p>在项目开发中，我们在能不使用反射的情况下就不使用反射，因为反射会影响程序的性能。这是我们大家都熟知的。但是你知道为什么说反射会影响程序的性能吗？要解开这一个问题就需要我们深入反射的源码来查看反射过程中都做了什么操作。由于这块内容比较庞大，限于篇幅，关于反射影响性能的问题将在下一篇文章中详细分析。敬请期待。</p>]]></content>
    
    
    <categories>
      
      <category>Java进阶</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java反射</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>这可能是ViewPager2滑动冲突最全处理方案</title>
    <link href="/2020/12/29/35.viewpager2-swiping-conflict/"/>
    <url>/2020/12/29/35.viewpager2-swiping-conflict/</url>
    
    <content type="html"><![CDATA[<p>自去年12月份ViewPager2正式版发布以后，ViewPager2已经逐渐开始替代旧版本的ViewPager。许多开发者也已经在项目中使用了ViewPager2。相比ViewPager，ViewPager2的功能不可谓不强大，我在之前写过的一篇文章<a href="https://zhangpan.site/2019/12/14/24.Know%20about%20ViewPager2/">《学不动也要学！深入了解ViewPager2 》</a>中对ViewPager2的使用做过详细的讲解。但是，由于当时没有太多实战，所以并没有发现ViewPager2的嵌套使用存在严重的滑动冲突。直到今年三月份用ViewPager2重构<a href="https://github.com/zhpanvip/BannerViewPager">BannerViewPager</a>的时候才发现这个问题。因此，在BVP 3.0版本中额外对ViewPager2做了滑动冲突处理，效果还算差强人意。另外，曾在论坛上看到过不少ViewPager2滑动冲突的求助帖子，甚至还有同学因为搜索ViewPager2滑动冲突而找到了<a href="https://github.com/zhpanvip/BannerViewPager">BannerViewPager</a>的Github主页。既然如此，不如写篇文章将BVP处理滑动冲突的经验分享给大家，没准还能涨知 <strong>(fěn)</strong> 识 **(sī)**，嘿嘿嘿。<br><img src="https://raw.githubusercontent.com/zhpanvip/images/master/project/article/3501.webp" alt="在这里插入图片描述"></p><h2 id="一、为什么ViewPager没有滑动冲突？"><a href="#一、为什么ViewPager没有滑动冲突？" class="headerlink" title="一、为什么ViewPager没有滑动冲突？"></a>一、为什么ViewPager没有滑动冲突？</h2><p>不知道你是否有这个疑问，在ViewPager时代，ViewPager嵌套ViewPager并没有出现过滑动冲突。可是为什么在ViewPager的升级版ViewPager2中却出现了滑动冲突呢？想要搞清楚这个问题就需要我们深入到ViewPager和ViewPager2的内部分析一下它们的源码了。</p><p>我们知道，滑动冲突是需要在onInterceptTouchEvent方法中进行处理的，根据自身条件来决定是否要拦截事件。在ViewPager的源码中看到以下代码(方便阅读，代码做了删减)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">onInterceptTouchEvent</span><span class="hljs-params">(MotionEvent ev)</span> </span>&#123;<br><br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> action = ev.getAction() &amp; MotionEvent.ACTION_MASK;<br>        <span class="hljs-keyword">if</span> (action == MotionEvent.ACTION_CANCEL || action == MotionEvent.ACTION_UP) &#123;<br>        <span class="hljs-comment">// 在事件取消或者抬起手指后重置状态</span><br>            resetTouch();<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br><br><br>        <span class="hljs-keyword">switch</span> (action) &#123;<br>            <span class="hljs-keyword">case</span> MotionEvent.ACTION_MOVE: &#123;<br>                <span class="hljs-comment">// 这里判断在水平方向上的滑动距离大于竖直方向的2倍，则认为是有效的切换页面的滑动</span><br>                <span class="hljs-keyword">if</span> (xDiff &gt; mTouchSlop &amp;&amp; xDiff * <span class="hljs-number">0.5f</span> &gt; yDiff) &#123; <br>                    mIsBeingDragged = <span class="hljs-keyword">true</span>;<br>                    <span class="hljs-comment">// 禁止Parent View拦截事件，即事件要能够传递到ViewPager</span><br>                    requestParentDisallowInterceptTouchEvent(<span class="hljs-keyword">true</span>);<br>                    setScrollState(SCROLL_STATE_DRAGGING);<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (yDiff &gt; mTouchSlop) &#123;<br>                    mIsUnableToDrag = <span class="hljs-keyword">true</span>;<br>                &#125;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">case</span> MotionEvent.ACTION_DOWN: &#123;     <br>                <span class="hljs-keyword">if</span> (mScrollState == SCROLL_STATE_SETTLING<br>                        &amp;&amp; Math.abs(mScroller.getFinalX() - mScroller.getCurrX()) &gt; mCloseEnough) &#123;<br>               <span class="hljs-comment">// 在Down事件中禁止Parent View拦截事件，是为了事件序列能够传递到ViewPager</span><br>                    requestParentDisallowInterceptTouchEvent(<span class="hljs-keyword">true</span>);<br>                    setScrollState(SCROLL_STATE_DRAGGING);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    completeScroll(<span class="hljs-keyword">false</span>);<br>                    mIsBeingDragged = <span class="hljs-keyword">false</span>;<br>                &#125;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">case</span> MotionEvent.ACTION_POINTER_UP:<br>                onSecondaryPointerUp(ev);<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> mIsBeingDragged;<br>    &#125;<br></code></pre></td></tr></table></figure><p>可以看到在ACTION_DOWN与ACTION_MOVE中根据一些判断条件调用了requestParentDisallowInterceptTouchEvent(true)方法来禁止Parent View拦截事件，也就是说ViewPager已经帮我们处理了滑动冲突，所以我们只管用即可，无需担心滑动冲突问题。</p><p>现在，我们转到ViewPager2中，翻阅源码发现只有在RecyclerView 的实现类中有onInterceptTouchEvent的相关方法，而且这句代码仅仅是处理禁用了用户输入的逻辑！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RecyclerViewImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RecyclerView</span> </span>&#123;<br><br>        .... <span class="hljs-comment">// 省略部分代码</span><br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">onInterceptTouchEvent</span><span class="hljs-params">(MotionEvent ev)</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> isUserInputEnabled() &amp;&amp; <span class="hljs-keyword">super</span>.onInterceptTouchEvent(ev);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>也就是说ViewPager2其实并没有帮我们处理滑动冲突！这是为什么呢？难道是ViewPager2的开发者们把这件事忘了？这里我敢保证肯定不是这样子的。其实，只要我们看一看ViewPager2的结构大概就能知道了。ViewPager2被声明了final，意味着我们不能像继承ViewPager一样来修改ViewPager2。如果官方在ViewPager2内部自行处理了滑动冲突，那么如果有特殊的需求，需要根据我们自己的情况来处理ViewPager2的滑动，那么官方写的处理滑动冲突的代码是不是会影响到我们自己的需求？所以我觉得也正因为这样，干脆不做任何处理，全权交给了开发者自行解决。</p><h2 id="二、滑动冲突的处理方案"><a href="#二、滑动冲突的处理方案" class="headerlink" title="二、滑动冲突的处理方案"></a>二、滑动冲突的处理方案</h2><p>既然官方不给我们处理，那就需要我们自己动手了。在开始之前我们先来了解以下处理滑动冲突的两种方案。既然出现滑动冲突，那么一定是由于两个布局相互嵌套引起的 。既然是两个布局，那么我们就可以分为两个方向来处理。即所谓的<strong>外部拦截法</strong>和<strong>内部拦截法</strong>。</p><h3 id="1-外部拦截法"><a href="#1-外部拦截法" class="headerlink" title="1.外部拦截法"></a>1.外部拦截法</h3><p>所谓的“外部拦截法“中的外部是指出现滑动冲突的这两个布局的外层。我们知道，一个事件序列是由Parent View先获取到的，如果Parent View不拦截事件那么才会交由子View去处理。既然是外层先获知事件，那外层View根据自身情况来决定是否要拦截事件不就行了吗？因此外部拦截法的实现是非常简单的，大概思路如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">onInterceptTouchEvent</span><span class="hljs-params">(MotionEvent event)</span> </span>&#123;<br>        <span class="hljs-keyword">boolean</span> intercepted = <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">int</span> x = (<span class="hljs-keyword">int</span>) event.getX();<br>        <span class="hljs-keyword">int</span> y = (<span class="hljs-keyword">int</span>) event.getY();<br>        <span class="hljs-keyword">switch</span> (event.getAction()) &#123;<br>            <span class="hljs-keyword">case</span> MotionEvent.ACTION_DOWN: &#123;<br>                intercepted = <span class="hljs-keyword">false</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">case</span> MotionEvent.ACTION_MOVE: &#123;<br>                <span class="hljs-keyword">if</span> (needIntercept) &#123; <span class="hljs-comment">// 这里根据需求判断是否需要拦截</span><br>                    intercepted = <span class="hljs-keyword">true</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    intercepted = <span class="hljs-keyword">false</span>;<br>                &#125;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">case</span> MotionEvent.ACTION_UP: &#123;<br>                intercepted = <span class="hljs-keyword">false</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">default</span>:<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        mLastXIntercept = x;<br>        mLastYIntercept = y;<br>        <span class="hljs-keyword">return</span> intercepted;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="2-内部拦截法"><a href="#2-内部拦截法" class="headerlink" title="2.内部拦截法"></a>2.内部拦截法</h3><p>所谓的”内部拦截法“指的是对内部的View做文章，让内部View决定是不是拦截事件。但是现在就有问题了，你怎么知道外部的View是不是要拦截事件啊？？如果外部View把事件拦截了，内部的View岂不是连西北风都喝不到了？别着急，Google官方当然有考虑到这种情况。在ViewGroup中有一个叫requestDisallowInterceptTouchEvent的方法，这个方法接受一个boolean值，意思是是否要禁止ViewGroup拦截当前事件。如果是true的话那么该ViewGroup则无法对事件进行拦截。有了这个方法那我们就可以让内部View大显神通了。来看下内部拦截法的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">dispatchTouchEvent</span><span class="hljs-params">(MotionEvent event)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> x = (<span class="hljs-keyword">int</span>) event.getX();<br>        <span class="hljs-keyword">int</span> y = (<span class="hljs-keyword">int</span>) event.getY();<br><br>        <span class="hljs-keyword">switch</span> (event.getAction()) &#123;<br>            <span class="hljs-keyword">case</span> MotionEvent.ACTION_DOWN: &#123;<br>            <span class="hljs-comment">// 禁止parent拦截down事件</span><br>                parent.requestDisallowInterceptTouchEvent(<span class="hljs-keyword">true</span>);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">case</span> MotionEvent.ACTION_MOVE: &#123;<br>                <span class="hljs-keyword">int</span> deltaX = x - mLastX;<br>                <span class="hljs-keyword">int</span> deltaY = y - mLastY;<br>                <span class="hljs-keyword">if</span> (disallowParentInterceptTouchEvent) &#123; <span class="hljs-comment">// 根据需求条件来决定是否让Parent View拦截事件。</span><br>                    parent.requestDisallowInterceptTouchEvent(<span class="hljs-keyword">false</span>);<br>                &#125;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">case</span> MotionEvent.ACTION_UP: &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">default</span>:<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        mLastX = x;<br>        mLastY = y;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.dispatchTouchEvent(event);<br>    &#125;<br></code></pre></td></tr></table></figure><p>这么处理之后，两个嵌套View就可以和谐工作了。</p><p>下面是来自外部View和内部View的对话。</p><p>外部View：”我想拦截事件！“</p><p>内部View：”不，你不想。这事件我要定了，耶稣都留不住他。“<br><img src="https://raw.githubusercontent.com/zhpanvip/images/master/project/article/3502.webp" alt="开发不容易，P图靠自己"></p><h2 id="三、处理ViewPager2的滑动冲突"><a href="#三、处理ViewPager2的滑动冲突" class="headerlink" title="三、处理ViewPager2的滑动冲突"></a>三、处理ViewPager2的滑动冲突</h2><p>上一章讲了滑动冲突处理的两种方案，那么本章我们就来解决ViewPager2的滑动冲突。首先，应该确定一下存在在哪些需要拦截和不需要拦截的边界条件。在写这篇文章之前，我Google搜索了一下ViewPager2的滑动冲突处理方案，关于这方面的文章还不算少，不过大部分的文章对于ViewPager2的滑动冲突处理考虑的都不够完善。</p><p>下面我们详细来分析一下：</p><ul><li>如果设置了userInputEnable=false,那么ViewPager2不应该拦截任何事件；</li><li>如果只有一个Item，那么ViewPager2也不应该拦截事件；</li><li>如果是多个Item，且当前是第一个页面，那么只能拦截向左的滑动事件，向右的滑动事件就不应该由ViewPager2拦截了；</li><li>如果是多个Item，且当前是最后一个页面，那么只能拦截向右的滑动事件，向左的滑动事件不应该由当前的ViewPager2拦截；</li><li>如果是多个Item，且是中间页面，那么无论向左还是向右的事件都应该由ViewPager2拦截；</li><li>最后，由于ViewPager2是支持竖直滑动的，那么竖直滑动也应该考虑以上条件。</li></ul><p>分析完了边界条件之后，我们看下应该使用哪种方案来处理滑动冲突？很明显，这里应该使用内部拦截法处理。但是，由于ViewPager2被设置成了final，我们无法通过继承的方式来处理，因此就需要我们在ViewPager2外部加一层自定义的Layout。这层Layout其实相当于夹在了内层View和外层View的中间，其实就是这层Layout就变成了内层。好了，废话不多说了，直接贴代码了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><code class="hljs java">class ViewPager2Container @JvmOverloads constructor(context: Context, attrs: AttributeSet? = null, defStyleAttr: Int = 0) : RelativeLayout(context, attrs, defStyleAttr) &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> mViewPager2: ViewPager2? = <span class="hljs-keyword">null</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> disallowParentInterceptDownEvent = <span class="hljs-keyword">true</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> startX = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> startY = <span class="hljs-number">0</span><br><br>    <span class="hljs-function">override fun <span class="hljs-title">onFinishInflate</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.onFinishInflate()<br>        <span class="hljs-keyword">for</span> (i in <span class="hljs-number">0</span> until childCount) &#123;<br>            val childView = getChildAt(i)<br>            <span class="hljs-keyword">if</span> (childView is ViewPager2) &#123;<br>                mViewPager2 = childView<br>                <span class="hljs-keyword">break</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (mViewPager2 == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> IllegalStateException(<span class="hljs-string">&quot;The root child of ViewPager2Container must contains a ViewPager2&quot;</span>)<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function">override fun <span class="hljs-title">onInterceptTouchEvent</span><span class="hljs-params">(ev: MotionEvent)</span>: Boolean </span>&#123;<br>        val doNotNeedIntercept = (!mViewPager2!!.isUserInputEnabled<br>                || (mViewPager2?.adapter != <span class="hljs-keyword">null</span><br>                &amp;&amp; mViewPager2?.adapter!!.itemCount &lt;= <span class="hljs-number">1</span>))<br>        <span class="hljs-keyword">if</span> (doNotNeedIntercept) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.onInterceptTouchEvent(ev)<br>        &#125;<br>        when (ev.action) &#123;<br>            MotionEvent.ACTION_DOWN -&gt; &#123;<br>                startX = ev.x.toInt()<br>                startY = ev.y.toInt()<br>                parent.requestDisallowInterceptTouchEvent(!disallowParentInterceptDownEvent)<br>            &#125;<br>            MotionEvent.ACTION_MOVE -&gt; &#123;<br>                val endX = ev.x.toInt()<br>                val endY = ev.y.toInt()<br>                val disX = abs(endX - startX)<br>                val disY = abs(endY - startY)<br>                <span class="hljs-keyword">if</span> (mViewPager2!!.orientation == ViewPager2.ORIENTATION_VERTICAL) &#123;<br>                    onVerticalActionMove(endY, disX, disY)<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mViewPager2!!.orientation == ViewPager2.ORIENTATION_HORIZONTAL) &#123;<br>                    onHorizontalActionMove(endX, disX, disY)<br>                &#125;<br>            &#125;<br>            MotionEvent.ACTION_UP, MotionEvent.ACTION_CANCEL -&gt; parent.requestDisallowInterceptTouchEvent(<span class="hljs-keyword">false</span>)<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.onInterceptTouchEvent(ev)<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> fun <span class="hljs-title">onHorizontalActionMove</span><span class="hljs-params">(endX: Int, disX: Int, disY: Int)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (mViewPager2?.adapter == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> (disX &gt; disY) &#123;<br>            val currentItem = mViewPager2?.currentItem<br>            val itemCount = mViewPager2?.adapter!!.itemCount<br>            <span class="hljs-keyword">if</span> (currentItem == <span class="hljs-number">0</span> &amp;&amp; endX - startX &gt; <span class="hljs-number">0</span>) &#123;<br>                parent.requestDisallowInterceptTouchEvent(<span class="hljs-keyword">false</span>)<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                parent.requestDisallowInterceptTouchEvent(currentItem != itemCount - <span class="hljs-number">1</span><br>                        || endX - startX &gt;= <span class="hljs-number">0</span>)<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (disY &gt; disX) &#123;<br>            parent.requestDisallowInterceptTouchEvent(<span class="hljs-keyword">false</span>)<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> fun <span class="hljs-title">onVerticalActionMove</span><span class="hljs-params">(endY: Int, disX: Int, disY: Int)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (mViewPager2?.adapter == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span><br>        &#125;<br>        val currentItem = mViewPager2?.currentItem<br>        val itemCount = mViewPager2?.adapter!!.itemCount<br>        <span class="hljs-keyword">if</span> (disY &gt; disX) &#123;<br>            <span class="hljs-keyword">if</span> (currentItem == <span class="hljs-number">0</span> &amp;&amp; endY - startY &gt; <span class="hljs-number">0</span>) &#123;<br>                parent.requestDisallowInterceptTouchEvent(<span class="hljs-keyword">false</span>)<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                parent.requestDisallowInterceptTouchEvent(currentItem != itemCount - <span class="hljs-number">1</span><br>                        || endY - startY &gt;= <span class="hljs-number">0</span>)<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (disX &gt; disY) &#123;<br>            parent.requestDisallowInterceptTouchEvent(<span class="hljs-keyword">false</span>)<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 设置是否允许在当前View的&#123;<span class="hljs-doctag">@link</span> MotionEvent#ACTION_DOWN&#125;事件中禁止父View对事件的拦截，该方法</span><br><span class="hljs-comment">     * 用于解决CoordinatorLayout+CollapsingToolbarLayout在嵌套ViewPager2Container时引起的滑动冲突问题。</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 设置是否允许在ViewPager2Container的&#123;<span class="hljs-doctag">@link</span> MotionEvent#ACTION_DOWN&#125;事件中禁止父View对事件的拦截，该方法</span><br><span class="hljs-comment">     * 用于解决CoordinatorLayout+CollapsingToolbarLayout在嵌套ViewPager2Container时引起的滑动冲突问题。</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> disallowParentInterceptDownEvent 是否允许ViewPager2Container在&#123;<span class="hljs-doctag">@link</span> MotionEvent#ACTION_DOWN&#125;事件中禁止父View拦截事件，默认值为false</span><br><span class="hljs-comment">     *                          true 不允许ViewPager2Container在&#123;<span class="hljs-doctag">@link</span> MotionEvent#ACTION_DOWN&#125;时间中禁止父View的时间拦截，</span><br><span class="hljs-comment">     *                          设置disallowIntercept为true可以解决CoordinatorLayout+CollapsingToolbarLayout的滑动冲突</span><br><span class="hljs-comment">     *                          false 允许ViewPager2Container在&#123;<span class="hljs-doctag">@link</span> MotionEvent#ACTION_DOWN&#125;时间中禁止父View的时间拦截，</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">fun <span class="hljs-title">disallowParentInterceptDownEvent</span><span class="hljs-params">(disallowParentInterceptDownEvent: Boolean)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.disallowParentInterceptDownEvent = disallowParentInterceptDownEvent<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上边代码限于篇幅我就不做过多解释了，注意一下在onFinishInflate中我们通过循环，遍历了ViewPager2Container的所有子View，如果没有找到ViewPager2就抛出异常。另外，disallowParentInterceptDownEvent方法注释写的比较详细就不多说了。</p><p>使用方法也很简单，直接用ViewPager2Container包裹ViewPager2即可：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;com.zhpan.sample.viewpager2.ViewPager2Container<br>        android:layout_width=<span class="hljs-string">&quot;match_parent&quot;</span><br>        android:layout_height=<span class="hljs-string">&quot;match_parent&quot;</span><br>        app:layout_constraintBottom_toBottomOf=<span class="hljs-string">&quot;parent&quot;</span><br>        app:layout_constraintLeft_toLeftOf=<span class="hljs-string">&quot;parent&quot;</span><br>        app:layout_constraintRight_toRightOf=<span class="hljs-string">&quot;parent&quot;</span><br>        app:layout_constraintTop_toTopOf=<span class="hljs-string">&quot;parent&quot;</span>&gt;<br>        <br>        &lt;androidx.viewpager2.widget.ViewPager2<br>            android:id=<span class="hljs-string">&quot;@+id/view_pager2&quot;</span><br>            android:layout_width=<span class="hljs-string">&quot;match_parent&quot;</span><br>            android:layout_height=<span class="hljs-string">&quot;match_parent&quot;</span> /&gt;<br><br>        &lt;com.zhpan.indicator.IndicatorView<br>            android:id=<span class="hljs-string">&quot;@+id/indicatorView&quot;</span><br>            android:layout_centerHorizontal=<span class="hljs-string">&quot;true&quot;</span><br>            android:layout_alignParentBottom=<span class="hljs-string">&quot;true&quot;</span><br>            android:layout_margin=<span class="hljs-string">&quot;@dimen/dp_20&quot;</span><br>            android:layout_width=<span class="hljs-string">&quot;wrap_content&quot;</span><br>            android:layout_height=<span class="hljs-string">&quot;wrap_content&quot;</span>/&gt;<br><br>    &lt;/com.zhpan.sample.viewpager2.ViewPager2Container&gt;<br></code></pre></td></tr></table></figure><p>这是关于ViewPager2滑动出冲突的处理方案，当然，由于<a href="https://github.com/zhpanvip/BannerViewPager">BannerViewPager</a>支持循环轮播，所以BannerViewPager的滑动冲突处理相对会更麻烦些。如果有兴趣的同学可以点击查看<a href="https://github.com/zhpanvip/BannerViewPager">BannerViewPager</a>的源码。</p><p>同时，<a href="https://github.com/zhpanvip/AndroidSample/blob/master/app/src/main/java/com/zhpan/sample/viewpager2/ViewPager2Container.kt">ViewPager2Container </a>的源码我也放到了Github，需要用到的可以自取。</p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>BVP</tag>
      
      <tag>ViewPager2</tag>
      
      <tag>滑动冲突</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>跟ViewHolder说再见！实现一个无限轮播图究竟有多简单？</title>
    <link href="/2020/12/27/34.bvp-v3-4-usage/"/>
    <url>/2020/12/27/34.bvp-v3-4-usage/</url>
    
    <content type="html"><![CDATA[<p>去年8月份，我在Github开源了一个无限循环的轮播图库—<a href="https://github.com/zhpanvip/BannerViewPager">BannerViewPager</a>(以下简称BVP)。时至今日，一年多的时间过去了，BVP在大家的支持下已经在GitHub上收获了1.9k的Star。前段时间，我将BVP迁移到了<a href="https://gitee.com/zhpanvip/BannerViewPager">Gitee</a>，也很有幸受到了Gitee官方的认可，并得到了Gitee官方的推荐，短时间内在Gitee上收获了近120个Star。当然，能够取得这么大的成绩离不开大家的支持。</p><p>BVP最初的目标是做一个全网最好用的轮播图库，让大家用尽可能少的代码实现任意想要的效果。现在回头看看，那些吹过的牛似乎也在慢慢实现。今年四月份，BVP迎来了3.0版本的重大更新—从ViewPager迁移到了ViewPager2。在3.0版本中BVP的API向ViewPager2对齐，并且大幅优化了代码结构。使得BVP在使用上大幅简化。</p><p>而在近期的3.4.0版本中，BVP又进行了一次重要更新。这次更新使得开发者无需开发者无需再编写ViewHolder类，这一优化让BVP的使用进一步简化。那么让我们来看一下使用最新版本的BVP实现一个无限循环轮播图究竟有多简单吧。</p><h3 id="1-gradle中添加依赖"><a href="#1-gradle中添加依赖" class="headerlink" title="1.gradle中添加依赖"></a>1.gradle中添加依赖</h3><p>在项目根目录的build.gradle中添加如下配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">allprojects &#123;<br>repositories &#123;<br>...<br>maven &#123; url <span class="hljs-string">&#x27;https://www.jitpack.io&#x27;</span> &#125;<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>然后在app目录下的gradle中添加依赖：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">implementation <span class="hljs-string">&#x27;com.github.zhpanvip:BannerViewPager:3.4.0&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="2-继承BaseBannerAdapter-并重写相关方法"><a href="#2-继承BaseBannerAdapter-并重写相关方法" class="headerlink" title="2.继承BaseBannerAdapter,并重写相关方法"></a>2.继承BaseBannerAdapter,并重写相关方法</h3><p>重写getLayoutId方法，并在这个方法中返回Item布局。然后重写bindData方法，在这个方法中通过BaseViewHolder进行数据绑定。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SimpleAdapter</span> : <span class="hljs-type">BaseBannerAdapter</span>&lt;<span class="hljs-type">CustomBean</span>&gt;</span>() &#123;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">bindData</span><span class="hljs-params">(holder: <span class="hljs-type">BaseViewHolder</span>&lt;<span class="hljs-type">CustomBean</span>&gt;, <span class="hljs-keyword">data</span>: <span class="hljs-type">CustomBean</span>?, position: <span class="hljs-type">Int</span>, pageSize: <span class="hljs-type">Int</span>)</span></span> &#123;<br>        holder.setImageResource(R.id.banner_image, <span class="hljs-keyword">data</span>!!.imageRes)<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getLayoutId</span><span class="hljs-params">(viewType: <span class="hljs-type">Int</span>)</span></span>: <span class="hljs-built_in">Int</span> &#123;<br>        <span class="hljs-keyword">return</span> R.layout.item_custom_view;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-在Activity中构建BannerViewPager"><a href="#3-在Activity中构建BannerViewPager" class="headerlink" title="3.在Activity中构建BannerViewPager"></a>3.在Activity中构建BannerViewPager</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> mViewPager: BannerViewPager&lt;CustomBean&gt;<br>...<br><br><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">setupViewPager</span><span class="hljs-params">()</span></span> &#123;<br>          mViewPager = findViewById(R.id.banner_view)<br>          mViewPager.apply &#123;<br>              adapter = SimpleAdapter()<br>              setLifecycleRegistry(lifecycle)<br>          &#125;.create(getPicList(<span class="hljs-number">4</span>))<br>      &#125;<br></code></pre></td></tr></table></figure><p>OK！到这里一个页面自动切换、无限循环且带有指示器的轮播图就完成了！没错，就是这么简单，就是这么不讲武德！！还是运行起来看下效果吧。<br><img src="https://raw.githubusercontent.com/zhpanvip/images/master/project/article/3401.gif" alt="在这里插入图片描述"></p><p>有同学可能说，这个效果太难看了。我们产品说想要一个炫酷一点的。没关系，这是一个加参(jiā)数(qián)就能解决的问题。看代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">mViewPager.apply &#123;<br>            adapter = SimpleAdapter()<br>            setLifecycleRegistry(lifecycle)<br>            setScrollDuration(<span class="hljs-number">800</span>)<br>            setRevealWidth(resources.getDimensionPixelOffset(R.dimen.dp_15))<br>            setPageStyle(PageStyle.MULTI_PAGE_OVERLAP)<br>            setIndicatorSliderColor(getColor(R.color.red_normal_color), getColor(R.color.red_checked_color))<br>            setIndicatorSliderRadius(resources.getDimensionPixelOffset(R.dimen.dp_4), resources.getDimensionPixelOffset(R.dimen.dp_6))<br>            setIndicatorSlideMode(IndicatorSlideMode.SCALE)<br>        &#125;.create(getPicList(<span class="hljs-number">4</span>))<br></code></pre></td></tr></table></figure><p>运行起来看下效果：</p><p><img src="https://raw.githubusercontent.com/zhpanvip/images/master/project/article/3402.gif" alt="在这里插入图片描述"></p><p>什么？产品小姐姐还不满意？没关系，现在就把<a href="https://github.com/zhpanvip/BannerViewPager/wiki">BVP的文档</a>摔到她脸上，让她 随！便！挑！包她满意。</p><p>最后欢迎大家到Github关注BVP，你的Star是给我最大的支持！</p><p>Github链接：<a href="https://github.com/zhpanvip/BannerViewPager">BannerViewPager</a></p>]]></content>
    
    
    <categories>
      
      <category>自定义View</category>
      
    </categories>
    
    
    <tags>
      
      <tag>BVP</tag>
      
      <tag>ViewPager2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>探索Java虚拟机的类加载机制</title>
    <link href="/2020/12/25/33.jvm-class-load/"/>
    <url>/2020/12/25/33.jvm-class-load/</url>
    
    <content type="html"><![CDATA[<p>我们知道Java程序在编译的过程中需要先经过javac将Java文件编译成字节码文件才能被虚拟机执行。而类加载指的就是将编译好的字节码（不仅仅指.class文件中的字节码，任意的字节码流都可以被读取到JVM）读取到JVM的内存中的过程。虚拟机在加载.class文件时会对数据进行校验、转换解析和初始化。最终形成可以被虚拟机直接使用的Java类型。这个过程称作虚拟机的类加载机制。类加载机制是虚拟机中很重要的一部分内容，在面试中出现的频率也是比较高。因此，作为一个Java程序员，JVM的类加载机制是我们必须掌握的知识。</p><p>为了更好的理解类加载的过程，我们先来看一道类加载的面试题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Person.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>&#123;<br>    <span class="hljs-keyword">static</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;I&#x27;m a person&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// Stuent.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span></span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String indentity=<span class="hljs-string">&quot;Student&quot;</span>;<br>    <span class="hljs-keyword">static</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;I&#x27;m a student&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Ryan</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Student</span></span>&#123;<br>    <span class="hljs-keyword">static</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;I&#x27;m Ryan&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来我们我们写一个测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>System.out.println(<span class="hljs-string">&quot;Ryan.indentity=&quot;</span> + Ryan.indentity);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>大家可以先不要看下边的答案，试着分析一下会输出什么样的结果。</p><p>好了，公布答案，上述代码结果输出如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">I<span class="hljs-string">&#x27;m a persion</span><br><span class="hljs-string">I&#x27;</span>m a student<br>Ryan.indentity=Student<br></code></pre></td></tr></table></figure><p>是否和你的答案一样呢？如果不一样，那说明你还没有清楚的理解JVM的类加载机制。接下来不妨就来学习一下JVM的类加载吧。</p><h2 id="一、类加载的过程"><a href="#一、类加载的过程" class="headerlink" title="一、类加载的过程"></a>一、类加载的过程</h2><p>一个类从被加载到虚拟机内存中开始，到卸载出虚拟机内存为止，它的声明周期会经历加载（Loading）、连接（Linking）、初始化（Initialization）、使用（Using）和卸载（Unloading）这几个阶段。而连接阶段又包含验证（Verification）、准备（Preparation）、解析（Resolution）三个阶段。如下图所示：<br><img src="https://raw.githubusercontent.com/zhpanvip/images/master/project/article/3302.gif" alt="在这里插入图片描述"><br>其中，加载、验证、准备、初始化和卸载这五个阶段的顺序是确定的，而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始。接下来，我们来详细的了解Java虚拟机中类加载的过程，即加载、验证、准备、解析和初始化这五个阶段。</p><h3 id="1-加载阶段"><a href="#1-加载阶段" class="headerlink" title="1.加载阶段"></a>1.加载阶段</h3><p>加载阶段是类加载过程的第一个阶段。这一阶段JVM会通过类的全限定名（可能来自.class文件，也可能来自ZIP压缩包、网络等，甚至可以是运行时生成。）来读取类的二进制字节流。并将读取到的二进制字节流转化为方法区的运行时数据结构，然后在内存中生成一个代表这个类的java.lang.Class对象。</p><p>简单的来说，这一阶段就是将类的字节码二进制流读取到JVM，并生成代表这个类的Class对象。</p><h3 id="2-连接"><a href="#2-连接" class="headerlink" title="2.连接"></a>2.连接</h3><p>连接阶段包含了验证、准备、解析三个过程。</p><h4 id="（1）验证"><a href="#（1）验证" class="headerlink" title="（1）验证"></a>（1）验证</h4><p>这一阶段的目的是为了保证class文件字节流符合当前虚拟机的要求。并且保证这些数据代码运行后不会危害虚拟机自身安全。验证阶段大致会完成四个阶段的检验：文件格式验证、元数据验证、字节码验证、符号引用验证。</p><p><strong>文件格式验证</strong></p><p>这一阶段验证字节流是否符合Class文件格式的规范，并且能被当前的虚拟机处理。</p><p><strong>元数据验证</strong></p><p>这一阶段是对字节码描述的信息进行语义分析，保证其描述的信息符合Java语言规范的要求。</p><p><strong>字节码验证</strong><br>这一阶段会通过数据流和控制流分析，确定程序语义是否合法，符合逻辑。这个阶段对类的方法体就行校验分析，保证被校验的类的方法在运行时不会做危害虚拟机安全的事情。</p><p><strong>符号引用验证</strong><br>最后一个阶段的校验发生在虚拟机符号引用转化为直引用的时候，这个转化动作将在连接的第三阶段–解析阶段发生。符号引用校验可以看做是对类自身以外（常量池的各种符号引用）的信息进行匹配性校验。</p><h4 id="（2）准备"><a href="#（2）准备" class="headerlink" title="（2）准备"></a>（2）准备</h4><p><strong>准备阶段是类加载机制中很重要的一个阶段。</strong> 这一阶段是正式为类中定义的静态变量（被static修饰的变量）分配内存并设置类变量初始值的阶段。这些变量所使用的内存都应该在方法区中进行分配。我们知道，在JDK7之前，Hotspot虚拟机使用永久代来实现方法区。而在JDK8之后，方法区被放在了Java堆中。因此，类变量也会随着Class对象一起存放在Java堆中。</p><p>另外，关于准备阶段有两点需要注意：</p><p> ①  <strong>为变量分配内存</strong>  我们知道，Java类中的变量可以分为<strong>成员变量</strong>与<strong>类变量</strong>，类变量是指被static修饰的变量，其他类型的变量都属于成员变量。而<strong>准备阶段的内存分配仅包括类变量，不包括成员变量</strong>，<strong>成员变量</strong>只有在对象实例化的时候随着对象一起分配到Java堆中。</p><p>例如下面的代码在准备阶段只会为value分配内存，而不会为str分配内存。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> &#123;</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> value = <span class="hljs-number">123</span>;<br>  <span class="hljs-keyword">public</span>  <span class="hljs-keyword">String</span> str = <span class="hljs-string">&quot;123&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>② <strong>为类变量赋初始值</strong> 在准备阶段，JVM会为类变量分配内存，并对其初始化。<strong>而初始化的值并非我们在代码中赋予的值，而是数据类型的零值。</strong> 例如上述代码中经过准备阶段后value的值是0，而并非123。但如果给value再加一个final修饰符，那么经过准备阶段，value的值就是123（因为此时的value相当于一个常量），这是因为在编译时Javac会为value生成ConstantValue属性，在准备阶段虚拟机就会根据ConstantValue的设置将value赋值为123。</p><h4 id="（3）解析"><a href="#（3）解析" class="headerlink" title="（3）解析"></a>（3）解析</h4><p>解析阶段是虚拟机将常量池的符号引用替换为直接引用的过程。这一阶段不太重要，了解即可。</p><h3 id="3-初始化"><a href="#3-初始化" class="headerlink" title="3.初始化"></a>3.初始化</h3><p>初始化是类加载的最后一个阶段，也是类加载过程中最重要的一个阶段。在这一阶段用户定义的Java程序代码（字节码）才真正开始执行。什么意思呢？刚才提到在准备阶段JVM会为类变量赋默认的初始值，<strong>而初始化阶段类变量才会被赋予我们在代码中声明的值。JVM会根据语句执行顺序对类对象进行初始化</strong>。</p><p>在《Java虚拟机规范》中并没有强制约束在什么情况下开始执行类加载的第一个“加载”阶段，但是对于初始化阶段《Java虚拟机规范》中却有着严格的约束。一般来说当 JVM 遇到下面 6 种情况的时候会触发类加载的初始化（在执行初始化阶段之前需要先执行加载、验证和准备阶段）：</p><p>① 遇到 new、getstatic、putstatic、invokestatic 这四条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。生成这4条指令的最常见的Java代码场景是：使用new关键字实例化对象的时候、读取或设置一个类的静态字段（被final修饰、已在编译器把结果放入常量池的静态字段除外）的时候，以及调用一个类的静态方法的时候。</p><p>② 使用 java.lang.reflect 包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。</p><p>③ 当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</p><p>④ 当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。</p><p>⑤ 当使用 JDK1.7 动态语言支持时，如果一个 java.lang.invoke.MethodHandle实例最后的解析结果<br>REF_getstatic,REF_putstatic,REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行初始化，则需要先出触发其初始化。</p><p>⑥ 当一个接口中定义了JDK8新加入的默认方法（被default关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。</p><h2 id="二、类加载例题分析"><a href="#二、类加载例题分析" class="headerlink" title="二、类加载例题分析"></a>二、类加载例题分析</h2><p>在了解了类加载的过程后，我们通过几个例题分析来深入的理解类加载。</p><h3 id="1-开篇例题分析"><a href="#1-开篇例题分析" class="headerlink" title="1.开篇例题分析"></a>1.开篇例题分析</h3><p>开篇的面试题中在main方法中调用了Ryan.indentity，而indentity是位于Ryan父类Student中的类变量。根据初始化阶段中的第①点我们可以知道：</p><blockquote><p>读取或设置一个类的静态字段（被final修饰、已在编译器把结果放入常量池的静态字段除外）的时候，以及调用一个类的静态方法的时候会触发类的初始化。</p></blockquote><p>因此，此时会首先去加载并初始化Ryan类，而从初始化③中我们知道：</p><blockquote><p>当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</p></blockquote><p> 因此，最先被加载并被初始化的类应该是Person类，Person类的初始化导致了首先输出 <em>I’m a person</em>语句。<br> 接着Student类被加载，所以第二行输出 了<em>I’m a student</em> 。最后完成Ryan类的加载并输出 <em>Ryan.indentity=Student</em></p><h3 id="2-例题二"><a href="#2-例题二" class="headerlink" title="2.例题二"></a>2.例题二</h3><p>给出Singleton 类如下代码所示，请分析程序的输出结果。大家可以先不要答案，试着自己分析一下结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton singleton = <span class="hljs-keyword">new</span> Singleton();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> x;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> y = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123;<br>        ++x;<br>        ++y;<br>        System.out.println(<span class="hljs-string">&quot;Singleton构造方法执行，x = &quot;</span> + x +<span class="hljs-string">&quot;,y = &quot;</span> + y);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;singleton.x = &quot;</span> + singleton.x);<br>        System.out.println(<span class="hljs-string">&quot;singleton.x = &quot;</span> + singleton.y);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Singleton构造方法执行，x = <span class="hljs-number">1</span>,y = <span class="hljs-number">1</span><br>singleton.x = <span class="hljs-number">1</span><br>singleton.x = <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>如果不了解类加载的过程，会觉得这是一个很奇怪的输出结果。x、y的初始值都是0，在构造方法种经过了同样的“++”操作，而最后的输出结果为什么不一样呢？我们还是先从出发类初始化的几个条件着手。</p><p>1）从触发类初始化的第④ 个条件可知，虚拟机启动时会先加载包含main方法的类。因此Singleton 首先会触发类加载流程。</p><p>2）而经过加载、验证流程后，进入类加载的准备阶段，这一阶段虚拟机会为类变量分配内存和并对其进行初始化赋值。注意，准备阶段只会给类变量赋默认值，经过准备阶段后结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton singleton = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> y = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>3）初始化阶段会根据代码顺序为类变量赋代码中声明的值。因此，首先会实例化Singleton ，并将实例化后的值赋给singleton。而此时，由于x、y还没有被赋值。因此x、y均为0。所以，在经过“++”操作后输出x、y的值均为1。</p><p>4）接下来为x、y赋代码中声明的值，而在我们的代码中x没有赋初始值，y则被赋值为0。因此，此时x仍然为1，而y则被赋值为0.</p><p>5）类加载完成后打印x、y的值。</p><p>经过以上两个例题的分析，相信大家对JVM的类加载机制有了一个更清楚的认识。而在类加载机制中除了类加载的过程，还有一个很重要的知识点，那就是类加载器，我们接着往下看。</p><h2 id="三、类加载器"><a href="#三、类加载器" class="headerlink" title="三、类加载器"></a>三、类加载器</h2><p>前两章我们了解了类加载的过程，而类加载的过程则是由类加载器来完成的。类加载器在Java程序中起到的作用可以说远超类加载阶段。我们在程序中使用到的任意一个类都需要类加载器将其加载到虚拟机，并且由类加载器保证被加载类的唯一性。这里我们需要明白一点：<strong>两个类是否相等的前提条件是这两个类是由同一个类加载器加载的。如果两个类来自同一个Class文件，但是被同一个虚拟机下不同的类加载器加载，那么这两个类必定不相等。</strong></p><p>那么问题来了，虚拟机是如何保证同一个Class文件只能被同一个类加载器加载的呢？要解答这个问题首先要了解类加载器的划分。</p><h3 id="1-类加载器的分类"><a href="#1-类加载器的分类" class="headerlink" title="1.类加载器的分类"></a>1.类加载器的分类</h3><p>在Java中类加载器分为启动类加载器（Bootstrap Class Loader）、扩展类加载器（Extension Class Loader）、应用类加载器（Application Class Loader）以及自定义类加载器（User Class Loader）。接下来我们就分别来认识这几种类加载器。</p><h4 id="1）启动类加载器（Bootstrap-Class-Loader）"><a href="#1）启动类加载器（Bootstrap-Class-Loader）" class="headerlink" title="1）启动类加载器（Bootstrap Class Loader）"></a>1）启动类加载器（Bootstrap Class Loader）</h4><p>这个类加载器是虚拟机的一部分，使用C++语言实现。这个类加载器只负责加载存放在<JAVA_HOME>\lib目录，或者被-Xbootclasspath参数所指定的路径中存放的Java虚拟机能够识别的（按照文件名识别，如rt.jar、tool.jar。名字不符合的类库即使放在lib目录下也不会被加载）类库加载到虚拟机中。</p><h4 id="2）扩展类加载器（Extension-Class-Loader）"><a href="#2）扩展类加载器（Extension-Class-Loader）" class="headerlink" title="2）扩展类加载器（Extension Class Loader）"></a>2）扩展类加载器（Extension Class Loader）</h4><p>这个类加载器位于类sun.miss.Launcher$ExtClassLoader中，并且是由Java代码所实现的。它负责加载<Java_HOME>\lib\ext目录中，或被java.ext.dirs系统变量所指定的路径中所有的类库。开发者可以直接在程序中使用扩展类加载器来加载Class文件。</p><h4 id="3）应用程序类加载器（Application-Class-Loader）"><a href="#3）应用程序类加载器（Application-Class-Loader）" class="headerlink" title="3）应用程序类加载器（Application Class Loader）"></a>3）应用程序类加载器（Application Class Loader）</h4><p>这个类加载器位于sun.misc.Launcher$AppClassLoader中，同样是由Java语言实现。他负责加载用户类路径（ClassPath)上所有的类库。开发者同样可以直接在代码中使用这个类加载器。如果程序中没有自定义的类加载器，一般情况下这个就是程序中默认的类加载器。</p><h4 id="4）自定义类加载器（User-Class-Loader）"><a href="#4）自定义类加载器（User-Class-Loader）" class="headerlink" title="4）自定义类加载器（User Class Loader）"></a>4）自定义类加载器（User Class Loader）</h4><p>除了上述三种Java系统中的类加载器外，很多情况下用户还会通过自定义类加载器加载所需要的类。诸如增加除了磁盘位置之外的Class文件来源，或者通过类加载器实现类的隔离、重载等功能</p><h3 id="2-双亲委派模型"><a href="#2-双亲委派模型" class="headerlink" title="2.双亲委派模型"></a>2.双亲委派模型</h3><p>在本章开头我们已经提到两个类相等的前提条件应该是这两个类是由同一个类加载器加载的。既然Java种存在这么多的类加载器，那么Java是如何保证同一个类都是由同一个类加载器加载的呢？这主要得益于类加载器的“双亲委派模型”。接下来我们就来认识一下什么是“双亲委派模型”。</p><p>如下图所示，展示了各个类加载器之间的层次关系就是本节要讲的“双亲委派模型”<br><img src="https://raw.githubusercontent.com/zhpanvip/images/master/project/article/3301.gif" alt="在这里插入图片描述"><br>双亲委派模型要求除了顶层启动类加载器外，其余的类加载器都应该有自己的父类加载器。而这里类加载器之间的父子关系不是通过继承来实现的，而是通过组合的关系来复用父加载器的代码。</p><p>双亲委派模型的工作过程如下：</p><blockquote><p>如果一个类加载器收到了类加载的请求，首先它不会自己尝试加载这个类，而是把这个请求委派给父类加载器来完成，每个层次的类加载器都是如此。因此，所有的类加载请求最终都会被传送到最顶层的启动类加载器种，只有当父加载器无法找到这个加载请求的类时，子类加载器才会尝试去完成加载。</p></blockquote><p>双亲委派模型的代码实现非常简单，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">synchronized</span> Class&lt;?&gt; loadClass(String name, <span class="hljs-keyword">boolean</span> resolve)<span class="hljs-keyword">throws</span> ClassNotFoundException &#123;<br>        <span class="hljs-comment">// 首先检查该类型是否已经被加载过了</span><br>        Class c = findLoadedClass(name);<br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">//如果这个类还没有被加载，则尝试加载该类</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span> (parent != <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// 如果存在父类加载器，就委派给父类加载器加载</span><br>                    c = parent.loadClass(name, <span class="hljs-keyword">false</span>);<br>                &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 如果不存在父类加载器，就尝试使用启动类加载器加载</span><br>                    c = findBootstrapClass0(name);<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<span class="hljs-comment">// 父类加载器找不到要加载的类，则抛出ClassNotFoundException </span><br>                <span class="hljs-comment">// 尝试调用自身的findClass方法进行类加载</span><br>                c = findClass(name);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (resolve) &#123;<br>            resolveClass(c);<br>        &#125;<br>        <span class="hljs-keyword">return</span> c;<br>    &#125;<br></code></pre></td></tr></table></figure><p>这段代码的逻辑非常清晰易懂，代码中已经做了详细的注释说明。正是因为双亲委派模型具备一种带有优先级的层次关系，使得无论哪个类加载最终都会委派给处于最顶层的启动类加载器进行加载，因此保证了在程序种各个类加载器环境中都能够保证是同一个类。</p><h2 id="四、小结"><a href="#四、小结" class="headerlink" title="四、小结"></a>四、小结</h2><p>类加载机制通常是很多面试者的噩梦，碰到类加载的面试题只能束手无策。而通过本篇文章的学习，你会发现其实类加载是一个很简单的过程，只要记住类加载的几个重要阶段，就能轻松驾驭大多数相关试题。另外，类加载器也是一个重要的知识点。虽然重要，但也简单，用短短几行代码通过”双亲委派模型“就实现了类加载的过程。不得不让我们佩服Java设计的精妙。</p><h2 id="五、参考-amp-推荐阅读"><a href="#五、参考-amp-推荐阅读" class="headerlink" title="五、参考&amp;推荐阅读"></a>五、参考&amp;推荐阅读</h2><p>《深入理解Java虚拟机 第三版》 作者周志明</p><p><a href="https://www.cnblogs.com/chanshuyi/p/the_java_class_load_mechamism.html">两道面试题，带你解析Java类加载机制</a></p>]]></content>
    
    
    <categories>
      
      <category>Java进阶</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
      <tag>类加载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ButterKnife被弃用，ViewBinding才是findView的未来？</title>
    <link href="/2020/11/29/32.Bye%20ButterKnife/"/>
    <url>/2020/11/29/32.Bye%20ButterKnife/</url>
    
    <content type="html"><![CDATA[<p>最近Android Studio更新到了4.1版本，发现项目中使用ButterKnife注解id的代码出现了警告，警告信息如下：</p><blockquote><p>Resource IDs will be non-final in Android Gradle Plugin version 5.0, avoid using them as annotation attributes</p></blockquote><p>从警告信息中可以看到在Gradle 5.0的插件中Resource 的Id值将不会再是final类型，因此应该避免在注解属性中使用Id。这意味着当我们把Gradle插件升级到5.0版本之后ButterKnife将无法再被使用！同时，我们在ButterKnife的官方文档上也看到了ButterKnife被标注弃用的信息：<br><img src="https://raw.githubusercontent.com/zhpanvip/images/master/project/article/3201.webp" alt="在这里插入图片描述"><br>陪伴我们多年，曾经辉煌一时，不可一世的ButterKnife也要寿终正寝，即将迎来它生命的终点。借这个机会，我们不妨来回顾一下Android开发中findView的发展史，以及展望下findView的未来。</p><h2 id="一、Android绑定View的发展史"><a href="#一、Android绑定View的发展史" class="headerlink" title="一、Android绑定View的发展史"></a>一、Android绑定View的发展史</h2><p>从Android系统诞生至今，在代码中findView一直是Android开发者无法绕开的一道程序。从最初的findViewbyId到如今炙手可热的ViewBinding，期间涌现出了许多findView的方式，它们让findView变得更加简单，也让我们的代码变得更加简洁。但随着Android新技术的发展，这些findView的方法也正在被一个一个的抛弃。本节内容我们就来回顾一下Android开发中findView的发展史。</p><h3 id="1-findViewById"><a href="#1-findViewById" class="headerlink" title="1.findViewById"></a>1.findViewById</h3><p>findViewById是Android开发中最原始，也是最基础的一种获取View的方法。它由Google官方提供，在Android开发生态的早期也是唯一一种能够获取View的方式。虽然它使用简单且根正苗红，贯穿古今。但由于高度重复的代码结构深受开发者诟病。在一个复杂布局的页面仅仅是findViewById的代码往往就能达到数十行。开发者无时无刻不想着弃用这一方案，因此后续衍生出了多种获取View的方式来简化代码。但万变不离其宗，归根结底，这些方式最终都还是通过findViewById来实现的。虽然它是最不被开发者认可的一种的方式，但时至今日开发者也无法摆脱它笼罩着的阴影。一脸你看不惯我你打我呀的表情！</p><h3 id="2-ButterKnife"><a href="#2-ButterKnife" class="headerlink" title="2.ButterKnife"></a>2.ButterKnife</h3><p>就在大家都在唾弃findViewById的大量重复代码时，一个插件横空出世。它通过一个BindView注解，传入一个Resource Id就能轻松获取到Id对应的View。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AppCompatActivity</span> </span>&#123;<br> <span class="hljs-meta">@BindView(R.id.text_view)</span><br> TextView mTextView;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState);<br>        setContentView(R.layout.activity_main);<br>        ButterKnife.bind(<span class="hljs-keyword">this</span>);<br>    &#125;<br>    &#125;<br><br></code></pre></td></tr></table></figure><p>它就是红极一时，时至今日大家依然还在用着的ButterKnife。ButterKnife通过最前沿的Java技术（最初的版本可能是反射，未加考究）–Java编译时注解处理器，在编译时自动生成findViewById的代码。例如，上边的例子通过ButterKnife会生成一个MainActivity_ViewBinding 类，在这个类中通过findViewById为mTextView赋值，其代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainActivity_ViewBinding</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Unbinder</span> </span>&#123;<br>  <span class="hljs-keyword">private</span> MainActivity target;<br><br>  <span class="hljs-meta">@UiThread</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MainActivity_ViewBinding</span><span class="hljs-params">(MainActivity target)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>(target, target.getWindow().getDecorView());<br>  &#125;<br><br>  <span class="hljs-meta">@UiThread</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MainActivity_ViewBinding</span><span class="hljs-params">(MainActivity target, View source)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.target = target;<br><br>    target.mTextView = Utils.findRequiredViewAsType(source, R.id.text_view, <span class="hljs-string">&quot;field &#x27;mTextView&#x27;&quot;</span>, TextView.class);<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-meta">@CallSuper</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unbind</span><span class="hljs-params">()</span> </span>&#123;<br>    MainActivity target = <span class="hljs-keyword">this</span>.target;<br>    <span class="hljs-keyword">if</span> (target == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">&quot;Bindings already cleared.&quot;</span>);<br>    <span class="hljs-keyword">this</span>.target = <span class="hljs-keyword">null</span>;<br><br>    target.mTextView = <span class="hljs-keyword">null</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这一操作省去了开发者手动编写findViewById的时间,大大简化了代码，同时提高了开发效率。在当时的开发者看来ButterKnife不得不说是一个神器，以至于到后来成了Android项目开发的标配。</p><p>后来，随着Android Studio的诞生，Eclipse开发Android项目逐渐淡出历史舞台。Android studio的出现，带来了全新的技术，模块化风靡一时。大概在这个时候，Google官方似乎就已经有了改造R类的想法。在Android项目的library模块中，生成R类中的成员变量就已经改为了非final修饰。同时，Google官方也不再建议在app模块的代码中使用像：<code>switch(view.getId())</code>这样的代码。</p><p>正如Android studio官网文档<a href="http://tools.android.com/tips/non-constant-fields">《Non-constant Fields in Case Labels》</a>上给出的原因：</p><blockquote><p>In other words, the constants are not final in a library project. The reason for this is simple: When multiple library projects are combined, the actual values of the fields (which must be unique) could collide. Before ADT 14, all fields were final, so as a result, all libraries had to have all their resources and associated Java code recompiled along with the main project whenever they were used. This was bad for performance, since it made builds very slow. It also prevented distributing library projects that didn’t include the source code, limiting the usage scope of library projects.</p></blockquote><p>这一改变直接致使ButterKnife无法在Android项目的library模块中使用。而此时，ButterKnife正是如日中天，追随的开发者不计其数。为了能够让ButterKnife运行在library模块，ButterKnife的作者Jake Wharton大佬曲线救国，通过生成R2类让ButterKnife在library模块中复活，并且得以发展壮大。但不得不说，此时的ButterKnife就已经埋下了深深的隐患，并导致了其最终的溃败。</p><h3 id="3-DataBinding"><a href="#3-DataBinding" class="headerlink" title="3.DataBinding"></a>3.DataBinding</h3><p>DataBinding是Google官方在2015年谷歌I/O大会上发布的一个数据绑定框架，它并非专为findView而生，而是作为MVVM架构的双向绑定数据的工具。findView的功能仅仅是DataBinding的一个附赠品。</p><p>开发者一般会在MVVM架构的项目中使用DataBinding来获取View。但是它也有很多诟病，比如需要修改xml的结构，在xml外部嵌套一个<layout>标签。并且很多情况下需要手动build才能生成DataBinding相关类。诸如此类问题，自然不会得到开发者的青睐。</p><p>关于DataBinding的详细使用在这里不做探讨。</p><h3 id="4-Kotlin-Android-Extensions"><a href="#4-Kotlin-Android-Extensions" class="headerlink" title="4.Kotlin Android Extensions"></a>4.Kotlin Android Extensions</h3><p>2017年Google I/O开发者大会中，Google宣布Kotlin成为Android开发的一级语言，自此，Kotlin “转正”与Java并驾齐驱。而JetBrain推出的Kotlin Android Extension(以下简称KAE)插件成为了有史以来最简单的获取View的方法，简单到无需任何代码，直接通过id作为View使用。这一功能足以让所有Android开发者抓狂，纷纷感叹这才是findView的未来啊，终于可以和裹挟开发者十多年的findViewById说拜拜了！<br>作为一个Android开发者，不知道你是否会好奇Kotlin是如何将Id作为View的？我们不妨写一个简单的例子:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainActivity</span> : <span class="hljs-type">AppCompatActivity</span></span>() &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)<br>        setContentView(R.layout.activity_main)<br>        textView.text = <span class="hljs-string">&quot;Test&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>布局文件中TextView的id设置为“textView”,则在Activity中可以直接将textView作为一个TextView来使用。我们通过Android Studio的工具将kotlin的字节码反编译成Java代码看下<br><img src="https://raw.githubusercontent.com/zhpanvip/images/master/project/article/3202.webp" alt="在这里插入图片描述"><br>通过上述操作，打开kotlin的字节码后，再通过Decompile反编译成Java代码，则会得到如下图所示的结果：<br><img src="https://raw.githubusercontent.com/zhpanvip/images/master/project/article/3203.webp" alt="在这里插入图片描述"><br>通过反编译得到的Java代码我们发现Kotlin的这一操作其实也是通过findViewById实现的。只是通过插件的方式让我们感觉上是用了View的Id。</p><p>通过Kotlin的扩展插件来find view,无疑是一种优秀的方案。但这一方案并不是无懈可击。它存在以下几个缺点：</p><ul><li>类型安全：res下的任何id都可以被访问，有可能因访问了非当前Layout下的id而出错</li><li>空安全：这主要体现在Configuration中的对应布局不全时，运行时可能出现NPE</li><li>兼容性：只能在kotlin中使用，java不友好</li><li>局限性：不能跨module使用</li></ul><p>也正是这几个缺点导致了KAE的大溃败。随着Google对亲儿子ViewBinding的大力推广，KAE最终也招架不住，只能缴械投降—Jetbrains在官网宣布废弃KAE，并推荐开发者使用ViewBinding.<br><img src="https://raw.githubusercontent.com/zhpanvip/images/master/project/article/3204.webp" alt="在这里插入图片描述"></p><h3 id="5-ViewBinding"><a href="#5-ViewBinding" class="headerlink" title="5.ViewBinding"></a>5.ViewBinding</h3><p>到这里，以上提到的多种findView方案都已经被废弃，唯独只剩Google官方正在大力推广的ViewBinding组件。ViewBinding是Google在2019年I/O大会上公布的一款Android视图绑定工具。它的使用方式有点类似DataBinding，但相比DataBinding，ViewBinding是一个更轻量级、更纯粹的findViewById的替代方案。它具有以下几个优点：</p><ul><li>类型安全: ViewBinding会基于布局中的View生成类型正确的属性。比如，在布局中放入了一个 TextView ，视图绑定就会暴露出一个 TextView 类型的属性供开发中使用。</li><li>空安全:ViewBinding会检测某个视图是不是只在一些配置下存在，并依据结果生成带有 @Nullable 注解的属性。所以即使在多种配置下定义的布局文件，视图绑定依然能够保证空安全。</li><li>ViewBinding生成的绑定类是一个Java类，并且添加了Kotlin的注解，可以很好的支持 Java 和 Kotlin 两种编程语言。</li></ul><p>同时，Google官方还给出了一个ViewBinding、ButterKnife以及KAE的对比，如下图：<br><img src="https://raw.githubusercontent.com/zhpanvip/images/master/project/article/3205.webp" alt="在这里插入图片描述"><br>总而言之，到目前为止除了ViewBinding我们已经别无选择。那么不妨接下来详细探究下ViewBinding的使用方法。</p><h2 id="二、ViewBinding使用详解"><a href="#二、ViewBinding使用详解" class="headerlink" title="二、ViewBinding使用详解"></a>二、ViewBinding使用详解</h2><h3 id="1-开启ViewBinding"><a href="#1-开启ViewBinding" class="headerlink" title="1.开启ViewBinding"></a>1.开启ViewBinding</h3><p>Android Studio对于ViewBinding的支持是从3.6版本开始的，AS 3.6版本内置了Gradle插件。只需要在build.gradle中通过以下配置即可开启ViewBinding:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">android &#123;<br>    buildFeatures &#123;<br>        viewBinding = <span class="hljs-literal">true</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果，你的项目存在多个模块，则需要在每个模块的gradle中添加上述配置。完成以上配置后ViewBinding会为所有布局文件自动生成对应的绑定类。且无须修改原有布局的 XML 文件，ViewBinding会根据现有的布局自动完成所有工作。</p><h3 id="2-在Activity中使用ViewBinding"><a href="#2-在Activity中使用ViewBinding" class="headerlink" title="2.在Activity中使用ViewBinding"></a>2.在Activity中使用ViewBinding</h3><p>首先编写activity_main.xml的布局文件，如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">androidx.constraintlayout.widget.ConstraintLayout</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:app</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:tools</span>=<span class="hljs-string">&quot;http://schemas.android.com/tools&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">tools:context</span>=<span class="hljs-string">&quot;.MainActivity&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/text_view&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;Hello World!&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">app:layout_constraintBottom_toBottomOf</span>=<span class="hljs-string">&quot;parent&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">app:layout_constraintLeft_toLeftOf</span>=<span class="hljs-string">&quot;parent&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">app:layout_constraintRight_toRightOf</span>=<span class="hljs-string">&quot;parent&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">app:layout_constraintTop_toTopOf</span>=<span class="hljs-string">&quot;parent&quot;</span> /&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span><br></code></pre></td></tr></table></figure><p>完成后gradle插件会自动生成一个名为ActivityMainBinding的Java类，在Activity中通过ActivityMainBinding获取Binding实例，如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> &#123;<br>       <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)<br>       <span class="hljs-keyword">val</span> binding = ActivityMainBinding.inflate(layoutInflater)<br>       setContentView(binding.root)<br>       binding.textView.text = <span class="hljs-string">&quot;Hello World&quot;</span><br>   &#125;<br></code></pre></td></tr></table></figure><h3 id="3-ViewBinding与include标签"><a href="#3-ViewBinding与include标签" class="headerlink" title="3.ViewBinding与include标签"></a>3.ViewBinding与include标签</h3><p>在项目开发中，通常我们会使用include标签来简化布局文件，那么在使用了include标签的布局文件中，应该如何使用ViewBinding呢？且看代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs xml">// activity_main.xml<br><span class="hljs-tag">&lt;<span class="hljs-name">androidx.constraintlayout.widget.ConstraintLayout</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:app</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:tools</span>=<span class="hljs-string">&quot;http://schemas.android.com/tools&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">tools:context</span>=<span class="hljs-string">&quot;.MainActivity&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">include</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/include&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">layout</span>=<span class="hljs-string">&quot;@layout/layout_include&quot;</span> /&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span><br><br><br>// layout_include.xml<br><span class="hljs-tag">&lt;<span class="hljs-name">androidx.constraintlayout.widget.ConstraintLayout</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:app</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;match_parent&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/tv_text&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;Hello World!&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">app:layout_constraintBottom_toBottomOf</span>=<span class="hljs-string">&quot;parent&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">app:layout_constraintLeft_toLeftOf</span>=<span class="hljs-string">&quot;parent&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">app:layout_constraintRight_toRightOf</span>=<span class="hljs-string">&quot;parent&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">app:layout_constraintTop_toTopOf</span>=<span class="hljs-string">&quot;parent&quot;</span> /&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span><br></code></pre></td></tr></table></figure><p>上述两个布局文件会分别生成ActivityMainBinding与LayoutIncludeBinding两个Java类，并且ActivityMainBinding类中通过组合依赖了LayoutIncludeBinding类。因此，使用方式如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)<br>        <span class="hljs-keyword">val</span> binding = ActivityMainBinding.inflate(layoutInflater)<br>        setContentView(binding.root)<br>        <span class="hljs-comment">//  从ActivityMainBinding中获取LayoutIncludeBinding</span><br>        <span class="hljs-keyword">val</span> include = binding.include<br>        <span class="hljs-comment">// 通过LayoutIncludeBinding为TextView赋值</span><br>        include.tvText.text = <span class="hljs-string">&quot;Hello World&quot;</span><br>    &#125;<br></code></pre></td></tr></table></figure><p>如果layout_include.xml文件位于子模块，经实践与以上代码的使用方式并无任何差异，但一定要在子模块中开启ViewBinding才行。</p><p>4.ViewBinding在Fragment中的使用<br>在Fragment中使用ViewBinding与Activity中有些差异，这里为了简便，我们使用上述中的activity_main.xml作为Fragment的布局文件，则Fragment的代码如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> binding: ActivityMainBinding<br><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreateView</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">    inflater: <span class="hljs-type">LayoutInflater</span>,</span></span><br><span class="hljs-function"><span class="hljs-params">    container: <span class="hljs-type">ViewGroup</span>?,</span></span><br><span class="hljs-function"><span class="hljs-params">    savedInstanceState: <span class="hljs-type">Bundle</span>?</span></span><br><span class="hljs-function"><span class="hljs-params">)</span></span>: View? &#123;<br>    binding = ActivityMainBinding.inflate(inflater, container, <span class="hljs-literal">false</span>)<br>    <span class="hljs-keyword">return</span> binding.root<br>&#125;<br><br><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onViewCreated</span><span class="hljs-params">(view: <span class="hljs-type">View</span>, savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> &#123;<br>    <span class="hljs-keyword">super</span>.onViewCreated(view, savedInstanceState)<br>    binding.textView.text=<span class="hljs-string">&quot;Hello World&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-ViewBinding在RecyclerView-Adapter中的使用"><a href="#5-ViewBinding在RecyclerView-Adapter中的使用" class="headerlink" title="5.ViewBinding在RecyclerView#Adapter中的使用"></a>5.ViewBinding在RecyclerView#Adapter中的使用</h3><p>布局文件不再贴出，直接看Adapter的代码，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestAdapter</span> : <span class="hljs-type">RecyclerView.Adapter</span>&lt;<span class="hljs-type">TestViewHolder</span>&gt;</span>() &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreateViewHolder</span><span class="hljs-params">(parent: <span class="hljs-type">ViewGroup</span>, viewType: <span class="hljs-type">Int</span>)</span></span>: TestViewHolder &#123;<br>        <span class="hljs-keyword">val</span> binding =<br>            ItemTestBinding.inflate(LayoutInflater.from(parent.context))<br>        <span class="hljs-keyword">return</span> TestViewHolder(binding)<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onBindViewHolder</span><span class="hljs-params">(holder: <span class="hljs-type">TestViewHolder</span>, position: <span class="hljs-type">Int</span>)</span></span> &#123;<br>        holder.binding.textView.text = <span class="hljs-string">&quot;Hello World&quot;</span><br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getItemCount</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Int</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">10</span><br>    &#125;<br><br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestViewHolder</span></span>(<span class="hljs-keyword">var</span> binding: ItemTestBinding) :<br>        RecyclerView.ViewHolder(binding.root)<br>&#125;<br></code></pre></td></tr></table></figure><p>通过以上几个实例可以看到ViewBinding的使用是非常简单的。而ViewBinding的实现原理也并不难，Gradle插件会根据布局文件在项目的build目录下生成相应的ViewBinding类，并且，最终也是通过findViewById来完成View的获取的。具体实现代码不再贴出，感兴趣的同学可以自行查看。</p><h2 id="三、展望与总结"><a href="#三、展望与总结" class="headerlink" title="三、展望与总结"></a>三、展望与总结</h2><p>时代在发展，Android获取View的方式仍在变化。ViewBinding无疑是一个优秀的组件，但它真的是Android开发中获取View的最优方案吗？显然，并不是！因为ViewBinding归根结底还是通过findViewById实现，且需要插件生成相关的Binding类，虽然省去了手动编写，但是ViewBinding仍然没能解决代码冗余的问题。那什么才是findViewById的未来呢？大概最好的findView就是没有findView吧！目前Google正在朝着这一方向努力，正在开发的Jetpack Compose库就是要取代Android的布局文件，彻底消除findViewById。相信在未来某一天，随着Jetpack Compose库的普及，这个旷日持久的findViewById之争也最终会画上一个圆满的句号。</p><h2 id="参考-amp-推荐阅读"><a href="#参考-amp-推荐阅读" class="headerlink" title="参考&amp;推荐阅读"></a>参考&amp;推荐阅读</h2><p><a href="http://tools.android.com/tips/non-constant-fields">Non-constant Fields in Case Labels</a></p><p><a href="https://android-developers.googleblog.com/2020/11/the-future-of-kotlin-android-extensions.html">The future of Kotlin Android Extensions</a></p><p><a href="https://blog.csdn.net/vitaviva/article/details/109912831">Kotlin Android Extensions遭废弃，官方推荐使用ViewBinding</a></p><p><a href="https://juejin.cn/post/6844904088128192525">使用视图绑定替代 findViewById</a></p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ViewBinding</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android 11新特性汇总</title>
    <link href="/2020/11/06/31.Android%2011%20new%20feature/"/>
    <url>/2020/11/06/31.Android%2011%20new%20feature/</url>
    
    <content type="html"><![CDATA[<p>本文内容来自公司项目适配Android-11的调研，内容未加整理。</p><h1 id="以-Android-11-为目标平台的应用"><a href="#以-Android-11-为目标平台的应用" class="headerlink" title="以 Android 11 为目标平台的应用"></a>以 Android 11 为目标平台的应用</h1><p>只有指定了targetVersion=30时需要适配一下内容.</p><h3 id="1-存储与访问机制变更"><a href="#1-存储与访问机制变更" class="headerlink" title="1.存储与访问机制变更"></a>1.存储与访问机制变更</h3><p>Android 中存储可以分为两大类：私有存储和共享存储</p><ul><li>私有存储 (Private Storage) : 每个应用在都拥有自己的私有目录，其它应用看不到，彼此也无法访问到该目录：<ul><li>内部存储私有目录<code> (/data/data/packageName)</code> ；</li><li>外部存储私有目录 <code>(/sdcard/Android/data/packageName)</code>，</li></ul></li><li>共享存储 (Shared Storage) : 存储其他应用可访问文件， 包含媒体文件、文档文件以及其他文件，对应设备DCIM、Pictures、Alarms、Music、Notifications、Podcasts、Ringtones、Movies、Download等目录。</li></ul><h4 id="1-分区存储强制执行"><a href="#1-分区存储强制执行" class="headerlink" title="(1) 分区存储强制执行"></a>(1) 分区存储强制执行</h4><blockquote><p>安卓10中设置requestLegacyExternalStorage为true来修改外部存储空间视图模型（true为 Legacy View，false 为 Filtered View）但是<strong>当您将应用更新为以 Android 11 为目标平台后，将无法使用 <code>requestLegacyExternalStorage</code> 来停用分区存储。</strong></p></blockquote><p>分区存储是指应用对于文件的读写只能在沙盒环境中进行，对于读取媒体文件可以通过MediaStore进行访问。分区存储在Android10中已经开始推行。但在Android10中并没有强制分区存储，在targetSdkVersion = 29的情况下可以通过 ：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">android:requestLegacyExternalStorage=&quot;true&quot;<br></code></pre></td></tr></table></figure><p>设置不强制启动分区存储。从Android11开始，分区存储变为强制执行，当设置了targetSdkVersion = 30，则会强制开启分区存储。但是为了安全，Google提供了以下配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">android:preserveLegacyExternalStorage=&quot;true&quot;<br></code></pre></td></tr></table></figure><p>在覆盖安装的时候可以暂时关闭分区存储。</p><p><strong>1)访问专属目录</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><br><span class="hljs-comment">//分区存储空间</span><br><span class="hljs-keyword">val</span> file = File(context.filesDir, filename)<br><br><span class="hljs-comment">//应用专属外部存储空间</span><br><span class="hljs-keyword">val</span> appSpecificExternalDir = File(context.getExternalFilesDir(), filename)<br><br></code></pre></td></tr></table></figure><p><strong>2)访问公共媒体目录</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><br><span class="hljs-keyword">val</span> cursor = contentResolver.query(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">&quot;<span class="hljs-subst">$&#123;MediaStore.MediaColumns.DATE_ADDED&#125;</span> desc&quot;</span>)<br><span class="hljs-keyword">if</span> (cursor != <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">while</span> (cursor.moveToNext()) &#123;<br>        <span class="hljs-keyword">val</span> id = cursor.getLong(cursor.getColumnIndexOrThrow(MediaStore.MediaColumns._ID))<br>        <span class="hljs-keyword">val</span> uri = ContentUris.withAppendedId(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, id)<br>        println(<span class="hljs-string">&quot;image uri is <span class="hljs-variable">$uri</span>&quot;</span>)<br>    &#125;<br>    cursor.close()<br>&#125;<br><br></code></pre></td></tr></table></figure><p>Environment.getExternalStoragePublicDirectory(“”)方法在Android11中已被弃用，使用该方法会导致程序报错。</p><h4 id="2-SAF访问框架（Storage-Access-Framework"><a href="#2-SAF访问框架（Storage-Access-Framework" class="headerlink" title="(2) SAF访问框架（Storage Access Framework)"></a>(2) SAF访问框架（Storage Access Framework)</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> intent = Intent(Intent.ACTION_OPEN_DOCUMENT)<br>  intent.addCategory(Intent.CATEGORY_OPENABLE)<br>  intent.type = <span class="hljs-string">&quot;image/*&quot;</span><br>  startActivityForResult(intent, <span class="hljs-number">100</span>)<br><br>  <span class="hljs-meta">@RequiresApi(Build.VERSION_CODES.KITKAT)</span><br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onActivityResult</span><span class="hljs-params">(requestCode: <span class="hljs-type">Int</span>, resultCode: <span class="hljs-type">Int</span>, <span class="hljs-keyword">data</span>: <span class="hljs-type">Intent</span>?)</span></span> &#123;<br>      <span class="hljs-keyword">super</span>.onActivityResult(requestCode, resultCode, <span class="hljs-keyword">data</span>)<br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">data</span> == <span class="hljs-literal">null</span> || resultCode != Activity.RESULT_OK) <span class="hljs-keyword">return</span><br>      <span class="hljs-keyword">if</span> (requestCode == <span class="hljs-number">100</span>) &#123;<br>          <span class="hljs-keyword">val</span> uri = <span class="hljs-keyword">data</span>.<span class="hljs-keyword">data</span><br>          println(<span class="hljs-string">&quot;image uri is <span class="hljs-variable">$uri</span>&quot;</span>)<br>      &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><p>同时，Android11中还提供了两个Intent入口：</p><ul><li><p>调用<code>ACTION_MANAGE_STORAGE intent</code> 操作检查可用空间。</p></li><li><p>调用<code>ACTION_CLEAR_APP_CACHE intent</code> 操作清除所有缓存。</p></li></ul><p>对于像手机管理器的APP可以通过这两个Intent管理APP的缓存。</p><h4 id="3-所有文件访问权限"><a href="#3-所有文件访问权限" class="headerlink" title="(3) 所有文件访问权限"></a>(3) 所有文件访问权限</h4><blockquote><p>针对文件管理器以及一些备份类的应用，它们需要获得共享存储的更广泛的访问权限。Android 11 里将会引入一个特别的权限叫做 <strong>MANAGE_EXTERNAL_STORAGE</strong>，该权限将授权读写所有共享存储内容，这也将同时包含非媒体类型的文件。但是获得这个权限的应用还是<strong>无法访问</strong>其他应用的应用专属目录 (app-specific directory)，无论是外部存储还是内部存储。</p></blockquote><p>使用MANAGE_EXTERNAL_STORAGE权限：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.MANAGE_EXTERNAL_STORAGE&quot;</span> /&gt;</span>     <br></code></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><br><span class="hljs-keyword">val</span> intent = Intent()    <br><br>intent.action= Settings.ACTION_MANAGE_ALL_FILES_ACCESS_PERMISSION    <br><br>startActivity(intent)     <span class="hljs-comment">//判断是否获取MANAGE_EXTERNAL_STORAGE权限：    </span><br><br><span class="hljs-keyword">val</span> isHasStoragePermission= Environment.isExternalStorageManager()<br><br></code></pre></td></tr></table></figure><h4 id="4-媒体文件访问权限"><a href="#4-媒体文件访问权限" class="headerlink" title="(4) 媒体文件访问权限"></a>(4) 媒体文件访问权限</h4><blockquote><p>Android 10 中要求所有应用都使用 MediaStore API 来访问照片、视频和音乐文件，我们也将继续秉承这个原则。但是我们也知道，很多深度依赖基于原始文件路径 API 的应用和第三方库是很难切换到使用文件描述符 (File Descriptor) 的。因此在 Android 11 里，依赖原始文件路径的 API 和库<a href="https://link.zhihu.com/?target=https://developer.android.google.cn/preview/privacy/storage%23media-files-raw-paths">可以再次使用</a>了。您需要在应用的 Manifest 文件里添加 requestLegacyExternalStorage 属性，以保证 Android 10 的用户也可以使用该特性。</p><p>在实际的运行中，依赖原始文件路径的 I/O 请求会被重定向到使用 MediaStore API，当使用这种方式访问本应用存储空间之外的文件时，这次重定向会造成性能影响。而且直接使用原始文件路径，并不会比使用 MediaStore API 有更多优势，因此我们强烈建议直接使用 MediaStore API。</p><p>在 Android 10 中，应用在对每一个文件请求编辑或删除时都必须得到用户的确认。而在 Android 11 中，应用可以一次请求<a href="https://link.zhihu.com/?target=https://developer.android.com/preview/privacy/storage%23media-file-access">修改或者删除多个媒体文件</a>。系统的默认图库应用 (Gallery) 将不再展示这些对话框。我们希望这项改进能够使用户体验更加顺畅。</p></blockquote><p><strong>1) 执行批量操作</strong></p><p>Android 11 向 <code>MediaStore API</code> 中添加了多种方法，用于简化特定媒体文件更改流程（例如在原位置编辑照片），分别是：</p><ul><li><p><code> createWriteRequest()</code> 用户向应用授予对指定媒体文件组的写入访问权限的请求。</p></li><li><p><code>createFavoriteRequest()</code>用户将设备上指定的媒体文件标记为“收藏”的请求。对该文件具有读取访问权限的任何应用都可以看到用户已将该文件标记为“收藏”。</p></li><li><p>createTrashRequest()用户将指定的媒体文件放入设备垃圾箱的请求。垃圾箱中的内容会在系统定义的时间段后被永久删除。</p></li><li><p>createDeleteRequest()用户立即永久删除指定的媒体文件（而不是先将其放入垃圾箱）的请求。</p></li></ul><p>例如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> urisToModify = listOf(uri,uri,...)<br><span class="hljs-keyword">val</span> editPendingIntent = MediaStore.createWriteRequest(contentResolver,<br>        urisToModify)<br><br><span class="hljs-comment">// Launch a system prompt requesting user permission for the operation.</span><br>startIntentSenderForResult(editPendingIntent.intentSender, EDIT_REQUEST_CODE,<br>    <span class="hljs-literal">null</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<br><br><br><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onActivityResult</span><span class="hljs-params">(requestCode: <span class="hljs-type">Int</span>, resultCode: <span class="hljs-type">Int</span>,</span></span><br><span class="hljs-function"><span class="hljs-params">                 <span class="hljs-keyword">data</span>: <span class="hljs-type">Intent</span>?)</span></span> &#123;<br>    <span class="hljs-keyword">when</span> (requestCode) &#123;<br>        EDIT_REQUEST_CODE -&gt;<br>            <span class="hljs-keyword">if</span> (resultCode == Activity.RESULT_OK) &#123;<br>                <span class="hljs-comment">/* Edit request granted; proceed. */</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">/* Edit request not granted; explain to the user. */</span><br>            &#125;<br>    &#125;<br>&#125;    <br><br></code></pre></td></tr></table></figure><p><strong>2）直接文件路径和原生库访问文件</strong></p><p>Android11又恢复了使用<code>直接文件路径</code>访问访问媒体文件！也就是除了 <code>MediaStore API</code>之外还有两种方式可以访问媒体文件：</p><ul><li>File API。</li><li>原生库，例如 fopen()。</li></ul><h4 id="5-文档访问权限"><a href="#5-文档访问权限" class="headerlink" title="(5) 文档访问权限"></a>(5) 文档访问权限</h4><p>在分区存储权限中说过可以使用SAF来访问公共目录，但Android11中部分目录不能访问，如下：</p><p>无法再使用 <code>ACTION_OPEN_DOCUMENT_TREE intent</code> 操作请求访问以下目录：</p><ul><li>内部存储卷的根目录。</li><li>设备制造商认为可靠的各个 SD 卡卷的根目录，无论该卡是模拟卡还是可移除的卡。可靠的卷是指应用在大多数情况下可以成功访问的卷。</li><li>Download 目录。</li></ul><p>无法再使用 <code>ACTION_OPEN_DOCUMENT_TREE</code> 或 <code>ACTION_OPEN_DOCUMENT intent</code> 操作请求用户从以下目录中选择单独的文件：</p><ul><li>Android/data/ 目录及其所有子目录。</li><li>Android/obb/ 目录及其所有子目录。</li></ul><h3 id="2-位置权限更新"><a href="#2-位置权限更新" class="headerlink" title="2.位置权限更新"></a>2.位置权限更新</h3><h4 id="1-单次访问权限"><a href="#1-单次访问权限" class="headerlink" title="(1)单次访问权限"></a>(1)单次访问权限</h4><blockquote><p>在 Android 11 及更高版本中，每当应用请求在前台访问位置信息时，系统权限对话框都包含一个名为<strong>仅限这一次</strong>的选项。通过这一选项，用户可以更好地控制应用何时有权访问位置信息。</p></blockquote><p>####(2) 在后台访问位置信息的权限</p><blockquote><p>Android 11 更改了应用中的功能获取后台位置信息访问权限的方式。</p></blockquote><p>（1）从Android10系统开始，需要申请后台位置权限（ACCESS_BACKGROUND_LOCATION），并且只有用户点了始终允许之后才能获得后台位置权限。Android11设备上对于后台位置权限再次收紧，表现在系统对话框上不在提示始终允许字样，而是提供了位置权限设置入口，需要用户到设置页面允许后才能获得后台位置权限。</p><p>（2）在targetVersion小于30时候，可以前台位置权限与后台位置权限一起申请，并且对话框提供了文字说明，表示需要随时获取用户位置信息。，进入设置选择始终允许即可。但targetVersion设置为30时，必须单独申请后台位置权限，而且必须在获取前台位置权限之后，并且无任何提示，需要开发者自行设置提示样式。</p><h3 id="3-电话号码相关权限"><a href="#3-电话号码相关权限" class="headerlink" title="3.电话号码相关权限"></a>3.电话号码相关权限</h3><blockquote><p>Android11更改了读取电话号码时与电话相关的权限。如果您的应用以 Android 11 为目标平台，并且需要访问以下列表中显示的电话号码 API，则必须请求 <code>READ_PHONE_NUMBERS</code>权限，而不是 <code>READ_PHONE_STATE</code> 权限。</p></blockquote><ul><li><a href="https://developer.android.com/reference/kotlin/android/telephony/TelephonyManager?hl=zh-cn#getline1number"><code>TelephonyManager</code></a> 类和 <a href="https://developer.android.com/reference/kotlin/android/telecom/TelecomManager?hl=zh-cn#getline1number"><code>TelecomManager</code></a> <code>getLine1Number()</code> 方法</li><li><a href="https://developer.android.com/reference/kotlin/android/telephony/TelephonyManager?hl=zh-cn"><code>TelephonyManager</code></a> 类中的 <code>getMsisdn()</code> 方法</li></ul><p>也就是当用到这两个API的时候，原来的<code>READ_PHONE_STATE</code>权限不管用了，需要<code>READ_PHONE_NUMBERS</code>权限才行。</p><p>需要做的改动：</p><ol><li>更改 <code>READ_PHONE_STATE</code> 的声明，以使您的应用仅在 Android 10（API 级别 29）及更低版本中使用该权限。</li><li>添加 <code>READ_PHONE_NUMBERS</code> 权限。</li></ol><p>清单文件配置如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><br><span class="hljs-tag">&lt;<span class="hljs-name">manifest</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- Grants the READ_PHONE_STATE permission only on devices that run</span><br><span class="hljs-comment">         Android 10 (API level 29) and lower. --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;READ_PHONE_STATE&quot;</span></span><br><span class="hljs-tag">                     <span class="hljs-attr">android:maxSdkVersion</span>=<span class="hljs-string">&quot;29&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;READ_PHONE_NUMBERS&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">manifest</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="4-自动重置权限"><a href="#4-自动重置权限" class="headerlink" title="4.自动重置权限"></a>4.自动重置权限</h3><p>如果用户几个月未与应用互动，系统会自动重置应用的敏感权限。</p><blockquote><p>如果应用以 Android 11 为目标平台并且数月未使用，系统会通过自动重置用户已授予应用的运行时敏感权限来保护用户数据。此操作与用户在系统设置中查看权限并将应用的访问权限级别更改为拒绝的做法效果一样。如果应用已遵循有关在运行时请求权限的最佳做法，那么您不必对应用进行任何更改。这是因为，当用户与应用中的功能互动时，您应该会验证相关功能是否具有所需权限。</p></blockquote><p><strong>请求用户停用自动重置功能</strong></p><p>如果需要，您可以要求用户阻止系统重置应用的权限。如果用户希望应用主要在后台运行，即使用户不与应用互动，应用也能正常工作，那么此做法就非常有用。</p><h3 id="5-应用打包与安装"><a href="#5-应用打包与安装" class="headerlink" title="5.应用打包与安装"></a>5.应用打包与安装</h3><h4 id="1-压缩的资源文件"><a href="#1-压缩的资源文件" class="headerlink" title="(1) 压缩的资源文件"></a>(1) 压缩的资源文件</h4><blockquote><p>如果以 Android 11（API 级别 30）或更高版本为目标平台的应用包含压缩的 <code>resources.arsc</code> 文件或者如果此文件未按 4 字节边界对齐，应用将无法安装。如果存在其中任意一种情况，系统将无法对此文件进行内存映射。无法进行内存映射的资源表必须读入 RAM 中的缓冲区，从而给系统造成不必要的内存压力，并大大增加设备的 RAM 使用量。</p></blockquote><h4 id="2-需要使用V2签名"><a href="#2-需要使用V2签名" class="headerlink" title="(2) 需要使用V2签名"></a>(2) 需要使用V2签名</h4><p>对于以 Android 11（API 级别 30）为目标平台，且目前仅使用 APK 签名方案 v1 签名的应用，现在还必须使用 APK 签名方案 v2或更高版本进行签名。用户无法在搭载 Android 11 的设备上安装或更新仅通过 APK 签名方案 v1 签名的应用。</p><h3 id="6-软件包可见性"><a href="#6-软件包可见性" class="headerlink" title="6.软件包可见性"></a>6.软件包可见性</h3><p>当应用查询设备上已安装应用的列表时，系统会过滤返回的列表。</p><blockquote><p>Android 11 更改了应用查询用户已在设备上安装的其他应用以及与之交互的方式。使用新的  元素，应用可以定义一组自身可访问的其他应用。通过告知系统应向您的应用显示哪些其他应用，此元素有助于鼓励最小权限原则。此外，此元素还可帮助 Google Play 等应用商店评估应用为用户提供的隐私权和安全性。</p></blockquote><p>也就是说，<code>Android11中</code>，如果你想去获取其他应用的信息，比如包名，名称等等，不能直接获取了，必须在清单文件中添加<code>&lt;queries&gt;</code>元素，告知系统你要获取哪些应用信息或者哪一类应用。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><br><span class="hljs-keyword">val</span> pm = <span class="hljs-keyword">this</span>.packageManager<br>   <span class="hljs-keyword">val</span> listAppcations: List&lt;ApplicationInfo&gt; = pm<br>           .getInstalledApplications(PackageManager.GET_META_DATA)<br>   <span class="hljs-keyword">for</span> (app <span class="hljs-keyword">in</span> listAppcations) &#123;<br>       Log.e(<span class="hljs-string">&quot;lz&quot;</span>,app.packageName)<br>   &#125;<br><br></code></pre></td></tr></table></figure><p>上述代码在Android11上只能获取到自己APP的信息，查询不到其他应用信息。如果需要查询其他APP，需要添加<queries>元素，有两种方式：</p><p>（1）元素中加入具体包名</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><br><span class="hljs-tag">&lt;<span class="hljs-name">manifest</span> <span class="hljs-attr">package</span>=<span class="hljs-string">&quot;com.example.game&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">queries</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">package</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;com.example.store&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">package</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;com.example.services&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">queries</span>&gt;</span><br>    ...<br><span class="hljs-tag">&lt;/<span class="hljs-name">manifest</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>（2）元素中加入固定过滤的<code>intent</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">manifest</span> <span class="hljs-attr">package</span>=<span class="hljs-string">&quot;com.example.game&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">queries</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">intent</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">action</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.intent.action.SEND&quot;</span> /&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">data</span> <span class="hljs-attr">android:mimeType</span>=<span class="hljs-string">&quot;image/jpeg&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">intent</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">queries</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">manifest</span>&gt;</span><br></code></pre></td></tr></table></figure><p>同时，Google还添加了QUERY_ALL_PACKAGES的权限，需要在清单文件中加入该权限后可以获取到APP的所有应用列表。</p><h3 id="7-5G功能支持"><a href="#7-5G功能支持" class="headerlink" title="7. 5G功能支持"></a>7. 5G功能支持</h3><h4 id="1-针对-5G-的模拟器支持"><a href="#1-针对-5G-的模拟器支持" class="headerlink" title="(1) 针对 5G 的模拟器支持"></a>(1) 针对 5G 的模拟器支持</h4><blockquote><p>Android 11 添加了 <a href="https://developer.android.com/about/versions/11/features/5g">5G API</a>，使您的应用能够添加各种先进的功能。如需在添加这些功能时对其进行测试，您可以使用 <a href="https://developer.android.com/studio/run/emulator">Android SDK 模拟器</a>的新功能。这项新功能是在模拟器版本 30.0.22 中添加的。选择 5G 网络设置可将 <a href="https://developer.android.com/reference/android/telephony/TelephonyDisplayInfo"><code>TelephonyDisplayInfo</code></a> 设为 <a href="https://developer.android.com/reference/android/telephony/TelephonyDisplayInfo#OVERRIDE_NETWORK_TYPE_NR_NSA"><code>OVERRIDE_NETWORK_TYPE_NR_NSA</code></a>，修改带宽估算值，还允许您设置按流量计费性，以验证您的应用是否会对 <a href="https://developer.android.com/reference/android/net/NetworkCapabilities#NET_CAPABILITY_TEMPORARILY_NOT_METERED"><code>NET_CAPABILITY_TEMPORARILY_NOT_METERED</code></a> 状态的变化做出适当的响应。</p></blockquote><h4 id="2-5G功能"><a href="#2-5G功能" class="headerlink" title="(2) 5G功能"></a>(2) 5G功能</h4><p>Android 11 引入了以下功能变更和增强功能</p><ul><li>按流量计费性</li><li>5G检测</li><li>带宽估算</li></ul><p><strong>检查按流量计费性</strong></p><p><a href="https://developer.android.com/reference/android/net/NetworkCapabilities#NET_CAPABILITY_TEMPORARILY_NOT_METERED"><code>NET_CAPABILITY_TEMPORARILY_NOT_METERED</code></a> 是 Android 11 中添加的一项功能，可根据移动网络运营商提供的信息，告知您正在使用的网络是否不按流量计费。</p><p>该新标记与 <a href="https://developer.android.com/reference/android/net/NetworkCapabilities#NET_CAPABILITY_NOT_METERED"><code>NET_CAPABILITY_NOT_METERED</code></a> 一起使用。该现有标记指示网络是否始终不按流量计费，并且同时适用于 WLAN 和移动网络连接。</p><p>这两个标记之间的区别在于，在网络类型不变的情况下，<code>NET_CAPABILITY_TEMPORARILY_NOT_METERED</code> 可能会发生变化。以 Android 11 为目标平台的应用可以使用 <code>NET_CAPABILITY_TEMPORARILY_NOT_METERED</code> 标记。在搭载 Android 9 及更低版本的设备上，操作系统不会报告该标记。对于在 Android 10 上运行的应用，此标记可能可用，具体取决于运行应用的设备。</p><p>一旦确定当前网络暂时或永久不按流量计费，您便可以显示分辨率更高的内容（如 4k 视频）、上传日志、备份文件，以及主动下载内容。</p><p>使用在网络回调中收到的 <code>NetworkCapabilites</code> 对象来检查以下代码的输出：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> manager = getSystemService(CONNECTIVITY_SERVICE) <span class="hljs-keyword">as</span> ConnectivityManager<br>     manager.registerDefaultNetworkCallback(<span class="hljs-keyword">object</span> : ConnectivityManager.NetworkCallback() &#123;<br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCapabilitiesChanged</span><span class="hljs-params">(network: <span class="hljs-type">Network</span>, networkCapabilities: <span class="hljs-type">NetworkCapabilities</span>)</span></span> &#123;<br>          <span class="hljs-keyword">super</span>.onCapabilitiesChanged(network, networkCapabilities)<br>            <span class="hljs-comment">//true 代表连接不按流量计费</span><br>            <span class="hljs-keyword">val</span> isNotFlowPay=networkCapabilities.hasCapability(NetworkCapabilities.NET_CAPABILITY_NOT_METERED) ||<br>                            networkCapabilities.hasCapability(NetworkCapabilities.NET_CAPABILITY_TEMPORARILY_NOT_METERED)<br>          &#125;<br>    &#125;)<br><br></code></pre></td></tr></table></figure><p>如果值为 true，则可以将网络视为不按流量计费。</p><p>注册网络回调</p><p>使用 <a href="https://developer.android.com/reference/android/net/ConnectivityManager#registerDefaultNetworkCallback(android.net.ConnectivityManager.NetworkCallback)"><code>ConnectivityManager.registerDefaultNetworkCallback()</code></a> 注册一个网络回调，以监听 <code>NetworkCapabilities</code> 何时发生更改。您可以通过替换 <code>NetworkCallback</code> 中的 [<code>onCapabilitiesChanged()</code>](<a href="https://developer.android.com/reference/android/net/ConnectivityManager.NetworkCallback#onCapabilitiesChanged">https://developer.android.com/reference/android/net/ConnectivityManager.NetworkCallback#onCapabilitiesChanged</a>(android.net.Network, android.net.NetworkCapabilities)) 方法来检测 <code>NetworkCapabilities</code> 的更改。</p><p><code>registerDefaultNetworkCallback()</code> 会使注册的回调在注册后立即触发，从而为应用提供有关当前状态的信息。将来的回调对于应用在状态从不按流量计费更改为按流量计费或者从按流量计费更改为不按流量计费时采取适当的措施至关重要。</p><p><strong>5G检测</strong></p><p>从 Android 11 开始，可以使用基于回调的 API 调用来检测设备是否连接到了 5G 网络。可以检查连接的是 5G NR（独立）网络，还是 NSA（非独立）网络。</p><p>通过<code>TelephonyManager</code>的监听方法并传入 <a href="https://developer.android.com/reference/android/telephony/PhoneStateListener#LISTEN_DISPLAY_INFO_CHANGED"><code>LISTEN_DISPLAY_INFO_CHANGED</code></a>，以确定用户是否连接到了 5G 网络。替换 <a href="https://developer.android.com/reference/android/telephony/PhoneStateListener#onDisplayInfoChanged(android.telephony.TelephonyDisplayInfo)"><code>onDisplayInfoChanged()</code></a> 方法，以确定应用连接到的网络类型：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><br><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getNetworkType</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">val</span> tManager = getSystemService(Context.TELEPHONY_SERVICE) <span class="hljs-keyword">as</span> TelephonyManager<br>        tManager.listen(<span class="hljs-keyword">object</span> : PhoneStateListener() &#123;<br><br>            <span class="hljs-meta">@RequiresApi(Build.VERSION_CODES.R)</span><br>            <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onDisplayInfoChanged</span><span class="hljs-params">(telephonyDisplayInfo: <span class="hljs-type">TelephonyDisplayInfo</span>)</span></span> &#123;<br>                <span class="hljs-keyword">if</span> (ActivityCompat.checkSelfPermission(<span class="hljs-keyword">this</span><span class="hljs-symbol">@Android11Test2Activity</span>, android.Manifest.permission.READ_PHONE_STATE) != android.content.pm.PackageManager.PERMISSION_GRANTED) &#123;<br>                    <span class="hljs-keyword">return</span><br>                &#125;<br>                <span class="hljs-keyword">super</span>.onDisplayInfoChanged(telephonyDisplayInfo)<br><br>                <span class="hljs-keyword">when</span>(telephonyDisplayInfo.networkType) &#123;<br>                    TelephonyDisplayInfo.OVERRIDE_NETWORK_TYPE_LTE_ADVANCED_PRO -&gt; showToast(<span class="hljs-string">&quot;高级专业版 LTE (5Ge)&quot;</span>)<br>                    TelephonyDisplayInfo.OVERRIDE_NETWORK_TYPE_NR_NSA -&gt; showToast(<span class="hljs-string">&quot;NR (5G) - 5G Sub-6 网络&quot;</span>)<br>                    TelephonyDisplayInfo.OVERRIDE_NETWORK_TYPE_NR_NSA_MMWAVE -&gt; showToast(<span class="hljs-string">&quot;5G+/5G UW - 5G mmWave 网络&quot;</span>)<br>                    <span class="hljs-keyword">else</span> -&gt; showToast(<span class="hljs-string">&quot;other&quot;</span>)<br>                &#125;<br>            &#125;<br><br>        &#125;, PhoneStateListener.LISTEN_DISPLAY_INFO_CHANGED)<br>    &#125;<br><br></code></pre></td></tr></table></figure><table><thead><tr><th align="left"><strong>返回类型</strong></th><th align="left"><strong>网络</strong></th></tr></thead><tbody><tr><td align="left"><a href="https://developer.android.com/reference/android/telephony/TelephonyDisplayInfo#OVERRIDE_NETWORK_TYPE_LTE_ADVANCED_PRO"><code>OVERRIDE_NETWORK_TYPE_LTE_ADVANCED_PRO</code></a></td><td align="left">高级专业版 LTE (5Ge)</td></tr><tr><td align="left"><a href="https://developer.android.com/reference/android/telephony/TelephonyDisplayInfo#OVERRIDE_NETWORK_TYPE_NR_NSA"><code>OVERRIDE_NETWORK_TYPE_NR_NSA</code></a></td><td align="left">NR (5G) - 5G Sub-6 网络</td></tr><tr><td align="left"><a href="https://developer.android.com/reference/android/telephony/TelephonyDisplayInfo#OVERRIDE_NETWORK_TYPE_NR_NSA_MMWAVE"><code>OVERRIDE_NETWORK_TYPE_NR_NSA_MMWAVE</code></a></td><td align="left">5G+/5G UW - 5G mmWave 网络</td></tr></tbody></table><p><strong>带宽估测</strong></p><p>带宽估测使用您在确定按流量计费性时使用的 <code>NetworkCapabilities</code> 对象。您可以使用该对象获取带宽估测值。</p><p>带宽估测方法 <a href="https://developer.android.com/reference/android/net/NetworkCapabilities#getLinkDownstreamBandwidthKbps()"><code>getLinkDownstreamBandwidthKbps()</code></a> 和 <a href="https://developer.android.com/reference/android/net/NetworkCapabilities#getLinkUpstreamBandwidthKbps()"><code>getLinkUpstreamBandwidthKbps()</code></a> 的可靠性和准确性在 Android 11 中得到了改进，这是因为，为了适应 5G 而进行了框架支持的升级和平台/调制解调器问题修复。</p><p>带宽默认值仅提供关于应用启动的指导。这应该可以帮助您处理“空闲时启动”的情况。您的应用应衡量用户开始与其互动后的性能，并动态地调整其流式传输行为。例如，您可以根据启动时的带宽估测来选择要提供的视频分辨率。随着用户使用应用，继续检查估测值；随着其连接类型和强度的变化，相应地调整应用的行为。</p><h3 id="8-媒体Intent打开相机"><a href="#8-媒体Intent打开相机" class="headerlink" title="8.媒体Intent打开相机"></a>8.媒体Intent打开相机</h3><blockquote><p>从Android11开始，只有预装的系统相机可以相应以下Intent事件：</p></blockquote><ul><li>android.media.action.VIDEO_CAPTURE</li><li>android.media.action.IMAGE_CAPTURE</li><li>android.media.action.IMAGE_CAPTURE_SECURE</li></ul><p>也就是使用Intent将无法唤起第三方相机，如果需要打开第三方相机官方给的建议是可以通过为<code>intent</code>设置软件包名称或组件来使这些intent变得明确。</p><h3 id="9-前台服务类型"><a href="#9-前台服务类型" class="headerlink" title="9.前台服务类型"></a>9.前台服务类型</h3><blockquote><p>从 Android 9 开始，应用仅限于在前台访问摄像头和麦克风。为了进一步保护用户，Android 11 更改了前台服务访问摄像头和麦克风相关数据的方式。如果您的应用以 Android 11 为目标平台并且在某项前台服务中访问这些类型的数据，您需要在该前台服务的声明的 foregroundServiceType 属性中添加新的 camera 和 microphone 类型。</p></blockquote><p>在Android10的时候，对于前台定位服务就必须加上<code>android:foregroundServiceType=&quot;location&quot;</code>，现在Android11上又增加了两个权限限制，一个是摄像头一个是麦克风。</p><p>所以总结下来就是，应用某项前台服务需要访问<code>位置信息、摄像头和麦克风</code>，那么就要在清单文件中这样添加：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><br><span class="hljs-tag">&lt;<span class="hljs-name">manifest</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">service</span> <span class="hljs-attr">...</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:foregroundServiceType</span>=<span class="hljs-string">&quot;location|camera|microphone&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">manifest</span>&gt;</span><br></code></pre></td></tr></table></figure><p>有的朋友可能测试发现，不加<code>foregroundServiceType</code>的前提下，让<code>Activity</code>启动了一个前台服务，并在服务里去获取定位，竟然可以获取到定位信息，难道官方说错了？</p><p>其实这是因为你并没有让前台服务单独运行，你可以试着在<code>Activity</code>启动Service后，进入Home界面，然后过几秒再请求位置，就请求不到了。但是不会崩溃，因为这个被系统设置的权限类别为<code>MODE_IGNORED</code>，也就是静默失败模式。</p><p>所以为了保险起见，只要前台服务涉及到了这三个功能，就在清单文件加上<code>android:foregroundServiceType</code></p><h3 id="10-Toast行为变更"><a href="#10-Toast行为变更" class="headerlink" title="10.Toast行为变更"></a>10.Toast行为变更</h3><h3 id="1-自定义Toast被屏蔽"><a href="#1-自定义Toast被屏蔽" class="headerlink" title="(1)自定义Toast被屏蔽"></a>(1)自定义Toast被屏蔽</h3><blockquote><p>出于安全方面的考虑，同时也为了保持良好的用户体验，如果包含自定义视图的消息框是以 Android 11 或更高版本为目标平台的应用从后台发送的，系统会屏蔽这些消息框。请注意，仍允许使用文本消息框；此类消息框是使用 <a href="https://developer.android.com/reference/kotlin/android/widget/Toast#maketext"><code>Toast.makeText()</code></a> 创建的，并不调用 <a href="https://developer.android.com/reference/kotlin/android/widget/Toast#setview"><code>setView()</code></a>。</p></blockquote><p>如果您的应用仍尝试从后台发布包含自定义视图的消息框，系统不会向用户显示相应的消息，而是会在 logcat 中记录以下消息：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><br>W/NotificationService: Blocking custom toast from <span class="hljs-keyword">package</span> \  &lt;<span class="hljs-keyword">package</span>&gt; due to <span class="hljs-keyword">package</span> <span class="hljs-keyword">not</span> in the foreground<br></code></pre></td></tr></table></figure><p>如果应用在后台时弹出自定义toast则会有相关警告，但不会crash。</p><h4 id="2-消息框回调"><a href="#2-消息框回调" class="headerlink" title="(2) 消息框回调"></a>(2) 消息框回调</h4><p>如果您希望在消息框（文本消息框或自定义消息框）出现或消失时收到通知，请使用 Android 11 中添加的 <a href="https://developer.android.com/reference/android/widget/Toast#addCallback(android.widget.Toast.Callback)"><code>addCallback()</code></a> 方法。</p><h3 id="11-allowBackup"><a href="#11-allowBackup" class="headerlink" title="11.allowBackup"></a>11.allowBackup</h3><blockquote><p>如果您的应用以 Android 11 为目标平台，您将无法再使用 allowBackup 属性停用应用文件的设备到设备迁移。系统会自动启用此功能。不过，即使您的应用以 Android 11 为目标平台，您也可以通过将 allowBackup 属性设置为 false 来停用应用文件的云端备份和恢复。</p></blockquote><p><strong>android:allowBackup属性</strong></p><ul><li>代表是否允许应用参与备份和恢复基础架构。如果将此属性设为 false，则永远不会为该应用执行<code>备份或恢复</code>，即使是采用全系统备份方法也不例外（这种备份方法通常会通过 adb 保存所有应用数据）。此属性的默认值为 true。</li></ul><p>所以这里是不能停用文件的<code>设备到设备</code>迁移，但是可以停用<code>云端备份和恢复</code></p><h2 id="二、行为变更：所有应用"><a href="#二、行为变更：所有应用" class="headerlink" title="二、行为变更：所有应用"></a>二、行为变更：所有应用</h2><p>此模块的修改内容针对所有项目在<code>Android11</code>手机上存在的改动，与<code>targetSdkVersion</code>无关。</p><h3 id="1-数据访问审核"><a href="#1-数据访问审核" class="headerlink" title="1.数据访问审核"></a>1.数据访问审核</h3><blockquote><p>为了让应用及其依赖项访问用户私密数据的过程更加透明，Android 11 引入了数据访问审核功能。借助此流程得出的见解，您可以更好地识别和纠正可能出现的意外数据访问。</p></blockquote><p>哪些范畴属于用户私密数据呢？其实就是危险权限的调用，所以这个功能就是提供了可以监听危险权限调用的监听。主要涉及到的方法是<code>AppOpsManager.OnOpNotedCallback</code>。无论是应用本身，还是依赖库或者SDK中的代码，只要访问到私密数据（危险权限），都会回调给我们。</p><p>对于<strong>工程庞大或者使用较多SDK</strong>的工程比较适合用上这个功能，让自己应用的私有数据管理更加<code>透明规范</code>，否则对于私有数据的使用和管理并不全面和方便。而且还可以对权限使用<code>添加归因</code>，也就是一个tag，标志权限用到了什么地方。方便回调的时候知晓哪里使用了<code>私有数据</code>。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><br><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> &#123;<br>    <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)<br>    setContentView(R.layout.activity_test1)<br><br>    <span class="hljs-comment">//创建归因（attribute）  </span><br>    attributionContext = createAttributionContext(<span class="hljs-string">&quot;shareLocation&quot;</span>)<br><br>    <span class="hljs-comment">//监听事件</span><br>    <span class="hljs-keyword">val</span> appOpsCallback = <span class="hljs-keyword">object</span> : AppOpsManager.OnOpNotedCallback() &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">logPrivateDataAccess</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">                opCode: <span class="hljs-type">String</span>, attributionTag: <span class="hljs-type">String</span>, trace: <span class="hljs-type">String</span>)</span></span> &#123;<br>            Log.i(TAG, <span class="hljs-string">&quot;Private data accessed. &quot;</span> +<br>                    <span class="hljs-string">&quot;Operation: <span class="hljs-variable">$opCode</span>\n &quot;</span> +<br>                    <span class="hljs-string">&quot;Attribution Tag:<span class="hljs-variable">$attributionTag</span>\nStack Trace:\n<span class="hljs-variable">$trace</span>&quot;</span>)<br>        &#125;<br><br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onNoted</span><span class="hljs-params">(syncNotedAppOp: <span class="hljs-type">SyncNotedAppOp</span>)</span></span> &#123;<br>            syncNotedAppOp.attributionTag?.let &#123;<br>                logPrivateDataAccess(syncNotedAppOp.op,<br>                        it,<br>                        Throwable().stackTrace.toString())<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onSelfNoted</span><span class="hljs-params">(syncNotedAppOp: <span class="hljs-type">SyncNotedAppOp</span>)</span></span> &#123;<br>            syncNotedAppOp.attributionTag?.let &#123;<br>                logPrivateDataAccess(syncNotedAppOp.op,<br>                        it,<br>                        Throwable().stackTrace.toString())<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onAsyncNoted</span><span class="hljs-params">(asyncNotedAppOp: <span class="hljs-type">AsyncNotedAppOp</span>)</span></span> &#123;<br>            asyncNotedAppOp.attributionTag?.let &#123;<br>                logPrivateDataAccess(asyncNotedAppOp.op,<br>                        it,<br>                        asyncNotedAppOp.message)<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//开启私密数据监听</span><br>    <span class="hljs-keyword">val</span> appOpsManager =<br>            getSystemService(AppOpsManager::<span class="hljs-keyword">class</span>.java) <span class="hljs-keyword">as</span> AppOpsManager<br>    appOpsManager.setOnOpNotedCallback(mainExecutor, appOpsCallback)<br><br>    btn1.setOnClickListener &#123;<br>        getLocation()<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getLocation</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> locationManager = attributionContext.getSystemService(<br>            LocationManager::<span class="hljs-keyword">class</span>.java) <span class="hljs-keyword">as</span> LocationManager<br>    <span class="hljs-keyword">if</span> (!checkPermission()) &#123;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <span class="hljs-keyword">val</span> location: Location? = locationManager.getLastKnownLocation(LocationManager.NETWORK_PROVIDER)<br>    <span class="hljs-keyword">if</span> (location != <span class="hljs-literal">null</span>) &#123;<br>        showToast(<span class="hljs-string">&quot;<span class="hljs-subst">$&#123;location.latitude&#125;</span>&quot;</span>)<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>该例子主要展示了一个<code>获取位置信息</code>的功能，如果调用到<code>getLocation</code>方法，就会触发<code>onNoted</code>回调，回调信息包括危险权限code以及归因。</p><p>其中<strong>OnOpNotedCallback</strong> 一共三个回调方法：</p><ul><li><code>onNoted</code> 正常情况下都会回调到该方法</li><li><code>onAsyncNoted</code> 如果数据访问并非发生在应用调用API期间，就会调用onAsyncNoted()，比如一些监听器的回调。</li><li><code>onSelfNoted</code> 在极少数情况下，如果应用将自身的UID传递到 noteOp()，需要调用 onSelfNoted()。</li></ul><h3 id="2-单次授权"><a href="#2-单次授权" class="headerlink" title="2.单次授权"></a>2.单次授权</h3><blockquote><p>在 Android 11 中，每当应用请求与位置信息、麦克风或摄像头相关的权限时，面向用户的权限对话框会包含仅限这一次选项。如果用户在对话框中选择此选项，系统会向应用授予临时的单次授权。</p></blockquote><p>就是在申请与<code>位置信息、麦克风或摄像头</code>相关的权限时，系统会自动提供一个<code>单次授权</code>的选项，只供这一次权限获取。然后用户下次打开app的时候，系统会再次提示用户授予权限。这个影响应该不大，只要我们每次使用的时候都去判断权限，没有就去申请即可。</p><h3 id="3-权限对话框的可见性"><a href="#3-权限对话框的可见性" class="headerlink" title="3.权限对话框的可见性"></a>3.权限对话框的可见性</h3><blockquote><p>Android 11 建议不要请求用户已选择拒绝的权限。在应用安装到设备上后，如果用户在使用过程中屡次针对某项特定的权限点按拒绝，此操作表示其希望“不再询问”。</p></blockquote><p>这个都算不上改动，只是官方的一个<code>良好建议</code>。建议在用户多次拒绝之后，不要再展示权限申请。</p><h3 id="4-数据访问审核"><a href="#4-数据访问审核" class="headerlink" title="4.数据访问审核"></a>4.数据访问审核</h3><p>为了让应用及其依赖项访问用户私密数据的过程更加透明，Android 11 引入了数据访问审核功能。借助此流程得出的见解，您可以更好地识别可能出现的意外数据访问。您的应用可以注册 <code>AppOpsManager.OnOpNotedCallback</code> 实例，该实例可在每次发生以下任一事件时执行相应操作：</p><ul><li>应用的代码访问私密数据。为了帮助您确定应用的哪个逻辑部分调用了事件，您可以按归因标记审核数据访问。</li><li>依赖库或 SDK 中的代码访问私密数据。</li></ul><h3 id="5-永久SIM卡标识符"><a href="#5-永久SIM卡标识符" class="headerlink" title="5.永久SIM卡标识符"></a>5.永久SIM卡标识符</h3><blockquote><p>在 Android 11 及更高版本中，使用 <a href="https://developer.android.google.cn/reference/android/telephony/SubscriptionInfo#getIccId()"><code>getIccId()</code></a> 方法访问不可重置的 ICCID 受到限制。该方法会返回一个非 null 的空字符串。如需唯一标识设备上安装的 SIM 卡，请改用 <a href="https://developer.android.google.cn/reference/android/telephony/SubscriptionInfo#getSubscriptionId()"><code>getSubscriptionId()</code></a> 方法。订阅 ID 会提供一个索引值（从 1 开始），用于唯一识别已安装的 SIM 卡（包括实体 SIM 卡和电子 SIM 卡）。除非设备恢复出厂设置，否则此标识符的值对于给定 SIM 卡是保持不变的。</p></blockquote><h3 id="6-非-SDK-接口限制"><a href="#6-非-SDK-接口限制" class="headerlink" title="6.非 SDK 接口限制"></a>6.非 SDK 接口限制</h3><blockquote><p>Android 11 包含更新后的受限制非 SDK 接口列表（基于与 Android 开发者之间的协作以及最新的内部测试）。在限制使用非 SDK 接口之前，我们会尽可能确保有可用的公开替代方案。</p></blockquote><p>如果您的应用并非以 Android 11 为目标平台，那么其中一些变更可能不会立即对您产生影响。不过，虽然您目前可以使用一些非 SDK 接口（具体取决于应用的目标 API 级别），但只要您使用任何非 SDK 方法或字段，应用无法运行的风险终归较高。</p><p>如果您不确定自己的应用是否使用了非 SDK 接口，则可以测试该应用，进行确认。如果您的应用依赖于非 SDK 接口，您应该开始计划迁移到 SDK 替代方案。然而，我们知道某些应用具有使用非 SDK 接口的有效用例。如果您无法为应用中的某项功能找到使用非 SDK 接口的替代方案，则应<a href="https://developer.android.google.cn/distribute/best-practices/develop/restrictions-non-sdk-interfaces#feature-request">请求新的公共 API</a>。</p><p>如需详细了解此 Android 版本中的变更，请参阅 <a href="https://developer.android.google.cn/about/versions/11/non-sdk-11">Android 11 中有关限制非 SDK 接口的更新</a>。如需全面了解有关非 SDK 接口的详细信息，请参阅<a href="https://developer.android.google.cn/distribute/best-practices/develop/restrictions-non-sdk-interfaces">对非 SDK 接口的限制</a>。</p><h3 id="4-Scudo-Hardened-Allocator"><a href="#4-Scudo-Hardened-Allocator" class="headerlink" title="4.Scudo Hardened Allocator"></a>4.Scudo Hardened Allocator</h3><blockquote><p>Android 11 在内部使用 Scudo Hardened Allocator 为堆分配提供服务。Scudo 能够检测并减轻某些类型的内存安全违规行为。如果您在原生代码崩溃报告中发现与 Scudo 相关的崩溃（例如 Scudo ERROR:），请参阅 Scudo 问题排查文档。</p></blockquote><p><code>Scudo</code>是一种动态的用户模式内存分配器，旨在抵御与堆相关的漏洞，同时保持良好的性能。它是一个开源的项目。 Android 11中，将采用这个新的<code>heap分配器</code>，性能更好，更安全。</p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android-11</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试官：哈希表都不知道，你是怎么看懂HashMap的？</title>
    <link href="/2020/09/25/30.Know%20about%20HashTable/"/>
    <url>/2020/09/25/30.Know%20about%20HashTable/</url>
    
    <content type="html"><![CDATA[<p>HashMap是Java面试中的必问考点之一，网上关于HashMap实现原理的文章数不胜数。但是在翻阅了大部分HashMap相关的文章之后，发现大多数文章都是对HashMap源码的分析，丝毫没有提到哈希表的概念。这就导致了很多人只记住了HashMap的原理，却不知哈希表为何物的奇特现象。很多情况下，面试官可能并不会直接问HashMap是如何实现的，而是抛出一个质问三连：<br><img src="https://raw.githubusercontent.com/zhpanvip/images/master/project/article/hashtable/0.jpg" alt="在这里插入图片描述"></p><p>搞错了，重来！什么是哈希表？什么是哈希冲突？如何处理哈希冲突？</p><p><img src="https://raw.githubusercontent.com/zhpanvip/images/master/project/article/hashtable/1.jpg" alt="在这里插入图片描述"></p><p>对于不了解哈希表的同学，这三个问题确实触及到了知识盲区。为了避免这种尴尬，接下来就一起来学习一下哈希表吧。</p><h2 id="一、什么是哈希表？"><a href="#一、什么是哈希表？" class="headerlink" title="一、什么是哈希表？"></a>一、什么是哈希表？</h2><p>在回答这个问题之前我们先来思考一个问题：<strong>如何在一个无序的线性表中查找一个数据元素？</strong></p><p>注意，这是一个无序的线性表，也就是说要查找的这个元素在线性表中的位置是随机的。对于这样的情况，想要找到这个元素就必须对这个线性表进行遍历，然后与要查找的这个元素进行比较。这就意味着查找这个元素的时间复杂度为o(n)。对于o(n)的时间复杂度，在查找海量数据的时候也是一个非常消耗性能的操作。那么有没有一种数据结构，这个数据结构中的元素与它所在的位置存在一个对应关系，这样的话我们就可以通过这个元素直接找到它所在的位置，而此时查找这个元素的时间复杂度就变成了o(1),可以大大节省程序的查找效率。当然，这种数据结构是存在的，它就是我们今天要讲的<strong>哈希表</strong>。</p><p>我们先来看一下哈希表的定义：</p><blockquote><p><strong>哈希表</strong>又叫<strong>散列表</strong>，是一种根据设定的映射函数f(key)将一组关键字映射到一个有限且连续的地址区间上，并以关键字在地址区间中的“像”作为元素在表中的存储位置的一种数据结构。这个映射过程称为<strong>哈希造表</strong>或者<strong>散列</strong>，这个映射函数f(key)即为<strong>哈希函数</strong>也叫<strong>散列函数</strong>，通过哈希函数得到的存储位置称为<strong>哈希地址</strong>或<strong>散列地址</strong></p></blockquote><p>定义总是这么的拗口且难以理解。简单来说，哈希表就是通过一个映射函数f(key)将一组数据散列存储在数组中的一种数据结构。在这哈希表中，每一个元素的key和它的存储位置都存在一个f(key)的映射关系，我们可以通过f(key)快速的查找到这个元素在表中的位置。</p><p>举个例子，有一组数据：[19,24,6,33,51,15]，我们用散列存储的方式将其存储在一个长度为11的数组中。采用<strong>除留取余法</strong>，将这组数据分别模上数组的长度（即f(key)=key % 11），以余数作为该元素在数组中的存储的位置。则会得到一个如下图所示的哈希表：</p><p><img src="https://raw.githubusercontent.com/zhpanvip/images/master/project/article/hashtable/2.png" alt="哈希表示例"></p><p>此时，如果我们想从这个表中找到值为15的元素，只需要将15模上11即可得到15在数组中的存储位置。可见哈希表对于查找元素的效率是非常高的。</p><h2 id="二、什么是哈希冲突"><a href="#二、什么是哈希冲突" class="headerlink" title="二、什么是哈希冲突"></a>二、什么是哈希冲突</h2><p>上一节中我们举了一个很简单的例子来解释什么是哈希表，例子中的这组数据只有6个元素。假如我们向这组数据中再插入一些元素，插入后的数据为：[19,24,6,33,51,15,25,72]，新元素25模11后得到3，存储到3的位置没有问题。而接下来我们对72模11之后得到了6，而此时在数组中6的位置已经被其他元素给占据了。“72“只能很无奈的表示我放哪呢？<br><img src="https://raw.githubusercontent.com/zhpanvip/images/master/project/article/hashtable/3.png" alt="哈希冲突"><br>对于上述情况我们将其称之为哈希冲突。哈希冲突比较官方的定义为：</p><blockquote><p>对于不同的关键字，可能得到同一个哈希地址，即key1≠key2,而 f(key1)=f(key2)，对于这种现象我们称之为<strong>哈希冲突</strong>，也叫<strong>哈希碰撞</strong></p></blockquote><p>一般情况下，哈希冲突只能尽可能的减少，但不可能完全避免。因为哈希函数是从关键字集合到地址集合的映射，通常来说关键字集合比较大，它的元素理论上包括所有可能的关键字，而地址集合的元素仅为哈希表中的地址值。这就导致了哈希冲突的必然性。</p><h3 id="1-如何减少哈希冲突？"><a href="#1-如何减少哈希冲突？" class="headerlink" title="1.如何减少哈希冲突？"></a>1.如何减少哈希冲突？</h3><p>尽管哈希冲突不可避免，但是我们也要尽可能的减少哈希冲突的出现。一个好的哈希函数可以有效的减少哈希冲突的出现。那什么样的哈希函数才是一个好的哈希函数呢？通常来说，一个好的哈希函数对于关键字集合中的任意一个关键字，经过这个函数映射到地址集合中任何一个集合的概率是相等的。</p><p>常用的构造哈希函数的方法有以下几种：<br><strong>（1）除留取余法</strong></p><p>这个方法我们在上边已经有接触过了。取关键字被某个不大于哈希表长m的数p除后所得余数为哈希地址。即：f(key)=key % p, p≤m;</p><p><strong>（2）直接定址法</strong></p><p>直接定址法是指取关键字或关键字的某个线性函数值为哈希地址。即： f(key)=key 或者 f(key)=a*key+b、</p><p><strong>（3）数字分析法</strong></p><p>假设关键字是以为基的数（如以10为基的十进制数），并且哈希表中可能出现的关键字都是事先知道的，则可以选取关键字的若干位数组成哈希表。</p><p>当然，除了上边列举的几种方法，还有很多种选取哈希函数的方法，就不一一列举了。我们只要知道，选取合适的哈希函数可以有效减少哈希冲突即可。</p><h3 id="2-如何处理哈希冲突？"><a href="#2-如何处理哈希冲突？" class="headerlink" title="2.如何处理哈希冲突？"></a>2.如何处理哈希冲突？</h3><p>虽然我们可以通过选取好的哈希函数来减少哈希冲突，但是哈希冲突终究是避免不了的。那么，碰到哈希冲突应该怎么处理呢？接下来我们来介绍几种处理哈希冲突的方法。</p><p><strong>（1）开放定址法</strong></p><p>开放定址法是指当发生地址冲突时，按照某种方法继续探测哈希表中的其他存储单元，直到找到空位置为止。</p><p>我们以本节开头的例子来讲解开放定址法是如何处理冲突的。72模11后得到6，而此时6的位置已经被其他元素占用了，那么将6加1得到7，<br>此时发现7的位置也被占用了，那就再加1得到下一个地址为8，而此时8仍然被占用，再接着加1得到9，此时9处为空，则将72存入其中，即得到如下哈希表：</p><p><img src="https://raw.githubusercontent.com/zhpanvip/images/master/project/article/hashtable/4.png" alt="线性探测再散列"><br>像上边的这种探测方法称为<strong>线性探测再散列</strong>。当然除了线性探测再散列之外还有二次探测再散列，探测地址的方式为原哈希地址加上d (d= $±1^2$、$±2^2$、$±3^2$……$±m^2$)，经过二次探测再散列后会得到求得72的哈希地址为5，存储如下图所示：</p><p><img src="https://raw.githubusercontent.com/zhpanvip/images/master/project/article/hashtable/5.png" alt="二次探测再散列"></p><p><strong>（2）再哈希法</strong></p><p>再哈希法即选取若干个不同的哈希函数，在产生哈希冲突的时候计算另一个哈希函数，直到不再发生冲突为止。</p><p><strong>（3）建立公共溢出区</strong></p><p>专门维护一个溢出表，当发生哈希冲突时，将值填入溢出表。</p><p><strong>（4）链地址法</strong></p><p>链地址法是指在碰到哈希冲突的时候，将冲突的元素以链表的形式进行存储。也就是凡是哈希地址为<strong>i</strong>的元素都插入到同一个链表中，元素插入的位置可以是表头（<strong>头插法</strong>），也可以是表尾（<strong>尾插法</strong>）。我们以仍然以[19,24,6,33,51,15,25,72]<br>这一组数据为例，用链地址法来进行哈希冲突的处理，得到如下图所示的哈希表：</p><p><img src="https://raw.githubusercontent.com/zhpanvip/images/master/project/article/hashtable/6.png" alt="链地址法"><br>我们可以向这组数据中再添加一些元素，得到一组新的数据[19,24,6,33,51,15,25,72,37,17,4,55,83]。使用链地址法得到如下哈希表：</p><p><img src="https://raw.githubusercontent.com/zhpanvip/images/master/project/article/hashtable/7.png" alt="链地址法"></p><h2 id="三、链地址法的弊端与优化"><a href="#三、链地址法的弊端与优化" class="headerlink" title="三、链地址法的弊端与优化"></a>三、链地址法的弊端与优化</h2><p>上一节中我们讲解了几种常用的处理哈希冲突的方法。其中比较常用的是链地址法，比如HashMap就是基于链地址法的哈希表结构。虽然链地址法是一种很好的处理哈希冲突的方法，但是在一些极端情况下链地址法也会出现问题。举个例子，我们现在有这样一组数据：[48,15,26,4,70,82,59]。我们将这组数据仍然散列存储到长度为11的数组中，此时则得到了如下的结果：</p><p><img src="https://raw.githubusercontent.com/zhpanvip/images/master/project/article/hashtable/8.png" alt="链地址法存在的问题"></p><p>可以发现，此时的哈希表俨然已经退化成了一个链表，当我们在这样的数据结构中去查找某个元素的话，时间复杂度又变回了o(n)。这显然不符合我们的预期。因此，当哈希表中的链表过长时就需要我们对其进行优化。我们知道，二叉查找树的查询效率是远远高于链表的。因此，当哈希表中的链表过长时我们就可以把这个链表变成一棵红黑树。上面的一组数据优化后可得到如下结果：</p><p><img src="https://raw.githubusercontent.com/zhpanvip/images/master/project/article/hashtable/10.png" alt="在这里插入图片描述"></p><p>红黑树是一个可以自平衡的二叉查找树。它的查询的时间复杂度为o(lgn)。通过这样的优化可以提高哈希表的查询效率。</p><h2 id="四、哈希表的扩容与Rehash"><a href="#四、哈希表的扩容与Rehash" class="headerlink" title="四、哈希表的扩容与Rehash"></a>四、哈希表的扩容与Rehash</h2><p>在哈希表长度不变的情况下，随着哈希表中插入的元素越来越多，发生哈希冲突的概率会越来越大，相应的查找的效率就会越来越低。这意味着影响哈希表性能的因素除了哈希函数与处理冲突的方法之外，还与哈希表的<strong>装填因子</strong>大小有关。</p><blockquote><p>我们将哈希表中元素数与哈希表长度的比值称为<strong>装填因子</strong>。装填因子 <strong>α= $\frac{哈希表中元素数}{哈希表长度}$</strong></p></blockquote><p>很显然，<strong>α</strong>的值越小哈希冲突的概率越小，查找时的效率也就越高。而减小<strong>α</strong>的值就意味着降低了哈希表的使用率。显然这是一个矛盾的关系，不可能有完美解。为了兼顾彼此，装填因子的最大值一般选在0.65~0.9之间。比如HashMap中就将装填因子定为0.75。一旦HashMap的装填因子大于0.75的时候，为了减少哈希冲突，就需要对哈希表进行<strong>扩容</strong>操作。比如我们可以将哈希表的长度扩大到原来的2倍。</p><p>这里我们应该知道，扩容并不是在原数组基础上扩大容量，而是需要申请一个长度为原来2倍的新数组。因此，扩容之后就需要将原来的数据从旧数组中重新散列存放到扩容后的新数组。这个过程我们称之为<strong>Rehash</strong>。</p><p>接下来我们仍然以[19,24,6,33,51,15,25,72,37,17,4,55,83]这组数据为例来演示哈希表扩容与Rehash的过程。假设哈希表的初始长度为11，装载因子的最大值定位0.75，扩容前的数据插入如下图所示：</p><p><img src="https://raw.githubusercontent.com/zhpanvip/images/master/project/article/hashtable/11.png" alt="在这里插入图片描述"></p><p>当我们插入第9个元素的时候发现此时的装填因子已经大于了0.75，因此触发了扩容操作。为了方便画图，这里将数组长度扩展到了18。扩容后将[19,24,6,33,51,15,25,72,37,17,4,55,83]这组数据重新散列，会得到如下图所示的结果：</p><p><img src="https://raw.githubusercontent.com/zhpanvip/images/master/project/article/hashtable/12.png" alt="在这里插入图片描述"></p><p>可以看到扩容前后元素存储位置大相径庭。Rehash的操作将会重新散列扩容前已经存储的数据，这一操作涉及大量的元素移动，是一个非常消耗性能的操作。因此，在开发中我们应该尽量避免Rehash的出现。比如，可以预估元素的个数，事先指定哈希表的长度，这样可以有效减少Rehash。</p><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>哈希表是数据结构中非常重要的一个知识点，本篇文章详细的讲解了哈希表的相关概念，让大家对哈希表有了一个清晰的认识。哈希表弥补了线性表或者树的查找效率低的问题，通过哈希表在理想的情况下可以将查找某个元素的时间复杂度降低到o(1),但是由于哈希冲突的存在，哈希表的查找效率很难达到理想的效果。另外，哈希表的扩容与Rehash的操作对哈希表存储时的性能也有很大的影响。由此可见使用哈希表存储数据也并非一个完美的方案。但是，对于查找性能要求高的情况下哈希表的数据结构还是我们的不二选择。</p><p>最后了解了哈希表对于理解HashMap会有莫大的帮助。毕竟HashMap本身就是基于哈希表实现的。</p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>哈希表</tag>
      
      <tag>HashTable</tag>
      
      <tag>HashMap</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>垃圾回收机制全面解析</title>
    <link href="/2020/09/19/29.Java%20GC/"/>
    <url>/2020/09/19/29.Java%20GC/</url>
    
    <content type="html"><![CDATA[<p>提起Java的垃圾回收机制大家应该都有所了解，它不仅是面试的常客，也是Java体系中相当重要的一块知识。深入理解Java的GC机制，不仅有助于我们在开发中提高程序的性能，更有了在面试官面前炫(zhuang)技(X)的资本。本篇文章将全面且深入的分析JVM的垃圾回收机制，同时还会对常用的垃圾收集器（包括最前沿的ZGC收集器和Shenandoah收集器）进行讲解。</p><h2 id="一、GC机制概述"><a href="#一、GC机制概述" class="headerlink" title="一、GC机制概述"></a>一、GC机制概述</h2><p>在<a href="https://zhangpan.site/2020/09/04/25.%E6%B8%A9%E6%95%85%E7%9F%A5%E6%96%B0--JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E8%AF%A6%E8%A7%A3/">《深入JVM–Java运行时内存区域详解》</a>这篇文章中我们对JVM的运行时内存区域进行了详细的分析。我们知道对象的创建是由JVM完成的，在对象创建的时候JVM会在Java堆中开辟一块空间用来存储这个对象。而当对象“死亡”的时候，同样是由JVM来处理的，JVM处理“死亡”对象的过程就是我们今天要讲的垃圾回收机制。</p><h3 id="1-堆内存的区域划分"><a href="#1-堆内存的区域划分" class="headerlink" title="1.堆内存的区域划分"></a>1.堆内存的区域划分</h3><p>关于堆内存区域的划分，其实是由垃圾收集器的特性决定的。本节将要讲到的内存区域划分主要是指的G1收集器之前的经典垃圾收集器对堆内存的划分。</p><p>为了方便JVM更好的管理和回收对象，Java的设计者们将Java的堆内存成为了两大块,分别为：<strong>新生代（Young Generation）</strong> 和 <strong>老年代（Old Generation）</strong>。而根据新生代的特性，又将新生代分成了一块较大的Eden区域和两块较小但大小相等的Survivor区域。至于新时代和老年代这两块区域，是我们今天要探讨的重点，后文中将会多次出现。</p><p>了解了堆内存的划分后我们再来看垃圾回收的特点。垃圾收集器在执行一次垃圾回收时，可能是<strong>部分收集（Partical GC）</strong>也可能是<strong>整堆收集（Full GC</strong>），部分收集又可以分为<strong>新生代收集（Minor GC/Young GC）</strong>和<strong>老年代收集（Major GC/Old GC）</strong>。既然有这样的划分，那收集器回收区域的规则是根据什么条件确定的呢？ 在JDK6 update 24之后，回收区域的规则为：只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小，就会进行Minor GC，否则将进行Full GC。</p><p>对象通常是在Eden区域被创建，JVM会给每个对象定义一个年龄（Age）计数器，存储在对象头中。如果经过第一次Minor GC后对象仍然存活，并且能被Survivor区域容纳的话，对象则会被移动到Survivor区域，同时会将对象的年龄设置为1岁。接下来，该对象会经历多次的垃圾回收，Survivor区中的对象每熬过一次Minor GC，它的年龄就会增加一岁。如果对这个象增加到一定年龄（默认15，可通过-XX:MaxTenuringThreshold参数设置），就会被移动到老年代中。</p><p>当然，为了更好的适应不同程序的内存情况，HotSpot虚拟机并不是绝对要求对象年龄达到-XX:MaxTenuringThreshold后才能转移到老年代，特殊情况有如下两种：</p><ul><li>如果Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，则年龄大于或等于该年龄的对象就可以直接进入老年代。</li><li>另外，对于大对象，HotSpot虚拟机可通过-XX:PretenureSizeThreshold参数进行设置，当对象内存大于设定的值的话，这个对象会绕过Eden区域直接被分配到老年代。</li></ul><p>正所谓条条大路通罗马，而有些人的家就在罗马。看来即便是计算机也绕不过特权阶级这个坎儿呀。。。</p><h3 id="2-永久代（Permanent-Generation）"><a href="#2-永久代（Permanent-Generation）" class="headerlink" title="2.永久代（Permanent Generation）"></a>2.永久代（Permanent Generation）</h3><p>在JDK7以及之前，HotSpot虚拟机还有另外一块叫<strong>永久代（Permanent Generation）</strong> 的存储区域，这块区域并不属于堆内存，而是对于方法区的实现。主要用于存放Class和Meta（元数据）的信息，Class在类加载的时候被放入永久代。永久代和存放实例的堆内存区域不同，GC不会在主程序运行期对永久代进行清理。所以这也导致了永久代的区域会随着加载的Class的增多而爆满，最终抛出OOM异常。</p><p>虽然被称为永久代，但这块内存区域也会进行垃圾回收。永久代的垃圾收集主要包废弃常量和无用的类（被类加载器卸载的Class）。永久代触发垃圾回收的条件比较困难，需要同时满足以下三点：</p><ul><li>该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例；</li><li>加载该类的ClassLoader已经被回收；</li><li>该类对应的java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法；</li></ul><h3 id="3-元空间（MetaSpace）"><a href="#3-元空间（MetaSpace）" class="headerlink" title="3.元空间（MetaSpace）"></a>3.元空间（MetaSpace）</h3><p>由于永久代可能存在内存溢出的问题，在JDK8之后永久代已经不复存在，取而代之的是<strong>元空间（MetaSpace）</strong>。</p><p>元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制，但可以通过-XX:MetaspaceSize这个参数来指定初始空间大小，当达到设置的最大值就会触发垃圾收集进行类型卸载，同时GC会对该值进行调整：如果释放了大量的空间，就适当降低该值；如果释放了很少的空间，那么在不超过MaxMetaspaceSize时，适当提高该值。可以通过-XX:MaxMetaspaceSize来设置元空间能够使用的最大内存，默认是没有限制的。</p><p>除了上面两个指定大小的选项以外，还有两个与 GC 相关的属性：<br>-XX:MinMetaspaceFreeRatio，在GC之后，最小的Metaspace剩余空间容量的百分比，减少为分配空间所导致的垃圾收集<br>-XX:MaxMetaspaceFreeRatio，在GC之后，最大的Metaspace剩余空间容量的百分比，减少为释放空间所导致的垃圾收集</p><p>有关垃圾回收的区域如下图所示：<br><img src="https://raw.githubusercontent.com/zhpanvip/images/master/project/article/jvmgc/01.png" alt="在这里插入图片描述"></p><p>上图中的Permanet Generation区域，在Jdk8中，被MetaSpace区取代了。</p><h2 id="二、垃圾收集的标记算法"><a href="#二、垃圾收集的标记算法" class="headerlink" title="二、垃圾收集的标记算法"></a>二、垃圾收集的标记算法</h2><p>垃圾收集器回收垃圾的第一步先要确定哪些对象是可以被回收的。因此，JVM会扫描堆内存中的所有对象，并标记出可被回收的对象。而垃圾收集的标记算法有以下两种：</p><h3 id="1-引用计数算法"><a href="#1-引用计数算法" class="headerlink" title="1.引用计数算法"></a>1.引用计数算法</h3><p>引用计数算法通过在每个对象中添加一个计数器，当有一个地方引用它的时候计数器的值就会增加1；当引用失效的时候计数器的值则会减1。当计数器的值为0时，则可认为这个对象已经不再使用。因此对于引用计数算法，垃圾收集器只需要回收计数器为0的对象即可。</p><p>引用计数算法的优点是效率很高，不需要遍历所有对象。但它是存在一个致命的缺点，即无法解决对象之间循环引用的问题。比如对象A引用了对象B,对象B也引用了对象A，除此之外，A、B两个对象再也没有被其他地方引用。此时对象A和对象B的计数器均不为0，所以A、B两个对象都无法被回收。所以，目前商用的Java虚拟机都没有选用引用计数算法来进行标记。</p><h3 id="2-可达性分析算法"><a href="#2-可达性分析算法" class="headerlink" title="2.可达性分析算法"></a>2.可达性分析算法</h3><p>可达性分析算法也被称为根搜索算法。这一算法的基本思路是用一系列的“GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径被称为”引用链“（Reference Chain）。如果一个对象到”GC Roots”没有任何的引用链相连，则证明此对象可能不再被使用。</p><p>如下图所示，灰色部分的对象没有关联到引用链上，此时这些对象就会被判定为可回收对象。<br><img src="https://raw.githubusercontent.com/zhpanvip/images/master/project/article/jvmgc/02.png" alt="在这里插入图片描述"><br>哪些对象可以被作为GC Roots呢？主要包括以下几种：</p><ul><li>在虚拟机栈（栈帧中的本地变量表）中引用的对象。</li><li>方法区中类静态属性引用的对象。</li><li>在方法区中引用的对象，如字符串常量池（String Table）里的引用</li><li>本地方法栈中JNI引用的对象</li><li>Java虚拟机内部的引用，如基本数据类型对应的Class对象以及一些常驻的异常对象等。</li><li>所有同步锁持有的对象</li><li>反应Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。</li></ul><h2 id="三、垃圾收集算法"><a href="#三、垃圾收集算法" class="headerlink" title="三、垃圾收集算法"></a>三、垃圾收集算法</h2><h3 id="1-标记-清除算法（Mark-Sweep）"><a href="#1-标记-清除算法（Mark-Sweep）" class="headerlink" title="1.标记-清除算法（Mark-Sweep）"></a>1.标记-清除算法（Mark-Sweep）</h3><p>标记-清除算法是最早出现也是最基础的一种垃圾收集算法。该算法分为“标记”和”清除“两个阶段，标记阶段就是上边讲到的对垃圾的标记。首先会通过可达性分析算法标记出所有需要回收的对象，然后统一回收掉所有被标记的对象。标记-清除算法的执行过程如下图所示：<br><img src="https://raw.githubusercontent.com/zhpanvip/images/master/project/article/jvmgc/03.jpg" alt="在这里插入图片描述"></p><p>图中深灰色区域为可回收区域，在标记完成后直接将深灰色区域进行清理。这一算法很容易理解，实现起来也很便捷，但是也存在两个缺点：</p><p>1.执行效率会随对象增多而降低。如果Java堆中包含大量需要回收的对象。此时需要进行大量标记和清除操作。导致标记和清除这两个过程需要大量的时间，降低了执行效率。</p><p>2.引起严重的内存碎片化问题。标记、清除之后会产生大量不连续的内存空间，这可能会导致在需要分配大对象时无法找到足够的连续空间，进而引发GC。</p><h3 id="2-标记-复制算法（Copying）"><a href="#2-标记-复制算法（Copying）" class="headerlink" title="2.标记-复制算法（Copying）"></a>2.标记-复制算法（Copying）</h3><p>标记-复制算法也被简称为复制算法。它是对标记-清除算法的改进。复制算法将内存划分为大小相等的两块，分配对象时只使用其中的一块。当这块内存用完时，就将存活的对象复制到另外一块上面，然后把已使用的这块内存一次性清理掉。复制算法的执行过程如下图所示：<br><img src="https://raw.githubusercontent.com/zhpanvip/images/master/project/article/jvmgc/04.jpg" alt="在这里插入图片描述"></p><p>复制算法虽然解决了标记-清除算法的一些问题。但其缺陷也显而易见，直接导致了可用内存变为原来的一半，内存使用率太低！</p><h3 id="3-标记-整理算法（Mark-Compact）"><a href="#3-标记-整理算法（Mark-Compact）" class="headerlink" title="3.标记-整理算法（Mark-Compact）"></a>3.标记-整理算法（Mark-Compact）</h3><p>标记整理算法在标记了存活对象之后，会让所有存活的对象向内存的一端移动，然后直接清除掉边界外的内存。该算法的示意图如下图所示：</p><p><img src="https://raw.githubusercontent.com/zhpanvip/images/master/project/article/jvmgc/05.jpg" alt="在这里插入图片描述"></p><p>移动存活对象并更新所有被移动对象的引用是一个比较耗时的操作。而且，在移动对象时必须暂停所有用户线程才能进行（这一操作有个专有名词叫“Stop The World”，简称STW）。拖累了用户程序的执行效率</p><h3 id="4-分代收集-Generational-Collection"><a href="#4-分代收集-Generational-Collection" class="headerlink" title="4.分代收集(Generational Collection)"></a>4.分代收集(Generational Collection)</h3><p>分代收集不能称得上是一种算法，它会根据堆内存的不同区域采用不同的收集算法，因地制宜嘛。</p><p>比如上边我们已经说过的，在G1收集器之前，所有的收集器都是将Java堆划分为新生代和老年代，由于新生代中对象存活率比较低，因此在新时代采用优化了的复制算法。HotSpot虚拟机中将Eden和Survivor的大小大小划分为8:1的比例，分配对象只使用Eden和其中的一块Surivor区域，在标记完成后将存活的对象复制到另外一块Survior空间中，然后清除Eden和使用的一块Surivor。这样，新生代的空间利用率就达到了90%。</p><p>对于老年代每次垃圾回收存活的对象比较多，因此这一区域采用的是标记-整理算法进行垃圾回收。</p><h2 id="四、垃圾收集器"><a href="#四、垃圾收集器" class="headerlink" title="四、垃圾收集器"></a>四、垃圾收集器</h2><p>通过前面几节我们认识了垃圾收集的原理，那么，本节就来认识一下各具特色的垃圾收集器。垃圾收集器其实就是对于前面讲到的原理的实现，只不过在Java的发展史中出现了一代又一代的垃圾收集器，而新一代的垃圾收集器都是对上一代垃圾收集器缺点的弥补。直到前几天（2020年9月15日），在Oracle JDK15中又引入了新的垃圾收集器Shenandoah。可见直到今天Java的设计者们依然还在对收集器进行优化。</p><p>我们先来通过一张图片看下经典的几款垃圾收集器，图中连线表示这两款收集器可以配合使用。<br><img src="https://raw.githubusercontent.com/zhpanvip/images/master/project/article/jvmgc/06.jpeg" alt="在这里插入图片描述"><br>接下来我们我们来认识下这几款收集器，另外除了图中的这几款收集器还会详细讲解ZGC和Shenandoah。</p><h3 id="1-新生代收集器"><a href="#1-新生代收集器" class="headerlink" title="1.新生代收集器"></a>1.新生代收集器</h3><h4 id="1-1-Serial收集器"><a href="#1-1-Serial收集器" class="headerlink" title="1.1 Serial收集器"></a>1.1 Serial收集器</h4><p>Serial收集器是最基础、发展历史最悠久的收集器。它是一个单线程工作的收集器，对于早期的单核处理器或处理器核心数较少的情况下，Serial收集器由于没有线程交互的开销，所以收集效率比较高。但是，Serial收集器整个收集过程是需要STW的。这也是导致了早期的Java程序慢的主要原因之一。Serial收集器新生代采用的是标记-复制算法，运行过程如下图所示：<br><img src="https://raw.githubusercontent.com/zhpanvip/images/master/project/article/jvmgc/07.webp" alt="在这里插入图片描述"></p><h4 id="1-2-ParNew收集器"><a href="#1-2-ParNew收集器" class="headerlink" title="1.2 ParNew收集器"></a>1.2 ParNew收集器</h4><p>ParNew收集器实质上是Serial收集器的多线程版本。除了使用多条线程进行垃圾收集之外，其它特性包括Serial收集器的所有控制参数、收集算法、Stop The World、对象分配规则、回收策略等都与Serial收集器完全一致。ParNew收集器的工作过程如下图所示：<br><img src="https://raw.githubusercontent.com/zhpanvip/images/master/project/article/jvmgc/08.webp" alt="在这里插入图片描述"><br>ParNew是JDK 7之前的遗留系统中首选的新生代收集器，因为除了Serial收集器外它是唯一能和CMS收集器配合工作的新生代收集器。</p><h4 id="1-3-Parallel-Scavenge收集器"><a href="#1-3-Parallel-Scavenge收集器" class="headerlink" title="1.3 Parallel Scavenge收集器"></a>1.3 Parallel Scavenge收集器</h4><p>Parallel Scavenge收集器也是一款新生代收集器，它同样是基于标记-复制算法实现。也是能够并行收集的多线程收集器，从表面上看它与ParNew非常相似。Parallel Scavenge收集器的目标是达到一个可控制的吞吐量（Throughput）。</p><blockquote><p>吞吐量=（运行用户代码的时间）/（运行用户代码时间+运行垃圾收集时间）</p></blockquote><p>Parallel Scavenge收集器运行过程如下图所示：<br><img src="https://raw.githubusercontent.com/zhpanvip/images/master/project/article/jvmgc/09.webp" alt="在这里插入图片描述"></p><h3 id="2-老年代收集器"><a href="#2-老年代收集器" class="headerlink" title="2.老年代收集器"></a>2.老年代收集器</h3><h4 id="2-1-Serial-Old收集器"><a href="#2-1-Serial-Old收集器" class="headerlink" title="2.1 Serial Old收集器"></a>2.1 Serial Old收集器</h4><p>Serial Old是Serial收集器的老年代版本，它与Serial一样都是单线程收集器。Serial Old使用的是标记-整理算法。它的主要意义也是提供客户端模式下的HotSpot虚拟机使用。</p><h4 id="2-2-Parallel-Old收集器"><a href="#2-2-Parallel-Old收集器" class="headerlink" title="2.2 Parallel Old收集器"></a>2.2 Parallel Old收集器</h4><p>Parallel Old 是Parallel Scavenge收集器的老年代版本，支持多线程并发收集，基于标记-整理算法。这个收集器是在JDK 6时开始提供。</p><h4 id="2-3-CMS收集器"><a href="#2-3-CMS收集器" class="headerlink" title="2.3 CMS收集器"></a>2.3 CMS收集器</h4><p>CMS（Concurrent Mark Sweep）收集器是一款具有划时代意义的收集器。前面我们提到的几款收集器在工作期间全程都需要STW，而CMS第一次实现了垃圾收集的并发处理。因此，这款收集器可以有效的减少垃圾收集过程中的停顿时间。CMS收集器是基于标记-清除算法实现的。我们来详细了解一下CMS的工作过程：</p><p><strong>（1）初始标记：</strong> 从GC Roots出发标记全部直接子节点的过程，该阶段是STW的。由于GC Roots数量不多，通常该阶段耗时非常短。</p><p><strong>（2）并发标记：</strong>  并发标记阶段是指从GC Roots开始对堆中对象进行可达性分析，找出存活对象。该阶段是并发的，即应用线程和GC线程可以同时活动。并发标记耗时相对长很多，但因为不是STW，所以我们不太关心该阶段耗时的长短。</p><p><strong>（3）重新标记：</strong> 重新标记那些在并发标记阶段发生变化的对象。该阶段是STW的。</p><p><strong>（4）并非清除：</strong> 并行清理， 开启用户线程，同时GC线程开始对为标记的区域做清扫。</p><p>CMS运行过程如下图所示：<br><img src="https://raw.githubusercontent.com/zhpanvip/images/master/project/article/jvmgc/10.jpg" alt="在这里插入图片描述"><br>从上面描述可以看到，CMS能够并发收集，有效减少停顿时间。但CMS并不是一款完美的垃圾收集器，不然也不会在JDK15中将其移除。它的缺点主要有以下几个：</p><ul><li><strong>并发收集占用CPU资源。</strong> 虽然并发阶段不会导致用户停顿，并发时的收集线程却占用了一部分CPU资源，导致应用程序变慢，降低了吞吐量。</li><li></li><li><strong>无法处理浮动垃圾。</strong> CMS的并发标记和并发清理阶段，用户线程是继续运行的，这期间必然会有新的垃圾对象产生。对于已经收集过的区域，CMS无法再去回头处理它们，只能等到下一次垃圾收集时再清理掉。</li><li></li><li><strong>并发清理阶段需要保证内存充足。</strong> 由于在垃圾收集阶段用户线程依然在运行，所有不得不预留足够的空间提供给用户线程使用。因此CMS收集器在垃圾收集开始时需要预留足够的内存。JDK 5的默认设置，当老年代使用了68%的空间后就垃圾收集会被激活。虽然可以通过参数-XX:CMSInitiatingOccupancyFraction来调高CMS的触发百分比，但这样又会导致CMS运行期间可能出现预留内存不足的情况。此时，CMS就会出现一次”并发失败“（Concurrent Mode Failure），虚拟机不得不启动后备预案，停止用户线程的执行，启动Serial Old收集器重新进行老年代的垃圾收集。</li><li><strong>产生大量碎片空间 。</strong>  由于CMS使用的是“标记-清除”算法，因此会导致大量空间碎片产生。</li></ul><h3 id="3-全局收集器"><a href="#3-全局收集器" class="headerlink" title="3.全局收集器"></a>3.全局收集器</h3><h4 id="3-1-Garbage-Firs-收集器"><a href="#3-1-Garbage-Firs-收集器" class="headerlink" title="3.1 Garbage Firs 收集器"></a>3.1 Garbage Firs 收集器</h4><p>Garbage First收集器简称G1收集器，它是在JDK 6中被添加到Hotspot虚拟机的。与其它收集器相比G1收集器引入了很多新特点。如下：</p><p><strong>（1）独具特色的分代收集方式。</strong></p><p>G1收集器在堆内存的分代上做了很大的改变。它不再将堆内存简单的分为新生代和老年代，而是将堆划分为若干个大小相等、内存连续的Region。每个Region都可以根据需要扮演Eden空间、Survivor空间 、Old空间或者Humongous。如下图所示：<br><img src="https://raw.githubusercontent.com/zhpanvip/images/master/project/article/jvmgc/11.webp" alt="在这里插入图片描述"><br>其中Humomngous区域我们比较陌生，它是G1收集器独有的用于存放大对象的区域。如果对象的大小超过了Region容量一半即可被判定为大对象放入Humongous空间。如果一个非常大的对象超过了整个Humongous的内存，则这个对象会被存放在N个连续的Humongous Region之中。这么看来，Humongous更像是分担了部分老年代的功能。</p><blockquote><p>Region的大小可以通过参数-XX:G1HeapRegionSize设置，取值范围为1~32MB，且应该为2的N次幂。</p></blockquote><p>当然，别具一格的分代方式也会带来别具一格的问题。垃圾收集器应该如何跨Region进行收集？因为一个对象被分配到某个Region中，这个对象不可能只被本Region的对象引用，而是可能与堆中任意一个Region中的对象建立引用关系。这种情况其实在新生代与老年代中一样会碰到，只不过在G1中会显得更加突出。对于这种问题的处理虚拟机都是使用Remembered Set来避免全堆扫描的。在G1的每个Region区都维护着一个Remembered Set。当虚拟机发现程序在堆引用类型的数据进行写操作时会产生一个写屏障（Write Barrier），检查引用的对象是否处于不同的Region。如果是，便通过CardTable将引用信息记录到被引用对象所属的Region的Remembered Set中。当垃圾回收启动时，在GC跟节点的枚举范围中加入Remembered Set即可保证不对全堆扫描，同时也不会有遗漏。</p><blockquote><p>Remembered Set在存储结构的本质上是一种哈希表，Key是别的Region的起始地址，Value是一个集合，里边存储的是CardTable的索引号。CardTable存储的是“我指向谁”，而整个Remembered Set中的一个键值对（Key+Value）其实构成了一个双向卡表，即：”我指向谁，谁指向我“</p></blockquote><p>由于Region的数量要比传统的收集器的分代数量要多的多，因此G1收集器要比其它传统收集器有着更高的内存占用负担。根据相关经验，G１至少要耗费大约相当于Java堆容量10％至20%的额外内存来维持收集工作。</p><p><strong>（2）能建立可预测的停顿时间模型。</strong><br>G1收集器可以有计划的避免整个Java堆进行全区域的垃圾收集。他会跟踪各个Region里面的垃圾堆积的价值大小，在后台维护一个优先列表（Collection Set 简称CSet）。并且允许用户通过-XX:MaxGCPauseMillis参数设定允许的收集停顿时间。G1根据设定的停顿时间优先处理回收价值收益最大的那些Region,这也是Garbage First名字的由来。这种使用Region划分内存空间以及有优先级堆回收方式保证了G1收集器在有限时间内可以获取尽可能高堆收集效率。但是这个停顿时间必须切合实际，如果设置得非常低，会导致每次只能回收很小的一部分内存，最终垃圾慢慢堆积，最终占满整个堆内存，导致Full GC而产生长时间的“STW”，影响了性能。<br><strong>（3）具有整合空间碎片的能力。</strong><br>G1收集器从整体来看是基于“标记-整理”算法实现的，从局部（两个Region之间）是基于“复制”算法实现的，这两种算法在执行期间都不会产生内存的空间碎片。<br><strong>（4）可以并行和并发收集。</strong><br>G1收集器的运作过程可以分为四个步骤：<br><strong>初始标记（Initial Marking）：</strong> 初始标记只会标记GC Roots能直接关联到的对象，这一阶段是需要Stop The World的，但是由于GC Roots数量有限，所以这一阶段并不会消耗太多时间。<br><strong>并发标记（Concurrent Marking）：</strong> 从GC Roots开始对堆中对象进行可达性分析，找出存活对象。并发标记阶段耗时较长，但是这一阶段是并发执行的，因此，对性能不会造成影响。<br><strong>最终标记（Final Marking）：</strong> 重新标记在并发标记阶段发生变化的对象，这一阶段是需要STW的，但耗时很短。<br><strong>筛选回收阶段（Live Data Counting And Evacuation）</strong> 负责跟新Region跟新的数据，对各个Region的回收加之和成本进行排序，根据用户所期望的停顿时间来制定回收计划。可自由选择任意多个Region构成回收集，然后把决定回收的那一部分Region的存活对象复制到空的Region中，再清理掉旧Region的全部空间。这里涉及到存活对象的移动是必须STW，由多个收集器线程并行完成。</p><pre><code>G1收集器的执行过程如下图所示：</code></pre><p><img src="https://raw.githubusercontent.com/zhpanvip/images/master/project/article/jvmgc/12.jpg" alt="在这里插入图片描述"></p><h4 id="3-2-ZGC收集器"><a href="#3-2-ZGC收集器" class="headerlink" title="3.2 ZGC收集器"></a>3.2 ZGC收集器</h4><p>ZGC收集器是目前为止垃圾收集器最前沿的成果，它针对的目标是大内存、低延迟的后端服务器。ZGC可以将T级别内存回收的停顿时间控制在10ms以内，并且停顿时间不会随着内存增加而增大。ZGC能有这样的成果主要得益于它使用了读屏障、染色指针、多重映射等技术，实现了可并发的标记-整理算法。</p><h5 id="（1）ZGC的堆内存划分"><a href="#（1）ZGC的堆内存划分" class="headerlink" title="（1）ZGC的堆内存划分"></a><strong>（1）ZGC的堆内存划分</strong></h5><p>ZGC与G1收集器类似，都是将堆内存划分成了许多Region。但与G1不同的是，ZGC的Region区域大小是不相等的，且具有动态创建和动态销毁的特性。ZGC将Region分为大、中、小三类容量。其中，小型Region的容量固定为2MB,用于存放内存小于256k的小对象；中型Region容量固定为32MB,用于存放大小大于等于256kb但小于4M的对象；而大型Region的容量不固定，但必须是2MB的整数(N大于2)倍，用来存储大于4MB的对象。大Region容量不固定的这一特性也导致了它的内存可能比中型Region还小的情况。</p><p>ZGC的堆内存划分如下图所示：<br><img src="https://raw.githubusercontent.com/zhpanvip/images/master/project/article/jvmgc/13.jpg" alt="在这里插入图片描述"></p><h5 id="（2）ZGC的关键技术"><a href="#（2）ZGC的关键技术" class="headerlink" title="（2）ZGC的关键技术"></a>（2）ZGC的关键技术</h5><p>前面我们已经提到ZGC之所以能将停顿时间控制在10ms以内，是因为它使用了读屏障、着色指针以及多重映射等技术。但是由于到目前为止笔者对于这些技术中的很多原理还没完全搞明白，因为它涉及到了很多操作系统层面的知识，而这些知识在期末考试完的那一刻就全部还给了操作系统老师。所以这里我也只能是简单分析，也欢迎大家留言讨论。<br><strong>染色指针</strong><br>我们知道如果需要在对象中存储一些额外的信息时，可以在对象头中添加额外的存储字段。比如前边章节中提到的对象的分代年龄，另外还有像对象的hash等都会这样存储。而ZGC的染色指针是直接把标记信息存储在了对象的引用指针上。这样，在进行可达性分析遍历对象图来标记对象的时候其实是遍历了“引用图”来标记了引用。<br>为什么指针可以存储信息？在64位系统中，理论可以访问的内存高达16EB（2的64次幂）字节。但实际上，基于需求、性能、成本等方面的考虑，在AMD64架构中只支持到52位的地址总线和48位的虚拟地址空间，所以目前64位的硬件实际能够支持的最大内存只有256TB。此外，操作系统中还会施加自己的约束，64位的Linux仅支持47位的进程虚拟地址和46位的物理空间地址，64位的Windows系统甚至只支持44位的物理地址空间。（这里涉及到操作系统分页调度的相关知识，感兴趣的同学可以查阅相关资料）</p><p>鉴于此，虚拟机实际仅使用64位地址空间的第0到41位，而第42到45位存储对象的标记信息。通过高四位的这些标志，虚拟机可以直接从指针中看到其引用对象的三色标记状态、是否进入了重新分配（即被移动过）、是否通过finalize()方法才能被访问到,具体如下图所示：</p><p><img src="https://raw.githubusercontent.com/zhpanvip/images/master/project/article/jvmgc/14.jpg" alt="在这里插入图片描述"><br>因为标记信息又额外占用了46位中的四位，导致ZGC能够映射的内存只剩42位，因此，ZGC能够管理的内存不可以超过4TB（2的42次幂，这里指Linux平台下，Windows上实际会更小，只有40位）。</p><p><strong>读屏障</strong><br>读屏障这个技术应该不难理解，因为在G1中我们已经知道了写屏障。</p><blockquote><p>读屏障是JVM向应用代码插入一小段代码的技术。当应用线程从堆中读取对象引用时，就会执行这段代码。需要注意的是，仅“从堆中读取对象引用”才会触发这段代码。</p></blockquote><p>读屏障示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><br>Object o = obj.FieldA   <span class="hljs-comment">// 从堆中读取引用，需要加入屏障</span><br>&lt;Load barrier&gt;<br>Object p = o  <span class="hljs-comment">// 无需加入屏障，因为不是从堆中读取引用</span><br>o.dosomething() <span class="hljs-comment">// 无需加入屏障，因为不是从堆中读取引用</span><br><span class="hljs-keyword">int</span> i =  obj.FieldB  <span class="hljs-comment">//无需加入屏障，因为不是对象引用</span><br></code></pre></td></tr></table></figure><p>因为有读屏障在，在对象标记和转移过程中，会根据指针染色情况首先确定对象的引用地址是否满足条件，并作出相应动作。</p><h5 id="（3）ZGC的并发收集过程"><a href="#（3）ZGC的并发收集过程" class="headerlink" title="（3）ZGC的并发收集过程"></a>（3）ZGC的并发收集过程</h5><p>ZGC的回收算法采用的是Mark-Compact ，它会将活着的对象都移动到另一个Region，然后整个回收掉原来的Region。ZGC的执行过程可以分为四个阶段，这四大阶段全部是可以并发执行的，但是在其中两个阶段中会有短暂的停顿。</p><p><strong>并发标记(Concurrent Mark )</strong></p><p>这一阶段也与G1类似，也会经历初始标记、最终标记的短暂停顿。与G1不同的是，ZGC的标记是在指针上，标记阶段会更新染色指针中的Marked0、Marked1标志位。</p><p>初始标记会标记与GCRoots直接关联的对象。</p><p>接着会遍历对象图标记处全部可达的对象。这一阶段耗时比较多，但是是并发的，因此不会发生STW。</p><p><strong>并发预备重分配（Concurrent  Prepare for Relocate）</strong></p><p>这一阶段会根据特定的查询条件统计出本次收集过程要清理的Region，将这些Region组成重分配集（Relocation Set）。</p><p><strong>发重分配（Concurrent  Relocate）</strong></p><p>这一阶段是ZGC的核心阶段。这一阶段会把存活的对象复制到新的Region，并未重分配集中的每个Region维护一个转发表（Forward Table），记录旧对象到新对象的转向关系。由于有染色指针的存在，ZGC收集器能从引用上明确知道这个对象是否处于重分配集中，如果此时用户线程并发访问了重分配集中的对象，就会触发读屏障，然后根据Region上的转发记录将访问转发到新复制的对象上。同时，修正更新该引用的值，使其指向新对象。</p><p><strong>并发重映射（Concurrent Remap）</strong><br>重映射就是修正整个堆中指向重分配集中旧对象的所有引用。因为有并发重分配的存在，这里即使不去做重映射也不会出现任何问题。因此，为了节省性能ZGC把这个阶段合并到了下一次垃圾收集循环中的并发标记阶段来完成。这样节省了一次遍历对象图的性能开销。当所有指针被修正后，记录新旧关系的转发表也会被释放掉。</p><p>可见，ZGC的整个收集过程只有在标记阶段有短暂的停顿，这是为什么ZGC能将停顿控制在10ms以内的原因。在最近发布的JDK15中，ZGC已经结束了实验阶段，成为了JDK15正式的垃圾收集器。</p><h4 id="3-3-Shenandoah收集器"><a href="#3-3-Shenandoah收集器" class="headerlink" title="3.3 Shenandoah收集器"></a>3.3 Shenandoah收集器</h4><p>其实，开始并没有打算写Shenanoah这个收集器。但是，看到刚刚发布的JDK15中已经将Shenanoah转正了。所以还是花点时间聊一聊这款收集器。Shenanoah收集器其实并非Oracle公司开发的，而是RedHat公司开发，并在2014年将它贡献给了Open JDK。既然在JDK15中Oracle将Shenanoah正式纳入JDK中，必然证明Shenanoah至少是一款可以媲美ZGC的收集器。事实也确实如此，它与ZGC一样可以将垃圾收集时的停顿时间控制在10ms以内。</p><h5 id="Shenandoah的堆内存划分"><a href="#Shenandoah的堆内存划分" class="headerlink" title="Shenandoah的堆内存划分"></a><strong>Shenandoah的堆内存划分</strong></h5><p>Shenandoah收集器对堆内存的划分与G1更为相似，它也是基于Region的堆内存布局，同样有存放大对象的Humongous Region。但是，Shenandoah没有将Region再分为新生代和老年代。同时，Shenandoah摒弃了G1收集器中耗费大量内存和计算资源维护的记忆集，改用了链接矩阵的全局数据结构来记录跨Region的引用关系。</p><h5 id="Shenandoah的关键技术"><a href="#Shenandoah的关键技术" class="headerlink" title="Shenandoah的关键技术"></a>Shenandoah的关键技术</h5><p><strong>（1）链接矩阵</strong></p><p>上边提到Shenandoah使用了链接矩阵来处理跨Region引用的问题。什么是链接矩阵呢？我们可以将它简单理解为一张二维表格，如果Region N有对象指向RegionM，就在表格的N行M列中打上一个标记，如下图所示，如果Region 5中的对象Baz引用了Region 3的Foo，Foo又引用了Region 1的Bar，那连接矩阵中的5行3列、3行1列就应该被打上标记。在回收时通过这张表格就可以得出哪些Region之间产生了跨代引用。<br><img src="https://raw.githubusercontent.com/zhpanvip/images/master/project/article/jvmgc/15.jpeg" alt="在这里插入图片描述"></p><p><strong>（2）转发指针</strong><br>转发指针的核心内容就是，在原有对象布局结构的最前面增加一个新的引用字段，在正常不处于并发移动的情况下，该引用指向对象自己。如下图：<br><img src="https://raw.githubusercontent.com/zhpanvip/images/master/project/article/jvmgc/16.png" alt="在这里插入图片描述"></p><p>转发指针加入后带来的收益自然是当对象拥有了一份新的副本时，只需要修改一处指针的值，即旧对象上转发指针的引用位置，使其指向新对象，便可将所有对该对象的访问转发到新的副本上。这样只要对象的内存仍然存在，未被清理掉，虚拟机内存中所有通过旧引用地址访问的代码仍然可用，都会被自动转发到新对象上继续工作。<br><img src="https://raw.githubusercontent.com/zhpanvip/images/master/project/article/jvmgc/17.png" alt="在这里插入图片描述"></p><p>Brooks Pointers 转发指针在设计上决定了它是必然会出现多线程竞争问题的。Shenandoah收集器是通过比较交换（Compare And Swap,CAS）操作来保证并发时堆中的访问正确性的。</p><h5 id="Shenandoah的并发收集过程"><a href="#Shenandoah的并发收集过程" class="headerlink" title="Shenandoah的并发收集过程"></a>Shenandoah的并发收集过程</h5><p>Shenandoah收集器的工作过程大致可以划分为以下九个阶段：</p><p><strong>（1）初始标记：</strong> 与G1一样，首先标记与GC Roots直接关联的对象，这个阶段仍是STW的，这一阶段停顿时间很短。</p><p><strong>（2）并发标记：</strong> 与G1一样，从GC Roots开始对堆中对象进行可达性分析，找出存活对象。并发标记阶段耗时较长，但是这一阶段是并发执行的，因此，对性能不会造成影响。</p><p><strong>（3）最终标记：</strong> 与G1一样，处理剩余的SATB扫描，并在这个阶段统计出回收价值最高的Region，将这些Region构成一组回收集。此阶段也会有一小段短暂的停顿。</p><p><strong>（4）并发清理：</strong> 这个阶段用于清理那些整个区域内连一个存活对象都没有找到的Region。</p><p><strong>（5）并发回收：</strong> 这个阶段是Shenandoah与之前HotSpot中其他收集器的核心差异。在这个阶段，Shenandoah要把回收集里面的存活对象先复制一份到其他未被使用的Region中。但是有个难点是在移动对象的同时，用户线程仍然可能不停的对被移动的对象进行读写访问，移动对象之后整个内存中所有指向该对象的引用都还是旧对象的地址，这是很难一瞬间全部改变过来的。对于这个难点，Shenandoah将会通过读屏障和被称为“Brooks Pointers”的转发指针来解决。<br>并发回收阶段运行时间的长短取决于回收集的大小。</p><p><strong>（6）初始引用更新：</strong> 并发回收阶段复制对象结束后，还需要把堆中所有指向旧对象的引用修正蛋糕复制后的新地址，这个操作称为引用更新。这个阶段就是对这个操作进行初始化的，初始引用更新时间很短，会产生一个非常短暂的停顿。</p><p><strong>并发引用更新：</strong> 真正开始进行引用更新操作，这个阶段是与用户线程一起并发的，时间长短取决于内存中涉及的引用数量的多少。</p><p><strong>（7）最终引用更新：</strong> 解决了堆中的引用更新后，还要修正存在于GC Roots 中的引用。这个阶段是Shenandoah的最后一次停顿，时间长短与GC Roots的数量有关。</p><p><strong>（8）并发清理：</strong> 经过并发回收和引用更新之后，整个回收集中所有的Region已再无存活对象，最后再调用一次并发清理过程来回收这些Region 的内存空间，供以后新对象分配使用。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇文章从堆的分代到垃圾收集算法再到垃圾收集器都做了比较详细的讲解。关于垃圾收集器这部分内容其实本来没打算写的太详细，因为笔者本身做的是客户端，而客户端对于收集器的性能并没有太高的要求，加之Android端到目前为止仅支持到Java8版本。所以一般情况下，客户端开发者不太会关注到Java8之后比较前沿的Java知识。像ZGC、Shenandoah这种前沿的垃圾收集器更不会关注太多。但是对于而后台开发而言却是完全不同。拿垃圾收集器来说，后台相比客户端会比较迫切的需要能够支持大内存、低延迟的收集器。所以，既然写Java GC的文章，就不能只面向客户端。讲不明白垃圾收集器总觉得会少了点什么。所以在写ZGC和Shenandoah收集器的过程中花了大量时间去查阅了很多资料，往往是看懂了，理解了，然后才能动手来写。因此，免不了的也会有些疏漏或错误，还望大家多多包含。同时，希望大家通过这篇文章能够得到自己想要的知识。</p><h2 id="参考-amp-推荐阅读"><a href="#参考-amp-推荐阅读" class="headerlink" title="参考&amp;推荐阅读"></a>参考&amp;推荐阅读</h2><p>《深入理解Java虚拟机 第二版/第三版》作者：周志明</p><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MDI3MjA5MQ==&mid=2697268836&idx=1&sn=4c783b7c6541a9df0baf0b9060ff4c08&chksm=8376f150b401784656eef2414311b8a0290e1902fc6ab2665bc12c9d5c9c8ef194b968c7b7cb&scene=27#wechat_redirect">一文看懂JVM内存布局及GC原理</a></p><p><a href="https://cloud.tencent.com/developer/article/1623210">深入理解 JVM 垃圾回收机制及其实现原理</a></p><p><a href="https://www.cnblogs.com/paddix/p/5309550.html">Java8内存模型—永久代(PermGen)和元空间(Metaspace)</a></p><p><a href="https://juejin.im/post/6844903666432868365">搞定JVM垃圾回收就是这么简单</a></p><p><a href="https://juejin.im/entry/6844903666902630414">Java程序员的荣光，听R大论JDK11的ZGC</a></p><p><a href="https://blog.csdn.net/MeituanTech/article/details/107853015">新一代垃圾回收器ZGC的探索与实践</a></p><p><a href="https://my.oschina.net/u/4334817/blog/4315059">深入理解JVM（③）低延迟的Shenandoah收集器</a></p>]]></content>
    
    
    <categories>
      
      <category>Java进阶</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入理解Java中的字符串(二)</title>
    <link href="/2020/09/12/28.String%20in%20java%20(2)/"/>
    <url>/2020/09/12/28.String%20in%20java%20(2)/</url>
    
    <content type="html"><![CDATA[<p><a href="https://zhangpan.site/2020/09/08/27.String%20in%20java(1)/">上篇文章</a>我们深入分析了String的内存和它的一些特性。本篇文章我们深入的来分析一下与String相关的另外两个类，它们分别是StringBuilder和StringBuffer。这两个类与String有什么关系呢？首先我们看下下边这张类图：</p><p><img src="https://raw.githubusercontent.com/zhpanvip/images/master/project/article/string/2801.webp"><br>从图中可以看出StringBuilder和StringBuffer都继承了AbstractStringBuilder，而AbstractStringBuilder与String实现了共同的接口CharSequence。</p><p>我们知道，字符串是由一系列字符组成的，String的内部就是基于char数组（jdk9之后基于byte数组）实现的，而数组通常是一块连续的内存区域，在数组初始化的时候就需要指定数组的大小。上一篇文章中我们已经知道String是不可变的，因为它内部的数组被声明为了final，同时，String的字符拼接、插入、删除等操作均是通过实例化新的对象实现的。而今天要认识的StringBuilder和StringBuffer与String相比就具有了动态性。接下来就让我们一起来认识下这两个类。</p><h2 id="一、StringBuilder"><a href="#一、StringBuilder" class="headerlink" title="一、StringBuilder"></a>一、StringBuilder</h2><p>在StringBuilder的父类AbstractStringBuilder 中可以看到如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractStringBuilder</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Appendable</span>, <span class="hljs-title">CharSequence</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * The value is used for character storage.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">char</span>[] value;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * The count is the number of characters used.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">int</span> count;<br>&#125;<br></code></pre></td></tr></table></figure><p>StringBuilder与String一样都是基于char数组实现的，不同的是StringBuilder没有final修饰，这就意味着StringBuilder是可以被动态改变的。接下来看下StringBuilder无参构造方法，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * Constructs a string builder with no characters in it and an</span><br><span class="hljs-comment">    * initial capacity of 16 characters.</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">StringBuilder</span><span class="hljs-params">()</span> </span>&#123;<br>       <span class="hljs-keyword">super</span>(<span class="hljs-number">16</span>);<br>   &#125;<br></code></pre></td></tr></table></figure><p>在这个方法中调用了父类的构造方法，到AbstractStringBuilder 中看到其构造方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Creates an AbstractStringBuilder of the specified capacity.</span><br><span class="hljs-comment"> */</span><br>AbstractStringBuilder(<span class="hljs-keyword">int</span> capacity) &#123;<br>    value = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[capacity];<br>&#125;<br></code></pre></td></tr></table></figure><p>AbstractStringBuilder的构造方法内部初始化了一个容量为capacity的数组。也就是说StringBuilder默认初始化了一个容量为16的char[]数组。StringBuilder中除了无参构造外还提供了多个构造方法，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * Constructs a string builder with no characters in it and an</span><br><span class="hljs-comment">    * initial capacity specified by the &#123;<span class="hljs-doctag">@code</span> capacity&#125; argument.</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span>      capacity  the initial capacity.</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@throws</span>     NegativeArraySizeException  if the &#123;<span class="hljs-doctag">@code</span> capacity&#125;</span><br><span class="hljs-comment">    *               argument is less than &#123;<span class="hljs-doctag">@code</span> 0&#125;.</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">StringBuilder</span><span class="hljs-params">(<span class="hljs-keyword">int</span> capacity)</span> </span>&#123;<br>       <span class="hljs-keyword">super</span>(capacity);<br>   &#125;<br><br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * Constructs a string builder initialized to the contents of the</span><br><span class="hljs-comment">    * specified string. The initial capacity of the string builder is</span><br><span class="hljs-comment">    * &#123;<span class="hljs-doctag">@code</span> 16&#125; plus the length of the string argument.</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span>   str   the initial contents of the buffer.</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">StringBuilder</span><span class="hljs-params">(String str)</span> </span>&#123;<br>       <span class="hljs-keyword">super</span>(str.length() + <span class="hljs-number">16</span>);<br>       append(str);<br>   &#125;<br><br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * Constructs a string builder that contains the same characters</span><br><span class="hljs-comment">    * as the specified &#123;<span class="hljs-doctag">@code</span> CharSequence&#125;. The initial capacity of</span><br><span class="hljs-comment">    * the string builder is &#123;<span class="hljs-doctag">@code</span> 16&#125; plus the length of the</span><br><span class="hljs-comment">    * &#123;<span class="hljs-doctag">@code</span> CharSequence&#125; argument.</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span>      seq   the sequence to copy.</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">StringBuilder</span><span class="hljs-params">(CharSequence seq)</span> </span>&#123;<br>       <span class="hljs-keyword">this</span>(seq.length() + <span class="hljs-number">16</span>);<br>       append(seq);<br>   &#125;<br></code></pre></td></tr></table></figure><p>这段代码的第一个方法初始化一个指定容量大小的StringBuilder。另外两个构造方法分别可以传入String和CharSequence来初始化StringBuilder，这两个构造方法的容量均会在传入字符串长度的基础上在加上16。</p><h3 id="1-StringBuilder的append操作与扩容"><a href="#1-StringBuilder的append操作与扩容" class="headerlink" title="1.StringBuilder的append操作与扩容"></a>1.StringBuilder的append操作与扩容</h3><p>上篇文章已经知道通过StringBuilder的append方法可以进行高效的字符串拼接，append方法是如何实现的呢？这里以append（String）为例，可以看到StringBuilder的append调用了父类的append方法，其实不止append，StringBuilder类中操作字符串的方法几乎都是通过父类来实现的。append方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">// StringBuilder</span><br><span class="hljs-meta">@Override</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> StringBuilder <span class="hljs-title">append</span><span class="hljs-params">(String str)</span> </span>&#123;<br>       <span class="hljs-keyword">super</span>.append(str);<br>       <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>   &#125;<br><br> <span class="hljs-comment">// AbstractStringBuilder</span><br> <span class="hljs-function"><span class="hljs-keyword">public</span> AbstractStringBuilder <span class="hljs-title">append</span><span class="hljs-params">(String str)</span> </span>&#123;<br>       <span class="hljs-keyword">if</span> (str == <span class="hljs-keyword">null</span>)<br>           <span class="hljs-keyword">return</span> appendNull();<br>       <span class="hljs-keyword">int</span> len = str.length();<br>       ensureCapacityInternal(count + len);<br>       str.getChars(<span class="hljs-number">0</span>, len, value, count);<br>       count += len;<br>       <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>   &#125;<br><br></code></pre></td></tr></table></figure><p>在append方法的第一行首先进行了null检查，等于null的时候调用了appendNull方法。其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> AbstractStringBuilder <span class="hljs-title">appendNull</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> c = count;<br>        ensureCapacityInternal(c + <span class="hljs-number">4</span>);<br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">char</span>[] value = <span class="hljs-keyword">this</span>.value;<br>        value[c++] = <span class="hljs-string">&#x27;n&#x27;</span>;<br>        value[c++] = <span class="hljs-string">&#x27;u&#x27;</span>;<br>        value[c++] = <span class="hljs-string">&#x27;l&#x27;</span>;<br>        value[c++] = <span class="hljs-string">&#x27;l&#x27;</span>;<br>        count = c;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p>appendNull方法中首先调用了ensureCapacityInternal来确保字符串数组容量充值，关于ensureCapacityInternal这个方法下边再详细分析。接下来可以看到把”null”的字符添加到了char[]数组value中。</p><p>上文我们提到，StringBuilder内部数组的默认容量是16，因此，在进行字符串拼接的时候需要先确保char[]数组有足够的容量。因此，在appendNull方法以及append方法中都调用了ensureCapacityInternal方法来检查char[]数组是否有足够的容量，如果容量不足则会对数组进行扩容，ensureCapacityInternal源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ensureCapacityInternal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minimumCapacity)</span> </span>&#123;<br>        <span class="hljs-comment">// overflow-conscious code</span><br>        <span class="hljs-keyword">if</span> (minimumCapacity - value.length &gt; <span class="hljs-number">0</span>)<br>            expandCapacity(minimumCapacity);<br>    &#125;<br></code></pre></td></tr></table></figure><p>这里判读如果拼接后的字符串长度大于字符串数组的长度则会调用expandCapacity进行扩容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">expandCapacity</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minimumCapacity)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> newCapacity = value.length * <span class="hljs-number">2</span> + <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (newCapacity - minimumCapacity &lt; <span class="hljs-number">0</span>)<br>            newCapacity = minimumCapacity;<br>        <span class="hljs-keyword">if</span> (newCapacity &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (minimumCapacity &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// overflow</span><br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> OutOfMemoryError();<br>            newCapacity = Integer.MAX_VALUE;<br>        &#125;<br>        value = Arrays.copyOf(value, newCapacity);<br>    &#125;<br></code></pre></td></tr></table></figure><p>expandCapacity的逻辑也很简单，首先通过原数组的长度乘2并加2后计算得到扩容后的数组长度。接下来判断了newCapacity如果小于minimumCapacity，则将minimumCapacity值赋值给了newCapacity。这里因为调用expandCapacity方法的不止一个地方，所以加这句代码确保安全。</p><p>而接下来的一句代码就很有趣了，newCapacity 和minimumCapacity 还有可能小于0吗？当minimumCapacity小于0的时候竟然还抛出了一个OutOfMemoryError异常。其实，这里小于0是因为越界了。我们知道在计算机中存储的都是二进制，乘2相当于向左移了一位。以byte为例，一个byte有8bit,在有符号数中最左边的一个bit位是符号位，正数的符号位为0，负数为1。那么一个byte可以表示的大小范围为[-128~127]，而如果一个数字大于127时则会出现越界，即最左边的符号位会被左边第二位的1顶替，就出现了负数的情况。当然，并不是byte而是int,但是原理是一样的。</p><p>另外在这个方法的最后一句通过Arrays.copyOf进行了一个数组拷贝，其实Arrays.copyOf在上篇文章中就有见到过，在这里不妨来分析一下这个方法，看源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">char</span>[] copyOf(<span class="hljs-keyword">char</span>[] original, <span class="hljs-keyword">int</span> newLength) &#123;<br>       <span class="hljs-keyword">char</span>[] copy = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[newLength];<br>       System.arraycopy(original, <span class="hljs-number">0</span>, copy, <span class="hljs-number">0</span>,<br>                        Math.min(original.length, newLength));<br>       <span class="hljs-keyword">return</span> copy;<br>   &#125;<br></code></pre></td></tr></table></figure><p>咦？copyOf方法中竟然也去实例化了一个对象！！那不会影响性能吗？莫慌，看一下这里仅仅是实例化了一个newLength长度的空数组，对于数组的初始化其实仅仅是指针的移动而已，浪费的性能可谓微乎其微。接着这里通过System.arraycopy的native方法将原数组复制到了新的数组中。</p><h3 id="2-StringBuilder的subString-方法toString-方法"><a href="#2-StringBuilder的subString-方法toString-方法" class="headerlink" title="2.StringBuilder的subString()方法toString()方法"></a>2.StringBuilder的subString()方法toString()方法</h3><p>StringBuilder中其实没有subString方法，subString的实现是在StringBuilder的父类AbstractStringBuilder中的。它的代码非常简单，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">substring</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (start &lt; <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StringIndexOutOfBoundsException(start);<br>        <span class="hljs-keyword">if</span> (end &gt; count)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StringIndexOutOfBoundsException(end);<br>        <span class="hljs-keyword">if</span> (start &gt; end)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StringIndexOutOfBoundsException(end - start);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String(value, start, end - start);<br>    &#125;<br></code></pre></td></tr></table></figure><p>在进行了合法判断之后，substring直接实例化了一个String对象并返回。这里和String的subString实现其实并没有多大差别。<br>而StringBuilder的toString方法的实现其实更简单，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>       <span class="hljs-comment">// Create a copy, don&#x27;t share the array</span><br>       <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String(value, <span class="hljs-number">0</span>, count);<br>   &#125;<br></code></pre></td></tr></table></figure><p>这里直接实例化了一个String对象并将StringBuilder中的value传入，我们来看下String(value, 0, count)这个构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">String</span><span class="hljs-params">(<span class="hljs-keyword">char</span> value[], <span class="hljs-keyword">int</span> offset, <span class="hljs-keyword">int</span> count)</span> </span>&#123;<br>      <span class="hljs-keyword">if</span> (offset &lt; <span class="hljs-number">0</span>) &#123;<br>          <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StringIndexOutOfBoundsException(offset);<br>      &#125;<br>      <span class="hljs-keyword">if</span> (count &lt; <span class="hljs-number">0</span>) &#123;<br>          <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StringIndexOutOfBoundsException(count);<br>      &#125;<br>      <span class="hljs-comment">// Note: offset or count might be near -1&gt;&gt;&gt;1.</span><br>      <span class="hljs-keyword">if</span> (offset &gt; value.length - count) &#123;<br>          <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StringIndexOutOfBoundsException(offset + count);<br>      &#125;<br>      <span class="hljs-keyword">this</span>.value = Arrays.copyOfRange(value, offset, offset+count);<br>  &#125;<br></code></pre></td></tr></table></figure><p>可以看到，在String的这个构造方法中又通过Arrays.copyOfRange方法进行了数组拷贝，Arrays.copyOfRange的源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">char</span>[] copyOfRange(<span class="hljs-keyword">char</span>[] original, <span class="hljs-keyword">int</span> from, <span class="hljs-keyword">int</span> to) &#123;<br>     <span class="hljs-keyword">int</span> newLength = to - from;<br>     <span class="hljs-keyword">if</span> (newLength &lt; <span class="hljs-number">0</span>)<br>         <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(from + <span class="hljs-string">&quot; &gt; &quot;</span> + to);<br>     <span class="hljs-keyword">char</span>[] copy = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[newLength];<br>     System.arraycopy(original, from, copy, <span class="hljs-number">0</span>,<br>                      Math.min(original.length - from, newLength));<br>     <span class="hljs-keyword">return</span> copy;<br> &#125;<br></code></pre></td></tr></table></figure><p>Arrays.copyOfRange与Arrays.copyOf类似，内部都是重新实例化了一个char[]数组，所以String构造方法中的this.value与传入进来的value不是同一个对象。<strong>意味着StringBuilder在每次调用toString的时候生成的String对象内部的char[]数组并不是同一个！这里立一个Falg</strong>！</p><h3 id="3-StringBuilder的其它方法"><a href="#3-StringBuilder的其它方法" class="headerlink" title="3.StringBuilder的其它方法"></a>3.StringBuilder的其它方法</h3><p>StringBuilder除了提供了append方法、subString方法以及toString方法外还提供了还提供了插入（insert）、删除（delete、deleteCharAt）、替换（replace）、查找（indexOf）以及反转（reverse）等一些列的字符串操作的方法。但由于实现都非常简单，这里就不再赘述了。</p><h2 id="二、StringBuffer"><a href="#二、StringBuffer" class="headerlink" title="二、StringBuffer"></a>二、StringBuffer</h2><p>在第一节已经知道，StringBuilder的方法几乎都是在它的父类AbstractStringBuilder中实现的。而StringBuffer同样继承了AbstractStringBuilder，这就意味着StringBuffer的功能其实跟StringBuilder并无太大差别。我们通过StringBuffer几个方法来看</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * A cache of the last value returned by toString. Cleared</span><br><span class="hljs-comment">     * whenever the StringBuffer is modified.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">char</span>[] toStringCache;<br><br>  <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> StringBuffer <span class="hljs-title">append</span><span class="hljs-params">(String str)</span> </span>&#123;<br>        toStringCache = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">super</span>.append(str);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> StringIndexOutOfBoundsException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@since</span>      1.2</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> StringBuffer <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span> </span>&#123;<br>        toStringCache = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">super</span>.delete(start, end);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> StringIndexOutOfBoundsException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@since</span>      1.2</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> StringBuffer <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, <span class="hljs-keyword">char</span>[] str, <span class="hljs-keyword">int</span> offset,</span></span><br><span class="hljs-function"><span class="hljs-params">                                            <span class="hljs-keyword">int</span> len)</span></span><br><span class="hljs-function">    </span>&#123;<br>        toStringCache = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">super</span>.insert(index, str, offset, len);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br><br><span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> String <span class="hljs-title">substring</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> substring(start, count);<br>    &#125;<br><br><span class="hljs-comment">// ...</span><br></code></pre></td></tr></table></figure><p>可以看到在StringBuffer的方法上都加上了synchronized关键字,也就是说StringBuffer的所有操作都是线程安全的。所以，在多线程操作字符串的情况下应该首选StringBuffer。<br>另外，我们注意到在StringBuffer的方法中比StringBuilder多了一个toStringCache的成员变量 ，从源码中看到toStringCache是一个char[]数组。它的注释是这样描述的：</p><blockquote><p>toString返回的最后一个值的缓存，当StringBuffer被修改的时候该值都会被清除。</p></blockquote><p>我们再观察一下StringBuffer中的方法，发现只要是操作过操作过StringBuffer中char[]数组的方法，toStringCache都被置空了！而没有操作过字符数组的方法则没有对其做置空操作。另外，注释中还提到了 toString方法，那我们不妨来看一看StringBuffer中的 toString，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>     <span class="hljs-keyword">if</span> (toStringCache == <span class="hljs-keyword">null</span>) &#123;<br>         toStringCache = Arrays.copyOfRange(value, <span class="hljs-number">0</span>, count);<br>     &#125;<br>     <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String(toStringCache, <span class="hljs-keyword">true</span>);<br> &#125;<br></code></pre></td></tr></table></figure><p>这个方法中首先判断当toStringCache 为null时会通过 Arrays.copyOfRange方法对其进行赋值，Arrays.copyOfRange方法上边已经分析过了，他会重新实例化一个char[]数组，并将原数组赋值到新数组中。这样做有什么影响呢？细细思考一下不难发现在不修改StringBuffer的前提下，多次调用StringBuffer的toString方法，生成的String对象都共用了同一个字符数组–toStringCache。这里是StringBuffer和StringBuilder的一点区别。至于StringBuffer中为什么这么做其实并没有很明确的原因，可以参考StackOverRun<br><a href="https://stackoverrun.com/cn/q/12697236">《Why StringBuffer has a toStringCache while StringBuilder not?》</a>中的一个回答:</p><blockquote><p>1.因为StringBuffer已经保证了线程安全，所以更容易实现缓存（StringBuilder线程不安全的情况下需要不断同步toStringCache）<br>2.可能是历史原因</p></blockquote><h2 id="三、-总结"><a href="#三、-总结" class="headerlink" title="三、 总结"></a>三、 总结</h2><p>本篇文章到此就结束了。《深入理解Java中的字符串》通过两篇文章深入的分析了String、StringBuilder与StringBuffer三个字符串相关类。这块内容其实非常简单，只要花一点时间去读一下源码就很容易理解。当然，如果你没看过此部分源码相信这篇文章能够帮助到你。不管怎样，相信大家通过阅读本文还是能有一些收获。解了这些知识后可以帮助我们在开发中对字符串的选用做出更好的选择。同时，这块内容也是面试常客，相信大家读完本文去应对面试官的问题也会绰绰有余。</p>]]></content>
    
    
    <categories>
      
      <category>Java进阶</category>
      
    </categories>
    
    
    <tags>
      
      <tag>String</tag>
      
      <tag>StringBuilder</tag>
      
      <tag>StringBuffer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入理解Java中的字符串(一)</title>
    <link href="/2020/09/08/27.String%20in%20java(1)/"/>
    <url>/2020/09/08/27.String%20in%20java(1)/</url>
    
    <content type="html"><![CDATA[<p>初学Java时我们已经知道Java中可以分为两大数据类型，分别为基本数据类型和引用数据类型。而在这两大数据类型中有一个特殊的数据类型String，String属于引用数据类型，但又有区别于其它的引用数据类型。可以说它是数据类型中的一朵奇葩。那么，本篇文章我们就来深入的认识一下Java中的String字符串。</p><h2 id="一、从String字符串的内存分配说起"><a href="#一、从String字符串的内存分配说起" class="headerlink" title="一、从String字符串的内存分配说起"></a>一、从String字符串的内存分配说起</h2><p>上一篇文章<a href="https://blog.csdn.net/qq_20521573/article/details/108394326">《温故知新–你不知道的JVM内存分配》</a>详细的分析了JVM的内存模型。在常量池部分我们了解了三种常量池，分别为：字符串常量池、Class文件常量池以及运行时常量池。而字符串的内存分配则和字符串常量池有着莫大的关系。</p><p>我们知道，实例化一个字符串可以通过两种方法来实现，第一种最常用的是通过字面量赋值的方式，另一种是通过构造方法传参的方式。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">String str1=<span class="hljs-string">&quot;abc&quot;</span>;<br>String str2=<span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;abc&quot;</span>);<br></code></pre></td></tr></table></figure><p>这两种方式在内存分配上有什么不同呢? 相信大家在初学Java的时候老师都有给我们讲解过：</p><blockquote><p>1.通过字面量赋值的方式创建String，只会在字符串常量池中生成一个String对象。<br>2.通过构造方法传入String参数的方式会在堆内存和字符串常量池中各生成一个String对象，并将堆内存上String的引用放入栈。</p></blockquote><p>这样的回答正确吗？至少在现在看来并不完全正确，因为它完全取决于使用的Java版本。上一篇文章<a href="https://blog.csdn.net/qq_20521573/article/details/108394326">《温故知新–你不知道的JVM内存分配》</a>谈到HotSpot虚拟机在不同的JDK上对于字符串常量池的实现是不同的，摘录如下：</p><blockquote><p>在JDK7以前，字符串常量池在方法区（永久代）中，此时常量池中存放的是字符串对象。而在JDK7中，字符串常量池从方法区迁移到了堆内存，同时将字符串对象存到了Java堆，字符串常量池中只是存入了字符串对象的引用。</p></blockquote><p>这句话应该怎么理解呢？我们以String str1=new String(“abc”)为例来分析：</p><h3 id="1-JDK6中的内存分配"><a href="#1-JDK6中的内存分配" class="headerlink" title="1.JDK6中的内存分配"></a>1.JDK6中的内存分配</h3><p>先来分析一下JDK6的内存分配情况，如下图所示：<br><img src="https://raw.githubusercontent.com/zhpanvip/images/master/project/article/string/jdk6-01.png" alt="jdk6-01"><br>当调用new String(“abc”)后，会在Java堆与常量池中各生成一个“abc”对象。同时，将str1指向堆中的“abc”对象。</p><h3 id="2-JDK7中的内存分配"><a href="#2-JDK7中的内存分配" class="headerlink" title="2.JDK7中的内存分配"></a>2.JDK7中的内存分配</h3><p>而在JDK7及以后版本中，由于字符串常量池被移到了堆内存，所以内存分配方式也有所不同，如下图所示：<br><img src="https://raw.githubusercontent.com/zhpanvip/images/master/project/article/string/jdk7-01.png" alt="jdk7-01"><br>当调用了new String(“abc”)后，会在堆内存中创建两个“abc”对象，str1指向其中一个”abc”对象，而常量池中则会生成一个“abc”对象的引用，并指向另一个”abc”对象。</p><p>至于Java中为什么要这么设计，我们在上篇文章中也已经解释了：** 因为String是Java中使用最频繁的一种数据类型，为了节省程序内存提高程序性能，Java的设计者们开辟了一块字符串常量池区域，这块区域是是所有类共享的，每个虚拟机只有一个字符串常量池。因此，在使用字面量方式赋值的时候，如果字符串常量池中已经有了该字符串，则不会在堆内存中重新创建对象，而是直接将其指向了字符串常量池中的对象。**</p><h2 id="二、String的intern-方法"><a href="#二、String的intern-方法" class="headerlink" title="二、String的intern()方法"></a>二、String的intern()方法</h2><p>在了解了String的内存分配之后，我们需要再来认识一下String中一个很重要的方法：String.intern()。</p><p>很多读者可能对于这一方法并不是太了解，但并不代表他不重要。我们先来看一下intern()方法的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Returns a canonical representation for the string object.</span><br><span class="hljs-comment">     * &lt;p&gt;</span><br><span class="hljs-comment">     * A pool of strings, initially empty, is maintained privately by the</span><br><span class="hljs-comment">     * class &#123;<span class="hljs-doctag">@code</span> String&#125;.</span><br><span class="hljs-comment">     * &lt;p&gt;</span><br><span class="hljs-comment">     * When the intern method is invoked, if the pool already contains a</span><br><span class="hljs-comment">     * string equal to this &#123;<span class="hljs-doctag">@code</span> String&#125; object as determined by</span><br><span class="hljs-comment">     * the &#123;<span class="hljs-doctag">@link</span> #equals(Object)&#125; method, then the string from the pool is</span><br><span class="hljs-comment">     * returned. Otherwise, this &#123;<span class="hljs-doctag">@code</span> String&#125; object is added to the</span><br><span class="hljs-comment">     * pool and a reference to this &#123;<span class="hljs-doctag">@code</span> String&#125; object is returned.</span><br><span class="hljs-comment">     * &lt;p&gt;</span><br><span class="hljs-comment">     * It follows that for any two strings &#123;<span class="hljs-doctag">@code</span> s&#125; and &#123;<span class="hljs-doctag">@code</span> t&#125;,</span><br><span class="hljs-comment">     * &#123;<span class="hljs-doctag">@code</span> s.intern() == t.intern()&#125; is &#123;<span class="hljs-doctag">@code</span> true&#125;</span><br><span class="hljs-comment">     * if and only if &#123;<span class="hljs-doctag">@code</span> s.equals(t)&#125; is &#123;<span class="hljs-doctag">@code</span> true&#125;.</span><br><span class="hljs-comment">     * &lt;p&gt;</span><br><span class="hljs-comment">     * All literal strings and string-valued constant expressions are</span><br><span class="hljs-comment">     * interned. String literals are defined in section 3.10.5 of the</span><br><span class="hljs-comment">     * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span>  a string that has the same contents as this string, but is</span><br><span class="hljs-comment">     *          guaranteed to be from a pool of unique strings.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> String <span class="hljs-title">intern</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure><p>emmmmm….居然是一个native方法，不过没关系，即使看不到源码我们也能从其注释中得到一些信息：<strong>当调用intern方法的时候，如果字符串常量池中已经包含了一个等于该String对象的字符串，则直接返回字符串常量池中该字符串的引用。否则，会将该字符串对象包含的字符串添加到常量池，并返回此对象的引用。</strong></p><h3 id="1-一个关于intern-的简单例子"><a href="#1-一个关于intern-的简单例子" class="headerlink" title="1.一个关于intern()的简单例子"></a>1.一个关于intern()的简单例子</h3><p>了解了intern方法的用途之后，来看一个简单的列子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>String str1 = <span class="hljs-string">&quot;hello world&quot;</span>;<br>String str2 = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;hello world&quot;</span>);<br>String str3=str2.intern();<br>System.out.println(<span class="hljs-string">&quot;str1 == str2:&quot;</span>+(str1 == str2));<br>System.out.println(<span class="hljs-string">&quot;str1 == str3:&quot;</span>+(str1 == str3));<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的一段代码会输出什么？编译运行之后如下：<br><img src="https://raw.githubusercontent.com/zhpanvip/images/master/project/article/string/jdk7-02.png" alt="jdk7-02"></p><p>如果理解了intern方法就很容易解释这个结果了，从上面截图中可以看到，我们的运行环境是JDK8。</p><p><strong><em>String str1 = “hello world”;</em></strong> 这行代码会首先在Java堆中创建一个对象，并将该对象的引用放入字符串常量池中，str1指向常量池中的引用。</p><p><strong><em>String str2 = new String(“hello world”);</em></strong>这行代码会通过new来实例化一个String对象，并将该对象的引用赋值给str2，然后检测字符串常量池中是否已经有了与“hello world”相等的对象，如果没有，则会在堆内存中再生成一个值为”hello world”的对象，并将其引用放入到字符串常量池中，否则，不会再去创建。这里，第一行代码其实已经在字符串常量池中保存了“hello world”字符串对象的引用，因此，第二行代码就不会再次向常量池中添加“hello world”的引用。</p><p><strong><em>String str3=str2.intern();</em></strong> 这行代码会首先去检测字符串常量池中是否已经包含了”hello world”的String对象，如果有则直接返回其引用。而在这里，str2.intern()其实刚好返回了第一行代码中生成的“hello world”对象。</p><p>因此【System.out.println(“str1 == str3:”+(str1 == str3));】这行代码会输出true.</p><p>如果切到JDK6，其打印结果与上一致，至于原因读者可以自行分析。</p><p><img src="https://raw.githubusercontent.com/zhpanvip/images/master/project/article/string/jdk6-02.png" alt="jdk6-02"></p><h3 id="2-改造例子，再看intern"><a href="#2-改造例子，再看intern" class="headerlink" title="2.改造例子，再看intern"></a>2.改造例子，再看intern</h3><p>上一节中我们通过一个例子认识了intern()方法的作用，接下来，我们对上述例子做一些修改：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> &#123;</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br><span class="hljs-keyword">String</span> str1=<span class="hljs-keyword">new</span> <span class="hljs-keyword">String</span>(<span class="hljs-string">&quot;he&quot;</span>)+<span class="hljs-keyword">new</span> <span class="hljs-keyword">String</span>(<span class="hljs-string">&quot;llo&quot;</span>);<br><span class="hljs-keyword">String</span> str2=str1.intern();<br><span class="hljs-keyword">String</span> str3=<span class="hljs-string">&quot;hello&quot;</span>;<br>System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;str1 == str2:&quot;</span>+(str1 == str2));<br>System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;str2 == str3:&quot;</span>+(str2 == str3));<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>先别急着看下方答案，思考一下在JDK7（或JDK7之后）及JDK6上会输出什么结果？</p><h4 id="1-JDK8的运行结果分析"><a href="#1-JDK8的运行结果分析" class="headerlink" title="1).JDK8的运行结果分析"></a>1).JDK8的运行结果分析</h4><p>我们先来看下我们先来看下JDK8的运行结果：</p><p><img src="https://raw.githubusercontent.com/zhpanvip/images/master/project/article/string/jdk7-03.png" alt="jdk7-03"></p><p>通过运行程序发现输出的两个结果都是true，这是为什么呢？我们通过一个图来分析：<br><img src="https://raw.githubusercontent.com/zhpanvip/images/master/project/article/string/jdk7-02.png"><br>**<em>String str1=new String(“he”)+new String(“llo”);**</em> 这行代码中new String(“he”)和new String(“llo”)会在堆上生成四个对象，因为与本例无关，所以图上没有画出，new String(“he”)+new String(“llo”)通过”+“号拼接后最终会生成一个”hello”对象并赋值给str1。</p><p><strong><em>String str2=str1.intern();</em></strong> 这行代码会首先检测字符串常量池，发现此时还没有存在与”hello”相等的字符串对象的引用，而在检测堆内存时发现堆中已经有了“hello”对象，遂将堆中的”hello”对象的应用放入字符串常量池中。</p><p><strong><em>String str3=”hello”;</em></strong> 这行代码发现字符串常量池中已经存在了“hello”对象的引用，因此将str3指向了字符串常量池中的引用。</p><p>此时，我们发现str1、str2、str3指向了堆中的同一个”hello”对象，因此，就有了上边两个均为true的输出结果。</p><h4 id="2-JDK6的运行结果分析"><a href="#2-JDK6的运行结果分析" class="headerlink" title="2).JDK6的运行结果分析"></a>2).JDK6的运行结果分析</h4><p>我们将运行环境切换到JDK6，来看下其输出结果：<br><img src="https://raw.githubusercontent.com/zhpanvip/images/master/project/article/string/jdk6-03.png" alt="jdk6-03"><br>有点意思！相同的代码在不同的JDK版本上输出结果竟然不相等。这是怎么回事呢？我们还通过一张图来分析：<br><img src="https://raw.githubusercontent.com/zhpanvip/images/master/project/article/string/jdk6-04.png" alt="jdk7-04"><br>**<em>String str1=new String(“he”)+new String(“llo”);**</em> 这行代码会通过new String(“he”)和new String(“llo”)会分别在Java堆与字符串常量池中各生成两个String对象，由于与本例无关，所以并没有在图中画出。而new String(“he”)+new String(“llo”)通过“+”号拼接后最终会在Java堆上生成一个”hello”对象，并将其赋值给了str1。</p><p><strong><em>String str2=str1.intern();</em></strong> 这行代码检测到字符串常量池中还没有“hello”对象，因此将堆中的”hello“对象复制到了字符串常量池，并将其赋值给str2。</p><p><strong><em>String str3=”hello”;</em></strong> 这行代码检测到字符串常量池中已经有了”hello“对象，因此直接将str3指向了字符串常量池中的”hello“对象。<br>此时str1指向的是Java堆中的”hello“对象，而str2和str3均指向了字符串常量池中的对象。因此，有了上面的输出结果。</p><p>通过这两个例子，相信大家因该对String的intern()方法有了较深的认识。那么intern()方法具体在开发中有什么用呢？推荐大家可以看下美团技术团队的一篇文章<a href="https://tech.meituan.com/2014/03/06/in-depth-understanding-string-intern.html">《深入解析String#intern》</a>中举的两个例子。限于篇幅，本文不再举例分析。</p><h2 id="三、String类的结构及特性分析"><a href="#三、String类的结构及特性分析" class="headerlink" title="三、String类的结构及特性分析"></a>三、String类的结构及特性分析</h2><p>前两节我们认识了String的内存分配以及它的intern()方法，这两节内容其实都是对String内存的分析。到目前为止，我们还并未认识String类的结构以及它的一些特性。那么本节内容我们就此来分析。先通过一段代码来大致了解一下String类的结构（代码取自jdk8）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">String</span></span><br><span class="hljs-class">    <span class="hljs-keyword">implements</span> <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span>, <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">String</span>&gt;, <span class="hljs-title">CharSequence</span> </span>&#123;<br><span class="hljs-comment">/** The value is used for character storage. */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">char</span> value[];<br>    <span class="hljs-comment">/** Cache the hash code for the string */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> hash; <span class="hljs-comment">// Default to 0</span><br><span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到String类实现了Serializable接口、Comparable接口以及CharSequence接口，意味着它可以被序列化，同时方便我们排序。另外，String类还被声明为了final类型，这意味着String类是不能被继承的。而在其内部维护了一个char数组，说明String是通过char数组来实现的，同时我们注意到这个char数组也被声明为了final，这也是我们常说的String是不可变的原因。</p><h3 id="1-不同JDK版本之间String的差异"><a href="#1-不同JDK版本之间String的差异" class="headerlink" title="1.不同JDK版本之间String的差异"></a>1.不同JDK版本之间String的差异</h3><p>Java的设计团队一直在对String类进行优化，这就导致了不同jdk版本上String类的实现有些许差异，只是我们使用上并无感知。下图列出了jdk6-jdk9中String源码的一些变化。<br><img src="https://raw.githubusercontent.com/zhpanvip/images/master/project/article/string/05.png"><br>可以看到在Java6之前String中维护了一个char 数组、一个偏移量 offset、一个字符数量 count以及一个哈希值 hash。<br>String对象是通过 offset 和 count 两个属性来定位 char[]  数组，获取字符串。这么做可以高效、快速地共享数组对象，同时节省内存空间，但这种方式很有可能会导致内存泄漏。</p><p>在Java7和Java8的版本中移除了 offset 和 count 两个变量了。这样的好处是String对象占用的内存稍微少了些，同时 String.substring 方法也不再共享 char[]，从而解决了使用该方法可能导致的内存泄漏问题。</p><p>从Java9开始，String中的char数组被byte[]数组所替代。我们知道一个char类型占用两个字节，而byte占用一个字节。因此在存储单字节的String时，使用char数组会比byte数组少一个字节，但本质上并无任何差别。<br>另外，注意到在Java9的版本中多了一个coder，它是编码格式的标识，在计算字符串长度或者调用 indexOf() 函数时，需要根据这个字段，判断如何计算字符串长度。coder 属性默认有 0 和 1 两个值， 0 代表Latin-1（单字节编码），1 代表 UTF-16 编码。如果 String判断字符串只包含了 Latin-1，则 coder 属性值为 0 ，反之则为 1。</p><h3 id="2-String字符串的裁剪、拼接等操作分析"><a href="#2-String字符串的裁剪、拼接等操作分析" class="headerlink" title="2.String字符串的裁剪、拼接等操作分析"></a>2.String字符串的裁剪、拼接等操作分析</h3><p>在本节内容的开头我们已经知道了字符串的不可变性。那么为什么我们还可以使用String的substring方法进行裁剪，甚至可以直接使用”+“连接符进行字符串的拼接呢？</p><h4 id="1-String的substring实现"><a href="#1-String的substring实现" class="headerlink" title="(1)String的substring实现"></a>(1)String的substring实现</h4><p>关于substring的实现，其实我们直接深入String的源码查看即可，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">substring</span><span class="hljs-params">(<span class="hljs-keyword">int</span> beginIndex)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (beginIndex &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StringIndexOutOfBoundsException(beginIndex);<br>        &#125;<br>        <span class="hljs-keyword">int</span> subLen = value.length - beginIndex;<br>        <span class="hljs-keyword">if</span> (subLen &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StringIndexOutOfBoundsException(subLen);<br>        &#125;<br>        <span class="hljs-keyword">return</span> (beginIndex == <span class="hljs-number">0</span>) ? <span class="hljs-keyword">this</span> : <span class="hljs-keyword">new</span> String(value, beginIndex, subLen);<br>    &#125;<br></code></pre></td></tr></table></figure><p>从这段代码中可以看出，其实字符串的裁剪是通过实例化了一个新的String对象来实现的。所以，如果在项目中存在大量的字符串裁剪的代码应尽量避免使用String，而是使用性能更好的StringBuilder或StringBuffer来处理。</p><h4 id="2-String的字符串拼接实现"><a href="#2-String的字符串拼接实现" class="headerlink" title="(2)String的字符串拼接实现"></a>(2)String的字符串拼接实现</h4><h5 id="1）字符串拼接方案性能对比"><a href="#1）字符串拼接方案性能对比" class="headerlink" title="1）字符串拼接方案性能对比"></a>1）字符串拼接方案性能对比</h5><p>关于字符串的拼接有很多实现方法，在这里我们举三个例子来进行一个性能对比，分别如下：</p><p> <strong>使用”+“操作符拼接字符串</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> COUNT=<span class="hljs-number">50000</span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>String str=<span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;COUNT;i++) &#123;<br>str=str+<span class="hljs-string">&quot;abc&quot;</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p> <strong>使用String的concat()方法拼接</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> COUNT=<span class="hljs-number">50000</span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>String str=<span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;COUNT;i++) &#123;<br>str=str+<span class="hljs-string">&quot;abc&quot;</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>使用StringBuilder的append方法拼接</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> COUNT=<span class="hljs-number">50000</span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>StringBuilder str=<span class="hljs-keyword">new</span> StringBuilder();<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;COUNT;i++) &#123;<br>str.append(<span class="hljs-string">&quot;abc&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如上代码，通过三种方法分别进行了50000次字符串拼接，每种方法分别运行了20次。统计耗时，得到以下表格：</p><table><thead><tr><th>拼接方法</th><th>最小用时（ms）</th><th>最大用时(ms)</th><th>平均用时（ms）</th></tr></thead><tbody><tr><td>“+”操作符</td><td>4868</td><td>5146</td><td>4924</td></tr><tr><td>String的concat方法</td><td>2227</td><td>2456</td><td>2296</td></tr><tr><td>StringBuilder的append方法</td><td>4</td><td>12</td><td>6.6</td></tr></tbody></table><p>从以上数据中可以很直观的看到”+“操作符的性能是最差的，平均用时达到了4924ms。其次是String的concat方法，平均用时也在2296ms。而表现最为优秀的是StringBuilder的append方法，它的平均用时竟然只有6.6ms。这也是为什么在开发中不建议使用”+“操作符进行字符串拼接的原因。</p><h5 id="2）三种字符串拼接方案原理分析"><a href="#2）三种字符串拼接方案原理分析" class="headerlink" title="2）三种字符串拼接方案原理分析"></a>2）三种字符串拼接方案原理分析</h5><p><strong>”+“操作符的实现原理</strong><br>由于”+“操作符是由JVM来完成的，我么无法直接看到代码实现。不过Java为我们提供了一个javap的工具，可以帮助我们将Class文件进行一个反汇编，通过汇编指令，大致可以看出”+“操作符的实现原理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> COUNT=<span class="hljs-number">50000</span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;COUNT;i++) &#123;<br>str=str+<span class="hljs-string">&quot;abc&quot;</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>把上边这段代码编译后，执行javap，得到如下结果：</p><p><img src="https://raw.githubusercontent.com/zhpanvip/images/master/project/article/string/06.png"><br>注意图中的”11：“行指令处实例化了一个StringBuilder，在”19：”行处调用了StringBuilder的append方法，并在第”27：”行处调用了String的toString()方法。可见，JVM在进行”+“字符串拼接时也是用了StringBuilder来实现的，但为什么与直接使用StringBuilder的差距那么大呢？其实，只要我们将上边代码转换成虚拟机优化后的代码一看便知：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> COUNT=<span class="hljs-number">50000</span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>String str=<span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;COUNT;i++) &#123;<br>str=<span class="hljs-keyword">new</span> StringBuilder(str).append(<span class="hljs-string">&quot;abc&quot;</span>).toString();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可见，优化后的代码虽然也是用的StringBuilder，但是StringBuilder却是在循环中实例化的，这就意味着循环了50000次，创建了50000个StringBuilder对象，并且调用了50000次toString()方法。怪不得用了这么长时间！！！</p><p><strong>String的concat方法的实现原理</strong><br>关于concat方法可以直接到String内部查看其源码，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">concat</span><span class="hljs-params">(String str)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> otherLen = str.length();<br>        <span class="hljs-keyword">if</span> (otherLen == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> len = value.length;<br>        <span class="hljs-keyword">char</span> buf[] = Arrays.copyOf(value, len + otherLen);<br>        str.getChars(buf, len);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String(buf, <span class="hljs-keyword">true</span>);<br>    &#125;<br></code></pre></td></tr></table></figure><p>可以看到，在concat方法中使用Arrays的copyOf进行了一次数组拷贝，接下来又通过getChars方法再次进行了数组拷贝，最后通过new实例化了String对象并返回。这也意味着每调用一次concat都会生成一个String对象，但相比”+“操作符却省去了toString方法。因此，其性能要比”+“操作符好上不少。</p><p>至于StringBuilder其实也没必要再去分析了，毕竟”+“操作符也是基于StringBuilder实现的，只不过拼接过程中”+“操作符创建了大量的对象。而StringBuilder拼接时仅仅创建了一个StringBuilder对象。</p><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>本篇文章我们深入分析了String字符串的内存分配、intern()方法，以及String类的结构及特性。关于这块知识，网上的文章鱼龙混杂，甚至众说纷纭。笔者也是参考了大量的文章并结合自己的理解来做的分析。但是，避免不了的可能会出现理解偏差的问题，如果有，希望大家多多讨论给予指正。<br>同时，文章中多次提到StringBuilder,但限于文章篇幅，没能给出关于其详细分析。不过不用担心，我会在下一篇文章中再做探讨。<br>不管怎样，相信大家看完这篇文章后一定<br>对String有了更加深入的认识，尤其是了解String类的一些裁剪及拼接中可能造成的性能问题，在今后的开发中应该尽量避免。</p><h2 id="参考-amp-推荐阅读"><a href="#参考-amp-推荐阅读" class="headerlink" title="参考&amp;推荐阅读"></a>参考&amp;推荐阅读</h2><p><a href="https://tech.meituan.com/2014/03/06/in-depth-understanding-string-intern.html">深入解析String#intern</a></p><p><a href="https://juejin.im/post/6844903951351939086#comment">Java String 对象，你真的了解了吗？</a></p>]]></content>
    
    
    <categories>
      
      <category>Java进阶</category>
      
    </categories>
    
    
    <tags>
      
      <tag>String</tag>
      
      <tag>StringBuilder</tag>
      
      <tag>StringBuffer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java运行时内存区域详解</title>
    <link href="/2020/09/04/26.JVM%20memory/"/>
    <url>/2020/09/04/26.JVM%20memory/</url>
    
    <content type="html"><![CDATA[<p>Java内存分配是Java基础中非常重要的一部分内容，深入理解JVM的内存分配机制将有助于我们解决开发中遇到的很多问题。同时，内存分配这一块也是面试常客。笔者作为面试官也问过不少内存分配的问题，但令笔者惊讶的是不少三五年经验的面试者对于这块内容的回答也是含糊其辞，显然没有完全搞明白。那么本节内容我们就来系统的回顾一下Java中的内存分配机制。</p><h2 id="JVM内存分配概述"><a href="#JVM内存分配概述" class="headerlink" title="JVM内存分配概述"></a>JVM内存分配概述</h2><p>首先，我们应该明白一点，JVM并不是单一的存在，在Java二十多年的发展史中曾经涌现出了许多优秀的虚拟机，如大家耳熟能详的HotSpot虚拟机就是其中之一。不同的虚拟机在内存分配上也略有差异，但总体来说都遵循《Java虚拟机规范》。在《Java虚拟机规范》中规定了五种虚拟机运行时数据区，他们分别为：程序计数器、Java虚拟机栈、本地方法栈、本地方法区、Java堆、以及方法区。如下图所示：<br><img src="https://raw.githubusercontent.com/zhpanvip/images/master/project/article/2601.png"></p><p>接下来，我们来对以上五个内存区域进行详细分析。</p><h2 id="一、程序计数器（Program-Counter）"><a href="#一、程序计数器（Program-Counter）" class="headerlink" title="一、程序计数器（Program Counter）"></a>一、程序计数器（Program Counter）</h2><p>程序计数器是用于存放下一条指令所在单元地址的一块内存，在Intel x86和Itanium微处理器中，被称作<strong>指令指针</strong>（instruction pointer，IP），显然“指令指针”这个名字更易于我们理解这个概念。在JVM中，程序计数器是一块较小的内存空间，可以看作是<strong>当前线程所执行字节码的行号指示器</strong>。字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成。</p><p>我们知道，多线程的情况下，线程是由CPU调度来执行指令的，在单核CPU中，某一时刻只会有一个线程在执行指令，这就意味着CPU会频繁的切换线程，而在线程切换后需要恢复到正确的执行位置，这就需要<strong>每条线程都有一个独立的程序计数器</strong>，各个线程之间计数器互不影响。</p><p>另外，关于程序计数器我们需要知道的是，Java虚拟机规范中没有针对程序计数器规定任何的OutMemoryError。至于为什么？我个人觉得应该是程序计数器所占用的内存很小，加之线程数是有限的。因此，规范中并未对其做任何约束限制。<br>从以上内容中我们可以总结出以下几点：</p><ul><li><strong>程序计数器是线程私有的，每条线程都有一个程序计数器。</strong></li><li><strong>程序计数器存放了下一条要执行的指令的位置</strong></li><li><strong>字节码解释器通过给改变计数器的值来执行指令</strong></li><li><strong>程序计数器是JVM内存中唯一没有规定OutMemoryError的区域</strong></li></ul><h2 id="二、Java虚拟机栈-Java-Virtual-Machine-Stacks"><a href="#二、Java虚拟机栈-Java-Virtual-Machine-Stacks" class="headerlink" title="二、Java虚拟机栈(Java Virtual Machine Stacks)"></a>二、Java虚拟机栈(Java Virtual Machine Stacks)</h2><p>提到Java中的<strong>栈内存</strong>，大家应该都不陌生，甚至很多小伙伴对于栈内存说的头头是道：“栈内存是用来存储基本数据类型和对象的引用的”。但是，事实如此吗？其实，并不准确！这仅仅是Java虚拟机栈功能的一部分。</p><p>虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧用于存储局部变量表、操作数栈、动态连接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。</p><blockquote><p>栈帧是用于支持虚拟机进行方法调用和方法执行的数据结构，它是虚拟机运行时数据区中的虚拟机栈的栈元素，栈帧存储了方法的变量表、操作数栈、动态连接和方法返回等信息。本篇内容对栈帧不做过多解读，了解即可。</p></blockquote><p>而我们平时说的“栈内存”其实指的是虚拟机中的局部变量表部分。局部变量表存放了编译器可以知道的各种基本数据类型（boolean、type、char、short、int、final、long、double）、对象引用（reference类型，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其它与此对象相关的位置）和returnAddress类型（指向了一条字节码指令地址）。其中长度为long和double类型的数据会占用两个局部变量空间（Slot），其余的数据类型只占用一个。而局部变量表所需要的空间是在编译期间完成分配的，当进入一个方法时这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法的运行期间不会改变局部变量的大小。</p><p>同时，Java虚拟机栈与程序计数器一样都是线程私有的。Java虚拟机栈的生命周期与线程相同。另外，在Java虚拟机规范中对这一区域规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，就会抛出StackOverflowError异常；如果虚拟机栈可以动态扩展（当前大部分的虚拟机都可以动态扩展）如果扩展时无法申请到足够的内存则会抛出OutOfMemoryError异常。</p><p>对于以上内容，我们可以有以下几点结论：</p><ul><li><strong>虚拟机栈是线程私有的，生命周期与线程相同</strong></li><li><strong>虚拟机栈的功能不仅仅是存储基本数据类型和对象的引用</strong></li><li><strong>虚拟机栈描述的是Java方法执行的内存模型</strong></li><li><strong>Java虚拟机栈内存不足时会抛出StackOverflowError异常和OutOfMemoryError异常</strong></li></ul><h2 id="三、本地方法栈（Native-Method-Stack）"><a href="#三、本地方法栈（Native-Method-Stack）" class="headerlink" title="三、本地方法栈（Native Method Stack）"></a>三、本地方法栈（Native Method Stack）</h2><p>本地方法栈与虚拟机栈的作用是非常相似的，他们之间的区别不过是虚拟机栈为虚拟机执行Java方法（字节码）服务，而本地方法栈则为虚拟机使用到的Native方法服务。在虚拟机规范中对本地方法栈中方法使用的语言、使用的方式与数据结构并没有强制的规定，因此虚拟机是可以自由实现的。像HotSpot虚拟机就把本地方法栈和虚拟机栈合二为一了。</p><p>与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError.</p><p>关于本地虚拟机栈，我们有如下总结：</p><ul><li><strong>本地方法栈为虚拟机使用到的Native方法服务</strong></li><li><strong>某些虚拟机本地方法栈与虚拟机栈合二为一</strong></li><li><strong>本地方法栈区域会抛出StackOverflowError和OutOfMemoryError</strong></li></ul><h2 id="四、Java堆"><a href="#四、Java堆" class="headerlink" title="四、Java堆"></a>四、Java堆</h2><p>堆内存应该是Java开发者最熟悉的一块内存区域了，因为它实在是太重要了！我们所创建的对象实例几乎都是存放在堆内存中。因此，Java堆是虚拟机所管理的最大的一块内存区域。<strong>Java堆是被所有线程共享的一块内存区域</strong>，在虚拟机启动时创建。Java虚拟机规范中对堆内存有这样的描述：<strong>所有的对象实例以及数组都要在堆上分配</strong>，但是随着JIT编译器的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都在堆上分配也不是那么绝对了。</p><p>对于Java堆内存我们还可以进行一个细分：<strong>新生代（Young Generation）</strong>、<strong>老年代（Old Generation</strong>）；而新生代则又可以细分为Eden空间、From Survivor空间、To Survivor。如下图所示（注：图片中Permanent Generation即永久代不属于堆内存，而是方法区的一部分）：<br><img src="https://raw.githubusercontent.com/zhpanvip/images/master/project/article/2602.png"><br>而Java中的垃圾回收就是针对Java堆上不同的区域进行扫描回收，关于Java的GC机制我会在后续“温故知新”系列文章中详细解读。</p><p>从内存分配的角度来看，线程共享的Java堆中可能划分出多个线程私有的缓冲区（Thread Local Allocation Buffer，TLAB).</p><p>但是，无论怎么划分，堆上所存放的内容都是对象的实例。进一步划分只不过是为了更好的回收内存或者更快的分配内存。</p><p>另外，Java虚拟机规范中规定，Java堆可以处于物理上不连续的内存空间中。如果虚拟机在为实例分配内存时没有足够的空间，并且堆也无法在扩展，则会抛出OutOfMemoryError异常。</p><p>关于Java堆我们可做如下总结：</p><ul><li><strong>堆内存是被所有线程共享的一块内存区域</strong></li><li><strong>Java中创建的对象几乎都存放在堆内存中</strong></li><li><strong>垃圾回收机制会对堆内存进行扫描和垃圾对象的回收</strong></li><li><strong>堆内存不足时会抛出OutOfMemoryError异常</strong></li></ul><h2 id="五、方法区（Method-Area）"><a href="#五、方法区（Method-Area）" class="headerlink" title="五、方法区（Method Area）"></a>五、方法区（Method Area）</h2><p>方法区是用来存储虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。方法区与堆内存一样是所有线程共享的一块区域。Java虚拟机对于方法区的限制非常宽松，因此也就导致了不同的虚拟机上方法区有不同的表现。我们以HotSpot虚拟机为例：<strong>方法区在JDK1.7之前是一块单独的区域</strong>，很多人喜欢把它成为“永久代”（Permanent Generation），但本质上两者并不等价，仅仅是因为HotSpot虚拟机的设计团队把GC分代收集扩展到了方法区，或者说<strong>使用永久代来实现了方法区</strong>。这样HotSpot的垃圾收集器就可以向管理Java堆一样管理这部分内存。但是对于其它虚拟机（如BEA JRockit、IBM J9等）来说其实是不存在永久代的概念的。用永久代来实现方法区并不是一个好主意，因为这样更容易出现内存溢出的问题。而HotSpot的团队显然也意识到了这点问题，因此，在JDK1.7中将方法区中的字符串常量池移到了堆内存中，并在JDK1.8中完全废除了“永久代”，使用元空间替代了永久代。</p><p>另外，根据Java虚拟机规范规定，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。</p><p>关于方法区有如下总结：</p><ul><li><strong>方法区与堆内存一样是所有线程共享的一块区域</strong></li><li><strong>方法区是用来存储虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据</strong></li><li><strong>不同的虚拟机对于方法区的实现不同</strong></li><li><strong>HotSpot虚拟机在JDK1.7中将字符串常量池移到了堆内存，并在JDK1.8中用元空间去掉了“永久代”。</strong></li><li><strong>方法区内存不足时会抛出OutOfMemoryError异常</strong></li></ul><h2 id="六、Java中的常量池"><a href="#六、Java中的常量池" class="headerlink" title="六、Java中的常量池"></a>六、Java中的常量池</h2><p>关于常量池Java中可以分为三种，分别为：全局字符串常量池、Class文件常量池、运行时常量池。很多不了解的开发者容易将这三块区域混淆。本节内容我们就来详细的堆这三种常量池进行分析。</p><h3 id="1-字符串常量池（String-Pool）"><a href="#1-字符串常量池（String-Pool）" class="headerlink" title="1.字符串常量池（String Pool）"></a>1.字符串常量池（String Pool）</h3><p>我们知道，字符串属于引用数据类型，但是可以说字符串是Java中使用频繁的一种数据类型。因此，为了节省程序内存，提高性能，Java的设计者开辟了一块叫字符串常量池的区域，用来存储一些全局的字符串。字符串常量池是所有类公用的一块空间，在一个虚拟机中只有一块常量池区域。在类加载完成，经过验证，准备阶段之后在堆中生成字符串对象实例，然后将该字符串对象实例的引用值存到字符串常量池中（这里描述指的是JDK7及以后的HotSpot虚拟机）。<br>在HotSpot虚拟机中字符串常量池是通过一个StringTable类来实现的。它是一个哈希表，里面存的是字符串引用（JDK6及之前版本存放的是字符串对象）。<br><strong>我们在上一节中提到，在JDK7以前，字符串常量池在方法区（永久代）中，此时常量池中存放的是字符串对象。而在JDK7中，字符串常量池从方法区迁移到了堆内存，同时将字符串对象存到了堆内存，只在字符串常量池中存入了字符串对象的引用。</strong></p><h3 id="2-Class文件常量池（Class-Constant-Pool）"><a href="#2-Class文件常量池（Class-Constant-Pool）" class="headerlink" title="2.Class文件常量池（Class Constant Pool）"></a>2.Class文件常量池（Class Constant Pool）</h3><p>我们知道，Java文件在通过javac编译后会生成Class文件，Class文件中除了存放类的版本、字段、方法、接口等描述信息外，还有一项是<strong>常量池（Constants Pool Table）</strong>，常量池用于存放编译期间生产的各种字面量和符号引用。关于Class文件常量池本文不做过多赘述，如果想要详细了解此块内容可以参考周志明的《深入理解Java虚拟机》第六章的内容。</p><h3 id="3-运行时常量池（Runtime-Constant-Pool）"><a href="#3-运行时常量池（Runtime-Constant-Pool）" class="headerlink" title="3.运行时常量池（Runtime Constant Pool）"></a>3.运行时常量池（Runtime Constant Pool）</h3><p>运行时常量池是方法区的一部分，虚拟机会在类加载后将存Class文件常量池的内容加载到运行时常量池。因此，每一个类都会有一个运行时常量池。运行时常量池相对于Class文件常量池有具备动态性。因为Java语言并不要求常量一定在编译期间才能生成。也就是并非预置入Class文件常量池中的内容才能进入运行时常量池，运行期间也可以将新的常量放入常量池中，例如String类中的intern()方法（关于String及其intern方法我也会在后续“温故知新”系列文章中详细讲解）<br>由于运行时常量池属于方法区，因此其内存限制自然与方法区无异，当常量池无法再申请到内存时会抛出OutMemoryError异常。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇内容详细的分析了JVM的内存分配策略，网上关于JVM内存分配的文章多到数不胜数。但是我敢保证绝大部分文章没有本文写的详细且易懂。如果你能够认真读完本文相信你对JVM的内存分配一定会有一个更加深入的认识。</p><h2 id="参考-amp-推荐阅读"><a href="#参考-amp-推荐阅读" class="headerlink" title="参考&amp;推荐阅读"></a>参考&amp;推荐阅读</h2><p>《深入理解Java虚拟机 第三版》作者：周志明</p><p><a href="http://tangxman.github.io/2015/07/27/the-difference-of-java-string-pool/">Java中几种常量池的区分</a></p>]]></content>
    
    
    <categories>
      
      <category>Java进阶</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学不动也要学！探究Fragment延迟加载的前世今生</title>
    <link href="/2020/01/02/25.Yesterday%20and%20tommrrow%20with%20Fragment/"/>
    <url>/2020/01/02/25.Yesterday%20and%20tommrrow%20with%20Fragment/</url>
    
    <content type="html"><![CDATA[<p>上周在<a href="https://juejin.im/post/5df4aabe6fb9a0161104c8eb">《学不动也要学！深入了解ViewPager2》</a>一篇文章的留言中，大家普遍对于Fragment懒加载的问题比较关心。其实，对于Fragment懒加载问题的处理由来已久，网上不乏相关的优秀文章。但是，由于Fragment生命周期的原因使得懒加载问题的处理并不是那么的优雅。显然，Google也意识到了问题所在。因此，在Androidx的库中对于Fragment的生命周期状态的控制进行了深度优化，使得我们更容易的去管控Fragment的生命周期，也使得我们更容易的去处理懒加载问题。但是，前提条件是我们要了解Google对于Fragment做了哪些优化。那么就让我们借此机会一起来探究一下吧！（ <strong><em>懒加载称作延迟加载我觉得更贴切一些，所以下文就统称为延迟加载了。</em></strong> ）</p><h2 id="一、Fragment延迟加载的前世"><a href="#一、Fragment延迟加载的前世" class="headerlink" title="一、Fragment延迟加载的前世"></a>一、Fragment延迟加载的前世</h2><p>虽然本篇文章是对于Fragment新特性的探究，但是我觉得写文章总要有个因果。也为了照顾一下还不太了解什么是延迟加载的同学。我们还是先来了解一下延迟加载，顺便回顾一下Fragment延迟加载的旧方案。</p><h3 id="1-为什么要对Fragment做延迟加载"><a href="#1-为什么要对Fragment做延迟加载" class="headerlink" title="1.为什么要对Fragment做延迟加载?"></a>1.为什么要对Fragment做延迟加载?</h3><p>首先，我们要搞清楚一个问题。“Fragment延迟加载“中的“延迟”并不指的是延迟加载Fragment，而是延迟加载Fragment中的数据。对于Fragment的使用通常我们会结合ViewPager。在<a href="https://juejin.im/post/5df4aabe6fb9a0161104c8eb">《学不动也要学！深入了解ViewPager2》</a>一文中我们也提到ViewPager的预加载问题。ViewPager会默认在当前页面的左右两边至少预加载一个页面以保证ViewPager的流畅性。我们假设在ViewPager的所有Fragment中都存在网络请求。当我们打开这个页面的时候由于ViewPager的预加载原因，即使在其它Fragment不可见的情况下也会去进行网络请求加载数据。而如果此时用户根本就没有去滑动ViewPager就退出了应用或者切换到了其他页面。那么对于这个不可见的Fragment中的网络请求岂不是既浪费了流量也浪费了手机和服务器的性能？</p><p>那么此时有的同学就有问题了。你就不能在Fragment显示的时候去加载数据吗?问的好！在解答之前我们先来看下Fragment的生命周期<br><img src="https://raw.githubusercontent.com/zhpanvip/images/master/project/article/fragment/2501.jpg" alt="在这里插入图片描述"><br>想必这张图大家应该都非常熟悉了。当Fragment被预加载的时候，此Fragment的生命周期会从onAttach执行到onResume。显然我们无法通过Fragment的生命周期来控制Fragment的延迟加载。那么该怎么办呢？我们且往下看。</p><h3 id="2-如何处理Fragment的延迟加载？"><a href="#2-如何处理Fragment的延迟加载？" class="headerlink" title="2.如何处理Fragment的延迟加载？"></a>2.如何处理Fragment的延迟加载？</h3><p>通过上一小节的分析我们知道想要在Fragment的生命周期中处理延迟加载的问题显然是走不通的。所以想要处理Fragment的延迟加载就需要另想它法了。还好，在Fragment中为我们提供了一个setUserVisibleHint(isVisibleToUser: Boolean)的方法，这个方法中有一个isVisibleToUser的boolean类型的参数，其意义表示当前的Fragment是否对用户可见。因此，对于Fragment的延迟加载我们便可以通过这个方法来展开。<br>既然要使用setUserVisibleHint(isVisibleToUser: Boolean)那么就应该知道这个方法的调用时机。我们写一个ViewPager嵌套Fragment的例子来打印下日志：</p><p><img src="https://raw.githubusercontent.com/zhpanvip/images/master/project/article/fragment/2502.png"><br><em>注：上图打印的日志中”position:0“表示当前Fragment，“position:1”表示预加载的Fragment，下同。</em></p><p>可见该方法是在Fragment的onAttach之前就已经被调用了。因此，对于延迟加载我们可以在setUserVisibleHint(isVisibleToUser: Boolean)方法及onViewCreated(view: View, savedInstanceState: Bundle?)添加标志位来控制是否加载数据。我们来看下代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseLazyFragment</span> : <span class="hljs-type">Fragment</span></span>() &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 当前Fragment状态是否可见</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> isVisibleToUser: <span class="hljs-built_in">Boolean</span> = <span class="hljs-literal">false</span><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 是否已创建View</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> isViewCreated: <span class="hljs-built_in">Boolean</span> = <span class="hljs-literal">false</span><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 是否第一次加载数据</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> isFirstLoad = <span class="hljs-literal">true</span><br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">setUserVisibleHint</span><span class="hljs-params">(isVisibleToUser: <span class="hljs-type">Boolean</span>)</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.setUserVisibleHint(isVisibleToUser)<br>        <span class="hljs-keyword">this</span>.isVisibleToUser = isVisibleToUser<br>        onLazyLoad()<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onLazyLoad</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">if</span> (isVisibleToUser &amp;&amp; isViewCreated &amp;&amp; isFirstLoad) &#123;<br>            isFirstLoad = <span class="hljs-literal">false</span><br>            lazyLoad()<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onViewCreated</span><span class="hljs-params">(view: <span class="hljs-type">View</span>, savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onViewCreated(view, savedInstanceState)<br>        isViewCreated = <span class="hljs-literal">true</span><br>        onLazyLoad()<br>    &#125;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">lazyLoad</span><span class="hljs-params">()</span></span><br><br>&#125;<br></code></pre></td></tr></table></figure><p>我们通过在Fragment中添加了三个标志位实现了延迟加载的功能。我们到TestFragment尝试一下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestFragment</span> : <span class="hljs-type">BaseLazyFragment</span></span>() &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> position: <span class="hljs-built_in">Int</span> = <span class="hljs-number">0</span><br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">setUserVisibleHint</span><span class="hljs-params">(isVisibleToUser: <span class="hljs-type">Boolean</span>)</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.setUserVisibleHint(isVisibleToUser)<br>        <span class="hljs-keyword">val</span> bundle = arguments<br>        position = bundle!!.getInt(KEY_POSITION)<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreateView</span><span class="hljs-params">(inflater: <span class="hljs-type">LayoutInflater</span>, container: <span class="hljs-type">ViewGroup</span>?, savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span>: View? &#123;<br>        <span class="hljs-keyword">val</span> cardView = CardView(inflater, container)<br>        cardView.bind(Card.fromBundle(arguments!!),position)<br>        <span class="hljs-keyword">return</span> cardView.view<br>    &#125;<br><br>    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> &#123;<br><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> KEY_POSITION = <span class="hljs-string">&quot;position&quot;</span><br><br>        <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getInstance</span><span class="hljs-params">(card: <span class="hljs-type">Card</span>, position: <span class="hljs-type">Int</span>)</span></span>: TestFragment &#123;<br>            <span class="hljs-keyword">val</span> fragment = TestFragment()<br>            <span class="hljs-keyword">val</span> bundle = card.toBundle()<br>            bundle.putInt(KEY_POSITION, position)<br>            fragment.arguments = bundle<br>            <span class="hljs-keyword">return</span> fragment<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">lazyLoad</span><span class="hljs-params">()</span></span> &#123;<br>        showToast(<span class="hljs-string">&quot;Fragment<span class="hljs-variable">$position</span> is loading data&quot;</span>)<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">showToast</span><span class="hljs-params">(content: <span class="hljs-type">String</span>)</span></span> &#123;<br>        Toast.makeText(context, content, Toast.LENGTH_SHORT).show()<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><p>我们来看下效果：<br><img src="https://raw.githubusercontent.com/zhpanvip/images/master/project/article/fragment/2503.png" alt="在这里插入图片描述"><br>嗯！立竿见影，只有当Fragment完全显示出来的时候loading data的操作才被执行。这种延迟加载的方案在Androidx 1.1.0版本以前被广泛应用。而在Androidx 1.1.0版本中，Google对于Fragment进行了优化处理，使得延迟加载也有了新的解决方案。</p><h2 id="二、Fragment的setMaxLifecycle探究"><a href="#二、Fragment的setMaxLifecycle探究" class="headerlink" title="二、Fragment的setMaxLifecycle探究"></a>二、Fragment的setMaxLifecycle探究</h2><p>上一节中我们讲到因为ViewPager的预加载机制以及Fragment的生命周期无法得以控制，我们不得不通过setUserVisibleHint(isVisibleToUser: Boolean)和onViewCreated(view: View, savedInstanceState: Bundle?)方法以及添加三个标志位来处理延迟加载，显然这样的代码并不优雅。</p><p>当我们将Android项目迁移到Androidx并将androidx版本升级到1.1.0之后发现，我们第一节中用到的setUserVisibleHint(isVisibleToUser: Boolean)方法已被标记为废弃了！<br><img src="https://raw.githubusercontent.com/zhpanvip/images/master/project/article/fragment/2504.png" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ... 省略其它注释</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@deprecated</span> Use &#123;<span class="hljs-doctag">@link</span> FragmentTransaction#setMaxLifecycle(Fragment, Lifecycle.State)&#125;</span><br><span class="hljs-comment"> * instead.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Deprecated</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setUserVisibleHint</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> isVisibleToUser)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!mUserVisibleHint &amp;&amp; isVisibleToUser &amp;&amp; mState &lt; STARTED<br>            &amp;&amp; mFragmentManager != <span class="hljs-keyword">null</span> &amp;&amp; isAdded() &amp;&amp; mIsCreated) &#123;<br>        mFragmentManager.performPendingDeferredStart(<span class="hljs-keyword">this</span>);<br>    &#125;<br>    mUserVisibleHint = isVisibleToUser;<br>    mDeferStart = mState &lt; STARTED &amp;&amp; !isVisibleToUser;<br>    <span class="hljs-keyword">if</span> (mSavedFragmentState != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-comment">// Ensure that if the user visible hint is set before the Fragment has</span><br>        <span class="hljs-comment">// restored its state that we don&#x27;t lose the new value</span><br>        mSavedUserVisibleHint = isVisibleToUser;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>并且从注释中可以看到使用 FragmentTransaction#setMaxLifecycle(Fragment, Lifecycle.State)方法来替换setUserVisibleHint方法。setMaxLifecycle实在Androidx 1.1.0中新增加的一个方法。setMaxLifecycle从名字上来看意思是设置一个最大的生命周期，因为这个方法是在FragmentTransaction中，因此我们可以知道应该是为Fragment来设置一个最大的生命周期。我们来看下setMaxLifecycle的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * Set a ceiling for the state of an active fragment in this FragmentManager. If fragment is</span><br><span class="hljs-comment">    * already above the received state, it will be forced down to the correct state.</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    * &lt;p&gt;The fragment provided must currently be added to the FragmentManager to have it&#x27;s</span><br><span class="hljs-comment">    * Lifecycle state capped, or previously added as part of this transaction. The</span><br><span class="hljs-comment">    * &#123;<span class="hljs-doctag">@link</span> Lifecycle.State&#125; passed in must at least be &#123;<span class="hljs-doctag">@link</span> Lifecycle.State#CREATED&#125;, otherwise</span><br><span class="hljs-comment">    * an &#123;<span class="hljs-doctag">@link</span> IllegalArgumentException&#125; will be thrown.&lt;/p&gt;</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> fragment the fragment to have it&#x27;s state capped.</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> state the ceiling state for the fragment.</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@return</span> the same FragmentTransaction instance</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-meta">@NonNull</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> FragmentTransaction <span class="hljs-title">setMaxLifecycle</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Fragment fragment,</span></span><br><span class="hljs-function"><span class="hljs-params">           <span class="hljs-meta">@NonNull</span> Lifecycle.State state)</span> </span>&#123;<br>       addOp(<span class="hljs-keyword">new</span> Op(OP_SET_MAX_LIFECYCLE, fragment, state));<br>       <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>   &#125;<br></code></pre></td></tr></table></figure><p>这个方法接收一个Fragment参数和一个Lifecycle的状态参数。Lifecycle是jetpack中很重要的一个库，它具有对Activity和Fragment生命周期感知能力，相信很多同学都应该对Lifecycle都略知一二。在Lifecycle的State中定义了五种生命周期状态，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> State &#123;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * Destroyed state for a LifecycleOwner. After this event, this Lifecycle will not dispatch</span><br><span class="hljs-comment">         * any more events. For instance, for an &#123;<span class="hljs-doctag">@link</span> android.app.Activity&#125;, this state is reached</span><br><span class="hljs-comment">         * &lt;b&gt;right before&lt;/b&gt; Activity&#x27;s &#123;<span class="hljs-doctag">@link</span> android.app.Activity#onDestroy() onDestroy&#125; call.</span><br><span class="hljs-comment">         */</span><br>        DESTROYED,<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * Initialized state for a LifecycleOwner. For an &#123;<span class="hljs-doctag">@link</span> android.app.Activity&#125;, this is</span><br><span class="hljs-comment">         * the state when it is constructed but has not received</span><br><span class="hljs-comment">         * &#123;<span class="hljs-doctag">@link</span> android.app.Activity#onCreate(android.os.Bundle) onCreate&#125; yet.</span><br><span class="hljs-comment">         */</span><br>        INITIALIZED,<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * Created state for a LifecycleOwner. For an &#123;<span class="hljs-doctag">@link</span> android.app.Activity&#125;, this state</span><br><span class="hljs-comment">         * is reached in two cases:</span><br><span class="hljs-comment">         * &lt;ul&gt;</span><br><span class="hljs-comment">         *     &lt;li&gt;after &#123;<span class="hljs-doctag">@link</span> android.app.Activity#onCreate(android.os.Bundle) onCreate&#125; call;</span><br><span class="hljs-comment">         *     &lt;li&gt;&lt;b&gt;right before&lt;/b&gt; &#123;<span class="hljs-doctag">@link</span> android.app.Activity#onStop() onStop&#125; call.</span><br><span class="hljs-comment">         * &lt;/ul&gt;</span><br><span class="hljs-comment">         */</span><br>        CREATED,<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * Started state for a LifecycleOwner. For an &#123;<span class="hljs-doctag">@link</span> android.app.Activity&#125;, this state</span><br><span class="hljs-comment">         * is reached in two cases:</span><br><span class="hljs-comment">         * &lt;ul&gt;</span><br><span class="hljs-comment">         *     &lt;li&gt;after &#123;<span class="hljs-doctag">@link</span> android.app.Activity#onStart() onStart&#125; call;</span><br><span class="hljs-comment">         *     &lt;li&gt;&lt;b&gt;right before&lt;/b&gt; &#123;<span class="hljs-doctag">@link</span> android.app.Activity#onPause() onPause&#125; call.</span><br><span class="hljs-comment">         * &lt;/ul&gt;</span><br><span class="hljs-comment">         */</span><br>        STARTED,<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * Resumed state for a LifecycleOwner. For an &#123;<span class="hljs-doctag">@link</span> android.app.Activity&#125;, this state</span><br><span class="hljs-comment">         * is reached after &#123;<span class="hljs-doctag">@link</span> android.app.Activity#onResume() onResume&#125; is called.</span><br><span class="hljs-comment">         */</span><br>        RESUMED;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * Compares if this State is greater or equal to the given &#123;<span class="hljs-doctag">@code</span> state&#125;.</span><br><span class="hljs-comment">         *</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@param</span> state State to compare with</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@return</span> true if this State is greater or equal to the given &#123;<span class="hljs-doctag">@code</span> state&#125;</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isAtLeast</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> State state)</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> compareTo(state) &gt;= <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>而在setMaxLifecycle中接收的生命周期状态要求不能低于CREATED，否则会抛出一个IllegalArgumentException的异常。当传入参数为DESTROYED或者INITIALIZED时则会抛出如下图的异常：</p><p><img src="https://raw.githubusercontent.com/zhpanvip/images/master/project/article/fragment/2505.png"><br>因此除去这两个生命周期外，仅剩下CREATED、STARTED、RESUMED三个生命周期状态的参数可用，那么接下来我们就逐个来研究这三个参数的效果。</p><h3 id="1-不设置setMaxLifecycle"><a href="#1-不设置setMaxLifecycle" class="headerlink" title="1.不设置setMaxLifecycle"></a>1.不设置setMaxLifecycle</h3><p>我们先来看下在不设置setMaxLifecycle的时候添加一个Fragment的状态，以便和后边的情况进行对比。首先我们在Activity中添加一个Fragment，代码如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">fragment = TestLifecycleFragment.getInstance(Card.DECK[<span class="hljs-number">0</span>], <span class="hljs-number">0</span>)<br>       <span class="hljs-keyword">val</span> fragmentTransaction = supportFragmentManager.beginTransaction()<br>       fragmentTransaction.add(R.id.ll_fragment, fragment)<br>       fragmentTransaction.commit()<br></code></pre></td></tr></table></figure><p>启动Activity，我们将该Fragment生命周期的日志打印出来如下：<br><img src="https://raw.githubusercontent.com/zhpanvip/images/master/project/article/fragment/2506.png" alt="在这里插入图片描述"><br>可以看到这个Fragment生命周期从onAttach一直执行到了onResume。并且在Activity中成功显示出了Fragment</p><p><img src="https://raw.githubusercontent.com/zhpanvip/images/master/project/article/fragment/2507.png"></p><h3 id="2-setMaxLifecycle与CREATED"><a href="#2-setMaxLifecycle与CREATED" class="headerlink" title="2.setMaxLifecycle与CREATED"></a>2.setMaxLifecycle与CREATED</h3><p>接下来，我们将maxLifecycle设置为CREATED：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">fragment = TestLifecycleFragment.getInstance(Card.DECK[<span class="hljs-number">0</span>], <span class="hljs-number">0</span>)<br><span class="hljs-keyword">val</span> fragmentTransaction = supportFragmentManager.beginTransaction()<br>fragmentTransaction.add(R.id.ll_fragment, fragment)<br>fragmentTransaction.setMaxLifecycle(fragment, Lifecycle.State.CREATED)<br>fragmentTransaction.commit()<br></code></pre></td></tr></table></figure><p>再来看日志输出：<br><img src="https://raw.githubusercontent.com/zhpanvip/images/master/project/article/fragment/2508.png" alt="在这里插入图片描述"><br>可以看到该Fragment的生命周期仅仅执行到了onCreate就没再往下执行了。并且Activity中没有加载出来当前Fragment。</p><p>那么现在问题来了，假设Fragment已经执行到了onResume,此时再为Fragment设置一个CREATED的最大生命周期会出现什么样的情况呢？我们通过日志来验证一下：</p><p><img src="https://raw.githubusercontent.com/zhpanvip/images/master/project/article/fragment/2509.png"><br>从日志中可以看到已经执行了onResume的Fragment，将其最大生命周期设置为CREATED后会执行onPause-&gt;onStop-&gt;onDestoryView。也就是回退到了onCreate的状态。</p><h3 id="3-setMaxLifecycle与STARTED"><a href="#3-setMaxLifecycle与STARTED" class="headerlink" title="3.setMaxLifecycle与STARTED"></a>3.setMaxLifecycle与STARTED</h3><p>接下来，我们将maxLifecycle设置为STARTED：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">fragment = TestLifecycleFragment.getInstance(Card.DECK[<span class="hljs-number">0</span>], <span class="hljs-number">0</span>)<br><span class="hljs-keyword">val</span> fragmentTransaction = supportFragmentManager.beginTransaction()<br>fragmentTransaction.add(R.id.ll_fragment, fragment)<br>fragmentTransaction.setMaxLifecycle(fragment, Lifecycle.State.STARTED)<br>fragmentTransaction.commit()<br></code></pre></td></tr></table></figure><p>日志输出如下：<br><img src="https://raw.githubusercontent.com/zhpanvip/images/master/project/article/fragment/2510.png" alt="在这里插入图片描述"><br>可以看到Fragment的生命周期执行到了onStart,并且Activity中成功显示出了当前fragment。</p><p>同样，假设Fragment已经执行到了onResume方法再为其设置最大生命周期为STARTED会怎样呢？来看日志：<br><img src="https://raw.githubusercontent.com/zhpanvip/images/master/project/article/fragment/2511.png" alt="在这里插入图片描述"><br>可以看到，设置最大生命周期STARTED后Fragment执行了onPause方法，也就是生命周期退回到了onStart。</p><h3 id="4-setMaxLifecycle与RESUMED"><a href="#4-setMaxLifecycle与RESUMED" class="headerlink" title="4.setMaxLifecycle与RESUMED"></a>4.setMaxLifecycle与RESUMED</h3><p>最后，我们将maxLifecycle设置为RESUMED：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">fragment = TestLifecycleFragment.getInstance(Card.DECK[<span class="hljs-number">0</span>], <span class="hljs-number">0</span>)<br><span class="hljs-keyword">val</span> fragmentTransaction = supportFragmentManager.beginTransaction()<br>fragmentTransaction.add(R.id.ll_fragment, fragment)<br>fragmentTransaction.setMaxLifecycle(fragment, Lifecycle.State.RESUMED)<br>fragmentTransaction.commit()<br></code></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/zhpanvip/images/master/project/article/fragment/2512.png" alt="在这里插入图片描述"><br>可以看到此时和第一种情况一样的效果,Fragment的生命周期执行到了onResume。</p><p>而对于已经执行了onResume后的Fragment，再去设置最大生命周期为RESUMED会怎么样呢？因为当前Fragment已经是RESUMED状态了,所以不会再去执行任何代码。</p><p>到这里我们可以得出一个结论：</p><blockquote><p><strong>通过setMaxLifecycle方法可以精确控制Fragment生命周期的状态，如果Fragment的生命周期状态小于被设置的最大生命周期，则当前Fragment的生命周期会执行到被设置的最大生命周期，反之，如果Fragment的生命周期状态大于被设置的最大生命周期，那么则会回退到被设置的最大生命周期。</strong></p></blockquote><p>有了这一结论，在ViewPager中便可以对Fragment的生命周期进行控制，以此来更方便的实现延迟加载功能了。</p><h2 id="三、Fragment延迟加载的今生"><a href="#三、Fragment延迟加载的今生" class="headerlink" title="三、Fragment延迟加载的今生"></a>三、Fragment延迟加载的今生</h2><h3 id="1、延迟加载新方案之于ViewPager"><a href="#1、延迟加载新方案之于ViewPager" class="headerlink" title="1、延迟加载新方案之于ViewPager"></a>1、延迟加载新方案之于ViewPager</h3><p>通过上一小节的分析我们知道了可以通过setMaxLifecycle来设置Fragment的最大生命周期，从而可以实现ViewPager中Fragment的延迟加载。当然，关于生命周期状态处理的操作无需我们自己实现，在Androidx 1.1.0版本中的FragmentStatePagerAdapter已经帮我们实现了，只需要在使用时候传进去相应的参数即可。</p><p>FragmentStatePagerAdapter的构造方法接收两个参数，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * Constructor for &#123;<span class="hljs-doctag">@link</span> FragmentStatePagerAdapter&#125;.</span><br><span class="hljs-comment">  *</span><br><span class="hljs-comment">  * If &#123;<span class="hljs-doctag">@link</span> #BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT&#125; is passed in, then only the current</span><br><span class="hljs-comment">  * Fragment is in the &#123;<span class="hljs-doctag">@link</span> Lifecycle.State#RESUMED&#125; state, while all other fragments are</span><br><span class="hljs-comment">  * capped at &#123;<span class="hljs-doctag">@link</span> Lifecycle.State#STARTED&#125;. If &#123;<span class="hljs-doctag">@link</span> #BEHAVIOR_SET_USER_VISIBLE_HINT&#125; is</span><br><span class="hljs-comment">  * passed, all fragments are in the &#123;<span class="hljs-doctag">@link</span> Lifecycle.State#RESUMED&#125; state and there will be</span><br><span class="hljs-comment">  * callbacks to &#123;<span class="hljs-doctag">@link</span> Fragment#setUserVisibleHint(boolean)&#125;.</span><br><span class="hljs-comment">  *</span><br><span class="hljs-comment">  * <span class="hljs-doctag">@param</span> fm fragment manager that will interact with this adapter</span><br><span class="hljs-comment">  * <span class="hljs-doctag">@param</span> behavior determines if only current fragments are in a resumed state</span><br><span class="hljs-comment">  */</span><br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FragmentStatePagerAdapter</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> FragmentManager fm,</span></span><br><span class="hljs-function"><span class="hljs-params">         <span class="hljs-meta">@Behavior</span> <span class="hljs-keyword">int</span> behavior)</span> </span>&#123;<br>     mFragmentManager = fm;<br>     mBehavior = behavior;<br> &#125;<br></code></pre></td></tr></table></figure><p>第一个FragmentManager 参数不必多说，第二个参数时一个枚举类型的Behavior参数，其可选值如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@Retention(RetentionPolicy.SOURCE)</span><br><span class="hljs-meta">@IntDef(&#123;BEHAVIOR_SET_USER_VISIBLE_HINT, BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT&#125;)</span><br><span class="hljs-keyword">private</span> <span class="hljs-meta">@interface</span> Behavior &#123; &#125;<br></code></pre></td></tr></table></figure><p>当behavior为BEHAVIOR_SET_USER_VISIBLE_HINT时，Fragment改变的时候，setUserVisibleHint方法会被调用，也就是这个参数其实是为了兼容以前的老代码。并且BEHAVIOR_SET_USER_VISIBLE_HINT参数已经被置为废弃。所以我们的可选参数只剩下了BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT。</p><p>当behavior为BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT时意味着只有当前显示的Fragment会被执行到onResume，而其它Fragment的生命周期都只会执行到onStart.</p><p>这一功能时如何实现的呢？我们追随BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT的脚步找到了setPrimaryItem方法，这个方法的作用是设置ViewPager当前显示的Item，其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setPrimaryItem</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> ViewGroup container, <span class="hljs-keyword">int</span> position, <span class="hljs-meta">@NonNull</span> Object object)</span> </span>&#123;<br>        Fragment fragment = (Fragment)object;<br>        <span class="hljs-keyword">if</span> (fragment != mCurrentPrimaryItem) &#123;<br>            <span class="hljs-keyword">if</span> (mCurrentPrimaryItem != <span class="hljs-keyword">null</span>) &#123;<br>                mCurrentPrimaryItem.setMenuVisibility(<span class="hljs-keyword">false</span>);<br>                <span class="hljs-keyword">if</span> (mBehavior == BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT) &#123;<br>                    <span class="hljs-keyword">if</span> (mCurTransaction == <span class="hljs-keyword">null</span>) &#123;<br>                        mCurTransaction = mFragmentManager.beginTransaction();<br>                    &#125;<br>                    mCurTransaction.setMaxLifecycle(mCurrentPrimaryItem, Lifecycle.State.STARTED);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    mCurrentPrimaryItem.setUserVisibleHint(<span class="hljs-keyword">false</span>);<br>                &#125;<br>            &#125;<br>            fragment.setMenuVisibility(<span class="hljs-keyword">true</span>);<br>            <span class="hljs-keyword">if</span> (mBehavior == BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT) &#123;<br>                <span class="hljs-keyword">if</span> (mCurTransaction == <span class="hljs-keyword">null</span>) &#123;<br>                    mCurTransaction = mFragmentManager.beginTransaction();<br>                &#125;<br>                mCurTransaction.setMaxLifecycle(fragment, Lifecycle.State.RESUMED);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                fragment.setUserVisibleHint(<span class="hljs-keyword">true</span>);<br>            &#125;<br><br>            mCurrentPrimaryItem = fragment;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>这段代码非常简单易懂，mCurrentPrimaryItem是当前正在显示的item，fragment是接下来要显示的item。可以看到当mBehavior 为BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT时，mCurrentPrimaryItem的最大生命周期被设置为了STARTED，而fragment的最大生命周期则被设置为了RESUMED。而当mBehavior为BEHAVIOR_SET_USER_VISIBLE_HINT时仍然会调用setUserVisibleHint方法，这种情况就不再讨论，因为BEHAVIOR_SET_USER_VISIBLE_HINT也已经被废弃掉了。<br>那么我们着重来分析一下BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT时的情况：</p><p><strong>mCurrentPrimaryItem是当前显示的Fragment，所以该Fragment必然已经执行到了onResume方法，而此时为其设置了最大生命周期STARTED，那么mCurrentPrimaryItem必然会执行onPause退回到STARTED状态。<br>而fragment当前生命周期状态为onStart，当为其设置了RESUME的最大生命周期状态后,fragment必然会执行onResume方法进入RESUMED状态。</strong></p><p>知道了这一结论后，我们再去进行懒加载的控制是不是就异常简单了？此时我们只需要一个flag去标志是否是第一次加载数据就可以了。因此，懒加载的实现可以如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestLifecycleFragment</span> : <span class="hljs-type">Fragment</span></span>() &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> isFirstLoad = <span class="hljs-literal">true</span><br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onResume</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onResume()<br>        <span class="hljs-keyword">if</span> (isFirstLoad) &#123;<br>        isFirstLoad = <span class="hljs-literal">false</span><br>            loadData()<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">abstract</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">loadData</span><span class="hljs-params">()</span></span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2、延迟加载之于ViewPager2"><a href="#2、延迟加载之于ViewPager2" class="headerlink" title="2、延迟加载之于ViewPager2"></a>2、延迟加载之于ViewPager2</h3><p>上篇文章<a href="https://juejin.im/post/5df4aabe6fb9a0161104c8eb">《学不动也要学！深入了解ViewPager2》</a>中我们对ViewPager2有了比较深入的了解,其中在讲解ViewPager2的offScreenPageLimit时候得出过这样一个结论:</p><blockquote><p>ViewPager2的offScreenPageLimit默认值为OFFSCREEN_PAGE_LIMIT_DEFAULT,当setOffscreenPageLimit为OFFSCREEN_PAGE_LIMIT_DEFAULT时候会使用RecyclerView的缓存机制。默认只会加载当前显示的Fragment,而不会像ViewPager一样至少预加载一个item.当切换到下一个item的时候，当前Fragment会执行onPause方法，而下一个Fragment则会从onCreate一直执行到onResume。当再次滑动回第一个页面的时候当前页面同样会执行onPuase，而第一个页面会执行onResume。</p></blockquote><p>也就是说在ViewPager2中，默认关闭了预加载机制。没有了预加载机制再谈延迟加载其实也没有任何意义了。所以关于ViewPager2的延迟加载也就不用多说了吧？只需要将网络请求放到onStart中即可。相信随着ViewPager2的普及延迟加载的概念也会慢慢淡出开发者的视线。</p><p><strong>2020/1/4补充：</strong></p><p>如果为ViewPager2设置了offScreenPageLimit(1)那结果会是怎样的呢？我们来看日志：</p><p><img src="https://raw.githubusercontent.com/zhpanvip/images/master/project/article/fragment/2513.png"><br>从日志中可以看到ViewPager2预加载了一个Fragment，并且预加载的Fragment的生命周期仅仅执行到了onStart。所以此处我们可以猜测在FragmentStateAdapter中一定设置了setMaxLifecycle(fragment, STARTED)，具体源码不再贴出，大家可以自行查看。因此，此时处理懒加载问题其实和ViewPager的懒加载新方案如出一辙了，仅仅需要添加一个boolean值即可。</p><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>本篇文章对于Fragment的延迟加载进行了深入的探究，并且了解了在Androidx 1.1.0版本中对Fragment最大生命周期状态的控制，从而探究出了Fragment延迟加载的新方案。对于ViewPager2，因其默认不会进行预加载因此也就意味着我们无需处理ViewPager2的延迟加载问题。好了，这一篇花费了我两个周末（其实是上周末写了一半偷了个懒）的文章到此就结束了，如果你从中学有所收获那么请你不要吝啬留下你的赞。</p><p><a href="https://github.com/zhpanvip/ViewPagerSample">本文涉及源码</a></p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ViewPager2</tag>
      
      <tag>Fragment</tag>
      
      <tag>懒加载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学不动也要学！深入了解ViewPager2</title>
    <link href="/2019/12/14/24.Know%20about%20ViewPager2/"/>
    <url>/2019/12/14/24.Know%20about%20ViewPager2/</url>
    
    <content type="html"><![CDATA[<p>就在上个月20号(2019年11月20号)，期待已久的ViewPager2 正式版终于发布了！不知道你是否已经蠢蠢欲动着手用ViewPager2去改造你项目的ViewPager了？什么？你还不知道ViewPager2？那么请你马上系好安全带，本篇文章将带你一览ViewPager2的风采。</p><h2 id="一、ViewPager2的新特性"><a href="#一、ViewPager2的新特性" class="headerlink" title="一、ViewPager2的新特性"></a>一、ViewPager2的新特性</h2><p>ViewPager2从名字就可以看出来它是ViewPager的升级版，既然是升级版那么它相比ViewPager有哪些新功能和哪些API变化呢？我们接着往下看。</p><h3 id="1-ViewPager2新特性"><a href="#1-ViewPager2新特性" class="headerlink" title="1.ViewPager2新特性"></a>1.ViewPager2新特性</h3><ul><li>基于RecyclerView实现。这意味着RecyclerView的优点将会被ViewPager2所继承。</li><li>支持竖直滑动。只需要一个参数就可以改变滑动方向。</li><li>支持关闭用户输入。通过setUserInputEnabled来设置是否禁止用户滑动页面。</li><li>支持通过编程方式滚动。通过fakeDragBy(offsetPx)代码模拟用户滑动页面。</li><li>CompositePageTransformer 支持同时添加多个PageTransformer。</li><li>支持DiffUtil ，可以添加数据集合改变的item动画。</li><li>支持RTL (right-to-left)布局。我觉得这个功能对国内开发者来说可能用处不大..</li></ul><h3 id="2-相比ViewPager变化的API2501"><a href="#2-相比ViewPager变化的API2501" class="headerlink" title="2.相比ViewPager变化的API2501"></a>2.相比ViewPager变化的API2501</h3><p>ViewPager2相比ViewPager做了哪些改变呢？研究了一番之后我大概列出以下几点：</p><ul><li>ViewPager2与ViewPager同是继承自ViewGrop，但是ViewPager2被声明成了final。意味着我们不可能再像ViewPager一样通过继承来修改ViewPager2的代码。</li><li>FragmentStatePagerAdapter被FragmentStateAdapter 替代</li><li>PagerAdapter被RecyclerView.Adapter替代</li><li>addPageChangeListener被registerOnPageChangeCallback。我们知道ViewPager的addPageChangeListener接收的是一个OnPageChangeListener的接口，而这个接口中有三个方法，当想要监听页面变化时需要重写这三个方法。而ViewPager2的registerOnPageChangeCallback方法接收的是一个叫OnPageChangeCallback的抽象类，因此我们可以选择性的重写需要的方法即可。</li><li>移除了setPargeMargin方法。</li><li>关于offScreenPageLimit–离屏加载新特性</li></ul><p>以上所罗列的新特性和API可能并不完整，如有疏漏可以留言补充。</p><h2 id="二、开启ViewPager2之旅"><a href="#二、开启ViewPager2之旅" class="headerlink" title="二、开启ViewPager2之旅"></a>二、开启ViewPager2之旅</h2><p>ViewPager2位于androidx包下，也就是它不像ViewPager一样被内置在系统源码中。因此，使用ViewPager2需要额外的添加依赖库。另外，android support中不包含ViewPager2，也就是要使用ViewPager2必须迁移到androidx才可以。</p><h3 id="1-添加依赖，目前ViewPager2的最新版本是1-0-0："><a href="#1-添加依赖，目前ViewPager2的最新版本是1-0-0：" class="headerlink" title="1.添加依赖，目前ViewPager2的最新版本是1.0.0："></a>1.添加依赖，目前ViewPager2的最新版本是1.0.0：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">dependencies &#123;<br>    implementation <span class="hljs-string">&quot;androidx.viewpager2:viewpager2:1.0.0&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-ViewPager2布局文件："><a href="#2-ViewPager2布局文件：" class="headerlink" title="2.ViewPager2布局文件："></a>2.ViewPager2布局文件：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;androidx.viewpager2.widget.ViewPager2<br>       android:id=<span class="hljs-string">&quot;@+id/view_pager&quot;</span><br>       android:layout_width=<span class="hljs-string">&quot;match_parent&quot;</span><br>       android:layout_height=<span class="hljs-string">&quot;match_parent&quot;</span><br>       app:layout_constraintBottom_toBottomOf=<span class="hljs-string">&quot;parent&quot;</span><br>       app:layout_constraintLeft_toLeftOf=<span class="hljs-string">&quot;parent&quot;</span><br>       app:layout_constraintRight_toRightOf=<span class="hljs-string">&quot;parent&quot;</span><br>       app:layout_constraintTop_toTopOf=<span class="hljs-string">&quot;parent&quot;</span> /&gt;<br></code></pre></td></tr></table></figure><h3 id="3-ViewPager2的Adapter"><a href="#3-ViewPager2的Adapter" class="headerlink" title="3.ViewPager2的Adapter"></a>3.ViewPager2的Adapter</h3><p>因为ViewPager2内部封装的是RecyclerView，因此它的Adapter也就是RecyclerView的Adapter。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyAdapter</span> : <span class="hljs-type">RecyclerView.Adapter</span>&lt;<span class="hljs-type">MyAdapter.PagerViewHolder</span>&gt;</span>() &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> mList: List&lt;<span class="hljs-built_in">Int</span>&gt; = ArrayList()<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreateViewHolder</span><span class="hljs-params">(parent: <span class="hljs-type">ViewGroup</span>, viewType: <span class="hljs-type">Int</span>)</span></span>: PagerViewHolder &#123;<br>        <span class="hljs-keyword">val</span> itemView = LayoutInflater.from(parent.context).inflate(R.layout.item_page, parent, <span class="hljs-literal">false</span>)<br>        <span class="hljs-keyword">return</span> PagerViewHolder(itemView)<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onBindViewHolder</span><span class="hljs-params">(holder: <span class="hljs-type">PagerViewHolder</span>, position: <span class="hljs-type">Int</span>)</span></span> &#123;<br>        holder.bindData(mList[position])<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">setList</span><span class="hljs-params">(list: <span class="hljs-type">List</span>&lt;<span class="hljs-type">Int</span>&gt;)</span></span> &#123;<br>        mList = list<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getItemCount</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Int</span> &#123;<br>        <span class="hljs-keyword">return</span> mList.size<br>    &#125;<br><span class="hljs-comment">//ViewHolder需要继承RecycleView.ViewHolder</span><br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PagerViewHolder</span></span>(itemView: View) : RecyclerView.ViewHolder(itemView) &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> mTextView: TextView = itemView.findViewById(R.id.tv_text)<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> colors = arrayOf(<span class="hljs-string">&quot;#CCFF99&quot;</span>,<span class="hljs-string">&quot;#41F1E5&quot;</span>,<span class="hljs-string">&quot;#8D41F1&quot;</span>,<span class="hljs-string">&quot;#FF99CC&quot;</span>)<br><br>        <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">bindData</span><span class="hljs-params">(i: <span class="hljs-type">Int</span>)</span></span> &#123;<br>            mTextView.text = i.toString()<br>            mTextView.setBackgroundColor(Color.parseColor(colors[i]))<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>item_page中代码如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">&lt;LinearLayout xmlns:android=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span><br>    android:layout_width=<span class="hljs-string">&quot;match_parent&quot;</span><br>    android:layout_height=<span class="hljs-string">&quot;match_parent&quot;</span><br>    android:gravity=<span class="hljs-string">&quot;center&quot;</span>&gt;<br><br>    &lt;TextView<br>        android:id=<span class="hljs-string">&quot;@+id/tv_text&quot;</span><br>        android:background=<span class="hljs-string">&quot;@color/colorPrimaryDark&quot;</span><br>        android:layout_width=<span class="hljs-string">&quot;match_parent&quot;</span><br>        android:layout_height=<span class="hljs-string">&quot;280dp&quot;</span><br>        android:gravity=<span class="hljs-string">&quot;center&quot;</span><br>        android:textColor=<span class="hljs-string">&quot;#ffffff&quot;</span><br>        android:textSize=<span class="hljs-string">&quot;22sp&quot;</span> /&gt;<br>&lt;/LinearLayout&gt;<br></code></pre></td></tr></table></figure><h3 id="4-在Activity中为ViewPager设置Adapter："><a href="#4-在Activity中为ViewPager设置Adapter：" class="headerlink" title="4.在Activity中为ViewPager设置Adapter："></a>4.在Activity中为ViewPager设置Adapter：</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> viewPager2 = findViewById&lt;ViewPager2&gt;(R.id.view_pager)<br>      <span class="hljs-keyword">val</span> myAdapter = MyAdapter()<br>      myAdapter.setList(<span class="hljs-keyword">data</span>)<br>      viewPager2.adapter = myAdapter<br></code></pre></td></tr></table></figure><p>很简单就完成了一个ViewPager的功能，来看下效果怎么样：<br><img src="https://raw.githubusercontent.com/zhpanvip/images/master/project/article/viewpager2/2401.gif" alt="在这里插入图片描述"></p><h3 id="5-ViewPager2竖直滑动"><a href="#5-ViewPager2竖直滑动" class="headerlink" title="5.ViewPager2竖直滑动"></a>5.ViewPager2竖直滑动</h3><p>接下来我们通过一行代码为其设置竖直滑动</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">viewPager2.orientation = ViewPager2.ORIENTATION_VERTICAL<br></code></pre></td></tr></table></figure><p>竖直滑动用ViewPager是很难实现的，而通过ViewPager2只需要设置一个参数即可。来看下效果：<br><img src="https://raw.githubusercontent.com/zhpanvip/images/master/project/article/viewpager2/2402.gif" alt="在这里插入图片描述"></p><h3 id="6-页面滑动事件监听"><a href="#6-页面滑动事件监听" class="headerlink" title="6.页面滑动事件监听"></a>6.页面滑动事件监听</h3><p>上文已经提到过了，我们为ViewPager设置页面滑动的监听事件需要重写三个方法，而为ViewPager2设置监听事件只需要重写需要的方法即可，因为ViewPager2中OnPageChangeCallback是一个抽象类。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">viewPager2.registerOnPageChangeCallback(<span class="hljs-keyword">object</span> : ViewPager2.OnPageChangeCallback() &#123;<br>            <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onPageSelected</span><span class="hljs-params">(position: <span class="hljs-type">Int</span>)</span></span> &#123;<br>                <span class="hljs-keyword">super</span>.onPageSelected(position)<br>                Toast.makeText(<span class="hljs-keyword">this</span><span class="hljs-symbol">@MainActivity</span>, <span class="hljs-string">&quot;page selected <span class="hljs-variable">$position</span>&quot;</span>, Toast.LENGTH_SHORT).show()<br>            &#125;<br>        &#125;)<br></code></pre></td></tr></table></figure><h3 id="7-setUserInputEnabled与fakeDragBy"><a href="#7-setUserInputEnabled与fakeDragBy" class="headerlink" title="7.setUserInputEnabled与fakeDragBy"></a>7.setUserInputEnabled与fakeDragBy</h3><p>我们知道，在使用ViewPager的时候想要禁止用户滑动需要重写ViewPager的onInterceptTouchEvent。而ViewPager2被声明为了final，我们无法再去继承ViewPager2。那么我们应该怎么禁止ViewPager2的滑动呢？其实在ViewPager2中已经为我们提供了这个功能，只需要通过setUserInputEnabled即可实现。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">viewPager2.isUserInputEnabled = <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p>同时ViewPager2新增了一个fakeDragBy的方法。通过这个方法可以来模拟拖拽。在使用fakeDragBy前需要先beginFakeDrag方法来开启模拟拖拽。fakeDragBy会返回一个boolean值，true表示有fake drag正在执行，而返回false表示当前没有fake drag在执行。我们通过代码来尝试下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">fakeDragBy</span><span class="hljs-params">(view: <span class="hljs-type">View</span>)</span></span> &#123;<br>        viewPager2.beginFakeDrag()<br>        <span class="hljs-keyword">if</span> (viewPager2.fakeDragBy(-<span class="hljs-number">310f</span>))<br>            viewPager2.endFakeDrag()<br>    &#125;<br></code></pre></td></tr></table></figure><p>需要注意到是fakeDragBy接受一个float的参数，当参数值为正数时表示向前一个页面滑动，当值为负数时表示向下一个页面滑动。<br>下面来看下效果图：<br><img src="https://raw.githubusercontent.com/zhpanvip/images/master/project/article/viewpager2/2403.gif" alt="在这里插入图片描述"><br>演示图中禁止了用户输入，通过按钮点击可以模拟用户滑动。</p><h3 id="8-ViewPager2的offScreenPageLimit"><a href="#8-ViewPager2的offScreenPageLimit" class="headerlink" title="8.ViewPager2的offScreenPageLimit"></a>8.ViewPager2的offScreenPageLimit</h3><p>offScreenPageLimit在ViewPager中就已经存在，这个参数用来控制ViewPager左右两端预加载页面的个数。为了保证ViewPager的流畅性，offScreenPageLimit被强制规定为大于0的数，即使我们将其设置为0，ViewPager内部也会将其改为1。因此ViewPager就被强制左右两边至少加载一个页面。这也是一直被广大开发者所诟病的一个问题。而在ViewPager2中针对这一问题做了优化。我们点开ViewPager2的源码来看下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"># VewPager2<br><br><span class="hljs-keyword">private</span> <span class="hljs-meta">@OffscreenPageLimit</span> <span class="hljs-keyword">int</span> mOffscreenPageLimit = OFFSCREEN_PAGE_LIMIT_DEFAULT;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Value to indicate that the default caching mechanism of RecyclerView should be used instead</span><br><span class="hljs-comment"> * of explicitly prefetch and retain pages to either side of the current page.</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@see</span> #setOffscreenPageLimit(int)</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> OFFSCREEN_PAGE_LIMIT_DEFAULT = -<span class="hljs-number">1</span>;<br><br> <span class="hljs-comment">/** <span class="hljs-doctag">@hide</span> */</span><br><span class="hljs-meta">@SuppressWarnings(&quot;WeakerAccess&quot;)</span><br><span class="hljs-meta">@RestrictTo(LIBRARY_GROUP_PREFIX)</span><br><span class="hljs-meta">@Retention(SOURCE)</span><br><span class="hljs-meta">@IntDef(&#123;OFFSCREEN_PAGE_LIMIT_DEFAULT&#125;)</span><br><span class="hljs-meta">@IntRange(from = 1)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> OffscreenPageLimit &#123;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>可以看到在ViewPager2中offScreenPageLimit的默认值被设置为了-1，而且offScreenPageLimit这个成员变量被一个名为@OffscreenPageLimit的注解所修饰，而在这个注解强制要求int的范围是大于等于1的。什么？ViewPager2的预加载页面难道也必须大于等于1？那这相比ViewPager有什么区别呢？先别着急，其实最大的区别就在这个OFFSCREEN_PAGE_LIMIT_DEFAULT上，这个值被设置为-1，那么它代表什么意思呢？我们可以从ViewPager2源码的注释中找出一些端倪</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * &lt;p&gt;Set the number of pages that should be retained to either side of the currently visible</span><br><span class="hljs-comment">     * page(s). Pages beyond this limit will be recreated from the adapter when needed. Set this to</span><br><span class="hljs-comment">     * &#123;<span class="hljs-doctag">@link</span> #OFFSCREEN_PAGE_LIMIT_DEFAULT&#125; to use RecyclerView&#x27;s caching strategy. The given value</span><br><span class="hljs-comment">     * must either be larger than 0, or &#123;<span class="hljs-doctag">@code</span> #OFFSCREEN_PAGE_LIMIT_DEFAULT&#125;.&lt;/p&gt;</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * &lt;p&gt;Pages within &#123;<span class="hljs-doctag">@code</span> limit&#125; pages away from the current page are created and added to the</span><br><span class="hljs-comment">     * view hierarchy, even though they are not visible on the screen. Pages outside this limit will</span><br><span class="hljs-comment">     * be removed from the view hierarchy, but the &#123;<span class="hljs-doctag">@code</span> ViewHolder&#125;s will be recycled as usual by</span><br><span class="hljs-comment">     * &#123;<span class="hljs-doctag">@link</span> RecyclerView&#125;.&lt;/p&gt;</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * &lt;p&gt;This is offered as an optimization. If you know in advance the number of pages you will</span><br><span class="hljs-comment">     * need to support or have lazy-loading mechanisms in place on your pages, tweaking this setting</span><br><span class="hljs-comment">     * can have benefits in perceived smoothness of paging animations and interaction. If you have a</span><br><span class="hljs-comment">     * small number of pages (3-4) that you can keep active all at once, less time will be spent in</span><br><span class="hljs-comment">     * layout for newly created view subtrees as the user pages back and forth.&lt;/p&gt;</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * &lt;p&gt;You should keep this limit low, especially if your pages have complex layouts. By default</span><br><span class="hljs-comment">     * it is set to &#123;<span class="hljs-doctag">@code</span> OFFSCREEN_PAGE_LIMIT_DEFAULT&#125;.&lt;/p&gt;</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> limit How many pages will be kept offscreen on either side. Valid values are all</span><br><span class="hljs-comment">     *        values &#123;<span class="hljs-doctag">@code</span> &gt;= 1&#125; and &#123;<span class="hljs-doctag">@link</span> #OFFSCREEN_PAGE_LIMIT_DEFAULT&#125;</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IllegalArgumentException If the given limit is invalid</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@see</span> #getOffscreenPageLimit()</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setOffscreenPageLimit</span><span class="hljs-params">(<span class="hljs-meta">@OffscreenPageLimit</span> <span class="hljs-keyword">int</span> limit)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (limit &lt; <span class="hljs-number">1</span> &amp;&amp; limit != OFFSCREEN_PAGE_LIMIT_DEFAULT) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<br>                    <span class="hljs-string">&quot;Offscreen page limit must be OFFSCREEN_PAGE_LIMIT_DEFAULT or a number &gt; 0&quot;</span>);<br>        &#125;<br>        mOffscreenPageLimit = limit;<br>        <span class="hljs-comment">// Trigger layout so prefetch happens through getExtraLayoutSize()</span><br>        mRecyclerView.requestLayout();<br>    &#125;<br></code></pre></td></tr></table></figure><p>从这段对setOffscreenPageLimit(int)方法的注释中我们可以看到，当setOffscreenPageLimit被设置为OFFSCREEN_PAGE_LIMIT_DEFAULT时候会使用RecyclerView的缓存机制。那么我们就来在ViewPager2中尝试下加载Fragment是一种怎样的效果吧。<br>首先我们在ViewPager中添加多个Fragment，并且setOffscreenPageLimit使用默认值，然后再Fragment声明周期中打印出日志，代码不再贴出，直接看日志打印的内容：<br><img src="https://raw.githubusercontent.com/zhpanvip/images/master/project/article/viewpager2/2404.webp"><br>从日志中可以看出来初始化的只有第一个Fragment。当我们滑动到第二个页面的时候，打印日志如下：</p><p><img src="https://raw.githubusercontent.com/zhpanvip/images/master/project/article/viewpager2/2405.webp"><br>可以看到第二个页面在滑动的时候才被初始化，由此我们可以看出在ViewPager2中默认的OffscreenPageLimit是不会进行页面预加载的。<br>接下来我们将offscreenPageLimit值改为1，再来看下输出日志：</p><p><img src="https://raw.githubusercontent.com/zhpanvip/images/master/project/article/viewpager2/2406.webp"><br>此时可以看到offscreenPageLimit设置为1后会预加载进来一个页面，和ViewPager几乎是一样的效果。总之，ViewPager2对于ViewPager的预加载机制做了优化，使得体验上变得更好。关于ViewPager2的offScreenLimit在本篇文章中不再深究，我会在下篇文章中深入探讨。</p><h2 id="三、ViewPager2的PageTransformer"><a href="#三、ViewPager2的PageTransformer" class="headerlink" title="三、ViewPager2的PageTransformer"></a>三、ViewPager2的PageTransformer</h2><p>相比ViewPager，ViewPager2的Transformer功能有了很大的扩展。ViewPager2不仅可以通过PageTransformer用来设置页面动画，还可以用PageTransformer设置页面间距以及同时添加多个PageTransformer。接下来我们就来认识下ViewPager2的PageTransformer吧！</p><h3 id="1-setPageMargin"><a href="#1-setPageMargin" class="headerlink" title="1.setPageMargin"></a>1.setPageMargin</h3><p>在第一章中我们提到了ViewPager2移除了setPageMargin方法，那么怎么为ViewPager2设置页面间距呢？其实在ViewPager2中为我们提供了MarginPageTransformer，我们可以通过ViewPager2的setPageTransformer方法来设置页面间距。代码如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">viewPager2.setPageTransformer(MarginPageTransformer(resources.getDimension(R.dimen.dp_10).toInt()))<br></code></pre></td></tr></table></figure><p>上述代码我们为ViewPager2设置了10dp的页面间距。效果如下：<br><img src="https://raw.githubusercontent.com/zhpanvip/images/master/project/article/viewpager2/2407.gif" alt="在这里插入图片描述"></p><h3 id="2-认识CompositePageTransformer"><a href="#2-认识CompositePageTransformer" class="headerlink" title="2.认识CompositePageTransformer"></a>2.认识CompositePageTransformer</h3><p>这个时候我们应该有个疑问，为ViewPager2设置了页面间距后如果还想设置页面动画的Transformer怎么办呢？这时候就该CompositePageTransformer出场了。从名字上也可以看出来它是一个组合的PageTransformer。没错，CompositePageTransformer实现了PageTransformer接口，同时在其内部维护了一个List集合，我们可以将多个PageTransformer添加到CompositePageTransformer中。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> compositePageTransformer = CompositePageTransformer()<br>       compositePageTransformer.addTransformer(ScaleInTransformer())<br>       compositePageTransformer.addTransformer(MarginPageTransformer(resources.getDimension(R.dimen.dp_10).toInt()))<br>       viewPager2.setPageTransformer(compositePageTransformer)<br></code></pre></td></tr></table></figure><p>上述代码中我们通过CompositePageTransformer为ViewPager设置了MarginPageTransformer和一个页面缩放的ScaleInTransformer。来看下效果：</p><p><img src="https://raw.githubusercontent.com/zhpanvip/images/master/project/article/viewpager2/2408.gif" alt="在这里插入图片描述"></p><h3 id="3-ViewPager2中的PageTransformer"><a href="#3-ViewPager2中的PageTransformer" class="headerlink" title="3.ViewPager2中的PageTransformer"></a>3.ViewPager2中的PageTransformer</h3><p>PageTransformer是一个位于ViewPager2中的接口，因此ViewPager2的PageTransformer是独立于ViewPager的，它与ViewPager的PageTransformer没有任何关系。虽然如此，却不必担心。因为ViewPager2的PageTransformer和ViewPager的PageTransformer实现方式一模一样。我们看下上一小节中用到的ScaleInTransformer：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ScaleInTransformer</span> : <span class="hljs-type">ViewPager2.PageTransformer &#123;</span></span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> mMinScale = DEFAULT_MIN_SCALE<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">transformPage</span><span class="hljs-params">(view: <span class="hljs-type">View</span>, position: <span class="hljs-type">Float</span>)</span></span> &#123;<br>        view.elevation = -abs(position)<br>        <span class="hljs-keyword">val</span> pageWidth = view.width<br>        <span class="hljs-keyword">val</span> pageHeight = view.height<br><br>        view.pivotY = (pageHeight / <span class="hljs-number">2</span>).toFloat()<br>        view.pivotX = (pageWidth / <span class="hljs-number">2</span>).toFloat()<br>        <span class="hljs-keyword">if</span> (position &lt; -<span class="hljs-number">1</span>) &#123;<br>            view.scaleX = mMinScale<br>            view.scaleY = mMinScale<br>            view.pivotX = pageWidth.toFloat()<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (position &lt;= <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">if</span> (position &lt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">val</span> scaleFactor = (<span class="hljs-number">1</span> + position) * (<span class="hljs-number">1</span> - mMinScale) + mMinScale<br>                view.scaleX = scaleFactor<br>                view.scaleY = scaleFactor<br>                view.pivotX = pageWidth * (DEFAULT_CENTER + DEFAULT_CENTER * -position)<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">val</span> scaleFactor = (<span class="hljs-number">1</span> - position) * (<span class="hljs-number">1</span> - mMinScale) + mMinScale<br>                view.scaleX = scaleFactor<br>                view.scaleY = scaleFactor<br>                view.pivotX = pageWidth * ((<span class="hljs-number">1</span> - position) * DEFAULT_CENTER)<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            view.pivotX = <span class="hljs-number">0f</span><br>            view.scaleX = mMinScale<br>            view.scaleY = mMinScale<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> &#123;<br><br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> DEFAULT_MIN_SCALE = <span class="hljs-number">0.85f</span><br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> DEFAULT_CENTER = <span class="hljs-number">0.5f</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-ViewPager2的一屏多页效果"><a href="#4-ViewPager2的一屏多页效果" class="headerlink" title="4.ViewPager2的一屏多页效果"></a>4.ViewPager2的一屏多页效果</h3><p>在ViewPager2的官方Sample上看到了ViewPager2的一屏多页可以通过为RecyclerView设置Padding来实现。代码如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><br>viewPager2.apply &#123;<br>            offscreenPageLimit=<span class="hljs-number">1</span><br>           <span class="hljs-keyword">val</span> recyclerView= getChildAt(<span class="hljs-number">0</span>) <span class="hljs-keyword">as</span> RecyclerView<br>            recyclerView.apply &#123;<br>                <span class="hljs-keyword">val</span> padding = resources.getDimensionPixelOffset(R.dimen.dp_10) +<br>                        resources.getDimensionPixelOffset(R.dimen.dp_10)<br>                <span class="hljs-comment">// setting padding on inner RecyclerView puts overscroll effect in the right place</span><br>                setPadding(padding, <span class="hljs-number">0</span>, padding, <span class="hljs-number">0</span>)<br>                clipToPadding = <span class="hljs-literal">false</span><br>            &#125;<br>        &#125;<br><span class="hljs-keyword">val</span> compositePageTransformer = CompositePageTransformer()<br>compositePageTransformer.addTransformer(ScaleInTransformer())<br>compositePageTransformer.addTransformer(MarginPageTransformer(resources.getDimension(R.dimen.dp_10).toInt()))<br>viewPager2.setPageTransformer(compositePageTransformer)<br><br></code></pre></td></tr></table></figure><p>最后，我们来看下效果<br><img src="https://raw.githubusercontent.com/zhpanvip/images/master/project/article/viewpager2/2409.gif" alt="在这里插入图片描述"></p><h2 id="四、ViewPager2与Fragment"><a href="#四、ViewPager2与Fragment" class="headerlink" title="四、ViewPager2与Fragment"></a>四、ViewPager2与Fragment</h2><p>我们前面也已经提到了ViewPager2中新增的FragmentStateAdapter 替代了ViewPager的FragmentStatePagerAdapter。那么来我们就用ViewPager2来实现一个Activity中嵌套Fragment的实例。</p><h3 id="1-Activity的layout中添加ViewPager2"><a href="#1-Activity的layout中添加ViewPager2" class="headerlink" title="1.Activity的layout中添加ViewPager2"></a>1.Activity的layout中添加ViewPager2</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">&lt;androidx.viewpager2.widget.ViewPager2<br>           android:id=<span class="hljs-string">&quot;@+id/vp_fragment&quot;</span><br>           android:layout_width=<span class="hljs-string">&quot;match_parent&quot;</span><br>           android:layout_height=<span class="hljs-string">&quot;match_parent&quot;</span><br>           android:layout_above=<span class="hljs-string">&quot;@id/rg_tab&quot;</span> /&gt;<br></code></pre></td></tr></table></figure><h3 id="2-实现FragmentStateAdapter"><a href="#2-实现FragmentStateAdapter" class="headerlink" title="2.实现FragmentStateAdapter"></a>2.实现FragmentStateAdapter</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AdapterFragmentPager</span></span>(fragmentActivity: FragmentActivity) : FragmentStateAdapter(fragmentActivity) &#123;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">createFragment</span><span class="hljs-params">(position: <span class="hljs-type">Int</span>)</span></span>: Fragment &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">when</span> (position) &#123;<br>            PAGE_HOME -&gt; HomeFragment.getInstance();<br>            PAGE_FIND -&gt; PageFragment.getInstance();<br>            PAGE_INDICATOR -&gt; IndicatorFragment.getInstance();<br>            PAGE_OTHERS -&gt; OthersFragment.getInstance();<br>            <span class="hljs-keyword">else</span> -&gt; EmptyFragment.getInstance();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getItemCount</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Int</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">4</span><br>    &#125;<br><br>    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> &#123;<br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> PAGE_HOME = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> PAGE_FIND = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> PAGE_INDICATOR = <span class="hljs-number">2</span><br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> PAGE_OTHERS = <span class="hljs-number">3</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-在Activity中为ViewPager2设置FragmentStateAdapter"><a href="#3-在Activity中为ViewPager2设置FragmentStateAdapter" class="headerlink" title="3.在Activity中为ViewPager2设置FragmentStateAdapter"></a>3.在Activity中为ViewPager2设置FragmentStateAdapter</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">vp_fragment.adapter = AdapterFragmentPager(<span class="hljs-keyword">this</span>)<br>       vp_fragment.offscreenPageLimit = <span class="hljs-number">3</span><br>       vp_fragment.isUserInputEnabled=<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><h2 id="五、ViewPager2与TabLayout"><a href="#五、ViewPager2与TabLayout" class="headerlink" title="五、ViewPager2与TabLayout"></a>五、ViewPager2与TabLayout</h2><p>TabLayout也是项目中经常用到的一个控件，它通常会与ViewPager一起出现。那么对于ViewPager2应该怎么使用Tablayout呢？这需要我们认识一个新类TabLayoutMediator，这个类是在material-1.2.0中新增的一个类，目前material包的最新版本是1.2.0-alpha03，因此需要我们单独引入这个包，依赖如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">implementation <span class="hljs-string">&#x27;com.google.android.material:material:1.2.0-alpha03&#x27;</span><br></code></pre></td></tr></table></figure><p>TabLayoutMediator的构造方法接收三个参数，第一个参数为TabLayout；第二个参数为ViewPager2；第三个参数是TabConfigurationStrategy，这是一个接口，该接口中有一个方法onConfigureTab(@NonNull TabLayout.Tab tab, int position),第一个参数是当前Tab,第二个当前position，源码如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">TabConfigurationStrategy</span> </span>&#123;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * Called to configure the tab for the page at the specified position. Typically calls &#123;<span class="hljs-doctag">@link</span></span><br><span class="hljs-comment">   * TabLayout.Tab#setText(CharSequence)&#125;, but any form of styling can be applied.</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> tab The Tab which should be configured to represent the title of the item at the given</span><br><span class="hljs-comment">   *     position in the data set.</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> position The position of the item within the adapter&#x27;s data set.</span><br><span class="hljs-comment">   */</span><br>  void onConfigureTab(<span class="hljs-meta">@NonNull</span> TabLayout.Tab tab, int position);<br>&#125;<br></code></pre></td></tr></table></figure><p> 接下来我们便可以通过TabLayoutMediator将TabLayout与ViewPager2关联起来了：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">TabLayoutMediator(tab_layout, view_pager) &#123; tab, position -&gt;<br>            <span class="hljs-comment">//  为Tab设置Text</span><br>            tab.text = Card.DECK[position].toString()<br>        &#125;.attach()<br></code></pre></td></tr></table></figure><p>使用起来非常简单，实现效果如下图所示：</p><p><img src="https://raw.githubusercontent.com/zhpanvip/images/master/project/article/viewpager2/2410.gif"></p><h2 id="六、小结"><a href="#六、小结" class="headerlink" title="六、小结"></a>六、小结</h2><p>本篇文章我们认识了ViewPager2的新特性以及其用法。总得来说ViewPager2相比ViewPager不管在性能上还是在功能上都有了很大的提升。因此，我相信在不久的未来ViewPager2必定会取代ViewPager。那么，你是否已经考虑将ViewPager2用到你的项目中了呢？</p><p>最后再来给大家推荐一下<a href="https://github.com/zhpanvip/BannerViewPager">BannerViewPager</a>。这是一个基于ViewPager实现的具有强大功能的无限轮播库。在未来，我会在BannerViewPager 3.0版本中用ViewPager2来重构代码。欢迎大家到GitHub关注<a href="https://github.com/zhpanvip/BannerViewPager">BannerViewPager</a> 。</p><p>ViewPager2懒加载可以看参看下面文章：</p><p><a href="https://juejin.im/post/6844904033774206984">《学不动也要学！探究Fragmen延迟加载的前世今生》</a></p><p><a href="https://github.com/zhpanvip/ViewPagerSample">本文涉及源码下载</a></p><p>第四节中ViewPager2与Fragment的代码见：</p><p><a href="https://github.com/zhpanvip/BannerViewPager">BannerViewPager</a> </p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ViewPager2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>干货满满，整理给程序员的15款开发利器</title>
    <link href="/2019/12/05/23.Development%20tools%20for%20programmer/"/>
    <url>/2019/12/05/23.Development%20tools%20for%20programmer/</url>
    
    <content type="html"><![CDATA[<p>今天给大家分享一些开发者必备的神器，这些都是笔者在几年的工作中收集到的，对于开发者非常有用的小工具。我将这些工具分为了四个部分来介绍，分别时—图片篇、文档篇、开发篇和插件篇。文章会对于各个小工具的功能及用途做一个简单介绍，并会给出星级评分，当然评分只能作为参考，因为不同工具对于不同的人有不同的重要性，这些评分是站在笔者角度来分析的。</p><h2 id="一、图片篇"><a href="#一、图片篇" class="headerlink" title="一、图片篇"></a>一、图片篇</h2><h3 id="1-GIF神器–ezgif"><a href="#1-GIF神器–ezgif" class="headerlink" title="1.GIF神器–ezgif"></a><a href="https://ezgif.com/video-to-gif">1.GIF神器–ezgif</a></h3><p>星级评分：<font color=orange >★★★★★</font><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi80LzE2ZWQxNGQxMzcxNzQ1NTE?x-oss-process=image/format,png"><br>这是一个国外站点，从名字上就可以看出这是一个Gif相关的网站。这个网站绝对称得上是一个神器，它不仅可以将视频转换为GIF，还支持GIF图片的编辑、制作、裁剪，修改尺寸、美化甚至还可以GIF转视频、倒放等等众多功能。最重要的一点是完全免费！！！所以这个工具的评分直怼到五分毫不为过。想要了解更多还是大家亲自体验！</p><h3 id="2-图片压缩神器–TinyPNG"><a href="#2-图片压缩神器–TinyPNG" class="headerlink" title="2.图片压缩神器–TinyPNG"></a><a href="https://tinypng.com/">2.图片压缩神器–TinyPNG</a></h3><p>星级评分：<font color=orange >★★★★★</font><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi80LzE2ZWQxNGRhYTY0YTFlNTU?x-oss-process=image/format,png"><br>这是一个图片无损压缩的小工具，同样来自国外。通常在App开发过程中我们都会格外注意App包的内存，拿Android的一个30M的Apk来说可能有一半以上的内存都是图片。而TinyPNG提供了批量压缩打包下载的强大功能。同时，这个网站还提供了MAC和Windows的桌面程序（桌面端限每月500张）。下图是一张Mac桌面端的截图：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi80LzE2ZWQxNGUwZjU2MjNkZmI?x-oss-process=image/format,png"><br>可以看到我们从UI拿到的图片，经过TinyPng压缩后体积减少了78.2%-91.1%。但压缩前和压缩后图片的质量肉眼几乎看不出任何差别！这对前端开发同学来说堪称神器。五星毫无悬念！</p><h3 id="3-在线作图–ProcessOn"><a href="#3-在线作图–ProcessOn" class="headerlink" title="3.在线作图–ProcessOn"></a><a href="https://www.processon.com/;jsessionid=64008D63D312671F43AE9D007BB51386.jvm1">3.在线作图–ProcessOn</a></h3><p>星级评分：<font color=orange >★★★★☆</font></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi80LzE2ZWQxNGU1YmYwMTEyMTk?x-oss-process=image/format,png"><br>这是一款免费的在线作图工具，支持流程图、思维导图、原型图、UML、网络拓扑图等。这个网站可以说应用广泛，各行各业都可能会用得到。贴一张使用ProcessOn制作的思维导图仅供参考：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi80LzE2ZWQxNGI5YmQ3MWI4MjU?x-oss-process=image/format,png" alt="在这里插入图片描述"><br>注：图片来源ProcessOn<br>虽然这个网站声称是免费作图，但免费是由一定限制的，每个账号做多可以免费保存十个文件。这也是和前两个网站相比唯一的缺点，毕竟公司也要生存，有盈利才能生存嘛，收费不为过！星级评分四颗星！</p><h3 id="4-Android-9阴影图生成器–Android-Shadow-Generator"><a href="#4-Android-9阴影图生成器–Android-Shadow-Generator" class="headerlink" title="4.Android .9阴影图生成器–Android Shadow Generator"></a><a href="https://inloop.github.io/shadow4android/">4.Android .9阴影图生成器–Android Shadow Generator</a></h3><p>星级评分：<font color=orange >★★★☆☆</font><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi80LzE2ZWQxNGI5YmZmZmY3MjU?x-oss-process=image/format,png" alt="在这里插入图片描述"><br>Android开发的同学都应该比较熟悉.9图，它是一种可以拉伸的图片。同时，做Android开发的同学也应该知道做阴影效果的痛苦。而Android Shadow Generator这个网站就提供了一个可以生成带阴影的.9图。通过这个工具不仅可以定义阴影的大小还可以顶指圆角、颜色等等。但是这个工具使用的局限性比较大，对于Android开发者来说是个不错的福利。三颗星拿走！</p><h3 id="5-业界大佬–PhotoShop"><a href="#5-业界大佬–PhotoShop" class="headerlink" title="5.业界大佬–PhotoShop"></a><a href="https://www.adobe.com/cn/products/photoshop/free-trial-download.html">5.业界大佬–PhotoShop</a></h3><p>星级评分：<font color=orange >★★★★★</font></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi80LzE2ZWQxNGU5M2JkNjNlYTg?x-oss-process=image/format,png"><br>这个软件应该不用我去做过多解释了吧，毕竟它的名气可以说无人不知无人不晓。作为一款专业的图像处理软件，想要掌握它并不是一件容易的事，但是作为一个开发人员并不需要掌握太高深的技能，了解一些简单技巧就足以应对常见问题了。没有五颗星说不过去吧？</p><h2 id="二、文档篇"><a href="#二、文档篇" class="headerlink" title="二、文档篇"></a>二、文档篇</h2><h3 id="1-PDF神器–Easy-PDF"><a href="#1-PDF神器–Easy-PDF" class="headerlink" title="1.PDF神器–Easy PDF"></a><a href="https://easypdf.com/cn">1.PDF神器–Easy PDF</a></h3><p>星级评分：<font color=orange >★★★★★</font><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi80LzE2ZWQxNGVkYWMwZTVmZGU?x-oss-process=image/format,png"><br>EasyPDF–又一款神器横空出世，它提供了强大的PDF转换功能，可以PDF转Word、PDF转PPT、Word转PDF…各种PDF转换功能应有尽有。最重要的一点是免费！！！五星还有什么说的么？</p><h3 id="2-在线文档编辑器–腾讯文档"><a href="#2-在线文档编辑器–腾讯文档" class="headerlink" title="2.在线文档编辑器–腾讯文档"></a><a href="https://docs.qq.com/desktop">2.在线文档编辑器–腾讯文档</a></h3><p>星级评分：<font color=orange >★★★★☆</font></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi80LzE2ZWQxNTQ5YWI0NTZkM2E?x-oss-process=image/format,png"><br>这是一个免费的在线文档编辑器,提供了在线编辑Word、Excel、PPT等文档，同时可以将文档分享给好友还可以授权好友共同编辑文档。是一个很不错的文档编辑工具。四颗星物有所值。</p><h3 id="4-Markdown编辑器–MarkdownPad"><a href="#4-Markdown编辑器–MarkdownPad" class="headerlink" title="4.Markdown编辑器–MarkdownPad"></a><a href="http://markdownpad.com/">4.Markdown编辑器–MarkdownPad</a></h3><p>星级评分：<font color=orange >★★★☆☆</font></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi80LzE2ZWQxNjFiNjM5MWUzNDU?x-oss-process=image/format,png"></p><p>MarkdownPad是一款桌面端的Markdown编辑器，对于经常使用Markdown写博客的开发者来说是一款很好用的工具。但是由于是国外的站点，下载比较慢，且安装好后在Windows上需要协同awesomium才能正常使用。由于使用局限性，且有很多在线的Markdown编辑器，譬如掘金、CSDN、简书(不推荐程序员使用简书，原因你懂的..)等，所以这个工具给三颗星吧。</p><p>另外，放一个百度云的MarkdownPad下载链接，包含了awesomium。</p><p><a href="https://pan.baidu.com/s/1fZm_d6ZfXesnx4_wnuMm6g">MarkdownPad下载</a></p><h2 id="三、开发篇"><a href="#三、开发篇" class="headerlink" title="三、开发篇"></a>三、开发篇</h2><h3 id="1-Postman"><a href="#1-Postman" class="headerlink" title="1.Postman"></a><a href="https://www.getpostman.com/">1.Postman</a></h3><p>星级评分：<font color=orange >★★★★★</font></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi80LzE2ZWQxNzQ5NzQzYTU1ZGY?x-oss-process=image/format,png"></p><p>这是一个开发者的神器，不管是前端人员还是后端人员都要必备的一个软件。对于前端人员来说跟后台联调时可以通过postman来模拟请求，可以自定义添加params、authorization、headers、body等，实在是一个开发利器。星级评分五颗星！</p><h3 id="2-JSON处理工具–Bejson"><a href="#2-JSON处理工具–Bejson" class="headerlink" title="2.JSON处理工具–Bejson"></a><a href="https://www.bejson.com/">2.JSON处理工具–Bejson</a></h3><p>星级评分：<font color=orange >★★★★☆</font></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi80LzE2ZWQxNzRkMmI4OTJkMDg?x-oss-process=image/format,png"></p><p>这是一款Json格式化的工具，非常贴心好用。切换到Json-&gt;Json视图模式下查看json非常清晰，一目了然。也是四星值得推荐的工具。</p><h2 id="四、插件篇"><a href="#四、插件篇" class="headerlink" title="四、插件篇"></a>四、插件篇</h2><h3 id="1-Octotree"><a href="#1-Octotree" class="headerlink" title="1.Octotree"></a>1.Octotree</h3><p>星级评分：<font color=orange >★★★★☆</font></p><p>如果你是github中毒用户，那么此款插件可谓是一个超级福利。在浏览github时要想打开某个类非常不方便，需要点击跳转好多次。而有了Octotree后就可以像在IDE中一样浏览github项目了。如下图：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi80LzE2ZWQxN2NlOTc0YzA5NGY?x-oss-process=image/format,png"></p><h3 id="2-彩云小译"><a href="#2-彩云小译" class="headerlink" title="2.彩云小译"></a>2.彩云小译</h3><p>星级评分：<font color=orange >★★★★☆</font><br>这是一款翻译工具，对于英语不好的同学来说简直就是救星，只要点一下插件就可以直接在原网页上翻译。支持英文翻译中文，同时也支持中文翻译英文。翻译效果如下图所示：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi80LzE2ZWQxODQzNzI0ZDdiMDA?x-oss-process=image/format,png"></p><h3 id="4-文件转换–Convertio"><a href="#4-文件转换–Convertio" class="headerlink" title="4.文件转换–Convertio"></a>4.<a href="https://convertio.co/zh/">文件转换–Convertio</a></h3><p>星级评分：<font color=orange >★★★★☆</font></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi80LzE2ZWQxODdhMzhhOTBiZWM?x-oss-process=image/format,png"><br>这是一个综合的文件转换平台不仅支持Web端更有Chrome插件。通过Convertio可以转换音频、视频、图像、文档等等。也是一个很不错的值得四颗星的工具。</p><h2 id="五、BannerViewPager–Android开发者福利"><a href="#五、BannerViewPager–Android开发者福利" class="headerlink" title="五、BannerViewPager–Android开发者福利"></a>五、<a href="https://github.com/zhpanvip/BannerViewPager">BannerViewPager–Android开发者福利</a></h2><p>一个非常好用的可以实现任意样式的Banner轮播图–<a href="https://github.com/zhpanvip/BannerViewPager">BannerViewPager</a></p><h3 id="据说BannerViewPager可以实现任意Banner样式？"><a href="#据说BannerViewPager可以实现任意Banner样式？" class="headerlink" title="据说BannerViewPager可以实现任意Banner样式？"></a>据说BannerViewPager可以实现任意Banner样式？</h3><blockquote><p>腾讯视频、QQ音乐、酷狗音乐、支付宝、天猫、淘宝、优酷视频、喜马拉雅、网易云音乐、哔哩哔哩、全民K歌等App的Banner页面样式及指示器样式都可以通过<a href="https://github.com/zhpanvip/BannerViewPager">BannerViewPager</a>实现哦！</p></blockquote><h3 id="列举效果预览"><a href="#列举效果预览" class="headerlink" title="列举效果预览"></a>列举效果预览</h3><table><thead><tr><th>PageStylel</th><th>IndicatorStyle</th></tr></thead><tbody><tr><td><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi80LzE2ZWQxOWEyMzkxNmY2ZTY?x-oss-process=image/format,png"></td><td><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi80LzE2ZWQxOWQ0YTMzZWJhZmM?x-oss-process=image/format,png"></td></tr></tbody></table><p>详情可以查看以下文章：</p><p><a href="https://juejin.im/post/5d6bce24f265da03db0790d1">《打造一个丝滑般自动轮播无限循环Android库》</a></p><p><a href="https://juejin.im/post/5d74d3faf265da03b5747015">《BannerViewPager源码剖析》</a></p><p><a href="https://juejin.im/post/5dda0b6d518825731f569a8c">《剖析BannerViewPager中Indicator的设计思想》</a></p><p><a href="https://github.com/zhpanvip/BannerViewPager">点击此处查看源码</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>开发工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>静态代理这么用？--聊一聊ViewPagerIndicator重构的一些经验</title>
    <link href="/2019/11/24/22.Proxy%20Pattern%20in%20IndicatorView/"/>
    <url>/2019/11/24/22.Proxy%20Pattern%20in%20IndicatorView/</url>
    
    <content type="html"><![CDATA[<p>ViewPagerIndicator的代码可谓一波三折，在不久前ViewPagerIndicator作为一个单独的仓库从<a href="https://github.com/zhpanvip/BannerViewPager">BannerViewPager</a>中拆分了出来。拆分后的indicator已经不仅仅适用于BannerViewPager，还可以用于ViewPager和ViewPager2。现在，经历了几次代码重构后,总算可以拿得出手了。本篇文章就来写一写关于重构indicator的一些经验，了解下该库是如何通过静态代理模式来实现多种多样的indicator样式的。</p><p>先贴上<a href="https://github.com/zhpanvip/viewpagerindicator">ViewPagerIndicator</a>源码链接以及预览图，使用方式可以参考GitHub主页README,同时有兴趣的同学欢迎到GitHub star项目。</p><table><thead><tr><th>Attrs</th><th>CIRCLE</th><th>DASH</th><th>ROUND_RECT</th></tr></thead><tbody><tr><td>NORMAL</td><td><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/27/171bbe6bc1be5e6b~tplv-t2oaga2asx-image.image" alt="CIRCLE_NORMAL"></td><td><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/27/171bbe714fea7070~tplv-t2oaga2asx-image.image" alt="DASH_NORMAL"></td><td><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/27/171bbe76ed8e7596~tplv-t2oaga2asx-image.image" alt="ROUND_RECT_NORMAL"></td></tr><tr><td>SMOOTH</td><td><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/27/171bbe7f3eb8b67f~tplv-t2oaga2asx-image.image" alt="CIRCLE_SMOOTH"></td><td><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/27/171bbe84d8e72c01~tplv-t2oaga2asx-image.image" alt="DASH_SMOOTH"></td><td><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/27/171bbe8d4610a819~tplv-t2oaga2asx-image.image" alt="ROUND_RECT_SMOOTH"></td></tr><tr><td>WORM</td><td><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/27/171bbe94b8343002~tplv-t2oaga2asx-image.image" alt="CIRCLE_WORM"></td><td><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/27/171bbe99efa4bf70~tplv-t2oaga2asx-image.image" alt="DASH_WORM"></td><td><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/27/171bbea0ee416556~tplv-t2oaga2asx-image.image" alt="ROUND_WORM"></td></tr><tr><td>COLOR</td><td><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/27/171bbea5f0dc18b9~tplv-t2oaga2asx-image.image" alt="CIRCLE_COLOR"></td><td><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/27/171bbeab734b3d64~tplv-t2oaga2asx-image.image" alt="DASH_COLOR"></td><td><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/27/171bbeb3b468aa46~tplv-t2oaga2asx-image.image" alt="ROUND_COLOR"></td></tr><tr><td>SCALE</td><td><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/27/171bbeba52f93dea~tplv-t2oaga2asx-image.image" alt="CIRCLE_SCALE"></td><td><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/27/171bbebfeec63dd2~tplv-t2oaga2asx-image.image" alt="DASH_SCALE"></td><td><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/27/171bbec80f11b947~tplv-t2oaga2asx-image.image" alt="ROUND_SCALE"></td></tr></tbody></table><h2 id="一、为什么要重构"><a href="#一、为什么要重构" class="headerlink" title="一、为什么要重构"></a>一、为什么要重构</h2><p>在Indicator未拆分之前针对IndicatorView进行了两次较大的重构。第一次重构在上篇文章中也有提到。最初的Indicator是在BannerViewPager内部维护了一个指示器ImageView的List集合，在BannerViewPager内部会根据页面size动态添加指示器的Image。显然这种处理方式存在很大的弊端，即：不灵活、可扩展性低、性能相对较差等诸多问题。针对这一系列问题，在后续版本中对Indicator进行了第一次重构。这次重构将Indicator改为自定义View，并且抽象出了IIndicator接口，极大的增强了Indicator的可扩展性。因此，在后续若干个版本迭代中Indicator逐渐支持了多种样式（CIRCLE/DASH/ROUND_RECT）和多种滑动模式（SMOOTH/NORMAL）并且支持自定义Indicator。相比最初版本，不管在功能还是性能上都有了很大的提升。但是，在后续版本的迭代中却又暴露出许多问题。而这些问题很大程度上影响了开发和使用。列举其中一个最大问题如下：</p><h3 id="多个IndicatorView不利于维护和使用"><a href="#多个IndicatorView不利于维护和使用" class="headerlink" title="多个IndicatorView不利于维护和使用"></a>多个IndicatorView不利于维护和使用</h3><p>在BannerViewPager早期版本中indicator已经支持了CIRCLE和DASH两种样式，与之对应的是CircleIndicatorView和DashIndicatorView。在BannerViewPager内部用简单工厂模式根据IndicatorStyle来生成对应的IndicatorView。这么以来就出现了一个弊端，即每添加一种Indicator样式都需要一个与之对应的IndicatorView类，当Indicator 样式越来越多的时候维护成本和使用成本都会随之增加–使用该库的开发人员需要记住每种样式对应的IndicatorView名字，作为该库维护者也要面对越来越臃肿的代码结构，这是大家都不愿意看到的。因此，在这样的背景下IndicatorView的第二次重构就势在必行，不得不做了。针对这一问题，在第二次重构中使用了静态代理模式对代码结构进行了优化。</p><h2 id="二、回顾静态代理模式"><a href="#二、回顾静态代理模式" class="headerlink" title="二、回顾静态代理模式"></a>二、回顾静态代理模式</h2><p>不知道现在大家对代理模式还记得多少，也不知道是否经常会在项目种用到代理模式。不管怎样，我们先来回顾以下静态代理模式吧：</p><blockquote><p>代理模式即为其它对象提供一种代理控制对这个对象的访问。在代理模式中，一个类代表另一个类的功能。这种类型的设计模式属于结构型模式。在代理模式中，我们创建具有现有对象的对象，以便向外界提供功能接口。</p></blockquote><p>代理模式的结构图如下：<br><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/11/24/16e9bbccba24acd7~tplv-t2oaga2asx-image.image" alt="这里写图片描述"><br>注：图片来源《大话设计模式》</p><p>看定义总是那么的晦涩难懂，我们还是来举一个代理模式的场景：</p><blockquote><p>Ryan想在上海买一套房子，但是他又不懂房地产的行情，于是委托了中介（Proxy）来帮助他买房子。</p></blockquote><p>我们把这个场景通过Java代码来实现一下：</p><h3 id="1-抽象出接口"><a href="#1-抽象出接口" class="headerlink" title="1.抽象出接口"></a>1.抽象出接口</h3><p>首先我们把买房子的一类人抽象出来一个接口，接口中有一个buyHouse的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IPersonBuyHouse</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">buyHouse</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-明确被代理的对象"><a href="#2-明确被代理的对象" class="headerlink" title="2.明确被代理的对象"></a>2.明确被代理的对象</h3><p>Ryan想要买房子，于是他就需要实现这个IPersonBuyHouse接口:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Ryan</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IPersonBuyHouse</span></span>&#123;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buyHouse</span><span class="hljs-params">()</span> </span>&#123;<br>System.out.println(<span class="hljs-string">&quot;Ryan:I want buy a House...&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-寻找代理"><a href="#3-寻找代理" class="headerlink" title="3.寻找代理"></a>3.寻找代理</h3><p>由于Ryan不了解房地产行情，于是将买房子的事情委托给了中介（Proxy），因此中介（Proxy）也需要实现IPersonBuyHouse的接口。但是中介不是给自己买房子的，而是买给其它有购房需求者的，所以他应该持有一个IPersonBuyHouse。而此处的购房需求者就是Ryan.于是Proxy代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Proxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IPersonBuyHouse</span></span>&#123;<br><br><span class="hljs-keyword">private</span> IPersonBuyHouse mIPerson;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Proxy</span><span class="hljs-params">()</span> </span>&#123;<br>    mIPerson=<span class="hljs-keyword">new</span> Ryan();<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buyHouse</span><span class="hljs-params">()</span> </span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;Proxy:I can help you to buy house&quot;</span>);<br>    mIPerson.buyHouse();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来我们在Main方法种测试一下Proxy类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProxyTest</span> </span>&#123;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">new</span> Proxy().buyHouse();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/11/24/16e9bbccbc4943bd~tplv-t2oaga2asx-image.image" alt="在这里插入图片描述"><br>通过上面的例子可以看到静态代理是一个很简单的设计模式。那么接下来我们看下如何通过静态代理模式来完成对IndicatorView的重构吧。</p><h2 id="三、用静态代理模式重构Indicator"><a href="#三、用静态代理模式重构Indicator" class="headerlink" title="三、用静态代理模式重构Indicator"></a>三、用静态代理模式重构Indicator</h2><p>在第一章节中我们就已经提到了当前Indicator的弊端：要维护多个IndicatorView，不利于开发也不利于使用。我们当前的目的就是要将IndicatorView统一成一个。而我们现在面临的困境是如何让一个IndicatorView承载多个Indicator Style？因为它既要绘制CIRCLE Style又要绘制DASH Style，以及以后可能还会增加更多的Style样式。在这种场景下我们就可以想到代理模式来解决问题。</p><p>上一个章节中我们举了一个静态代理的例子是正向思维写下来的，那么本章中我们就采用逆向思维，看下如何倒推出来静态代理模式。</p><h3 id="1-初步设想"><a href="#1-初步设想" class="headerlink" title="1.初步设想"></a>1.初步设想</h3><p>首先，我们想要一个IndicatorView承接所有Style的绘制，那么正常来说我们就需要在IndicatorView中通过IndicatorStyle判断是哪种样式，然后在IndicatorView中进行绘制。其伪代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IndicatorView</span>  </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onMeasure</span><span class="hljs-params">(<span class="hljs-keyword">int</span> widthMeasureSpec, <span class="hljs-keyword">int</span> heightMeasureSpec)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(Style==CIRCLE) &#123;<br>        setMeasuredDimension(measurCircleWidth(), measurCircleHeight());<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>    setMeasuredDimension(measurDashWidth(), measurDashHeight());<br>    &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onDraw</span><span class="hljs-params">(Canvas canvas)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(Style==CIRCLE) &#123;<br>        drawCircleIndicator(canvas);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        drawDashleIndicator(canvas);<br>    &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是如果IndicatorStyle样式非常多的情况下，IndicatorView必然会变得非常庞大且臃肿。因此，我们自然而然的就会想到将View的measure和draw的逻辑抽出来单独给一个类来完成，那么这个类中呢至少应该有measure和draw两个方法。因此，我们将这个类的伪代码写出来大概应该是这样子的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DrawerProxy</span>  </span>&#123;<br><br>    <span class="hljs-keyword">public</span> BaseDrawer.<span class="hljs-function">MeasureResult <span class="hljs-title">onMeasure</span><span class="hljs-params">(<span class="hljs-keyword">int</span> widthMeasureSpec, <span class="hljs-keyword">int</span> heightMeasureSpec)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(Style==CIRCLE) &#123;<br>    <span class="hljs-keyword">return</span> measureCircleIndicator(<span class="hljs-keyword">int</span> widthMeasureSpec, <span class="hljs-keyword">int</span> heightMeasureSpec);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">return</span> measureDashIndicator(<span class="hljs-keyword">int</span> widthMeasureSpec, <span class="hljs-keyword">int</span> heightMeasureSpec);<br>    &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onDraw</span><span class="hljs-params">(Canvas canvas)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(Style==CIRCLE) &#123;<br>        drawCircleIndicator(canvas);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        drawDashleIndicator(canvas);<br>    &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-抽象接口"><a href="#2-抽象接口" class="headerlink" title="2.抽象接口"></a>2.抽象接口</h3><p>通过上一小节的操作我们虽然将测量和绘制逻辑从IndicatorView中剥离了出来，但是DrawerProxy 这个类却承载了所有的测量和绘制逻辑。当Style样式多的时候同样会使DrawerProxy类变得臃肿不堪。因此，我们又很自然的想到了应该把不同Style的绘制逻辑单独抽出来，于是就有了CircleDrawer和DashDrawer两个类来分别处理各自的逻辑。但因为这两个类又要同时被放在DrawerProxy类中，且这两个类都又共同的方法。因此可以抽出一个CircleDrawer和DashDrawer的共同接口。于是就有了这样的一个IDrawer的接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IDrawer</span> </span>&#123;<br><br>    BaseDrawer.<span class="hljs-function">MeasureResult <span class="hljs-title">onMeasure</span><span class="hljs-params">(<span class="hljs-keyword">int</span> widthMeasureSpec, <span class="hljs-keyword">int</span> heightMeasureSpec)</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onDraw</span><span class="hljs-params">(Canvas canvas)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>同时CircleDrawer和DashDrawer都应该实现该接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CircleDrawer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IDrawer</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> MeasureResult <span class="hljs-title">onMeasure</span><span class="hljs-params">(<span class="hljs-keyword">int</span> widthMeasureSpec, <span class="hljs-keyword">int</span> heightMeasureSpec)</span> </span>&#123;<br>   <span class="hljs-comment">// ... 省略measure逻辑</span><br>        <span class="hljs-keyword">return</span> mMeasureResult;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onDraw</span><span class="hljs-params">(Canvas canvas)</span> </span>&#123;<br>        drawIndicator(canvas);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">drawIndicator</span><span class="hljs-params">(Canvas canvas)</span> </span>&#123;<br>       <span class="hljs-comment">// ...省略draw逻辑</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">//DashDrawer与此类似，不再贴出</span><br></code></pre></td></tr></table></figure><h3 id="3-回眸一看，静态代理？"><a href="#3-回眸一看，静态代理？" class="headerlink" title="3.回眸一看，静态代理？"></a>3.回眸一看，静态代理？</h3><p>到了这里我们在再来看DrawerProxy，发现这个类中同样需要onMeasure和onDraw，那他实现IDrawer接口顺理成章，同时它应该持有一个IDrawer类以便完成真实的测量和绘制任务。于是乎，完善之后的DrawerProxy类就成了这个样子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DrawerProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IDrawer</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> IDrawer mIDrawer;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DrawerProxy</span><span class="hljs-params">(IndicatorOptions indicatorOptions)</span> </span>&#123;<br>        init(indicatorOptions);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(IndicatorOptions indicatorOptions)</span> </span>&#123;<br>        mIDrawer = DrawerFactory.createDrawer(indicatorOptions);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setIndicatorOptions</span><span class="hljs-params">(IndicatorOptions indicatorOptions)</span> </span>&#123;<br>        init(indicatorOptions);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> BaseDrawer.<span class="hljs-function">MeasureResult <span class="hljs-title">onMeasure</span><span class="hljs-params">(<span class="hljs-keyword">int</span> widthMeasureSpec, <span class="hljs-keyword">int</span> heightMeasureSpec)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> mIDrawer.onMeasure(widthMeasureSpec, heightMeasureSpec);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onDraw</span><span class="hljs-params">(Canvas canvas)</span> </span>&#123;<br>        mIDrawer.onDraw(canvas);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>到这里，我们回过神来看一下，这不就是一个非常标准的静态代理模式吗？当然，这里也结合了简单工厂模式来生成对应的Drawer。<br>接着我们来看下重构后的IndicatorView</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IndicatorView</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BaseIndicatorView</span> </span>&#123;<br><br>  <span class="hljs-keyword">private</span> DrawerProxy mDrawerProxy;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">IndicatorView</span><span class="hljs-params">(Context context)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>(context, <span class="hljs-keyword">null</span>);<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">IndicatorView</span><span class="hljs-params">(Context context, <span class="hljs-meta">@Nullable</span> AttributeSet attrs)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>(context, attrs, <span class="hljs-number">0</span>);<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">IndicatorView</span><span class="hljs-params">(Context context, <span class="hljs-meta">@Nullable</span> AttributeSet attrs, <span class="hljs-keyword">int</span> defStyleAttr)</span> </span>&#123;<br>    <span class="hljs-keyword">super</span>(context, attrs, defStyleAttr);<br>    mDrawerProxy = <span class="hljs-keyword">new</span> DrawerProxy(getIndicatorOptions());<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onMeasure</span><span class="hljs-params">(<span class="hljs-keyword">int</span> widthMeasureSpec, <span class="hljs-keyword">int</span> heightMeasureSpec)</span> </span>&#123;<br>    <span class="hljs-keyword">super</span>.onMeasure(widthMeasureSpec, heightMeasureSpec);<br>    BaseDrawer.MeasureResult measureResult = mDrawerProxy.onMeasure(widthMeasureSpec, heightMeasureSpec);<br>    setMeasuredDimension(measureResult.getMeasureWidth(), measureResult.getMeasureHeight());<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onDraw</span><span class="hljs-params">(Canvas canvas)</span> </span>&#123;<br>    <span class="hljs-keyword">super</span>.onDraw(canvas);<br>    mDrawerProxy.onDraw(canvas);<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setIndicatorOptions</span><span class="hljs-params">(IndicatorOptions indicatorOptions)</span> </span>&#123;<br>    <span class="hljs-keyword">super</span>.setIndicatorOptions(indicatorOptions);<br>    mDrawerProxy.setIndicatorOptions(indicatorOptions);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到通过静态代理模式简化完后的IndicatorView仅仅剩下了三十多行的代码，所有的测量和绘制逻辑都交给代理类DrawerProxy来处理，而DrawerProxy又将逻辑移交给对应的Drawer来完成。这样，所有的类都各司其职，代码简单明了！开发和维护起来也就变得更加得心应手了！</p><p>最后，我们来看下如何使用Indicator：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">    indicatorView<br>.setSlideMode(IndicatorSlideMode.WORM)<br>.setIndicatorStyle(IndicatorStyle.CIRCLE)<br>.setSliderColor(getResColor(R.color.red_normal_color), getResColor(R.color.red_checked_color))<br>.setupWithViewPager(viewPager)<br></code></pre></td></tr></table></figure><p>通过一个简单的链式调用传入不同的参数便实现了多种多样的指示器样式。</p><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>本篇文章分享了对ViewPagerIndicator重构的一些经验。通过本篇文章相信大家对于静态代理模式也会有了更深的认识。重构后的代码在维护和使用上相比以前显然有了更明显的提升。但是并不等于现在的Indicator已经无懈可击了。相反，它还有很长的路要走。就目前而言，Indicator的SlideMode部分还是又相当大的优化空间的，那么我们就在后面的版本中拭目以吧。</p><p><a href="https://github.com/zhpanvip/viewpagerindicator">ViewPagerIndicator源码戳此处</a></p><p>同时，欢迎关注用ViewPagerIndicator实现的<a href="https://github.com/zhpanvip/BannerViewPager">BannerViewPager</a>库</p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
      <tag>ViewPager2</tag>
      
      <tag>indicator</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BannerViewPager源码剖析(二)</title>
    <link href="/2019/09/08/21.BVP%20source/"/>
    <url>/2019/09/08/21.BVP%20source/</url>
    
    <content type="html"><![CDATA[<p>BannerViewPager系列文章共三篇，此文为第二篇，另外两篇参看下面链接：</p><p><a href="https://blog.csdn.net/qq_20521573/article/details/100186077">《打造一个丝滑般自动轮播无限循环Android库》</a></p><p><a href="https://blog.csdn.net/qq_20521573/article/details/103216593">《剖析BannerViewPager中Indicator的设计思想》</a></p><p>上篇文章<a href="https://juejin.im/post/5d6bce24f265da03db0790d1">《打造一个丝滑般自动轮播无限循环Android库》</a>非常详细的介绍了<a href="https://github.com/zhpanvip/BannerViewPager">BannerViewPager</a>的基础功能及使用方法。我们知道BannerViewPager不但可以支持任意的页面布局，而且可以支持任意的Indicator。那么<a href="https://github.com/zhpanvip/BannerViewPager">BannerViewPager</a>的这些功能是如何实现的呢？本篇文章将深入源码来带大家了解<a href="https://github.com/zhpanvip/BannerViewPager">BannerViewPager</a>的设计思路。</p><h1 id="一、如何支持任意的Item布局"><a href="#一、如何支持任意的Item布局" class="headerlink" title="一、如何支持任意的Item布局"></a>一、如何支持任意的Item布局</h1><p>产品的需求千变万化，你永远也猜不到下一步产品会给你提一个什么样的需求。因此对于一个比较人性化的Banner库来说，它也应该支持开发者去自定义任意的Item页面布局。BannerViewPager就是本着这样的思路来做的。接下来将通过两小节的内容来探究BannerViewPager是如何实现任意Item布局的。</p><h2 id="1-BannerViewPager的ViewHolder"><a href="#1-BannerViewPager的ViewHolder" class="headerlink" title="1.BannerViewPager的ViewHolder"></a>1.BannerViewPager的ViewHolder</h2><p>我们先从setHolderCreator(HolderCreator<VH> holderCreator)这个方法说起。在使用BannerViewPager的时候必须设置一个HolderCreator，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">bannerViewPager.setHolderCreator(<span class="hljs-keyword">new</span> HolderCreator&lt;CustomPageViewHolder&gt;() &#123;<br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-function"><span class="hljs-keyword">public</span> CustomPageViewHolder <span class="hljs-title">createViewHolder</span><span class="hljs-params">()</span> </span>&#123;<br>                        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CustomPageViewHolder();<br>                    &#125;<br>                &#125;)<br></code></pre></td></tr></table></figure><p>在HolderCreator的createViewHolder方法中返回了一个CustomPageViewHolder，这个CustomPageViewHolder是我们自己实现的。其内部会通过createView方法来inflate出来一自定义的itemView,并在onBind方法中为itemView绑定数据。码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomPageViewHolder</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ViewHolder</span>&lt;<span class="hljs-title">CustomBean</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">private</span> ImageView mImageView;<br>    <span class="hljs-keyword">private</span> TextView mTextView;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> View <span class="hljs-title">createView</span><span class="hljs-params">(ViewGroup viewGroup, Context context, <span class="hljs-keyword">int</span> position)</span> </span>&#123;<br>        View view = LayoutInflater.from(context).inflate(R.layout.item_custom_view, viewGroup, <span class="hljs-keyword">false</span>);<br>        mImageView = view.findViewById(R.id.banner_image);<br>        mTextView = view.findViewById(R.id.tv_describe);<br>        <span class="hljs-keyword">return</span> view;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onBind</span><span class="hljs-params">(Context context, CustomBean data, <span class="hljs-keyword">int</span> position, <span class="hljs-keyword">int</span> size)</span> </span>&#123;<br>        mImageView.setImageResource(data.getImageRes());<br>        mTextView.setText(data.getImageDescription());<br>    &#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>在BannerViewPager内部setupViewPager的时候，针对HolderCreator做了如下操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setupViewPager</span><span class="hljs-params">()</span> </span>&#123;<br>       <span class="hljs-keyword">if</span> (holderCreator != <span class="hljs-keyword">null</span>) &#123;<br>            BannerPagerAdapter&lt;T, VH&gt; bannerPagerAdapter =<br>                  <span class="hljs-keyword">new</span> BannerPagerAdapter&lt;&gt;(mList, holderCreator);<br>          bannerPagerAdapter.setPageStyle(mPageStyle);<br>          bannerPagerAdapter.setCanLoop(isCanLoop);<br>        bannerPagerAdapter.setPageClickListener(position -&gt; &#123;<br>               <span class="hljs-keyword">if</span> (mOnPageClickListener != <span class="hljs-keyword">null</span>) &#123;<br>                   mOnPageClickListener.onPageClick(PositionUtils.getRealPosition(isCanLoop, position, mList.size(), mPageStyle));<br>              &#125;<br>          &#125;);<br>          mViewPager.setAdapter(bannerPagerAdapter);<br>       ...<br>       &#125; <span class="hljs-keyword">else</span> &#123;<br>           <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException(<span class="hljs-string">&quot;You must set HolderCreator for BannerViewPager&quot;</span>);<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><p>上述代码中判断如果holderCreator为null时就抛出了一个NullPointerException，这也解释了为什么必须要为BannenrViewPager设置holderCreator。当holderCreator不为null时，将holder传递到了BannerPagerAdapter中,并且为BannerPagerAdapter设置了相关参数和页面点击事件。</p><p>我们接下来到BannerPagerAdapter中一探究竟：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BannerPagerAdapter</span>&lt;<span class="hljs-title">T</span>, <span class="hljs-title">VH</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ViewHolder</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">PagerAdapter</span> </span>&#123;<br> <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-meta">@NonNull</span><br>    <span class="hljs-function">Object <span class="hljs-title">instantiateItem</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> <span class="hljs-keyword">final</span> ViewGroup container, <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> position)</span> </span>&#123;<br>        View itemView = getView(PositionUtils.getRealPosition(isCanLoop, position, mList.size(), mPageStyle),container);<br>        container.addView(itemView);<br>        <span class="hljs-keyword">return</span> itemView;<br>    &#125;<br><br>...<br><span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> View <span class="hljs-title">getView</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> position, ViewGroup container)</span> </span>&#123;<br>        ViewHolder&lt;T&gt; holder = holderCreator.createViewHolder();<br>        <span class="hljs-keyword">if</span> (holder == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;can not return a null holder&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> createView(holder, position, container);<br>    &#125;<br>    <br><span class="hljs-function"><span class="hljs-keyword">private</span> View <span class="hljs-title">createView</span><span class="hljs-params">(ViewHolder&lt;T&gt; holder, <span class="hljs-keyword">int</span> position, ViewGroup container)</span> </span>&#123;<br>        View view = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">if</span> (list != <span class="hljs-keyword">null</span> &amp;&amp; list.size() &gt; <span class="hljs-number">0</span>) &#123;<br>          view = holder.createView(container, container.getContext(), position);<br>          holder.onBind(container.getContext(), list.get(position), position, list.size());<br>        <span class="hljs-keyword">return</span> view;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>在BannerPagerAdapter的getView方法中通过holderCreator.createViewHolder()拿到了自定义的ViewHolder，此时即为上边的CustomPageViewHolder 。接下来在createView方法中调用CustomPageViewHolder的createView方法拿到我们自定义的itemView,并通过holder.onBind方法将集合中的数据传递给了CustomPageViewHolder。到这里我们就完成了自定义item布局以及item数据的绑定。</p><h2 id="2-BannerViewPager的泛型设计"><a href="#2-BannerViewPager的泛型设计" class="headerlink" title="2 .BannerViewPager的泛型设计"></a>2 .BannerViewPager的泛型设计</h2><p>在上一小节中通过HolderCreator来实现任意的页面布局，但此时我们应该会面临一个问题，既然可以支持任意的页面布局那么BannerViewPager中接收的数据也应该时任意类型的。对于该问题我们可以引入泛型来实现。首先看BannerViewPager的泛型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BannerViewPager</span>&lt;<span class="hljs-title">T</span>, <span class="hljs-title">VH</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ViewHolder</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">RelativeLayout</span> <span class="hljs-keyword">implements</span></span><br><span class="hljs-class">        <span class="hljs-title">ViewPager</span>.<span class="hljs-title">OnPageChangeListener</span> </span>&#123;<br>        <br><span class="hljs-comment">// 轮播数据集合</span><br>        <span class="hljs-keyword">private</span> List&lt;T&gt; mList;<br><br><span class="hljs-keyword">private</span> HolderCreator&lt;VH&gt; holderCreator;<br>    <br><span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>BannerViewPager有两个泛型参数，第一个参数T是对应的数据类型，它用来作为BannerViewPager中List集合的泛型。另一个泛型参数VH规定了必须是继承ViewHolder的类，用来作为HolderCreator的泛型。而ViewHolder和HolderCreator均是一个带有泛型参数的接口，其代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ViewHolder</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-function">View <span class="hljs-title">createView</span><span class="hljs-params">(ViewGroup viewGroup,Context context, <span class="hljs-keyword">int</span> position)</span></span>;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> context context</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> data 实体类对象</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> position 当前位置</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> size 页面个数</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onBind</span><span class="hljs-params">(Context context,T data,<span class="hljs-keyword">int</span> position,<span class="hljs-keyword">int</span> size)</span></span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">HolderCreator</span>&lt;<span class="hljs-title">VH</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ViewHolder</span>&gt; </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 创建ViewHolder</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">VH <span class="hljs-title">createViewHolder</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>另外，T和VH两个泛型也同时作为BannerPagerAdapter的泛型参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BannerPagerAdapter</span>&lt;<span class="hljs-title">T</span>, <span class="hljs-title">VH</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ViewHolder</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">PagerAdapter</span> </span>&#123;<br><br><span class="hljs-keyword">private</span> List&lt;T&gt; list;<br> <br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BannerPagerAdapter</span><span class="hljs-params">(List&lt;T&gt; list, HolderCreator&lt;VH&gt; holderCreator)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.list = list;<br>        <span class="hljs-keyword">this</span>.holderCreator = holderCreator;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，我们通过泛型约束，使得涉及到的相关类中的参数数据类型保持了同步,从而实现了BannerViewPager可以接收并处理任意的数据类型。</p><h1 id="二、如何实现无限循环轮播"><a href="#二、如何实现无限循环轮播" class="headerlink" title="二、如何实现无限循环轮播"></a>二、如何实现无限循环轮播</h1><p>关于ViewPager的无限循环无外乎两种方案。</p><p>第一种方案是在PagerAdapter的getCount中返回一个Integer.MAX_VALUE，即一个最大的Integer整数。然后将setCurrentItem的值设置为 Integer.MAX_VALUE / 2，在滑动过程中不断取余以此来达到一个无限循环轮播的假象。</p><p>另外一种方案是额外增加两个ViewPager的item count，然后在第0个Item填充最后一条数据，在最后一个Item填充第0条数据。当右滑到第一个Item的时候将currentItem置为pageSize-1,当滑动到最后一个Item的时候将currentItem置为1，以此来达到一个无限循环的目的，此方案的示意图如下：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMS8xNy8xNmU3ODVhZDcyYmQ2NzQz?x-oss-process=image/format,png" alt="无限循环示意图"><br>BannerViewPager的无限轮播使用的是第二种方案。至于这两种方案孰优孰劣不好判断，因为我并没有深入研究过方案一，因此对比这两种方案的优略对比我暂时没有发言权。但是关于第二种方案的优略我可以加以分析。</p><h2 id="方案二的优点："><a href="#方案二的优点：" class="headerlink" title="方案二的优点："></a>方案二的优点：</h2><p><strong>1.这一方案实现了真正意义上的无限轮播</strong></p><p>相比方案一设置了一个最大值来制造无限轮播的假象，方案二实现的是一种真正的无限轮播。这个方案通过手动切换position使得轮播能够无限持续下去。这一点可能要略优于方案一。（其实Integer.MAX_VALUE的数值已经达到了数十亿级别，即使从一数到十亿恐怕都要几天吧？所以这一点也算不上方案一的缺点）</p><p><strong>2.页面切换较少出现空白页</strong></p><p>曾经看过几个使用方案一实现的Banner都有偶尔出现空白页的问题，当然不排除是这些库写的有问题，毕竟我也见过使用方案一实现非常好的库。而BannerViewPager在使用方案二时并没有经过什么特殊处理，却也很少见到空白页问题，当然也不排除是我代码写的好。（板儿砖尽管扔过来吧，哈哈！）。</p><h2 id="方案二的缺点："><a href="#方案二的缺点：" class="headerlink" title="方案二的缺点："></a>方案二的缺点：</h2><p>虽然BannerViewPager使用的是方案二，但是秉着公正的态度，绝不包庇这一方案的缺点。这个方案的优点虽然我苦思冥想也只想出来了两条，但是关于它的缺点我却能罗列出来很多。正所谓谁(sei)用谁(sei)知道！</p><p><strong>1.onPageSelected(int)方法重复调用问题</strong></p><p>我们为BannerViewPager开启自动轮播，并为其设置页面改变的监听事件，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">mBannerViewPager.setAutoPlay(<span class="hljs-keyword">true</span>)<br>.setOnPageChangeListener(<span class="hljs-keyword">new</span> OnPageChangeListenerAdapter() &#123;<br>                   <span class="hljs-meta">@Override</span><br>                   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onPageSelected</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position)</span> </span>&#123;<br>                       BannerUtils.e(<span class="hljs-string">&quot;position &quot;</span> + position);<br>                   &#125;<br>               &#125;)<br></code></pre></td></tr></table></figure><p>然后可以看到打印的Log：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMS8xNy8xNmU3ODVhZDcyZThkZDZm?x-oss-process=image/format,png" alt="在这里插入图片描述"><br>在BannerViewPager只有三个页面的情况下，页面position selected的周期是0、1、2、0。很明显，第0个页面被多调用了一次。虽然在大多数情况下并没有影响，但是当需要在选中第0个页面时做一些逻辑的话，就会产生一定影响。至于这个问题有没有解决办法，暂时还未去做进一步探究。</p><p><strong>2.在一屏三页模式下，这一方案在轮播到最后一页时会出现下一页短暂空白的问题</strong></p><p>出现这一问题的原因是因为为了完成循环在切换到最后一页时我们立即将position切换到了position为1的页面，而此时position为2个页面还未加载出来，因此就有了短暂的空白问题。为了解决这一问题，又不得不在原来循环的基础上再增加两个页面，并将setOffscreenPageLimit设置为2。这样无形中增加了内存开销，并且使得逻辑处理变得更为复杂！</p><p><strong>3.需要对position进行变换</strong></p><p>为了实现循环我们将page count增加了2，为了解决一屏三页的空白问题我们将page count增加了4。但对外暴露的接口需要拿到正确的position，此时我们就不得不在BannerViewPager内部对position进行变换，使之能够对应到正确的position。虽然解决了问题，但是这些逻辑处理却变得很臃肿。尽管方案一也会存在position的变换问题，但是相比方案二还是优雅很多。</p><p>综上来看，方案二其实并不是一个完美的方案，相反它却存在诸多的问题！但是由于没有用过方案一，所以对于方案一有没有坑，现在也不好妄下结论。有熟悉方案一的同学可以在文章下留言告知。后续我会单独开一个分支来尝试下方案一。如果方案一没有大问题，BannerViewPager的循环轮播方案可能会迁移到第一个解决方案（目前2.4.3版本已切换为方案一，许多问题迎刃而解。真香！）。</p><h1 id="三、千变万化的Indicator"><a href="#三、千变万化的Indicator" class="headerlink" title="三、千变万化的Indicator"></a>三、千变万化的Indicator</h1><p>在最初的设计中，BannerViewPager同其它大多Bannenr库一样,内部维护了一个Indicator的List集合用来存放Indicator的icon，然后根据页面size动态的添加Indicator。显然这样的Indicator非常不灵活，如果UI觉得之前颜色不好看，需要换个颜色。你说，OK！没关系，你给我切图就好了。但是如果UI说我需要一个Indicator跟随ViewPager滑动的效果，那么此时你一定一脸茫然不知所措！于是和UI开启了漫长的拉锯战…扯远了，我们继续回归正题。考虑到这个问题，在后来的版本中针对Indicator进行了优化重构，现在的BannerViewPager已经可以支持任意样式的Indicator。并且还可以根据需求任意摆放Indicator的位置。是否期待了解这些神奇的功能是如何实现的呢？接下来就一起来探究<br>首先，定义了一个IIndicator的接口，该接口继承了ViewPager.OnPageChangeListener接口。其代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IIndicator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ViewPager</span>.<span class="hljs-title">OnPageChangeListener</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setPageSize</span><span class="hljs-params">(<span class="hljs-keyword">int</span> pageSize)</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setNormalColor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> normalColor)</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setCheckedColor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> checkedColor)</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setSlideMode</span><span class="hljs-params">(IndicatorSlideMode slideStyle)</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setIndicatorGap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> gap)</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setIndicatorWidth</span><span class="hljs-params">(<span class="hljs-keyword">int</span> normalIndicatorWidth, <span class="hljs-keyword">int</span> checkedIndicatorWidth)</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">notifyDataChanged</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>在BannerViewPager内部持有了IIndicator的实例，并且setIndicatorView方法只接收IIndicator类型的参数。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BannerPagerAdapter</span>&lt;<span class="hljs-title">T</span>, <span class="hljs-title">VH</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ViewHolder</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">PagerAdapter</span> </span>&#123;<br><br><span class="hljs-comment">// 轮播指示器</span><br>    <span class="hljs-keyword">private</span> IIndicator mIndicatorView;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 设置自定义View指示器,自定义View需要需要继承BaseIndicator或者实现IIndicator接口自行绘制指示器。</span><br><span class="hljs-comment">     * 注意，一旦设置了自定义IndicatorView,通过BannerViewPager设置的部分IndicatorView参数将失效。</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> customIndicator 自定义指示器</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> BannerViewPager&lt;T, VH&gt; <span class="hljs-title">setIndicatorView</span><span class="hljs-params">(IIndicator customIndicator)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (customIndicator <span class="hljs-keyword">instanceof</span> View) &#123;<br>            isCustomIndicator = <span class="hljs-keyword">true</span>;<br>            mIndicatorView = customIndicator;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在setIndicatorView内部通过判断customIndicator是否是View的实例，以此确保了指示器必须继承自View并实现IIndicator接口。并且可以看到在满足条件的情况下将isCustomIndicator置为了true，以此来标记是否是自定义的指示器。如果外部没有调用setIndicatorView设置自定义指示器或者设置的指示器不符合要求，那么mIndicatorView岂不是就为null了？不慌，我们接着往下看代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BannerPagerAdapter</span>&lt;<span class="hljs-title">T</span>, <span class="hljs-title">VH</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ViewHolder</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">PagerAdapter</span> </span>&#123;<br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 构造ViewPager</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> list ViewPager数据</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">create</span><span class="hljs-params">(List&lt;T&gt; list)</span> </span>&#123;<br>        initBannerData(list);<br>    &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initBannerData</span><span class="hljs-params">(List&lt;T&gt; list)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (list != <span class="hljs-keyword">null</span>) &#123;<br>            mList.clear();<br>            mList.addAll(list);<br>            <span class="hljs-keyword">if</span> (mList.size() &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">if</span> (mList.size() &gt; <span class="hljs-number">1</span>) &#123;<br>                    <span class="hljs-keyword">if</span> (isCustomIndicator &amp;&amp; <span class="hljs-keyword">null</span> != mIndicatorView) &#123;<br>                        initIndicator(mIndicatorView);<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        initIndicator(IndicatorFactory.createIndicatorView(getContext(), mIndicatorStyle));<br>                    &#125;<br>                &#125;<br>                <span class="hljs-comment">// ...</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们在使用BannerViewPager的时候设置完参数配置之后需要调用create(List&lt;T&gt; list)方法，在这个方法中会根据list的数据情况来初始化Indicator。上述代码中只有在list.size()大于1的时候才会初始化Indicator，并且在后边判断如果是自定义的Indicator就直接初始化指示器，如果没有自定义指示器，那么就调用指示器工厂，根据设置的指示器Style生成内置指示器样式。这么一来就实现了内置指示器和自定义指示器的切换。</p><p>那么问题又来了，关于Indicator位置任意摆放是如何实现的呢？为什么自定义指示器可以直接new出来，也可以放在xml中呢？关于这两个问题就需要来看下initIndicator做了什么操作了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initIndicator</span><span class="hljs-params">(IIndicator indicatorView)</span> </span>&#123;<br>        mIndicatorLayout.setVisibility(mIndicatorVisibility);<br>        mIndicatorView = indicatorView;<br>        <span class="hljs-keyword">if</span> (((View) mIndicatorView).getParent() == <span class="hljs-keyword">null</span>) &#123;<br>            mIndicatorLayout.removeAllViews();<br>            mIndicatorLayout.addView((View) mIndicatorView);<br>            initIndicatorViewMargin();<br>            initIndicatorGravity();<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>在initIndicator中会首先判断indicatorView的parent是否为null。什么情况下indicatorView的parent会为null呢？答案就是内置指示器和setIndicatorView()的参数通过new的方式传进来的情况下indicatorView的parent会是null的情况！那么此时就将indicator添加到BannerViewPager内部mIndicatorLayout中就可以了。而如果Indicator是声明在xml中的情况，此时通过findViewById获得的Indicator其parent一定不会是null，那么在initIndicator中只是将其赋值给了mIndicatorView。以此完成了对内置IndicatorView的替换。这样其实不管通过怎样的方法设置IndicatorView都保证了BannerViewPager内部始终只会维护一个Indicator。方法非常巧妙，这里我想要一个赞！（似乎又嗅到了板儿砖的气息）</p><h1 id="四、遇到的其他问题及解决方案"><a href="#四、遇到的其他问题及解决方案" class="headerlink" title="四、遇到的其他问题及解决方案"></a>四、遇到的其他问题及解决方案</h1><p>在BannerViewPager的开发过避免不了的会碰到一些问题，虽然有些已经解决了，但有些可能还悬而未决。但是不管解决没解决以供大家参考或讨论。</p><h2 id="1-手指滑动页面过程中应停止自动轮播"><a href="#1-手指滑动页面过程中应停止自动轮播" class="headerlink" title="1.手指滑动页面过程中应停止自动轮播"></a>1.手指滑动页面过程中应停止自动轮播</h2><p>自动轮播的功能是通过Handler来实现的。通过postDelayed开启轮播，通过removeCallbacks停止轮播。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 开启轮播</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">startLoop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!isLooping &amp;&amp; isAutoPlay &amp;&amp; mList.size() &gt; <span class="hljs-number">1</span>) &#123;<br>            mHandler.postDelayed(mRunnable, interval);<br>            isLooping = <span class="hljs-keyword">true</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 停止轮播</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stopLoop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (isLooping) &#123;<br>            mHandler.removeCallbacks(mRunnable);<br>            isLooping = <span class="hljs-keyword">false</span>;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>如果在手指滑动的过程中没有停止轮播，体验上来说非常不好。因此，需要处理这种情况。解决方案是重写ViewPager的setOnTouchListener方法，监听手指滑动的时候停止轮播，抬起手指的时候开启轮播。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setTouchListener</span><span class="hljs-params">()</span> </span>&#123;<br>       mViewPager.setOnTouchListener((v, event) -&gt; &#123;<br>           <span class="hljs-keyword">int</span> action = event.getAction();<br>           <span class="hljs-keyword">switch</span> (action) &#123;<br>               <span class="hljs-keyword">case</span> MotionEvent.ACTION_DOWN:<br>               <span class="hljs-keyword">case</span> MotionEvent.ACTION_MOVE:<br>                   isLooping = <span class="hljs-keyword">true</span>;<br>                   stopLoop();<br>                   <span class="hljs-keyword">break</span>;<br>               <span class="hljs-keyword">case</span> MotionEvent.ACTION_UP:<br>               <span class="hljs-keyword">case</span> MotionEvent.ACTION_CANCEL:<br>                   isLooping = <span class="hljs-keyword">false</span>;<br>                   startLoop();<br>               <span class="hljs-keyword">default</span>:<br>                   <span class="hljs-keyword">break</span>;<br>           &#125;<br>           <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>       &#125;);<br>   &#125;<br></code></pre></td></tr></table></figure><h2 id="2-关于instantiateItem的优化问题"><a href="#2-关于instantiateItem的优化问题" class="headerlink" title="2.关于instantiateItem的优化问题"></a>2.关于instantiateItem的优化问题</h2><p>我们知道，在ViewPager每次切换页面的时候都会调用instantiateItem去实例化ItemView，也就意味着我们在这个方法中通过ViewHolder的createView方法每次切换页面都会被调用重新初始化绑定数据。这样对程序来说是一种性能上的浪费。针对这种情况，在2.4.3之前的版本中做了些优化。在BannerPagerAdapter中维护一个List<View> mViewList集合，用来存放创建出来的itemView.在itemView初始化成功后，为其设置tag并保存到集合中，当在此切换页面时我们从集合中取出itemView并对比tag,如果一致则直接使用即可。这样就避免了重复的创建对象，造成一些性能开销。具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BannerPagerAdapter</span>&lt;<span class="hljs-title">T</span>, <span class="hljs-title">VH</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ViewHolder</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">PagerAdapter</span> </span>&#123;<br><br><span class="hljs-keyword">private</span> List&lt;View&gt; mViewList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> View <span class="hljs-title">findViewByPosition</span><span class="hljs-params">(ViewGroup container, <span class="hljs-keyword">int</span> position)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (View view : mViewList) &#123;<br>            <span class="hljs-keyword">if</span> (((<span class="hljs-keyword">int</span>) view.getTag()) == position &amp;&amp; view.getParent() == <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">return</span> view;<br>            &#125;<br>        &#125;<br>        View view = getView(position, container);<br>        view.setTag(position);<br>        mViewList.add(view);<br>        <span class="hljs-keyword">return</span> view;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是这一优化却又会引发另一个问题，即内存问题！通常App的轮播控件都是图片，而图片是比较占用内存的。此时我们把所有的itemView都存储在一个集合中这样真的是一个好的方案吗？在ViewPager页面少的情况下问题可能不会凸显。但是如果ViewPager的页面很多的情况下问题就相当严重了！于是，后来我灵光一闪，突发奇想！那我就设置一个最大缓存呗？当集合中的个数超过阈值的时候就把最近用过的一个itemView移除掉不就好了？妙哉妙哉！可转念一想，这尼玛和设置一个setOffscreenPageLimit有什么区别呢？当我们在考虑这些问题的时候Google工程师早就替我们想到了！所以关于ViewPager的instantiateItem是否有必要去优化我目前持保留态度。但是，在BannerViewPager 2.4.3之前的版本中确实做了上述优化，因此前些版本中可能会存在内存问题。至于2.4.3或之后版本大概会去掉这部分优化。这个问题可能也只能留在未来，待升级到ViewPager2后解决了！关于这个问题欢迎大家在文章下方留言，各抒己见！</p><h2 id="3-RecyclerView-ViewPager会有非Smooth的页面滑动情况"><a href="#3-RecyclerView-ViewPager会有非Smooth的页面滑动情况" class="headerlink" title="3.RecyclerView+ViewPager会有非Smooth的页面滑动情况"></a>3.RecyclerView+ViewPager会有非Smooth的页面滑动情况</h2><p>这个问题不是太好描述，我们直接通过一张GIF来看</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMS8xOS8xNmU4NDAyYTEyOWI1MGQ3?x-oss-process=image/format,png"><br>从图中可以很直观的看到，把BannerViewPager向上划出屏幕再很快划回来，此时BannerViewPager页面切换的动画没有了，很生硬的直接跳到了下一页。这个问题不是BannerViewPager的bug,而是ViewPager内部原因导致的，可以看到很多线上的APP都存在这个问题，例如喜马拉雅（喜马拉雅的轮播图真心做的好看呀，效果也很赞！）。这个bug虽然不影响使用，但是总感觉效果不太好。因此还是要处理一下。处理之前先来分析一下问题原因。<br>在ViewPager内部有一个私有成员变量mFirstLayout，其默认值为true。这个参数用来标记是否是第一次layout的。如果是第一次layout那么滑动就不是smooth的。代码如下：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public void set<span class="hljs-constructor">CurrentItem(<span class="hljs-params">int</span> <span class="hljs-params">item</span>)</span> &#123;<br>    mPopulatePending = <span class="hljs-literal">false</span>;<br>    set<span class="hljs-constructor">CurrentItemInternal(<span class="hljs-params">item</span>, !<span class="hljs-params">mFirstLayout</span>, <span class="hljs-params">false</span>)</span>;<br>&#125;<br><br>void set<span class="hljs-constructor">CurrentItemInternal(<span class="hljs-params">int</span> <span class="hljs-params">item</span>, <span class="hljs-params">boolean</span> <span class="hljs-params">smoothScroll</span>, <span class="hljs-params">boolean</span> <span class="hljs-params">always</span>)</span> &#123;<br>    set<span class="hljs-constructor">CurrentItemInternal(<span class="hljs-params">item</span>, <span class="hljs-params">smoothScroll</span>, <span class="hljs-params">always</span>, 0)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个参数在onLayout方法中会被置为false.代码如下：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">@Override<br>protected void on<span class="hljs-constructor">Layout(<span class="hljs-params">boolean</span> <span class="hljs-params">changed</span>, <span class="hljs-params">int</span> <span class="hljs-params">l</span>, <span class="hljs-params">int</span> <span class="hljs-params">t</span>, <span class="hljs-params">int</span> <span class="hljs-params">r</span>, <span class="hljs-params">int</span> <span class="hljs-params">b</span>)</span> &#123;<br>    <span class="hljs-comment">//  在onLayout的最后一行</span><br>    mFirstLayout = <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>因此，在正常情况下，onLayout执行之后页面滑动都应该时smooth的。然后，当ViewPager滑动出屏幕的时候其onDetachedFromWindow方法会被调用，而当其再次进入屏幕的时候则会调用onAttachedToWindow这个方法。来看看onAttachedToWindow方法中的代码：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onAttachedToWindow</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.onAttachedToWindow();<br>        mFirstLayout = <span class="hljs-keyword">true</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p>仅仅把mFirstLayout置为了true！而如果此时onLayout没有被触发，而是先发生了页面滚动，那么此时的页面滑动就没了的smooth效果了。了解了原因之后处理起来就简单了，因为mFirstLayout是私有属性，我们无法访问，所以只有通过反射来修改其值。我们在CatchViewPager(继承自ViewPager的一个类)中做如下操作：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> firstLayout = <span class="hljs-keyword">true</span>;<br><br> <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onAttachedToWindow</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.onAttachedToWindow();<br>        hookFirstLayout();<br>    &#125;<br><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onDetachedFromWindow</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.onDetachedFromWindow();<br>        firstLayout = <span class="hljs-keyword">false</span>;<br>    &#125;<br><br> <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">hookFirstLayout</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Field mFirstLayout = ViewPager.class.getDeclaredField(&quot;mFirstLayout&quot;);<br>            mFirstLayout.setAccessible(<span class="hljs-keyword">true</span>);<br>            mFirstLayout.set(<span class="hljs-keyword">this</span>, firstLayout);<br>            setCurrentItem(getCurrentItem());<br>        &#125; <span class="hljs-keyword">catch</span> (IllegalAccessException | NoSuchFieldException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br></code></pre></td></tr></table></figure><p>这样问题就迎刃而解了，再次滑动RecyclerView，一切完好！</p><h2 id="4-关于Indicator在SMOOTH下的滑动问题。"><a href="#4-关于Indicator在SMOOTH下的滑动问题。" class="headerlink" title="4.关于Indicator在SMOOTH下的滑动问题。"></a>4.关于Indicator在SMOOTH下的滑动问题。</h2><p>这是一个由来已久的问题，感觉好难处理！如果不处理循环的话其实是非常容易的，但是如果加上循环之后总是有这样那的问题😂。只能说目前的计算方式不是太对，具体怎么计算的我也不贴出来了！毕竟现在写出来的还是有bug的。很羡慕喜马拉雅的滑动效果做的太Nice了！后续版本中我会想办法再优化这个问题。</p><h1 id="五、总结及致谢"><a href="#五、总结及致谢" class="headerlink" title="五、总结及致谢"></a>五、总结及致谢</h1><p>到这里关于BannerViewPager的两篇文章就全部结束了，<a href="https://juejin.im/post/5d6bce24f265da03db0790d1">上一篇文章</a>主要着重介绍了BannerViewPager的功能及用法，而本篇文章则详细的讲解了BannerViewPager的实现原理。就目前而言，BannerViewPager并不是一个完美的轮播库，很多地方还有很大值得优化的空间甚至有些功能还存在一些小bug。但是这些都不会阻碍BannerViewPager逐渐走向优秀。在未来的版本中我将会针对这些问题逐一优化。当然，如果你有好的解决方案欢迎在文章下方留言，也可以直接到github提交pull request。如果你有什么好的建议或者遇到什么问题也欢迎在文章下方留言讨论。</p><p>最后要特别感谢saiwu-bigkoo大神的<a href="https://github.com/saiwu-bigkoo/Android-ConvenientBanner">Android-ConvenientBanner</a>库以及youth5201314大神的<a href="https://github.com/youth5201314/banner">banner</a>库。BannerViewPager中的很多思想来自这两个库。BannerViewPager中内置的四个ViewPager Transform来自<a href="https://github.com/ToxicBakery/ViewPagerTransforms">ViewPagerTransforms</a>库，在此表示感谢。同时还要感谢<a href="https://wanandroid.com/">玩Android</a>提供的接口支持，以及在开发过程中参考过的文章或其它优秀开源库，不能一一列出，在此一并表示感谢。</p><p>最后还是要贴上源码地址，欢迎star、fork 。</p><p><a href="https://github.com/zhpanvip/BannerViewPager">点击查看源码</a></p>]]></content>
    
    
    <categories>
      
      <category>自定义View</category>
      
    </categories>
    
    
    <tags>
      
      <tag>自定义View</tag>
      
      <tag>BVP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>打造一个丝滑般自动轮播无限循环Android库(一)</title>
    <link href="/2019/09/01/20.BannerViewPager/"/>
    <url>/2019/09/01/20.BannerViewPager/</url>
    
    <content type="html"><![CDATA[<p>本文同步发布在<a href="https://juejin.im/post/5d6bce24f265da03db0790d1">掘金</a>，如需转载请注明出处。</p><p>BannerViewPager系列文章共三篇，此文为第一篇，另外两篇参看下面链接：</p><p><a href="https://blog.csdn.net/qq_20521573/article/details/100609592">BannerViewPager源码剖析</a></p><p><a href="https://blog.csdn.net/qq_20521573/article/details/103216593">剖析BannerViewPager中Indicator的设计思想</a></p><p>最近公司项目在升级AndroidX，由于项目中用到的一些比较老的库都已停止更新维护，因此需要将这些库替换掉，其中就包括自动轮播的Banner库。恰逢笔者在之前写过一个轮播图，因此就在此基础上重构，打造出了一个全新的支持多种样式的轮播库—<a href="https://github.com/zhpanvip/BannerViewPager/tree/master">BannerViewPager</a>。个人觉得<a href="https://github.com/zhpanvip/BannerViewPager/tree/master">BannerViewPager</a>要优于其它开源的Banner库，不仅仅是因为它拥有简洁高效的代码，更是因为它高度的可定制性。<a href="https://github.com/zhpanvip/BannerViewPager/tree/master">BannerViewPager</a>不仅支持任意的页面布局，而且可以支持任意的Indicator样式。甚至连Indicator的位置都可以做到任意摆放。是的，就是这么随心所欲。无图言叼，还是先通过图片和代码一览BannerViewPager的功能吧(多图预警)。</p><h1 id="一、BannerViewPager效果预览及API介绍"><a href="#一、BannerViewPager效果预览及API介绍" class="headerlink" title="一、BannerViewPager效果预览及API介绍"></a>一、BannerViewPager效果预览及API介绍</h1><p>由于GIF图片质量问题，下面的预览图并不清晰，大家可以点击下面链接或者扫描二维码下载Apk体验。Apk存放在github上，下载速度可能会比较慢。</p><p> <a href="https://github.com/zhpanvip/BannerViewPager/raw/master/download/app.apk">点击或扫描二维码下载apk</a></p><p><img src="https://raw.githubusercontent.com/zhpanvip/Resource/master/image/banner/qrcode.png"></p><h2 id="1-setIndicatorStyle（开局就放王炸？）"><a href="#1-setIndicatorStyle（开局就放王炸？）" class="headerlink" title="1.setIndicatorStyle（开局就放王炸？）"></a>1.setIndicatorStyle（开局就放王炸？）</h2><p>BannerViewPager目前内置了CIRCLE和DASH两种样式的指示器,通过setIndicatorStyle(int)一行代码就可以切换指示器的样式。当然，如果内置样式不满足你的需求。BannerViewPager还提供了自定义指示器的功能。只要继承BaseIndicatorView或者实现IIndicator接口，并重写相应方法，就可以通过自定义View为所欲为的打造任意的Indicator了。如下图【自定义】就是自己实现的指示器样式。</p><table><thead><tr><th>CIRCLE</th><th>DASH</th><th>自定义</th></tr></thead><tbody><tr><td><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMS8xNi8xNmU3NGNhODFlOWM4OGI5?x-oss-process=image/format,png"></td><td><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMS8xNi8xNmU3NGNiNGU3M2YyM2U3?x-oss-process=image/format,png"></td><td><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMS8xNi8xNmU3NGNjMjE2OWNiOTBi?x-oss-process=image/format,png"></td></tr></tbody></table><p>下面通过代码演示如何切换指示器：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">mViewPager.set<span class="hljs-constructor">IndicatorStyle(IndicatorStyle.DASH)</span><br>          .set<span class="hljs-constructor">IndicatorHeight(BannerUtils.<span class="hljs-params">dp2px</span>(3f)</span>)<br>          .set<span class="hljs-constructor">IndicatorWidth(BannerUtils.<span class="hljs-params">dp2px</span>(3)</span>, <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">BannerUtils</span>.</span></span>dp2px(<span class="hljs-number">10</span>))<br>          .set<span class="hljs-constructor">HolderCreator(()</span> -&gt; <span class="hljs-keyword">new</span> <span class="hljs-constructor">ImageResourceViewHolder(0)</span>)<br>          .create(mDrawableList)<br></code></pre></td></tr></table></figure><p>通过5行代码就轻松的实现了上图【Dash】仿支付宝的Indicator样式（大家可以留意一下支付宝的轮播Indicator，挺有意思）。</p><p>关于自定义IndicatorView将会放在后边章节详细讲解。</p><h2 id="2-setPageStyle"><a href="#2-setPageStyle" class="headerlink" title="2.setPageStyle"></a>2.setPageStyle</h2><p>通过setPageStyle(int)一行代码开启一屏三页模式，一屏三页模式下目前有三种样式，分别如下图所示：</p><table><thead><tr><th>MULTI_PAGE</th><th>MULTI_PAGE_SCALE</th><th>MULTI_PAGE_OVERLAP</th></tr></thead><tbody><tr><td><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMS8xNS8xNmU2ZjNjMTdhZDcyMGMx?x-oss-process=image/format,png" alt="MULTI_PAGE "></td><td><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMS8xNS8xNmU2ZjNjMTdiODNhOTQ4?x-oss-process=image/format,png" alt="MULTI_PAGE_SCALE "></td><td><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMS8xNS8xNmU2ZjNjMTdjM2QwOWVh?x-oss-process=image/format,png" alt="MULTI_PAGE_OVERLAP "></td></tr><tr><td>代码演示：</td><td></td><td></td></tr></tbody></table><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">mViewPager</span><span class="hljs-selector-class">.setPageStyle</span>(<span class="hljs-selector-tag">PageStyle</span><span class="hljs-selector-class">.MULTI_PAGE</span>)<br>          <span class="hljs-selector-class">.setPageMargin</span>(<span class="hljs-selector-tag">BannerUtils</span><span class="hljs-selector-class">.dp2px</span>(10))<br>          <span class="hljs-selector-class">.setRevealWidth</span>(<span class="hljs-selector-tag">BannerUtils</span><span class="hljs-selector-class">.dp2px</span>(10))<br>          <span class="hljs-selector-class">.setHolderCreator</span>(() <span class="hljs-selector-tag">-</span>&gt; <span class="hljs-selector-tag">new</span> <span class="hljs-selector-tag">ImageResourceViewHolder</span>(<span class="hljs-selector-tag">BannerUtils</span><span class="hljs-selector-class">.dp2px</span>(5)))<br>          <span class="hljs-selector-class">.create</span>(<span class="hljs-selector-tag">mDrawableList</span>);<br></code></pre></td></tr></table></figure><p>同样通过短短5行代码就实现了上图【MULTI_PAGE】的效果，简单好用！</p><h2 id="3-如何实现指示器位置任意摆放？"><a href="#3-如何实现指示器位置任意摆放？" class="headerlink" title="3.如何实现指示器位置任意摆放？"></a>3.如何实现指示器位置任意摆放？</h2><p>我们看到上面图表中MULTI_PAGE_OVERLAP模式下指示器显示到了Banner的下边。这种效果该怎么实现呢？其实BannerViewPager是支持把Indicator摆放在任意位置的。之所以能如此强大是因为我们通过自定义指示器替换了内置的IndicatorView，也就是说此时的IndicatorView已经脱离了BannerViewPager,也就理所当然的可以放在任意位置了。接下来通过代码来看下如何实现：</p><h3 id="1-Xml布局文件如下"><a href="#1-Xml布局文件如下" class="headerlink" title="(1)Xml布局文件如下"></a>(1)Xml布局文件如下</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs stylus">&lt;RelativeLayout xmlns:android=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span><br>    xmlns:app=<span class="hljs-string">&quot;http://schemas.android.com/apk/res-auto&quot;</span><br>    android:layout_width=<span class="hljs-string">&quot;match_parent&quot;</span><br>    android:layout_height=<span class="hljs-string">&quot;match_parent&quot;</span>&gt;<br><br>    &lt;com<span class="hljs-selector-class">.zhpan</span><span class="hljs-selector-class">.bannerview</span>.BannerViewPager<br>        android:id=<span class="hljs-string">&quot;@+id/banner_view&quot;</span><br>        android:layout_width=<span class="hljs-string">&quot;match_parent&quot;</span><br>        android:layout_height=<span class="hljs-string">&quot;180dp&quot;</span><br>        android:layout_marginTop=<span class="hljs-string">&quot;20dp&quot;</span><br>        app:bvp_page_style=<span class="hljs-string">&quot;multi_page&quot;</span> /&gt;<br><br>    &lt;com<span class="hljs-selector-class">.zhpan</span><span class="hljs-selector-class">.bannerview</span><span class="hljs-selector-class">.indicator</span>.CircleIndicatorView<br>        android:id=<span class="hljs-string">&quot;@+id/indicator_view&quot;</span><br>        android:layout_width=<span class="hljs-string">&quot;wrap_content&quot;</span><br>        android:layout_height=<span class="hljs-string">&quot;wrap_content&quot;</span><br>        android:layout_below=<span class="hljs-string">&quot;@id/banner_view&quot;</span><br>        android:layout_centerHorizontal=<span class="hljs-string">&quot;true&quot;</span><br>        android:layout_marginTop=<span class="hljs-string">&quot;10dp&quot;</span> /&gt;<br> &lt;/RelativeLayout&gt;<br><br></code></pre></td></tr></table></figure><h3 id="2-通过setIndicatorView-IIndicator-替换内部指示器"><a href="#2-通过setIndicatorView-IIndicator-替换内部指示器" class="headerlink" title="(2)通过setIndicatorView(IIndicator)替换内部指示器"></a>(2)通过setIndicatorView(IIndicator)替换内部指示器</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">      CircleIndicatorView indicatorView = find<span class="hljs-constructor">ViewById(R.<span class="hljs-params">id</span>.<span class="hljs-params">indicator_view</span>)</span>;<br>mViewPager.set<span class="hljs-constructor">IndicatorView(<span class="hljs-params">indicatorView</span>)</span><br>                .set<span class="hljs-constructor">IndicatorColor(Color.<span class="hljs-params">parseColor</span>(<span class="hljs-string">&quot;#888888&quot;</span>)</span>,<br>                     <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Color</span>.</span></span>parse<span class="hljs-constructor">Color(<span class="hljs-string">&quot;#118EEA&quot;</span>)</span>)<br>                .set<span class="hljs-constructor">HolderCreator(()</span> -&gt; <span class="hljs-keyword">new</span> <span class="hljs-constructor">ImageResourceViewHolder(BannerUtils.<span class="hljs-params">dp2px</span>(5)</span>))<br>                .create(mDrawableList);<br></code></pre></td></tr></table></figure><p>CircleIndicatorView是什么？其实他就是内置在BannerViewPager中的指示器，现在你只需要把它同BannerViewPager放在同一个布局文件中就可以了。又是仅仅通过一行代码就完成了对内部指示器的替换，不知道你看完之后是否会拍案叫绝，竟然如此简单！</p><h2 id="4-setIndicatorSlideMode"><a href="#4-setIndicatorSlideMode" class="headerlink" title="4.setIndicatorSlideMode"></a>4.setIndicatorSlideMode</h2><p>我们应该见过很多App轮播图的指示器都会跟随页面一起滑动。BannerViewPager自然也不会少了这个功能。通过setIndicatorSlideMode(int)一行代码就可以轻松切换到下图（SMOOTH）的效果。</p><table><thead><tr><th>NORMAL</th><th>SMOOTH</th></tr></thead><tbody><tr><td><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMS8xNS8xNmU2ZjNjMWIwM2U5NWE5?x-oss-process=image/format,png"></td><td><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMS8xNS8xNmU2ZjNjMWI0MGMwMzAz?x-oss-process=image/format,png"></td></tr></tbody></table><p>代码实现仍然非常简单，使用BannerViewPager你只需要记住一个核心–Only One Line！所以演示代码不再贴出你应该不会揍我吧？</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMS8xNi8xNmU3NGE4NThhY2ZmZTg2?x-oss-process=image/format,png"></p><h2 id="5-setPageTransformerStyle"><a href="#5-setPageTransformerStyle" class="headerlink" title="5.setPageTransformerStyle"></a>5.setPageTransformerStyle</h2><p>关于Transform更好的方式应该是留给开发者自己去实现，因此BannerViewPager中目前仅内置了四种常用Transform样式，如果不能满足需求，可以通过BannerViewPager的setPageTransformer(ViewPager.PageTransformer transformer)设置自定义的Transform。四种内置Transform样式如下：</p><table><thead><tr><th>STACK</th><th>ACCORDION</th><th>DEPTH</th><th>ROTATE</th></tr></thead><tbody><tr><td><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMS8xNy8xNmU3OTkyZGZmMTA5MWYz?x-oss-process=image/format,png"></td><td><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMS8xNy8xNmU3OTkzNjI4NGU2MThm?x-oss-process=image/format,png"></td><td><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMS8xNy8xNmU3OTk0MzBhYThmYTFl?x-oss-process=image/format,png"></td><td><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMS8xNy8xNmU3OTk0YmQ2MzlmYjAw?x-oss-process=image/format,png"></td></tr></tbody></table><p>当然，BannerViewPager的功能并不仅仅局限于此，更多功能就不再演示，可以看下面所有开放的API接口。</p><h2 id="6-BannerViewPager开放的API"><a href="#6-BannerViewPager开放的API" class="headerlink" title="6.BannerViewPager开放的API"></a>6.BannerViewPager开放的API</h2><p>BannerViewPager开放了众多API,以供满足不同的需求，具体如下表：</p><table><thead><tr><th>方法名</th><th>方法描述</th><th>说明</th></tr></thead><tbody><tr><td>BannerViewPager&lt;T, VH&gt; setCanLoop(boolean canLoop)</td><td>是否开启循环</td><td>默认值true</td></tr><tr><td>BannerViewPager&lt;T, VH&gt; setAutoPlay(boolean autoPlay)</td><td>是否开启自动轮播</td><td>默认值true</td></tr><tr><td>BannerViewPager&lt;T, VH&gt; setInterval(int interval)</td><td>自动轮播时间间隔</td><td>单位毫秒，默认值3000</td></tr><tr><td>BannerViewPager&lt;T, VH&gt; setScrollDuration(int scrollDuration)</td><td>设置页面滚动时间</td><td>设置页面滚动时间</td></tr><tr><td>BannerViewPager&lt;T, VH&gt; setRoundCorner(int radius)</td><td>设置圆角</td><td>默认无圆角 需要SDK_INT&gt;=LOLLIPOP(API 21)</td></tr><tr><td>BannerViewPager&lt;T, VH&gt; setOnPageClickListener(OnPageClickListener onPageClickListener)</td><td>设置页面点击事件</td><td></td></tr><tr><td>BannerViewPager&lt;T, VH&gt; setHolderCreator(HolderCreator&lt;VH&gt; holderCreator)</td><td>设置HolderCreator</td><td>必须设置HolderCreator，否则会抛出NullPointerException</td></tr><tr><td>BannerViewPager&lt;T, VH&gt; setIndicatorVisibility(@Visibility int visibility)</td><td>indicator vibility</td><td>默认值VISIBLE 2.4.2 新增</td></tr><tr><td>BannerViewPager&lt;T, VH&gt; setIndicatorStyle(int indicatorStyle)</td><td>设置指示器样式</td><td>可选枚举(CIRCLE, DASH) 默认CIRCLE</td></tr><tr><td>BannerViewPager&lt;T, VH&gt; setIndicatorGravity(int gravity)</td><td>指示器位置</td><td>可选值(CENTER、START、END)默认值CENTER</td></tr><tr><td>BannerViewPager&lt;T, VH&gt; setIndicatorColor(int normalColor,int checkedColor)</td><td>指示器圆点颜色</td><td>normalColor：未选中时颜色默认”#8C6C6D72”， checkedColor：选中时颜色 默认”#8C18171C”</td></tr><tr><td>BannerViewPager&lt;T, VH&gt; setIndicatorSlideMode(int slideMode)</td><td>设置Indicator滑动模式</td><td>可选（NORMAL、SMOOTH），默认值SMOOTH</td></tr><tr><td>BannerViewPager&lt;T, VH&gt; setIndicatorRadius(int radius)</td><td>设置指示器圆点半径</td><td>默认值4dp</td></tr><tr><td>BannerViewPager&lt;T, VH&gt; setIndicatorRadius(int normalRadius,int checkRadius)</td><td>设置指示器圆点半径</td><td>normalRadius:未选中时半径  checkedRadius:选中时的半径,默认值4dp</td></tr><tr><td>BannerViewPager&lt;T, VH&gt; setIndicatorWidth(int indicatorWidth)</td><td>设置指示器宽度，如果是圆形指示器，则为直径</td><td>默认值8dp</td></tr><tr><td>BannerViewPager&lt;T, VH&gt; setIndicatorWidth(int normalWidth, int checkWidth)</td><td>设置指示器宽度，如果是圆形指示器，则为直径</td><td>默认值8dp</td></tr><tr><td>BannerViewPager&lt;T, VH&gt; setIndicatorHeight(int indicatorHeight)</td><td>设置指示器高度，仅在Indicator样式为DASH时有效</td><td>默认值normalIndicatorWidth/2</td></tr><tr><td>BannerViewPager&lt;T, VH&gt; setIndicatorGap(int indicatorMargin)</td><td>指示器圆点间距</td><td>默认值为指示器宽度（或者是圆的直径）</td></tr><tr><td>BannerViewPager&lt;T, VH&gt; setIndicatorView(IIndicator indicatorView)</td><td>设置自定义指示器</td><td></td></tr><tr><td>BannerViewPager&lt;T, VH&gt; setPageTransformerStyle(int style)</td><td>设置页面Transformer内置样式</td><td></td></tr><tr><td>BannerViewPager&lt;T, VH&gt; setCurrentItem(int item)</td><td>Set the currently selected page.</td><td>2.3.5新增</td></tr><tr><td>void getCurrentItem()</td><td>获取当前position</td><td>2.3.5新增</td></tr><tr><td>BannerViewPager&lt;T, VH&gt; setPageStyle(PageStyle pageStyle)</td><td>设置页面样式</td><td>2.4.0新增 可选（MULTI_PAGE、NORMAL）MULTI_PAGE：一屏多页样式</td></tr><tr><td>BannerViewPager&lt;T, VH&gt; setPageMargin(int pageMargin)</td><td>设置页面间隔</td><td>2.4.0新增</td></tr><tr><td>BannerViewPager&lt;T, VH&gt; setIndicatorMargin(int left, int top, int right, int bottom)</td><td>设置Indicator边距</td><td>2.4.1新增</td></tr><tr><td>BannerViewPager&lt;T, VH&gt; setOnPageChangeListener(OnPageChangeListener l)</td><td>页面改变的监听事件</td><td>2.4.3新增</td></tr><tr><td>void startLoop()</td><td>开启自动轮播</td><td>初始化BannerViewPager时不必调用该方法,设置setAutoPlay后会调用startLoop()</td></tr><tr><td>void stopLoop()</td><td>停止自动轮播</td><td>如果开启自动轮播，为避免内存泄漏需要在onStop()或onDestroy中调用此方法</td></tr><tr><td>List&lt;T&gt; getList()</td><td>获取Banner中的集合数据</td><td></td></tr><tr><td>void create(List<T> list)</td><td>初始化并构造BannerViewPager</td><td>必须调用，否则前面设置的参数无效</td></tr></tbody></table><h2 id="7-BannerViewPager支持的attrs"><a href="#7-BannerViewPager支持的attrs" class="headerlink" title="7.BannerViewPager支持的attrs"></a>7.BannerViewPager支持的attrs</h2><p>你也可以通过xml来设置BannerViewPager，xml支持的attrs如下:<br>| Attributes | format | description |<br>|–|–|–|<br>| bvp_interval | integer | 自动轮播时间间隔 |<br>| bvp_scroll_duration | integer | 页面切换时滑动时间|<br>| bvp_can_loop | boolean| 是否循环 |<br>| bvp_auto_play | boolean | 是否自动播放  |<br>| bvp_indicator_checked_color | color | indicator选中时颜色 |<br>| bvp_indicator_normal_color | color | indicator未选中时颜色 |<br>| bvp_indicator_radius | dimension | indicator圆点半径或者Dash模式的1/2宽度  |<br>| bvp_round_corner| dimension  | Banner圆角大小 |<br>| bvp_page_margin | dimension | 页面item间距 |<br>| bvp_reveal_width | dimension | 一屏多页模式下两边item漏出的宽度 |<br>| bvp_indicator_style | enum | indicator样式(circle/dash)  |<br>| bvp_indicator_slide_mode | enum | indicator滑动模式(normal/smooth) |<br>| bvp_indicator_gravity | enum | indicator位置(center/start/end) |<br>| bvp_page_style | enum | page样式(normal/multi_page/multi_page_overlap/multi_page_scale) |<br>| bvp_transformer_style | enum | transform样式(normal/depth/stack/accordion) |<br>| bvp_indicator_visibility| enum | indicator visibility(visible/gone/invisible) |</p><h1 id="二、BannerViewPager详细使用说明"><a href="#二、BannerViewPager详细使用说明" class="headerlink" title="二、BannerViewPager详细使用说明"></a>二、BannerViewPager详细使用说明</h1><h2 id="1-gradle中添加依赖"><a href="#1-gradle中添加依赖" class="headerlink" title="1.gradle中添加依赖"></a>1.gradle中添加依赖</h2><p>如果您已迁移到AndroidX请使用latestVersion(&gt;=2.4.3.1)</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs clean"><span class="hljs-keyword">implementation</span> <span class="hljs-string">&#x27;com.zhpan.library:bannerview:latestVersion&#x27;</span><br><br></code></pre></td></tr></table></figure><p>如果未迁移到AndroidX请使用（非Androidx的包托管在JCenter上）：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clean"><span class="hljs-keyword">implementation</span> <span class="hljs-string">&#x27;com.zhpan.library:bannerview:2.4.3.1&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="2-在xml文件中添加如下代码："><a href="#2-在xml文件中添加如下代码：" class="headerlink" title="2. 在xml文件中添加如下代码："></a>2. 在xml文件中添加如下代码：</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;com.zhpan.bannerview.BannerViewPager<br>        android:<span class="hljs-attribute">id</span>=<span class="hljs-string">&quot;@+id/banner_view&quot;</span><br>        android:<span class="hljs-attribute">layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span><br>        android:<span class="hljs-attribute">layout_margin</span>=<span class="hljs-string">&quot;10dp&quot;</span><br>        android:<span class="hljs-attribute">layout_height</span>=<span class="hljs-string">&quot;160dp&quot;</span> /&gt;<br></code></pre></td></tr></table></figure><h2 id="3-Banner的Item页面布局"><a href="#3-Banner的Item页面布局" class="headerlink" title="3.Banner的Item页面布局"></a>3.Banner的Item页面布局</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">RelativeLayout</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ImageView</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/banner_image&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:scaleType</span>=<span class="hljs-string">&quot;centerCrop&quot;</span> /&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">LinearLayout</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_alignParentBottom</span>=<span class="hljs-string">&quot;true&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:background</span>=<span class="hljs-string">&quot;#66000000&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:gravity</span>=<span class="hljs-string">&quot;center_vertical&quot;</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/tv_describe&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_gravity</span>=<span class="hljs-string">&quot;center_vertical&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_marginStart</span>=<span class="hljs-string">&quot;15dp&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:gravity</span>=<span class="hljs-string">&quot;center_vertical&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:paddingTop</span>=<span class="hljs-string">&quot;5dp&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:paddingBottom</span>=<span class="hljs-string">&quot;5dp&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:textColor</span>=<span class="hljs-string">&quot;#FFFFFF&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:textSize</span>=<span class="hljs-string">&quot;16sp&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">LinearLayout</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">RelativeLayout</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="4-自定义ViewHolder"><a href="#4-自定义ViewHolder" class="headerlink" title="4.自定义ViewHolder"></a>4.自定义ViewHolder</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public <span class="hljs-keyword">class</span> NetViewHolder implements ViewHolder&lt;BannerData&gt; &#123;<br>    <span class="hljs-keyword">private</span> ImageView mImageView;<br>    <span class="hljs-keyword">private</span> TextView mTextView;<br><br>    @Override<br>    public View create<span class="hljs-constructor">View(ViewGroup <span class="hljs-params">viewGroup</span>, Context <span class="hljs-params">context</span>, <span class="hljs-params">int</span> <span class="hljs-params">position</span>)</span> &#123;<br>        View view = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">LayoutInflater</span>.</span></span>from(context).inflate(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">R</span>.</span></span>layout.item_net, viewGroup, <span class="hljs-literal">false</span>);<br>        mImageView = view.find<span class="hljs-constructor">ViewById(R.<span class="hljs-params">id</span>.<span class="hljs-params">banner_image</span>)</span>;<br>        mTextView = view.find<span class="hljs-constructor">ViewById(R.<span class="hljs-params">id</span>.<span class="hljs-params">tv_describe</span>)</span>;<br>        return view;<br>    &#125;<br><br>    @Override<br>    public void on<span class="hljs-constructor">Bind(Context <span class="hljs-params">context</span>, BannerData <span class="hljs-params">data</span>, <span class="hljs-params">int</span> <span class="hljs-params">position</span>, <span class="hljs-params">int</span> <span class="hljs-params">size</span>)</span> &#123;<br>        ImageLoaderOptions options = <span class="hljs-keyword">new</span> ImageLoaderOptions.<span class="hljs-constructor">Builder()</span>.into(mImageView).load(data.get<span class="hljs-constructor">ImagePath()</span>).place<span class="hljs-constructor">Holder(R.<span class="hljs-params">drawable</span>.<span class="hljs-params">placeholder</span>)</span>.build<span class="hljs-literal">()</span>;<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ImageLoaderManager</span>.</span></span>get<span class="hljs-constructor">Instance()</span>.load<span class="hljs-constructor">Image(<span class="hljs-params">options</span>)</span>;<br>        mTextView.set<span class="hljs-constructor">Text(<span class="hljs-params">data</span>.<span class="hljs-params">getTitle</span>()</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-BannerViewPager参数配置"><a href="#5-BannerViewPager参数配置" class="headerlink" title="5.BannerViewPager参数配置"></a>5.BannerViewPager参数配置</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs arduino">   <span class="hljs-keyword">private</span> BannerViewPager&lt;BannerData, NetViewHolder&gt; mBannerViewPager;<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initViewPager</span><span class="hljs-params">()</span> </span>&#123;<br>            mBannerViewPager = findViewById(R.id.banner_view);<br>            mBannerViewPager.showIndicator(<span class="hljs-literal">true</span>)<br>               .setInterval(<span class="hljs-number">3000</span>)<br>               .setCanLoop(<span class="hljs-literal">false</span>)<br>               .setAutoPlay(<span class="hljs-literal">true</span>)<br>               .setRoundCorner(DpUtils.dp2px(<span class="hljs-number">7</span>))<br>               .setIndicatorColor(Color.parseColor(<span class="hljs-string">&quot;#935656&quot;</span>), Color.parseColor(<span class="hljs-string">&quot;#FF4C39&quot;</span>))<br>               .setIndicatorGravity(BannerViewPager.END)<br>               .setScrollDuration(<span class="hljs-number">1000</span>).setHolderCreator(NetViewHolder::<span class="hljs-keyword">new</span>)<br>               .setOnPageClickListener(<span class="hljs-built_in">position</span> -&gt; &#123;<br>                   BannerData bannerData = mBannerViewPager.getList().<span class="hljs-built_in">get</span>(<span class="hljs-built_in">position</span>);<br>                   Toast.makeText(NetworkBannerActivity.<span class="hljs-keyword">this</span>,<br>                           <span class="hljs-string">&quot;点击了图片&quot;</span> + <span class="hljs-built_in">position</span> + <span class="hljs-string">&quot; &quot;</span> + bannerData.getDesc(), Toast.LENGTH_SHORT).show();<br><br>               &#125;).create(mList);<br>       &#125;<br></code></pre></td></tr></table></figure><h3 id="6-开启与停止轮播"><a href="#6-开启与停止轮播" class="headerlink" title="6.开启与停止轮播"></a>6.开启与停止轮播</h3><p><strong><em>2.5.0之后版本无需自行在Activity或Fragment中管理stopLoop和startLoop方法，但这两个方法依旧保留对外开发</em></strong></p><p><del>如果开启了自动轮播功能，请务必在onDestroy中停止轮播，以免出现内存泄漏。</del></p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">protected</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onDestroy</span><span class="hljs-params">()</span> </span>&#123;<br>       <span class="hljs-keyword">super</span>.onDestroy();<br>       <span class="hljs-keyword">if</span> (mBannerViewPager != <span class="hljs-keyword">null</span>)<br>   mViewpager.stopLoop();<br>   &#125;<br></code></pre></td></tr></table></figure><p><del>为了节省性能也可以在onStop中停止轮播，在onResume中开启轮播：</del></p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onStop</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">super</span>.onStop();<br>    <span class="hljs-keyword">if</span> (mBannerViewPager != <span class="hljs-keyword">null</span>)<br>        mBannerViewPager.stopLoop();<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onResume</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">super</span>.onResume();<br>    <span class="hljs-keyword">if</span> (mBannerViewPager != <span class="hljs-keyword">null</span>)<br>        mBannerViewPager.startLoop();<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="三、高级功能—自定义IndicatorView"><a href="#三、高级功能—自定义IndicatorView" class="headerlink" title="三、高级功能—自定义IndicatorView"></a>三、高级功能—自定义IndicatorView</h1><p>因为指示器的样式千变万化,BannerViewPager中不可能内置所有的样式，因此我将定义权限交给了开发者自己来实现，这样就可以满足所有开发者的需求了。但是自定义IndicatorView需要有一定的自定义View基础，尽管我已经在BaseIndicatorView中处理了许多逻辑，但是还是要开发者根据自身需求进行Indicator的绘制。好了，下面就让我们来看看如何实现自定义IndicatorView吧。</p><p>关于自定义IndicatorView其实我们在第一节中讲解Indicator摆放位置时已经提到了，就是通过setIndicator(IIndicator)来替换内部的指示器。当然，这个方法接收的参数不仅仅是内置的两个IndicatorView，它还可以是我们自己实现的Indicator。前提只需要继承BaseIndicatorView或者继承View并实现IIndicator，然后根据需求绘制即可。</p><h3 id="1-认识BaseIndicatorView"><a href="#1-认识BaseIndicatorView" class="headerlink" title="(1)认识BaseIndicatorView"></a>(1)认识BaseIndicatorView</h3><p>BaseIndicatorView是BannerViewPager库中的一个类，它继承自View并实现了IIndicator接口。在这个类中存储了BannerViewPager的许多参数信息，比如页面个数(pageSize)、页面滑动进度(slideProgress)以及当前页面位置(currentPosition)等，这些都是在绘制IndicatorView时会用到的信息。有了这些参数之后我们就可以比较轻松的去绘制指示器了。如果你觉得我这些数据计算的不够精确或者计算存在错误，那么你大可以自己实现IIndicator接口自行计算。本文我会通过继承BaseIndicatorView的方式来实现一个自定义指示器的例子。<br>你可以点击链接查看<a href="https://github.com/zhpanvip/BannerViewPager/blob/master/bannerview/src/main/java/com/zhpan/bannerview/indicator/BaseIndicatorView.java">BaseIndicatorView</a>的完整代码。</p><h3 id="2-开启自定义IndicatorView之路"><a href="#2-开启自定义IndicatorView之路" class="headerlink" title="(2)开启自定义IndicatorView之路"></a>(2)开启自定义IndicatorView之路</h3><p>好了，接下来我们就来完成一个如下图所示的自定义IndicatorView吧！</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMS8xNi8xNmU3NDdhMGJmZDc3MGE1?x-oss-process=image/format,png"></p><p><strong>新建一个FigureIndicatorView类并继承BaseIndicatorView</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public <span class="hljs-keyword">class</span> FigureIndicatorView extends BaseIndicatorView &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> radius = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">DpUtils</span>.</span></span>dp2px(<span class="hljs-number">20</span>);<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> backgroundColor = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Color</span>.</span></span>parse<span class="hljs-constructor">Color(<span class="hljs-string">&quot;#88FF5252&quot;</span>)</span>;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> textColor = Color.WHITE;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> textSize=<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">DpUtils</span>.</span></span>dp2px(<span class="hljs-number">13</span>);<br><br>    <span class="hljs-comment">// ...省略无关代码</span><br><br>    @Override<br>    protected void on<span class="hljs-constructor">Measure(<span class="hljs-params">int</span> <span class="hljs-params">widthMeasureSpec</span>, <span class="hljs-params">int</span> <span class="hljs-params">heightMeasureSpec</span>)</span> &#123;<br>        super.on<span class="hljs-constructor">Measure(<span class="hljs-params">widthMeasureSpec</span>, <span class="hljs-params">heightMeasureSpec</span>)</span>;<br>        set<span class="hljs-constructor">MeasuredDimension(2 <span class="hljs-operator">*</span> <span class="hljs-params">radius</span>, 2 <span class="hljs-operator">*</span> <span class="hljs-params">radius</span>)</span>;<br>    &#125;<br><br>    @Override<br>    protected void on<span class="hljs-constructor">Draw(Canvas <span class="hljs-params">canvas</span>)</span> &#123;<br>        super.on<span class="hljs-constructor">Draw(<span class="hljs-params">canvas</span>)</span>;<br>        mPaint.set<span class="hljs-constructor">Color(<span class="hljs-params">backgroundColor</span>)</span>;<br>        canvas.draw<span class="hljs-constructor">Circle(<span class="hljs-params">getWidth</span>()</span><span class="hljs-operator"> / </span><span class="hljs-number">2</span>, get<span class="hljs-constructor">Height()</span><span class="hljs-operator"> / </span><span class="hljs-number">2</span>, radius, mPaint);<br>        mPaint.set<span class="hljs-constructor">Color(<span class="hljs-params">textColor</span>)</span>;<br>        mPaint.set<span class="hljs-constructor">TextSize(<span class="hljs-params">textSize</span>)</span>;<br>        String text = currentPosition + <span class="hljs-number">1</span> + <span class="hljs-string">&quot;/&quot;</span> + pageSize;<br>        <span class="hljs-built_in">int</span> textWidth = (<span class="hljs-built_in">int</span>) mPaint.measure<span class="hljs-constructor">Text(<span class="hljs-params">text</span>)</span>;<br>        Paint.FontMetricsInt fontMetricsInt = mPaint.get<span class="hljs-constructor">FontMetricsInt()</span>;<br>        <span class="hljs-built_in">int</span> baseline = (get<span class="hljs-constructor">MeasuredHeight()</span> - fontMetricsInt.bottom + fontMetricsInt.top)<span class="hljs-operator"> / </span><span class="hljs-number">2</span> - fontMetricsInt.top;<br>        canvas.draw<span class="hljs-constructor">Text(<span class="hljs-params">text</span>, (<span class="hljs-params">getWidth</span>()</span> - textWidth)<span class="hljs-operator"> / </span><span class="hljs-number">2</span>, baseline, mPaint);<br>    &#125;<br><br>    public void set<span class="hljs-constructor">Radius(<span class="hljs-params">int</span> <span class="hljs-params">radius</span>)</span> &#123;<br>        this.radius = radius;<br>    &#125;<br><br>    @Override<br>    public void set<span class="hljs-constructor">BackgroundColor(@ColorInt <span class="hljs-params">int</span> <span class="hljs-params">backgroundColor</span>)</span> &#123;<br>        this.backgroundColor = backgroundColor;<br>    &#125;<br><br>    public void set<span class="hljs-constructor">TextSize(<span class="hljs-params">int</span> <span class="hljs-params">textSize</span>)</span> &#123;<br>        this.textSize = textSize;<br>    &#125;<br>    <span class="hljs-comment">// ...省略无关代码</span><br>&#125;<br></code></pre></td></tr></table></figure><p>有自定义View基础的同学应该能很轻松的看懂上边的代码。首先通过onMeasure()方法测量了View的大小，接下来就是在onDraw方法中绘制圆和文字了。很容易就实现了一个自定义的IndicatorView。当然，这个例子本身就比较简单。如果你需要绘制比较复杂且带有动画的Indicator，可以参考源码中的CircleIndicatorView和DashIndicatorView，或许它能给你一些灵感。</p><h3 id="3-设置自定义指示器"><a href="#3-设置自定义指示器" class="headerlink" title="(3)设置自定义指示器"></a>(3)设置自定义指示器</h3><p>接下来就将我们自己绘制的指示器设置到BannerViewPager中吧！</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">FigureIndicatorView indicatorView = <span class="hljs-keyword">new</span> <span class="hljs-constructor">FigureIndicatorView(<span class="hljs-params">mContext</span>)</span>;<br>indicatorView.set<span class="hljs-constructor">Radius(BannerUtils.<span class="hljs-params">dp2px</span>(18)</span>);<br>indicatorView.set<span class="hljs-constructor">TextSize(BannerUtils.<span class="hljs-params">dp2px</span>(13)</span>);<br>indicatorView.set<span class="hljs-constructor">BackgroundColor(Color.<span class="hljs-params">parseColor</span>(<span class="hljs-string">&quot;#aa118EEA&quot;</span>)</span>);<br><br>mViewPager.set<span class="hljs-constructor">IndicatorGravity(IndicatorGravity.END)</span><br>          .set<span class="hljs-constructor">IndicatorView(<span class="hljs-params">indicatorView</span>)</span><br>          .set<span class="hljs-constructor">HolderCreator(()</span> -&gt; <span class="hljs-keyword">new</span> <span class="hljs-constructor">ImageResourceViewHolder(0)</span>)<br>          .create(mDrawableList);    <br>    <br></code></pre></td></tr></table></figure><p>依然如此潇洒自然！好了，关于BannerViewPager的介绍今天就讲解到这里了。接下来的一篇文章将会对BannerViewPager的源码进行剖析，了解下它是如何通过简单的Api实现来实现复杂的功能的。</p><p>都看到这里了，确定不到GitHub点个星再走？源码已放到文章末尾。如果有好的Idea也欢迎Pull Request。</p><p><a href="https://juejin.im/post/5d74d3faf265da03b5747015">《BannerViewPager源码解析》</a></p><p><a href="https://github.com/zhpanvip/BannerViewPager">源码下载</a></p><p><strong>文章上次更新2019.11.16</strong></p>]]></content>
    
    
    <categories>
      
      <category>自定义View</category>
      
    </categories>
    
    
    <tags>
      
      <tag>自定义View</tag>
      
      <tag>BVP</tag>
      
      <tag>ViewPager2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>手撕黄油刀--探究ButterKnife的实现原理</title>
    <link href="/2019/08/26/19.butterknife%20source%20code%20analysis/"/>
    <url>/2019/08/26/19.butterknife%20source%20code%20analysis/</url>
    
    <content type="html"><![CDATA[<p>上篇文章《Java编译时注解处理器（APT）详解》中学习了Java APT技术在Android中的使用，并且我们知道，当前Android开发中常用的许多框架都使用了APT技术，并且ButterKnife就是利用APT来实现的。那么本篇内容我们就来探究一下ButterKnife的实现原理。</p><h1 id="一、ButterKnife的bind过程"><a href="#一、ButterKnife的bind过程" class="headerlink" title="一、ButterKnife的bind过程"></a>一、ButterKnife的bind过程</h1><p>当然，在探究源码，还是首先应该了解如何使用，我们以ButterKnife的BindView为例。首先在Activity的onCreate方法中通过ButterKnife.bind()方法绑定，然后为TextView添加BindView注解即可拿到TextView的实例。代码如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">package</span> com.zhpan.app;<br><br>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AppCompatActivity</span> </span>&#123;<br> <span class="hljs-meta">@BindView</span>(<span class="hljs-type">R</span>.id.text_view)<br> <span class="hljs-type">TextView</span> mTextView;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> void onCreate(<span class="hljs-type">Bundle</span> savedInstanceState) &#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState);<br>        setContentView(<span class="hljs-type">R</span>.layout.activity_main);<br>        <span class="hljs-type">ButterKnife</span>.bind(<span class="hljs-keyword">this</span>);<br>    &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>ButterKnife是怎么做到通过注解获取TextView的实例的呢？我们就从bind方法开始吧，点击ButterKnife的bind方法，其代码如下：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-comment">//ButterKnife中有很多bind的重载方法，仅以此为例</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-function">Unbinder <span class="hljs-title">bind</span><span class="hljs-params">(@NonNull Activity <span class="hljs-keyword">target</span>)</span> </span>&#123;<br>    View sourceView = <span class="hljs-keyword">target</span>.getWindow().getDecorView();<br>    <span class="hljs-function"><span class="hljs-keyword">return</span> <span class="hljs-title">createBinding</span><span class="hljs-params">(<span class="hljs-keyword">target</span>, sourceView)</span></span>;<br>  &#125;<br></code></pre></td></tr></table></figure><p>可以看到在bind方法中通过Activity拿到了DecorView（至于不懂DecorView是什么的同学可以自行Google）。然后调用了createBinding方法，并传入Activity对象和DecorView两个参数。我们追踪createBinding的代码如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Unbinder createBinding(<span class="hljs-meta">@NonNull</span> <span class="hljs-built_in">Object</span> target, <span class="hljs-meta">@NonNull</span> View source) &#123;<br>    Class&lt;?&gt; targetClass = target.getClass();<br>    <span class="hljs-comment">//获取到了与target相关的类的构造方法</span><br>    Constructor&lt;? <span class="hljs-keyword">extends</span> Unbinder&gt; <span class="hljs-keyword">constructor</span> = findBindingConstructorForClass(<span class="hljs-params">targetClass</span>);<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">constructor</span> == null) &#123;<br>      <span class="hljs-keyword">return</span> Unbinder.EMPTY;<br>    &#125;<br><br>    <span class="hljs-comment">//noinspection TryWithIdenticalCatches Resolves to API 19+ only type.</span><br>    <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">//通过构造方法反射实例化了这个类，这个类接收两个参数，分别是上边的Activity和DecorView</span><br>      <span class="hljs-keyword">return</span> constructor.newInstance(target, source);<br>    &#125; <span class="hljs-keyword">catch</span> (IllegalAccessException e) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;Unable to invoke &quot;</span> + <span class="hljs-keyword">constructor</span>, e);<br>    &#125; <span class="hljs-keyword">catch</span> (InstantiationException e) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;Unable to invoke &quot;</span> + <span class="hljs-keyword">constructor</span>, e);<br>    &#125; <span class="hljs-keyword">catch</span> (InvocationTargetException e) &#123;<br>      Throwable cause = e.getCause();<br>      <span class="hljs-keyword">if</span> (cause <span class="hljs-keyword">instanceof</span> RuntimeException) &#123;<br>        <span class="hljs-keyword">throw</span> (RuntimeException) cause;<br>      &#125;<br>      <span class="hljs-keyword">if</span> (cause <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Error</span>) &#123;<br>        <span class="hljs-keyword">throw</span> (<span class="hljs-built_in">Error</span>) cause;<br>      &#125;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;Unable to create binding instance.&quot;</span>, cause);<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><p>上述代码中通过findBindingConstructorForClass()方法得到了某个类的构造方法，并在接下来的代码中通过反射 constructor.newInstance(target, source)实例化了这个类，我们点进findBindingConstructorForClass()方法看这里做了什么。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">private</span> static Constructor&lt;? extends Unbinder&gt; find<span class="hljs-constructor">BindingConstructorForClass(Class&lt;?&gt; <span class="hljs-params">cls</span>)</span> &#123;<br><span class="hljs-comment">//从BINDINGS中获取cls对应的Unbinder</span><br>    Constructor&lt;? extends Unbinder&gt; bindingCtor = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">BINDINGS</span>.</span></span>get(cls);<br>    <span class="hljs-keyword">if</span> (bindingCtor != null) &#123; 如果已存在直接return<br>      <span class="hljs-keyword">if</span> (debug) <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Log</span>.</span></span>d(TAG, <span class="hljs-string">&quot;HIT: Cached in binding map.&quot;</span>);<br>      return bindingCtor;<br>    &#125;<br>    <span class="hljs-comment">//这里拿到的clsName应该为“com.zhpan.app.MainActivity”</span><br>    String clsName = cls.get<span class="hljs-constructor">Name()</span>;<br>    <span class="hljs-keyword">if</span> (clsName.starts<span class="hljs-constructor">With(<span class="hljs-string">&quot;android.&quot;</span>)</span><span class="hljs-operator"> || </span>clsName.starts<span class="hljs-constructor">With(<span class="hljs-string">&quot;java.&quot;</span>)</span>) &#123;<br>      <span class="hljs-keyword">if</span> (debug) <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Log</span>.</span></span>d(TAG, <span class="hljs-string">&quot;MISS: Reached framework class. Abandoning search.&quot;</span>);<br>      return null;<br>    &#125;<br>    <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">//从类加载器中获取“com.zhpan.app.MainActivity_ViewBinding”</span><br>      Class&lt;?&gt; bindingClass = cls.get<span class="hljs-constructor">ClassLoader()</span>.load<span class="hljs-constructor">Class(<span class="hljs-params">clsName</span> + <span class="hljs-string">&quot;_ViewBinding&quot;</span>)</span>;<br>      <span class="hljs-comment">// 获取“com.zhpan.app.MainActivity_ViewBinding”类中的构造方法</span><br>      bindingCtor = (Constructor&lt;? extends Unbinder&gt;) bindingClass.get<span class="hljs-constructor">Constructor(<span class="hljs-params">cls</span>, View.<span class="hljs-params">class</span>)</span>;<br>    &#125; catch (ClassNotFoundException e) &#123;<br>      <span class="hljs-keyword">if</span> (debug) <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Log</span>.</span></span>d(TAG, <span class="hljs-string">&quot;Not found. Trying superclass &quot;</span> + cls.get<span class="hljs-constructor">Superclass()</span>.get<span class="hljs-constructor">Name()</span>);<br>      bindingCtor = find<span class="hljs-constructor">BindingConstructorForClass(<span class="hljs-params">cls</span>.<span class="hljs-params">getSuperclass</span>()</span>);<br>    &#125; catch (NoSuchMethodException e) &#123;<br>      throw <span class="hljs-keyword">new</span> <span class="hljs-constructor">RuntimeException(<span class="hljs-string">&quot;Unable to find binding constructor for &quot;</span> + <span class="hljs-params">clsName</span>, <span class="hljs-params">e</span>)</span>;<br>    &#125;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">BINDINGS</span>.</span></span>put(cls, bindingCtor);<br>    return bindingCtor;<br>  &#125;<br></code></pre></td></tr></table></figure><p>直接看第7行，通过 cls.getName()得到了bind方法中参数的名字，由于我们是再MainActivity中调用的bind方法，因此，这里拿到的名字就是“com.zhpan.app.MainActivity”,接下来再第13行中通过ClassLoader拿到了一个名字是”clsName”+”_ViewBinding”的类，也就是名字为MainActivity_ViewBinding的类。我们在项目里搜索一下，发现果真能找到这个类，其代码如下：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">package</span> com.zhpan.app;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainActivity_ViewBinding</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Unbinder</span> </span>&#123;<br>  <span class="hljs-keyword">private</span> MainActivity <span class="hljs-keyword">target</span>;<br><br>  <span class="hljs-meta">@UiThread</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MainActivity_ViewBinding</span><span class="hljs-params">(MainActivity <span class="hljs-keyword">target</span>)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>(<span class="hljs-keyword">target</span>, <span class="hljs-keyword">target</span>.getWindow().getDecorView());<br>  &#125;<br><br>  <span class="hljs-meta">@UiThread</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MainActivity_ViewBinding</span><span class="hljs-params">(MainActivity <span class="hljs-keyword">target</span>, View source)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.<span class="hljs-keyword">target</span> = <span class="hljs-keyword">target</span>;<br><br>    <span class="hljs-keyword">target</span>.mTextView = Utils.findRequiredViewAsType(source, R.id.text_view, <span class="hljs-string">&quot;field &#x27;mTextView&#x27;&quot;</span>, TextView.class);<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-meta">@CallSuper</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">unbind</span><span class="hljs-params">()</span> </span>&#123;<br>    MainActivity <span class="hljs-keyword">target</span> = <span class="hljs-keyword">this</span>.<span class="hljs-keyword">target</span>;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">target</span> == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">&quot;Bindings already cleare![在这里插入图片描述](https://img-blog.csdnimg.cn/20190825162306549.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwNTIxNTcz,size_16,color_FFFFFF,t_70)d.&quot;</span>);<br>    <span class="hljs-keyword">this</span>.<span class="hljs-keyword">target</span> = <span class="hljs-keyword">null</span>;<br><br>    <span class="hljs-keyword">target</span>.mTextView = <span class="hljs-keyword">null</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个类的构造方法中我们可以看到</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">target.mTextView = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Utils</span>.</span></span>find<span class="hljs-constructor">RequiredViewAsType(<span class="hljs-params">source</span>, R.<span class="hljs-params">id</span>.<span class="hljs-params">text_view</span>, <span class="hljs-string">&quot;field &#x27;mTextView&#x27;&quot;</span>, TextView.<span class="hljs-params">class</span>)</span>;<br></code></pre></td></tr></table></figure><p>通过这句代码给Activity中的mTextView赋了值，到这里也就不奇怪为什通过一个BindView的注解就得到了mTextView的对象了。而MainActivity_ViewBinding这个类是从哪里来的呢？想必看过上篇文章同学应该都知道了，就是通过APT在代码编译期间自动生成的。其实后面的代码其实已经没有必要去看了，无非就是通过AbstractProcessor来处理注解，然后根据注解自动生成所需代码的。但是写文章要有始有终，也本着负责任的态度，还是深入ButtereKnife内部一探究竟。</p><h1 id="二、探究ButterKnife的注解处理器ButterKnifeProcessor"><a href="#二、探究ButterKnife的注解处理器ButterKnifeProcessor" class="headerlink" title="二、探究ButterKnife的注解处理器ButterKnifeProcessor"></a>二、探究ButterKnife的注解处理器ButterKnifeProcessor</h1><p>现在我们来看一下ButterKnife的代码的模块结构：</p><p><img src="https://img-blog.csdnimg.cn/20190825162330432.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwNTIxNTcz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>看到butterknife-annotations和butterknife-compiler很眼熟？和上篇文章我们自己写的代码结构是一样的，butterknife-annotations模块下存放的是butterknife的所有注解，butterknife-compiler是用来处理butterknife-annotations注解的。所以们直接看butterknife-compiler模块下的ButterKnifeProcessor类。</p><h2 id="1-ButterKnifeProcessor的getSupportedAnnotationTypes-方法"><a href="#1-ButterKnifeProcessor的getSupportedAnnotationTypes-方法" class="headerlink" title="1.ButterKnifeProcessor的getSupportedAnnotationTypes()方法"></a>1.ButterKnifeProcessor的getSupportedAnnotationTypes()方法</h2><p>我们知道ButterKnife除了BindView注解之外还有许多其它注解，比如常用的BindColor注解、OnClick注解等。这些注解的名字都会被添加到getSupportedAnnotationTypes方法中的Set集合里。来看getSupportedAnnotationTypes的源码：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs crystal">@Override public Set&lt;String&gt; getSupportedAnnotationTypes() &#123;<br>    Set&lt;String&gt; types = new LinkedHashSet&lt;&gt;();<br>    /<span class="hljs-regexp">/遍历ButterKnife中的所有注解，并将注解名字添加到Set集合</span><br><span class="hljs-regexp">    for (Class&lt;? extends Annotation&gt; annotation : getSupportedAnnotations()) &#123;</span><br><span class="hljs-regexp">      types.add(annotation.getCanonicalName());</span><br><span class="hljs-regexp">    &#125;</span><br><span class="hljs-regexp">    return types;</span><br><span class="hljs-regexp">  &#125;</span><br></code></pre></td></tr></table></figure><h2 id="2-ButterKnifeProcessor的process方法"><a href="#2-ButterKnifeProcessor的process方法" class="headerlink" title="2.ButterKnifeProcessor的process方法"></a>2.ButterKnifeProcessor的process方法</h2><p>我们知道process方法是整个注解处理其的核心方法，对注解的处理以及代码的生成都是在这个方法里边实现的。那么接下来，就一步步看ButterKnife是怎么处理注解和生成代码的。<br>**(1)解析RoundEnviroment**<br>在process方法的第一行我们看到通过findAndParseTargets方法得到了一个 Map&lt;TypeElement, BindingSet&gt;集合，代码如下：</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> process(<span class="hljs-built_in">Set</span>&lt;? extends TypeElement&gt; elements, RoundEnvironment env) &#123;<br>    <span class="hljs-comment">//通过findAndParseTargets处理注解得到BindingSet的集合</span><br>    <span class="hljs-built_in">Map</span>&lt;TypeElement, BindingSet&gt; bindingMap = findAndParseTargets(env);<br>    <br>     <span class="hljs-params">...</span><br>  <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br></code></pre></td></tr></table></figure><p>而在findAndParseTargets(env)是对一系列注解的处理，这里我们仅以处理BindView为例：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">private</span> Map&lt;TypeElement, BindingSet&gt; find<span class="hljs-constructor">AndParseTargets(RoundEnvironment <span class="hljs-params">env</span>)</span> &#123;<br>    Map&lt;TypeElement, BindingSet.Builder&gt; builderMap = <span class="hljs-keyword">new</span> LinkedHashMap&lt;&gt;<span class="hljs-literal">()</span>;<br>    Set&lt;TypeElement&gt; erasedTargetNames = <span class="hljs-keyword">new</span> LinkedHashSet&lt;&gt;<span class="hljs-literal">()</span>;<br><br>    <span class="hljs-keyword">for</span> (Element element : env.get<span class="hljs-constructor">ElementsAnnotatedWith(BindView.<span class="hljs-params">class</span>)</span>) &#123;<br>      <span class="hljs-keyword">try</span> &#123;<br>        parse<span class="hljs-constructor">BindView(<span class="hljs-params">element</span>, <span class="hljs-params">builderMap</span>, <span class="hljs-params">erasedTargetNames</span>)</span>;<br>      &#125; catch (Exception e) &#123;<br>        log<span class="hljs-constructor">ParsingError(<span class="hljs-params">element</span>, BindView.<span class="hljs-params">class</span>, <span class="hljs-params">e</span>)</span>;<br>      &#125;<br>    &#125;<br><br><span class="hljs-comment">//省略处理其它注解的代码</span><br>...<br><br><br></code></pre></td></tr></table></figure><p>第9行在parseBindView方法中对BindView注解进行了一系列的校验，通过校验后解析BindView的数据，比如view的Id等信息封装到了BindingSet.Builder中,并最终将封装好的BindingSet.Builder放入builderMap 中。由于parseBindView方法的代码比较多，这里就不再贴出了，有兴趣的可以直接下载源码查看。<br>接下来得到builderMap的集合之后，由于findAndParseTargets方法返回值是Map&lt;TypeElement, BindingSet&gt;，因此接下来又对builderMap集合进行了遍历并最终存储到了 Map&lt;TypeElement, BindingSet&gt;中。代码如下：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">private</span> Map&lt;TypeElement, BindingSet&gt; find<span class="hljs-constructor">AndParseTargets(RoundEnvironment <span class="hljs-params">env</span>)</span> &#123;<br><br>...<br><br>Deque&lt;Map.Entry&lt;TypeElement, BindingSet.Builder&gt;&gt; entries =<br>        <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;(builderMap.entry<span class="hljs-constructor">Set()</span>);<br>    Map&lt;TypeElement, BindingSet&gt; bindingMap = <span class="hljs-keyword">new</span> LinkedHashMap&lt;&gt;<span class="hljs-literal">()</span>;<br>    <span class="hljs-keyword">while</span> (!entries.is<span class="hljs-constructor">Empty()</span>) &#123;<br>      Map.Entry&lt;TypeElement, BindingSet.Builder&gt; entry = entries.remove<span class="hljs-constructor">First()</span>;<br><br>      TypeElement <span class="hljs-keyword">type</span> = entry.get<span class="hljs-constructor">Key()</span>;<br>      BindingSet.Builder builder = entry.get<span class="hljs-constructor">Value()</span>;<br><br>      TypeElement parentType = find<span class="hljs-constructor">ParentType(<span class="hljs-params">type</span>, <span class="hljs-params">erasedTargetNames</span>)</span>;<br>      <span class="hljs-keyword">if</span> (parentType<span class="hljs-operator"> == </span>null) &#123;<br>        bindingMap.put(<span class="hljs-keyword">type</span>, builder.build<span class="hljs-literal">()</span>);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        BindingSet parentBinding = bindingMap.get(parentType);<br>        <span class="hljs-keyword">if</span> (parentBinding != null) &#123;<br>          builder.set<span class="hljs-constructor">Parent(<span class="hljs-params">parentBinding</span>)</span>;<br>          bindingMap.put(<span class="hljs-keyword">type</span>, builder.build<span class="hljs-literal">()</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-comment">// Has a superclass binding but we haven&#x27;t built it yet. Re-enqueue for later.</span><br>          entries.add<span class="hljs-constructor">Last(<span class="hljs-params">entry</span>)</span>;<br>        &#125;<br>      &#125;<br>    &#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>好了，接下来，继续到process方法中，在拿到bindingMap 之后遍历bindingMap ，并调用BindingSet的brewJava来生成Java文件，代码如下：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public boolean process(Set&lt;? extends TypeElement&gt; elements, RoundEnvironment env) &#123;<br>    Map&lt;TypeElement, BindingSet&gt; bindingMap = find<span class="hljs-constructor">AndParseTargets(<span class="hljs-params">env</span>)</span>;<br><br>    <span class="hljs-keyword">for</span> (Map.Entry&lt;TypeElement, BindingSet&gt; entry : bindingMap.entry<span class="hljs-constructor">Set()</span>) &#123;<br>      TypeElement typeElement = entry.get<span class="hljs-constructor">Key()</span>;<br>      BindingSet binding = entry.get<span class="hljs-constructor">Value()</span>;<br><br>      JavaFile javaFile = binding.brew<span class="hljs-constructor">Java(<span class="hljs-params">sdk</span>, <span class="hljs-params">debuggable</span>, <span class="hljs-params">useAndroidX</span>)</span>;<br>      <span class="hljs-keyword">try</span> &#123;<br>        javaFile.write<span class="hljs-constructor">To(<span class="hljs-params">filer</span>)</span>;<br>      &#125; catch (IOException e) &#123;<br>        error(typeElement, <span class="hljs-string">&quot;Unable to write binding for type %s: %s&quot;</span>, typeElement, e.get<span class="hljs-constructor">Message()</span>);<br>      &#125;<br>    &#125;<br><br>    return <span class="hljs-literal">false</span>;<br>  &#125;<br></code></pre></td></tr></table></figure><h2 id="3-JavaPoet生成代码"><a href="#3-JavaPoet生成代码" class="headerlink" title="3.JavaPoet生成代码"></a>3.JavaPoet生成代码</h2><p>BindingSet 的brewJava方法中同样是使用了JavaPoet来生成代码的，无非就是拼接类，构造方法、方法，这些感觉真的没什么说的了。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">JavaFile brew<span class="hljs-constructor">Java(<span class="hljs-params">int</span> <span class="hljs-params">sdk</span>, <span class="hljs-params">boolean</span> <span class="hljs-params">debuggable</span>, <span class="hljs-params">boolean</span> <span class="hljs-params">useAndroidX</span>)</span> &#123;<br>    TypeSpec bindingConfiguration = create<span class="hljs-constructor">Type(<span class="hljs-params">sdk</span>, <span class="hljs-params">debuggable</span>, <span class="hljs-params">useAndroidX</span>)</span>;<br>    return <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">JavaFile</span>.</span></span>builder(bindingClassName.package<span class="hljs-constructor">Name()</span>, bindingConfiguration)<br>        .add<span class="hljs-constructor">FileComment(<span class="hljs-string">&quot;Generated code from Butter Knife. Do not modify!&quot;</span>)</span><br>        .build<span class="hljs-literal">()</span>;<br>  &#125;<br></code></pre></td></tr></table></figure><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">private</span> TypeSpec create<span class="hljs-constructor">Type(<span class="hljs-params">int</span> <span class="hljs-params">sdk</span>, <span class="hljs-params">boolean</span> <span class="hljs-params">debuggable</span>, <span class="hljs-params">boolean</span> <span class="hljs-params">useAndroidX</span>)</span> &#123;<br>    TypeSpec.Builder result = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">TypeSpec</span>.</span></span><span class="hljs-keyword">class</span><span class="hljs-constructor">Builder(<span class="hljs-params">bindingClassName</span>.<span class="hljs-params">simpleName</span>()</span>)<br>        .add<span class="hljs-constructor">Modifiers(PUBLIC)</span>;<br>    <span class="hljs-keyword">if</span> (isFinal) &#123;<br>      result.add<span class="hljs-constructor">Modifiers(FINAL)</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (parentBinding != null) &#123;<br>      result.superclass(parentBinding.bindingClassName);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      result.add<span class="hljs-constructor">Superinterface(UNBINDER)</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (has<span class="hljs-constructor">TargetField()</span>) &#123;<br>      result.add<span class="hljs-constructor">Field(<span class="hljs-params">targetTypeName</span>, <span class="hljs-string">&quot;target&quot;</span>, PRIVATE)</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (isView) &#123;<br>      result.add<span class="hljs-constructor">Method(<span class="hljs-params">createBindingConstructorForView</span>(<span class="hljs-params">useAndroidX</span>)</span>);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isActivity) &#123;<br>      result.add<span class="hljs-constructor">Method(<span class="hljs-params">createBindingConstructorForActivity</span>(<span class="hljs-params">useAndroidX</span>)</span>);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isDialog) &#123;<br>      result.add<span class="hljs-constructor">Method(<span class="hljs-params">createBindingConstructorForDialog</span>(<span class="hljs-params">useAndroidX</span>)</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!constructor<span class="hljs-constructor">NeedsView()</span>) &#123;<br>      <span class="hljs-comment">// Add a delegating constructor with a target type + view signature for reflective use.</span><br>      result.add<span class="hljs-constructor">Method(<span class="hljs-params">createBindingViewDelegateConstructor</span>(<span class="hljs-params">useAndroidX</span>)</span>);<br>    &#125;<br>    result.add<span class="hljs-constructor">Method(<span class="hljs-params">createBindingConstructor</span>(<span class="hljs-params">sdk</span>, <span class="hljs-params">debuggable</span>, <span class="hljs-params">useAndroidX</span>)</span>);<br><br>    <span class="hljs-keyword">if</span> (has<span class="hljs-constructor">ViewBindings()</span><span class="hljs-operator"> || </span>parentBinding<span class="hljs-operator"> == </span>null) &#123;<br>      result.add<span class="hljs-constructor">Method(<span class="hljs-params">createBindingUnbindMethod</span>(<span class="hljs-params">result</span>, <span class="hljs-params">useAndroidX</span>)</span>);<br>    &#125;<br><br>    return result.build<span class="hljs-literal">()</span>;<br>  &#125;<br></code></pre></td></tr></table></figure><p>关于ButterKnife的源码就说这么多吧。总结一下，其实就是根据注解使用APT及JavaPoet在项目编译期间自动生成代码，并达到为注解元素赋值或者添加监听的目的。在阅读Butterknife时候不一定要把每一句代码都搞懂，能做到掌握其核心原理便可。</p>]]></content>
    
    
    <categories>
      
      <category>源码分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>源码分析</tag>
      
      <tag>APT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>编译时注解处理器</title>
    <link href="/2018/09/10/18.java%20apt/"/>
    <url>/2018/09/10/18.java%20apt/</url>
    
    <content type="html"><![CDATA[<p>上篇文章我们使用注解+反射实现了一个仿ButterKnife功能的示例。考虑到反射是在运行时完成的，多少会影响程序性能。因此，ButterKnife本身并非基于注解+反射来实现的，而是用APT技术在编译时处理的。APT什么呢？接下来一起来看。</p><h2 id="一、APT简介"><a href="#一、APT简介" class="headerlink" title="一、APT简介"></a>一、APT简介</h2><p><strong>1.什么是APT？</strong><br>APT即为Annotation Processing Tool，它是javac的一个工具，中文意思为编译时注解处理器。APT可以用来在编译时扫描和处理注解。通过APT可以获取到注解和被注解对象的相关信息，在拿到这些信息后我们可以根据需求来自动的生成一些代码，省去了手动编写。注意，获取注解及生成代码都是在代码编译时候完成的，相比反射在运行时处理注解大大提高了程序性能。APT的核心是AbstractProcessor类，关于AbstractProcessor类后面会做详细说明。<br><strong>2.哪里用到了APT？</strong><br>APT技术被广泛的运用在Java框架中，包括Android项以及Java后台项目，除了上面我们提到的ButterKnife之外，像EventBus 、Dagger2以及阿里的ARouter路由框架等都运用到APT技术，因此要想了解以、探究这些第三方框架的实现原理，APT就是我们必须要掌握的。</p><p><strong>3.如何在Android Studio中构建一个APT项目?</strong><br>APT项目需要由至少两个Java Library模块组成，不知道什么是Java Library？没关系，手把手来叫你如何创建一个Java Library。<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS84LzI0LzE2Y2JmZWU0YTM2ZjI1ZWU?x-oss-process=image/format,png" alt="在这里插入图片描述"><br>首先，新建一个Android项目，然后File–&gt;New–&gt;New Module,打开如上图所示的面板，选择Java Library即可。刚才说到一个APT项目至少应该由两个Java Library模块。那么这两个模块分别是什么作用呢？<br>1.首先需要一个Annotation模块，这个用来存放自定义的注解。<br>2. 另外需要一个Compiler模块，这个模块依赖Annotation模块。<br>3.项目的App模块和其它的业务模块都需要依赖Annotation模块，同时需要通过annotationProcessor依赖Compiler模块。<br>app模块的gradle中依赖关系如下：</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">implementation</span> <span class="hljs-function"><span class="hljs-title">project</span>(<span class="hljs-string">&#x27;:annotation&#x27;</span>)</span><br><span class="hljs-variable">annotationProcessor</span> <span class="hljs-function"><span class="hljs-title">project</span>(<span class="hljs-string">&#x27;:factory-compiler&#x27;</span>)</span><br></code></pre></td></tr></table></figure><p>APT项目的模块的结构图如下所示：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS84LzI0LzE2Y2JmZWU0YTM3YjU1Yjc?x-oss-process=image/format,png" alt="在这里插入图片描述"></p><blockquote><p>为什么要强调上述两个模块一定要是Java Library？如果创建Android Library模块你会发现不能找到AbstractProcessor这个类，这是因为Android平台是基于OpenJDK的，而OpenJDK中不包含APT的相关代码。因此，在使用APT时，必须在Java Library中进行。</p></blockquote><h2 id="二、从一个例子开始认识APT"><a href="#二、从一个例子开始认识APT" class="headerlink" title="二、从一个例子开始认识APT"></a>二、从一个例子开始认识APT</h2><p>在学习Java基础的时候想必大家都写过简单工厂模式的例子，回想一下什么是简单工厂模式。接下来引入一个工厂模式的例子，首先定义一个形状的接口IShape，并为其添加 draw()方法：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">public<span class="hljs-built_in"> interface </span>IShape &#123;<br>void draw();<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来定义几个形状实现IShape接口,并重写draw()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rectangle</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IShape</span> </span>&#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> </span>&#123;<br>System.out.println(<span class="hljs-string">&quot;Draw a Rectangle&quot;</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Triangle</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IShape</span> </span>&#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> </span>&#123;<br>System.out.println(<span class="hljs-string">&quot;Draw a Triangle&quot;</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Circle</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IShape</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Draw a circle&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来我们需要一个工厂类，这个类接收一个参数，根据我们传入的参数创建出对应的形状，代码如下：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShapeFactory</span> </span>&#123;<br>  <span class="hljs-keyword">public</span> Shape create(<span class="hljs-keyword">String</span> id) &#123;<br>    <span class="hljs-keyword">if</span> (id == <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">IllegalArgumentException</span>(<span class="hljs-string">&quot;id is null!&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;Circle&quot;</span>.equals(id)) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-type">Circle</span>();<br>    &#125;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;Rectangle&quot;</span>.equals(id)) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-type">Rectangle</span>();<br>    &#125;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;Triangle&quot;</span>.equals(id)) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-type">Triangle</span>();<br>    &#125;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">IllegalArgumentException</span>(<span class="hljs-string">&quot;Unknown id = &quot;</span> + id);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上就是一个简单工厂模式的示例代码，想必大家都能够理解。</p><p>那么，现在问题来了，在项目开发过程中，我们随时可能会添加一个新的形状。此时就不得不修改工厂类来适配新添加的形状了。试想一下，每添加一个形状类都需要我们手动去更新Factory类，是不是影响了我们的开发效率？如果这个Factory类能够根据我们添加新的形状来同步更新Factory代码，岂不是就省了我们很多时间了吗？</p><p>应该怎么做才能满足上述需求呢？在第一节中已经提到了使用APT可以帮助我们自动生成代码。那么这个工厂类是不是可以使用APT技术来自动生成呢？我们唯一要做的事情就是新添加的形状类上加上一个注解，注解处理器就会在编译时根据注解信息自动生成ShapeFactory类的代码了，美哉，美哉！理想很丰满，但是，现实很骨感。虽然已经明确了要做什么，但是想要注解处理器帮我们生成代码，却还有很长的路要走。不过，不当紧，接下来我们将一步步实现注解处理器并让其自动生成Factory类。</p><h2 id="三、使用APT处理注解"><a href="#三、使用APT处理注解" class="headerlink" title="三、使用APT处理注解"></a>三、使用APT处理注解</h2><p><strong>1.定义Factory注解</strong><br>首先在annotation模块下添加一个Factory的注解，Factory注解的Target为ElementType，表示它可以注解类、接口或者枚举。Retention指定为RetentionPolicy.CLASS，表示该在字节码中有效。Factory注解添加两个成员，一个Class类型的type，用来表示注解的类的类型，相同的类型表示属于同一个工厂。令需一个String类型的id,用来表示注解的类的名称。Factory注解代码如下：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Target</span>(ElementType.TYPE)<br><span class="hljs-variable">@Retention</span>(RetentionPolicy.CLASS)<br>public <span class="hljs-variable">@interface</span> Factory &#123;<br><br>    <span class="hljs-selector-tag">Class</span> <span class="hljs-selector-tag">type</span>();<br><br>    <span class="hljs-selector-tag">String</span> <span class="hljs-selector-tag">id</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来我们用@Factory去注解形状类，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Factory(id = &quot;Rectangle&quot;, type = IShape.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rectangle</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IShape</span> </span>&#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> </span>&#123;<br>System.out.println(<span class="hljs-string">&quot;Draw a Rectangle&quot;</span>);<br>&#125;<br>&#125;<br>... 其他形状类代码类似不再贴出<br></code></pre></td></tr></table></figure><p>**2.认识AbstractProcessor **</p><p>接下来，就到了我们本篇文章所要讲的核心了。没错，就是AbstractProcessor！我们先在factory-compiler模块下创建一个FactoryProcessor类继承AbstractProcessor ，并重写相应的方法，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@AutoService(Processor.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FactoryProcessor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractProcessor</span> </span>&#123;<br>  <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(ProcessingEnvironment processingEnvironment)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.init(processingEnvironment);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Set&lt;String&gt; <span class="hljs-title">getSupportedAnnotationTypes</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.getSupportedAnnotationTypes();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">process</span><span class="hljs-params">(Set&lt;? extends TypeElement&gt; set, RoundEnvironment roundEnvironment)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> SourceVersion <span class="hljs-title">getSupportedSourceVersion</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.getSupportedSourceVersion();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，在这个类上添加了@AutoService注解，它的作用是用来生成META-INF/services/javax.annotation.processing.Processor文件的，也就是我们在使用注解处理器的时候需要手动添加META-INF/services/javax.annotation.processing.Processor，而有了@AutoService后它会自动帮我们生成。<a href="https://github.com/google/auto/tree/master/service">AutoService</a>是Google开发的一个库，使用时需要在factory-compiler中添加依赖，如下：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">implementation</span> &#x27;com.google.auto.service:auto-service:<span class="hljs-number">1</span>.<span class="hljs-number">0</span>-rc<span class="hljs-number">4</span>&#x27;<br></code></pre></td></tr></table></figure><p>接下来我们将目光移到FactoryProcessor类内部，可以看到在这个类中重写了四个方法，我们由易到难依次来看：<br>**<em>(1) public SourceVersion getSupportedSourceVersion()**</em><br>这个方法非常简单，只有一个返回值，用来指定当前正在使用的Java版本，通常return SourceVersion.latestSupported()即可。</p><p> <strong><em>(2) public Set&lt;String&gt; getSupportedAnnotationTypes()</em></strong><br> 这个方法的返回值是一个Set集合，集合中指要处理的注解类型的名称(这里必须是完整的包名+类名，例如com.example.annotation.Factory)。由于在本例中只需要处理@Factory注解，因此Set集合中只需要添加@Factory的名称即可。</p><p> <strong><em>(3) public synchronized void init(ProcessingEnvironment processingEnvironment)</em></strong><br>这个方法用于初始化处理器，方法中有一个ProcessingEnvironment类型的参数，ProcessingEnvironment是一个注解处理工具的集合。它包含了众多工具类。例如：<br>Filer可以用来编写新文件；<br>Messager可以用来打印错误信息；<br>Elements是一个可以处理Element的工具类。</p><p><strong><em>在这里我们有必要认识一下什么是Element</em></strong><br>在Java语言中，Element是一个接口，表示一个程序元素，它可以指代包、类、方法或者一个变量。Element已知的子接口有如下几种：</p><blockquote><p>PackageElement  表示一个包程序元素。提供对有关包及其成员的信息的访问。<br>ExecutableElement  表示某个类或接口的方法、构造方法或初始化程序（静态或实例），包括注释类型元素。<br>TypeElement  表示一个类或接口程序元素。提供对有关类型及其成员的信息的访问。注意，枚举类型是一种类，而注解类型是一种接口。<br>VariableElement  表示一个字段、enum 常量、方法或构造方法参数、局部变量或异常参数。</p></blockquote><p>接下来，我希望大家先来理解一个新的概念，<strong>即抛弃我们现有对Java类的理解，把Java类看作是一个结构化的文件</strong>。什么意思？就是把Java类看作一个类似XML或者JSON一样的东西。有了这个概念之后我们就可以很容易的理解什么是Element了。带着这个概念来看下面的代码：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs arduino">package com.zhpan.mannotation.factory;  <span class="hljs-comment">//    PackageElement</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Circle</span> &#123;</span>  <span class="hljs-comment">//  TypeElement</span><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> i; <span class="hljs-comment">//   VariableElement</span><br>    <span class="hljs-keyword">private</span> Triangle triangle;  <span class="hljs-comment">//  VariableElement</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Circle</span><span class="hljs-params">()</span> </span>&#123;&#125; <span class="hljs-comment">//    ExecuteableElement</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">(   <span class="hljs-comment">//  ExecuteableElement</span></span></span><br><span class="hljs-function"><span class="hljs-params">                        <span class="hljs-keyword">String</span> s)</span>   <span class="hljs-comment">//  VariableElement</span></span><br><span class="hljs-function">    </span>&#123;<br>        System.out.<span class="hljs-built_in">println</span>(s);<br>    &#125;<br><br>    @Override<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">//  ExecuteableElement</span><br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;Draw a circle&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在明白了吗？不同类型Element其实就是映射了Java中不同的类元素！知晓这个概念后将对理解后边的代码有很大的帮助。</p><p> <strong><em>(4) public boolean process(Set&lt;? extends TypeElement&gt; set, RoundEnvironment roundEnvironment)</em></strong><br> 终于，到了FactoryProcessor类中最后一个也是最重要的一个方法了。先看这个方法的返回值，是一个boolean类型，返回值表示注解是否由当前Processor 处理。如果返回 true，则这些注解由此注解来处理，后续其它的 Processor 无需再处理它们；如果返回 false，则这些注解未在此Processor中处理并，那么后续 Processor 可以继续处理它们。<br> 在这个方法的方法体中，我们可以校验被注解的对象是否合法、可以编写处理注解的代码，以及自动生成需要的java文件等。因此说这个方法是AbstractProcessor 中的最重要的一个方法。我们要处理的大部分逻辑都是在这个方法中完成。</p><p>了解上述四个方法之后我们便可以初步的来编写FactoryProcessor类的代码了，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@AutoService(Processor.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FactoryProcessor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractProcessor</span> </span>&#123;<br>        <span class="hljs-keyword">private</span> Types mTypeUtils;<br>    <span class="hljs-keyword">private</span> Messager mMessager;<br>    <span class="hljs-keyword">private</span> Filer mFiler;<br>    <span class="hljs-keyword">private</span> Elements mElementUtils;<br>    <span class="hljs-keyword">private</span> Map&lt;String, FactoryGroupedClasses&gt; factoryClasses = <span class="hljs-keyword">new</span> LinkedHashMap&lt;&gt;();<br><br>  <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(ProcessingEnvironment processingEnvironment)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.init(processingEnvironment);<br><br>mTypeUtils = processingEnvironment.getTypeUtils();<br>        mMessager = processingEnvironment.getMessager();<br>        mFiler = processingEnvironment.getFiler();<br>        mElementUtils = processingEnvironment.getElementUtils();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Set&lt;String&gt; <span class="hljs-title">getSupportedAnnotationTypes</span><span class="hljs-params">()</span> </span>&#123;<br>        Set&lt;String&gt; annotations = <span class="hljs-keyword">new</span> LinkedHashSet&lt;&gt;();<br>        annotations.add(Factory.class.getCanonicalName());<br>        <span class="hljs-keyword">return</span> annotations;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">process</span><span class="hljs-params">(Set&lt;? extends TypeElement&gt; set, RoundEnvironment roundEnvironment)</span> </span>&#123;<br><br>   <span class="hljs-comment">//扫描所有被@Factory注解的元素</span><br>   <span class="hljs-keyword">for</span> (Element annotatedElement : roundEnv.getElementsAnnotatedWith(Factory.class)) &#123;<br><br>&#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> SourceVersion <span class="hljs-title">getSupportedSourceVersion</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> SourceVersion.latestSupported();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述FactoryProcessor 代码中在process方法中通过roundEnv.getElementsAnnotatedWith(Factory.class)方法已经拿到了被注解的元素的集合。正常情况下，这个集合中应该包含的是所有被Factory注解的Shape类的元素，也就是一个TypeElement。但在编写程序代码时可能有新来的同事不太了解@Factory的用途而误把@Factory用在接口或者抽象类上，这是不符合我们的标准的。因此，需要在process方法中判断被@Factory注解的元素是否是一个类，如果不是一个类元素，那么就抛出异常，终止编译。代码如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs php">@Override<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> process(Set<span class="hljs-meta">&lt;?</span> <span class="hljs-keyword">extends</span> TypeElement&gt; annotations, RoundEnvironment roundEnv) &#123;<br> <span class="hljs-comment">//  通过RoundEnvironment获取到所有被@Factory注解的对象</span><br>    <span class="hljs-keyword">for</span> (Element annotatedElement : roundEnv.getElementsAnnotatedWith(Factory.<span class="hljs-keyword">class</span>)) &#123;<br><span class="hljs-keyword">if</span> (annotatedElement.getKind() != ElementKind.<span class="hljs-keyword">CLASS</span>) &#123;<br> <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ProcessingException(annotatedElement, <span class="hljs-string">&quot;Only classes can be annotated with @%s&quot;</span>,<br>                    Factory.<span class="hljs-keyword">class</span>.getSimpleName());<br>         &#125;<br>         TypeElement typeElement = (TypeElement) annotatedElement;<br>         FactoryAnnotatedClass annotatedClass = <span class="hljs-keyword">new</span> FactoryAnnotatedClass(typeElement);<br>...<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>基于面向对象的思想，我们可以将annotatedElement中包含的信息封装成一个对象，方便后续使用，因此，另外可以另外声明一个FactoryAnnotatedClass来解析并存放annotatedElement的相关信息。FactoryAnnotatedClass代码如下：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FactoryAnnotatedClass</span> &#123;</span><br>    <span class="hljs-keyword">private</span> TypeElement mAnnotatedClassElement;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">String</span> mQualifiedSuperClassName;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">String</span> mSimpleTypeName;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">String</span> mId;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FactoryAnnotatedClass</span><span class="hljs-params">(TypeElement classElement)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.mAnnotatedClassElement = classElement;<br>        Factory annotation = classElement.getAnnotation(Factory.class);<br>        mId = annotation.id();<br>        <span class="hljs-keyword">if</span> (mId.length() == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<br>                    <span class="hljs-keyword">String</span>.format(<span class="hljs-string">&quot;id() in @%s for class %s is null or empty! that&#x27;s not allowed&quot;</span>,<br>                            Factory.class.getSimpleName(), classElement.getQualifiedName().toString()));<br>        &#125;<br><br>        <span class="hljs-comment">// Get the full QualifiedTypeName</span><br>        <span class="hljs-keyword">try</span> &#123;  <span class="hljs-comment">// 该类已经被编译</span><br>            Class&lt;?&gt; clazz = annotation.type();<br>            mQualifiedSuperClassName = clazz.getCanonicalName();<br>            mSimpleTypeName = clazz.getSimpleName();<br>        &#125; <span class="hljs-keyword">catch</span> (MirroredTypeException mte) &#123;<span class="hljs-comment">// 该类未被编译</span><br>            DeclaredType classTypeMirror = (DeclaredType) mte.getTypeMirror();<br>            TypeElement classTypeElement = (TypeElement) classTypeMirror.asElement();<br>            mQualifiedSuperClassName = classTypeElement.getQualifiedName().toString();<br>            mSimpleTypeName = classTypeElement.getSimpleName().toString();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// ...省去getter</span><br>&#125;<br></code></pre></td></tr></table></figure><p>为了生成合乎要求的ShapeFactory类，在生成ShapeFactory代码前需要对被Factory注解的元素进行一系列的校验，只有通过校验，符合要求了才可以生成ShapeFactory代码。根据需求，我们列出如下规则：</p><blockquote><p>1.只有类才能被@Factory注解。因为在ShapeFactory中我们需要实例化Shape对象，虽然@Factory注解声明了Target为ElementType.TYPE，但接口和枚举并不符合我们的要求。<br>2.被@Factory注解的类中需要有public的构造方法，这样才能实例化对象。<br>3.被注解的类必须是type指定的类的子类<br>4.id需要为String类型，并且需要在相同type组中唯一<br>5.具有相同type的注解类会被生成在同一个工厂类中</p></blockquote><p>根据上面的规则，我们来一步步完成校验，如下代码：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> checkValidClass(FactoryAnnotatedClass item) <span class="hljs-keyword">throws</span> ProcessingException &#123;<br><br>        TypeElement classElement = item.getTypeElement();<br><br>        <span class="hljs-keyword">if</span> (!classElement.getModifiers().contains(Modifier.<span class="hljs-keyword">PUBLIC</span>)) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ProcessingException(classElement, <span class="hljs-string">&quot;The class %s is not public.&quot;</span>,<br>                    classElement.getQualifiedName().toString());<br>        &#125;<br><br>        <span class="hljs-comment">// 如果是抽象方法则抛出异常终止编译</span><br>        <span class="hljs-keyword">if</span> (classElement.getModifiers().contains(Modifier.<span class="hljs-keyword">ABSTRACT</span>)) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ProcessingException(classElement,<br>                    <span class="hljs-string">&quot;The class %s is abstract. You can&#x27;t annotate abstract classes with @%&quot;</span>,<br>                    classElement.getQualifiedName().toString(), Factory.<span class="hljs-keyword">class</span>.getSimpleName());<br>        &#125;<br><br>        <span class="hljs-comment">// 这个类必须是在@Factory.type()中指定的类的子类，否则抛出异常终止编译</span><br>        TypeElement superClassElement = mElementUtils.getTypeElement(item.getQualifiedFactoryGroupName());<br>        <span class="hljs-keyword">if</span> (superClassElement.getKind() == ElementKind.<span class="hljs-keyword">INTERFACE</span>) &#123;<br>            <span class="hljs-comment">// 检查被注解类是否实现或继承了@Factory.type()所指定的类型，此处均为IShape</span><br>            <span class="hljs-keyword">if</span> (!classElement.getInterfaces().contains(superClassElement.asType())) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ProcessingException(classElement,<br>                        <span class="hljs-string">&quot;The class %s annotated with @%s must implement the interface %s&quot;</span>,<br>                        classElement.getQualifiedName().toString(), Factory.<span class="hljs-keyword">class</span>.getSimpleName(),<br>                        item.getQualifiedFactoryGroupName());<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            TypeElement currentClass = classElement;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>                TypeMirror superClassType = currentClass.getSuperclass();<br><br>                <span class="hljs-keyword">if</span> (superClassType.getKind() == TypeKind.NONE) &#123;<br>                    <span class="hljs-comment">// 向上遍历父类，直到Object也没获取到所需父类，终止编译抛出异常</span><br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ProcessingException(classElement,<br>                            <span class="hljs-string">&quot;The class %s annotated with @%s must inherit from %s&quot;</span>,<br>                            classElement.getQualifiedName().toString(), Factory.<span class="hljs-keyword">class</span>.getSimpleName(),<br>                            item.getQualifiedFactoryGroupName());<br>                &#125;<br><br>                <span class="hljs-keyword">if</span> (superClassType.toString().equals(item.getQualifiedFactoryGroupName())) &#123;<br>                    <span class="hljs-comment">// 校验通过，终止遍历</span><br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                currentClass = (TypeElement) mTypeUtils.asElement(superClassType);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 检查是否由public的无参构造方法</span><br>        <span class="hljs-keyword">for</span> (Element enclosed : classElement.getEnclosedElements()) &#123;<br>            <span class="hljs-keyword">if</span> (enclosed.getKind() == ElementKind.CONSTRUCTOR) &#123;<br>                ExecutableElement constructorElement = (ExecutableElement) enclosed;<br>                <span class="hljs-keyword">if</span> (constructorElement.getParameters().<span class="hljs-keyword">size</span>() == <span class="hljs-number">0</span> &amp;&amp;<br>                        constructorElement.getModifiers().contains(Modifier.<span class="hljs-keyword">PUBLIC</span>)) &#123;<br>                    <span class="hljs-comment">// 存在public的无参构造方法，检查结束</span><br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 为检测到public的无参构造方法，抛出异常，终止编译</span><br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ProcessingException(classElement,<br>                <span class="hljs-string">&quot;The class %s must provide an public empty default constructor&quot;</span>,<br>                classElement.getQualifiedName().toString());<br>    &#125;<br></code></pre></td></tr></table></figure><p>如果通过上述校验，那么说明被@Factory注解的类是符合我们的要求的，接下来就可以处理注解信息来生成所需代码了。但是本着面向对象的思想，我们还需声明FactoryGroupedClasses来存放FactoryAnnotatedClass，并且在这个类中完成了ShapeFactory类的代码生成。FactoryGroupedClasses 代码如下：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FactoryGroupedClasses</span> &#123;</span><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">String</span> SUFFIX = <span class="hljs-string">&quot;Factory&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">String</span> qualifiedClassName;<br><br>    <span class="hljs-keyword">private</span> Map&lt;<span class="hljs-keyword">String</span>, FactoryAnnotatedClass&gt; itemsMap = <span class="hljs-keyword">new</span> LinkedHashMap&lt;&gt;();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FactoryGroupedClasses</span><span class="hljs-params">(<span class="hljs-keyword">String</span> qualifiedClassName)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.qualifiedClassName = qualifiedClassName;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(FactoryAnnotatedClass toInsert)</span> </span>&#123;<br>        FactoryAnnotatedClass factoryAnnotatedClass = itemsMap.<span class="hljs-built_in">get</span>(toInsert.getId());<br>        <span class="hljs-keyword">if</span> (factoryAnnotatedClass != null) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IdAlreadyUsedException(factoryAnnotatedClass);<br>        &#125;<br>        itemsMap.<span class="hljs-built_in">put</span>(toInsert.getId(), toInsert);<br>    &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">generateCode</span><span class="hljs-params">(Elements elementUtils, Filer filer)</span> throws IOException </span>&#123;<br>        <span class="hljs-comment">//  Generate java file</span><br>        ...<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来将所有的FactoryGroupedClasses都添加到集合中去</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs haxe">  <span class="hljs-keyword">private</span> Map&lt;<span class="hljs-keyword">String</span>, FactoryGroupedClasses&gt; factoryClasses = <span class="hljs-keyword">new</span> <span class="hljs-type">LinkedHashMap</span>&lt;&gt;();<br><br><span class="hljs-comment">// ...</span><br>FactoryGroupedClasses factoryClass = factoryClasses.<span class="hljs-keyword">get</span>(annotatedClass.getQualifiedFactoryGroupName());<br>   <span class="hljs-keyword">if</span> (factoryClass == <span class="hljs-literal">null</span>) &#123;<br>           <span class="hljs-keyword">String</span> qualifiedGroupName = annotatedClass.getQualifiedFactoryGroupName();<br>           factoryClass = <span class="hljs-keyword">new</span> <span class="hljs-type">FactoryGroupedClasses</span>(qualifiedGroupName);<br>           factoryClasses.put(qualifiedGroupName, factoryClass);<br>     &#125;<br>factoryClass.add(annotatedClass);<br><span class="hljs-comment">// ...</span><br></code></pre></td></tr></table></figure><p>OK!到目前为止，所有的准备工作都已经完成了。接下来就是根据注解信息来生成ShapeFactory类了，有没有很兴奋？遍历factoryClasses集合,并调用FactoryGroupedClasses类的generateCode()方法来生成代码了：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">for</span> (FactoryGroupedClasses <span class="hljs-attribute">factoryClass </span>: factoryClasses.values()) &#123;<br>          <span class="hljs-selector-tag">factoryClass</span><span class="hljs-selector-class">.generateCode</span>(mElementUtils, mFiler);<br>     &#125;<br></code></pre></td></tr></table></figure><p>可是，当我们去掉用generateCode(mElementUtils, mFiler)方法的时候…..纳尼？还是一个空方法，我们还没由实现呢！笑哭?…</p><h2 id="四、认识JavaPoet并用其生成ShapeFactory类"><a href="#四、认识JavaPoet并用其生成ShapeFactory类" class="headerlink" title="四、认识JavaPoet并用其生成ShapeFactory类"></a>四、认识JavaPoet并用其生成ShapeFactory类</h2><p>到此为止，我们唯一剩余的需求就是生成ShapeFactory类了。上一节中我们在FactoryProcessor类的init(ProcessingEnvironment processingEnvironment)方法中通过processingEnvironment拿到了Filer，并且我们也提到通过Filer可以用来编写文件，即可以通过Filer来生成我们所需要的ShapeFactory类。但是，直接使用Filer需要我们手动拼接类的代码，很可能一不小心写错了一个字母就致使所生成的类是无效的。因此，我们需要来认识一下<a href="https://github.com/square/javapoet">JavaPoet</a>这个库。 JavaPoet是square公司的一个开源框架<a href="https://github.com/square/javapoet">JavaPoet</a>，由Jake Wharton大神所编写。JavaPoet可以用对象的方式来帮助我们生成类代码，也就是我们能只要把要生成的类文件包装成一个对象，JavaPoet便可以自动帮我们生成类文件了。关于这个库的使用就不详细在这里讲解了，有需要了解的可以到github查看，使用起来很简单。</p><p>好了，步入正题，使用JavaPoet构建并自动生成ShapeFactory类的代码如下：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public void generate<span class="hljs-constructor">Code(Elements <span class="hljs-params">elementUtils</span>, Filer <span class="hljs-params">filer</span>)</span> throws IOException &#123;<br>        TypeElement superClassName = elementUtils.get<span class="hljs-constructor">TypeElement(<span class="hljs-params">qualifiedClassName</span>)</span>;<br>        String factoryClassName = superClassName.get<span class="hljs-constructor">SimpleName()</span> + SUFFIX;<br>        String qualifiedFactoryClassName = qualifiedClassName + SUFFIX;<br>        PackageElement pkg = elementUtils.get<span class="hljs-constructor">PackageOf(<span class="hljs-params">superClassName</span>)</span>;<br>        String packageName = pkg.is<span class="hljs-constructor">Unnamed()</span> ? null : pkg.get<span class="hljs-constructor">QualifiedName()</span>.<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span>;<br><br>        MethodSpec.Builder <span class="hljs-keyword">method</span> = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">MethodSpec</span>.</span></span><span class="hljs-keyword">method</span><span class="hljs-constructor">Builder(<span class="hljs-string">&quot;create&quot;</span>)</span><br>                .add<span class="hljs-constructor">Modifiers(Modifier.PUBLIC)</span><br>                .add<span class="hljs-constructor">Parameter(String.<span class="hljs-params">class</span>, <span class="hljs-string">&quot;id&quot;</span>)</span><br>                .returns(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">TypeName</span>.</span></span>get(superClassName.<span class="hljs-keyword">as</span><span class="hljs-constructor">Type()</span>));<br>        <span class="hljs-keyword">method</span>.<span class="hljs-keyword">begin</span><span class="hljs-constructor">ControlFlow(<span class="hljs-string">&quot;if (id == null)&quot;</span>)</span><br>                .add<span class="hljs-constructor">Statement(<span class="hljs-string">&quot;throw new IllegalArgumentException($S)&quot;</span>, <span class="hljs-string">&quot;id is null!&quot;</span>)</span><br>                .<span class="hljs-keyword">end</span><span class="hljs-constructor">ControlFlow()</span>;<br><br>        <span class="hljs-keyword">for</span> (FactoryAnnotatedClass item : itemsMap.values<span class="hljs-literal">()</span>) &#123;<br>            <span class="hljs-keyword">method</span>.<span class="hljs-keyword">begin</span><span class="hljs-constructor">ControlFlow(<span class="hljs-string">&quot;if ($S.equals(id))&quot;</span>, <span class="hljs-params">item</span>.<span class="hljs-params">getId</span>()</span>)<br>                    .add<span class="hljs-constructor">Statement(<span class="hljs-string">&quot;return new $L()&quot;</span>, <span class="hljs-params">item</span>.<span class="hljs-params">getTypeElement</span>()</span>.get<span class="hljs-constructor">QualifiedName()</span>.<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span>)<br>                    .<span class="hljs-keyword">end</span><span class="hljs-constructor">ControlFlow()</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">method</span>.add<span class="hljs-constructor">Statement(<span class="hljs-string">&quot;throw new IllegalArgumentException($S + id)&quot;</span>, <span class="hljs-string">&quot;Unknown id = &quot;</span>)</span>;<br><br>        TypeSpec typeSpec = TypeSpec<br>                .<span class="hljs-keyword">class</span><span class="hljs-constructor">Builder(<span class="hljs-params">factoryClassName</span>)</span><br>                .add<span class="hljs-constructor">Modifiers(Modifier.PUBLIC)</span><br>                .add<span class="hljs-constructor">Method(<span class="hljs-params">method</span>.<span class="hljs-params">build</span>()</span>)<br>                .build<span class="hljs-literal">()</span>;<br><br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">JavaFile</span>.</span></span>builder(packageName, typeSpec).build<span class="hljs-literal">()</span>.write<span class="hljs-constructor">To(<span class="hljs-params">filer</span>)</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p>好了，现在项目已经可以帮我们自动来生成需要的Java文件啦。接下来验证一下，Build一下项目，切换到project模式下，在app–&gt;build–&gt;generated–&gt;source–&gt;apt–&gt;debug–&gt;(package)–&gt;factory下面就可以看到ShapeFactory类，如下图：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS84LzI0LzE2Y2JmZWU0YTM2NjA5N2E?x-oss-process=image/format,png" alt="这里写图片描述"><br>这个类并非是我们自己编写的，而是通过使用APT的一系列骚操作自动生成的。现在可以再添加一个形状类实现IShape并附加@Factory注解，再次编译后都自动会生成到ShapeFactory中！</p><p>到此为止，本篇文章就告一段落了。相信看完本篇文章一定大有所获，因为掌握了APT技术之后，再去研究使用APT的第三方框架源码，一定会游刃有余，事半功倍。</p><p>由于本篇文章结构比较复杂且代码也较多，项目的源码已经放在文章末尾，可作参考。</p><p><a href="https://github.com/zhpanvip/MAnnotation">源码下载</a></p><p><strong>参考资料</strong></p><p><a href="https://www.race604.com/annotation-processing/">Java注解处理器</a></p><p><a href="http://www.cjsdn.net/Doc/JDK60/javax/annotation/processing/AbstractProcessor.html">JDK文档AbstractProcessor</a></p>]]></content>
    
    
    <categories>
      
      <category>Java进阶</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Annotation</tag>
      
      <tag>APT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java中的注解及其实例应用</title>
    <link href="/2018/08/25/17.Java%20annotation/"/>
    <url>/2018/08/25/17.Java%20annotation/</url>
    
    <content type="html"><![CDATA[<p>Java注解在我们项目开发 中是非常常见的。比如经常用到的几种java内置的注解：</p><p> @Override，表示当前的方法定义将覆盖超类中的方法。</p><p> @Deprecated，表示当前方法即将废弃，不推荐使用。</p><p> @SuppressWarnings，表示忽略编译器的警告信息。</p><p>对于上面几个注解想必大家都不会陌生。除此之外，我们还经常在一些第三方框架中看到一些自定义注解。比如大名鼎鼎的ButterKnife和Arouter都是基于注解实现的。网上关于注解的文章数不胜数，但是，很多章都是贴下注解的定义，然后解释下几种元注解，扔出一个自定义注解的例子就不了了之了。刚接触注解的时候，看了半天注解相关的文章也没弄懂注解到底有什么用，我想很多读者应该都有和我一样的经历。其实注解往往是需要结合反射来用的，离了反射，注解也就失去了灵魂。那么，本篇文章我们会先来学习一下注解的基础知识，然后通过几个实例来认识注解的具体用途。</p><h2 id="一、注解基础知识简介"><a href="#一、注解基础知识简介" class="headerlink" title="一、注解基础知识简介"></a>一、注解基础知识简介</h2><p>首先我们来看下维基百科上给注解的定义:</p><blockquote><p>Java注解又称Java标注，是Java语言5.0版本开始支持加入源代码的特殊语法元数据。Java语言中的类、方法、变量、参数和包等都可以被标注。和Javadoc不同，Java标注可以通过反射获取标注内容。在编译器生成类文件时，标注可以被嵌入到字节码中。Java虚拟机可以保留标注内容，在运行时可以获取到标注内容。 当然它也支持自定义Java标注。</p></blockquote><p>从定义中我们可以看出来，注解其实就是一个标记，它可以标记类、方法、变量、参数甚至是包。有了这个标记之后呢，我们就可以通过反射获取到被注解标记的这些类、方法或者变量、参数等。从而根据注解信息去进行一些特殊操作。比如结合反射实现一些特殊处理，或者结合APT(Java编译时注解处理器)来动态来生生代码。</p><p>说了这么多，我们还是先来认识一下注解吧。</p><h3 id="1-注解的声明"><a href="#1-注解的声明" class="headerlink" title="1.注解的声明"></a>1.注解的声明</h3><p>同类(class)与接口(interface)一样，注解( @interface)也是一种定义类型，它是在JDK 5.0中引入的。我们可以通过@interface来声明一个注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Inherited</span><br><span class="hljs-meta">@Retention(RetentionPolicy.SOURCE)</span><br><span class="hljs-meta">@Target(ElementType.PARAMETER)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> MAnnotation &#123;<br><span class="hljs-function">string <span class="hljs-title">name</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">age</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> 18</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如上代码，我们声明了一个自定义注解MAnnotation，可以看到注解的结构与声明一个类或者接口有些类似。同时注解也可以有成员变量。如上代码中，我们为其声明了name和age两个成员，并且为age赋了一个默认值。而注解与类和接口最大的不同之处就是需要声明<strong>元注解</strong>。也就是上述代码的前四行。那什么是元注解呢？我们接着来看。</p><h3 id="2-元注解"><a href="#2-元注解" class="headerlink" title="2.元注解"></a>2.元注解</h3><p>元注解可以理解为注解的注解。用来提供对给其他的注解做类型说明的。比如说通过元注解可以指定注解的作用范围或者指定注解保留的时期（编译器、字节码或者运行时）。JDK中提供了如下4个元注解：</p><blockquote><p>@Target<br>@Retention<br> @Inherited<br>@Documented</p></blockquote><p>那么接下来我们来逐个了解一下上述四个元注解的所用</p><h4 id="（1）元注解之-Target"><a href="#（1）元注解之-Target" class="headerlink" title="（1）元注解之@Target"></a>（1）元注解之@Target</h4><p>@Target用于指定注解可以修饰哪些程序元素，例如指定注解可以修饰类、修饰方法或者修饰参数等。我们来看一下@Target的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Target(ElementType.ANNOTATION_TYPE)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Target &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Returns an array of the kinds of elements an annotation type</span><br><span class="hljs-comment">     * can be applied to.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> an array of the kinds of elements an annotation type</span><br><span class="hljs-comment">     * can be applied to</span><br><span class="hljs-comment">     */</span><br>    ElementType[] value();<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到@Target包含一个类型为ElementType[ ]的成员变量，有趣的一点是Target自己修饰了自己，并且指定了ElementType为ANNOTATION_TYPE，意味着@Target是用来标记（注解）注解的。ElementType是一个枚举类型，我们来看一下它的所有枚举值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> ElementType &#123;<br>    <span class="hljs-comment">/** 指定注解能修饰类、接口或枚举类型 */</span><br>    TYPE,<br><br>    <span class="hljs-comment">/** 指定注解能修饰成员变量 */</span><br>    FIELD,<br><br>    <span class="hljs-comment">/** 指定注解能修饰方法 */</span><br>    METHOD,<br><br>    <span class="hljs-comment">/**指定注解能修饰参数 */</span><br>    PARAMETER,<br><br>    <span class="hljs-comment">/** 指定注解能修饰构造器 */</span><br>    CONSTRUCTOR,<br><br>    <span class="hljs-comment">/** 指定注解能修饰局部变量 */</span><br>    LOCAL_VARIABLE,<br><br>    <span class="hljs-comment">/** 指定注解能修饰注解 */</span><br>    ANNOTATION_TYPE,<br><br>    <span class="hljs-comment">/** 指定注解能修饰包 */</span><br>    PACKAGE,<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 指定注解能够修饰类型参数（1.8新加入）</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@since</span> 1.8</span><br><span class="hljs-comment">     */</span><br>    TYPE_PARAMETER,<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 类型使用声明（1.8新加入）</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@since</span> 1.8</span><br><span class="hljs-comment">     */</span><br>    TYPE_USE<br>&#125;<br></code></pre></td></tr></table></figure><p>在本章第一节中我们自定义的MAnnotation注解被声明了@Target(ElementType.PARAMETER)，那么MAnnotation就只能用来注解参数，如果用来修饰了其它元素编译器则会报错。另外如果一个自定义注解没有声明@Target，那么这个注解可以作用于任意程序元素。</p><h4 id="（2）元注解之-Retention"><a href="#（2）元注解之-Retention" class="headerlink" title="（2）元注解之@Retention"></a>（2）元注解之@Retention</h4><p>Retention意思有保留、保持的意思，它表示注解存在阶段是保留在源码（编译期），字节码（类加载）还是者运行期（JVM中运行）。在@Retention注解中使用枚举RetentionPolicy来表示注解保留时期，@Retention的源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Target(&#123;ElementType.ANNOTATION_TYPE&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Retention &#123;<br>    <span class="hljs-function">RetentionPolicy <span class="hljs-title">value</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>而@Retention中的成员变量RetentionPolicy 同样也是一个枚举类型，其值有三个，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> RetentionPolicy &#123;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 该类型修饰的注解信息只会保留在源码里，源码经过编译后，注解信息会被丢弃，不会保留在编译好的字节码里）</span><br><span class="hljs-comment">*/</span><br>    SOURCE,<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">* 该类型修饰的注解会保留在源码和字节码中，但不会被加载到虚拟机</span><br><span class="hljs-comment">*/</span><br>    CLASS,<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">* 该类型修饰的注解会在源码、字节码以及JVM中都有保留</span><br><span class="hljs-comment">*/</span><br>    RUNTIME;<br>&#125;<br></code></pre></td></tr></table></figure><p>例如，在本章第一节中声明的自定义注解MAnnotation 被@Retention(RetentionPolicy.SOURCE)所修饰，那么这个注解只会存在于源码中。</p><h4 id="（3）元注解之-Inherited"><a href="#（3）元注解之-Inherited" class="headerlink" title="（3）元注解之@Inherited"></a>（3）元注解之@Inherited</h4><p>@Inherited是一个标记注解，指定注解具有继承性。要注意的是它并不是说注解本身可以继承，而是说如果一个父类被 @Inherited 注解的话，那么如果它的子类没有被任何注解标记的话，那么这个子类就继承了父类的注解。可以看到本章第一节中MAnnotation被@Inherited修饰。那么来看下面的一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@MAnnotation</span> <br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClassA</span></span>&#123;&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClassB</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ClassA</span> </span>&#123;&#125;<br></code></pre></td></tr></table></figure><p>ClassA 被 MAnnotation 注解，ClassB 继承 ClassA，那么此时ClassB也拥有@MAnnotation 注解。</p><h4 id="（4）元注解之-Documented"><a href="#（4）元注解之-Documented" class="headerlink" title="（4）元注解之@Documented"></a>（4）元注解之@Documented</h4><p>@Documented是一个标记注解，本章第一节中的MAnnotation 使用了@Documented修饰，则在用javadoc命令生成API文档后，所有使用注解MAnnotation 修饰的程序元素，将会包含注解MAnnotation 的说明。</p><p>以上提到的四种元注解中，最常用的是@Target注解于@Retention。或许看到这里你仍然觉得一头雾水，仍然不知道这些东西有什么用途。那么实属正常情况。我们会在后边章节中举例说明。</p><h2 id="二、注解的实例应用"><a href="#二、注解的实例应用" class="headerlink" title="二、注解的实例应用"></a>二、注解的实例应用</h2><h3 id="1-在Android中使用注解替代枚举"><a href="#1-在Android中使用注解替代枚举" class="headerlink" title="1.在Android中使用注解替代枚举"></a>1.在Android中使用注解替代枚举</h3><p>我们知道，在Android的View中有一个setVisibility(int )的方法，该方法接受一个int类型，用来设置View的可见性。那么既然是一个int参数，那么理论上应该可以接受任何的int类型，但是当我们尝试在这个方法中传入一个10的时候，编译器却报错了，错误如下图：<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/effee15129da4eb4b8491dc950b29a63~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"><br> 编译器告诉我们，这个参数只能接受View.VISIBLE,View.INVISIBLE以及View.GONE。这是如何实现的呢？其实就是通过自定义注解来实现的。我们看下setVisibility的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setVisibility</span><span class="hljs-params">(<span class="hljs-meta">@Visibility</span> <span class="hljs-keyword">int</span> visibility)</span> </span>&#123;<br>        setFlags(visibility, VISIBILITY_MASK);<br>    &#125;<br></code></pre></td></tr></table></figure><p>可以看到setVisibility中的参数visibility被一个@Visibility的注解修饰了，而@Visibility注解如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@IntDef(&#123;VISIBLE, INVISIBLE, GONE&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.SOURCE)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Visibility &#123;&#125;<br></code></pre></td></tr></table></figure><p>其中@IntDef是Android源码中的一个自定义注解，可以用@IntDef来指定一个数组集合，如果一个注解被@IntDef标记，并指定了数组集合，那么这个注解去标记参数时，这个参数只能接受在@IntDef中所指定的几个参数。而Visibility注解中指定了{VISIBLE, INVISIBLE, GONE}三个参数，因此，当我们在setVisibility中传入这三个以外的其它值时，编译器就会提示错误。当然，这一检查流程是IDE完成的，我们无需关心太多。而我们在平时的开发中也可以用此类方法替代枚举。</p><h3 id="2-注解结合反射实现ButterKnife功能"><a href="#2-注解结合反射实现ButterKnife功能" class="headerlink" title="2.注解结合反射实现ButterKnife功能"></a>2.注解结合反射实现ButterKnife功能</h3><p>第二个例子，我们来看下注解与反射的结合使用来实现一个与ButterKnife类似功能的实例。</p><p>在文章开头我们就提到离开反射的注解是没有灵魂的，正是因为反射才赋予了注解实质的用途。那么接下来，我们用注解+反射来模仿并实现一个简易的ButterKnife的功能。要实现的功能列举如下：</p><ul><li>使用注解注入布局文件省去setContentView（ButterKnife中并没有提供此功能）</li><li>使用注解省去findViewById</li><li>使用注解省去setOnClickListener</li></ul><h4 id="（1）定义注解"><a href="#（1）定义注解" class="headerlink" title="（1）定义注解"></a>（1）定义注解</h4><p>根据以上需求，我们可以定义三个注解。</p><p>① InjectLayout注解用于给Activity注入布局文件的注解，该注解用于Activity类上。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(ElementType.TYPE)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> InjectLayout &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">value</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> -1</span>; <span class="hljs-comment">// Activity布局文件</span><br>&#125;<br></code></pre></td></tr></table></figure><p>② BindView 注解用于查找控件ID，该注解作用于成员变量上。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Retention(RetentionPolicy.SOURCE)</span><br><span class="hljs-meta">@Target(&#123;ElementType.FIELD&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> BindView &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">value</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> -1</span>; <span class="hljs-comment">// View的id</span><br>&#125;<br></code></pre></td></tr></table></figure><p>③OnClick 注解给View设置监听事件，该注解作用于方法上</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(ElementType.METHOD)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> OnClick &#123;<br>    <span class="hljs-keyword">int</span>[] value(); <span class="hljs-comment">// View的Id数组</span><br>&#125;<br></code></pre></td></tr></table></figure><p>以上三个注解因为都是需要结合反射，因此@Retention都需要声明为RetentionPolicy.RUNTIME。接着，我们把以上三个注解分别应用到Activity的元素上，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@InjectLayout(R.layout.activity_main)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AppCompatActivity</span> </span>&#123;<br><br>    <span class="hljs-meta">@BindView(R.id.tv_test)</span><br>    Button mButton;<br><br>    <span class="hljs-meta">@OnClick(&#123;R.id.btn_factory,R.id.tv_test&#125;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onClick</span><span class="hljs-params">(View view)</span> </span>&#123;<br>       <span class="hljs-keyword">switch</span> (view.getId()) &#123;<br>            <span class="hljs-keyword">case</span> R.id.tv_test:<br>                Toast.makeText(<span class="hljs-keyword">this</span>, <span class="hljs-string">&quot;通过注解点击了Button&quot;</span>, Toast.LENGTH_SHORT).show();<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">default</span>：<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="（2）使用反射处理注解信息"><a href="#（2）使用反射处理注解信息" class="headerlink" title="（2）使用反射处理注解信息"></a>（2）使用反射处理注解信息</h4><p>上一小节中，由于我们没有对注解做任何的操作，因此，实际上这些注解到现在为止是没有任何作用的。仅仅是为Activity的这些元素打上了一个标记。那么接下来，我们就需要通过反射为注解注入灵魂。</p><p><strong>① 反射+InjectLayout注解实现绑定Activity布局文件</strong></p><p>定义injectLayout方法并传入Activity参数，然后通过Class的isAnnotationPresent方法判断Activity上是否有injectLayout的注解信息，如果有，则读取注解信息，并调用Activity的setContentView方法为Activity设置布局文件，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">injectLayout</span><span class="hljs-params">(Activity activity)</span> </span>&#123;<br>        Class&lt;?&gt; activityClass = activity.getClass();<br>        <span class="hljs-keyword">if</span> (activityClass.isAnnotationPresent(InjectLayout.class)) &#123;<br>            InjectLayout injectLayout = activityClass.getAnnotation(InjectLayout.class);<br>            activity.setContentView(injectLayout.value());<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>这样，通过在Activity中调用injectLayout方法就可以完成布局文件的绑定。</p><p><strong>② 反射+BindView 注解绑定View</strong><br>在bindView方法中获取到Activity中的所有成员变量并进行遍历，逐个判断成员遍历上是否有BindView 注解，如果包含该注解，则读取注解中的id，并调用findViewById方法通过反射为View赋值。代码实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bindView</span><span class="hljs-params">(Activity activity)</span> </span>&#123;<br>       Class&lt;?&gt; activityClass = activity.getClass();<br>       Field[] declaredFields = activityClass.getDeclaredFields();<br>       <span class="hljs-keyword">for</span> (Field field : declaredFields) &#123;<br>           <span class="hljs-keyword">if</span> (field.isAnnotationPresent(BindView.class)) &#123;<br>               BindView bindView = field.getAnnotation(BindView.class);<br>               <span class="hljs-keyword">try</span> &#123;<br>                   View view = activity.findViewById(bindView.value());<br>                   field.setAccessible(<span class="hljs-keyword">true</span>);<br>                   field.set(activity, view);<br>               &#125; <span class="hljs-keyword">catch</span> (IllegalAccessException e ) &#123;<br>                   e.printStackTrace();<br>               &#125;<br>           &#125;<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><p><strong>③ 反射+OnClick实现点击事件的绑定</strong></p><p>首先获取到Activity中的所有方法，并进行遍历判断方法上是否包含OnClick注解，如果包含则读取注解信息，因为OnClick注解中的参数是一个数组，因此得到数组后需要遍历该数组并获取到View，并为view设置点击事件，在点击的回调用通过反射来调用被@OnClick注解的方法。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bindOnClick</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Activity activity)</span> </span>&#123;<br>    Class&lt;?&gt; cls = activity.getClass();<br>    Method[] methods = cls.getMethods();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; methods.length; i++) &#123;<br>        <span class="hljs-keyword">final</span> Method method = methods[i];<br>        <span class="hljs-keyword">if</span> (method.isAnnotationPresent(OnClick.class)) &#123;<br>            OnClick mOnclick = method.getAnnotation(OnClick.class);<br>            <span class="hljs-keyword">int</span>[] ids = mOnclick.value();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; ids.length; j++) &#123;<br>                <span class="hljs-keyword">final</span> View view = activity.findViewById(ids[j]);<br>                <span class="hljs-keyword">if</span>(view==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">continue</span>;<br>                view.setOnClickListener(<span class="hljs-keyword">new</span> View.OnClickListener() &#123;<br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onClick</span><span class="hljs-params">(View v)</span> </span>&#123;<br>                        <span class="hljs-keyword">try</span> &#123;<br>                            method.setAccessible(<span class="hljs-keyword">true</span>);<br>                            method.invoke(activity, view);<br>                        &#125; <span class="hljs-keyword">catch</span> (IllegalAccessException e) &#123;<br>                            e.printStackTrace();<br>                        &#125; <span class="hljs-keyword">catch</span> (InvocationTargetException e) &#123;<br>                            e.printStackTrace();<br>                        &#125;<br>                    &#125;<br>                &#125;);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在完成以上操作后，则可以在Activity的onCreate方法中分别调用injectLayout、bindView和bindOnClick来完成绑定。我们来看下运行及起来的效果：<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/58c97493bcee46a0b2b148d899e4e8a9~tplv-k3u1fbpfcp-zoom-1.image" alt="这里写图片描述"></p><p>效果貌似还不错，实现了与ButterKnife的部分功能，甚至我们还比ButterKnife多了一个注入布局的功能。</p><p><a href="https://github.com/zhpanvip/MAnnotation/blob/master/app/src/main/java/com/zhpan/mannotation/BindProcessor.java">本节相关源码点这里</a></p><h3 id="3-注解结合Java编译时注解处理器（APT）"><a href="#3-注解结合Java编译时注解处理器（APT）" class="headerlink" title="3.注解结合Java编译时注解处理器（APT）"></a>3.注解结合Java编译时注解处理器（APT）</h3><p>上一节中我们使用注解+反射实现了一个简易的ButterKnife功能。但是，我们知道反射是一个比较消耗性能的操作，并且上述操作中还进行了循环遍历，而这些实现多多少少都会对性能造成一定的影响。因此，ButterKnife的实现并非使用的用反射，而是使用APT（Java编译时注解处理器）来实现的。而APT的实现也是基于注解，但是由于APT的相关知识相对复杂，因此就不在本篇文章中展开讲了。请参看下一篇文章<a href="https://blog.csdn.net/qq_20521573/article/details/82321755">《Java进阶–编译时注解处理器（APT）详解》</a></p><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>注解的概念非常简单，但是如果只学习注解的知识，却很难理解注解的作用。而网上很多文章往往只讲解注解的概念，却对注解的使用只字不提。这样其实是误导了很多读者，致使很多人看完之后依然是一头雾水，不理解注解是做什么用的。而本篇通过讲解注解的基本概念以及注解的三个实例应用。相信通过这些内容读者一定会对注解有一个深刻的认识。</p>]]></content>
    
    
    <categories>
      
      <category>Java进阶</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Annotation,Java注解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于Arouter的路由实现方案</title>
    <link href="/2018/07/26/16.Arouter%20in%20project/"/>
    <url>/2018/07/26/16.Arouter%20in%20project/</url>
    
    <content type="html"><![CDATA[<h1 id="一、为什么要在项目中引入路由？"><a href="#一、为什么要在项目中引入路由？" class="headerlink" title="一、为什么要在项目中引入路由？"></a>一、为什么要在项目中引入路由？</h1><p>在开始之前我们先来思考一下这个问题。为什么要在项目中引入路由？相信大家的答案可能会有所不同，但是应该也不外乎以下几点：</p><h2 id="1-为了实现项目组件化"><a href="#1-为了实现项目组件化" class="headerlink" title="1.为了实现项目组件化"></a>1.为了实现项目组件化</h2><p>想必很多开发者引入路由的目的都是因为要实现项目组件化。我们知道，组件化的项目各个业务模块之间没有相互的依赖关系。不同业务模块之间的通信最好的解决方案就是支持页面路由。</p><h2 id="2-方便APP内部跳转"><a href="#2-方便APP内部跳转" class="headerlink" title="2.方便APP内部跳转"></a>2.方便APP内部跳转</h2><p>可能有些小伙伴会有疑问，App内部直接通过Intent跳转不是很好吗，为什么要多此一举引入路由呢？当然，通常情况下通过Intent跳转也无伤大雅。但是在某些情况下，比如像下图这样的一个页面：<br><img src="https://img-blog.csdnimg.cn/2019091700111637.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwNTIxNTcz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>这是一个典型的多Type的RecyclerView页面，这个页面中所有的数据都是从服务器获取的，在引入路由之前所有的点击跳转事件都需要后台给我们一个type,我们根据type判断需要向哪一个Activity跳转，并且需要通过Intent携带目的页面所需要的参数。显然这样写会使我们代码变得非常臃肿，代码之间的耦合度也非常高。然而在引入路由之后一切都变得不一样了。我们只需要后台返回目的页面所对应的URL，并在URL上拼接页面跳转所需要的参数，此时前台只需要拿到URL，然后通过路由即可到达对应的页面。这样以来使我们的代码变得简洁明了，并且保证了代码的低耦合。</p><h2 id="3-方便APP外部跳转"><a href="#3-方便APP外部跳转" class="headerlink" title="3.方便APP外部跳转"></a>3.方便APP外部跳转</h2><p>通常可以看到很多应用支持从浏览器唤醒App并跳转到对应的页面。做到比较好的如知乎，体验过知乎的小伙伴应该知道，知乎可以从浏览器唤醒App并且直接在App中打开当前在浏览器中浏览的内容。我们知道，从外部唤起App需要给Activity添加Schema。而如果App内部有许多Activity需要支持外部唤起，我们不可能为这些Activity都添加Schema。那么此时我们就可以单独设置一个支持Schema的Activity，浏览器可以通过Schema唤起这个Activity。而在这个Activity中会接收浏览器传过来的URL，然后根据URL进行路由分发，通过URL路由到对应的页面即可。</p><h1 id="二-、ARouter的使用"><a href="#二-、ARouter的使用" class="headerlink" title="二 、ARouter的使用"></a>二 、ARouter的使用</h1><p>其实很不想在这篇文章中长篇大论如何使用<a href="https://github.com/alibaba/ARouter">ARouter</a>，因为<a href="https://github.com/alibaba/ARouter/blob/master/README_CN.md">ARouter的官方文档</a>上已经非常详细的告诉了开发者如何去使用，只要仔细的阅读ARouter的文档基本上绝大部分问题都可以得到解决。但是为了照顾没有使用过ARouter的小伙伴，这里还是再啰嗦一下。如果你对ARouter的使用已经非常熟悉了那么你可以忽略此章节，直接到下一章了。</p><h2 id="1-添加依赖和配置"><a href="#1-添加依赖和配置" class="headerlink" title="1.添加依赖和配置"></a>1.添加依赖和配置</h2><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">android</span> <span class="hljs-string">&#123;</span><br>    <span class="hljs-attr">defaultConfig</span> <span class="hljs-string">&#123;</span><br>        <span class="hljs-attr">...</span><br>        <span class="hljs-attr">javaCompileOptions</span> <span class="hljs-string">&#123;</span><br>            <span class="hljs-attr">annotationProcessorOptions</span> <span class="hljs-string">&#123;</span><br>                <span class="hljs-attr">arguments</span> = <span class="hljs-string">[AROUTER_MODULE_NAME: project.getName()]</span><br>            <span class="hljs-attr">&#125;</span><br>        <span class="hljs-attr">&#125;</span><br>    <span class="hljs-attr">&#125;</span><br><span class="hljs-attr">&#125;</span><br><br><span class="hljs-attr">dependencies</span> <span class="hljs-string">&#123;</span><br>    <span class="hljs-meta">//</span> <span class="hljs-string">替换成最新版本, 需要注意的是api</span><br>    <span class="hljs-meta">//</span> <span class="hljs-string">要与compiler匹配使用，均使用最新版可以保证兼容</span><br>    <span class="hljs-attr">implementation</span> <span class="hljs-string">&#x27;com.alibaba:arouter-api:x.x.x&#x27;</span><br>    <span class="hljs-attr">annotationProcessor</span> <span class="hljs-string">&#x27;com.alibaba:arouter-compiler:x.x.x&#x27;</span><br>    <span class="hljs-attr">...</span><br><span class="hljs-attr">&#125;</span><br></code></pre></td></tr></table></figure><p>这里需要注意，如果你的项目有多个业务模块，那么每个模块都需要在gradle中添加以上配置。</p><h2 id="2-初始化SDK"><a href="#2-初始化SDK" class="headerlink" title="2.初始化SDK"></a>2.初始化SDK</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">if</span> (is<span class="hljs-constructor">Debug()</span>) &#123;           <span class="hljs-comment">// 这两行必须写在init之前，否则这些配置在init过程中将无效</span><br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ARouter</span>.</span></span><span class="hljs-keyword">open</span><span class="hljs-constructor">Log()</span>;     <span class="hljs-comment">// 打印日志</span><br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ARouter</span>.</span></span><span class="hljs-keyword">open</span><span class="hljs-constructor">Debug()</span>;   <span class="hljs-comment">// 开启调试模式(如果在InstantRun模式下运行，必须开启调试模式！线上版本需要关闭,否则有安全风险)</span><br>&#125;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ARouter</span>.</span></span>init(mApplication); <span class="hljs-comment">// 尽可能早，推荐在Application中初始化</span><br></code></pre></td></tr></table></figure><h2 id="3-添加注解"><a href="#3-添加注解" class="headerlink" title="3.添加注解"></a>3.添加注解</h2><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-comment">// 在支持路由的页面上添加注解(必选)</span><br><span class="hljs-comment">// 这里的路径需要注意的是至少需要有两级，/xx/xx</span><br>@Route(path = <span class="hljs-string">&quot;/test/activity&quot;</span>)<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-symbol">YourActivity</span> <span class="hljs-symbol">extend</span> <span class="hljs-symbol">Activity</span> &#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-发起路由操作"><a href="#4-发起路由操作" class="headerlink" title="4.发起路由操作"></a>4.发起路由操作</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// 1. 应用内简单的跳转(通过URL跳转在&#x27;进阶用法&#x27;中)</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ARouter</span>.</span></span>get<span class="hljs-constructor">Instance()</span>.build(<span class="hljs-string">&quot;/test/activity&quot;</span>).navigation<span class="hljs-literal">()</span>;<br><br><span class="hljs-comment">// 2. 跳转并携带参数</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ARouter</span>.</span></span>get<span class="hljs-constructor">Instance()</span>.build(<span class="hljs-string">&quot;/test/1&quot;</span>)<br>            .<span class="hljs-keyword">with</span><span class="hljs-constructor">Long(<span class="hljs-string">&quot;key1&quot;</span>, 666L)</span><br>            .<span class="hljs-keyword">with</span><span class="hljs-constructor">String(<span class="hljs-string">&quot;key3&quot;</span>, <span class="hljs-string">&quot;888&quot;</span>)</span><br>            .<span class="hljs-keyword">with</span><span class="hljs-constructor">Object(<span class="hljs-string">&quot;key4&quot;</span>, <span class="hljs-params">new</span> Test(<span class="hljs-string">&quot;Jack&quot;</span>, <span class="hljs-string">&quot;Rose&quot;</span>)</span>)<br>            .navigation<span class="hljs-literal">()</span>;<br></code></pre></td></tr></table></figure><p>很多情况下需要通过URL跳转，ARouter支持直接通过URL跳转：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">Uri uri= <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Uri</span>.</span></span>parse(url);<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ARouter</span>.</span></span>get<span class="hljs-constructor">Instance()</span>.build(uri).navigation<span class="hljs-literal">()</span>;<br></code></pre></td></tr></table></figure><h2 id="5-路由解析参数"><a href="#5-路由解析参数" class="headerlink" title="5.路由解析参数"></a>5.路由解析参数</h2><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-comment">// 为每一个参数声明一个字段，并使用 @Autowired 标注</span><br><span class="hljs-comment">// URL中不能传递Parcelable类型数据，通过ARouter api可以传递Parcelable对象</span><br><span class="hljs-meta">@Route</span>(path = <span class="hljs-string">&quot;/test/activity&quot;</span>)<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test1Activity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Activity</span> </span>&#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">public</span> String name;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">int</span> age;<br>    <br>    <span class="hljs-comment">// 通过name来映射URL中的不同参数</span><br>    <span class="hljs-meta">@Autowired</span>(name = <span class="hljs-string">&quot;girl&quot;</span>) <br>    <span class="hljs-keyword">boolean</span> boy;<br>    <br>    <span class="hljs-comment">// 支持解析自定义对象，URL中使用json传递</span><br>    <span class="hljs-meta">@Autowired</span><br>    TestObj obj;      <br>    <br>    <span class="hljs-comment">// 使用 withObject 传递 List 和 Map 的实现了</span><br>    <span class="hljs-comment">// Serializable 接口的实现类(ArrayList/HashMap)</span><br>    <span class="hljs-comment">// 的时候，接收该对象的地方不能标注具体的实现类类型</span><br>    <span class="hljs-comment">// 应仅标注为 List 或 Map，否则会影响序列化中类型</span><br>    <span class="hljs-comment">// 的判断, 其他类似情况需要同样处理        </span><br>    <span class="hljs-meta">@Autowired</span><br>    List&lt;TestObj&gt; list;<br>    <span class="hljs-meta">@Autowired</span><br>    Map&lt;String, List&lt;TestObj&gt;&gt; map;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> </span>&#123;<br>    <span class="hljs-keyword">super</span>.onCreate(savedInstanceState);<br>    ARouter.getInstance().inject(<span class="hljs-keyword">this</span>);<br><br>    <span class="hljs-comment">// ARouter会自动对字段进行赋值，无需主动获取</span><br>    Log.d(<span class="hljs-string">&quot;param&quot;</span>, name + age + boy);<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">// 如果需要传递自定义对象，新建一个类（并非自定义对象类），然后实现 SerializationService,并使用@Route注解标注(方便用户自行选择序列化方式)，例如：</span><br><span class="hljs-meta">@Route</span>(path = <span class="hljs-string">&quot;/yourservicegroupname/json&quot;</span>)<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JsonServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">SerializationService</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(Context context)</span> </span>&#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">json2Object</span><span class="hljs-params">(String text, Class&lt;T&gt; clazz)</span> </span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">return</span> JSON.<span class="hljs-title">parseObject</span><span class="hljs-params">(text, clazz)</span></span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-function">String <span class="hljs-title">object2Json</span><span class="hljs-params">(Object instance)</span> </span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">return</span> JSON.<span class="hljs-title">toJSONString</span><span class="hljs-params">(instance)</span></span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>除了使用@Autowired注解注入参数外，还可以与普通页面跳转一样通过getIntent()获取参数。</p><p>以上就是ARouter的一些基本用法，了解这些基本用法之后并不等于已经掌握了ARouter。因为当你实际用到项目中的时候可能会面临诸多问题。</p><h1 id="三-、ARouter的采坑之路"><a href="#三-、ARouter的采坑之路" class="headerlink" title="三 、ARouter的采坑之路"></a>三 、ARouter的采坑之路</h1><p>如果你只是简单的写一个ARouter使用的Demo，那么可能上一章的内容已经足够了。但是当你在项目中引入ARouter后各种各样的问题便会接踵而至。</p><h2 id="1-使用ARouter实现登录拦截"><a href="#1-使用ARouter实现登录拦截" class="headerlink" title="1.使用ARouter实现登录拦截"></a>1.使用ARouter实现登录拦截</h2><p>这是在项目中引入ARouter后面临的第一个问题。通常情况下，大部分App不登录便可以进入主页面，在跳转需要用户权限的页面时会首先跳转到登录页面引导用户登录。我相信大部分的开发在最初时候都写过类似这样的代码：</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable"><span class="hljs-keyword">if</span></span> (<span class="hljs-variable">isLogin</span>) &#123;<br>    <span class="hljs-function"><span class="hljs-title">goToDestination</span>();</span><br><span class="hljs-function"> &#125; <span class="hljs-variable"><span class="hljs-keyword">else</span></span> &#123;</span><br><span class="hljs-function">    <span class="hljs-title">goToLogin</span>();</span><br><span class="hljs-function"> &#125;</span><br></code></pre></td></tr></table></figure><p>在每次跳转页面的时候都需要进行是否登录的判断，这样的代码显然有很大的弊端。而ARouter为我们提供了面向切面的登录拦截功能，ARouter的文档上给了我们一个例子：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-comment">// 比较经典的应用就是在跳转过程中处理登陆事件，这样就不需要在目标页重复做登陆检查</span><br><span class="hljs-comment">// 拦截器会在跳转之间执行，多个拦截器会按优先级顺序依次执行</span><br><span class="hljs-variable">@Interceptor</span>(priority = <span class="hljs-number">8</span>, name = <span class="hljs-string">&quot;测试用拦截器&quot;</span>)<br>public class TestInterceptor implements IInterceptor &#123;<br>    <span class="hljs-variable">@Override</span><br>    public void process(Postcard postcard, InterceptorCallback callback) &#123;<br>    ...<br>    <span class="hljs-selector-tag">callback</span><span class="hljs-selector-class">.onContinue</span>(postcard);  <span class="hljs-comment">// 处理完成，交还控制权</span><br>    <span class="hljs-comment">// callback.onInterrupt(new RuntimeException(&quot;我觉得有点异常&quot;));      // 觉得有问题，中断路由流程</span><br><br>    <span class="hljs-comment">// 以上两种至少需要调用其中一种，否则不会继续路由</span><br>    &#125;<br><br>    <span class="hljs-variable">@Override</span><br>    public void init(Context context) &#123;<br>    <span class="hljs-comment">// 拦截器的初始化，会在sdk初始化的时候调用该方法，仅会调用一次</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果你按着官方文档上这样写，那么你大概率会碰到很多问题。列举如下：<br><strong>如何处理有些页面需要登录拦截，有些页面不需要登录拦截？</strong><br>如果你添加了拦截器，那么在每次路由跳转时都会优先走到拦截器中，在拦截器的process()方法中你可以通过判断当前是否登录来决定是否继续该路由操作，如果已经登录，那么直接通过 callback.onContinue(postcard)继续当前路由，而如果没有登录，那么就将目的页面修改为登录页。但是，不要忘了，添加拦截器后所有的路由操作都会优先走到这里，而我们的需求是只有需要用户权限的时候才需要跳转到登录页，否则即使没有登录依然可以跳转到目的页。此时我们应该怎么办？<br>如果你仔细的看了ARouter的开发文档，你可能注意到在@Route的注解有一个int类型的extras参数。如此我们便可以通过这个参数来对Activity进行标记是否需要登录：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-meta">@Route</span>(path = <span class="hljs-type">PATH_TEST</span>, extras = <span class="hljs-type">IGNORE_LOGIN</span>)<br>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BaseTitleCompatActivity</span> </span>&#123;&#125;<br></code></pre></td></tr></table></figure><p>接下来，在拦截器中可以拿到extras参数，以此来确定该页面是否需要登录：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">if</span>(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">UserInfoTools</span>.</span></span>is<span class="hljs-constructor">Login()</span><span class="hljs-operator"> || </span>IGNORE_LOGIN<span class="hljs-operator"> == </span>postcard.get<span class="hljs-constructor">Extra()</span>) &#123;  <span class="hljs-comment">//  已经登录或者不需要拦截的情况</span><br> <span class="hljs-comment">//  继续当前路由</span><br>      callback.on<span class="hljs-constructor">Continue(<span class="hljs-params">postcard</span>)</span>;<br> &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">// 未登录且需要登录的情况</span><br>    <span class="hljs-comment">//路由到登录页面</span><br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ARouter</span>.</span></span>get<span class="hljs-constructor">Instance()</span>.build(RoutingTable.PATH_GUEST_LOGIN).navigation<span class="hljs-literal">()</span>;<br>    ...<br>  &#125;<br></code></pre></td></tr></table></figure><p>到这里这个问题解决了，但是当你兴致勃勃的运行起来App,在未登录的情况下点击跳转到需要用户权限的页面，你憧憬着跳转页面会被拦截到登录页，但是你又被无情的事实打脸了。竟然页面毫无反应？于是你断点、打Log发现ARouter.getInstance().build(RoutingTable.PATH_GUEST_LOGIN).navigation()这句代码确实执行了，但是为什么没有跳转到登录页？于是你苦思冥想，突然灵光一闪，哇！是因为这一句路由也会走到了拦截器里，如此岂不成了一个死循环。于是你Google如何解决，发现原来需要调用greenChannel()来避免出现死循环。于是有了如下代码：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">if</span>(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">UserInfoTools</span>.</span></span>is<span class="hljs-constructor">Login()</span><span class="hljs-operator"> || </span>IGNORE_LOGIN<span class="hljs-operator"> == </span>postcard.get<span class="hljs-constructor">Extra()</span>) &#123;  <span class="hljs-comment">//  已经登录或者不需要拦截的情况</span><br> <span class="hljs-comment">//  继续当前路由</span><br>      callback.on<span class="hljs-constructor">Continue(<span class="hljs-params">postcard</span>)</span>;<br> &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">// 未登录且需要登录的情况</span><br>    <span class="hljs-comment">//路由到登录页面</span><br>   <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ARouter</span>.</span></span>get<span class="hljs-constructor">Instance()</span>.build(RoutingTable.PATH_GUEST_LOGIN).green<span class="hljs-constructor">Channel()</span>.navigation<span class="hljs-literal">()</span>;<br>    ...<br>  &#125;<br></code></pre></td></tr></table></figure><p>修改之后你怀着和刚才一样的心情兴致勃勃的运行起来App,心想，这次一定没问题。好！点击按钮….竟然成功跳转到了登录页面。于是你兴奋起来，疯狂的点击这些页面，发现都没问题。可是…当你点了几次之后突然发现，页面跳转无效了！！你简直不敢相信自己的眼睛，刚才明明是好好的…于是你在此陷入了沉思。<br>好吧，这次直接公布答案了，那是因为你需要将原来的路由打断，而之所以前几次有效大概猜测是因为greenChannel()去开启了多个channel，而ARouter的channel是有限的，因此在点击几次之后路由再次失效了。于是修改后代码如下：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">if</span>(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">UserInfoTools</span>.</span></span>is<span class="hljs-constructor">Login()</span><span class="hljs-operator"> || </span>IGNORE_LOGIN<span class="hljs-operator"> == </span>postcard.get<span class="hljs-constructor">Extra()</span>) &#123;  <span class="hljs-comment">//  已经登录或者不需要拦截的情况</span><br> <span class="hljs-comment">//  继续当前路由</span><br>      callback.on<span class="hljs-constructor">Continue(<span class="hljs-params">postcard</span>)</span>;<br> &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">// 未登录且需要登录的情况</span><br>    <span class="hljs-comment">//路由到登录页面</span><br>   <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ARouter</span>.</span></span>get<span class="hljs-constructor">Instance()</span>.build(RoutingTable.PATH_GUEST_LOGIN).green<span class="hljs-constructor">Channel()</span>.navigation<span class="hljs-literal">()</span>;<br>   callback.on<span class="hljs-constructor">Interrupt(<span class="hljs-params">null</span>)</span>;<br>  &#125;<br></code></pre></td></tr></table></figure><p>关于登录拦截看似简单，实则使用时候竟然会碰到这么多问题！相信第一次使用时都会被虐的掉眼泪。</p><h2 id="2-处理一个Activity对应多个路径的情况"><a href="#2-处理一个Activity对应多个路径的情况" class="headerlink" title="2.处理一个Activity对应多个路径的情况"></a>2.处理一个Activity对应多个路径的情况</h2><p>在某些情况可能出现一个页面对应多个路径的情况。出现这种情况的原因可能是前期路由没有规划好，导致后边版本的路由路径做了修改。从而出现了一个Activity对应多个页面的情况。为了兼容旧版路由，我们不得不处理这种情况。但是，Route的注解中path是唯一的，并不能通过@Route注解解决一个Activity对应多个路径的情况。此时就需要用到ARouter的重写URL的功能。只需要实现PathReplaceService 接口，在重写的方法中对URI或者Path进行替换即可，注意，这个类一定要加@Route注解。代码参考如下：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">@<span class="hljs-constructor">Route(<span class="hljs-params">path</span> = <span class="hljs-string">&quot;/lost/service&quot;</span>)</span><br>public <span class="hljs-keyword">class</span> ARouterLostReplaceService implements PathReplaceService &#123;<br>    @Override<br>    public String <span class="hljs-keyword">for</span><span class="hljs-constructor">String(String <span class="hljs-params">path</span>)</span> &#123;<span class="hljs-comment">//对于path处理与uri类似</span><br>        return path;<br>    &#125;<br><br>    @Override<br>    public Uri <span class="hljs-keyword">for</span><span class="hljs-constructor">Uri(Uri <span class="hljs-params">uri</span>)</span> &#123;<br>        String path = uri.get<span class="hljs-constructor">Path()</span>;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">PATH_LOST1</span>.</span></span>equals(path)) &#123;<br>            uri = replace<span class="hljs-constructor">UriPath(<span class="hljs-params">uri</span>, PATH_REAL1)</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">PATH_LOST2</span>.</span></span>equals(path)) &#123;<br>            uri = replace<span class="hljs-constructor">UriPath(<span class="hljs-params">uri</span>, PATH_REAL2)</span>;<br>        &#125;<br>        return uri;<br>    &#125;<br><br>    @Override<br>    public void init(Context context) &#123;<br><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 替换URI中的path</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param uri 被替换的uri</span><br><span class="hljs-comment">     * @param path 要替换的path</span><br><span class="hljs-comment">     * @return 替换后的uri</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Uri replace<span class="hljs-constructor">UriPath(Uri <span class="hljs-params">uri</span>, String <span class="hljs-params">path</span>)</span> &#123;<br>        StringBuilder resultUrl = <span class="hljs-keyword">new</span> <span class="hljs-constructor">StringBuilder(<span class="hljs-params">uri</span>.<span class="hljs-params">getScheme</span>()</span> + <span class="hljs-string">&quot;://&quot;</span> + uri.get<span class="hljs-constructor">Host()</span> + path);<br>        String<span class="hljs-literal">[]</span> split = uri.<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span>.split(<span class="hljs-string">&quot;\\?&quot;</span>);<br>        <span class="hljs-keyword">if</span>(split.length &gt;= <span class="hljs-number">2</span>) &#123;<br>            resultUrl.append(<span class="hljs-string">&quot;?&quot;</span>).append(split<span class="hljs-literal">[<span class="hljs-number">1</span>]</span>);<br>        &#125;<br>        return <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Uri</span>.</span></span>parse(resultUrl.<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-ARouter全局降级策略"><a href="#3-ARouter全局降级策略" class="headerlink" title="3.ARouter全局降级策略"></a>3.ARouter全局降级策略</h2><p>在路由跳转时可能会出现找不到Path对应页面的情况，对于这种情况可以通过实现DegradeService 接口来处理，同样这个类也必须要添加@Route注解。这样当路由跳转时找不到路径就会走到这个类的onLost方法中，此时就可以在这个方法中来做相应的处理了。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-comment">// 实现DegradeService接口，并加上一个Path内容任意的注解即可</span><br><span class="hljs-variable">@Route</span>(path = <span class="hljs-string">&quot;/lost/path&quot;</span>)<br>public class DegradeServiceImpl implements DegradeService &#123;<br><span class="hljs-variable">@Override</span><br>public void onLost(Context context, Postcard postcard) &#123;<br>    <span class="hljs-comment">//  可以在此处统一处理，比如跳转到首页</span><br>&#125;<br><br><span class="hljs-variable">@Override</span><br>public void init(Context context) &#123;<br><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="四、通过浏览器跳转到App对应页面"><a href="#四、通过浏览器跳转到App对应页面" class="headerlink" title="四、通过浏览器跳转到App对应页面"></a>四、通过浏览器跳转到App对应页面</h1><h2 id="1-Schema协议"><a href="#1-Schema协议" class="headerlink" title="1.Schema协议"></a>1.Schema协议</h2><p>很多人对于Schema协议比较陌生，但是如果说URL大家一定都非常熟悉。其实URL就是一种Schema协议。Schema协议通常由四部分组成：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs inform7"><span class="hljs-comment">[scheme]</span>://<span class="hljs-comment">[host]</span>/<span class="hljs-comment">[path]</span>?<span class="hljs-comment">[query]</span><br>scheme：表示协议名称<br>host：Schema所作用的地址域<br>path：Schema指定的路径<br>query：携带的参数<br></code></pre></td></tr></table></figure><p>拿百度搜索的URL来举例子：<a href="https://www.baidu.com/s?wd=%E8%A6%81%E6%90%9C%E7%B4%A2%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97%E3%80%82%E8%BF%99%E4%B8%AAURL%E4%B8%8ESchema%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB%E5%A6%82%E4%B8%8B">https://www.baidu.com/s?wd=要搜索的关键字。这个URL与Schema协议的对应关系如下</a></p><blockquote><p>schema:：https<br>host： <a href="http://www.baidu.com/">www.baidu.com</a><br>path： /s<br>query：wd=要搜索的关键字</p></blockquote><p>了解了Schema协议后，其实我们完全可以按照Schema协议的格式来自定义一个Schema链接，如下：</p><blockquote><p>myApp://<a href="http://www.myapp.com/main/home?id=1">www.myApp.com/main/home?id=1</a></p><p>我们自己定义的Schema链接的对应关系为：<br> schema:：myApp<br>host：<a href="http://www.myapp.com/">www.myApp.com</a><br>path：/main/home<br>query：id=1</p></blockquote><h2 id="2-通过Schema链接打开Activity"><a href="#2-通过Schema链接打开Activity" class="headerlink" title="2.通过Schema链接打开Activity"></a>2.通过Schema链接打开Activity</h2><p>通过浏览器打开App其实就是通过Schema链接来实现的。我们就以上一节中自定义的Schema链接为例来实现浏览器打开App。首先在项目中添加一个RouterActivity，RouterActivity在AndroidManifest中的配置如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">activity</span></span><br><span class="hljs-tag">      <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;.activity.RouterActivity&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">android:configChanges</span>=<span class="hljs-string">&quot;orientation|keyboardHidden|screenSize&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">android:screenOrientation</span>=<span class="hljs-string">&quot;portrait&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">intent-filter</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">action</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.intent.action.VIEW&quot;</span> /&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">category</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.intent.category.DEFAULT&quot;</span> /&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">category</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.intent.category.BROWSABLE&quot;</span> /&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">data</span> <span class="hljs-attr">android:scheme</span>=<span class="hljs-string">&quot;myApp&quot;</span> /&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">intent-filter</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">activity</span>&gt;</span><br></code></pre></td></tr></table></figure><p>我们在AndroidManifest中为RouterActivity添加了schema，此时在HTML中写入以下代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;myApp://www.myApp.com/main/home?id=1&quot;</span>&gt;</span>打开APP<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><p>通过点击HTML页面的”打开App”便可启动RouterActivity。并且RouterActivity启动后可以通过Intent获取到启动的URI。代码如下：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">  #RouterActivity<br> <br>@Override<br>   protected void on<span class="hljs-constructor">Create(Bundle <span class="hljs-params">data</span>)</span> &#123;<br>       super.on<span class="hljs-constructor">Create(<span class="hljs-params">data</span>)</span>;<br>       Uri launchUri = get<span class="hljs-constructor">Intent()</span>.get<span class="hljs-constructor">Data()</span>;<br>       dispatch<span class="hljs-constructor">RouterUri(<span class="hljs-params">launchUri</span>)</span>;<br>   &#125;<br></code></pre></td></tr></table></figure><p>至此，我们已经可以通过App来打开项目的RouterActivity。</p><h2 id="3-通过路由跳转到目的页面"><a href="#3-通过路由跳转到目的页面" class="headerlink" title="3.通过路由跳转到目的页面"></a>3.通过路由跳转到目的页面</h2><p>上一节中我们通过HTML打开了RouterActivity，并在RouterActivity中拿到了跳转的URI，那么接下来我们便可以根据URI的信息打开对应的页面了。但是在开启路由跳转之前为了保险起见需要对URI进行一些校验。详细代码如下：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">private</span> void dispatch<span class="hljs-constructor">RouterUri(Uri <span class="hljs-params">launchUri</span>)</span> &#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">RoutingTable</span>.</span></span>is<span class="hljs-constructor">ValidRouterUri(<span class="hljs-params">launchUri</span>)</span>) &#123;  <span class="hljs-comment">//判断是否是合法的URI，这里只有URI携带了Path才算合法</span><br>            <span class="hljs-keyword">if</span>(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">App</span>.</span></span>is<span class="hljs-constructor">RootActivityLaunched()</span>) &#123; <span class="hljs-comment">// app已启动</span><br>                <span class="hljs-keyword">if</span>(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">RoutingTable</span>.</span></span>is<span class="hljs-constructor">WxUri(<span class="hljs-params">launchUri</span>)</span>) &#123; <span class="hljs-comment">//如果是微信的URI那么目的地是要跳转到小程序的（此处为项目中的需求）</span><br>                    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">RoutingTable</span>.</span></span><span class="hljs-keyword">open</span><span class="hljs-constructor">MiniProgram(<span class="hljs-params">this</span>, <span class="hljs-params">launchUri</span>)</span>;<br>                    finish<span class="hljs-literal">()</span>;<br>                    return;<br>                &#125;<br>                <span class="hljs-comment">//通过ARouter路由到目的页面</span><br>               <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ARouter</span>.</span></span>get<span class="hljs-constructor">Instance()</span>.build(launchUri).navigation<span class="hljs-literal">()</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">// app未启动, 保存router uri, 幷尝试启动app</span><br>               <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">SharedPreferUtil</span>.</span></span>put(Constants.ROUTER_URI, launchUri.<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span>);<br>               launch<span class="hljs-constructor">App()</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">// 走到此处可能是因为URI没有携带Path，即并非要跳转目的页面，而是要启动APP  。因此直接启动App即可</span><br>            launch<span class="hljs-constructor">App()</span>;<br>        &#125;<br>        finish<span class="hljs-literal">()</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p>上面代码中，我们对URI做了一系列校验，根据不同的URI做不同的处理。同时我们应该也注意到了，如果APP已经启动了，那么就可以直接跳转对应的页面了，而如果App没有启动，那么则是先将URI保存到了SharedPreference中，接着启动了App。那么此时App启动后会在MainActivity中读取SharedPreference中的配置，如果读取到URI的信息，那么就先将此数据从SharedPreference中移除，然后通过ARouter跳转到URI指定的页面去。MainActivity中的部分代码如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-meta">#MainActivity</span><br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">resumeRoute</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-comment">// Continue for interrupted router uri</span><br>        String interruptedLaunchUriString =<br>                Configuration.<span class="hljs-keyword">get</span>(Constants.INTERRUPTED_ROUTER_URI, <span class="hljs-literal">null</span>);<br>         <span class="hljs-comment">//移除SharedPreference中的URI，避免下次打开MainActivity错误跳转</span><br>        SharedPreferUtil.<span class="hljs-keyword">remove</span>(Constants.ROUTER_URI);<br>        Uri launchUri = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">if</span>(interruptedLaunchUriString != <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// Activity未启动的情况下 通过外部Scheme跳转非MainActivity</span><br>            launchUri = Uri.parse(interruptedLaunchUriString);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(launchUri == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><span class="hljs-comment">//通过路由跳转到URI对应的页面</span><br>        ARouter.getInstance().build(launchUri).navigation();<br>    &#125;<br></code></pre></td></tr></table></figure><p>关于ARouter的路由方案所涉及的内容至此已经全部讲完了。</p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Arouter</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>自定义View之弹性滑动的LockView</title>
    <link href="/2018/07/14/15.Custom%20view--LockView/"/>
    <url>/2018/07/14/15.Custom%20view--LockView/</url>
    
    <content type="html"><![CDATA[<p>本篇文章我们来实现一个带有弹性滑动效果的自定义View。当然，文章的侧重点是自定义View但也会涉及到View的事件分发以及一些其他方面的知识，例如使用Scroller实现带有阻尼效果的弹性滑动。因此，我相信看完这篇文章你不仅能学到自定义View的相关知识，还会了解到View的事件分发！还是老规矩，看下最终实现效果。<br><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/8/4/16c5ae3be83cc87f~tplv-t2oaga2asx-zoom-in-crop-mark:1512:0:0:0.awebp" alt="在这里插入图片描述"><br> 分析图中效果会发现其核心功能类似于一个简单的下拉刷新、上拉加载的框架，但又有区别。开始前还是先来罗列一下几个核心步骤，如下：<br>      一. 明确需求，确定对外开放的接口<br>      二. 分析滑动效果，初步实现控件布局<br>      三. 关于滑动，不得不说的事件分发<br>      四. 实现自定义CircleWaveView</p><h2 id="一-明确需求，确定对外开放接口"><a href="#一-明确需求，确定对外开放接口" class="headerlink" title="一. 明确需求，确定对外开放接口"></a>一. 明确需求，确定对外开放接口</h2><p>首先应该明确控件的需求，确定有哪些功能，然后做针对性开发。这里先贴出该控件的使用方法，也是为了更好地认识控件的需求。<br><strong>1.布局文件添加</strong></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs vim">&lt;RelativeLayout xmln<span class="hljs-variable">s:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span><br>    xmln<span class="hljs-variable">s:tools</span>=<span class="hljs-string">&quot;http://schemas.android.com/tools&quot;</span><br>    android:layout_width=<span class="hljs-string">&quot;match_parent&quot;</span><br>    android:layout_height=<span class="hljs-string">&quot;match_parent&quot;</span><br>    tool<span class="hljs-variable">s:context</span>=<span class="hljs-string">&quot;.MainActivity&quot;</span>&gt;<br><br>    &lt;<span class="hljs-keyword">com</span>.zhpan.lockview.<span class="hljs-keyword">view</span>.LockView<br>        android:id=<span class="hljs-string">&quot;@+id/lock_view&quot;</span><br>        android:layout_width=<span class="hljs-string">&quot;wrap_content&quot;</span><br>        android:layout_height=<span class="hljs-string">&quot;wrap_content&quot;</span><br>        android:layout_centerInParent=<span class="hljs-string">&quot;true&quot;</span> /&gt;<br><br>&lt;/RelativeLayout&gt;<br></code></pre></td></tr></table></figure><p><strong>2.设置操作的监听事件。</strong>代码如下：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">mLockView</span><span class="hljs-selector-class">.setOnLockOperateListener</span>(new OnLockOperateListener() &#123;<br>     <span class="hljs-variable">@Override</span><br>     public void onLockPrepared() &#123;<span class="hljs-comment">//  上锁就绪</span><br><br>     &#125;<br><br>     <span class="hljs-variable">@Override</span><br>     public void onUnLockPrepared() &#123;<span class="hljs-comment">//  开锁就绪</span><br><br>     &#125;<br><br>     <span class="hljs-variable">@Override</span><br>     public void onLockStart() &#123;<span class="hljs-comment">// 开始上锁</span><br><br>     &#125;<br><br>     <span class="hljs-variable">@Override</span><br>     public void onUnlockStart() &#123;<span class="hljs-comment">// 开始开锁</span><br><br>     &#125;<br><br>     <span class="hljs-variable">@Override</span><br>     public void onNotPrepared() &#123;<span class="hljs-comment">// 上下滑动距离未达到就绪状态</span><br><br>     &#125;<br> &#125;);<br></code></pre></td></tr></table></figure><p><strong>3.对外开放接口</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// 设置蓝牙是否连接</span><br>mLockView.set<span class="hljs-constructor">BluetoothConnect(<span class="hljs-params">false</span>)</span>;<br><span class="hljs-comment">// 设置上锁状态</span><br>mLockView.set<span class="hljs-constructor">LockState(<span class="hljs-params">isLock</span>)</span>;<br><span class="hljs-comment">// 设置View是否可以滑动</span><br>mLockView.set<span class="hljs-constructor">CanSlide(<span class="hljs-params">true</span>)</span><br><span class="hljs-comment">// 设置滑动阻尼大小</span><br>mLockView.set<span class="hljs-constructor">Damping(1.7)</span><br><span class="hljs-comment">// 设置View中心文字</span><br>mLockView.set<span class="hljs-constructor">Text(<span class="hljs-string">&quot;已上锁&quot;</span>)</span>;<br><span class="hljs-comment">// 设置中心大圆的颜色</span><br>mLockView.setCircleColor<br><span class="hljs-comment">// 开启心跳动画</span><br>mLockView.start<span class="hljs-constructor">Wave()</span>;<br><span class="hljs-comment">// 停止心跳动画</span><br>mLockView.stop<span class="hljs-constructor">Wave()</span>;<br><span class="hljs-comment">// 是否正在搜索/连接蓝牙</span><br>mLockView.connecting(<span class="hljs-literal">true</span>);<br><br><span class="hljs-comment">// 点击事件监听（只有在未连接蓝牙时有效）</span><br>mLockView.set<span class="hljs-constructor">OnClickListener(<span class="hljs-params">new</span> View.OnClickListener()</span> &#123;<br>         @Override<br>         public void on<span class="hljs-constructor">Click(View <span class="hljs-params">v</span>)</span> &#123;<br><br>         &#125;<br>     &#125;);<br></code></pre></td></tr></table></figure><p>我们来总结下控件中需要实现的功能：</p><ol><li>控件布局的实现。</li><li>蓝牙未连接时，只能点击而不能滑动。</li><li>点击事件以及连接中动画。</li><li>更改连接状态。</li><li>实现上下弹性滑动，且需要控制滑动边界。</li><li>滑动事件回掉。</li><li>心跳动画实现。</li></ol><p>以上几点就是我们要完成的核心功能，有了需求之后就直接进入主题来实现我们想要的效果吧。</p><h2 id="二、分析控件，初步实现控件布局"><a href="#二、分析控件，初步实现控件布局" class="headerlink" title="二、分析控件，初步实现控件布局"></a>二、分析控件，初步实现控件布局</h2><p>分析上图的效果发现，中间的View是可滑动的，且覆盖在上下小圆点的上面。对于这种效果直接继承View实现起来会不太方便。因此我们可以想到利用自定义ViewGroup来布局页面。这么一来使开发简单了许多。那么接下来先新建一个layout_oval_lock.xml的布局为文件，并采用FrameLayout来布局控件，这样就实现了层次叠加效果，FrameLayout内部是两个自定义View，我们可以暂且搁置不管，后面会讲到如何实现。布局文件如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs stylus">&lt;FrameLayout xmlns:android=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span><br>    android:layout_width=<span class="hljs-string">&quot;match_parent&quot;</span><br>    android:layout_height=<span class="hljs-string">&quot;match_parent&quot;</span><br>    xmlns:app=<span class="hljs-string">&quot;http://schemas.android.com/apk/res-auto&quot;</span><br>    android:orientation=<span class="hljs-string">&quot;vertical&quot;</span>&gt;<br><br>    &lt;com<span class="hljs-selector-class">.zhpan</span><span class="hljs-selector-class">.lockview</span><span class="hljs-selector-class">.view</span>.CircleView<br>        android:id=<span class="hljs-string">&quot;@+id/green_cv&quot;</span><br>        android:layout_width=<span class="hljs-string">&quot;15dp&quot;</span><br>        android:layout_height=<span class="hljs-string">&quot;15dp&quot;</span><br>        android:layout_marginTop=<span class="hljs-string">&quot;110dp&quot;</span><br>        app:circle_color=<span class="hljs-string">&quot;@color/green&quot;</span><br>        android:layout_gravity=<span class="hljs-string">&quot;center&quot;</span>/&gt;<br><br>    &lt;com<span class="hljs-selector-class">.zhpan</span><span class="hljs-selector-class">.lockview</span><span class="hljs-selector-class">.view</span>.CircleView<br>        android:id=<span class="hljs-string">&quot;@+id/red_cv&quot;</span><br>        android:layout_width=<span class="hljs-string">&quot;15dp&quot;</span><br>        android:layout_height=<span class="hljs-string">&quot;15dp&quot;</span><br>        app:circle_color=<span class="hljs-string">&quot;@color/red&quot;</span><br>        android:layout_marginTop=<span class="hljs-string">&quot;-110dp&quot;</span><br>        android:layout_gravity=<span class="hljs-string">&quot;center&quot;</span>/&gt;<br><br>    &lt;com<span class="hljs-selector-class">.zhpan</span><span class="hljs-selector-class">.lockview</span><span class="hljs-selector-class">.view</span>.CircleWaveView<br>        android:id=<span class="hljs-string">&quot;@+id/circle_wave_view&quot;</span><br>        android:layout_width=<span class="hljs-string">&quot;220dp&quot;</span><br>        android:layout_height=<span class="hljs-string">&quot;300dp&quot;</span><br>        android:layout_gravity=<span class="hljs-string">&quot;center&quot;</span><br>        android:<span class="hljs-attribute">padding</span>=<span class="hljs-string">&quot;20dp&quot;</span>/&gt;<br><br>    &lt;ProgressBar<br>        android:id=<span class="hljs-string">&quot;@+id/progress&quot;</span><br>        android:layout_width=<span class="hljs-string">&quot;30dp&quot;</span><br>        android:layout_height=<span class="hljs-string">&quot;30dp&quot;</span><br>        android:<span class="hljs-attribute">visibility</span>=<span class="hljs-string">&quot;gone&quot;</span><br>        android:indeterminateTint=<span class="hljs-string">&quot;@color/white&quot;</span><br>        android:layout_gravity=<span class="hljs-string">&quot;center&quot;</span>/&gt;<br>&lt;/FrameLayout&gt;<br></code></pre></td></tr></table></figure><p>接下来新建一个LockView类并继承FrameLayout。LockView与 上边layout_oval_lock的布局文件关联，并重写相应的方法。代码如下：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public <span class="hljs-constructor">LockView(Context <span class="hljs-params">context</span>)</span> &#123;<br>        this(context, null);<br>    &#125;<br><br>    public <span class="hljs-constructor">LockView(Context <span class="hljs-params">context</span>, AttributeSet <span class="hljs-params">attrs</span>)</span> &#123;<br>        this(context, attrs, <span class="hljs-number">0</span>);<br>    &#125;<br><br>    public <span class="hljs-constructor">LockView(Context <span class="hljs-params">context</span>, AttributeSet <span class="hljs-params">attrs</span>, <span class="hljs-params">int</span> <span class="hljs-params">defStyleAttr</span>)</span> &#123;<br>        super(context, attrs, defStyleAttr);<br>        init(context, attrs);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> void init(Context context, AttributeSet attrs) &#123;<br>        mTouchSlop = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ViewConfiguration</span>.</span></span>get(context).get<span class="hljs-constructor">ScaledTouchSlop()</span>;<br>        View view = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">View</span>.</span></span>inflate(context, <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">R</span>.</span></span>layout.layout_oval_lock, this);<br>        mCircleWaveView = (CircleWaveView) view.find<span class="hljs-constructor">ViewById(R.<span class="hljs-params">id</span>.<span class="hljs-params">circle_wave_view</span>)</span>;<br>        mCircleView = (CircleView) view.find<span class="hljs-constructor">ViewById(R.<span class="hljs-params">id</span>.<span class="hljs-params">green_cv</span>)</span>;<br>        distance = ((LayoutParams) mCircleView.get<span class="hljs-constructor">LayoutParams()</span>).topMargin;<br>        mProgressBar = (ProgressBar) view.find<span class="hljs-constructor">ViewById(R.<span class="hljs-params">id</span>.<span class="hljs-params">progress</span>)</span>;<br>        mScroller = mCircleWaveView.get<span class="hljs-constructor">Scroller()</span>;<br>        mContext = context;<br>        mCircleWaveView.set<span class="hljs-constructor">OnClickListener(<span class="hljs-params">new</span> OnClickListener()</span> &#123;<br>            @Override<br>            public void on<span class="hljs-constructor">Click(View <span class="hljs-params">v</span>)</span> &#123;<br>            &#125;<br>        &#125;);<br>    &#125;<br><br>    @Override<br>    protected void on<span class="hljs-constructor">Layout(<span class="hljs-params">boolean</span> <span class="hljs-params">changed</span>, <span class="hljs-params">int</span> <span class="hljs-params">l</span>, <span class="hljs-params">int</span> <span class="hljs-params">t</span>, <span class="hljs-params">int</span> <span class="hljs-params">r</span>, <span class="hljs-params">int</span> <span class="hljs-params">b</span>)</span> &#123;<br>        View view = get<span class="hljs-constructor">ChildAt(0)</span>;<br>        view.layout(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, get<span class="hljs-constructor">MeasuredWidth()</span>, get<span class="hljs-constructor">MeasuredHeight()</span>);<br>    &#125;<br><br>    @Override<br>    protected void on<span class="hljs-constructor">SizeChanged(<span class="hljs-params">int</span> <span class="hljs-params">w</span>, <span class="hljs-params">int</span> <span class="hljs-params">h</span>, <span class="hljs-params">int</span> <span class="hljs-params">oldw</span>, <span class="hljs-params">int</span> <span class="hljs-params">oldh</span>)</span> &#123;<br>        super.on<span class="hljs-constructor">SizeChanged(<span class="hljs-params">w</span>, <span class="hljs-params">h</span>, <span class="hljs-params">oldw</span>, <span class="hljs-params">oldh</span>)</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="三-关于滑动，不得不说的事件分发"><a href="#三-关于滑动，不得不说的事件分发" class="headerlink" title="三.关于滑动，不得不说的事件分发"></a>三.关于滑动，不得不说的事件分发</h2><p>接下来就要来处理中心View的滑动了！说到滑动，避免不了的就应该想到Android中View的事件分发，那么对于滑动事件的处理我们需要重写三个方法。我想很多小伙伴肯定已经想到了！没错，就是事件分发的三个核心方法：dispatchTouchEvent、onInterceptTouchEvent、以及onTouchEvent。我觉得还是先简单来了解一下这三个方法吧，因为它确实挺重要的。</p><ul><li><strong><em>dispatchTouchEvent</em></strong>   顾名思义，这个方法就是用来对事件进行分发的。如果事件传递到了当前View，那么这个方法一定会被调用。它的返回结果受当前View的onTouchEvent或下级View的dispatchTouchEvent方法的影响，表示是否消费当前事件。</li><li><strong><em>onInterceptTouchEvent</em></strong>  这个方法在dispatchTouchEvent方法的内部被调用，用来表示是否拦截某个事件。返回结果表示是否拦截当前事件。需要注意的是View并没有该方法，这个方法仅仅存在于ViewGroup中！如果事件传递到View中，那么会直接调用该View的onTouchEvent方法。</li><li><strong><em>onTouchEvent</em></strong>  这个方法在dispatchTouchEvent方法中调用。用来处理点击事件。返回结果表示是否消费当前事件。View中的onTouchEvent方法默认会消费事件，只有当设置clickable和longClickable为false时则不会消费该事件。</li></ul><p><strong>首先来看LockView中重写的dispatchTouchEvent方法中的代码</strong>：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">dispatchTouchEvent</span><span class="hljs-params">(MotionEvent ev)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!canSlide)<br>        <span class="hljs-keyword">switch</span> (ev.getAction()) &#123;<br>            <span class="hljs-keyword">case</span> ACTION_DOWN:<br>                timestamp = System.currentTimeMillis();<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> ACTION_UP:<br>                <span class="hljs-keyword">if</span> (System.currentTimeMillis() - timestamp &lt; 500) &#123;<br>                    performClick();<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>                &#125;<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.<span class="hljs-title">dispatchTouchEvent</span><span class="hljs-params">(ev)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面提到，只要有事件传递到当前的ViewGroup那么dispatchTouchEvent就会首先被调用！因此在这个方法里先来判断当前是否是可以滑动状态（蓝牙未连接时不可滑动）。如果不可以滑动，那么就去处理点击事件，我们认为ACTION_DOWN和ACTION_UP之间间隔小于500毫秒就是一次点击事件，那么就在此处调用performClick方法并消费掉当前事件，如果间隔大于500毫秒，不认为是点击事件，那么紧接着就去调用父类的dispatchTouchEvent方法。如果当前可以滑动，那么同样调用父类的dispatchTouchEvent方法来处理。</p><p><strong>接下来我们看重写的onInterceptTouchEvent方法</strong></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><br>@Override<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span>ean onInterceptTouchEvent(MotionEvent ev) &#123;<br>        <span class="hljs-built_in">bool</span>ean <span class="hljs-built_in">int</span>ercepted = <span class="hljs-literal">true</span>;<br>        <span class="hljs-built_in">int</span> y = (<span class="hljs-built_in">int</span>) ev.getY();<br>        <span class="hljs-keyword">switch</span> (ev.getAction()) &#123;<br>            <span class="hljs-keyword">case</span> ACTION_DOWN:<br>                <span class="hljs-built_in">int</span>ercepted = <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">if</span> (!mScroller.isFinished()) &#123;<br>                    mScroller.abortAnimation();<br>                &#125;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> MotionEvent.ACTION_MOVE:<br>                <span class="hljs-keyword">if</span> (Math.abs(y - mLastY) &gt; mTouchSlop) &#123;<br>                    <span class="hljs-built_in">int</span>ercepted = <span class="hljs-literal">true</span>;<br>                &#125;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> MotionEvent.ACTION_UP:<br>                <span class="hljs-built_in">int</span>ercepted = <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        mLastY = y;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">int</span>ercepted;<br>    &#125;<br></code></pre></td></tr></table></figure><p>在这个方法中我们重点来看ACTION_MOVE的时候，在这里先判断了滑动的距离是否大于mTouchSlop，这个值是认为滑动的最小距离，当大于这个值的时候就认为是滑动了。那么看此时intercepted返回了true，表示要拦截这个事件！此处拦截了这个滑动事件会怎么样呢？答案是当前View中的onTouchEvent方法被调用了！现在请将我们的目光聚焦到onTouchEvent方法中，注意前方高能！</p><p><strong>核心中最核心的onTouchEvent方法</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><br>    @Override<br>    public boolean on<span class="hljs-constructor">TouchEvent(MotionEvent <span class="hljs-params">event</span>)</span> &#123;<br><br>        <span class="hljs-built_in">int</span> y = (<span class="hljs-built_in">int</span>) event.get<span class="hljs-constructor">Y()</span>;<br>        <span class="hljs-built_in">int</span> scrollY = mCircleWaveView.get<span class="hljs-constructor">ScrollY()</span>;<br>        switch (event.get<span class="hljs-constructor">Action()</span>) &#123;<br>            case ACTION_DOWN:<br>                <span class="hljs-keyword">if</span> (!mScroller.is<span class="hljs-constructor">Finished()</span>) &#123;<br>                    mScroller.abort<span class="hljs-constructor">Animation()</span>;<br>                &#125;<br>                break;<br>            case MotionEvent.ACTION_MOVE:<br>                <span class="hljs-keyword">if</span> (!canSlide) &#123;<br>                    return super.on<span class="hljs-constructor">TouchEvent(<span class="hljs-params">event</span>)</span>;<br>                &#125;<br>                <span class="hljs-built_in">int</span> deltaY = (<span class="hljs-built_in">int</span>) ((mLastY - y)<span class="hljs-operator"> / </span>damping);<br>                <span class="hljs-keyword">if</span> (mCircleWaveView.get<span class="hljs-constructor">ScrollY()</span> &gt; mTouchSlop) &#123;<br>                    mOption = Option.LOCK;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mCircleWaveView.get<span class="hljs-constructor">ScrollY()</span> &lt; -mTouchSlop) &#123;<br>                    mOption = Option.UNLOCK;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>abs(scrollY) &gt; (distance - mCircleWaveView.get<span class="hljs-constructor">Radius()</span> + mCircleView.get<span class="hljs-constructor">Radius()</span>)) &#123;<br>                    <span class="hljs-keyword">if</span> (mOption != null) &#123;<br>                        switch (mOption) &#123;<br>                            case LOCK:<br>                                <span class="hljs-keyword">if</span> (mOnLockOperateListener != null)<br>                                    mOnLockOperateListener.on<span class="hljs-constructor">LockPrepared()</span>;<br>                                mCircleWaveView.set<span class="hljs-constructor">LockPrepared(<span class="hljs-params">true</span>)</span>;<br>                                break;<br>                            case UNLOCK:<br>                                <span class="hljs-keyword">if</span> (mOnLockOperateListener != null)<br>                                    mOnLockOperateListener.on<span class="hljs-constructor">UnLockPrepared()</span>;<br>                                mCircleWaveView.set<span class="hljs-constructor">UnLockPrePared(<span class="hljs-params">true</span>)</span>;<br>                                break;<br>                        &#125;<br>                    &#125;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    mCircleWaveView.set<span class="hljs-constructor">UnLockPrePared(<span class="hljs-params">false</span>)</span>;<br>                    mCircleWaveView.set<span class="hljs-constructor">LockPrepared(<span class="hljs-params">false</span>)</span>;<br>                    mOnLockOperateListener.on<span class="hljs-constructor">NotPrepared()</span>;<br>                   <span class="hljs-comment">/* if (isLock()) &#123;</span><br><span class="hljs-comment">                        mCircleWaveView.setText(mContext.getResources().getString(R.string.device_control_unlock));</span><br><span class="hljs-comment">                    &#125; else &#123;</span><br><span class="hljs-comment">                        mCircleWaveView.setText(mContext.getResources().getString(R.string.device_control_lock));</span><br><span class="hljs-comment">                    &#125;*/</span><br><span class="hljs-comment">//                    isOperating = false;</span><br>                &#125;<br><br>                <span class="hljs-comment">/**</span><br><span class="hljs-comment">                 * 控制滑动边界</span><br><span class="hljs-comment">                 */</span><br>                <span class="hljs-built_in">int</span> border = (distance - mCircleWaveView.get<span class="hljs-constructor">Radius()</span> + mCircleView.get<span class="hljs-constructor">Radius()</span>) +<br>                        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">DensityUtils</span>.</span></span>dp2px(mContext, <span class="hljs-number">25</span>);<span class="hljs-comment">//  可上下滑动的最大距离</span><br>                <span class="hljs-comment">//  当前上下滑动的距离</span><br>                <span class="hljs-built_in">int</span> slideHeight = deltaY + mCircleWaveView.get<span class="hljs-constructor">ScrollY()</span>;<br>                <span class="hljs-keyword">if</span> (slideHeight &gt; border) &#123;<br>                    mCircleWaveView.scroll<span class="hljs-constructor">To(0, <span class="hljs-params">border</span>)</span>;<br>                    return <span class="hljs-literal">true</span>;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (slideHeight + border &lt; <span class="hljs-number">0</span>) &#123;<br>                    mCircleWaveView.scroll<span class="hljs-constructor">To(0, -<span class="hljs-params">border</span>)</span>;<br>                    return <span class="hljs-literal">true</span>;<br>                &#125;<br>                mCircleWaveView.scroll<span class="hljs-constructor">By(0, <span class="hljs-params">deltaY</span>)</span>;<br>                break;<br>            case MotionEvent.ACTION_UP:<br>                mCircleWaveView.set<span class="hljs-constructor">UnLockPrePared(<span class="hljs-params">false</span>)</span>;<br>                mCircleWaveView.set<span class="hljs-constructor">LockPrepared(<span class="hljs-params">false</span>)</span>;<br>                scrollY = mCircleWaveView.get<span class="hljs-constructor">ScrollY()</span>;<br>                <span class="hljs-keyword">if</span> (<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>abs(scrollY) &gt; (distance - mCircleWaveView.get<span class="hljs-constructor">Radius()</span> + mCircleView.get<span class="hljs-constructor">Radius()</span>)<span class="hljs-operator"> &amp;&amp; </span>mOption != null) &#123;<br>                    switch (mOption) &#123;<br>                        case LOCK:<br>                            <span class="hljs-keyword">if</span> (mOnLockOperateListener != null)<br>                                mOnLockOperateListener.on<span class="hljs-constructor">LockStart()</span>;<br>                            break;<br>                        case UNLOCK:<br>                            <span class="hljs-keyword">if</span> (mOnLockOperateListener != null)<br>                                mOnLockOperateListener.on<span class="hljs-constructor">UnlockStart()</span>;<br>                            break;<br>                    &#125;<br>                &#125;<br>                mCircleWaveView.smooth<span class="hljs-constructor">Scroll(0, 0)</span>;<br>                break;<br>        &#125;<br>        mLastY = y;<br>        return super.on<span class="hljs-constructor">TouchEvent(<span class="hljs-params">event</span>)</span>;<br>    &#125;<br><br></code></pre></td></tr></table></figure><p>看到这个方法中这么多代码不知道各位是否已经懵逼？（好吧，我承认，这地方代码写的确实比较乱）不过没关系，其实细细分析来还是不难理解的！同样，我们选择比较重要的点来看。首先来看ACTION_MOVE的时候，在这里先判断了是否可以滑动（其实不可以滑动的情况下应该不会走到这个方法，但是为了严谨还是加了判断），如果不能滑动则下边的逻辑全都不会再走了。接下来<br>通过判断滑动的方向来确定是要开锁还是上锁，并根据滑动距离来给出回调处理。即当中心圆CircleWaveView向上或向下滑动并完全覆盖到上/下的小圆点时则会回掉上锁就绪或者开锁就绪（onLockPrepared、onUnLockPrepared）的方法。此时释放CircleWaveView，则会回调开锁或者上锁（onLockStart、onUnlockStart）的方法。如果CircleWaveView在完全覆盖到上/下的小圆点的状态下，再向反方向滑动至未完全覆盖小圆点，此时则会回掉未就绪（onNotPrepared）的方法。下边贴一下回调接口，一共五个方法，如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span>  <span class="hljs-title">OnLockOperateListener</span> &#123;<br>   <span class="hljs-comment">// 上锁就绪</span><br>   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onLockPrepared</span>(<span class="hljs-params"></span>)</span>;<br>   <span class="hljs-comment">// 开锁就绪</span><br>   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onUnLockPrepared</span>(<span class="hljs-params"></span>)</span>;<br>   <span class="hljs-comment">// 开始上锁</span><br>   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onLockStart</span>(<span class="hljs-params"></span>)</span>;<br>   <span class="hljs-comment">// 开始开锁</span><br>   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onUnlockStart</span>(<span class="hljs-params"></span>)</span>;<br>   <span class="hljs-comment">// 未就绪</span><br>   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onNotPrepared</span>(<span class="hljs-params"></span>)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来是通过一系列计算来控制CircleWaveView的滑动边界。思路大致如此：首先根据CircleWaveView和上下小圆的位置来计算出可上下滑动的最大距离border。然后计算当CircleWaveView滑动的距离超过border时就强制将其滚动到border位置，已达到固定的效果。代码如下：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 控制滑动边界</span><br><span class="hljs-comment">     */</span><br>   <span class="hljs-built_in">int</span> border = (distance - mCircleWaveView.get<span class="hljs-constructor">Radius()</span> + mCircleView.get<span class="hljs-constructor">Radius()</span>) +<br>                       <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">DensityUtils</span>.</span></span>dp2px(mContext, <span class="hljs-number">25</span>);<span class="hljs-comment">//  可上下滑动的最大距离</span><br>   <span class="hljs-built_in">int</span> deltaY = (<span class="hljs-built_in">int</span>) ((mLastY - y)<span class="hljs-operator"> / </span>damping);<br>   <span class="hljs-comment">//  当前上下滑动的距离</span><br>   <span class="hljs-built_in">int</span> slideHeight = deltaY + mCircleWaveView.get<span class="hljs-constructor">ScrollY()</span>;<br>   <span class="hljs-keyword">if</span> (slideHeight &gt; border) &#123;<br>        mCircleWaveView.scroll<span class="hljs-constructor">To(0, <span class="hljs-params">border</span>)</span>;<br>        return <span class="hljs-literal">true</span>;<br>       &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (slideHeight + border &lt; <span class="hljs-number">0</span>) &#123;<br>         mCircleWaveView.scroll<span class="hljs-constructor">To(0, -<span class="hljs-params">border</span>)</span>;<br>         return <span class="hljs-literal">true</span>;<br>       &#125;<br>   mCircleWaveView.scroll<span class="hljs-constructor">By(0, <span class="hljs-params">deltaY</span>)</span>;<br></code></pre></td></tr></table></figure><p>然后是实现CircleWaveView的弹性滑动，这里我们给CircleWaveView加了一个弹性滑动和阻尼效果。弹性滑动是在CircleWaveView中通过Scroller来实现的，CircleWaveView暴漏出来smoothScroll的弹性滑动接口供在LockView中调用。这点我们在后面讲解CircleWaveView时再说。而阻尼滑动则是将原滑动距离除以阻尼系数以减小滑动距离从而产生阻尼效果。<br>最后来看ACTION_UP，同样是根据Y轴滑动距离与滑动方向回掉对应的方法，并将CircleWaveView恢复到原位。代码如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">scrollY</span> <span class="hljs-string">=</span> <span class="hljs-string">mCircleWaveView.getScrollY();</span><br><span class="hljs-string">if</span> <span class="hljs-string">(Math.abs(scrollY)</span> <span class="hljs-string">&gt;</span> <span class="hljs-string">(distance</span> <span class="hljs-bullet">-</span> <span class="hljs-string">mCircleWaveView.getRadius()</span> <span class="hljs-string">+</span> <span class="hljs-string">mCircleView.getRadius())</span> <span class="hljs-string">&amp;&amp;</span> <span class="hljs-string">mOption</span> <span class="hljs-type">!=</span> <span class="hljs-literal">null</span><span class="hljs-string">)</span> &#123;<br>   <span class="hljs-string">switch</span> <span class="hljs-string">(mOption)</span> &#123;<br>         <span class="hljs-attr">case LOCK:</span><br>              <span class="hljs-string">if</span> <span class="hljs-string">(mOnLockOperateListener</span> <span class="hljs-type">!=</span> <span class="hljs-literal">null</span><span class="hljs-string">)</span><br>                   <span class="hljs-string">mOnLockOperateListener.onLockStart();</span><br>          <span class="hljs-string">break;</span><br>          <span class="hljs-attr">case UNLOCK:</span><br>              <span class="hljs-string">if</span> <span class="hljs-string">(mOnLockOperateListener</span> <span class="hljs-type">!=</span> <span class="hljs-literal">null</span><span class="hljs-string">)</span><br>                   <span class="hljs-string">mOnLockOperateListener.onUnlockStart();</span><br>          <span class="hljs-string">break;</span><br>    &#125;<br><span class="hljs-string">mCircleWaveView.smoothScroll(0</span>, <span class="hljs-number">0</span><span class="hljs-string">);</span><br></code></pre></td></tr></table></figure><h2 id="四-实现自定义CircleWaveView"><a href="#四-实现自定义CircleWaveView" class="headerlink" title="四. 实现自定义CircleWaveView"></a>四. 实现自定义CircleWaveView</h2><p>关于自定义CircleWaveView就不具体来讲了，因为关于自定义View都是一样的步骤。这里我们只选取几个重要的地方来说。1.CircleWaveView中内容的绘制。2.关于弹性滑动的实现。3.心跳动画的实现以及状态改变的扩散动画。</p><p><strong>1.CircleWaveView中内容的绘制。</strong></p><p><strong>绘制主体圆。</strong>主要分为几种情况：<br>a.蓝牙未连接，且未能获取到网络数据，背景色为灰色。<br>b.蓝牙未连接，且能获取到网络数据，背景色为淡绿色或淡红色。<br>c.蓝牙已连接，开锁状态为绿色，未开锁状态为红色。<br>d.上拉上锁就绪状态为深红色，下拉开锁就绪状态为深绿色。</p><p>结合以上需求有如下代码：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">private</span> void draw<span class="hljs-constructor">Circle(Canvas <span class="hljs-params">canvas</span>)</span> &#123;<br>        mPaint.set<span class="hljs-constructor">Color(<span class="hljs-params">circleColor</span>)</span>;<br>        <span class="hljs-built_in">int</span> verticalCenter = get<span class="hljs-constructor">Height()</span><span class="hljs-operator"> / </span><span class="hljs-number">2</span>;<br>        <span class="hljs-built_in">int</span> horizontalCenter = get<span class="hljs-constructor">Width()</span><span class="hljs-operator"> / </span><span class="hljs-number">2</span>;<br>        <span class="hljs-built_in">int</span> mRadius = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>min(verticalCenter, horizontalCenter) - <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>min(verticalCenter, horizontalCenter)<span class="hljs-operator"> / </span><span class="hljs-number">5</span>;<br>        radius = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>min(verticalCenter, horizontalCenter) - <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>min(verticalCenter, horizontalCenter)<span class="hljs-operator"> / </span><span class="hljs-number">5</span>;<br>        <span class="hljs-keyword">if</span> (transforming) &#123;<br>            mPaint.set<span class="hljs-constructor">Color(<span class="hljs-params">getResources</span>()</span>.get<span class="hljs-constructor">Color(R.<span class="hljs-params">color</span>.<span class="hljs-params">green</span>)</span>);<br>            canvas.draw<span class="hljs-constructor">Circle(<span class="hljs-params">mPieCenterX</span>, <span class="hljs-params">mPieCenterY</span>, <span class="hljs-params">mRadius</span>, <span class="hljs-params">mPaint</span>)</span>;<br>            mRadius = isLock ? transformDelta : mRadius - transformDelta;<br>            mPaint.set<span class="hljs-constructor">Color(<span class="hljs-params">getResources</span>()</span>.get<span class="hljs-constructor">Color(R.<span class="hljs-params">color</span>.<span class="hljs-params">red</span>)</span>);<br>            canvas.draw<span class="hljs-constructor">Circle(<span class="hljs-params">mPieCenterX</span>, <span class="hljs-params">mPieCenterY</span>, <span class="hljs-params">mRadius</span>, <span class="hljs-params">mPaint</span>)</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            mRadius = mRadius - waveDelta;<br>            <span class="hljs-keyword">if</span> (!isBluetoothConnect) &#123;<br>                <span class="hljs-keyword">if</span> (isNoNetData) &#123;<br>                    mPaint.set<span class="hljs-constructor">Color(<span class="hljs-params">getColor</span>(R.<span class="hljs-params">color</span>.<span class="hljs-params">gray</span>)</span>);<br>                &#125; <span class="hljs-keyword">else</span><br>                    mPaint.set<span class="hljs-constructor">Color(<span class="hljs-params">isLock</span> ? <span class="hljs-params">getColor</span>(R.<span class="hljs-params">color</span>.<span class="hljs-params">redLight</span>)</span> : get<span class="hljs-constructor">Color(R.<span class="hljs-params">color</span>.<span class="hljs-params">greenLight</span>)</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (isLockPrepared) &#123;<br>                    mPaint.set<span class="hljs-constructor">Color(<span class="hljs-params">getColor</span>(R.<span class="hljs-params">color</span>.<span class="hljs-params">redDark</span>)</span>);<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isUnLockPrePared) &#123;<br>                    mPaint.set<span class="hljs-constructor">Color(<span class="hljs-params">getColor</span>(R.<span class="hljs-params">color</span>.<span class="hljs-params">greenDark</span>)</span>);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    mPaint.set<span class="hljs-constructor">Color(<span class="hljs-params">isLock</span> ? <span class="hljs-params">getColor</span>(R.<span class="hljs-params">color</span>.<span class="hljs-params">red</span>)</span> : get<span class="hljs-constructor">Color(R.<span class="hljs-params">color</span>.<span class="hljs-params">green</span>)</span>);<br>                &#125;<br>            &#125;<br>            canvas.draw<span class="hljs-constructor">Circle(<span class="hljs-params">mPieCenterX</span>, <span class="hljs-params">mPieCenterY</span>, <span class="hljs-params">mRadius</span>, <span class="hljs-params">mPaint</span>)</span>;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p><strong>绘制CircleWaveView中上下箭头。</strong>  关于箭头绘制，注释部分是通过Path来绘制的，但是发现效果不太好，绘制三角形圆角比较麻烦，所以后台改为了直接在canvas上绘制Bitmap来实现。代码如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">//</span>  <span class="hljs-string">绘制圆中两个三角</span><br>    <span class="hljs-string">private</span> <span class="hljs-string">void</span> <span class="hljs-string">drawTriangle(Canvas</span> <span class="hljs-string">canvas)</span> &#123;<br>        <span class="hljs-string">int</span> <span class="hljs-string">left</span> <span class="hljs-string">=</span> <span class="hljs-string">(mWidth</span> <span class="hljs-bullet">-</span> <span class="hljs-string">arrowUp.getWidth())</span> <span class="hljs-string">/</span> <span class="hljs-number">2</span><span class="hljs-string">;</span><br>        <span class="hljs-string">canvas.drawBitmap(arrowUp</span>, <span class="hljs-string">left</span>, <span class="hljs-string">mHeight</span> <span class="hljs-string">/</span> <span class="hljs-number">2</span> <span class="hljs-bullet">-</span> <span class="hljs-string">radius</span> <span class="hljs-string">+</span> <span class="hljs-string">dp13</span>, <span class="hljs-string">mPaint);</span><br>        <span class="hljs-string">canvas.drawBitmap(arrowDown</span>, <span class="hljs-string">left</span>, <span class="hljs-string">mHeight</span> <span class="hljs-string">/</span> <span class="hljs-number">2</span> <span class="hljs-string">+</span> <span class="hljs-string">radius</span> <span class="hljs-bullet">-</span> <span class="hljs-string">dp13</span> <span class="hljs-bullet">-</span> <span class="hljs-string">arrowDown.getHeight()</span>, <span class="hljs-string">mPaint);</span><br>        <span class="hljs-string">/*int</span> <span class="hljs-string">radius</span> <span class="hljs-string">=</span> <span class="hljs-string">Math.min(mHeight</span>, <span class="hljs-string">mWidth)</span> <span class="hljs-string">/</span> <span class="hljs-number">2</span> <span class="hljs-bullet">-</span> <span class="hljs-string">Math.min(mHeight</span>, <span class="hljs-string">mWidth)</span> <span class="hljs-string">/</span> <span class="hljs-number">8</span><span class="hljs-string">;</span><br>        <span class="hljs-string">mPaintTrangel.setStyle(Paint.Style.FILL);</span><br>        <span class="hljs-string">mPaintTrangel.setShadowLayer(4</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-string">Color.GRAY);</span><br>        <span class="hljs-string">//</span>  <span class="hljs-string">三角形顶点到圆边的距离</span><br>        <span class="hljs-string">int</span> <span class="hljs-string">h0</span> <span class="hljs-string">=</span> <span class="hljs-string">DensityUtils.dp2px(mContext</span>, <span class="hljs-number">10</span><span class="hljs-string">);</span><br>        <span class="hljs-string">//</span>  <span class="hljs-string">三角形高</span><br>        <span class="hljs-string">int</span> <span class="hljs-string">h1</span> <span class="hljs-string">=</span> <span class="hljs-string">DensityUtils.dp2px(mContext</span>, <span class="hljs-number">12</span><span class="hljs-string">);</span><br>        <span class="hljs-string">//</span>  <span class="hljs-string">三角形底边长</span><br>        <span class="hljs-string">int</span> <span class="hljs-string">w</span> <span class="hljs-string">=</span> <span class="hljs-string">DensityUtils.dp2px(mContext</span>, <span class="hljs-number">14</span><span class="hljs-string">);</span><br>        <span class="hljs-string">mPaintTrangel.setColor(getResources().getColor(R.color.transparent_33));</span><br>        <span class="hljs-string">mPath.moveTo(mWidth</span> <span class="hljs-string">/</span> <span class="hljs-number">2</span>, <span class="hljs-string">mHeight</span> <span class="hljs-string">/</span> <span class="hljs-number">2</span> <span class="hljs-bullet">-</span> <span class="hljs-string">(radius</span> <span class="hljs-bullet">-</span> <span class="hljs-string">h0));</span><br>        <span class="hljs-string">mPath.lineTo(mWidth</span> <span class="hljs-string">/</span> <span class="hljs-number">2</span> <span class="hljs-bullet">-</span> <span class="hljs-string">w</span>, <span class="hljs-string">mHeight</span> <span class="hljs-string">/</span> <span class="hljs-number">2</span> <span class="hljs-bullet">-</span> <span class="hljs-string">(radius</span> <span class="hljs-bullet">-</span> <span class="hljs-string">h1</span> <span class="hljs-bullet">-</span> <span class="hljs-string">h0));</span><br>        <span class="hljs-string">mPath.lineTo(mWidth</span> <span class="hljs-string">/</span> <span class="hljs-number">2</span> <span class="hljs-string">+</span> <span class="hljs-string">w</span>, <span class="hljs-string">mHeight</span> <span class="hljs-string">/</span> <span class="hljs-number">2</span> <span class="hljs-bullet">-</span> <span class="hljs-string">(radius</span> <span class="hljs-bullet">-</span> <span class="hljs-string">h1</span> <span class="hljs-bullet">-</span> <span class="hljs-string">h0));</span><br>        <span class="hljs-string">canvas.drawPath(mPath</span>, <span class="hljs-string">mPaintTrangel);</span><br>        <span class="hljs-string">mPaintTrangel.setShadowLayer(4</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-3</span>, <span class="hljs-string">Color.GRAY);</span><br>        <span class="hljs-string">mPath.moveTo(mWidth</span> <span class="hljs-string">/</span> <span class="hljs-number">2</span>, <span class="hljs-string">mHeight</span> <span class="hljs-string">/</span> <span class="hljs-number">2</span> <span class="hljs-string">+</span> <span class="hljs-string">(radius</span> <span class="hljs-bullet">-</span> <span class="hljs-string">h0));</span><br>        <span class="hljs-string">mPath.lineTo(mWidth</span> <span class="hljs-string">/</span> <span class="hljs-number">2</span> <span class="hljs-bullet">-</span> <span class="hljs-string">w</span>, <span class="hljs-string">mHeight</span> <span class="hljs-string">/</span> <span class="hljs-number">2</span> <span class="hljs-string">+</span> <span class="hljs-string">(radius</span> <span class="hljs-bullet">-</span> <span class="hljs-string">h1</span> <span class="hljs-bullet">-</span> <span class="hljs-string">h0));</span><br>        <span class="hljs-string">mPath.lineTo(mWidth</span> <span class="hljs-string">/</span> <span class="hljs-number">2</span> <span class="hljs-string">+</span> <span class="hljs-string">w</span>, <span class="hljs-string">mHeight</span> <span class="hljs-string">/</span> <span class="hljs-number">2</span> <span class="hljs-string">+</span> <span class="hljs-string">(radius</span> <span class="hljs-bullet">-</span> <span class="hljs-string">h1</span> <span class="hljs-bullet">-</span> <span class="hljs-string">h0));</span><br>        <span class="hljs-string">canvas.drawPath(mPath</span>, <span class="hljs-string">mPaintTrangel);*/</span><br>    &#125;<br></code></pre></td></tr></table></figure><p><strong>绘制CircleWaveView中心的文字</strong> 中心文字分为两种情况：当蓝牙未连接时，显示为两行。当蓝牙已连接时显示为一行。绘制思路是先计算出中心基线，然后再来分情况实现。代码如下：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">//  绘制圆中的文字</span><br>    <span class="hljs-keyword">private</span> void draw<span class="hljs-constructor">Text(Canvas <span class="hljs-params">canvas</span>)</span> &#123;<br>        <span class="hljs-keyword">if</span> (isConnecting) return;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">TextUtils</span>.</span></span>is<span class="hljs-constructor">Empty(<span class="hljs-params">mText</span>)</span>) &#123; <span class="hljs-comment">//   绘制单行文字</span><br>            String text = mContext.get<span class="hljs-constructor">Resources()</span>.get<span class="hljs-constructor">String(R.<span class="hljs-params">string</span>.<span class="hljs-params">ble_not_connect</span>)</span>;<br>            canvas.draw<span class="hljs-constructor">Text(<span class="hljs-params">text</span>, <span class="hljs-params">mPieCenterX</span>, <span class="hljs-params">getBaseline</span>(<span class="hljs-params">text</span>)</span>, mPaintText);<br>            return;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (isBluetoothConnect) &#123;   <span class="hljs-comment">//   绘制单行文字</span><br>            canvas.draw<span class="hljs-constructor">Text(<span class="hljs-params">mText</span>, <span class="hljs-params">mPieCenterX</span>, <span class="hljs-params">getBaseline</span>(<span class="hljs-params">mText</span>)</span>, mPaintText);<br>        &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-comment">//   绘制两行文字</span><br>            String text = mContext.get<span class="hljs-constructor">Resources()</span>.get<span class="hljs-constructor">String(R.<span class="hljs-params">string</span>.<span class="hljs-params">ble_not_connect</span>)</span>;<br>            <span class="hljs-built_in">int</span> baseline = get<span class="hljs-constructor">Baseline(<span class="hljs-params">text</span>)</span>;<br>            canvas.draw<span class="hljs-constructor">Text(<span class="hljs-params">text</span>, <span class="hljs-params">mPieCenterX</span>, <span class="hljs-params">baseline</span> - 30, <span class="hljs-params">mPaintText</span>)</span>;<br>            mPaintText.set<span class="hljs-constructor">TextSize(DensityUtils.<span class="hljs-params">dp2px</span>(<span class="hljs-params">mContext</span>, 12)</span>);<br>            canvas.draw<span class="hljs-constructor">Text(<span class="hljs-params">mText</span>, <span class="hljs-params">mPieCenterX</span>, <span class="hljs-params">baseline</span> + 30, <span class="hljs-params">mPaintText</span>)</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> get<span class="hljs-constructor">Baseline(String <span class="hljs-params">text</span>)</span> &#123;<br>        mPaintText.set<span class="hljs-constructor">TextSize(<span class="hljs-params">mTextSize</span>)</span>;<br>        mPaintText.get<span class="hljs-constructor">TextBounds(<span class="hljs-params">text</span>, 0, <span class="hljs-params">text</span>.<span class="hljs-params">length</span>()</span>, bounds);<br>        Paint.FontMetricsInt fontMetricsInt = mPaintText.get<span class="hljs-constructor">FontMetricsInt()</span>;<br>        return (get<span class="hljs-constructor">MeasuredHeight()</span> - fontMetricsInt.bottom + fontMetricsInt.top)<span class="hljs-operator"> / </span><span class="hljs-number">2</span><br>                - fontMetricsInt.top;<br>    &#125;<br></code></pre></td></tr></table></figure><p><strong>2.关于弹性滑动的实现。</strong> 关于滑动，通常我们会想到用ScrollTo或ScrollBy来实现。但由于这两个方法实现滑动都是瞬间完成的，因此滑动看起来会比较生硬，体验也很不好。因此想到可以使用Scroller来做一个滑动延迟实现带有弹性效果的滑动。由于Scroller本身时无法实现滑动的，因此还必须配合computeScroll方法共同完成。这里我们封装一个smoothScroll方法，提供给LockView调用。具体代码如下：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public void smooth<span class="hljs-constructor">Scroll(<span class="hljs-params">int</span> <span class="hljs-params">destX</span>, <span class="hljs-params">int</span> <span class="hljs-params">destY</span>)</span> &#123;<br>        <span class="hljs-built_in">int</span> scrollY = get<span class="hljs-constructor">ScrollY()</span>;<br>        <span class="hljs-built_in">int</span> delta = destY - scrollY;<br>        mScroller.start<span class="hljs-constructor">Scroll(<span class="hljs-params">destX</span>, <span class="hljs-params">scrollY</span>, 0, <span class="hljs-params">delta</span>, 400)</span>;<br>        invalidate<span class="hljs-literal">()</span>;<br>    &#125;<br><br>    @Override<br>    public void compute<span class="hljs-constructor">Scroll()</span> &#123;<br>        <span class="hljs-keyword">if</span> (mScroller.compute<span class="hljs-constructor">ScrollOffset()</span>) &#123;<br>            scroll<span class="hljs-constructor">To(<span class="hljs-params">mScroller</span>.<span class="hljs-params">getCurrX</span>()</span>, mScroller.get<span class="hljs-constructor">CurrY()</span>);<br>            post<span class="hljs-constructor">Invalidate()</span>;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p><strong>3.心跳动画的实现以及状态改变的扩散动画。</strong></p><p>首先来看心跳动画的实现，这里使用属性动画，首先为ValueAnimator设置从0到1再到0的一个数值变化，并且周期时间设置为600毫秒、重复次数设置为ValueAnimator.INFINITE，即为无限次循环。通过ValueAnimator中不断变化的value来计算圆半径的大小，并通过invalidate()方法不断重绘View，从而达到一个心跳动画的效果。代码如下：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">//  开始心跳动画</span><br>public void start<span class="hljs-constructor">Wave()</span> &#123;<br>        <span class="hljs-keyword">if</span> (animator != null<span class="hljs-operator"> &amp;&amp; </span>animator.is<span class="hljs-constructor">Running()</span>)<br>            animator.<span class="hljs-keyword">end</span><span class="hljs-literal">()</span>;<br>        animator = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ValueAnimator</span>.</span></span><span class="hljs-keyword">of</span><span class="hljs-constructor">Float(0f, 1f, 0f)</span>;<br>        animator.set<span class="hljs-constructor">RepeatCount(ValueAnimator.INFINITE)</span>;<br>        animator.set<span class="hljs-constructor">RepeatMode(ValueAnimator.RESTART)</span>;<br>        animator.set<span class="hljs-constructor">Duration(600)</span>;<br><br>        animator.add<span class="hljs-constructor">UpdateListener(<span class="hljs-params">new</span> ValueAnimator.AnimatorUpdateListener()</span> &#123;<br>            @Override<br>            public void on<span class="hljs-constructor">AnimationUpdate(ValueAnimator <span class="hljs-params">animation</span>)</span> &#123;<br>                <span class="hljs-built_in">int</span> verticalCenter = get<span class="hljs-constructor">Height()</span><span class="hljs-operator"> / </span><span class="hljs-number">2</span>;<br>                <span class="hljs-built_in">int</span> horizontalCenter = get<span class="hljs-constructor">Width()</span><span class="hljs-operator"> / </span><span class="hljs-number">2</span>;<br>                waveDelta = (<span class="hljs-built_in">int</span>) (<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>min(verticalCenter, horizontalCenter)<span class="hljs-operator"> * </span>(<span class="hljs-built_in">float</span>) animation.get<span class="hljs-constructor">AnimatedValue()</span><span class="hljs-operator"> / </span><span class="hljs-number">16</span>);<br>                invalidate<span class="hljs-literal">()</span>;<br>            &#125;<br>        &#125;);<br><br>        animator.start<span class="hljs-literal">()</span>;<br>    &#125;<br> <span class="hljs-comment">//  停止心跳动画</span><br> public void stop<span class="hljs-constructor">Wave()</span> &#123;<br>        <span class="hljs-keyword">if</span> (animator != null<span class="hljs-operator"> &amp;&amp; </span>animator.is<span class="hljs-constructor">Running()</span>)<br>            animator.<span class="hljs-keyword">end</span><span class="hljs-literal">()</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p>接下来看状态改变时扩散动画的实现，其实方法和心跳动画一样，都是采用ValueAnimator动态计算绘制圆的半径，不在赘述。参考如下代码：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public void change<span class="hljs-constructor">LockState(<span class="hljs-params">final</span> <span class="hljs-params">boolean</span> <span class="hljs-params">lock</span>)</span> &#123;<br>        stop<span class="hljs-constructor">Wave()</span>;<br>        <span class="hljs-keyword">if</span> (this.isLock != lock) &#123;<br>            transforming = <span class="hljs-literal">true</span>;<br>            ValueAnimator valueAnimator = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ValueAnimator</span>.</span></span><span class="hljs-keyword">of</span><span class="hljs-constructor">Float(0f, 0.99f)</span>;<br>            valueAnimator.set<span class="hljs-constructor">Duration(500)</span>;<br>            valueAnimator.add<span class="hljs-constructor">Listener(<span class="hljs-params">new</span> Animator.AnimatorListener()</span> &#123;<br>                @Override<br>                public void on<span class="hljs-constructor">AnimationStart(Animator <span class="hljs-params">animation</span>)</span> &#123;<br><br>                &#125;<br><br>                @Override<br>                public void on<span class="hljs-constructor">AnimationEnd(Animator <span class="hljs-params">animation</span>)</span> &#123;<br>                    transforming = <span class="hljs-literal">false</span>;<br>                    isLock = lock;<br>                    invalidate<span class="hljs-literal">()</span>;<br>                &#125;<br><br>                @Override<br>                public void on<span class="hljs-constructor">AnimationCancel(Animator <span class="hljs-params">animation</span>)</span> &#123;<br>                    transforming = <span class="hljs-literal">false</span>;<br>                &#125;<br><br>                @Override<br>                public void on<span class="hljs-constructor">AnimationRepeat(Animator <span class="hljs-params">animation</span>)</span> &#123;<br><br>                &#125;<br>            &#125;);<br>            valueAnimator.add<span class="hljs-constructor">UpdateListener(<span class="hljs-params">new</span> ValueAnimator.AnimatorUpdateListener()</span> &#123;<br>                @Override<br>                public void on<span class="hljs-constructor">AnimationUpdate(ValueAnimator <span class="hljs-params">animation</span>)</span> &#123;<br>                    <span class="hljs-built_in">int</span> verticalCenter = get<span class="hljs-constructor">Height()</span><span class="hljs-operator"> / </span><span class="hljs-number">2</span>;<br>                    <span class="hljs-built_in">int</span> horizontalCenter = get<span class="hljs-constructor">Width()</span><span class="hljs-operator"> / </span><span class="hljs-number">2</span>;<br>                    transformDelta = (<span class="hljs-built_in">int</span>) ((<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>min(verticalCenter, horizontalCenter) - <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>min(verticalCenter, horizontalCenter)<span class="hljs-operator"> / </span><span class="hljs-number">6</span>)<br><span class="hljs-operator">                            * </span>(<span class="hljs-built_in">float</span>) animation.get<span class="hljs-constructor">AnimatedValue()</span>);<br>                    invalidate<span class="hljs-literal">()</span>;<br>                &#125;<br>            &#125;);<br>            valueAnimator.start<span class="hljs-literal">()</span>;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>至此，关于LockView的绘制到这里就完全结束了。回顾一下本篇文章，重讲解了自定义LockView以及弹性滑动实现，然后探讨了关于事件分发的一些知识以及使用属性动画来实现心跳和扩散效果。相信看完本篇文章的小伙伴也会有不小的收获，最后关于源码，已放在文章末尾，欢迎start、forck！</p><p> <a href="https://github.com/zhpanvip/CustomView">源码链接</a></p>]]></content>
    
    
    <categories>
      
      <category>自定义View</category>
      
    </categories>
    
    
    <tags>
      
      <tag>自定义View</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android Widget开发详解</title>
    <link href="/2018/06/21/14.Android-Widget/"/>
    <url>/2018/06/21/14.Android-Widget/</url>
    
    <content type="html"><![CDATA[<p>好久没博客更新了，本篇文章来学习一下如何实现一个Android列表小部件，效果可以参看下图：<br><img src="https://img-blog.csdnimg.cn/20200906141912101.gif#pic_center" alt="这里写图片描述"><br>这个页面如果是在App内部实现，相信只要有一点Android基础的童鞋都能很轻松写出来。但是如果放到Widget中可能就不是那么简单了。因为Widget并没有运行在我们App的进程中，而是运行在系统的SystemServer进程中。你可能会惊讶，Whf！竟然不在我们App进程中！那么是不是意味着我们也不能像在App中那样操作View控件了？答案确实如此。不过不必过于担心，为了我们能在远程进程中更新界面，Google爸爸专门为我们提供了一个RemoteViews类。从名字上看，可能会觉得RemoteViews就是一个View。但事实并非如此，RemoteViews仅仅表示的是一个View结构。它可以在远程进程中展示和更新界面。今天我们要实现的列表小部件就是基于RemoteVeiw实现的。<br>那么接下来我们来学习如何实现一个桌面Widget，我们先列出要实现Widget的几个核心步骤：</p><ul><li>widget页面布局</li><li>小部件配置信息</li><li>了解AppWidgetProvider</li><li>RemoteViewsFactory实现列表适配</li><li>点击的事件处理</li></ul><h2 id="一-实现Widget界面"><a href="#一-实现Widget界面" class="headerlink" title="一. 实现Widget界面"></a>一. 实现Widget界面</h2><p><strong>1.widget页面布局。</strong>首先创建一个布局文件layout_widget.xml，内容如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">LinearLayout</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/ll_right&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:background</span>=<span class="hljs-string">&quot;@drawable/bg_widget&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:orientation</span>=<span class="hljs-string">&quot;vertical&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">RelativeLayout</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;40dp&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:background</span>=<span class="hljs-string">&quot;#ccc&quot;</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">ImageView</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/iv_icon&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;30dp&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;30dp&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_centerVertical</span>=<span class="hljs-string">&quot;true&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_marginEnd</span>=<span class="hljs-string">&quot;5dp&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_marginStart</span>=<span class="hljs-string">&quot;5dp&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:background</span>=<span class="hljs-string">&quot;@mipmap/ic_launcher_round&quot;</span> /&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/tv_title&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_centerVertical</span>=<span class="hljs-string">&quot;true&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_toEndOf</span>=<span class="hljs-string">&quot;@id/iv_icon&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;Widget&quot;</span> /&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">LinearLayout</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_alignParentEnd</span>=<span class="hljs-string">&quot;true&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:gravity</span>=<span class="hljs-string">&quot;center_vertical&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:orientation</span>=<span class="hljs-string">&quot;horizontal&quot;</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">ProgressBar</span></span><br><span class="hljs-tag">                <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/progress_bar&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;20dp&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;20dp&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">android:indeterminateTint</span>=<span class="hljs-string">&quot;@color/colorAccent&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">android:indeterminateTintMode</span>=<span class="hljs-string">&quot;src_atop&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">android:visibility</span>=<span class="hljs-string">&quot;gone&quot;</span> /&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span></span><br><span class="hljs-tag">                <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/tv_refresh&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">android:layout_marginEnd</span>=<span class="hljs-string">&quot;15dp&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;刷新&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">android:padding</span>=<span class="hljs-string">&quot;5dp&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">android:textSize</span>=<span class="hljs-string">&quot;12sp&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">LinearLayout</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">RelativeLayout</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ListView</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/lv_device&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:columnWidth</span>=<span class="hljs-string">&quot;80dip&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:gravity</span>=<span class="hljs-string">&quot;center&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:horizontalSpacing</span>=<span class="hljs-string">&quot;4dip&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:numColumns</span>=<span class="hljs-string">&quot;auto_fit&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:verticalSpacing</span>=<span class="hljs-string">&quot;4dip&quot;</span> /&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">LinearLayout</span>&gt;</span><br></code></pre></td></tr></table></figure><p>看到布局中的ListView控件，你可能会不屑一笑，都什么年代了还在用ListView？RecyclerView才是王道吧？可是我只能说句抱歉，Widget不支持RecyclerView。对，你没看错，真的不支持。在Widget中我们没办法做到想用什么就用什么，甚至觉得原生用着不爽，自己撸一个控件出来。对不起，Widget都不支持。因此Widget也有很大的局限性。我们来看下支持在Widget中运行的有哪些控件：</p><blockquote><p>A RemoteViews object (and, consequently, an App Widget) can support the following layout classes:<br>FrameLayout<br>LinearLayout<br>RelativeLayout<br>GridLayout<br>And the following widget classes:<br>AnalogClock<br>Button<br>Chronometer<br>ImageButton<br>ImageView<br>ProgressBar<br>TextView<br>ViewFlipper<br>ListView<br>GridView<br>StackView<br>AdapterViewFlipper<br>Descendants of these classes are not supported.</p></blockquote><p>除了上述列出的几个View，其它的包括Android原生View和自定义View是都不支持在Widget中运行的。因此基于Widget页面限制我们基本就可以告别炫酷的动画效果了。</p><h2 id="二-小部件配置信息"><a href="#二-小部件配置信息" class="headerlink" title="二.小部件配置信息"></a>二.小部件配置信息</h2><p>配置信息主要是设定小部件的一些属性，比如宽高、缩放模式、更新时间间隔等。我们需要在res/xml目录下新建widget_provider.xml文件，文件名字可以任意取。文件内容如下（可做参考）：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">appwidget-provider</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:minHeight</span>=<span class="hljs-string">&quot;180dp&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:minWidth</span>=<span class="hljs-string">&quot;300dp&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:previewImage</span>=<span class="hljs-string">&quot;@drawable/ic_launcher_background&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:initialLayout</span>=<span class="hljs-string">&quot;@layout/layout_widget&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:updatePeriodMillis</span>=<span class="hljs-string">&quot;50000&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:resizeMode</span>=<span class="hljs-string">&quot;horizontal|vertical&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:widgetCategory</span>=<span class="hljs-string">&quot;home_screen&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">appwidget-provider</span>&gt;</span><br></code></pre></td></tr></table></figure><p>针对上述文件中的配置信息来做下介绍。</p><ul><li><strong><em>minHeight、minWidth</em></strong> 定义Widget的最小高度和最小宽度（Widget可以通过拉伸来调整尺寸大小）。</li><li><strong><em>previewImage</em></strong> 定义添加小部件时显示的图标。</li><li><strong><em>initialLayout</em></strong> 定义了小部件使用的布局。</li><li><strong><em>updatePeriodMillis</em></strong>定义小部件自动更新的周期，单位为毫秒。</li><li><strong><em>resizeMode</em></strong> 指定了 widget 的调整尺寸的规则。可取的值有: “horizontal”, “vertical”, “none”。”horizontal”意味着widget可以水平拉伸，“vertical”意味着widget可以竖值拉伸，“none”意味着widget不能拉伸；默认值是”none”。</li><li><strong><em>widgetCategory</em></strong> 指定了 widget 能显示的地方：能否显示在 home Screen 或 lock screen 或 两者都可以。它的取值包括：”home_screen” 和 “keyguard”。Android 4.2 引入。<br>最后，需要我们在AndroidManifest中注册AppWidgetProvider时引用该文件，使用如下：</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">receiver</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;.widget.ListWidgetProvider&quot;</span>&gt;</span><br>     ...<br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta-data</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.appwidget.provider&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:resource</span>=<span class="hljs-string">&quot;@xml/widget_provider&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">receiver</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="三-了解AppWidgetProvider类"><a href="#三-了解AppWidgetProvider类" class="headerlink" title="三.了解AppWidgetProvider类"></a>三.了解AppWidgetProvider类</h2><p>我们来简单了解下AppWidgetProvider这个类。Widget的功能均是通过AppWidgetProvider来实现的。我们跟进源码可以发现它是继承自BroadcastReceiver类，也就是一个广播接收者。上面我们提到过RemoteViews是运行在SystemServer进程中的，再结合此处我们应该可以推测小部件的事件应该是通过广播来实现的。像小部件的添加、删除、更新、启用、禁用等均是在AppWidgetProvider中通过接受广播来完成的。看AppWidgetProvider中的几个方法：</p><ul><li>onUpdate() 当Widget被添加或者被更新时会调用该方法。上边我们提到通过配置updatePeriodMillis可以定期更新Widget。但是当我们在widget的配置文件中声明了android:configure的时候，添加Widget时则不会调用onUpdate方法。</li><li>onEnable() 这个方法会在用户首次添加Widget时调用。</li><li>onAppWidgetOptionsChanged() 这个方法会在添加Widget或者改变Widget的大小时候被调用。在这个方法中我们还可以根据Widget的大小来选择性的显示或隐藏某些控件。</li><li>onDeleted(Context, int[]) 当控件被删除的时候调用该方法</li><li>onEnabled(Context) 当第一个Widget被添加的时候调用。如果用户添加了两个这个小部件，那么只有第一个添加时才会调用onEnabled.</li><li>onDisabled(Context) 当最后一个Widget实例被移除的时候调用这个方法。在这个方法中我们可以做一些清除工作，例如删掉临时的数据库等。</li><li>onReceive(Context, Intent) 当接收到广播的时候会被调用。</li></ul><p>上述方法中，我们需要着重关心一下onUpdate()方法和onReceive()方法。因为onUpdate()方法会在Widget被添加时候调用，我们可以在此时为Widget添加一View的些交互事件，例如点击事件。由于本篇我们要实现的是一个列表小部件。因此我们还需要RemoteViewsFactory这个类来适配列表数据。</p><p>先来看下ListWidgetProvider这个类中的代码：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListWidgetProvider</span> <span class="hljs-title">extends</span> <span class="hljs-title">AppWidgetProvider</span> &#123;</span><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">String</span> TAG = <span class="hljs-string">&quot;WIDGET&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">String</span> REFRESH_WIDGET = <span class="hljs-string">&quot;com.oitsme.REFRESH_WIDGET&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">String</span> COLLECTION_VIEW_ACTION = <span class="hljs-string">&quot;com.oitsme.COLLECTION_VIEW_ACTION&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">String</span> COLLECTION_VIEW_EXTRA = <span class="hljs-string">&quot;com.oitsme.COLLECTION_VIEW_EXTRA&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Handler mHandler=<span class="hljs-keyword">new</span> Handler();<br>    <span class="hljs-keyword">private</span> Runnable runnable=<span class="hljs-keyword">new</span> Runnable() &#123;<br>        @Override<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-built_in">run</span>() &#123;<br>            hideLoading(Utils.getContext());<br>            Toast.makeText(Utils.getContext(), <span class="hljs-string">&quot;刷新成功&quot;</span>, Toast.LENGTH_SHORT).show();<br>        &#125;<br>    &#125;;<br><br>    @Override<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onUpdate</span><span class="hljs-params">(Context context, AppWidgetManager appWidgetManager,</span></span><br><span class="hljs-function"><span class="hljs-params">                         <span class="hljs-keyword">int</span>[] appWidgetIds)</span> </span>&#123;<br><br>        Log.d(TAG, <span class="hljs-string">&quot;ListWidgetProvider onUpdate&quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> appWidgetId : appWidgetIds) &#123;<br>            <span class="hljs-comment">// 获取AppWidget对应的视图</span><br>            RemoteViews remoteViews = <span class="hljs-keyword">new</span> RemoteViews(context.getPackageName(), R.layout.layout_widget);<br><br>            <span class="hljs-comment">// 设置响应 “按钮(bt_refresh)” 的intent</span><br>            Intent btIntent = <span class="hljs-keyword">new</span> Intent().setAction(REFRESH_WIDGET);<br>            PendingIntent btPendingIntent = PendingIntent.getBroadcast(context, <span class="hljs-number">0</span>, btIntent, PendingIntent.FLAG_UPDATE_CURRENT);<br>            remoteViews.setOnClickPendingIntent(R.id.tv_refresh, btPendingIntent);<br><br>            <span class="hljs-comment">// 设置 “ListView” 的adapter。</span><br>            <span class="hljs-comment">// (01) intent: 对应启动 ListWidgetService(RemoteViewsService) 的intent</span><br>            <span class="hljs-comment">// (02) setRemoteAdapter: 设置 gridview的适配器</span><br>            <span class="hljs-comment">//    通过setRemoteAdapter将ListView和ListWidgetService关联起来，</span><br>            <span class="hljs-comment">//    以达到通过 ListWidgetService 更新 ListView的目的</span><br>            Intent serviceIntent = <span class="hljs-keyword">new</span> Intent(context, ListWidgetService.class);<br>            remoteViews.setRemoteAdapter(R.id.lv_device, serviceIntent);<br><br><br>            <span class="hljs-comment">// 设置响应 “ListView” 的intent模板</span><br>            <span class="hljs-comment">// 说明：“集合控件(如GridView、ListView、StackView等)”中包含很多子元素，如GridView包含很多格子。</span><br>            <span class="hljs-comment">//     它们不能像普通的按钮一样通过 setOnClickPendingIntent 设置点击事件，必须先通过两步。</span><br>            <span class="hljs-comment">//        (01) 通过 setPendingIntentTemplate 设置 “intent模板”，这是比不可少的！</span><br>            <span class="hljs-comment">//        (02) 然后在处理该“集合控件”的RemoteViewsFactory类的getViewAt()接口中 通过 setOnClickFillInIntent 设置“集合控件的某一项的数据”</span><br>            Intent gridIntent = <span class="hljs-keyword">new</span> Intent();<br><br>            gridIntent.setAction(COLLECTION_VIEW_ACTION);<br>            gridIntent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, appWidgetId);<br>            PendingIntent pendingIntent = PendingIntent.getBroadcast(context, <span class="hljs-number">0</span>, gridIntent, PendingIntent.FLAG_UPDATE_CURRENT);<br>            <span class="hljs-comment">// 设置intent模板</span><br>            remoteViews.setPendingIntentTemplate(R.id.lv_device, pendingIntent);<br>            <span class="hljs-comment">// 调用集合管理器对集合进行更新</span><br>            appWidgetManager.updateAppWidget(appWidgetId, remoteViews);<br>        &#125;<br>        super.onUpdate(context, appWidgetManager, appWidgetIds);<br>    &#125;<br><br><br>    @Override<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onReceive</span><span class="hljs-params">(Context context, Intent intent)</span> </span>&#123;<br>        <span class="hljs-keyword">String</span> action = intent.getAction();<br>        AppWidgetManager appWidgetManager = AppWidgetManager.getInstance(context);<br>        <span class="hljs-keyword">if</span> (action.equals(COLLECTION_VIEW_ACTION)) &#123;<br>            <span class="hljs-comment">// 接受“ListView”的点击事件的广播</span><br>            <span class="hljs-keyword">int</span> type = intent.getIntExtra(<span class="hljs-string">&quot;Type&quot;</span>, <span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">int</span> appWidgetId = intent.getIntExtra(AppWidgetManager.EXTRA_APPWIDGET_ID,<br>                    AppWidgetManager.INVALID_APPWIDGET_ID);<br>            <span class="hljs-keyword">int</span> index = intent.getIntExtra(COLLECTION_VIEW_EXTRA, <span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">switch</span> (type) &#123;<br>                <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>                    Toast.makeText(context, <span class="hljs-string">&quot;item&quot;</span> + index, Toast.LENGTH_SHORT).show();<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>                    Toast.makeText(context, <span class="hljs-string">&quot;lock&quot;</span>+index, Toast.LENGTH_SHORT).show();<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>                    Toast.makeText(context, <span class="hljs-string">&quot;unlock&quot;</span>+index, Toast.LENGTH_SHORT).show();<br>                    <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (action.equals(REFRESH_WIDGET)) &#123;<br>            <span class="hljs-comment">// 接受“bt_refresh”的点击事件的广播</span><br>            Toast.makeText(context, <span class="hljs-string">&quot;刷新...&quot;</span>, Toast.LENGTH_SHORT).show();<br>            <span class="hljs-keyword">final</span> AppWidgetManager mgr = AppWidgetManager.getInstance(context);<br>            <span class="hljs-keyword">final</span> ComponentName cn = <span class="hljs-keyword">new</span> ComponentName(context,ListWidgetProvider.class);<br>            ListRemoteViewsFactory.refresh();<br>            mgr.notifyAppWidgetViewDataChanged(mgr.getAppWidgetIds(cn),R.id.lv_device);<br>            mHandler.postDelayed(runnable,<span class="hljs-number">2000</span>);<br>            showLoading(context);<br>        &#125;<br>        super.<span class="hljs-built_in">onReceive</span>(context, intent);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 显示加载loading</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">showLoading</span><span class="hljs-params">(Context context)</span> </span>&#123;<br>        RemoteViews remoteViews = <span class="hljs-keyword">new</span> RemoteViews(context.getPackageName(), R.layout.layout_widget);<br>        remoteViews.setViewVisibility(R.id.tv_refresh, View.VISIBLE);<br>        remoteViews.setViewVisibility(R.id.progress_bar, View.VISIBLE);<br>        remoteViews.setTextViewText(R.id.tv_refresh, <span class="hljs-string">&quot;正在刷新...&quot;</span>);<br>        refreshWidget(context, remoteViews, <span class="hljs-literal">false</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 隐藏加载loading</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hideLoading</span><span class="hljs-params">(Context context)</span> </span>&#123;<br>        RemoteViews remoteViews = <span class="hljs-keyword">new</span> RemoteViews(context.getPackageName(), R.layout.layout_widget);<br>        remoteViews.setViewVisibility(R.id.progress_bar, View.GONE);<br>        remoteViews.setTextViewText(R.id.tv_refresh, <span class="hljs-string">&quot;刷新&quot;</span>);<br>        refreshWidget(context, remoteViews, <span class="hljs-literal">false</span>);<br>    &#125;<br><br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 刷新Widget</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">refreshWidget</span><span class="hljs-params">(Context context, RemoteViews remoteViews, <span class="hljs-keyword">boolean</span> refreshList)</span> </span>&#123;<br>        AppWidgetManager appWidgetManager = AppWidgetManager.getInstance(context);<br>        ComponentName componentName = <span class="hljs-keyword">new</span> ComponentName(context, ListWidgetProvider.class);<br>        appWidgetManager.updateAppWidget(componentName, remoteViews);<br>        <span class="hljs-keyword">if</span> (refreshList)<br>            appWidgetManager.notifyAppWidgetViewDataChanged(appWidgetManager.getAppWidgetIds(componentName), R.id.lv_device);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>针对以上代码，我们着重来看onUpdate()方法。在onUpdate()中我们主要实现了两个功能，第一个功能ListView以外的事件点击，例如点击“刷新”来更新小部件。第二个功能是适配ListView并实现ListView内部Item控件的点击事件。在这个方法中我们首先获取到了一个RemoteView的实例，这个RemoteView对应的就是我们Widget布局的View。关于点击事件的实现代码中注释写的也比较详细，在这里就不做过多解释了。重点是需要了解如何实现并适配ListView，具体实现请看下节。</p><h2 id="四-RemoteViewsFactory实现列表适配"><a href="#四-RemoteViewsFactory实现列表适配" class="headerlink" title="四.RemoteViewsFactory实现列表适配"></a>四.RemoteViewsFactory实现列表适配</h2><p>上面我们提到了RemoteViewsFactory，这个类其实可以类比为ListView的Adapter，该类存在的意义就是为了适配ListView的数据。只不过这里是把Adapter换成RemoteViews来实现的。看下ListRemoteViewsFactory中的代码：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListRemoteViewsFactory</span> <span class="hljs-title">implements</span> <span class="hljs-title">RemoteViewsService</span>.<span class="hljs-title">RemoteViewsFactory</span> &#123;</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">String</span> TAG=<span class="hljs-string">&quot;Widget&quot;</span>;<br>    <span class="hljs-keyword">private</span> Context mContext;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> mAppWidgetId;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> List&lt;Device&gt; mDevices;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 构造GridRemoteViewsFactory</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ListRemoteViewsFactory</span><span class="hljs-params">(Context context, Intent intent)</span> </span>&#123;<br>        mContext = context;<br>        mAppWidgetId = intent.getIntExtra(AppWidgetManager.EXTRA_APPWIDGET_ID,<br>                AppWidgetManager.INVALID_APPWIDGET_ID);<br>    &#125;<br><br>    @Override<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> RemoteViews <span class="hljs-title">getViewAt</span><span class="hljs-params">(<span class="hljs-keyword">int</span> <span class="hljs-built_in">position</span>)</span> </span>&#123;<br>        <span class="hljs-comment">//  HashMap&lt;String, Object&gt; map;</span><br><br>        <span class="hljs-comment">// 获取 item_widget_device.xml 对应的RemoteViews</span><br>        RemoteViews rv = <span class="hljs-keyword">new</span> RemoteViews(mContext.getPackageName(), R.layout.item_widget_device);<br><br>        <span class="hljs-comment">// 设置 第position位的“视图”的数据</span><br>        Device device = mDevices.<span class="hljs-built_in">get</span>(<span class="hljs-built_in">position</span>);<br>        <span class="hljs-comment">//  rv.setImageViewResource(R.id.iv_lock, ((Integer) map.get(IMAGE_ITEM)).intValue());</span><br>        rv.setTextViewText(R.id.tv_name, device.getName());<br><br>        <span class="hljs-comment">// 设置 第position位的“视图”对应的响应事件</span><br>        Intent fillInIntent = <span class="hljs-keyword">new</span> Intent();<br>        fillInIntent.putExtra(<span class="hljs-string">&quot;Type&quot;</span>, <span class="hljs-number">0</span>);<br>        fillInIntent.putExtra(ListWidgetProvider.COLLECTION_VIEW_EXTRA, <span class="hljs-built_in">position</span>);<br>        rv.setOnClickFillInIntent(R.id.rl_widget_device, fillInIntent);<br><br><br>        Intent lockIntent = <span class="hljs-keyword">new</span> Intent();<br>        lockIntent.putExtra(ListWidgetProvider.COLLECTION_VIEW_EXTRA, <span class="hljs-built_in">position</span>);<br>        lockIntent.putExtra(<span class="hljs-string">&quot;Type&quot;</span>, <span class="hljs-number">1</span>);<br>        rv.setOnClickFillInIntent(R.id.iv_lock, lockIntent);<br><br>        Intent unlockIntent = <span class="hljs-keyword">new</span> Intent();<br>        unlockIntent.putExtra(<span class="hljs-string">&quot;Type&quot;</span>, <span class="hljs-number">2</span>);<br>        unlockIntent.putExtra(ListWidgetProvider.COLLECTION_VIEW_EXTRA, <span class="hljs-built_in">position</span>);<br>        rv.setOnClickFillInIntent(R.id.iv_unlock, unlockIntent);<br><br>        <span class="hljs-keyword">return</span> rv;<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 初始化ListView的数据</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initListViewData</span><span class="hljs-params">()</span> </span>&#123;<br>        mDevices = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        mDevices.add(<span class="hljs-keyword">new</span> Device(<span class="hljs-string">&quot;Hello&quot;</span>, <span class="hljs-number">0</span>));<br>        mDevices.add(<span class="hljs-keyword">new</span> Device(<span class="hljs-string">&quot;Oitsme&quot;</span>, <span class="hljs-number">1</span>));<br>        mDevices.add(<span class="hljs-keyword">new</span> Device(<span class="hljs-string">&quot;Hi&quot;</span>, <span class="hljs-number">0</span>));<br>        mDevices.add(<span class="hljs-keyword">new</span> Device(<span class="hljs-string">&quot;Hey&quot;</span>, <span class="hljs-number">1</span>));<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> i;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">refresh</span><span class="hljs-params">()</span></span>&#123;<br>        i++;<br>        mDevices.add(<span class="hljs-keyword">new</span> Device(<span class="hljs-string">&quot;Refresh&quot;</span>+i, <span class="hljs-number">1</span>));<br>    &#125;<br><br>    @Override<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">()</span> </span>&#123;<br>        Log.e(TAG,<span class="hljs-string">&quot;onCreate&quot;</span>);<br>        <span class="hljs-comment">// 初始化“集合视图”中的数据</span><br>        initListViewData();<br>    &#125;<br><br>    @Override<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getCount</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 返回“集合视图”中的数据的总数</span><br>        <span class="hljs-keyword">return</span> mDevices.<span class="hljs-built_in">size</span>();<br>    &#125;<br><br>    @Override<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getItemId</span><span class="hljs-params">(<span class="hljs-keyword">int</span> <span class="hljs-built_in">position</span>)</span> </span>&#123;<br>        <span class="hljs-comment">// 返回当前项在“集合视图”中的位置</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">position</span>;<br>    &#125;<br><br>    @Override<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> RemoteViews <span class="hljs-title">getLoadingView</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> null;<br>    &#125;<br><br>    @Override<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getViewTypeCount</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 只有一类 ListView</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><br>    @Override<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasStableIds</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    @Override<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onDataSetChanged</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    @Override<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onDestroy</span><span class="hljs-params">()</span> </span>&#123;<br>        mDevices.<span class="hljs-built_in">clear</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>有了RemoteViewsFactory 还需要有RemoteViewsService才能与ListView关联起来。来看RemoteViewsService的实现类ListWidgetService，很简单，只重写了onGetViewFactory方法：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListWidgetService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RemoteViewsService</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    public <span class="hljs-type">RemoteViewsService</span>.<span class="hljs-type">RemoteViewsFactory</span> onGetViewFactory(<span class="hljs-type">Intent</span> intent) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-type">ListRemoteViewsFactory</span>(<span class="hljs-keyword">this</span>, intent);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>至此我们可以再次回到ListWidgetProvider中的onUpdate()方法，来看ListWidgetService 是如何与ListView关联到一起的了。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">//  设置 “ListView” 的adapter。</span><br><span class="hljs-comment">// (01) intent: 对应启动 ListWidgetService(RemoteViewsService) 的intent</span><br><span class="hljs-comment">// (02) setRemoteAdapter: 设置 ListView的适配器</span><br><span class="hljs-comment">//  通过setRemoteAdapter将ListView和ListWidgetService关联起来，</span><br><span class="hljs-comment">//  以达到通过 ListWidgetService 更新 ListView 的目的</span><br> Intent serviceIntent = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Intent(<span class="hljs-params">context</span>, ListWidgetService.<span class="hljs-params">class</span>)</span>;<br> remoteViews.set<span class="hljs-constructor">RemoteAdapter(R.<span class="hljs-params">id</span>.<span class="hljs-params">lv_device</span>, <span class="hljs-params">serviceIntent</span>)</span>;<br></code></pre></td></tr></table></figure><h2 id="五-点击事件处理"><a href="#五-点击事件处理" class="headerlink" title="五.点击事件处理"></a>五.点击事件处理</h2><p>Widget中事件点击以及适配ListView，想必大家都有所了解了。那么对于事件的处理我们还没有提到，例如在Widget中点击了刷新后我们不能像在App中那样给控件设置一个事件监听来在回掉方法中处理。在文章开头我们就提到了Widget是依赖广播来实现，因此我们点击了刷新后其实仅仅是发送出来一个广播。如果我们不去处理广播那么点击事件其实是没有任何意义的。因此，来看ListWidgetProvider中第二个比较重要的方法onReceive()。这个方法比较简单，只要我们对特定的广播来做相应的处理就可以了。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs verilog">@Override<br>    public <span class="hljs-keyword">void</span> onReceive(Context <span class="hljs-keyword">context</span>, Intent intent) &#123;<br>        String action = intent<span class="hljs-variable">.getAction</span>();<br>        AppWidgetManager appWidgetManager = AppWidgetManager<span class="hljs-variable">.getInstance</span>(<span class="hljs-keyword">context</span>);<br>        <span class="hljs-keyword">if</span> (action<span class="hljs-variable">.equals</span>(COLLECTION_VIEW_ACTION)) &#123;<span class="hljs-comment">//处理列表中的事件</span><br>            <span class="hljs-comment">// 接受“ListView”的点击事件的广播</span><br>            <span class="hljs-keyword">int</span> <span class="hljs-keyword">type</span> = intent<span class="hljs-variable">.getIntExtra</span>(<span class="hljs-string">&quot;Type&quot;</span>, <span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">int</span> appWidgetId = intent<span class="hljs-variable">.getIntExtra</span>(AppWidgetManager<span class="hljs-variable">.EXTRA_APPWIDGET_ID</span>,<br>                    AppWidgetManager<span class="hljs-variable">.INVALID_APPWIDGET_ID</span>);<br>            <span class="hljs-keyword">int</span> index = intent<span class="hljs-variable">.getIntExtra</span>(COLLECTION_VIEW_EXTRA, <span class="hljs-number">0</span>);<br>            switch (<span class="hljs-keyword">type</span>) &#123;<br>                <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>                    Toast<span class="hljs-variable">.makeText</span>(<span class="hljs-keyword">context</span>, <span class="hljs-string">&quot;item&quot;</span> + index, Toast<span class="hljs-variable">.LENGTH_SHORT</span>)<span class="hljs-variable">.show</span>();<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>                    Toast<span class="hljs-variable">.makeText</span>(<span class="hljs-keyword">context</span>, <span class="hljs-string">&quot;lock&quot;</span>+index, Toast<span class="hljs-variable">.LENGTH_SHORT</span>)<span class="hljs-variable">.show</span>();<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>                    Toast<span class="hljs-variable">.makeText</span>(<span class="hljs-keyword">context</span>, <span class="hljs-string">&quot;unlock&quot;</span>+index, Toast<span class="hljs-variable">.LENGTH_SHORT</span>)<span class="hljs-variable">.show</span>();<br>                    <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (action<span class="hljs-variable">.equals</span>(REFRESH_WIDGET)) &#123;<span class="hljs-comment">//处理刷新事件</span><br>            <span class="hljs-comment">// 接受“bt_refresh”的点击事件的广播</span><br>            Toast<span class="hljs-variable">.makeText</span>(<span class="hljs-keyword">context</span>, <span class="hljs-string">&quot;刷新...&quot;</span>, Toast<span class="hljs-variable">.LENGTH_SHORT</span>)<span class="hljs-variable">.show</span>();<br>            <span class="hljs-keyword">final</span> AppWidgetManager mgr = AppWidgetManager<span class="hljs-variable">.getInstance</span>(<span class="hljs-keyword">context</span>);<br>            <span class="hljs-keyword">final</span> ComponentName cn = <span class="hljs-keyword">new</span> ComponentName(<span class="hljs-keyword">context</span>,ListWidgetProvider<span class="hljs-variable">.class</span>);<br>            ListRemoteViewsFactory<span class="hljs-variable">.refresh</span>();<br>            mgr<span class="hljs-variable">.notifyAppWidgetViewDataChanged</span>(mgr<span class="hljs-variable">.getAppWidgetIds</span>(cn),R<span class="hljs-variable">.id</span><span class="hljs-variable">.lv_device</span>);<br>            mHandler<span class="hljs-variable">.postDelayed</span>(runnable,<span class="hljs-number">2000</span>);<br>            showLoading(<span class="hljs-keyword">context</span>);<br>        &#125;<br>        <span class="hljs-keyword">super</span><span class="hljs-variable">.onReceive</span>(<span class="hljs-keyword">context</span>, intent);<br>    &#125;<br></code></pre></td></tr></table></figure><p>最后，别忘了ListWidgetProvider是广播，ListWidgetService是服务，都需要我们在AndroidManifest文件中来注册：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">receiver</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;.widget.ListWidgetProvider&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">intent-filter</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">action</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.appwidget.action.APPWIDGET_UPDATE&quot;</span> /&gt;</span><br><br>            <span class="hljs-comment">&lt;!-- ListWidgetProvider接收点击ListView的响应事件 --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">action</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;com.oitsme.COLLECTION_VIEW_ACTION&quot;</span> /&gt;</span><br>            <span class="hljs-comment">&lt;!-- ListWidgetProvider接收点击bt_refresh的响应事件 --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">action</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;com.oitsme.REFRESH_WIDGET&quot;</span> /&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">action</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;com.oitsme.LOCK_ACTION&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">action</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;com.oitsme.UNLOCK_ACTION&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">intent-filter</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">meta-data</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.appwidget.provider&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:resource</span>=<span class="hljs-string">&quot;@xml/widget_provider&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">receiver</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">service</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;.widget.ListWidgetService&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:permission</span>=<span class="hljs-string">&quot;android.permission.BIND_REMOTEVIEWS&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><h2 id="六-小结"><a href="#六-小结" class="headerlink" title="六.小结"></a>六.小结</h2><p>至此关于列表小部件的讲解就完成了。只是自我感觉文章的逻辑有点乱。如果没明白，大家可以参考下面Demo源码。其实关于Widget的这个Demo其实早在几个月前就已经写好了，但由于最近项目紧再加上本身也是第一次接触Widget控件，因此直至近日才开始动笔写这篇文章。所以文章中避免不了有错误和不合理的地方，欢迎留言指正。</p><p>参考<br><a href="https://developer.android.com/guide/topics/appwidgets/">https://developer.android.com/guide/topics/appwidgets/</a></p><p><a href="https://download.csdn.net/download/qq_20521573/11659588">源码下载</a></p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Widget</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于Https的那些事儿</title>
    <link href="/2018/02/12/13.Know%20about%20https%20/"/>
    <url>/2018/02/12/13.Know%20about%20https%20/</url>
    
    <content type="html"><![CDATA[<p>由于前不久苹果公司已经强制IOS应用必须使用HTTPS协议开发，虽然Google没有强制开发者使用HTTPS，但相信不久的将来Android也会跟随IOS全面转向HTTPS。因此，HTTPS的学习也是相当重要。本篇文章涉及到的代码不多，主要内容是对HTTPS协议的讲解，最后将结合Retrofit实现HTTPS的单双向认证。</p><p>下面将通过以下几节内容来学习HTTPS。</p><ul><li>HTTPS概述</li><li>HTTPS实现原理</li><li>数字证书</li><li>Https单项认证</li><li>Https双向认证</li></ul><h2 id="一、HTTPS概述"><a href="#一、HTTPS概述" class="headerlink" title="一、HTTPS概述"></a>一、HTTPS概述</h2><p> <strong>1.什么是HTTPS？</strong><br> 我们看维基百科给HTTPS的定义：</p><blockquote><p>HTTPS（Hypertext Transfer Protocol Secure）是一种通过计算机网络进行安全通信的传输协议。HTTPS经由HTTP进行通信，但利用TLS来加密数据包。HTTPS开发的主要目的，是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。</p></blockquote><p>原来HTTPS就是在HTTP协议的基础上加入了TLS协议。目的是保证我们的数据在网络上传输的安全性。</p><blockquote><p>TLS是传输层加密协议，前身是SSL协议。由网景公司于1995年发布。后改名为TLS。常用的 TLS 协议版本有：TLS1.2, TLS1.1, TLS1.0 和 SSL3.0。其中 SSL3.0 由于 POODLE 攻击已经被证明不安全。TLS1.0 也存在部分安全漏洞，比如 RC4 和 BEAST 攻击。</p></blockquote><p>由于HTTP协议采用明文传输，我们可以通过抓包很轻松的获取到HTTP所传输的数据。因此，采用HTTP协议是不安全的。这才催生了HTTPS的诞生。HTTPS相对HTTP提供了更安全的数据传输保障。主要体现在三个方面：</p><blockquote><p>1，  内容加密。客户端到服务器的内容都是以加密形式传输，中间者无法直接查看明文内容。<br>2，  身份认证。通过校验保证客户端访问的是自己的服务器。<br>3，  数据完整性。防止内容被第三方冒充或者篡改。</p></blockquote><h2 id="二、HTTPS实现原理"><a href="#二、HTTPS实现原理" class="headerlink" title="二、HTTPS实现原理"></a>二、HTTPS实现原理</h2><p>在学习HTTPS原理之前我们先了解一下两种加密方式： 对称加密和非对称加密。<br><strong>对称加密</strong> 即加密和解密使用同一个密钥，虽然对称加密破解难度很大，但由于对称加密需要在网络上传输密钥和密文，一旦被黑客截取很容就能被破解，因此对称加密并不是一个较好的选择。<br><strong>非对称加密</strong> 即加密和解密使用不同的密钥，分别称为公钥和私钥。我们可以用公钥对数据进行加密，但必须要用私钥才能解密。在网络上只需要传送公钥，私钥保存在服务端用于解密公钥加密后的密文。但是非对称加密消耗的CPU资源非常大，效率很低，严重影响HTTPS的性能和速度。因此非对称加密也不是HTTPS的理想选择。</p><p>那么HTTPS采用了怎样的加密方式呢？其实为了提高安全性和效率HTTPS结合了对称和非对称两种加密方式。即客户端使用对称加密生成密钥（key）对传输数据进行加密，然后使用非对称加密的公钥再对key进行加密。因此网络上传输的数据是被key加密的密文和用公钥加密后的密文key，因此即使被黑客截取，由于没有私钥，无法获取到明文key，便无法获取到明文数据。所以HTTPS的加密方式是安全的。</p><p>接下来我们以TLS1.2为例来认识HTTPS的握手过程。</p><blockquote><p>1，  客户端发送 client_hello，包含一个随机数 random1。<br>2，  服务端回复 server_hello，包含一个随机数 random2，携带了证书公钥 P。<br>3，  客户端接收到 random2 之后就能够生成 premaster_secrect （对称加密的密钥）以及 master_secrect（用premaster_secret加密后的数据）。<br>4，  客户端使用证书公钥 P 将 premaster_secrect 加密后发送给服务器 (用公钥P对premaster_secret加密)。<br>5，  服务端使用私钥解密得到 premaster_secrect。又由于服务端之前就收到了随机数 1，所以服务端根据相同的生成算法，在相同的输入参数下，求出了相同的 master secrect。</p></blockquote><p>HTTPS的握手过程如下图：<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTgwMjExMTUzOTIzOTI2?x-oss-process=image/format,png" alt="这里写图片描述"></p><h2 id="三、数字证书"><a href="#三、数字证书" class="headerlink" title="三、数字证书"></a>三、数字证书</h2><p>我们上面提到了HTTPS的工作原理，通过对称加密和非对称加密实现数据的安全传输。我们也知道非对称加密过程需要用到公钥进行加密。那么公钥从何而来？其实公钥就被包含在数字证书中。数字证书通常来说是由受信任的数字证书颁发机构CA，在验证服务器身份后颁发，证书中包含了一个密钥对（公钥和私钥）和所有者识别信息。数字证书被放到服务端，具有服务器身份验证和数据传输加密功能。</p><p>除了CA机构颁发的证书之外，还有非CA机构颁发的证书和自签名证书。</p><ul><li>非CA机构即是不受信任的机构颁发的证书，理所当然这样的证书是不受信任的。</li><li>自签名证书，就是自己给自己颁发的证书。当然自签名证书也是不受信任的。</li></ul><p>例如大(chou)名(ming)鼎(zhao)鼎(zhu)的12306网站使用的就是非CA机构颁发的证书（最近发现12306购票页面已经改为CA证书了），12306的证书是由SRCA颁发，SRCA中文名叫中铁数字证书认证中心，简称中铁CA。这是个铁道部自己搞的机构，相当于是自己给自己颁发证书。因此我们访问12306时通常会看到如下情景：<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTgwMjExMTczMjQ4NjE3?x-oss-process=image/format,png" alt="这里写图片描述"></p><p>说了这么多，我们来总结一下数字证书的两个作用：</p><blockquote><p>1， 分发公钥。每个数字证书都包含了注册者生成的公钥。在 TLS握手时会通过 certificate 消息传输给客户端。<br>2， 身份授权。确保客户端访问的网站是经过 CA 验证的可信任的网站。（在自签名证书的情况下可以验证是否是我们自己的服务器）</p></blockquote><p>最后我们从<a href="http://blog.csdn.net/dd864140130/article/details/52625666">别处</a>搬来一个中间人攻击的例子，来认识证书是如何保证我们的数据安全的。<br>对于一个正常的网络请求，其流程通常如下：<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTgwMjAyMDExODI0OTQ3?x-oss-process=image/format,png" alt="这里写图片描述"><br>但是，如果有黑客在通信过程中拦截了这个请求。试想在客户端和服务端中间有一个中间人，两者之间的传输对中间人来说是透明的，那么中间人完全可以获取两端之间的任何数据并加以修改，然后转发给两端。其流程如下图：<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTgwMjAyMDEyMTIzODM2?x-oss-process=image/format,png" alt="这里写图片描述"><br>此时恶意服务端完全可以发起双向攻击：对上可以欺骗服务端，对下可以欺骗客户端，更严重的是客户端段和服务端完全感知不到已经被攻击了。这就是所谓的中间人攻击。</p><blockquote><p>中间人攻击（MITM攻击）是指，黑客拦截并篡改网络中的通信数据。又分为被动MITM和主动MITM，被动MITM只窃取通信数据而不修改，而主动MITM不但能窃取数据，还会篡改通信数据。最常见的中间人攻击常常发生在公共wifi或者公共路由上。</p></blockquote><p>现在可以看看使用证书是怎么样提高安全性，避免中间人攻击的，用一张简单的流程图来说明：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTgwMjAyMTMzNTIxNjM1?x-oss-process=image/format,png" alt="这里写图片描述"></p><h2 id="四、HTTPS单项认证"><a href="#四、HTTPS单项认证" class="headerlink" title=" 四、HTTPS单项认证"></a> 四、HTTPS单项认证</h2><p>所谓单项认证只要服务端配置证书，客户端在请求服务端时验证服务器的证书即可。我们上述讲到的内容其实都是说的HTTPS单项认证。通常来说对于安全性要求不高的网站单项认证就可以满足我们的需求了。因此我们访问的HTTPS网站大部分都是单项认证。</p><p><strong>1.关于HTTPS的使用存在的误区</strong><br>由于我们对安全性的认识不够重视，通常对于HTTPS存在一些误区，这些误区可能直接给我们带来一些安全隐患。<br>*<strong>误区（1）：对于CA机构颁发的证书客户端无须内置***<br>上面提到访问HTTPS服务器是需要在客户端配置服务器证书的。有些小伙伴可能就纳闷了，说我们用的就是HTTPS但是并没有在客户端配置证书呢？比如请求百度的网站<a href="https://www.baidu.com/%EF%BC%8C%E5%92%8C%E8%AF%B7%E6%B1%82HTTP%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%B2%A1%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%E3%80%82%E5%85%B6%E5%AE%9E%E8%BF%99%E6%98%AF%E5%9B%A0%E4%B8%BA%E5%9C%A8Android%E7%B3%BB%E7%BB%9F%E4%B8%AD%E5%B7%B2%E7%BB%8F%E5%86%85%E7%BD%AE%E4%BA%86%E6%89%80%E6%9C%89CA%E6%9C%BA%E6%9E%84%E7%9A%84%E6%A0%B9%E8%AF%81%E4%B9%A6%EF%BC%8C%E4%B9%9F%E5%B0%B1%E6%98%AF%E5%8F%AA%E8%A6%81%E6%98%AFCA%E6%9C%BA%E6%9E%84%E9%A2%81%E5%8F%91%E7%9A%84%E8%AF%81%E4%B9%A6%EF%BC%8CAndroid%E6%98%AF%E7%9B%B4%E6%8E%A5%E4%BF%A1%E4%BB%BB%E7%9A%84%E3%80%82%E5%AF%B9%E4%BA%8E%E6%AD%A4%E7%A7%8D%E6%83%85%E5%86%B5%EF%BC%8C%E8%99%BD%E7%84%B6%E5%8F%AF%E4%BB%A5%E6%AD%A3%E5%B8%B8%E8%AE%BF%E9%97%AE%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%8C%E4%BD%86%E6%98%AF%E4%BB%8D%E7%84%B6%E5%AD%98%E5%9C%A8%E5%AE%89%E5%85%A8%E9%9A%90%E6%82%A3%E3%80%82%E5%81%87%E5%A6%82%E9%BB%91%E5%AE%A2%E8%87%AA%E5%AE%B6%E6%90%AD%E5%BB%BA%E4%BA%86%E4%B8%80%E4%B8%AA%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%B9%B6%E7%94%B3%E8%AF%B7%E5%88%B0%E4%BA%86CA%E8%AF%81%E4%B9%A6%EF%BC%8C%E7%94%B1%E4%BA%8E%E6%88%91%E4%BB%AC%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%B2%A1%E6%9C%89%E5%86%85%E7%BD%AE%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AF%81%E4%B9%A6%EF%BC%8C%E9%BB%98%E8%AE%A4%E4%BF%A1%E4%BB%BB%E6%89%80%E6%9C%89CA%E8%AF%81%E4%B9%A6%EF%BC%88%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%8F%AF%E4%BB%A5%E8%AE%BF%E9%97%AE%E6%89%80%E6%9C%89%E6%8C%81%E6%9C%89%E7%94%B1CA%E6%9C%BA%E6%9E%84%E9%A2%81%E5%8F%91%E7%9A%84%E8%AF%81%E4%B9%A6%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%89%EF%BC%8C%E9%82%A3%E4%B9%88%E9%BB%91%E5%AE%A2%E4%BB%8D%E7%84%B6%E5%8F%AF%E4%BB%A5%E5%8F%91%E8%B5%B7%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB%E5%8A%AB%E6%8C%81%E6%88%91%E4%BB%AC%E7%9A%84%E8%AF%B7%E6%B1%82%E5%88%B0%E9%BB%91%E5%AE%A2%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%8C%E5%AE%9E%E9%99%85%E4%B8%8A%E5%B0%B1%E6%88%90%E4%BA%86%E6%88%91%E4%BB%AC%E7%9A%84%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%92%8C%E9%BB%91%E5%AE%A2%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BB%BA%E7%AB%8B%E8%B5%B7%E4%BA%86%E8%BF%9E%E6%8E%A5%E3%80%82">https://www.baidu.com/，和请求HTTP服务器没什么区别。其实这是因为在Android系统中已经内置了所有CA机构的根证书，也就是只要是CA机构颁发的证书，Android是直接信任的。对于此种情况，虽然可以正常访问到服务器，但是仍然存在安全隐患。假如黑客自家搭建了一个服务器并申请到了CA证书，由于我们客户端没有内置服务器证书，默认信任所有CA证书（客户端可以访问所有持有由CA机构颁发的证书的服务器），那么黑客仍然可以发起中间人攻击劫持我们的请求到黑客的服务器，实际上就成了我们的客户端和黑客的服务器建立起了连接。</a><br>*</strong>误区（2）：对于非CA机构颁发的证书和自签名证书，可以忽略证书校验***<br>另外一种情况，如果我们服务器的证书是非认证机构颁发的 (例如12306)或者自签名证书，那么我们是无法直接访问到服务器的，直接访问通常会抛出如下异常：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">javax</span><span class="hljs-selector-class">.net</span><span class="hljs-selector-class">.ssl</span><span class="hljs-selector-class">.SSLHandshakeException</span>:<br>    <span class="hljs-selector-tag">java</span><span class="hljs-selector-class">.security</span><span class="hljs-selector-class">.cert</span><span class="hljs-selector-class">.CertPathValidatorException</span>:<br>        <span class="hljs-selector-tag">Trust</span> <span class="hljs-selector-tag">anchor</span> <span class="hljs-selector-tag">for</span> <span class="hljs-selector-tag">certification</span> <span class="hljs-selector-tag">path</span> <span class="hljs-selector-tag">not</span> <span class="hljs-selector-tag">found</span>.<br></code></pre></td></tr></table></figure><p>网上很多解决SSLHandshakeException异常的方案是自定义TrustManager忽略证书校验。代码如下：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-function">SSLSocketFactory <span class="hljs-title">getSSLSocketFactory</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">//创建一个不验证证书链的证书信任管理器。</span><br>        <span class="hljs-keyword">final</span> TrustManager[] trustAllCerts = <span class="hljs-keyword">new</span> TrustManager[]&#123;<span class="hljs-keyword">new</span> X509TrustManager() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> checkClientTrusted(<br>                    java.security.cert.X509Certificate[] chain,<br>                    String authType) <span class="hljs-keyword">throws</span> CertificateException &#123;<br>            &#125;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> checkServerTrusted(<br>                    java.security.cert.X509Certificate[] chain,<br>                    String authType) <span class="hljs-keyword">throws</span> CertificateException &#123;<br>            &#125;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> java.security.cert.X509Certificate[] getAcceptedIssuers() &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> java.security.cert.X509Certificate[<span class="hljs-number">0</span>];<br>            &#125;<br>        &#125;&#125;;<br><br>        <span class="hljs-comment">// Install the all-trusting trust manager</span><br>        <span class="hljs-keyword">final</span> SSLContext sslContext = SSLContext.getInstance(<span class="hljs-string">&quot;TLS&quot;</span>);<br>        sslContext.init(<span class="hljs-keyword">null</span>, trustAllCerts,<br>                <span class="hljs-keyword">new</span> java.security.SecureRandom());<br>        <span class="hljs-comment">// Create an ssl socket factory with our all-trusting manager</span><br>        <span class="hljs-keyword">return</span> sslContext<br>                .getSocketFactory();<br>    &#125;<br><br><br>  <span class="hljs-comment">//使用自定义SSLSocketFactory</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onHttps</span><span class="hljs-params">(OkHttpClient.Builder builder)</span> </span>&#123;<br>       <span class="hljs-keyword">try</span> &#123;<br>            builder.sslSocketFactory(getSSLSocketFactory()).hostnameVerifier(org.apache.http.conn.ssl.SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><br>    &#125;<br></code></pre></td></tr></table></figure><p>对于这样的处理方式虽然解决了SSLHandshakeException异常，但是却存在更大的安全隐患。因为此种做法直接使我们的客户端信任了所有证书（包括CA机构颁发的证书和非CA机构颁发的证书以及自签名证书），因此，这样配置将比第一种情况危害更大。</p><p><strong>2.Retrofit绑定证书实现HTTPS单项认证</strong><br>对于上述两种情况中存在的安全隐患，我们应该如何应对？最简单的解决方案就是在客户端内置服务器的证书，我们在校验服务端证书的时候只比对和App内置的证书是否完全相同，如果不同则断开连接。那么此时再遭遇中间人攻击劫持我们的请求时由于黑客服务器没有相应的证书，此时HTTPS请求校验不通过，则无法与黑客的服务器建立起连接。</p><p>那么接下来我们就结合Retrofit以访问12306为例来实现HTTPS的单项认证。<br>首先从12306网站下载签名证书，并放置到我们项目资源目录raw下。然后根据证书构造SSLSocketFactory，代码如下：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 单项认证</span><br><span class="hljs-comment">    */</span><br>   public static SSLSocketFactory get<span class="hljs-constructor">SSLSocketFactoryForOneWay(InputStream<span class="hljs-operator">...</span> <span class="hljs-params">certificates</span>)</span> &#123;<br>       <span class="hljs-keyword">try</span> &#123;<br>           CertificateFactory certificateFactory = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">CertificateFactory</span>.</span></span>get<span class="hljs-constructor">Instance(CLIENT_TRUST_MANAGER, CLIENT_TRUST_PROVIDER)</span>;<br>           KeyStore keyStore = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">KeyStore</span>.</span></span>get<span class="hljs-constructor">Instance(CLIENT_TRUST_KEYSTORE)</span>;<br>           keyStore.load(null);<br>           <span class="hljs-built_in">int</span> index = <span class="hljs-number">0</span>;<br>           <span class="hljs-keyword">for</span> (InputStream certificate : certificates) &#123;<br>               String certificateAlias = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Integer</span>.</span></span><span class="hljs-keyword">to</span><span class="hljs-constructor">String(<span class="hljs-params">index</span><span class="hljs-operator">++</span>)</span>;<br>               keyStore.set<span class="hljs-constructor">CertificateEntry(<span class="hljs-params">certificateAlias</span>, <span class="hljs-params">certificateFactory</span>.<span class="hljs-params">generateCertificate</span>(<span class="hljs-params">certificate</span>)</span>);<br>               <span class="hljs-keyword">try</span> &#123;<br>                   <span class="hljs-keyword">if</span> (certificate != null)<br>                       certificate.close<span class="hljs-literal">()</span>;<br>               &#125; catch (IOException e) &#123;<br>                   e.print<span class="hljs-constructor">StackTrace()</span>;<br>               &#125;<br>           &#125;<br><br>           SSLContext sslContext = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">SSLContext</span>.</span></span>get<span class="hljs-constructor">Instance(CLIENT_AGREEMENT)</span>;<br><br>           TrustManagerFactory trustManagerFactory =<br>                   <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">TrustManagerFactory</span>.</span></span>get<span class="hljs-constructor">Instance(TrustManagerFactory.<span class="hljs-params">getDefaultAlgorithm</span>()</span>);<br><br>           trustManagerFactory.init(keyStore);<br>           sslContext.init(null, trustManagerFactory.get<span class="hljs-constructor">TrustManagers()</span>, <span class="hljs-keyword">new</span> <span class="hljs-constructor">SecureRandom()</span>);<br>           return sslContext.get<span class="hljs-constructor">SocketFactory()</span>;<br>       &#125; catch (Exception e) &#123;<br>           e.print<span class="hljs-constructor">StackTrace()</span>;<br>       &#125;<br>       return null;<br>   &#125;<br></code></pre></td></tr></table></figure><p>接下来为OKHttpClient设置SslSocketFactory以及hostnameVerifier，代码如下：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">InputStream certificate12306 = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Utils</span>.</span></span>get<span class="hljs-constructor">Context()</span>.get<span class="hljs-constructor">Resources()</span>.<span class="hljs-keyword">open</span><span class="hljs-constructor">RawResource(R.<span class="hljs-params">raw</span>.<span class="hljs-params">srca</span>)</span>;<br>        OkHttpClient okHttpClient = <span class="hljs-keyword">new</span> OkHttpClient.<span class="hljs-constructor">Builder()</span><br>                .read<span class="hljs-constructor">Timeout(Constants.DEFAULT_TIMEOUT, TimeUnit.MILLISECONDS)</span><br>                .connect<span class="hljs-constructor">Timeout(Constants.DEFAULT_TIMEOUT, TimeUnit.MILLISECONDS)</span><br>                .add<span class="hljs-constructor">Interceptor(<span class="hljs-params">interceptor</span>)</span><br>                .add<span class="hljs-constructor">Interceptor(<span class="hljs-params">new</span> HttpHeaderInterceptor()</span>)<br>                .add<span class="hljs-constructor">NetworkInterceptor(<span class="hljs-params">new</span> HttpCacheInterceptor()</span>)<br>                .ssl<span class="hljs-constructor">SocketFactory(SslContextFactory.<span class="hljs-params">getSSLSocketFactoryForOneWay</span>(<span class="hljs-params">certificate12306</span>)</span>)<br>                .hostname<span class="hljs-constructor">Verifier(<span class="hljs-params">new</span> SafeHostnameVerifier()</span>)<br>                .cache(cache)<br>                .build<span class="hljs-literal">()</span>;<br></code></pre></td></tr></table></figure><p>上述代码中hostnameVerifier是对服务器的校验，SafeHostnameVerifier代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SafeHostnameVerifier</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HostnameVerifier</span> </span>&#123;<br>       <span class="hljs-meta">@Override</span><br>       <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">verify</span><span class="hljs-params">(String hostname, SSLSession session)</span> </span>&#123;<br>           <span class="hljs-keyword">if</span> (Constants.IP.equals(hostname)) &#123;<span class="hljs-comment">//校验hostname是否正确，如果正确则建立连接</span><br>               <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>           &#125;<br>           <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><p>verify方法中对比了请求的IP和服务器的IP是否一致，一致则返回true表示校验通过，否则返回false，检验不通过，断开连接。对于网上有些处理是直接返回true，即不对请求的服务器IP做校验，我们不推荐这样使用。而且现在谷歌应用商店已经对此种做法做了限制，禁止在verify方法中直接返回true的App上线。</p><h2 id="五、HTTPS双向认证"><a href="#五、HTTPS双向认证" class="headerlink" title=" 五、HTTPS双向认证"></a> 五、HTTPS双向认证</h2><p>对于HTTPS双向认证，用到的情况不多。但是对于像金融行业等对安全性要求较高的企业，通常都会使用双向认证。所谓双向认证就是客户端校验服务器证书，同时服务器也需要校验客户端的证书。因此，双向认证就另需一张证书放到客户端待服务端去验证。</p><blockquote><p>单项认证保证了我们自己的客户端只能访问我们自己的服务器，但并不能保证我们自己的服务器只能被我们自己的客户端访问（第三方客户端忽略证书校验即可）。那么双向认证则保证了我们的客户端只能访问我们自己的服务器，同时我们的服务器也只能被我们自己的客户端访问。因此双向认证可以说相比单项认证安全性足足提高一个等级。</p></blockquote><p><strong>1.双向认证流程</strong><br>接下来我们来了解下双向认证的流程，以加深对双向认证的理解：</p><blockquote><p>a. 客户端发送一个连接请求给服务器。<br>　　b. 服务器将自己的证书，以及同证书相关的信息发送给客户端。<br>　　c. 客户端检查服务器送过来的证书是否和App内置证书相同。如果是，就继续执行协议；如果不是则终止此次请求。<br>　　d. 接着客户端比较证书里的消息，例如域名和公钥，与服务器刚刚发送的相关消息是否一致，如果是一致的，客户端认可这个服务器的合法身份。<br>　　e. 服务器要求客户发送客户自己的证书。收到后，服务器验证客户端的证书，如果没有通过验证，拒绝连接；如果通过验证，服务器获得用户的公钥。<br>　　f. 客户端告诉服务器自己所能够支持的通讯对称密码方案。<br>　　g. 服务器从客户发送过来的密码方案中，选择一种加密程度最高的密码方案，用客户的公钥加过密后通知客户端。<br>　　h. 客户端针对这个密码方案，选择一个通话密钥，接着用服务器的公钥加过密后发送给服务器。<br>　　i. 服务器接收到客户端送过来的消息，用自己的私钥解密，获得通话密钥。<br>　　j. 服务器通过密钥解密客户端发送的被加密数据，得到明文数据。</p></blockquote><p><strong>2.Retrofit实现HTTPS双向认证</strong><br>对于双向认证，我们以华为北向平台登录接口为例来进行学习。想了解华为北向API<a href="http://developer.huawei.com/ict/cn/doc/site-oceanconnect-northbound_api_reference-zh/index.html/zh-cn_topic_0087306564">请戳此处</a><br>我们直接通过浏览器访问登录接口可以看到如下情景：<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTgwMzA1MTM1OTU3NTg0?x-oss-process=image/format,png" alt="这里写图片描述"><br>哈，惊喜不？直接被拒绝了！这就是双向认证，没有证书想访问服务器门都没有。那么对于双向认证我们应该做怎样的配置？我们可以参考华为开源出来的代码<a href="https://github.com/Huawei/IoT_OceanConnect_North_GUI_APPDemo">戳此处</a><br>源码中由两个证书文件ca.jks和outgoing.CertwithKey.pkcs12，其中ca.jks是在客户端配置的证书，outgoing.CertwithKey.pkcs12是在服务端配置的证书。因为我们当前客户端是Android系统，由于Android系统不支持jks格式的证书，因此需要把jks转成Android支持的bks格式。转换方式不再贴出，可自行查阅。<br>有了证书，接下来看获取SSLSocketFactory的代码：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 双向认证</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * @return SSLSocketFactory</span><br><span class="hljs-comment">   */</span><br>  public static SSLSocketFactory get<span class="hljs-constructor">SSLSocketFactoryForTwoWay()</span> &#123;<br>      <span class="hljs-keyword">try</span> &#123;<br>          InputStream certificate = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Utils</span>.</span></span>get<span class="hljs-constructor">Context()</span>.get<span class="hljs-constructor">Resources()</span>.<span class="hljs-keyword">open</span><span class="hljs-constructor">RawResource(R.<span class="hljs-params">raw</span>.<span class="hljs-params">capk</span>)</span>;<br>          <span class="hljs-comment">//  CertificateFactory certificateFactory = CertificateFactory.getInstance(&quot;X.509&quot;, &quot;BC&quot;);</span><br>          KeyStore keyStore = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">KeyStore</span>.</span></span>get<span class="hljs-constructor">Instance(CLIENT_TRUST_KEY)</span>;<br>          keyStore.load(certificate, <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">SELF_CERT_PWD</span>.</span></span><span class="hljs-keyword">to</span><span class="hljs-constructor">CharArray()</span>);<br>          KeyManagerFactory kmf = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">KeyManagerFactory</span>.</span></span>get<span class="hljs-constructor">Instance(KeyManagerFactory.<span class="hljs-params">getDefaultAlgorithm</span>()</span>);<br>          kmf.init(keyStore, <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">SELF_CERT_PWD</span>.</span></span><span class="hljs-keyword">to</span><span class="hljs-constructor">CharArray()</span>);<br><br>          <span class="hljs-keyword">try</span> &#123;<br>              <span class="hljs-keyword">if</span> (certificate != null)<br>                  certificate.close<span class="hljs-literal">()</span>;<br>          &#125; catch (IOException e) &#123;<br>              e.print<span class="hljs-constructor">StackTrace()</span>;<br>          &#125;<br><br>          <span class="hljs-comment">//初始化keystore</span><br>          KeyStore clientKeyStore = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">KeyStore</span>.</span></span>get<span class="hljs-constructor">Instance(CLIENT_TRUST_KEYSTORE)</span>;<br>          clientKeyStore.load(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Utils</span>.</span></span>get<span class="hljs-constructor">Context()</span>.get<span class="hljs-constructor">Resources()</span>.<span class="hljs-keyword">open</span><span class="hljs-constructor">RawResource(R.<span class="hljs-params">raw</span>.<span class="hljs-params">cabks</span>)</span>, <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">TRUST_CA_PWD</span>.</span></span><span class="hljs-keyword">to</span><span class="hljs-constructor">CharArray()</span>);<br><br>          SSLContext sslContext = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">SSLContext</span>.</span></span>get<span class="hljs-constructor">Instance(CLIENT_AGREEMENT)</span>;<br>          TrustManagerFactory trustManagerFactory = TrustManagerFactory.<br>                  get<span class="hljs-constructor">Instance(TrustManagerFactory.<span class="hljs-params">getDefaultAlgorithm</span>()</span>);<br><br>          trustManagerFactory.init(clientKeyStore);<br><br>          KeyManagerFactory keyManagerFactory = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">KeyManagerFactory</span>.</span></span>get<span class="hljs-constructor">Instance(KeyManagerFactory.<span class="hljs-params">getDefaultAlgorithm</span>()</span>);<br>          keyManagerFactory.init(clientKeyStore, <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">SELF_CERT_PWD</span>.</span></span><span class="hljs-keyword">to</span><span class="hljs-constructor">CharArray()</span>);<br><br>          sslContext.init(kmf.get<span class="hljs-constructor">KeyManagers()</span>, trustManagerFactory.get<span class="hljs-constructor">TrustManagers()</span>, <span class="hljs-keyword">new</span> <span class="hljs-constructor">SecureRandom()</span>);<br>          return sslContext.get<span class="hljs-constructor">SocketFactory()</span>;<br>      &#125; catch (Exception e) &#123;<br>          e.print<span class="hljs-constructor">StackTrace()</span>;<br>      &#125;<br>      return null;<br>  &#125;<br></code></pre></td></tr></table></figure><p>接下来同样需要配置OKHttpClient，代码如下：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">OkHttpClient okHttpClient = <span class="hljs-keyword">new</span> OkHttpClient.<span class="hljs-constructor">Builder()</span><br>                .read<span class="hljs-constructor">Timeout(Constants.DEFAULT_TIMEOUT, TimeUnit.MILLISECONDS)</span><br>                .connect<span class="hljs-constructor">Timeout(Constants.DEFAULT_TIMEOUT, TimeUnit.MILLISECONDS)</span><br>                .add<span class="hljs-constructor">Interceptor(<span class="hljs-params">interceptor</span>)</span><br>                .add<span class="hljs-constructor">Interceptor(<span class="hljs-params">new</span> HttpHeaderInterceptor()</span>)<br>                .add<span class="hljs-constructor">NetworkInterceptor(<span class="hljs-params">new</span> HttpCacheInterceptor()</span>)<br>                .ssl<span class="hljs-constructor">SocketFactory(SslContextFactory.<span class="hljs-params">getSSLSocketFactoryForTwoWay</span>()</span>)<br>                .hostname<span class="hljs-constructor">Verifier(<span class="hljs-params">new</span> SafeHostnameVerifier()</span>)<br>                .cache(cache)<br>                .build<span class="hljs-literal">()</span>;<br></code></pre></td></tr></table></figure><p>这样就完成了HTTPS的配置，接下来就可以愉快的访问HTTPS 双向认证的接口了。由于北向登录接口中需要appId和secret两个参数，因此，登录相关代码就不再贴出。</p><p>好了，到此关于HTTPS的学习就结束了，如果有不明白的地方可以参看文末源码。以上内容纯属个人对HTTPS的一些认识，如果文中有错误之处还请多多包涵，欢迎留言指正。</p><p>本文写成参考了大量的相关文章，在此表示感谢。</p><p><a href="https://github.com/zhpanvip/Retrofit2/tree/master/idea/src/main/java/com/zhpan/idea/net/https">源码参考</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://blog.jobbole.com/86660/">大型网站的 HTTPS 实践（1）：HTTPS 协议和原理</a><br><a href="http://blog.csdn.net/dd864140130/article/details/52625666">Retrofit中如何正确的使用https？</a><br><a href="http://blog.csdn.net/lmj623565791/article/details/48129405">Android Https相关完全解析 当OkHttp遇到Https</a><br><a href="https://www.jianshu.com/p/f2097616e65e">HTTPS原理及OKHTTP对HTTPS的支持</a></p>]]></content>
    
    
    <categories>
      
      <category>网络安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>https</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>追根溯源--探究Handler的实现原理</title>
    <link href="/2017/09/10/12.Handler%20source%20code%20analysis/"/>
    <url>/2017/09/10/12.Handler%20source%20code%20analysis/</url>
    
    <content type="html"><![CDATA[<h2 id="一、初识Handler"><a href="#一、初识Handler" class="headerlink" title="一、初识Handler"></a>一、初识Handler</h2><p>要分析一个框架的源码，首先需要了解它的使用。我们就从最基础的知识开始吧！</p><h3 id="场景1：将数据从子线程发送到主线程。"><a href="#场景1：将数据从子线程发送到主线程。" class="headerlink" title="场景1：将数据从子线程发送到主线程。"></a>场景1：将数据从子线程发送到主线程。</h3><p>我们知道Android系统中更新UI只能在主线程中进行。而通常网络请求实在子线程中进行的。在获取到服务器数据后我们需要切换到主线程来更新UI。通常在这种情况下我们会考虑使用Handler来进行线程切换。我们来模拟一个网络请求，并通过Handler将数据发送出去：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">private</span> Handler mHandler = <span class="hljs-keyword">new</span> Handler()&#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dispatchMessage</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Message msg)</span> </span>&#123;<br>            <span class="hljs-keyword">super</span>.dispatchMessage(msg);<br>            updateUI(msg);<br>        &#125;<br>    &#125;;<br><span class="hljs-comment">// 或者可以通过传入Handler.Callback的参数</span><br>Handler mHandler = <span class="hljs-keyword">new</span> Handler(<span class="hljs-keyword">new</span> Handler.Callback() &#123;<br>       <span class="hljs-meta">@Override</span><br>       <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">handleMessage</span><span class="hljs-params">(Message msg)</span> </span>&#123;<br>updateUI(msg);<br>           <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>       &#125;<br>   &#125;);<br><br><span class="hljs-comment">// 模拟网络请求</span><br> <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fetchData</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">new</span> Thread()&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                <span class="hljs-keyword">super</span>.run();<br>                Message message = mHandler.obtainMessage();<br>                message.obj=<span class="hljs-string">&quot;data from server&quot;</span>;<br>                mHandler.sendMessage(message);<br>            &#125;<br>        &#125;.start();<br><br>    &#125;<br></code></pre></td></tr></table></figure><p>我们通过子线程模拟网络请求，并将获取的数据通过Handler的sendMessage方法将数据发送了出去。而在Handler的dispatchMessage方法中便可收到刚刚发送的message。并且此时dispatchMessage处于主线程，因此可以直接在dispatchMessage方法中更新UI了。</p><h3 id="场景2：延迟发送Runnable"><a href="#场景2：延迟发送Runnable" class="headerlink" title="场景2：延迟发送Runnable"></a>场景2：延迟发送Runnable</h3><p>场景1是Handler很典型的一个应用，除此之外，我们还经常会通过Handler延迟发送一个Runnable，在delayMillis时间之后会执行Runnable的run方法。代码示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 假设是运行在Activity中的代码</span><br><span class="hljs-keyword">private</span> Handler mHandler = <span class="hljs-keyword">new</span> Handler();<br><span class="hljs-keyword">private</span> Runnable mRunnable = <span class="hljs-keyword">new</span> Runnable() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            handleMessage();<br>        &#125;<br>    &#125;;<br> <span class="hljs-meta">@Override</span><br>   <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> </span>&#123;<br>       <span class="hljs-keyword">super</span>.onCreate(savedInstanceState);<br> <span class="hljs-keyword">new</span> Thread()&#123;<br>           <span class="hljs-meta">@Override</span><br>           <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>               <span class="hljs-keyword">super</span>.run();<br>               mHandler.postDelayed(mRunnable,<span class="hljs-number">1000</span>);<br>           &#125;<br>       &#125;.start();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="场景3：在子线程中初始化Handler"><a href="#场景3：在子线程中初始化Handler" class="headerlink" title="场景3：在子线程中初始化Handler"></a>场景3：在子线程中初始化Handler</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">Handler mHandler;<br><span class="hljs-keyword">new</span> Thread()&#123;<br>           <span class="hljs-meta">@Override</span><br>           <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>               <span class="hljs-keyword">super</span>.run();<br>               mHandler=<span class="hljs-keyword">new</span> Handler();<br>           &#125;<br>       &#125;.start();<br></code></pre></td></tr></table></figure><p>此时，运行程序我们会发现程序Crash掉了，并且抛出了以下错误日志：</p><blockquote><p>java.lang.RuntimeException: Can’t create handler inside thread that has not called Looper.prepare()</p></blockquote><p>日志信息提示我们在子线程中创建Handler需要调用Looper.prepare()方法。</p><p>(注:以上场景均未考虑内存泄露问题)</p><p>那么针对以上三个应用场景，有些同学可能表示会有问题：</p><p><strong>问题1：</strong> 在场景1中Handler在子线程中发送出来的消息为什么到了dispatchMessage方法就变成了主线程呢？</p><p><strong>问题2：</strong> 在场景2的代码中我故意在子线程中调用了Handler的postDelayed方法，那么此时通过postDelayed方法发出来的Runnable究竟是运行在主线程还是子线程呢？</p><p><strong>问题3：</strong>  为什么在主线程中直接创建Handler可以正常运行而在子线程中创建Handler需要调用Looper.prepare()方法呢？</p><p>如果想要解开以上几个疑惑，就需要我们对Handler的源码有深入的了解。那么接下来我们就进入Handler的源码分析环节吧！</p><h2 id="二、Handler源码溯源历程"><a href="#二、Handler源码溯源历程" class="headerlink" title="二、Handler源码溯源历程"></a>二、Handler源码溯源历程</h2><h3 id="1-从实例化一个Handler说起"><a href="#1-从实例化一个Handler说起" class="headerlink" title="1.从实例化一个Handler说起"></a>1.从实例化一个Handler说起</h3><p>在使用Handler的第一步就需要我们先实例化一个Handler。那么，我们就从new Handler()着手，看看在初始化Handler的时候做了哪些操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">final</span> Looper mLooper;<br>   <span class="hljs-keyword">final</span> MessageQueue mQueue;<br><span class="hljs-keyword">final</span> Callback mCallback;<br>   <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> mAsynchronous;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Handler</span><span class="hljs-params">()</span> </span>&#123;<br>       <span class="hljs-keyword">this</span>(<span class="hljs-keyword">null</span>, <span class="hljs-keyword">false</span>);<br>   &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Handler</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> Callback callback, <span class="hljs-keyword">boolean</span> async)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (FIND_POTENTIAL_LEAKS) &#123;<br>            <span class="hljs-keyword">final</span> Class&lt;? extends Handler&gt; klass = getClass();<br>            <span class="hljs-keyword">if</span> ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;<br>                    (klass.getModifiers() &amp; Modifier.STATIC) == <span class="hljs-number">0</span>) &#123;<br>                Log.w(TAG, <span class="hljs-string">&quot;The following Handler class should be static or leaks might occur: &quot;</span> +<br>                    klass.getCanonicalName());<br>            &#125;<br>        &#125;<br><br>        mLooper = Looper.myLooper();<br>        <span class="hljs-keyword">if</span> (mLooper == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<br>                <span class="hljs-string">&quot;Can&#x27;t create handler inside thread &quot;</span> + Thread.currentThread()<br>                        + <span class="hljs-string">&quot; that has not called Looper.prepare()&quot;</span>);<br>        &#125;<br>        mQueue = mLooper.mQueue;<br>        mCallback = callback;<br>        mAsynchronous = async;<br>    &#125;<br><br></code></pre></td></tr></table></figure><p>可以看到，调用Handler的无参构造方法实例化Handler最终调用了Handler(@Nullable Callback callback, boolean async)的构造方法，而在这个构造方法中的逻辑似乎也很简单，通过调用Looper.myLooper()方法得到了一个Looper对象，如果此时mLooper为null，则会抛出一个RuntimeException。仔细看看发现这个异常信息不就是我们在第一章场景三中在子线程中初始化Handler的时候抛出来的异常吗？那么，什么时候通过Looper.myPrepare()方法得到的Handler会是空呢？要解决这个问题怕是要到Looper中一探究竟了。</p><p>首先来看下Looper.myPrepare()方法的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-meta">@Nullable</span> <span class="hljs-function">Looper <span class="hljs-title">myLooper</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> sThreadLocal.get();<br>&#125;<br><br></code></pre></td></tr></table></figure><p>这是Looper中的一个静态方法，这个方法简单到只有一行代码，即调用了ThreadLocal的get()方法来得到一个Looper。ThreadLocal是Java中的一个类，它是一个泛型类，有set(T)和T get()两个方法。ThreadLocal的神奇之处在于它可以在指定线程中存储数据，什么意思呢？即你在某个线程中存储的数据只能在该线程中获取的到。关于ThreadLocal我们只需要了解这些就够了，其实现原理不做深究，有兴趣的可以自从查阅源码。</p><p>既然了解了ThreadLocal的作用，那么在Looper内部一定事先调用了ThreadLocal的set方法。通过全局搜索sThreadLocal，发现了prepare()方法，其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">prepare</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> quitAllowed)</span> </span>&#123;<br>     <span class="hljs-keyword">if</span> (sThreadLocal.get() != <span class="hljs-keyword">null</span>) &#123;<br>         <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;Only one Looper may be created per thread&quot;</span>);<br>     &#125;<br>     sThreadLocal.set(<span class="hljs-keyword">new</span> Looper(quitAllowed));<br> &#125;<br><br></code></pre></td></tr></table></figure><p>果真如我们预料的那样，在Looper的prepare方法中实例化了Looper，并将其放入到了ThreadLocal中。而如果没有调用Looper.prepare()方法，那么获取到的Looper一定是null。到这里似乎解释了第一章的场景三在子线程中实例化Handler需要事先调用Looper.prepare()方法。但是，到这里我们似乎还是没有解释清楚疑惑三，为什么在主线程中直接实例化Handler却没有抛出异常呢？其实，当程序启动的时候会同时启动主线程，我们知道Java程序的入口是main方法。而在Android程序启动的入口同样是main方法。我们在ActivityThread中找到main方法，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><br># ActivityThread<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>...<br><br>        Looper.prepareMainLooper();<br>...<br><br>        Looper.loop();<br><br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;Main thread loop unexpectedly exited&quot;</span>);<br>    &#125;<br><br> # Looper<br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">prepareMainLooper</span><span class="hljs-params">()</span> </span>&#123;<br>        prepare(<span class="hljs-keyword">false</span>);<br>        <span class="hljs-keyword">synchronized</span> (Looper.class) &#123;<br>            <span class="hljs-keyword">if</span> (sMainLooper != <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">&quot;The main Looper has already been prepared.&quot;</span>);<br>            &#125;<br>            sMainLooper = myLooper();<br>        &#125;<br>    &#125;<br><br><br></code></pre></td></tr></table></figure><p>在main方法中调用了Looper.prepareMauinLooper()方法，而Looper.prepareMauinLooper()中又调用了prepare方法。因此，我们可以在主线程中直接实例化Handler而不用担心抛出异常。</p><h3 id="2-Handler的postXXX-或sendXXX"><a href="#2-Handler的postXXX-或sendXXX" class="headerlink" title="2.Handler的postXXX()或sendXXX"></a>2.Handler的postXXX()或sendXXX</h3><p>实例化Handler后，我们通常会通过Handler提供的方法来发送一个消息。在第一章节中列举了Handler的sendMessage()和postDelay()方法，其实除了这两个方法之外，Handler还提供了一系列的sendXXX()和postXXX()的方法。但追踪源码发现这些方法最终都会调用到sendMessageAtTime方法。</p><p>我们就以postDelayed方法为例来分析。首先，来看postDelayed的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">postDelayed</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Runnable r, <span class="hljs-keyword">long</span> delayMillis)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> sendMessageDelayed(getPostMessage(r), delayMillis);<br>    &#125;<br></code></pre></td></tr></table></figure><p>在postDelayed中调用了sendMessageDelayed方法，这个方法的第一个参数接收一个Message，这里通过getPostMessage(r)方法得到了Message对象，getPostMessage(r)源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Message <span class="hljs-title">getPostMessage</span><span class="hljs-params">(Runnable r)</span> </span>&#123;<br>        Message m = Message.obtain();<br>        m.callback = r;<br>        <span class="hljs-keyword">return</span> m;<br>    &#125;<br><br></code></pre></td></tr></table></figure><p>可以看到，在getPostMessage方法中将Runnable赋值给了Message.callback，此处我们先立一个Flag。</p><p>接下来追溯到sendMessageDelayed方法中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">sendMessageDelayed</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Message msg, <span class="hljs-keyword">long</span> delayMillis)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (delayMillis &lt; <span class="hljs-number">0</span>) &#123;<br>            delayMillis = <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);<br>    &#125;<br></code></pre></td></tr></table></figure><p>在这个方法中我们终于看到了sendMessageAtTime方法，其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">sendMessageAtTime</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Message msg, <span class="hljs-keyword">long</span> uptimeMillis)</span> </span>&#123;<br>        MessageQueue queue = mQueue;<br>        <span class="hljs-keyword">if</span> (queue == <span class="hljs-keyword">null</span>) &#123;<br>            RuntimeException e = <span class="hljs-keyword">new</span> RuntimeException(<br>                    <span class="hljs-keyword">this</span> + <span class="hljs-string">&quot; sendMessageAtTime() called with no mQueue&quot;</span>);<br>            Log.w(<span class="hljs-string">&quot;Looper&quot;</span>, e.getMessage(), e);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> enqueueMessage(queue, msg, uptimeMillis);<br>    &#125;<br></code></pre></td></tr></table></figure><p>这个方法中的代码逻辑很简单，仅仅调用了enqueueMessage方法，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">enqueueMessage</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> MessageQueue queue, <span class="hljs-meta">@NonNull</span> Message msg,</span></span><br><span class="hljs-function"><span class="hljs-params">            <span class="hljs-keyword">long</span> uptimeMillis)</span> </span>&#123;<br>        msg.target = <span class="hljs-keyword">this</span>;<br>        msg.workSourceUid = ThreadLocalWorkSource.getUid();<br><br>        <span class="hljs-keyword">if</span> (mAsynchronous) &#123;<br>            msg.setAsynchronous(<span class="hljs-keyword">true</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);<br>    &#125;<br></code></pre></td></tr></table></figure><p>在这个方法中我们需要注意的一点– msg.target = this，把当前Handler的对象赋值给了Message.target。紧接着调用了MessageQueue的enqueueMessage方法。MessageQueue这个类我们在上边已经碰到过了。即在实例化Handler的时候将mLooper.mQueue赋值给了Handler的mQueue.那么现在是时候来认识一下MessageQueue了。</p><h3 id="3-MessageQueue"><a href="#3-MessageQueue" class="headerlink" title="3.MessageQueue"></a>3.MessageQueue</h3><p>上一小节中我们在Handler的构造方法中看到了将mLooper.mQueue赋值给了Handler中的mQueue。而MessageQueue从名字上似乎也可以看出来它是一个存储消息的队列。并且在Handler的enqueueMessage方法中通过MessageQueue的enqueueMessage将消息添加到了MessageQueue中。接下来，我们看下enqueueMessage的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">enqueueMessage</span><span class="hljs-params">(Message msg, <span class="hljs-keyword">long</span> when)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (msg.target == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;Message must have a target.&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (msg.isInUse()) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(msg + <span class="hljs-string">&quot; This message is already in use.&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>            <span class="hljs-keyword">if</span> (mQuitting) &#123;<br>                IllegalStateException e = <span class="hljs-keyword">new</span> IllegalStateException(<br>                        msg.target + <span class="hljs-string">&quot; sending message to a Handler on a dead thread&quot;</span>);<br>                Log.w(TAG, e.getMessage(), e);<br>                msg.recycle();<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            &#125;<br><br>            msg.markInUse();<br>            msg.when = when;<br>            Message p = mMessages;<br>            <span class="hljs-keyword">boolean</span> needWake;<br>            <span class="hljs-keyword">if</span> (p == <span class="hljs-keyword">null</span> || when == <span class="hljs-number">0</span> || when &lt; p.when) &#123;<br>                <span class="hljs-comment">// New head, wake up the event queue if blocked.</span><br>                msg.next = p;<br>                mMessages = msg;<br>                needWake = mBlocked;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// Inserted within the middle of the queue.  Usually we don&#x27;t have to wake</span><br>                <span class="hljs-comment">// up the event queue unless there is a barrier at the head of the queue</span><br>                <span class="hljs-comment">// and the message is the earliest asynchronous message in the queue.</span><br>                needWake = mBlocked &amp;&amp; p.target == <span class="hljs-keyword">null</span> &amp;&amp; msg.isAsynchronous();<br>                Message prev;<br>                <span class="hljs-keyword">for</span> (;;) &#123;<br>                    prev = p;<br>                    p = p.next;<br>                    <span class="hljs-keyword">if</span> (p == <span class="hljs-keyword">null</span> || when &lt; p.when) &#123;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;<br>                        needWake = <span class="hljs-keyword">false</span>;<br>                    &#125;<br>                &#125;<br>                msg.next = p; <span class="hljs-comment">// invariant: p == prev.next</span><br>                prev.next = msg;<br>            &#125;<br><br>            <span class="hljs-comment">// We can assume mPtr != 0 because mQuitting is false.</span><br>            <span class="hljs-keyword">if</span> (needWake) &#123;<br>                nativeWake(mPtr);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br><br></code></pre></td></tr></table></figure><p>emmmmmm…阅读源码发现MessageQueue是一个用单项链表实现的队列，为什么是用链表？其实细想一下也不奇怪，因为我们可能频繁的将Message进行插入和删除。而使用链表性能上很明显要优于顺序表。这一段代码就是一个将Message插入到链表的一个过程，其实也没什么可以解释的。</p><p>既然有插入消息，那必然也会有取出消息。我们进入MessageQueue的源码，发现在MessageQueue中发现还有另外一个叫next的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">Message <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// Return here if the message loop has already quit and been disposed.</span><br>        <span class="hljs-comment">// This can happen if the application tries to restart a looper after quit</span><br>        <span class="hljs-comment">// which is not supported.</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> ptr = mPtr;<br>        <span class="hljs-keyword">if</span> (ptr == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">int</span> pendingIdleHandlerCount = -<span class="hljs-number">1</span>; <span class="hljs-comment">// -1 only during first iteration</span><br>        <span class="hljs-keyword">int</span> nextPollTimeoutMillis = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-keyword">if</span> (nextPollTimeoutMillis != <span class="hljs-number">0</span>) &#123;<br>                Binder.flushPendingCommands();<br>            &#125;<br><br>            nativePollOnce(ptr, nextPollTimeoutMillis);<br><br>            <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>                <span class="hljs-comment">// Try to retrieve the next message.  Return if found.</span><br>                <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> now = SystemClock.uptimeMillis();<br>                Message prevMsg = <span class="hljs-keyword">null</span>;<br>                Message msg = mMessages;<br>                <span class="hljs-keyword">if</span> (msg != <span class="hljs-keyword">null</span> &amp;&amp; msg.target == <span class="hljs-keyword">null</span>) &#123;<br>                    <span class="hljs-comment">// Stalled by a barrier.  Find the next asynchronous message in the queue.</span><br>                    <span class="hljs-keyword">do</span> &#123;<br>                        prevMsg = msg;<br>                        msg = msg.next;<br>                    &#125; <span class="hljs-keyword">while</span> (msg != <span class="hljs-keyword">null</span> &amp;&amp; !msg.isAsynchronous());<br>                &#125;<br>                <span class="hljs-keyword">if</span> (msg != <span class="hljs-keyword">null</span>) &#123;<br>                    <span class="hljs-keyword">if</span> (now &lt; msg.when) &#123;<br>                        <span class="hljs-comment">// Next message is not ready.  Set a timeout to wake up when it is ready.</span><br>                        nextPollTimeoutMillis = (<span class="hljs-keyword">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        <span class="hljs-comment">// Got a message.</span><br>                        mBlocked = <span class="hljs-keyword">false</span>;<br>                        <span class="hljs-keyword">if</span> (prevMsg != <span class="hljs-keyword">null</span>) &#123;<br>                            prevMsg.next = msg.next;<br>                        &#125; <span class="hljs-keyword">else</span> &#123;<br>                            mMessages = msg.next;<br>                        &#125;<br>                        msg.next = <span class="hljs-keyword">null</span>;<br>                        <span class="hljs-keyword">if</span> (DEBUG) Log.v(TAG, <span class="hljs-string">&quot;Returning message: &quot;</span> + msg);<br>                        msg.markInUse();<br>                        <span class="hljs-keyword">return</span> msg;<br>                    &#125;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// No more messages.</span><br>                    nextPollTimeoutMillis = -<span class="hljs-number">1</span>;<br>                &#125;<br><br>                <span class="hljs-comment">// Process the quit message now that all pending messages have been handled.</span><br>                <span class="hljs-keyword">if</span> (mQuitting) &#123;<br>                    dispose();<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>                &#125;<br><br>                <span class="hljs-comment">// If first time idle, then get the number of idlers to run.</span><br>                <span class="hljs-comment">// Idle handles only run if the queue is empty or if the first message</span><br>                <span class="hljs-comment">// in the queue (possibly a barrier) is due to be handled in the future.</span><br>                <span class="hljs-keyword">if</span> (pendingIdleHandlerCount &lt; <span class="hljs-number">0</span><br>                        &amp;&amp; (mMessages == <span class="hljs-keyword">null</span> || now &lt; mMessages.when)) &#123;<br>                    pendingIdleHandlerCount = mIdleHandlers.size();<br>                &#125;<br>                <span class="hljs-keyword">if</span> (pendingIdleHandlerCount &lt;= <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-comment">// No idle handlers to run.  Loop and wait some more.</span><br>                    mBlocked = <span class="hljs-keyword">true</span>;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br><br>                <span class="hljs-keyword">if</span> (mPendingIdleHandlers == <span class="hljs-keyword">null</span>) &#123;<br>                    mPendingIdleHandlers = <span class="hljs-keyword">new</span> IdleHandler[Math.max(pendingIdleHandlerCount, <span class="hljs-number">4</span>)];<br>                &#125;<br>                mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);<br>            &#125;<br><br>            <span class="hljs-comment">// Run the idle handlers.</span><br>            <span class="hljs-comment">// We only ever reach this code block during the first iteration.</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; pendingIdleHandlerCount; i++) &#123;<br>                <span class="hljs-keyword">final</span> IdleHandler idler = mPendingIdleHandlers[i];<br>                mPendingIdleHandlers[i] = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// release the reference to the handler</span><br><br>                <span class="hljs-keyword">boolean</span> keep = <span class="hljs-keyword">false</span>;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    keep = idler.queueIdle();<br>                &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>                    Log.wtf(TAG, <span class="hljs-string">&quot;IdleHandler threw exception&quot;</span>, t);<br>                &#125;<br><br>                <span class="hljs-keyword">if</span> (!keep) &#123;<br>                    <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>                        mIdleHandlers.remove(idler);<br>                    &#125;<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-comment">// Reset the idle handler count to 0 so we do not run them again.</span><br>            pendingIdleHandlerCount = <span class="hljs-number">0</span>;<br><br>            <span class="hljs-comment">// While calling an idle handler, a new message could have been delivered</span><br>            <span class="hljs-comment">// so go back and look again for a pending message without waiting.</span><br>            nextPollTimeoutMillis = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br><br></code></pre></td></tr></table></figure><p>这个方法的返回值是一个Message，很显然，这个方法就是从MessageQueue中取出消息的。我们注意到第12行代码，这里是一个for(;;)死循环。如果在MessageQueue中有Message的时候，next会将这个Message移除并返回。而当MessageQueue为空时，next方法将会被阻塞。</p><h3 id="4-回归Looper"><a href="#4-回归Looper" class="headerlink" title="4.回归Looper"></a>4.回归Looper</h3><p>我们了解了MessageQueue的插入和删除，但直到此时还没有看到在什么地方调用了MessageQueue的next方法将消息取出的。此时，我们将目光再次回归到Looper中。如果你刚才留意了ActivityThread中的main方法的话，应该注意到了main方法中的Looper.loop()方法,没错，一切将从这里开始，只有调用loop方法后消息循环系统才会真正运作起来，我们们来看loop的源码：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * Run the message queue in this thread. Be sure to call</span><br><span class="hljs-comment">    * &#123;@link #quit()&#125; to end the loop.</span><br><span class="hljs-comment">    */</span><br>   public static void loop<span class="hljs-literal">()</span> &#123;<br>       final Looper me = my<span class="hljs-constructor">Looper()</span>;<br>       <span class="hljs-keyword">if</span> (me<span class="hljs-operator"> == </span>null) &#123;<br>           throw <span class="hljs-keyword">new</span> <span class="hljs-constructor">RuntimeException(<span class="hljs-string">&quot;No Looper; Looper.prepare() wasn&#x27;t called on this thread.&quot;</span>)</span>;<br>       &#125;<br>       final MessageQueue queue = me.mQueue;<br><br>       <span class="hljs-comment">// Make sure the identity of this thread is that of the local process,</span><br>       <span class="hljs-comment">// and keep track of what that identity token actually is.</span><br>       <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Binder</span>.</span></span>clear<span class="hljs-constructor">CallingIdentity()</span>;<br>       final long ident = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Binder</span>.</span></span>clear<span class="hljs-constructor">CallingIdentity()</span>;<br><br>       <span class="hljs-keyword">for</span> (;;) &#123;<br>           Message msg = queue.next<span class="hljs-literal">()</span>; <span class="hljs-comment">// might block</span><br>           <span class="hljs-keyword">if</span> (msg<span class="hljs-operator"> == </span>null) &#123;<br>               <span class="hljs-comment">// No message indicates that the message queue is quitting.</span><br>               return;<br>           &#125;<br><br>           <span class="hljs-comment">// This must be in a local variable, in case a UI event sets the logger</span><br>           final Printer logging = me.mLogging;<br>           <span class="hljs-keyword">if</span> (logging != null) &#123;<br>               logging.println(<span class="hljs-string">&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot;</span> + msg.target + <span class="hljs-string">&quot; &quot;</span> +<br>                       msg.callback + <span class="hljs-string">&quot;: &quot;</span> + msg.what);<br>           &#125;<br><br>           final long traceTag = me.mTraceTag;<br>           <span class="hljs-keyword">if</span> (traceTag != <span class="hljs-number">0</span><span class="hljs-operator"> &amp;&amp; </span><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Trace</span>.</span></span>is<span class="hljs-constructor">TagEnabled(<span class="hljs-params">traceTag</span>)</span>) &#123;<br>               <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Trace</span>.</span></span>trace<span class="hljs-constructor">Begin(<span class="hljs-params">traceTag</span>, <span class="hljs-params">msg</span>.<span class="hljs-params">target</span>.<span class="hljs-params">getTraceName</span>(<span class="hljs-params">msg</span>)</span>);<br>           &#125;<br>           <span class="hljs-keyword">try</span> &#123;<br>               msg.target.dispatch<span class="hljs-constructor">Message(<span class="hljs-params">msg</span>)</span>;<br>           &#125; finally &#123;<br>               <span class="hljs-keyword">if</span> (traceTag != <span class="hljs-number">0</span>) &#123;<br>                   <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Trace</span>.</span></span>trace<span class="hljs-constructor">End(<span class="hljs-params">traceTag</span>)</span>;<br>               &#125;<br>           &#125;<br><br>           <span class="hljs-keyword">if</span> (logging != null) &#123;<br>               logging.println(<span class="hljs-string">&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot;</span> + msg.target + <span class="hljs-string">&quot; &quot;</span> + msg.callback);<br>           &#125;<br><br>           <span class="hljs-comment">// Make sure that during the course of dispatching the</span><br>           <span class="hljs-comment">// identity of the thread wasn&#x27;t corrupted.</span><br>           final long newIdent = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Binder</span>.</span></span>clear<span class="hljs-constructor">CallingIdentity()</span>;<br>           <span class="hljs-keyword">if</span> (ident != newIdent) &#123;<br>               <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Log</span>.</span></span>wtf(TAG, <span class="hljs-string">&quot;Thread identity changed from 0x&quot;</span><br>                       + <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Long</span>.</span></span><span class="hljs-keyword">to</span><span class="hljs-constructor">HexString(<span class="hljs-params">ident</span>)</span> + <span class="hljs-string">&quot; to 0x&quot;</span><br>                       + <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Long</span>.</span></span><span class="hljs-keyword">to</span><span class="hljs-constructor">HexString(<span class="hljs-params">newIdent</span>)</span> + <span class="hljs-string">&quot; while dispatching to &quot;</span><br>                       + msg.target.get<span class="hljs-constructor">Class()</span>.get<span class="hljs-constructor">Name()</span> + <span class="hljs-string">&quot; &quot;</span><br>                       + msg.callback + <span class="hljs-string">&quot; what=&quot;</span> + msg.what);<br>           &#125;<br><br>           msg.recycle<span class="hljs-constructor">Unchecked()</span>;<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><p>这里的loop方法同样也是一个死循环。只有当MessageQueue.next()返回null时才会跳出循环。上一小节中我们分析了Message.next方法是一个阻塞操作当MessageQueue中没有消息时next方法会一直被阻塞，因此也致使loop方法被阻塞。而当MessageQueue中添加了一条消息后，loop方法则会立即通过MessageQueue.next方法将消息取出并处理。可以看到通过调用msg.target.dispatchMessage(msg)处理消息。而msg.target是什么呢？我们回过头来看本章第二小节，在Handler的enqueueMessage中将Handler赋值给了msg.target,我们从Message的源码中也可以得到印证：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Message</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Parcelable</span> </span>&#123;<br>...<br><br>  <span class="hljs-comment">/*package*/</span> Handler target;<br><br>...<br>&#125;<br><br></code></pre></td></tr></table></figure><p>也就是此时的target其实就是Handler本身，此时我们找到Handler的dispatchMessage方法，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dispatchMessage</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Message msg)</span> </span>&#123;<br>       <span class="hljs-keyword">if</span> (msg.callback != <span class="hljs-keyword">null</span>) &#123;<br>           handleCallback(msg);<br>       &#125; <span class="hljs-keyword">else</span> &#123;<br>           <span class="hljs-keyword">if</span> (mCallback != <span class="hljs-keyword">null</span>) &#123;<br>               <span class="hljs-keyword">if</span> (mCallback.handleMessage(msg)) &#123;<br>                   <span class="hljs-keyword">return</span>;<br>               &#125;<br>           &#125;<br>           handleMessage(msg);<br>       &#125;<br>   &#125;<br><br></code></pre></td></tr></table></figure><p>看到这里想必大家应该就都明白了，上述代码首先检查了Message的callback是否为null，不为null就通过handleCallback来处理消息。Message的callback是一个Runnable对象，实际上就是Handler的post方法传递的Runnable参数，此时对应的是我们在第一章中的场景二。handleCallback方法代码如下：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleCallback</span><span class="hljs-params">(Message message)</span> </span>&#123;<br>        message.callback.<span class="hljs-built_in">run</span>();<br>    &#125;<br></code></pre></td></tr></table></figure><p>emmmm….原来我们post出来的Runnable的run方法就是在这里被调用的呀！</p><p>接着检查mCallback是否为null，不为null就调用mCallback的handleMessage方法处理消息，这里对应的是我们在实例化Handler时传入的Callback参数。如果mCallback也为null的话则调用了Handler中的handleMessage(msg)方法。这不正对应了我们第一章的场景一嘛！因此现在再来看下面的代码会不会豁然开朗呢？</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><br><span class="hljs-comment">//实例化Handler对象 传入Callback参数并重写handleMessage(Message msg)</span><br> <span class="hljs-keyword">static</span> Handler mHandler1 = <span class="hljs-keyword">new</span> Handler(<span class="hljs-keyword">new</span> Handler.Callback() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">handleMessage</span><span class="hljs-params">(Message msg)</span> </span>&#123;<br><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>    &#125;);<br><br><span class="hljs-comment">//实例化Handler对象 并重写Handler中的handleMessage(Message msg)</span><br>handleMessage(Message msg)<br> <span class="hljs-keyword">static</span> Handler mHandler = <span class="hljs-keyword">new</span> Handler()&#123;<br>  <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">handleMessage</span><span class="hljs-params">(Message msg)</span> </span>&#123;<br><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><p>到这里我们总算把Handler的消息机制给串联了起来。</p><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p> Handler、Looper和MessageQueue三者共支撑了Android中的消息机制。在使用的时候我们通常只需要和Handler打交道，通过Handler将消息发送出来。而在Handler内部的MessageQueue通过equeueMessage方法将Handler发送的消息以队列的形式进行存储。而Looper则作为一个消息泵，通过loop方法不断的调用MessageQueue的next方法将消息取出并进行处理，依次完成了整个的消息循环。同时，我们还应该特别强调ThreadLocal，正是有了它的存在，才使得我们能够轻松的进行切换线程。</p><p>整个过程当如下图所示：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwOTEwMTQxMzAwODA2?x-oss-process=image/format,png" alt="这里写图片描述"></p><p>看到这里，在第一章中提到的几点疑惑相信你心中应该也已经有了答案。我们不妨再来总结一下：</p><p><strong>问题1：</strong> 在场景1中Handler在子线程中发送出来的消息为什么到了dispatchMessage方法就变成了主线程呢？<br>虽然post消息是在子线程，但因为Handler是在主线程中被实例化的，由于在ActivityThread的main方法中调用了Looper.prepare(),因此，通过ThreadLocal将Looper缓存到了主线程中，而MessageQueue是Looper的成员变量，所以其也应是在主线程中。同时，Looper.loop方法将Message取出并通过Message.target.handlerMessage方法最终调用了dispatchMessage方法，所以dispatchMessage方法当然也是在主线程了。</p><p><strong>问题2：</strong> 在场景2的代码中我故意在子线程中调用了Handler的postDelayed方法，那么此时通过postDelayed方法发出来的Runnable究竟是运行在主线程还是子线程呢？</p><p>这个问题其实和问题1本质上是同一个问题，就无需多言了！</p><p><strong>问题3</strong>在文中已经给出了答案，这里也不再赘述。</p>]]></content>
    
    
    <categories>
      
      <category>源码分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android夜间模式实现方案</title>
    <link href="/2017/07/27/11.Android%20night%20mode/"/>
    <url>/2017/07/27/11.Android%20night%20mode/</url>
    
    <content type="html"><![CDATA[<p>对于一款阅读类的软件，夜间模式是不可缺少的。最初看到这个需求时候觉得无从下手，没有一点头绪。后来通过查阅资料发现Android官方在Support Library 23.2.0中已经加入了夜间主题。也就是只需要通过更换主题便可实现日间模式和夜间模式的切换。下面截取项目实现的夜间模式效果图：<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNzI3MjEyOTM4NjYy?x-oss-process=image/format,png" alt="这里写图片描述"><br>效果看起来还比较nice，没有闪屏，过度也比较平滑。那么项目中的这个日间、夜间模式切换效果是如何实现的呢？下面将从以下几个方面来讲解：</p><ul><li>一 实现夜间模式需要的配置</li><li>二 实现白天和夜间模式的切换</li><li>三 实现夜间模式时遇到的问题及解决方案</li></ul><p>一、实现夜间模式需要的配置<br>1.首先在gradel中引入以下依赖</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">compile</span> &#x27;com.android.support:appcompat-v<span class="hljs-number">7</span>:<span class="hljs-number">25</span>.<span class="hljs-number">3</span>.<span class="hljs-number">1</span>&#x27;<br></code></pre></td></tr></table></figure><p>2.让我们项目的主题继承夜间模式主题，在style中设置如下主题：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;AppTheme&quot;</span> <span class="hljs-attr">parent</span>=<span class="hljs-string">&quot;Theme.AppCompat.DayNight&quot;</span>&gt;</span><br><span class="xml">       <span class="hljs-comment">&lt;!-- Customize your theme here. --&gt;</span></span><br><span class="xml">       <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;colorPrimary&quot;</span>&gt;</span>@color/colorPrimary<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="xml">       <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;colorPrimaryDark&quot;</span>&gt;</span>@color/colorPrimaryDark<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="xml">       <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;colorAccent&quot;</span>&gt;</span>@color/colorAccent<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><p>3.新建drawable-night和values-night的资源目录。如果要适配不同分辨率的屏幕则可新建drawable-night-hdip、drawable-night-xhdpi等目录来存放不同分辨率的图片资源。values-night目录下存放与夜间模式相关的value文件。本篇文章讲解仅以夜间模式和日间模式的颜色为例，在values-night目录下新建color.xml文件。</p><p>（1）新建values-night目录，如下：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNzI3MjE1NDM4MzI5?x-oss-process=image/format,png" alt="新建values-night目录1"></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNzI3MjE1NjA5Nzg1?x-oss-process=image/format,png" alt="新建values-night目录2"></p><p>（2）在values-night目录下新建colors文件，如下：<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNzI3MjIwMTUyMjM0?x-oss-process=image/format,png" alt="新建colors文件1"></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNzI3MjIwMzAyNzg2?x-oss-process=image/format,png" alt="新建colors文件2"><br>接下来只需要在对应的colors文件下写不同的颜色值(夜间颜色值和白天颜色值)即可。至此关于实现夜间模式的配置已经基本完成。</p><p>二、实现白天和夜间模式的切换<br>1.启动App时检测是否处于夜间模式，如果是则切换至夜间主题。这个需要在自己项目的Application中实现。可在自己项目的Application中添加以下代码：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * 初始化夜间模式</span><br><span class="hljs-comment">  */</span><br>   <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setNightMode</span><span class="hljs-params">()</span> </span>&#123;<br>       <span class="hljs-keyword">boolean</span> nightMode = UserInfoTools.isNightMode(<span class="hljs-keyword">this</span>);<br>       AppCompatDelegate.setDefaultNightMode(nightMode ?<br>               AppCompatDelegate.MODE_NIGHT_YES : AppCompatDelegate.MODE_NIGHT_NO);<br>   &#125;<br></code></pre></td></tr></table></figure><p>这里需要介绍一下有关夜间模式的几个常量值。AppCompatDelegate.setDefaultNightMode(mode),其中mode有一下四个值：</p><ul><li>MODE_NIGHT_NO： 亮色(light)主题，不使用夜间模式</li><li>MODE_NIGHT_YES：暗色(dark)主题，使用夜间模式</li><li>MODE_NIGHT_AUTO：根据当前时间自动切换 亮色(light)/暗色(dark)主题（22：00-07：00时间段内自动切换为夜间模式）</li><li>MODE_NIGHT_FOLLOW_SYSTEM(默认选项)：设置为跟随系统，通常为MODE_NIGHT_NO<br>2.接下来需要我们在设置页面点击ToggleButton时切换白天/夜间模式。<br>具体实现如下：<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">private void <span class="hljs-keyword">set</span>NightMode<span class="hljs-params">()</span> &#123;<br>         <span class="hljs-string">//</span>  获取当前模式<br>        int currentNightMode = getResources<span class="hljs-params">()</span><span class="hljs-string">.getConfiguration</span><span class="hljs-params">()</span><span class="hljs-string">.uiMode</span> &amp; Configuration.UI_MODE_NIGHT_MASK;<br>        <span class="hljs-string">//</span>  将是否为夜间模式保存到SharedPreferences<br>        UserInfoTools.<span class="hljs-keyword">set</span>NightMode<span class="hljs-params">(this, <span class="hljs-attr">currentNightMode</span> == Configuration.UI_MODE_NIGHT_NO)</span>;<br>        <span class="hljs-string">//</span>  切换模式<br>        getDelegate<span class="hljs-params">()</span><span class="hljs-string">.setDefaultNightMode</span><span class="hljs-params">(<span class="hljs-attr">currentNightMode</span> == Configuration.UI_MODE_NIGHT_NO ?</span><br><span class="hljs-params">                AppCompatDelegate.MODE_NIGHT_YES : AppCompatDelegate.MODE_NIGHT_NO)</span>;<br>        UserInfoTools.<span class="hljs-keyword">set</span>ChangeNightMode<span class="hljs-params">(this,true)</span>;<br>        <span class="hljs-string">//</span>  重启Activity<br>        recreate<span class="hljs-params">()</span>;<br>    &#125;<br><br>private void <span class="hljs-keyword">set</span>Listener<span class="hljs-params">()</span> &#123;<br>        mToggleButton.<span class="hljs-keyword">set</span>OnClickListener<span class="hljs-params">((View v)</span> -&gt; &#123;<br>            <span class="hljs-keyword">set</span>NightMode<span class="hljs-params">()</span>;<br>        &#125;);<br>    &#125;<br></code></pre></td></tr></table></figure>注意，上面代码中设置白天/夜间模式的代码的最后调用了recreate()方法重启了当前Activity。但这样写切换模式时会有闪屏问题，体验比较差。具体优化将在下一节中实现。</li></ul><p>三 、实现夜间模式时遇到的问题及解决方案<br>利用谷歌官方提供的这个方案实现夜间模式的过程中遇到了不少的问题。且网上资料较少，大多文章讲解仅仅以一个简单的demo为例。但在用到实际项目中时会遇到很多的麻烦。这里主要总结了笔者曾经遇到过的难以解决的几个问题。<br>1.白天/夜间模式切换时闪屏问题<br>上一节中已经提到了在调用recreate()方法时会有闪屏问题。其实闪屏问题的解决比较简单。我们大可以不掉用recreate()方法，而是自己重启当前activity并为activity设置启动和退出动画即可！实现代码如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> setNightMode() &#123;<br>       <span class="hljs-comment">//  获取当前模式</span><br>       <span class="hljs-keyword">int</span> currentNightMode = getResources().getConfiguration().uiMode &amp; Configuration.UI_MODE_NIGHT_MASK;<br>       <span class="hljs-comment">//  将是否为夜间模式保存到SharedPreferences</span><br>       UserInfoTools.setNightMode(<span class="hljs-built_in">this</span>, currentNightMode == Configuration.UI_MODE_NIGHT_NO);<br>       <span class="hljs-comment">//  切换模式</span><br>       getDelegate().setDefaultNightMode(currentNightMode == Configuration.UI_MODE_NIGHT_NO ?<br>               AppCompatDelegate.MODE_NIGHT_YES : AppCompatDelegate.MODE_NIGHT_NO);<br>       UserInfoTools.setChangeNightMode(<span class="hljs-built_in">this</span>,<span class="hljs-literal">true</span>);<br><br>       <span class="hljs-comment">//recreate();</span><br><br>       startActivity(<span class="hljs-keyword">new</span> Intent(<span class="hljs-built_in">this</span>,SettingActivity.<span class="hljs-keyword">class</span>));<br>       overridePendingTransition(R.anim.animo_alph_close, R.anim.animo_alph_close);<br>       finish();<br>   &#125;<br></code></pre></td></tr></table></figure><p>如上代码，我们自行调用startActivity启动了设置页面并为其添加了一个透明渐变的启动动画。最后调用finish结束掉旧的设置页面。这样闪屏问题便迎刃而解。模式切换也变得流畅自然。<br> 2.切换夜间模式后返回MainActivity,MainActivity页面没有更新。解决这个问题可以在切换模式后从设置页面发送一个广播，然后在MainActivity中接收到这个广播后重启MainActivity即可。根据官方的推荐更换夜间模式后需要调用recreate()方法刷新页面。但是recreate()方法巨坑无比，调用recreate()方法引起了诸多问题。详见问题3、4、5。因此解决这个问题笔者并没有在MainActivity调用中调用recreate()方法。而是在SettingActivity中定义了一个boolean值来标记是否切换了夜间模式。然后重写了onKeyDown()方法。如果切换了夜间模式则在返回时发出一个广播结束掉MainActivity,然后调用startActivity()重启了MainActivity并添加了启动动画，让用户感觉是只是返回了主页面。其实思想跟解决问题1有些类似。还是结合代码来看吧。</p><p>SettingActivity中的代码</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">@Override<br>   public boolean on<span class="hljs-constructor">KeyDown(<span class="hljs-params">int</span> <span class="hljs-params">keyCode</span>, KeyEvent <span class="hljs-params">event</span>)</span> &#123;<br>       <span class="hljs-keyword">if</span> (keyCode<span class="hljs-operator"> == </span>KeyEvent.KEYCODE_BACK<span class="hljs-operator"> &amp;&amp; </span>event.get<span class="hljs-constructor">Action()</span><span class="hljs-operator"> == </span>KeyEvent.ACTION_DOWN) &#123;<br>           go<span class="hljs-constructor">Back()</span>;<br>           return <span class="hljs-literal">true</span>;<br>       &#125;<br>       return super.on<span class="hljs-constructor">KeyDown(<span class="hljs-params">keyCode</span>, <span class="hljs-params">event</span>)</span>;<br>   &#125;<br><br>   <span class="hljs-keyword">private</span> void go<span class="hljs-constructor">Back()</span> &#123;<br>       <span class="hljs-keyword">if</span> (isChangeNightMode) &#123;  <span class="hljs-comment">//  如果改变了夜间模式，则重启MainActivity</span><br>           <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">EventBus</span>.</span></span>get<span class="hljs-constructor">Default()</span>.post(<span class="hljs-keyword">new</span> <span class="hljs-constructor">NightModeEvent()</span>);<br>           Intent intent = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Intent(<span class="hljs-params">this</span>, MainActivity.<span class="hljs-params">class</span>)</span>;<br>           intent.put<span class="hljs-constructor">Extra(<span class="hljs-string">&quot;nightMode&quot;</span>, <span class="hljs-params">true</span>)</span>;<br>           start<span class="hljs-constructor">Activity(<span class="hljs-params">intent</span>)</span>;<br>           override<span class="hljs-constructor">PendingTransition(R.<span class="hljs-params">anim</span>.<span class="hljs-params">animo_alph_close</span>, R.<span class="hljs-params">anim</span>.<span class="hljs-params">activity_close</span>)</span>;<br>       &#125;<br>       finish<span class="hljs-literal">()</span>;<br>   &#125;<br></code></pre></td></tr></table></figure><p>MainActivity中的代码：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"> @Override<br>   public void on<span class="hljs-constructor">Create(Bundle <span class="hljs-params">savedInstanceState</span>)</span> &#123;<br>       super.on<span class="hljs-constructor">Create(<span class="hljs-params">savedInstanceState</span>)</span>;<br>       set<span class="hljs-constructor">ContentView(R.<span class="hljs-params">layout</span>.<span class="hljs-params">activity_main</span>)</span>;<br><br>       re<span class="hljs-constructor">StartActivity()</span><br>   &#125;<br><br><span class="hljs-comment">//  改变夜间模式后返回时重启Activity</span><br>   <span class="hljs-keyword">private</span> void re<span class="hljs-constructor">StartActivity()</span> &#123;<br>       Intent intent = get<span class="hljs-constructor">Intent()</span>;<br>       boolean nightMode = intent.get<span class="hljs-constructor">BooleanExtra(<span class="hljs-string">&quot;nightMode&quot;</span>, <span class="hljs-params">false</span>)</span>;<br>       <span class="hljs-keyword">if</span>(nightMode&amp;&amp;<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">UserInfoTools</span>.</span></span>get<span class="hljs-constructor">IsLogin(<span class="hljs-params">this</span>)</span>)&#123;<br>           <span class="hljs-comment">//  自动切换到“我的”页面</span><br>           mRbMe.perform<span class="hljs-constructor">Click()</span>;<br>       &#125;<br>   &#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 接收到夜间模式改变的事件后结束当前Activity</span><br><span class="hljs-comment">    * @param event</span><br><span class="hljs-comment">    */</span><br> @Subscribe<br>   public void set<span class="hljs-constructor">NightMode(NightModeEvent <span class="hljs-params">event</span>)</span> &#123;<br>       finish<span class="hljs-literal">()</span>;<br>   &#125;<br></code></pre></td></tr></table></figure><p>最后还有点问题需要说明，由问题1我们可以知道，改变模式后，我们重启了SettingActivity。因此在该类中定义的一个标记是否切换了夜间模式的boolean值并不能起到作用。解决办法是将这个值保存到SharedPreference中。然后重启SettingActivity后再取出该值。可以看代码，这点真心有点绕啊。。。<br>注意问题1中的setNightMode()方法中有一句代码 UserInfoTools.setChangeNightMode(this,true);将改变了夜间模式设置为了true并保存到了SharedPreferences中，然后在onCreate()中有以下代码来初始化isChangeNightMode的值。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">@Override<br>   public void on<span class="hljs-constructor">Create(Bundle <span class="hljs-params">savedInstanceState</span>)</span> &#123;<br>       super.on<span class="hljs-constructor">Create(<span class="hljs-params">savedInstanceState</span>)</span>;<br>       set<span class="hljs-constructor">ContentView(R.<span class="hljs-params">layout</span>.<span class="hljs-params">activity_main</span>)</span>;<br>                isChangeNightMode=<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">UserInfoTools</span>.</span></span>is<span class="hljs-constructor">ChangeNightMode(<span class="hljs-params">this</span>)</span>;<br>       <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">UserInfoTools</span>.</span></span>set<span class="hljs-constructor">ChangeNightMode(<span class="hljs-params">this</span>,<span class="hljs-params">false</span>)</span>;<br>   &#125;<br><br></code></pre></td></tr></table></figure><p>3.设置白天/夜间模式后出现无故闪退问题<br>这个问题说来比较奇怪，原因是切换了夜间模式后在MainActivity中调用了recreate()方法。具体原因笔者也没有弄清楚，调试了好一阵子也没有找出个所以然来。后来果断放弃了在MainActivity中调用recreate()方法，而是换成了startActivity()重新启动了MainActivity。之后这个问题便不复存在了。</p><p>4.点击ToggleButton切换模式后应用黑屏，随后挂掉。这个问题的最终原因还是因为recreate()方法引起的。如果你用了ToggleButton切换白天/夜间模式，并且为ToggleButton设置了setOnCheckChangedListener()方法，那么你将有很大概率碰到这个问题。引起这个问题的原因是因为调用了recreate()方法后Activity重新启动，但是新启动的Activity保存了之前Activity的状态。因此在重启时候重新设置了TouggleButton，继而调用了又setOnCheckChangedListener()方法，结果悲剧了。。。一个死循环产生了，程序不黑屏才怪。因此最简单的办法是放弃recreate()方法，改用问题1中的方法！（其实细心的小伙伴应该已经发现了，我的代码中仅仅是为ToggleButton设置了setOnClickListener()….机智如我啊）如果你有强迫症必须要使用setOnCheckChangedListener和recreate()方法那么也不是没有解决方案。可以定义一个boolean成员变量，然后在onCreate()方法中判断savedInstanceState是否为null，然后给这个boolean成员变量赋值，并在setOnCheckChangedListener()方法中根据这个boolean成员变量的值去调用设置夜间模式的方法即可。</p><p>5.设置夜间模式后MainActivity调用recreate()方法，MainActivity中的”发现“页面没有加载出来。发现页面如下面图片所示，也就是一个Fragment中嵌套了一个ViewPager。调用recreate()后整个ViewPager消失了。。。没有加载出来！！！<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNzI3MjM0MTQ3Mzg0?x-oss-process=image/format,png" alt="这里写图片描述"><br>解决方案，放弃使用recreate()，改用问题1中的方法！</p><p>万恶的recreate()方法！难道是我使用的姿势不对？</p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>夜间模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RxJava+Retrofit之token自动刷新（二）</title>
    <link href="/2017/07/27/10.RxJava%20and%20Retrofit-refresh%20token%20(2)/"/>
    <url>/2017/07/27/10.RxJava%20and%20Retrofit-refresh%20token%20(2)/</url>
    
    <content type="html"><![CDATA[<p><a href="http://blog.csdn.net/qq_20521573/article/details/70991850"> 上篇文章</a>主要对Retrofit做了封装，使之使用起来更加方便。在之前的封装中token过期再次刷新token后需要手动调用之前的请求，这种处理方式不够优雅，因此，在原有的基础上，本篇文章将基于上篇文章的封装并优化Token验证机制。使之能够实现过期自动刷新并重新调用请求。<br>接下来将通过以下几个小节来学习如何实现token验证。</p><ul><li>为什么要引入token机制</li><li>token机制的验证流程</li><li>RxJava+Retrofit封装实现token验证</li></ul><h1 id="一、为什么引入token机制"><a href="#一、为什么引入token机制" class="headerlink" title="一、为什么引入token机制"></a>一、为什么引入token机制</h1><h1 id="1-token是什么？"><a href="#1-token是什么？" class="headerlink" title="1.token是什么？"></a>1.token是什么？</h1><p>token意为令牌，通常是由客户端携带IMEI/Mac到服务器，服务器根据客户端的IMEI/Mac生成一段字符串并返回给客户端，并为其设置有效期。以此作为客户端和服务端交互的令牌。客户端每次请求都会携带token到服务器来代替用户名和密码。服务端验证token有效后则返回数据给客户端，否则返回特定的错误码给客户端。客户端根据错误码去做相应的处理。</p><h2 id="2-那么为什么引入token机制呢？"><a href="#2-那么为什么引入token机制呢？" class="headerlink" title="2.那么为什么引入token机制呢？"></a>2.那么为什么引入token机制呢？</h2><p>主要有以下两个原因：<br>（1）保证安全性。如果不引入token机制，那么我们每次请求数据都要携带用户名和密码。也就是每次请求数据用户名和密码都会在网络上传输。这样大大增加了安全风险，很容易被黑客截取。因此引入token机制也一定程度上保证了安全性。<br>（2）减小服务器压力。在引入token机制前，我们需要通过用户名和密码到服务器去验证用户身份是否合法。服务器认证用户名和密码是一个查询操作，如果用户量大，那么就会相应增加服务器的压力。而引入token机制后，服务器就可以将token作为一个用户的唯一标识来验证用户身份是否合法。这样可以大大减少服务器的压力。</p><h2 id="二、token机制的验证流程"><a href="#二、token机制的验证流程" class="headerlink" title="二、token机制的验证流程"></a>二、token机制的验证流程</h2><p>token的验证流程并非唯一的，至于使用怎样的验证流程可以自行确定。本文中采用OAuth2.0协议实现token验证机制。<br>主要步骤如下：</p><ol><li>通过用户名和密码登录成功获取token和refreshToken并保存到本地。</li><li>token的有效期为2小时，refreshToken的有效期为15天。</li><li>每次网络请求都需要带上token，而不必带上refreshToken。</li><li>如果服务器端判断token过期，则返回对应的错误码，客户端判断错误码后调用刷新token接口,重新获取token和refreshToken并存储。</li><li>如果连续15天未使用app或者用户修改了密码，则refreshToken过期，需要重新登录获取token和refreshToken。</li></ol><h1 id="三、RxJava-Retrofit封装实现token自动刷新"><a href="#三、RxJava-Retrofit封装实现token自动刷新" class="headerlink" title="三、RxJava+Retrofit封装实现token自动刷新"></a>三、RxJava+Retrofit封装实现token自动刷新</h1><p>有了以上两节的基础，我们就可以来自己实现token机制的验证了。在这里我们使用<a href="http://blog.csdn.net/qq_20521573/article/details/70991850">上篇文章</a>中封装的RxJava和Retrofit来实现token机制。</p><h2 id="1-登录认证，获取token和refresh-token"><a href="#1-登录认证，获取token和refresh-token" class="headerlink" title="1.登录认证，获取token和refresh_token"></a>1.登录认证，获取token和refresh_token</h2><p>登录时我们需要两个参数：用户名username、密码password以及appkey作为一个唯一id，每次登录成功服务器会返回token和refreshToken。登录请求的实体类LoginRequest如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginRequest</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BaseRequest</span></span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> userId;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> password;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来我们就可以来调用登录接口获取token了。登录成功后我们可将token和refreshToekn存储到本地。以提交表单为例，代码如下：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public void login<span class="hljs-literal">()</span> &#123;<br>         Map&lt;String, Object&gt; map = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">MapUtils</span>.</span></span>entity<span class="hljs-constructor">ToMap(<span class="hljs-params">new</span> BaseRequest()</span>);<br>        map.put(<span class="hljs-string">&quot;userId&quot;</span>,<span class="hljs-string">&quot;123456&quot;</span>);<br>        map.put(<span class="hljs-string">&quot;password&quot;</span>,<span class="hljs-string">&quot;123123&quot;</span>);<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">IdeaApi</span>.</span></span>get<span class="hljs-constructor">ApiService()</span><br>                .login(map)<br>                .subscribe<span class="hljs-constructor">On(Schedulers.<span class="hljs-params">io</span>()</span>)<br>                .compose(activity.&lt;BasicResponse&lt;LoginResponse&gt;&gt;bind<span class="hljs-constructor">ToLifecycle()</span>)<br>                .observe<span class="hljs-constructor">On(AndroidSchedulers.<span class="hljs-params">mainThread</span>()</span>)<br>                .subscribe(<span class="hljs-keyword">new</span> DefaultObserver&lt;BasicResponse&lt;LoginResponse&gt;&gt;(activity) &#123;<br>                    @Override<br>                    public void on<span class="hljs-constructor">Success(BasicResponse&lt;LoginResponse&gt; <span class="hljs-params">response</span>)</span> &#123;<br>                        LoginResponse results = response.get<span class="hljs-constructor">Results()</span>;<br>                        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ToastUtils</span>.</span></span>show(<span class="hljs-string">&quot;登录成功！获取到token&quot;</span> + results.get<span class="hljs-constructor">Token()</span> + <span class="hljs-string">&quot;,可以存储到本地了&quot;</span>);<br>                        <span class="hljs-comment">/**</span><br><span class="hljs-comment">                         * 可以将这些数据存储到User中，User存储到本地数据库</span><br><span class="hljs-comment">                         */</span><br>                        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">SharedPreferencesHelper</span>.</span></span>put(activity, <span class="hljs-string">&quot;token&quot;</span>, results.get<span class="hljs-constructor">Token()</span>);<br>                        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">SharedPreferencesHelper</span>.</span></span>put(activity, <span class="hljs-string">&quot;refresh_token&quot;</span>, results.get<span class="hljs-constructor">Refresh_token()</span>);<br>                        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">SharedPreferencesHelper</span>.</span></span>put(activity, <span class="hljs-string">&quot;refresh_secret&quot;</span>, results.get<span class="hljs-constructor">Refresh_secret()</span>);<br>                    &#125;<br>                &#125;);<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="2-明确需求，抛出异常"><a href="#2-明确需求，抛出异常" class="headerlink" title="2.明确需求，抛出异常"></a>2.明确需求，抛出异常</h2><p>由于token的有效期较短，因此我们需要经常刷新token来保证token的有效性。在请求网络的时候如果token过期或者无效服务器会给我们返回对应的错误码。我们需要根据状态码来判断token是否失效。如果失效则调用刷新token接口重新获取token。如果refreshToekn也过期那么我们需要重新登录。</p><p>现在，我们的需求是要实现token过期后自动刷新，刷新成功后自动调用原来的请求，如果refreshToken也过期，则退出登录。基于此，我们可以联想到RxJava的retryWhen操作符，我们可以通过retryWhen操作符判断token过期并自动刷新。</p><p>那么，接下来我们首要任务是如何判断token和refreshToken过期。还记得上篇文章中我们修改GsonResponseBodyConverter类来根据后台响应码来获取data中的数据。显然在此处判断token是否过期是比较合适的。接下来看GsonResponseBodyConverter中的代码：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">@Override<br> public Object convert(ResponseBody value) throws IOException &#123;<br>     <span class="hljs-keyword">try</span> &#123;<br>         BasicResponse response = (BasicResponse) adapter.from<span class="hljs-constructor">Json(<span class="hljs-params">value</span>.<span class="hljs-params">charStream</span>()</span>);<br>         <span class="hljs-keyword">if</span> (response.get<span class="hljs-constructor">Code()</span><span class="hljs-operator"> == </span>SUCCESS) &#123;<br>             <span class="hljs-keyword">if</span> (response.get<span class="hljs-constructor">Data()</span><span class="hljs-operator"> == </span>null)<br>                 throw <span class="hljs-keyword">new</span> <span class="hljs-constructor">ServerNoDataException(0, <span class="hljs-string">&quot;&quot;</span>)</span>;<br>             return response.get<span class="hljs-constructor">Data()</span>;<br>         &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (response.get<span class="hljs-constructor">Code()</span><span class="hljs-operator"> == </span>TOKEN_EXPIRED) &#123;<br>             throw <span class="hljs-keyword">new</span> <span class="hljs-constructor">TokenExpiredException(<span class="hljs-params">response</span>.<span class="hljs-params">getCode</span>()</span>, response.get<span class="hljs-constructor">Message()</span>);<br>         &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (response.get<span class="hljs-constructor">Code()</span><span class="hljs-operator"> == </span>REFRESH_TOKEN_EXPIRED) &#123;<br>             throw <span class="hljs-keyword">new</span> <span class="hljs-constructor">RefreshTokenExpiredException(<span class="hljs-params">response</span>.<span class="hljs-params">getCode</span>()</span>, response.get<span class="hljs-constructor">Message()</span>);<br>         &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (response.get<span class="hljs-constructor">Code()</span> != SUCCESS) &#123;<br>             <span class="hljs-comment">// 特定 API 的错误，在相应的 DefaultObserver 的 onError 的方法中进行处理</span><br>             throw <span class="hljs-keyword">new</span> <span class="hljs-constructor">ServerResponseException(<span class="hljs-params">response</span>.<span class="hljs-params">getCode</span>()</span>, response.get<span class="hljs-constructor">Message()</span>);<br>         &#125;<br>     &#125; finally &#123;<br>         value.close<span class="hljs-literal">()</span>;<br>     &#125;<br>     return null;<br> &#125; <br></code></pre></td></tr></table></figure><p>上面代码中我们自定义了几个异常，在判断对应的错误码后抛出对应的异常。此处我们可以着重关心下TokenExpiredException和RefreshTokenExpiredException，分别代表了token过期和refreshToken过期。</p><h2 id="3-添加代理，实现token过期自动刷新"><a href="#3-添加代理，实现token过期自动刷新" class="headerlink" title="3.添加代理，实现token过期自动刷新"></a>3.添加代理，实现token过期自动刷新</h2><p>因为几乎所有的请求都需要验证token是否过期，因此需要做统一处理。我们可以采用代理类来对Retrofit的API做统一的代理处理。代码如下：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public <span class="hljs-keyword">class</span> IdeaApiProxy implements IGlobalManager &#123;<br>    @<span class="hljs-constructor">SuppressWarnings(<span class="hljs-string">&quot;unchecked&quot;</span>)</span><br>    public &lt;T&gt; T get<span class="hljs-constructor">ApiService(Class&lt;T&gt; <span class="hljs-params">tClass</span>,String <span class="hljs-params">baseUrl</span>)</span> &#123;<br>        T t = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">RetrofitService</span>.</span></span>get<span class="hljs-constructor">RetrofitBuilder(<span class="hljs-params">baseUrl</span>)</span><br>                .build<span class="hljs-literal">()</span>.create(tClass);<br>        return (T) <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Proxy</span>.</span></span><span class="hljs-keyword">new</span><span class="hljs-constructor">ProxyInstance(<span class="hljs-params">tClass</span>.<span class="hljs-params">getClassLoader</span>()</span>, <span class="hljs-keyword">new</span> Class&lt;?&gt;<span class="hljs-literal">[]</span> &#123; tClass &#125;, <span class="hljs-keyword">new</span> <span class="hljs-constructor">ProxyHandler(<span class="hljs-params">t</span>, <span class="hljs-params">this</span>)</span>);<br>    &#125;<br><br>    @Override<br>    public void exit<span class="hljs-constructor">Login()</span> &#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样，我们就需要通过IdeaApiProxy 中的getApiService方法来创建API请求。其中的ProxyHandler则是实现了InvocationHandler。ProxyHandler类是我们处理token自动刷新的核心类。思想就是针对 method 的调用，做以 retryWhen 的包装，在retryWhen 中获取相应的异常信息来做处理，看 retryWhen 的代码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs php">@Override<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">Object</span> invoke(<span class="hljs-keyword">Object</span> proxy, <span class="hljs-keyword">final</span> Method method, <span class="hljs-keyword">final</span> <span class="hljs-keyword">Object</span>[] args) throws <span class="hljs-built_in">Throwable</span> &#123;<br>      <span class="hljs-keyword">return</span> Observable.just(<span class="hljs-literal">true</span>).flatMap(<span class="hljs-keyword">new</span> <span class="hljs-function"><span class="hljs-keyword">Function</span>&lt;<span class="hljs-title">Object</span>, <span class="hljs-title">ObservableSource</span>&lt;?&gt;&gt;(<span class="hljs-params"></span>) </span>&#123;<br>          @Override<br>          <span class="hljs-keyword">public</span> ObservableSource<span class="hljs-meta">&lt;?</span>&gt; apply(<span class="hljs-keyword">Object</span> o) throws <span class="hljs-built_in">Exception</span> &#123;<br>              <span class="hljs-keyword">try</span> &#123;<br>                  <span class="hljs-keyword">try</span> &#123;<br>                      <span class="hljs-keyword">if</span> (mIsTokenNeedRefresh) &#123;<br>                          updateMethodToken(method, args);<br>                      &#125;<br>                      <span class="hljs-keyword">return</span> (Observable<span class="hljs-meta">&lt;?</span>&gt;) method.invoke(mProxyObject, args);<br>                  &#125; <span class="hljs-keyword">catch</span> (InvocationTargetException e) &#123;<br>                      e.printStackTrace();<br>                  &#125;<br>              &#125; <span class="hljs-keyword">catch</span> (IllegalAccessException e) &#123;<br>                  e.printStackTrace();<br>              &#125;<br>              <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>          &#125;<br>      &#125;).retryWhen(<span class="hljs-keyword">new</span> <span class="hljs-function"><span class="hljs-keyword">Function</span>&lt;<span class="hljs-title">Observable</span>&lt;<span class="hljs-title">Throwable</span>&gt;, <span class="hljs-title">ObservableSource</span>&lt;?&gt;&gt;(<span class="hljs-params"></span>) </span>&#123;<br>          @Override<br>          <span class="hljs-keyword">public</span> ObservableSource<span class="hljs-meta">&lt;?</span>&gt; apply(Observable&lt;<span class="hljs-built_in">Throwable</span>&gt; observable) throws <span class="hljs-built_in">Exception</span> &#123;<br>              <span class="hljs-keyword">return</span> observable.flatMap(<span class="hljs-keyword">new</span> <span class="hljs-function"><span class="hljs-keyword">Function</span>&lt;<span class="hljs-title">Throwable</span>, <span class="hljs-title">ObservableSource</span>&lt;?&gt;&gt;(<span class="hljs-params"></span>) </span>&#123;<br>                  @Override<br>                  <span class="hljs-keyword">public</span> ObservableSource<span class="hljs-meta">&lt;?</span>&gt; apply(<span class="hljs-built_in">Throwable</span> <span class="hljs-built_in">throwable</span>) throws <span class="hljs-built_in">Exception</span> &#123;<br>                      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">throwable</span> <span class="hljs-keyword">instanceof</span> TokenExpiredException) &#123;<span class="hljs-comment">// token过期</span><br>                          <span class="hljs-keyword">return</span> refreshTokenWhenTokenInvalid();<br>                      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">throwable</span> <span class="hljs-keyword">instanceof</span> RefreshTokenExpiredException) &#123;<br>                          <span class="hljs-comment">// RefreshToken过期，执行退出登录的操作。</span><br>                          mGlobalManager.logout();<br>                          <span class="hljs-keyword">return</span> Observable.<span class="hljs-built_in">error</span>(<span class="hljs-built_in">throwable</span>);<br>                      &#125;<br>                      <span class="hljs-keyword">return</span> Observable.<span class="hljs-built_in">error</span>(<span class="hljs-built_in">throwable</span>);<br>                  &#125;<br>              &#125;);<br>          &#125;<br>      &#125;);<br>  &#125;<br></code></pre></td></tr></table></figure><p>这里针对 token 过期的 TokenExpiredException的异常，执行刷新 token 的操作，刷新 token 的操作则是直接调用 Retrofit 的方法，而不需要走代理了。另外它必须是个同步的代码块，一起来看refreshTokenWhenTokenInvalid方法中的代码：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">private</span> Observable&lt;?&gt; refresh<span class="hljs-constructor">TokenWhenTokenInvalid()</span> &#123;<br>        synchronized (<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ProxyHandler</span>.</span></span><span class="hljs-keyword">class</span>) &#123;<br>            <span class="hljs-comment">// Have refreshed the token successfully in the valid time.</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">new</span> <span class="hljs-constructor">Date()</span>.get<span class="hljs-constructor">Time()</span> - tokenChangedTime &lt; REFRESH_TOKEN_VALID_TIME) &#123;   <span class="hljs-comment">//  防止重复刷新token</span><br>                mIsTokenNeedRefresh = <span class="hljs-literal">true</span>;<br>                return <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Observable</span>.</span></span>just(<span class="hljs-literal">true</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                Map&lt;String, Object&gt; map = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">MapUtils</span>.</span></span>entity<span class="hljs-constructor">ToMap(<span class="hljs-params">new</span> BaseRequestData()</span>);<br>                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">RetrofitHelper</span>.</span></span>get<span class="hljs-constructor">ApiService()</span><br>                        .refresh<span class="hljs-constructor">Token(<span class="hljs-params">map</span>)</span><br>                        <span class="hljs-comment">//.observeOn(AndroidSchedulers.mainThread())</span><br>                        .subscribe(<span class="hljs-keyword">new</span> DefaultObserver&lt;RefreshTokenResponse&gt;<span class="hljs-literal">()</span> &#123;<br>                            @Override<br>                            public void on<span class="hljs-constructor">Success(RefreshTokenResponse <span class="hljs-params">response</span>)</span> &#123;<br>                                <span class="hljs-keyword">if</span> (response != null) &#123;<br>                                    <span class="hljs-comment">// 保存数据到本地</span><br>                                    mGlobalManager.token<span class="hljs-constructor">Refresh(<span class="hljs-params">response</span>)</span>;<br>                                    mIsTokenNeedRefresh = <span class="hljs-literal">true</span>;<br>                                    tokenChangedTime = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Date()</span>.get<span class="hljs-constructor">Time()</span>;<br>                                &#125;<br>                            &#125;<br><br>                            @Override<br>                            public void on<span class="hljs-constructor">Error(Throwable <span class="hljs-params">e</span>)</span> &#123;<br>                                super.on<span class="hljs-constructor">Error(<span class="hljs-params">e</span>)</span>;<br>                                mRefreshTokenError = e;<br>                            &#125;<br>                        &#125;);<br>                <span class="hljs-keyword">if</span> (mRefreshTokenError != null) &#123;<br>                    return <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Observable</span>.</span></span>error(mRefreshTokenError);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    return <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Observable</span>.</span></span>just(<span class="hljs-literal">true</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="4-刷新token成功后替换旧的token"><a href="#4-刷新token成功后替换旧的token" class="headerlink" title="4.刷新token成功后替换旧的token"></a>4.刷新token成功后替换旧的token</h2><p>当token刷新成功之后，我们将旧的token替换掉呢？java8中的method类，已经支持了动态获取方法名称，而之前的Java版本则是不支持的。那这里怎么办呢？通过看retrofit的调用，可以知道retrofit是可以将接口中的方法转换成API请求，并需要封装参数的。那就需要看一下Retrofit是如何实现的呢？最后发现重头戏是在Retrofit对每个方法添加的@interface的注解，通过Method类中的getParameterAnnotations来进行获取，主要的代码实现如下：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-keyword">private</span> void updateMethodToken(Method method, Object[] args) &#123;<br>        ServerKey serverKey = RealmDatabaseHelper.queryFirstFrom(ServerKey.<span class="hljs-keyword">class</span>);<br>        String token = serverKey.getToken();<br>        <span class="hljs-keyword">if</span> (mIsTokenNeedRefresh &amp;&amp; !TextUtils.isEmpty(token)) &#123;<br>            Annotation[][] annotationsArray = method.getParameterAnnotations();<br>            Annotation[] annotations;<br>            <span class="hljs-keyword">if</span> (annotationsArray != null &amp;&amp; annotationsArray.length &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; annotationsArray.length; i++) &#123;<br>                    annotations = annotationsArray[i];<br>                    <span class="hljs-keyword">for</span> (Annotation <span class="hljs-keyword">annotation</span> : <span class="hljs-title">annotations</span>) &#123;<br>                        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">annotation</span> <span class="hljs-title">instanceof</span> <span class="hljs-title">FieldMap</span>||<span class="hljs-title">annotation</span> <span class="hljs-title">instanceof</span> <span class="hljs-title">QueryMap</span>) &#123;// 以<span class="hljs-title">Map</span>方式提交表单<br>                            <span class="hljs-keyword">if</span> (args[i] instanceof Map)<br>                                ((Map&lt;String, Object&gt;) args[i]).put(TOKEN, token);<br>                        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">annotation</span> <span class="hljs-title">instanceof</span> <span class="hljs-title">Query</span>) &#123;<br>                            <span class="hljs-keyword">if</span> (TOKEN.equals(((Query) <span class="hljs-keyword">annotation</span>).<span class="hljs-title">value</span>())) &#123;<br>                                args[i] = token;<br>                            &#125;<br>                        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">annotation</span> <span class="hljs-title">instanceof</span> <span class="hljs-title">Field</span>) &#123;<br>                            <span class="hljs-keyword">if</span> (TOKEN.equals(((Field) <span class="hljs-keyword">annotation</span>).<span class="hljs-title">value</span>())) &#123;<br>                                args[i] = token;<br>                            &#125;<br>                        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-keyword">annotation</span> <span class="hljs-title">instanceof</span> <span class="hljs-title">Part</span>)&#123;   //  上传文件<br>                            <span class="hljs-keyword">if</span> (TOKEN.equals(((Part) <span class="hljs-keyword">annotation</span>).<span class="hljs-title">value</span>())) &#123;<br>                                RequestBody tokenBody = RequestBody.create(MediaType.parse(<span class="hljs-string">&quot;multipart/form-data&quot;</span>), token);<br>                                args[i] = tokenBody;<br>                            &#125;<br>                        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-keyword">annotation</span> <span class="hljs-title">instanceof</span> <span class="hljs-title">Body</span>)&#123;// <span class="hljs-title">Post</span>提交<span class="hljs-title">json</span>数据<br>                            <span class="hljs-keyword">if</span>(args[i] instanceof BaseRequest)&#123;<br>                                BaseRequest requestData= (BaseRequest) args[i];<br>                                requestData.setToken(token);<br>                                args[i]=requestData;<br>                            &#125;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>            mIsTokenNeedRefresh = <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>这里我们遍历所有的token字段，并将其替换成新的token。但上述方法仅仅适用于get请求和post请求以表单格式提交。如果是post请求且提交格式为json可以自行添加。另外此种方法不适用于token放在请求头的方式。</p><p><a href="https://blog.csdn.net/qq_20521573/article/details/70991850">（一）Rxjava2+Retrofit完美封装</a><br><a href="https://blog.csdn.net/qq_20521573/article/details/76100558">（二）Rxjava2+Retrofit之Token自动刷新</a><br><a href="https://blog.csdn.net/qq_20521573/article/details/78356747">（三）Rxjava2+Retrofit实现文件上传与下载</a></p><p>参考<br><a href="http://alighters.com/blog/2016/08/22/rxjava-plus-retrofitshi-xian-zhi-demo/">RxJava+Retrofit实现全局过期token自动刷新Demo篇</a> </p><p><a href="https://github.com/zhpanvip/Retrofit2/tree/token">源码下载</a></p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RxJava</tag>
      
      <tag>Retrofit</tag>
      
      <tag>token</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RxJava+Retrofit完美封装（一）</title>
    <link href="/2017/04/30/9.RxJava-Retrofit(1)/"/>
    <url>/2017/04/30/9.RxJava-Retrofit(1)/</url>
    
    <content type="html"><![CDATA[<p><strong><em>本篇文章已授权微信公众号 guolin_blog （郭霖）独家发布</em></strong></p><p>要说2016年最火的Android技术是什么，毫无疑问肯定是RxJava+Retrofit+Mvp。现如今2017年也已经过了快一半了。相信做android开发的小伙伴对RxJava和Retrofit也不再陌生。即使没有刻意的去学习过，也应该对RxJava和Retrofit有个一知半解。去年的时候学习了Rxjava和Retrofit的基本用法，但一直没有在实际项目中运用。今年开做新项目，果断在新项目中引入了RxJava和Retrofit。本篇文章将介绍笔者在项目中对Retrofit的封装。<br>先来看一下封装过后的Retrofit如何使用。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">RetrofitHelper</span>.</span></span>get<span class="hljs-constructor">ApiService()</span><br>                .get<span class="hljs-constructor">Article()</span><br>                .compose(RxUtil.&lt;ArticleWrapper&gt;rx<span class="hljs-constructor">SchedulerHelper(<span class="hljs-params">this</span>)</span>)<br>                .subscribe(<span class="hljs-keyword">new</span> DefaultObserver&lt;ArticleWrapper&gt;<span class="hljs-literal">()</span> &#123;<br>                    @Override<br>                    public void on<span class="hljs-constructor">Success(ArticleWrapper <span class="hljs-params">response</span>)</span> &#123;<br>                        show<span class="hljs-constructor">Toast(<span class="hljs-string">&quot;Request Success，size is：&quot;</span> + <span class="hljs-params">response</span>.<span class="hljs-params">getDatas</span>()</span>.size<span class="hljs-literal">()</span>);<br>                    &#125;<br>                &#125;);<br></code></pre></td></tr></table></figure><p>没错，就是这么简洁的一个链式调用，可以显示加载动画，还加入了Retrofit生命周期的管理。<br>开始之前需要先在module项目里的Gradle文件中添加用到的依赖库</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">compile</span> <span class="hljs-string">&quot;io.reactivex.rxjava2:rxjava:$rootProject.ext.rxjava2Version&quot;</span><br>   <span class="hljs-keyword">compile</span> <span class="hljs-string">&quot;com.squareup.retrofit2:retrofit:$rootProject.ext.retrofit2Version&quot;</span><br>   <span class="hljs-keyword">compile</span> <span class="hljs-string">&quot;com.squareup.retrofit2:converter-scalars:$rootProject.ext.retrofit2Version&quot;</span><br>   <span class="hljs-keyword">compile</span> <span class="hljs-string">&quot;com.squareup.retrofit2:converter-gson:$rootProject.ext.retrofit2Version&quot;</span><br>   <span class="hljs-keyword">compile</span> <span class="hljs-string">&quot;com.squareup.retrofit2:adapter-rxjava2:$rootProject.ext.retrofit2Version&quot;</span><br>   <span class="hljs-keyword">compile</span> <span class="hljs-string">&#x27;com.jakewharton.retrofit:retrofit2-rxjava2-adapter:1.0.0&#x27;</span><br>   <span class="hljs-keyword">compile</span> <span class="hljs-string">&#x27;io.reactivex.rxjava2:rxandroid:2.0.1&#x27;</span><br>   <span class="hljs-keyword">compile</span> <span class="hljs-string">&#x27;com.squareup.okhttp3:logging-interceptor:3.4.1&#x27;</span><br>   <span class="hljs-keyword">compile</span> <span class="hljs-string">&quot;com.trello.rxlifecycle2:rxlifecycle:$rootProject.ext.rxlifecycle&quot;</span><br>   <span class="hljs-comment">//compile &quot;com.trello.rxlifecycle2:rxlifecycle-android:$rootProject.ext.rxlifecycle&quot;</span><br>   <span class="hljs-keyword">compile</span> <span class="hljs-string">&quot;com.trello.rxlifecycle2:rxlifecycle-components:$rootProject.ext.rxlifecycle&quot;</span><br></code></pre></td></tr></table></figure><p>为了方便依赖库版本的修改我们采用”io.reactivex.rxjava2:rxjava:$rootProject.ext.rxjava2Version”这中方式添加依赖，因此需要在project的build.gradle文件的加上以下内容：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs lsl">ext &#123;<br>    supportLibVersion = &#x27;<span class="hljs-number">25.1</span><span class="hljs-number">.0</span>&#x27;<br>    butterknifeVersion = &#x27;<span class="hljs-number">8.5</span><span class="hljs-number">.1</span>&#x27;<br>    rxjava2Version = &#x27;<span class="hljs-number">2.0</span><span class="hljs-number">.8</span>&#x27;<br>    retrofit2Version = &#x27;<span class="hljs-number">2.2</span><span class="hljs-number">.0</span>&#x27;<br>    rxlifecycle=&#x27;<span class="hljs-number">2.1</span><span class="hljs-number">.0</span>&#x27;<br>    gsonVersion = &#x27;<span class="hljs-number">2.8</span><span class="hljs-number">.0</span>&#x27;<br>&#125;<br></code></pre></td></tr></table></figure><p>下面将通过几个小节对本次封装作详细的解析：</p><ul><li>服务器响应数据的基类BasicResponse</li><li>构建初始化Retrofit的工具类IdeaApi</li><li>通过GsonConverterFactory获取真实响应数据</li><li>封装DefaultObserver处理服务器响应</li><li>处理加载Loading</li><li>管理Retrofit生命周期</li><li>如何使用封装</li><li>小结</li></ul><h2 id="一-服务器响应数据的基类BasicResponse。"><a href="#一-服务器响应数据的基类BasicResponse。" class="headerlink" title="一.服务器响应数据的基类BasicResponse。"></a>一.服务器响应数据的基类BasicResponse。</h2><p>假定服务器返回的Json数据格式如下：</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs clojure">&#123;<br> <span class="hljs-string">&quot;code&quot;</span>: <span class="hljs-number">200</span>,<br> <span class="hljs-string">&quot;message&quot;</span>: <span class="hljs-string">&quot;成功&quot;</span>,<br> <span class="hljs-string">&quot;content&quot;</span>: &#123;<br>...<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>根据Json数据格式构建我们的BasicResponse（BasicResponse中的字段内容需要根据自己服务器返回的数据确定）。代码如下：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BasicResponse</span>&lt;T&gt; &#123;</span><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> code;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">String</span> message;<br>    <span class="hljs-keyword">private</span> T content;<br>...此处省去<span class="hljs-built_in">get</span>、<span class="hljs-built_in">set</span>方法。<br></code></pre></td></tr></table></figure><h2 id="二-构建初始化Retrofit的工具类IdeaApi。"><a href="#二-构建初始化Retrofit的工具类IdeaApi。" class="headerlink" title="二.构建初始化Retrofit的工具类IdeaApi。"></a>二.构建初始化Retrofit的工具类IdeaApi。</h2><p>该类通过RetrofitUtils来获取ApiService的实例。代码如下：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IdeaApi</span> &#123;</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">getApiService</span><span class="hljs-params">(Class&lt;T&gt; cls,<span class="hljs-keyword">String</span> baseUrl)</span> </span>&#123;<br>        Retrofit retrofit = RetrofitUtils .getRetrofitBuilder(baseUrl).build();<br>        <span class="hljs-keyword">return</span> retrofit.create(cls);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>RetrofitUtils用来构建Retrofit.Builder，并对OkHttp做以下几个方面的配置：</p><ol><li>设置日志拦截器，拦截服务器返回的json数据。Retrofit将请求到json数据直接转换成了实体类，但有时候我们需要查看json数据，Retrofit并没有提供直接获取json数据的功能。因此我们需要自定义一个日志拦截器拦截json数据，并输入到控制台。</li><li>设置Http请求头。给OkHttp 添加请求头拦截器，配置请求头信息。还可以为接口统一添加请求头数据。例如，把用户名、密码（或者token）统一添加到请求头。后续每个接口的请求头中都会携带用户名、密码（或者token）数据，避免了为每个接口单独添加。</li><li>为OkHttp配置缓存。同样可以同过拦截器实现缓存处理。包括控制缓存的最大生命值，控制缓存的过期时间。</li><li>如果采用https，我们还可以在此处理证书校验以及服务器校验。</li><li>为Retrofit添加GsonConverterFactory。此处是一个比较重要的环节，将在后边详细讲解。<br>RetrofitUtils 代码如下：<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public <span class="hljs-keyword">class</span> RetrofitUtils &#123;<br>    public static OkHttpClient.Builder get<span class="hljs-constructor">OkHttpClientBuilder()</span> &#123;<br><br>        HttpLoggingInterceptor loggingInterceptor = <span class="hljs-keyword">new</span> <span class="hljs-constructor">HttpLoggingInterceptor(<span class="hljs-params">new</span> HttpLoggingInterceptor.Logger()</span> &#123;<br>            @Override<br>            public void log(String message) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">LogUtils</span>.</span></span>e(<span class="hljs-string">&quot;OKHttp-----&quot;</span>, <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">URLDecoder</span>.</span></span>decode(message, <span class="hljs-string">&quot;utf-8&quot;</span>));<br>                &#125; catch (UnsupportedEncodingException e) &#123;<br>                    e.print<span class="hljs-constructor">StackTrace()</span>;<br>                    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">LogUtils</span>.</span></span>e(<span class="hljs-string">&quot;OKHttp-----&quot;</span>, message);<br>                &#125;<br>            &#125;<br>        &#125;);<br>        loggingInterceptor.set<span class="hljs-constructor">Level(HttpLoggingInterceptor.Level.BODY)</span>;<br><br>        File cacheFile = <span class="hljs-keyword">new</span> <span class="hljs-constructor">File(Utils.<span class="hljs-params">getContext</span>()</span>.get<span class="hljs-constructor">CacheDir()</span>, <span class="hljs-string">&quot;cache&quot;</span>);<br>        Cache cache = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Cache(<span class="hljs-params">cacheFile</span>, 1024 <span class="hljs-operator">*</span> 1024 <span class="hljs-operator">*</span> 100)</span>; <span class="hljs-comment">//100Mb</span><br><br>        return <span class="hljs-keyword">new</span> OkHttpClient.<span class="hljs-constructor">Builder()</span><br>                .read<span class="hljs-constructor">Timeout(Constants.DEFAULT_TIMEOUT, TimeUnit.MILLISECONDS)</span><br>                .connect<span class="hljs-constructor">Timeout(Constants.DEFAULT_TIMEOUT, TimeUnit.MILLISECONDS)</span><br>                .add<span class="hljs-constructor">Interceptor(<span class="hljs-params">loggingInterceptor</span>)</span><br>                .add<span class="hljs-constructor">Interceptor(<span class="hljs-params">new</span> HttpHeaderInterceptor()</span>)<br>                .add<span class="hljs-constructor">NetworkInterceptor(<span class="hljs-params">new</span> HttpCacheInterceptor()</span>)<br>               <span class="hljs-comment">// .sslSocketFactory(SslContextFactory.getSSLSocketFactoryForTwoWay())  // https认证 如果要使用https且为自定义证书 可以去掉这两行注释，并自行配制证书。</span><br>               <span class="hljs-comment">// .hostnameVerifier(new SafeHostnameVerifier())</span><br>                .cache(cache);<br>    &#125;<br><br>    public static Retrofit.Builder get<span class="hljs-constructor">RetrofitBuilder(String <span class="hljs-params">baseUrl</span>)</span> &#123;<br>        Gson gson = <span class="hljs-keyword">new</span> <span class="hljs-constructor">GsonBuilder()</span>.set<span class="hljs-constructor">DateFormat(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>)</span>.serialize<span class="hljs-constructor">Nulls()</span>.create<span class="hljs-literal">()</span>;<br>        OkHttpClient okHttpClient = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">RetrofitUtils</span>.</span></span>get<span class="hljs-constructor">OkHttpClientBuilder()</span>.build<span class="hljs-literal">()</span>;<br>        return <span class="hljs-keyword">new</span> Retrofit.<span class="hljs-constructor">Builder()</span><br>                .client(okHttpClient)<br>                .add<span class="hljs-constructor">ConverterFactory(GsonConverterFactory.<span class="hljs-params">create</span>(<span class="hljs-params">gson</span>)</span>)<br>                .add<span class="hljs-constructor">CallAdapterFactory(RxJava2CallAdapterFactory.<span class="hljs-params">create</span>()</span>)<br>                .base<span class="hljs-constructor">Url(<span class="hljs-params">baseUrl</span>)</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="三-通过GsonConverterFactory获取真实响应数据"><a href="#三-通过GsonConverterFactory获取真实响应数据" class="headerlink" title="三.通过GsonConverterFactory获取真实响应数据"></a>三.通过GsonConverterFactory获取真实响应数据</h2><p>在第一节中我们构建了服务器响应数据BasicResponse，BasicResponse由code、message、和content三个字段。其中code为服务器返回的错误码。我们会事先和服务器约定成功时的code值，比如200表示请求成功。但通常在请求服务器数据过程中免不了会出现各种错误。例如用户登录时密码错误、请求参数错误的情况。此时服务器会根据错误情况返回对应的错误码。一般来说，我们只关心成功时即code为200时的content数据。而对于code不为200时我们只需要给出对应的Toast提示即可。事实上我们对我们有用的仅仅时code为200时的content数据。因此我们可以考虑过滤掉code和message，在请求成功的回调中只返回content的内容。<br>在此种情况下就需要我们通过自定义GsonConverterFactory来实现了。我们可以直接从Retrofit的源码中copy出GsonConverterFactory的三个相关类来做修改。<br>其中最终要的一部分是修改GsonResponseBodyConverter中的convert方法。在该方法中拿到服务器响应数据并判断code是否为200。如果是，则获取到content并返回，如果不是，则在此处可以抛出对应的自定义的异常。然后再Observer中统一处理异常情况。GsonResponseBodyConverter代码如下：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-symbol">GsonResponseBodyConverter</span>&lt;<span class="hljs-symbol">T</span>&gt; <span class="hljs-symbol">implements</span> <span class="hljs-symbol">Converter</span>&lt;<span class="hljs-symbol">ResponseBody, <span class="hljs-symbol">Object</span></span>&gt; &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> TypeAdapter&lt;T&gt; adapter;<br><br>    GsonResponseBodyConverter(TypeAdapter&lt;T&gt; adapter) &#123;<br>        <span class="hljs-keyword">this</span>.adapter = adapter;<br>    &#125;<br><br>    @Override<br>    <span class="hljs-keyword">public</span> Object convert(ResponseBody value) throws IOException &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            BasicResponse response = (BasicResponse) adapter.fromJson(value.charStream());<br>            <span class="hljs-keyword">if</span> (response.getCode()==<span class="hljs-number">200</span>) &#123;<br>            <span class="hljs-keyword">return</span> response.getResults();<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 特定 API 的错误，在相应的 DefaultObserver 的 onError 的方法中进行处理</span><br>                throw new ServerResponseException(response.getCode(), response.getMessage());<br>            &#125;<br>        &#125; finally &#123;<br>            value.close();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="四-构建DefaultObserver处理服务器响应。"><a href="#四-构建DefaultObserver处理服务器响应。" class="headerlink" title="四.构建DefaultObserver处理服务器响应。"></a>四.构建DefaultObserver处理服务器响应。</h2><p>上一节中我们讲到了在请求服务器时可能出现的一些例如密码错误、参数错误的情况，服务器给我们返回了对应的错误码，我们根据错误码抛出了对应自定义异常。除此之外在我们发起网络请求时还可能发生一些异常情况。例如没有网络、请求超时或者服务器返回了数据但在解析时出现了数据解析异常等。对于这样的情况我们也要进行统一处理的。那么我们就需要自定义一个DefaultObserver类继承Observer，并重写相应的方法。<br>该类中最重要的两个方法时onNext和onError。<br><strong>1.在服务器返回数据成功的情况下会回调到onNext方法。</strong>因此我们可以在DefaultObserver中定义一个抽象方法onSuccess(T response)，在调用网络时重写onSuccess方法即可。<br><strong>2.如果在请求服务器过程中出现任何异常，都会回调到onError方法中。</strong>包括上节中我们自己抛出的异常都会回调到onError。因此我们的重头戏就是处理onError。在onError中我们根据异常信息给出对应的Toast提示即可。<br>DefaultObserver类的代码如下：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public abstract <span class="hljs-keyword">class</span> DefaultObserver&lt;T&gt; implements Observer&lt;T&gt; &#123;<br>    @Override<br>    public void on<span class="hljs-constructor">Subscribe(Disposable <span class="hljs-params">d</span>)</span> &#123;<br><br>    &#125;<br><br>    @Override<br>    public void on<span class="hljs-constructor">Next(T <span class="hljs-params">response</span>)</span> &#123;<br>        on<span class="hljs-constructor">Success(<span class="hljs-params">response</span>)</span>;<br>        on<span class="hljs-constructor">Finish()</span>;<br>    &#125;<br><br>    @Override<br>    public void on<span class="hljs-constructor">Error(Throwable <span class="hljs-params">e</span>)</span> &#123;<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">LogUtils</span>.</span></span>e(<span class="hljs-string">&quot;Retrofit&quot;</span>, e.get<span class="hljs-constructor">Message()</span>);<br>        <span class="hljs-keyword">if</span> (e instanceof HttpException) &#123;     <span class="hljs-comment">//   HTTP错误</span><br>            on<span class="hljs-constructor">Exception(ExceptionReason.BAD_NETWORK)</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e instanceof ConnectException<br><span class="hljs-operator">                || </span>e instanceof UnknownHostException) &#123;   <span class="hljs-comment">//   连接错误</span><br>            on<span class="hljs-constructor">Exception(ExceptionReason.CONNECT_ERROR)</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e instanceof InterruptedIOException) &#123;   <span class="hljs-comment">//  连接超时</span><br>            on<span class="hljs-constructor">Exception(ExceptionReason.CONNECT_TIMEOUT)</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e instanceof JsonParseException<br><span class="hljs-operator">                || </span>e instanceof JSONException<br><span class="hljs-operator">                || </span>e instanceof ParseException) &#123;   <span class="hljs-comment">//  解析错误</span><br>            on<span class="hljs-constructor">Exception(ExceptionReason.PARSE_ERROR)</span>;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(e instanceof ServerResponseException)&#123;<br>            on<span class="hljs-constructor">Fail(<span class="hljs-params">e</span>.<span class="hljs-params">getMessage</span>()</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            on<span class="hljs-constructor">Exception(ExceptionReason.UNKNOWN_ERROR)</span>;<br>        &#125;<br>        on<span class="hljs-constructor">Finish()</span>;<br>    &#125;<br><br>    @Override<br>    public void on<span class="hljs-constructor">Complete()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 请求成功</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * @param response 服务器返回的数据</span><br><span class="hljs-comment">     */</span><br>    abstract public void on<span class="hljs-constructor">Success(T <span class="hljs-params">response</span>)</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 服务器返回数据，但响应码不为200</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     */</span><br>    public void on<span class="hljs-constructor">Fail(String <span class="hljs-params">message</span>)</span> &#123;<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ToastUtils</span>.</span></span>show(message);<br>    &#125;<br>    <br>    public void on<span class="hljs-constructor">Finish()</span>&#123;&#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 请求异常</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * @param reason</span><br><span class="hljs-comment">     */</span><br>    public void on<span class="hljs-constructor">Exception(ExceptionReason <span class="hljs-params">reason</span>)</span> &#123;<br>        switch (reason) &#123;<br>            case CONNECT_ERROR:<br>                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ToastUtils</span>.</span></span>show(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">R</span>.</span></span><span class="hljs-built_in">string</span>.connect_error, Toast.LENGTH_SHORT);<br>                break;<br><br>            case CONNECT_TIMEOUT:<br>                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ToastUtils</span>.</span></span>show(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">R</span>.</span></span><span class="hljs-built_in">string</span>.connect_timeout, Toast.LENGTH_SHORT);<br>                break;<br><br>            case BAD_NETWORK:<br>                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ToastUtils</span>.</span></span>show(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">R</span>.</span></span><span class="hljs-built_in">string</span>.bad_network, Toast.LENGTH_SHORT);<br>                break;<br><br>            case PARSE_ERROR:<br>                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ToastUtils</span>.</span></span>show(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">R</span>.</span></span><span class="hljs-built_in">string</span>.parse_error, Toast.LENGTH_SHORT);<br>                break;<br><br>            case UNKNOWN_ERROR:<br>            default:<br>                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ToastUtils</span>.</span></span>show(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">R</span>.</span></span><span class="hljs-built_in">string</span>.unknown_error, Toast.LENGTH_SHORT);<br>                break;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 请求网络失败原因</span><br><span class="hljs-comment">     */</span><br>    public enum ExceptionReason &#123;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 解析数据失败</span><br><span class="hljs-comment">         */</span><br>        PARSE_ERROR,<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 网络问题</span><br><span class="hljs-comment">         */</span><br>        BAD_NETWORK,<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 连接错误</span><br><span class="hljs-comment">         */</span><br>        CONNECT_ERROR,<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 连接超时</span><br><span class="hljs-comment">         */</span><br>        CONNECT_TIMEOUT,<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 未知错误</span><br><span class="hljs-comment">         */</span><br>        UNKNOWN_ERROR,<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="五-处理加载Loading"><a href="#五-处理加载Loading" class="headerlink" title="五.处理加载Loading"></a>五.处理加载Loading</h2><p>关于Loading我们可以通过RxJava的compose操作符来做一个非常优雅的处理。首先定义一个ProgressUtils工具类，然后通过RxJava的ObservableTransformer做一个变换来处理Loading。想要显示Loading，只需要加上.compose(ProgressUtils.&lt; T &gt;applyProgressBar(this))即可。<br>ProgressUtils代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProgressUtils</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">ObservableTransformer&lt;T, T&gt; <span class="hljs-title">applyProgressBar</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">            <span class="hljs-meta">@NonNull</span> <span class="hljs-keyword">final</span> Activity activity, String msg)</span> </span>&#123;<br>        <span class="hljs-keyword">final</span> WeakReference&lt;Activity&gt; activityWeakReference = <span class="hljs-keyword">new</span> WeakReference&lt;&gt;(activity);<br>        <span class="hljs-keyword">final</span> DialogUtils dialogUtils = <span class="hljs-keyword">new</span> DialogUtils();<br>        dialogUtils.showProgress(activityWeakReference.get());<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ObservableTransformer&lt;T, T&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> ObservableSource&lt;T&gt; <span class="hljs-title">apply</span><span class="hljs-params">(Observable&lt;T&gt; upstream)</span> </span>&#123;<br>                <span class="hljs-keyword">return</span> upstream.doOnSubscribe(<span class="hljs-keyword">new</span> Consumer&lt;Disposable&gt;() &#123;<br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">accept</span><span class="hljs-params">(Disposable disposable)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br><br>                    &#125;<br>                &#125;).doOnTerminate(<span class="hljs-keyword">new</span> Action() &#123;<br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                        Activity context;<br>                        <span class="hljs-keyword">if</span> ((context = activityWeakReference.get()) != <span class="hljs-keyword">null</span><br>                                &amp;&amp; !context.isFinishing()) &#123;<br>                            dialogUtils.dismissProgress();<br>                        &#125;<br>                    &#125;<br>                &#125;).doOnSubscribe(<span class="hljs-keyword">new</span> Consumer&lt;Disposable&gt;() &#123;<br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">accept</span><span class="hljs-params">(Disposable disposable)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                        <span class="hljs-comment">/*Activity context;</span><br><span class="hljs-comment">                        if ((context = activityWeakReference.get()) != null</span><br><span class="hljs-comment">                                &amp;&amp; !context.isFinishing()) &#123;</span><br><span class="hljs-comment">                            dialogUtils.dismissProgress();</span><br><span class="hljs-comment">                        &#125;*/</span><br>                    &#125;<br>                &#125;);<br>            &#125;<br>        &#125;;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">ObservableTransformer&lt;T, T&gt; <span class="hljs-title">applyProgressBar</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">            <span class="hljs-meta">@NonNull</span> <span class="hljs-keyword">final</span> Activity activity)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> applyProgressBar(activity, <span class="hljs-string">&quot;&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>至此关于RxJava和Retrofit的二次封装已经基本完成。但是我们不能忽略了很重要的一点，就是网络请求的生命周期。我们将在下一节中详细讲解。</p><h2 id="六、管理Retrofit生命周期"><a href="#六、管理Retrofit生命周期" class="headerlink" title="六、管理Retrofit生命周期"></a>六、管理Retrofit生命周期</h2><p>当activity被销毁时，网络请求也应该随之终止的。要不然就可能造成内存泄漏。会严重影到响App的性能！因此Retrofit生命周期的管理也是比较重要的一点内容。在这里我们使用 **<a href="https://github.com/trello/RxLifecycle">RxLifecycle</a>**来对Retrofit进行生命周期管理。其使用流程如下：</p><p><strong>1.在gradel中添加依赖如下：</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">compile</span> &#x27;com.trello.rxlifecycle<span class="hljs-number">2</span>:rxlifecycle:<span class="hljs-number">2</span>.<span class="hljs-number">1</span>.<span class="hljs-number">0</span>&#x27;<br><span class="hljs-attribute">compile</span> &#x27;com.trello.rxlifecycle<span class="hljs-number">2</span>:rxlifecycle-components:<span class="hljs-number">2</span>.<span class="hljs-number">1</span>.<span class="hljs-number">0</span>&#x27;<br><br></code></pre></td></tr></table></figure><p><strong>2.让我们的BaseActivity继承RxAppCompatActivity。</strong><br>具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RxAppCompatActivity</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState);<br>        setContentView(getLayoutId());<br>        init(savedInstanceState);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">showToast</span><span class="hljs-params">(String msg)</span> </span>&#123;<br>        ToastUtils.show(msg);<br>    &#125;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-meta">@LayoutRes</span> <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getLayoutId</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(Bundle savedInstanceState)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>同样我们项目的BaseFragment继承RxFragment（注意使用继承V4包下的RxFragment），如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseFragment</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RxFragment</span> </span>&#123;<br><br>    <span class="hljs-keyword">public</span> View rootView;<br>    <span class="hljs-keyword">public</span> LayoutInflater inflater;<br><br><br>    <span class="hljs-meta">@Nullable</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> View <span class="hljs-title">onCreateView</span><span class="hljs-params">(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.onCreateView(inflater, container, savedInstanceState);<br>        <span class="hljs-keyword">this</span>.inflater = inflater;<br>        <span class="hljs-keyword">if</span> (rootView == <span class="hljs-keyword">null</span>) &#123;<br>            rootView = inflater.inflate(<span class="hljs-keyword">this</span>.getLayoutId(), container, <span class="hljs-keyword">false</span>);<br>            init(savedInstanceState);<br>        &#125;<br>        ViewGroup parent = (ViewGroup) rootView.getParent();<br>        <span class="hljs-keyword">if</span> (parent != <span class="hljs-keyword">null</span>) &#123;<br>            parent.removeView(rootView);<br>        &#125;<br>        <span class="hljs-keyword">return</span> rootView;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getLayoutId</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(Bundle savedInstanceState)</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">showToast</span><span class="hljs-params">(String msg)</span> </span>&#123;<br>        ToastUtils.show(msg);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onResume</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.onResume();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onPause</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.onPause();<br>    &#125;<br><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onDestroyView</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.onDestroyView();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>3.使用compose操作符管理Retrofit生命周期了:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">myObservable</span><br>            <span class="hljs-selector-class">.compose</span>(<span class="hljs-selector-tag">bindToLifecycle</span>())<br>            <span class="hljs-selector-class">.subscribe</span>();<br><br>或者<br><br><span class="hljs-selector-tag">myObservable</span><br>    <span class="hljs-selector-class">.compose</span>(<span class="hljs-selector-tag">RxLifecycle</span><span class="hljs-selector-class">.bindUntilEvent</span>(<span class="hljs-selector-tag">lifecycle</span>, <span class="hljs-selector-tag">ActivityEvent</span><span class="hljs-selector-class">.DESTROY</span>))<br>    <span class="hljs-selector-class">.subscribe</span>();<br><br></code></pre></td></tr></table></figure><p>关于RxLifecycle的详细使用方法可以参考 <strong><a href="https://github.com/trello/RxLifecycle">RxLifecycle官网</a></strong></p><h2 id="七-如何使用封装"><a href="#七-如何使用封装" class="headerlink" title="七.如何使用封装"></a>七.如何使用封装</h2><p>前面几节内容讲解了如何RxJava进行二次封装，封装部分的代码可以放在我们项目的Library模块中。那么封装好之后我们应该如何在app模块中使用呢？<br><strong>1.定义一个接口来存放我们项目的API</strong></p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">public</span> <span class="hljs-selector-tag">interface</span> <span class="hljs-selector-tag">IdeaApiService</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 此接口服务器响应数据BasicResponse的泛型T应该是List&lt;MeiZi&gt;</span><br><span class="hljs-comment">     * 即BasicResponse&lt;List&lt;MeiZi&gt;&gt;</span><br><span class="hljs-comment">     * @return BasicResponse&lt;List&lt;MeiZi&gt;&gt;</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-variable">@Headers</span>(<span class="hljs-string">&quot;Cache-Control: public, max-age=10&quot;</span>)<span class="hljs-comment">//设置缓存 缓存时间为100s</span><br>    <span class="hljs-variable">@GET</span>(<span class="hljs-string">&quot;福利/10/1&quot;</span>)<br>    Observable&lt;List&lt;MeiZi&gt;&gt; getMezi();<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 登录 接口为假接口 并不能返回数据</span><br><span class="hljs-comment">     * @return</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-variable">@POST</span>(<span class="hljs-string">&quot;login.do&quot;</span>)<br>    Observable&lt;LoginResponse&gt; login(<span class="hljs-variable">@Body</span> LoginRequest request);<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 刷新token 接口为假接口 并不能返回数据</span><br><span class="hljs-comment">     * @return</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-variable">@POST</span>(<span class="hljs-string">&quot;refresh_token.do&quot;</span>)<br>    Observable&lt;RefreshTokenResponseBean&gt; refreshToken(<span class="hljs-variable">@Body</span> RefreshTokenRequest request);<br><br>    <span class="hljs-variable">@Multipart</span><br>    <span class="hljs-variable">@POST</span>(<span class="hljs-string">&quot;upload/uploadFile.do&quot;</span>)<br>    Observable&lt;BasicResponse&gt; uploadFiles(<span class="hljs-variable">@Part</span> List&lt;MultipartBody.Part&gt; partList);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>2.定义一个RetrofitHelper 类，通过IdeaApi来获取IdeaApiService的实例。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RetrofitHelper</span> &#123;</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> IdeaApiService mIdeaApiService;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> IdeaApiService <span class="hljs-title">getApiService</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> mIdeaApiService;<br>    &#125;<br>    <span class="hljs-keyword">static</span> &#123;<br>       mIdeaApiService= IdeaApi.getApiService(IdeaApiService.class, Constants.API_SERVER_URL);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>3.在Activity或者Fragment中发起网络请求</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Get请求</span><br><span class="hljs-comment"> * @param view</span><br><span class="hljs-comment"> */</span><br>public void get<span class="hljs-constructor">Data(View <span class="hljs-params">view</span>)</span> &#123;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">RetrofitHelper</span>.</span></span>get<span class="hljs-constructor">ApiService()</span><br>            .get<span class="hljs-constructor">Mezi()</span><br>            .compose(this.&lt;List&lt;MeiZi&gt;&gt;bind<span class="hljs-constructor">ToLifecycle()</span>)<br>            .compose(ProgressUtils.&lt;List&lt;MeiZi&gt;&gt;apply<span class="hljs-constructor">ProgressBar(<span class="hljs-params">this</span>)</span>)<br>            .subscribe<span class="hljs-constructor">On(Schedulers.<span class="hljs-params">io</span>()</span>)<br>            .observe<span class="hljs-constructor">On(AndroidSchedulers.<span class="hljs-params">mainThread</span>()</span>)<br>            .subscribe(<span class="hljs-keyword">new</span> DefaultObserver&lt;List&lt;MeiZi&gt;&gt;<span class="hljs-literal">()</span> &#123;<br>                @Override<br>                public void on<span class="hljs-constructor">Success(List&lt;MeiZi&gt; <span class="hljs-params">response</span>)</span> &#123;<br>                    show<span class="hljs-constructor">Toast(<span class="hljs-string">&quot;请求成功，妹子个数为&quot;</span> + <span class="hljs-params">response</span>.<span class="hljs-params">size</span>()</span>);<br>                &#125;<br>            &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="八-小结"><a href="#八-小结" class="headerlink" title="八.小结"></a>八.小结</h2><p>本篇文章主要讲解了Rxjava和Retrofit的二次封装。以上内容也是笔者参考多方面的资料经过长时间的改动优化而来。但鉴于本人能力有限，其中也避免不了出现不当之处。还请大家多多包涵。另外，在投稿郭神公众号时文章可能还存在很多处理不优雅的地方，比如对响应数据的处理以及对Loading的处理。在投稿被推送后收到了很多小伙伴的建议，因此笔者也参考了大家的意见并做了优化，在此感谢大家。最后如果有疑问欢迎在文章留言评论。</p><p><a href="https://blog.csdn.net/qq_20521573/article/details/76100558">（二）Rxjava2+Retrofit之Token自动刷新</a><br><a href="https://blog.csdn.net/qq_20521573/article/details/78356747">（三）Rxjava2+Retrofit实现文件上传与下载</a></p><p><a href="https://github.com/zhpanvip/Retrofit2"> 源码传送门</a></p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RxJava</tag>
      
      <tag>Retrofit</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BaseActivity中封装通用的Toolbar</title>
    <link href="/2017/04/28/8.Use%20Toolbar%20in%20BaseActivity/"/>
    <url>/2017/04/28/8.Use%20Toolbar%20in%20BaseActivity/</url>
    
    <content type="html"><![CDATA[<p>之前写过一篇关于如何使用Toolbar的文章，最近在搭建新项目时对Toolbar做了封装。封装的预期目标是只在BaseActivity中引入Toolbar，然后子Activity通过继承BaseActivity就能显示Toolbar。接下来就看看如何实现这样的功能。<br>因为我们使用toolbar作为titlebar，因此首先需要去掉Actionbar。在style文件下修改默认Theme的parent为Theme.AppCompat.Light.NoActionBar便可以去掉默认的Actionbar，如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;AppTheme&quot;</span> <span class="hljs-attr">parent</span>=<span class="hljs-string">&quot;Theme.AppCompat.Light.NoActionBar&quot;</span>&gt;</span><br><span class="xml">    <span class="hljs-comment">&lt;!-- Customize your theme here. --&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;colorPrimary&quot;</span>&gt;</span>@color/colorPrimary<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;colorPrimaryDark&quot;</span>&gt;</span>@color/colorPrimaryDark<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;colorAccent&quot;</span>&gt;</span>@color/colorAccent<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span></span><br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><p>然后定义一个toolbar_layout的xml文件，在toolbar中加入俩个TextView作为标题和子标题，如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">android.support.v7.widget.Toolbar</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/toolbar&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:background</span>=<span class="hljs-string">&quot;@color/colorPrimary&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:minHeight</span>=<span class="hljs-string">&quot;?attr/actionBarSize&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--自定义toolbar的title 和subtitle --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/tv_right&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;@style/TextAppearance.AppCompat.Widget.ActionBar.Subtitle&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:maxLines</span>=<span class="hljs-string">&quot;1&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:textColor</span>=<span class="hljs-string">&quot;@color/white&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;right&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:paddingRight</span>=<span class="hljs-string">&quot;10dp&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_gravity</span>=<span class="hljs-string">&quot;right&quot;</span> /&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/tv_title&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;@style/TextAppearance.AppCompat.Widget.ActionBar.Title&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:lines</span>=<span class="hljs-string">&quot;1&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:ellipsize</span>=<span class="hljs-string">&quot;end&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;title&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:scrollHorizontally</span>=<span class="hljs-string">&quot;true&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:textColor</span>=<span class="hljs-string">&quot;@color/white&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_gravity</span>=<span class="hljs-string">&quot;center&quot;</span> /&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">android.support.v7.widget.Toolbar</span>&gt;</span><br></code></pre></td></tr></table></figure><p>接着在BaseActivity的布局文件中include进toolbar_layout，如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">LinearLayout</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">layout</span>=<span class="hljs-string">&quot;@layout/toolbar_layout&quot;</span>/&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">LinearLayout</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>这样BaseActivity中就可以正常显示出Toolbar了。那么如何实现子Activity继承BaseActivity而显示toolbar呢？其实我们可以在BaseActivity中做文章。<br>首先在BaseActivity中声明一个LinearLayout,然后把BaseActivity的布局文件添加到该LinearLayout中。我们知道子Activity通过setContentView()方法来关联布局文件，因此我们可以在BaseActivity中去重写setContentView()方法，在重写的setContentView中把子类的布局文件也添加到事先声明的LinearLayout中，接下来应该解决如何将这个LinearLayout与Activity关联。查阅相关资料可以知道，可以通过 findViewById(android.R.id.content)拿到window的ViewGroup然后将刚才声明的LinearLayout添加到这个ViewGroup中，这样就可以在子Activity中显示出BaseActivity中的Toolbar了。（具体原因可以查阅android.R.id.content和 DecorView）代码如下：</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs smali">public<span class="hljs-keyword"> abstract</span> class BaseActivity extends AppCompatActivity&#123;<br>     //the container of this activity layout<span class="hljs-built_in"> and </span>sub-activity layout<br>   <span class="hljs-keyword"> private</span> <span class="hljs-class">LinearLayout parentLinearLayout;</span><br>    <br>    @Override<br>   <span class="hljs-keyword"> public</span> void onCreate(Bundle savedInstanceState) &#123;<br>        super.onCreate(savedInstanceState);<br>        initContentView(R.layout.activity_base);<br>        setContentView(getLayoutId());<br>        initToolBar();<br>        init();<br>    &#125;<br>//  overwrite the function in<span class="hljs-built_in"> sub-activity </span>and<span class="hljs-built_in"> return </span>the layout id of<span class="hljs-built_in"> sub-activity </span>  <br><span class="hljs-keyword"> protected</span><span class="hljs-keyword"> abstract</span><span class="hljs-built_in"> int </span>getLayoutId();<br> <br><span class="hljs-keyword"> private</span> void initContentView(@LayoutRes<span class="hljs-built_in"> int </span>layoutResID) &#123;<br>        ViewGroup viewGroup = (ViewGroup) findViewById(android.R.id.content);<br>        viewGroup.removeAllViews();<br>        parentLinearLayout =<span class="hljs-built_in"> new </span>LinearLayout(this);<br>        parentLinearLayout.setOrientation(<span class="hljs-class">LinearLayout.VERTICAL);</span><br>// <span class="hljs-built_in"> add </span>parentLinearLayout in viewGroup<br>        viewGroup.addView(parent<span class="hljs-class">LinearLayout);</span><br>        // <span class="hljs-built_in"> add </span>the layout of BaseActivity in parentLinearLayout<br>        LayoutInflater.from(this).inflate(layoutResID, parent<span class="hljs-class">LinearLayout, true);</span><br>    &#125;<br>   /**<br>     * @param layoutResID  layout id of sub-activity<br>     */<br>    @Override<br>   <span class="hljs-keyword"> public</span> void setContentView(@LayoutRes<span class="hljs-built_in"> int </span>layoutResID) &#123;<br>        //  added the<span class="hljs-built_in"> sub-activity </span>layout id in parentLinearLayout<br>        LayoutInflater.from(this).inflate(layoutResID, parent<span class="hljs-class">LinearLayout, true);</span><br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>上述代码通过initContentView()方法将BaseActivity中的布局文件添加到了声明的parentLinearLayout中，通过setContentView()方法将子Activity的布局也添加到了parentLinearLayout中，然后又将parentLinearLayout添加到了viewGroup中实现了Activity与布局文件的关联。至此我们完成了第一步，使子Activity可以显示出BaseActivity中的Toolbar布局。<br>接下来，我们需要在BaseActivity中对Toolbar进行封装，使其能够更加方便的在子Activity中使用。比如添加toolbar回退键的监听，添加是否显示回退键的方法等。完整的BaseActivity如下：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public abstract <span class="hljs-keyword">class</span> BaseActivity extends AppCompatActivity&#123;<br>    <span class="hljs-comment">//the container of this activity layout and sub-activity layout </span><br>    <span class="hljs-keyword">private</span> LinearLayout parentLinearLayout;<br>    <span class="hljs-keyword">private</span> TextView mTvTitle;<br>    <span class="hljs-keyword">private</span> TextView mTvRight;<br>    <span class="hljs-keyword">private</span> Toolbar mToolbar;<br>    @Override<br>    public void on<span class="hljs-constructor">Create(Bundle <span class="hljs-params">savedInstanceState</span>)</span> &#123;<br>        super.on<span class="hljs-constructor">Create(<span class="hljs-params">savedInstanceState</span>)</span>;<br>        init<span class="hljs-constructor">ContentView(R.<span class="hljs-params">layout</span>.<span class="hljs-params">activity_base</span>)</span>;<br>      <br>        set<span class="hljs-constructor">ContentView(<span class="hljs-params">getLayoutId</span>()</span>);<br>        init<span class="hljs-constructor">ToolBar()</span>;<br>        set<span class="hljs-constructor">BackIcon()</span>;<br>        init<span class="hljs-literal">()</span>;<br>    &#125;<br><span class="hljs-comment">//  overwrite the function in sub-activity and return the layout id of sub-activity </span><br> protected abstract <span class="hljs-built_in">int</span> get<span class="hljs-constructor">LayoutId()</span>;<br><br> <span class="hljs-keyword">private</span> void init<span class="hljs-constructor">ContentView(@LayoutRes <span class="hljs-params">int</span> <span class="hljs-params">layoutResID</span>)</span> &#123;<br>        ViewGroup viewGroup = (ViewGroup) find<span class="hljs-constructor">ViewById(<span class="hljs-params">android</span>.R.<span class="hljs-params">id</span>.<span class="hljs-params">content</span>)</span>;<br>        viewGroup.remove<span class="hljs-constructor">AllViews()</span>;<br>        parentLinearLayout = <span class="hljs-keyword">new</span> <span class="hljs-constructor">LinearLayout(<span class="hljs-params">this</span>)</span>;<br>        parentLinearLayout.set<span class="hljs-constructor">Orientation(LinearLayout.VERTICAL)</span>;<br>        viewGroup.add<span class="hljs-constructor">View(<span class="hljs-params">parentLinearLayout</span>)</span>;<br>        <span class="hljs-comment">//  add the layout of BaseActivity in parentLinearLayout</span><br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">LayoutInflater</span>.</span></span>from(this).inflate(layoutResID, parentLinearLayout, <span class="hljs-literal">true</span>);<br>    &#125;<br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * @param layoutResID  the layout id of sub Activity</span><br><span class="hljs-comment">     */</span><br>    @Override<br>    public void set<span class="hljs-constructor">ContentView(@LayoutRes <span class="hljs-params">int</span> <span class="hljs-params">layoutResID</span>)</span> &#123;<br>        <span class="hljs-comment">//  added the sub-activity layout id in parentLinearLayout</span><br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">LayoutInflater</span>.</span></span>from(this).inflate(layoutResID, parentLinearLayout, <span class="hljs-literal">true</span>);<br><br>    &#125;<br><br><span class="hljs-keyword">private</span> void set<span class="hljs-constructor">BackIcon()</span>&#123;<br>        <span class="hljs-keyword">if</span> (null != get<span class="hljs-constructor">Toolbar()</span><span class="hljs-operator"> &amp;&amp; </span>is<span class="hljs-constructor">ShowBacking()</span>) &#123;<br>            get<span class="hljs-constructor">Toolbar()</span>.set<span class="hljs-constructor">NavigationIcon(R.<span class="hljs-params">drawable</span>.<span class="hljs-params">icon_back</span>)</span>;<br>            get<span class="hljs-constructor">Toolbar()</span>.set<span class="hljs-constructor">NavigationOnClickListener((<span class="hljs-params">v</span>)</span> -&gt; on<span class="hljs-constructor">BackPressed()</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * @return TextView in center</span><br><span class="hljs-comment">     */</span><br>    public TextView get<span class="hljs-constructor">ToolbarTitle()</span> &#123;<br>        return mTvTitle;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * @return TextView on the right</span><br><span class="hljs-comment">     */</span><br>    public TextView get<span class="hljs-constructor">SubTitle()</span> &#123;<br>        return mTvRight;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * set Title</span><br><span class="hljs-comment">     * @param title</span><br><span class="hljs-comment">     */</span><br>    public void set<span class="hljs-constructor">ToolBarTitle(CharSequence <span class="hljs-params">title</span>)</span> &#123;<br>        <span class="hljs-keyword">if</span> (mTvTitle != null) &#123;<br>            mTvTitle.set<span class="hljs-constructor">Text(<span class="hljs-params">title</span>)</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            get<span class="hljs-constructor">Toolbar()</span>.set<span class="hljs-constructor">Title(<span class="hljs-params">title</span>)</span>;<br>            set<span class="hljs-constructor">SupportActionBar(<span class="hljs-params">getToolbar</span>()</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * the toolbar of this Activity</span><br><span class="hljs-comment">     * @return support.v7.widget.Toolbar.</span><br><span class="hljs-comment">     */</span><br>    public Toolbar get<span class="hljs-constructor">Toolbar()</span> &#123;<br>        return (Toolbar) find<span class="hljs-constructor">ViewById(R.<span class="hljs-params">id</span>.<span class="hljs-params">toolbar</span>)</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * is show back icon,default is none。</span><br><span class="hljs-comment">     * you can override the function in subclass and return to true show the back icon</span><br><span class="hljs-comment">     * @return</span><br><span class="hljs-comment">     */</span><br>    protected boolean is<span class="hljs-constructor">ShowBacking()</span> &#123;<br>        return <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后我们可以在子Activity中去使用toolbar了。<br>我们让MainActivity继承BaseActivity,并在布局文件中添加一个button，切布局文件中没有添加标题栏，布局文件的代码就不再贴出了。然后 重写isShowBacing()方法，使其返回false，隐藏MainActivity的回退键。<br>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BaseActivity</span> </span>&#123;<br>    <span class="hljs-meta">@BindView(R.id.btn)</span><br>    Button mBtn1;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getLayoutId</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> R.layout.activity_main;<br>    &#125;<br><br> <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isShowBacking</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br><br><span class="hljs-meta">@OnClick(&#123;R.id.btn&#125;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Onclick</span><span class="hljs-params">(View view)</span></span>&#123;<br>        <span class="hljs-keyword">switch</span> (view.getId())&#123;<br>            <span class="hljs-keyword">case</span> R.id.btn:<br>                startActivity(<span class="hljs-keyword">new</span> Intent(<span class="hljs-keyword">this</span>,TestActivity.class));<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>创建TestActivity并继承BaseActivity，TestActivity的布局文件中不添加任何view。然后在TestActivity中给toolbar设置内容，如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BaseActivity</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> int getLayoutId() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-type">R</span>.layout.activity_test;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> void init() &#123;<br>        getToolbarTitle().setText(<span class="hljs-string">&quot;中间标题&quot;</span>);<br>        getSubTitle().setText(<span class="hljs-string">&quot;右边标题&quot;</span>);<br>        <span class="hljs-type">Toolbar</span> toolbar = getToolbar();<br>        toolbar.setLogo(<span class="hljs-type">R</span>.mipmap.ic_launcher);<br>        toolbar.setNavigationIcon(<span class="hljs-type">R</span>.drawable.back_white);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>效果如下图所示</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNDI5MTk1MzUxMDk5?x-oss-process=image/format,png" alt="这里写图片描述"></p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>自定义View之颜色渐变折线图</title>
    <link href="/2017/03/16/7.Custom%20View--LineChartView/"/>
    <url>/2017/03/16/7.Custom%20View--LineChartView/</url>
    
    <content type="html"><![CDATA[<p>首先看下要实现的效果图。<br><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/8/4/16c5ad8c54e56941~tplv-t2oaga2asx-zoom-in-crop-mark:1512:0:0:0.awebp" alt="这里写图片描述"><br>折线图的绘制主要有一下几个步骤。<br>一、定义LineChartView类并继承View。<br>二、添加自定义属性。以在value目录下创建attrs.xml文件,文件中我们可以定义一些用到的属性，比如折线颜色、字体大小等属性。文件内容如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">declare-styleable</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;LineChartView&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">attr</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;axesColor&quot;</span> <span class="hljs-attr">format</span>=<span class="hljs-string">&quot;color&quot;</span>/&gt;</span> <span class="hljs-comment">&lt;!--坐标轴颜色--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">attr</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;axesWidth&quot;</span> <span class="hljs-attr">format</span>=<span class="hljs-string">&quot;dimension&quot;</span>/&gt;</span><span class="hljs-comment">&lt;!--坐标轴宽度--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">attr</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;textColor&quot;</span> <span class="hljs-attr">format</span>=<span class="hljs-string">&quot;color&quot;</span>/&gt;</span> <span class="hljs-comment">&lt;!--字体颜色--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">attr</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;textSize&quot;</span> <span class="hljs-attr">format</span>=<span class="hljs-string">&quot;dimension&quot;</span>/&gt;</span> <span class="hljs-comment">&lt;!--字体大小--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">attr</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;lineColor&quot;</span> <span class="hljs-attr">format</span>=<span class="hljs-string">&quot;color&quot;</span>/&gt;</span> <span class="hljs-comment">&lt;!--折线颜色--&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">declare-styleable</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span><br></code></pre></td></tr></table></figure><p>接下来在LineChartView的构造方法中解析自定义属性的值并做相应的处理。在构造方法里还初始化了渐变颜色、折线数据的List集合以及初始化画笔等操作代码如下：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public <span class="hljs-constructor">LineChartView(Context <span class="hljs-params">context</span>, AttributeSet <span class="hljs-params">attrs</span>, <span class="hljs-params">int</span> <span class="hljs-params">defStyleAttr</span>)</span> &#123;<br>       super(context, attrs, defStyleAttr);<br>       TypedArray typedArray = context.obtain<span class="hljs-constructor">StyledAttributes(<span class="hljs-params">attrs</span>, R.<span class="hljs-params">styleable</span>.LineChartView)</span>;<br>       mAxesColor = typedArray.get<span class="hljs-constructor">Color(R.<span class="hljs-params">styleable</span>.LineChartView_axesColor, Color.<span class="hljs-params">parseColor</span>(<span class="hljs-string">&quot;#CCCCCC&quot;</span>)</span>);<br>       mAxesWidth = typedArray.get<span class="hljs-constructor">Dimension(R.<span class="hljs-params">styleable</span>.LineChartView_axesWidth, 1)</span>;<br>       mTextColor = typedArray.get<span class="hljs-constructor">Color(R.<span class="hljs-params">styleable</span>.LineChartView_textColor, Color.<span class="hljs-params">parseColor</span>(<span class="hljs-string">&quot;#ABABAB&quot;</span>)</span>);<br>       mTextSize = typedArray.get<span class="hljs-constructor">Dimension(R.<span class="hljs-params">styleable</span>.LineChartView_textSize, 32)</span>;<br>       mLineColor = typedArray.get<span class="hljs-constructor">Color(R.<span class="hljs-params">styleable</span>.LineChartView_lineColor, Color.RED)</span>;<br>       typedArray.recycle<span class="hljs-literal">()</span>;<br><br>       <span class="hljs-comment">//  初始化渐变色</span><br>       shadeColors = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span><span class="hljs-literal">[]</span>&#123;<br>               <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Color</span>.</span></span>argb(<span class="hljs-number">100</span>, <span class="hljs-number">255</span>, <span class="hljs-number">86</span>, <span class="hljs-number">86</span>), <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Color</span>.</span></span>argb(<span class="hljs-number">15</span>, <span class="hljs-number">255</span>, <span class="hljs-number">86</span>, <span class="hljs-number">86</span>),<br>               <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Color</span>.</span></span>argb(<span class="hljs-number">0</span>, <span class="hljs-number">255</span>, <span class="hljs-number">86</span>, <span class="hljs-number">86</span>)&#125;;<br>     <span class="hljs-comment">//  初始化折线数据</span><br>       mValues = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;<span class="hljs-literal">()</span>;<br>       mMargin10 = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">DensityUtils</span>.</span></span>dp2px(context, <span class="hljs-number">10</span>);<br>       init<span class="hljs-literal">()</span>;<br>   &#125;<br></code></pre></td></tr></table></figure><p>三、初始化画笔和路径。代码如下：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">private</span> void init<span class="hljs-literal">()</span> &#123;<br>        <span class="hljs-comment">//  初始化坐标轴画笔</span><br>        mPaintAxes = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Paint()</span>;<br>        mPaintAxes.set<span class="hljs-constructor">Color(<span class="hljs-params">mAxesColor</span>)</span>;<br>        mPaintAxes.set<span class="hljs-constructor">StrokeWidth(<span class="hljs-params">mAxesWidth</span>)</span>;<br><br>        <span class="hljs-comment">//  初始化文字画笔</span><br>        mPaintText = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Paint()</span>;<br>        mPaintText.set<span class="hljs-constructor">Style(Paint.Style.FILL)</span>;<br>        mPaintText.set<span class="hljs-constructor">AntiAlias(<span class="hljs-params">true</span>)</span>; <span class="hljs-comment">//抗锯齿</span><br>        mPaintText.set<span class="hljs-constructor">TextSize(<span class="hljs-params">mTextSize</span>)</span>;<br>        mPaintText.set<span class="hljs-constructor">Color(<span class="hljs-params">mTextColor</span>)</span>;<br>        mPaintText.set<span class="hljs-constructor">TextAlign(Paint.Align.LEFT)</span>;<br><br>        <span class="hljs-comment">//  初始化折线画笔</span><br>        mPaintLine = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Paint()</span>;<br>        mPaintLine.set<span class="hljs-constructor">Style(Paint.Style.STROKE)</span>;<br>        mPaintLine.set<span class="hljs-constructor">AntiAlias(<span class="hljs-params">true</span>)</span>;<br>        mPaintLine.set<span class="hljs-constructor">StrokeWidth(<span class="hljs-params">mAxesWidth</span> <span class="hljs-operator">/</span> 2)</span>;<br>        mPaintLine.set<span class="hljs-constructor">Color(<span class="hljs-params">mLineColor</span>)</span>;<br><br>        <span class="hljs-comment">//  初始化折线路径</span><br>        mPath = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Path()</span>;<br>        mPathShader = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Path()</span>;<br><br>        <span class="hljs-comment">//  阴影画笔</span><br>        mPaintShader = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Paint()</span>;<br>        mPaintShader.set<span class="hljs-constructor">AntiAlias(<span class="hljs-params">true</span>)</span>;<br>        mPaintShader.set<span class="hljs-constructor">StrokeWidth(2f)</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p>四、重写onLayout方法。在onLayout方法中获取控件的宽高、初始化原点坐标以及设置控件的背景。代码如下：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">@Override<br>   protected void on<span class="hljs-constructor">Layout(<span class="hljs-params">boolean</span> <span class="hljs-params">changed</span>, <span class="hljs-params">int</span> <span class="hljs-params">left</span>, <span class="hljs-params">int</span> <span class="hljs-params">top</span>, <span class="hljs-params">int</span> <span class="hljs-params">right</span>, <span class="hljs-params">int</span> <span class="hljs-params">bottom</span>)</span> &#123;<br>       super.on<span class="hljs-constructor">Layout(<span class="hljs-params">changed</span>, <span class="hljs-params">left</span>, <span class="hljs-params">top</span>, <span class="hljs-params">right</span>, <span class="hljs-params">bottom</span>)</span>;<br>       <span class="hljs-keyword">if</span> (changed) &#123;<br><br>           mWidth = get<span class="hljs-constructor">Width()</span>;<br>           mHeight = get<span class="hljs-constructor">Height()</span>;<br>           timeWidth = (<span class="hljs-built_in">int</span>) mPaintText.measure<span class="hljs-constructor">Text(<span class="hljs-params">startTime</span>)</span>;<br>           <span class="hljs-comment">//  初始化原点坐标</span><br>           xOrigin = <span class="hljs-number">0</span> + mMargin10;<br>           yOrigin = (mHeight - mTextSize - mMargin10);<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><p>五、重写onDraw方法。在onDraw方法中完成折线图的绘制。代码如下：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">@Override<br>   protected void on<span class="hljs-constructor">Draw(Canvas <span class="hljs-params">canvas</span>)</span> &#123;<br>       super.on<span class="hljs-constructor">Draw(<span class="hljs-params">canvas</span>)</span>;<br>       <span class="hljs-comment">//  Y轴坐标间距</span><br>       yInterval = (max - min)<span class="hljs-operator"> / </span>(yOrigin - mMargin10);<br><span class="hljs-comment">//  X轴坐标间距</span><br>       xInterval = (mWidth - xOrigin)<span class="hljs-operator"> / </span>(mItems.size<span class="hljs-literal">()</span> - <span class="hljs-number">1</span>);<br>       <span class="hljs-comment">//  画坐标轴</span><br>       draw<span class="hljs-constructor">Axes(<span class="hljs-params">canvas</span>)</span>;<br>       <span class="hljs-comment">//  画文字</span><br>       draw<span class="hljs-constructor">Text(<span class="hljs-params">canvas</span>)</span>;<br>       <span class="hljs-comment">//  画折线</span><br>       draw<span class="hljs-constructor">Line(<span class="hljs-params">canvas</span>)</span>;<br><span class="hljs-comment">//  绘制路径</span><br>       draw<span class="hljs-constructor">Path(<span class="hljs-params">canvas</span>)</span>;<br>   &#125;<br></code></pre></td></tr></table></figure><p>折线图的绘制可以分三部分：1.绘制坐标轴。2.绘制View上的文字。3.绘制折线。</p><p>1.坐标轴绘制的是第一象限，即左下角的点为原点。绘制坐标轴代码如下：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">//  画坐标轴</span><br>    <span class="hljs-keyword">private</span> void draw<span class="hljs-constructor">Axes(Canvas <span class="hljs-params">canvas</span>)</span> &#123;<br>        <span class="hljs-comment">//  绘制X轴</span><br>        canvas.draw<span class="hljs-constructor">Line(<span class="hljs-params">xOrigin</span>, <span class="hljs-params">yOrigin</span>, <span class="hljs-params">mWidth</span> - <span class="hljs-params">mMargin10</span>, <span class="hljs-params">yOrigin</span>, <span class="hljs-params">mPaintAxes</span>)</span>;<br>        <span class="hljs-comment">//  绘制X中轴线</span><br>        canvas.draw<span class="hljs-constructor">Line(<span class="hljs-params">xOrigin</span>, <span class="hljs-params">yOrigin</span> <span class="hljs-operator">/</span> 2, <span class="hljs-params">mWidth</span> - <span class="hljs-params">mMargin10</span>, <span class="hljs-params">yOrigin</span> <span class="hljs-operator">/</span> 2, <span class="hljs-params">mPaintAxes</span>)</span>;<br>        <span class="hljs-comment">//  绘制X上边线</span><br>        canvas.draw<span class="hljs-constructor">Line(<span class="hljs-params">xOrigin</span>, <span class="hljs-params">mMargin10</span>, <span class="hljs-params">mWidth</span> - <span class="hljs-params">mMargin10</span>, <span class="hljs-params">mMargin10</span>, <span class="hljs-params">mPaintAxes</span>)</span>;<br>        <span class="hljs-comment">//  绘制画Y轴</span><br>        canvas.draw<span class="hljs-constructor">Line(<span class="hljs-params">xOrigin</span>, <span class="hljs-params">yOrigin</span>, <span class="hljs-params">xOrigin</span>, <span class="hljs-params">mMargin10</span>, <span class="hljs-params">mPaintAxes</span>)</span>;<br>        <span class="hljs-comment">//  绘制Y右边线</span><br>        canvas.draw<span class="hljs-constructor">Line(<span class="hljs-params">mWidth</span> - <span class="hljs-params">mMargin10</span>, <span class="hljs-params">mMargin10</span>, <span class="hljs-params">mWidth</span> - <span class="hljs-params">mMargin10</span>, <span class="hljs-params">yOrigin</span>, <span class="hljs-params">mPaintAxes</span>)</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p>2.绘制文字，代码如下：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">private</span> void draw<span class="hljs-constructor">Text(Canvas <span class="hljs-params">canvas</span>)</span> &#123;<br>        <span class="hljs-comment">//  绘制最大值</span><br>        canvas.draw<span class="hljs-constructor">Text(String.<span class="hljs-params">format</span>(<span class="hljs-string">&quot;%.2f&quot;</span>, <span class="hljs-params">max</span> <span class="hljs-operator">*</span> 100 <span class="hljs-operator">/</span> 100.0)</span> + <span class="hljs-string">&quot;%&quot;</span>, xOrigin + <span class="hljs-number">6</span>, <span class="hljs-number">2</span><span class="hljs-operator"> * </span>mMargin10, mPaintText);<br>        <span class="hljs-comment">//  绘制最小值</span><br>        canvas.draw<span class="hljs-constructor">Text(String.<span class="hljs-params">format</span>(<span class="hljs-string">&quot;%.2f&quot;</span>, <span class="hljs-params">min</span> <span class="hljs-operator">*</span> 100 <span class="hljs-operator">/</span> 100.0)</span> + <span class="hljs-string">&quot;%&quot;</span>, xOrigin + <span class="hljs-number">6</span>, yOrigin - <span class="hljs-number">6</span>, mPaintText);<br>        <span class="hljs-comment">//  绘制中间值</span><br>        canvas.draw<span class="hljs-constructor">Text((String.<span class="hljs-params">format</span>(<span class="hljs-string">&quot;%.2f&quot;</span>, (<span class="hljs-params">min</span> + <span class="hljs-params">max</span>)</span><span class="hljs-operator"> * </span><span class="hljs-number">100</span><span class="hljs-operator"> / </span><span class="hljs-number">200.0</span>) + <span class="hljs-string">&quot;%&quot;</span>), xOrigin + <span class="hljs-number">6</span>, (yOrigin + mMargin10)<span class="hljs-operator"> / </span><span class="hljs-number">2</span>, mPaintText);<br><br>        <span class="hljs-comment">//  绘制开始日期</span><br>        canvas.draw<span class="hljs-constructor">Text(<span class="hljs-params">startTime</span>, <span class="hljs-params">xOrigin</span>, <span class="hljs-params">mHeight</span> - <span class="hljs-params">mMargin10</span>, <span class="hljs-params">mPaintText</span>)</span>;<br>        <span class="hljs-comment">//  绘制结束日期</span><br>        canvas.draw<span class="hljs-constructor">Text(<span class="hljs-params">endTime</span>, <span class="hljs-params">mWidth</span> - <span class="hljs-params">timeWidth</span> - <span class="hljs-params">mMargin10</span>, <span class="hljs-params">mHeight</span> - <span class="hljs-params">mMargin10</span>, <span class="hljs-params">mPaintText</span>)</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p>3.绘制折线及渐变填充</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">private</span> void draw<span class="hljs-constructor">Line(Canvas <span class="hljs-params">canvas</span>)</span> &#123;<br>        <span class="hljs-comment">//  画坐标点</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; mValues.size<span class="hljs-literal">()</span>; i++) &#123;<br>            <span class="hljs-built_in">float</span> x = i<span class="hljs-operator"> * </span>xInterval + xOrigin + mAxesWidth;<br>            <span class="hljs-keyword">if</span> (i<span class="hljs-operator"> == </span><span class="hljs-number">0</span>) &#123;<br>                mPathShader.move<span class="hljs-constructor">To(<span class="hljs-params">x</span>, <span class="hljs-params">yOrigin</span> - (<span class="hljs-params">mValues</span>.<span class="hljs-params">get</span>(<span class="hljs-params">i</span>)</span> - min)<span class="hljs-operator"> / </span>yInterval);<br>                mPath.move<span class="hljs-constructor">To(<span class="hljs-params">x</span>, <span class="hljs-params">yOrigin</span> - (<span class="hljs-params">mValues</span>.<span class="hljs-params">get</span>(<span class="hljs-params">i</span>)</span> - min)<span class="hljs-operator"> / </span>yInterval);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                mPath.line<span class="hljs-constructor">To(<span class="hljs-params">x</span> - <span class="hljs-params">mMargin10</span> - <span class="hljs-params">mAxesWidth</span>, <span class="hljs-params">yOrigin</span> - (<span class="hljs-params">mValues</span>.<span class="hljs-params">get</span>(<span class="hljs-params">i</span>)</span> - min)<span class="hljs-operator"> / </span>yInterval);<br>                mPathShader.line<span class="hljs-constructor">To(<span class="hljs-params">x</span> - <span class="hljs-params">mMargin10</span> - <span class="hljs-params">mAxesWidth</span>, <span class="hljs-params">yOrigin</span> - (<span class="hljs-params">mValues</span>.<span class="hljs-params">get</span>(<span class="hljs-params">i</span>)</span> - min)<span class="hljs-operator"> / </span>yInterval);<br>                <span class="hljs-keyword">if</span> (i<span class="hljs-operator"> == </span>mValues.size<span class="hljs-literal">()</span> - <span class="hljs-number">1</span>) &#123;<br>                    mPathShader.line<span class="hljs-constructor">To(<span class="hljs-params">x</span> - <span class="hljs-params">mMargin10</span> - <span class="hljs-params">mAxesWidth</span>, <span class="hljs-params">yOrigin</span>)</span>;<br>                    mPathShader.line<span class="hljs-constructor">To(<span class="hljs-params">xOrigin</span>, <span class="hljs-params">yOrigin</span>)</span>;<br>                    mPathShader.close<span class="hljs-literal">()</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (null<span class="hljs-operator"> == </span>mShadeColors) &#123;<br>            mPaintShader.set<span class="hljs-constructor">Color(Color.<span class="hljs-params">argb</span>(0, 0, 0, 0)</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            Shader mShader = <span class="hljs-keyword">new</span> <span class="hljs-constructor">LinearGradient(0, 0, 0, <span class="hljs-params">getHeight</span>()</span>, mShadeColors, null, Shader.TileMode.CLAMP);<br>            mPaintShader.set<span class="hljs-constructor">Shader(<span class="hljs-params">mShader</span>)</span>;<br>        &#125;<br>        canvas.draw<span class="hljs-constructor">Path(<span class="hljs-params">mPathShader</span>, <span class="hljs-params">mPaintShader</span>)</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p>六、折线图添加动画。</p><p>1.折线图的动画使用属性动画，首先需要计算动画的进度，因此需要先添加setPercentage方法，当动画开始时，我们可以在该方法中拿到percentage的值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Animate this property. It is the percentage of the path that is drawn.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * @param percentage float the percentage of the path.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setPercentage</span><span class="hljs-params">(<span class="hljs-keyword">float</span> percentage)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (percentage &lt; <span class="hljs-number">0.0f</span> || percentage &gt; <span class="hljs-number">1.0f</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<br>                <span class="hljs-string">&quot;setPercentage not between 0.0f and 1.0f&quot;</span>);<br>    &#125;<br>    mProgress = percentage;<br>    invalidate();<br>&#125;<br></code></pre></td></tr></table></figure><p>2.通过Path来绘制折线路径，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">drawPath</span><span class="hljs-params">(Canvas canvas)</span> </span>&#123;<br><br>       PathMeasure measure = <span class="hljs-keyword">new</span> PathMeasure(mPath, <span class="hljs-literal">false</span>);<br>       <span class="hljs-keyword">float</span> pathLength = measure.getLength();<br>       PathEffect effect = <span class="hljs-keyword">new</span> DashPathEffect(<span class="hljs-keyword">new</span> <span class="hljs-keyword">float</span>[]&#123;pathLength,<br>               pathLength&#125;, pathLength - pathLength * mProgress);<br>       mPaintLine.setPathEffect(effect);<br>       canvas.drawPath(mPath, mPaintLine);<br>   &#125;<br></code></pre></td></tr></table></figure><p>3.通过ObjectAnimator 开启动画，注意ObjectAnimator.ofFloat(lineChartView, “percentage”, 0.0f, 1.0f)中第二个参数必须为“percentage”，对应前那边的setPercentage方法，属性动画会根据“percentage”参数通过反射调用setPercentage：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">/**</span><br><span class="hljs-comment">   * @param lineChartView</span><br><span class="hljs-comment">   * @param duration      动画持续时间</span><br><span class="hljs-comment">   */</span><br>  public void start<span class="hljs-constructor">Anim(LineChartView <span class="hljs-params">lineChartView</span>, <span class="hljs-params">long</span> <span class="hljs-params">duration</span>)</span> &#123;<br>      ObjectAnimator anim = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ObjectAnimator</span>.</span></span><span class="hljs-keyword">of</span><span class="hljs-constructor">Float(<span class="hljs-params">lineChartView</span>, <span class="hljs-string">&quot;percentage&quot;</span>, 0.0f, 1.0f)</span>;<br>      anim.set<span class="hljs-constructor">Duration(<span class="hljs-params">duration</span>)</span>;<br>      anim.set<span class="hljs-constructor">Interpolator(<span class="hljs-params">new</span> LinearInterpolator()</span>);<br>      anim.start<span class="hljs-literal">()</span>;<br>  &#125;<br></code></pre></td></tr></table></figure><p>至此，折线图的绘制已经全部完成。最后还可以添加get() set()方法，暴露出属性接口，以供外部调用。代码就不再贴出来了。</p><p>七、使用LineChartView<br>1.在布局文件中添加LineChartView,可设置折线颜色、字体颜色、等属性，如下：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;com.example.zhpan.linechartview.LineChartView<br>        android:<span class="hljs-attribute">id</span>=<span class="hljs-string">&quot;@+id/lcv&quot;</span><br>        android:<span class="hljs-attribute">layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span><br>        android:<span class="hljs-attribute">layout_height</span>=<span class="hljs-string">&quot;200dp&quot;</span><br>        android:<span class="hljs-attribute">layout_marginBottom</span>=<span class="hljs-string">&quot;20dp&quot;</span><br>        android:<span class="hljs-attribute">layout_marginLeft</span>=<span class="hljs-string">&quot;15dp&quot;</span><br>        android:<span class="hljs-attribute">layout_marginRight</span>=<span class="hljs-string">&quot;15dp&quot;</span><br>        android:<span class="hljs-attribute">layout_marginTop</span>=<span class="hljs-string">&quot;15dp&quot;</span><br>        app:<span class="hljs-attribute">lineColor</span>=<span class="hljs-string">&quot;#FF0000&quot;</span><br>        app:<span class="hljs-attribute">textColor</span>=<span class="hljs-string">&quot;#ABABAB&quot;</span><br>        app:<span class="hljs-attribute">textSize</span>=<span class="hljs-string">&quot;12dp&quot;</span>/&gt;<br></code></pre></td></tr></table></figure><p>2.在Activity中为LineChartView设置数据，也可以通过代码为其设置属性。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">private</span> <span class="hljs-built_in">void</span> initData() &#123;<br>        <span class="hljs-comment">//  初始化折线数据</span><br>        List&lt;Float&gt; listValues = new ArrayList&lt;&gt;();<br>        Random random = new Random();<br>        <span class="hljs-built_in">float</span> startValue = random.nextFloat() * <span class="hljs-number">10</span>;<br>        listValues.add(startValue);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">30</span>; i++) &#123;<br>            startValue += random.nextFloat() * <span class="hljs-number">10</span> - <span class="hljs-number">5</span>;<br>            listValues.add(startValue);<br>        &#125;<br>        List&lt;Integer&gt; listShadeColors = new ArrayList&lt;&gt;();<br>        listShadeColors.add(Color.argb(<span class="hljs-number">100</span>, <span class="hljs-number">255</span>, <span class="hljs-number">86</span>, <span class="hljs-number">86</span>));<br>        listShadeColors.add(Color.argb(<span class="hljs-number">15</span>, <span class="hljs-number">255</span>, <span class="hljs-number">86</span>, <span class="hljs-number">86</span>));<br>        listShadeColors.add(Color.argb(<span class="hljs-number">0</span>, <span class="hljs-number">255</span>, <span class="hljs-number">86</span>, <span class="hljs-number">86</span>));<br>        <span class="hljs-comment">//  设置折线数据</span><br>        mLineChartView.setValues(listValues);<br>        <span class="hljs-comment">//  设置渐变颜色</span><br>        mLineChartView.setShadeColors(listShadeColors);<br>        <span class="hljs-comment">//  设置动画插值器</span><br>        mLineChartView.setInterpolator(new DecelerateInterpolator());<br>        mLineChartView.setAxisMinValue(<span class="hljs-number">-30</span>);<br>        mLineChartView.setAxisMaxValue(<span class="hljs-number">30</span>);<br>        mLineChartView.setStartTime(<span class="hljs-string">&quot;2017-03-15&quot;</span>);<br>        mLineChartView.setEndTime(<span class="hljs-string">&quot;2017-04-14&quot;</span>);<br>        <span class="hljs-comment">//  开启动画</span><br>        mLineChartView.startAnim(<span class="hljs-number">2500</span>);<br>    &#125;<br></code></pre></td></tr></table></figure><p><a href="https://github.com/zhpanvip/CustomView">源码下载</a></p>]]></content>
    
    
    <categories>
      
      <category>自定义View</category>
      
    </categories>
    
    
    <tags>
      
      <tag>自定义View</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android搜索关键字高亮显示及开发中遇到的坑</title>
    <link href="/2016/12/15/6.Hightlight%20search%20key/"/>
    <url>/2016/12/15/6.Hightlight%20search%20key/</url>
    
    <content type="html"><![CDATA[<p>公司项目中有一个搜索功能，需求是要把搜索关键字高亮显示出来。本来觉得是一个很简单的问题，开发过程也比较顺利。但在测试阶段还是出了些Bug。而且有些问题还挺莫名其妙！<br>最初的想法，定义一个工具类，然后封装一个处理高亮的方法，需要高亮显示的直接调用这个工具类就行了。工具类封装了一个matcherSearchContent()的静态方法，然后用SpannableStringBuilder去处理关键字高亮显示，处理完成后方法返回处理好的SpannableStringBuilder。然后就可以直接给TextView去set处理好的SpannableStringBuilder。具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TextHighLight</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SpannableStringBuilder <span class="hljs-title">matcherSearchContent</span><span class="hljs-params">(String text,String[] keyword)</span></span>&#123;<br>        SpannableStringBuilder spannable=<span class="hljs-keyword">new</span> SpannableStringBuilder(text);<br>        CharacterStyle span=<span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;keyword.length;i++)&#123;<br>            Pattern pattern=Pattern.compile(keyword[i]);<br>            Matcher matcher=pattern.matcher(text);<br>            <span class="hljs-keyword">while</span>(m.find())&#123;<br>                span=<span class="hljs-keyword">new</span> ForegroundColorSpan(Color.parseColor(<span class="hljs-string">&quot;#ff5656&quot;</span>));<br>                            spannable.setSpan(span,m.start(),matcher.end(), Spannable.SPAN_MARK_MARK);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> spannable;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是后来需求说字母是要忽略大小写的。这个该怎么实现啊，用逻辑实现还是很麻烦的。还好，可以用到正则表达式来完成加上一行代码 “(?i)” + keyword[i] 就可以了。修改后代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TextHighLight</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SpannableStringBuilder <span class="hljs-title">matcherSearchContent</span><span class="hljs-params">(String text,String[] keyword)</span></span>&#123;<br>        SpannableStringBuilder spannable=<span class="hljs-keyword">new</span> SpannableStringBuilder(text);<br>        CharacterStyle span=<span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;keyword.length;i++)&#123;<br>            wordReg = <span class="hljs-string">&quot;(?i)&quot;</span> + keyword[i];   <span class="hljs-comment">//忽略字母大小写</span><br>            Pattern pattern = Pattern.compile(wordReg);<br>            Matcher matcher=pattern.matcher(text);<br>            <span class="hljs-keyword">while</span>(m.find())&#123;<br>                span=<span class="hljs-keyword">new</span> ForegroundColorSpan(Color.parseColor(<span class="hljs-string">&quot;#ff5656&quot;</span>));<br>                spannable.setSpan(span,m.start(),matcher.end(), Spannable.SPAN_MARK_MARK);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> spannable;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>嗯 这个解决的比较轻松。接下来测试阶段出现的问题。当输入特殊字符比如“*”时，程序出现异常闪退。调试发现原因是因为“*”号导致。在正则表达式中“*”是通配符，因此在匹配正则表达式时出现了异常。。解决办法也比较简单吗，就是判读如果包含“*”号的话就加上一个反斜杠转义一下就行了嘛！于是就有了下面的代码（因为测试的时候只有搜索“*“、”(“、”)”时出现闪退，因此只对这三个字符作了处理）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TextHighLight</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     *   关键字高亮显示</span><br><span class="hljs-comment">     *   <span class="hljs-doctag">@param</span> text 文字</span><br><span class="hljs-comment">     *   <span class="hljs-doctag">@param</span> keyword 文字中的关键字数组</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SpannableStringBuilder <span class="hljs-title">matcherSearchContent</span><span class="hljs-params">(String text, String[] keyword)</span> </span>&#123;<br>        SpannableStringBuilder spannable = <span class="hljs-keyword">new</span> SpannableStringBuilder(text);<br><br>        CharacterStyle span;<br>        String wordReg;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; keyword.length; i++) &#123;<br>            String key = <span class="hljs-string">&quot;&quot;</span>;<br>            <span class="hljs-comment">//  处理通配符问题</span><br>            <span class="hljs-keyword">if</span> (keyword[i].contains(<span class="hljs-string">&quot;*&quot;</span>) || keyword[i].contains(<span class="hljs-string">&quot;(&quot;</span>) || keyword[i].contains(<span class="hljs-string">&quot;)&quot;</span>)) &#123;<br>                <span class="hljs-keyword">char</span>[] chars = keyword[i].toCharArray();<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; chars.length; k++) &#123;<br>                    <span class="hljs-keyword">if</span> (chars[k] == <span class="hljs-string">&#x27;*&#x27;</span> || chars[k] == <span class="hljs-string">&#x27;(&#x27;</span> || chars[k] == <span class="hljs-string">&#x27;)&#x27;</span>) &#123;<br>                        key = key + <span class="hljs-string">&quot;\\&quot;</span> + String.valueOf(chars[k]);<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        key = key + String.valueOf(chars[k]);<br>                    &#125;<br>                &#125;<br>                keyword[i] = key;<br>            &#125;<br><br>            wordReg = <span class="hljs-string">&quot;(?i)&quot;</span> + keyword[i];   <span class="hljs-comment">//忽略字母大小写</span><br>            Pattern pattern = Pattern.compile(wordReg);<br>            Matcher matcher = pattern.matcher(text);<br>            <span class="hljs-keyword">while</span> (matcher.find()) &#123;<br>                span = <span class="hljs-keyword">new</span> ForegroundColorSpan(Color.parseColor(<span class="hljs-string">&quot;#ff5656&quot;</span>));<br>                spannable.setSpan(span, matcher.start(), matcher.end(), Spannable.SPAN_MARK_MARK);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> spannable;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上边代码先判断了字符串中是否包含“*”、”（”、”)”号，如果包含的话就遍历字符串然后在“*、”（”、”)”号前边加上反斜杠转义。嗯 这次一定没问题了。然后运行测试，跑起来看效果。嗯，果真正常了！以为这样就完了那就太天真了。当在一级搜索页面测试的时候一个很奇怪的问题出现了！！输入“*”搜索时发现“*”竟然没有高亮显示！效果图如下：</p><table><thead><tr><th>一级搜索页面</th><th>二级页面搜索</th></tr></thead><tbody><tr><td><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwMzAxMjEwOTI1NTI3?x-oss-process=image/format,png" alt="二级搜索页面"></td><td><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwMzAxMjEwOTQ2Nzc3?x-oss-process=image/format,png" alt="一级搜索页面"></td></tr></tbody></table><p>很诡异，有木有！两个页面调用的同一个Adapter，调用的同一个处理高亮的方法，为什么一个显示了高亮效果而一个却不正常显示呢！接下来经过漫长的调试、打log、对比两个页面。看下面的log日志信息：<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTYxMjE1MTMxMTQxODg4?x-oss-process=image/format,png" alt="这里写图片描述"><br>嗯？要匹配的字符串怎么变成了“\ \ *”了？正常来说应该匹配“\<em>“ 的这样在正则表达式中”\</em>“正好被转义成“<em>”的，难怪出现没有匹配高亮显示，问题就出在了上边的for循环添加”&quot;那段代码。看上边代码发现经过处理转义字符后将keyword[i]进行了一次重新赋值，而调用处理高亮的方法时传过来的参数关键字数组仅仅是一个引用，而实际的数组是在堆内存中存储的，因此重新赋值致使堆内存数据发生了改变！<br>既然找到了问题所在就应该分析引起问题的原因，为什么转义字符会被添加了两次？<br>调试的时候发现getView()方法确实是被重复执行了多次。这个原因就很奇怪了，按理说getView()方法的调用应该是跟ListView条目对应的。即有多少条数据，getView()就会被调用多少次。但是为什么在这个页面getView()会被重复执行，而在另一个页面getView()却只调用了一次？后来通过查阅资料发现是由于ListView的布局原因引起的。**</em>当ListView的layout_height属性设置为wrap_content的时候，getView()就会出现被重复调用的问题！，而layout_height设置位match_parent的时候getView()的调用则是正常的***，现在再会过头来看两个页面的布局，上边第一张图片是出现问题的布局，因为该页面有多个ListView，因此单个ListView的layout_height都被定义成了wrap_content从而出现了上述getView()被重复调用问题。而第二张图片中只有一个ListView,layout_height属性设置的是match_parent,因此这个页面getView()只被调用了一次，所以高亮显示也就正常了！</p><p>问题原因找到了，也就好解决了。解决的方案有两个，第一就是更改ListView()的layout_height属性，给其设置为定值。第二就是在matcherSearchContent（）的方法里复制出来关键字的数组，然后再去匹配。这里采用的是第二种方案。修改后代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TextHighLight</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     *   关键字高亮显示</span><br><span class="hljs-comment">     *   <span class="hljs-doctag">@param</span> text 文字</span><br><span class="hljs-comment">     *   <span class="hljs-doctag">@param</span> keyword 文字中的关键字数组</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SpannableStringBuilder <span class="hljs-title">matcherSearchContent</span><span class="hljs-params">(String text, String[] keyword)</span> </span>&#123;<br>        String[] keyword = <span class="hljs-keyword">new</span> String[keyword1.length];<br>        System.arraycopy(keyword1, <span class="hljs-number">0</span>, keyword, <span class="hljs-number">0</span>, keyword1.length);<br>        SpannableStringBuilder spannable = <span class="hljs-keyword">new</span> SpannableStringBuilder(text);<br><br>        CharacterStyle span;<br>        String wordReg;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; keyword.length; i++) &#123;<br>            String key = <span class="hljs-string">&quot;&quot;</span>;<br>            <span class="hljs-comment">//  处理通配符问题</span><br>            <span class="hljs-keyword">if</span> (keyword[i].contains(<span class="hljs-string">&quot;*&quot;</span>) || keyword[i].contains(<span class="hljs-string">&quot;(&quot;</span>) || keyword[i].contains(<span class="hljs-string">&quot;)&quot;</span>)) &#123;<br>                <span class="hljs-keyword">char</span>[] chars = keyword[i].toCharArray();<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; chars.length; k++) &#123;<br>                    <span class="hljs-keyword">if</span> (chars[k] == <span class="hljs-string">&#x27;*&#x27;</span> || chars[k] == <span class="hljs-string">&#x27;(&#x27;</span> || chars[k] == <span class="hljs-string">&#x27;)&#x27;</span>) &#123;<br>                        key = key + <span class="hljs-string">&quot;\\&quot;</span> + String.valueOf(chars[k]);<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        key = key + String.valueOf(chars[k]);<br>                    &#125;<br>                &#125;<br>                keyword[i] = key;<br>            &#125;<br><br>            wordReg = <span class="hljs-string">&quot;(?i)&quot;</span> + keyword[i];   <span class="hljs-comment">//忽略字母大小写</span><br>            Pattern pattern = Pattern.compile(wordReg);<br>            Matcher matcher = pattern.matcher(text);<br>            <span class="hljs-keyword">while</span> (matcher.find()) &#123;<br>                span = <span class="hljs-keyword">new</span> ForegroundColorSpan(Color.parseColor(<span class="hljs-string">&quot;#ff5656&quot;</span>));<br>                spannable.setSpan(span, matcher.start(), matcher.end(), Spannable.SPAN_MARK_MARK);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> spannable;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>到这里关于关键字高亮的所有问题总算是解决了。</p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>RecyclerView/ListView嵌套CheckBox选中状态错乱解决方案</title>
    <link href="/2016/09/25/5.RecyclerView%20adn%20ListView%20nested%20Checkbox/"/>
    <url>/2016/09/25/5.RecyclerView%20adn%20ListView%20nested%20Checkbox/</url>
    
    <content type="html"><![CDATA[<p>在讨论这个问题之前应该先了解ListView的复用机制<br>ListView复用的原理：ListView中的每一个Item显示都需要Adapter调用一次getView的方法，这个方法会传入一个convertView的参数，返回的View就是这个Item显示的View。如果当Item的数量足够大，再为每一个Item都创建一个View对象，必将占用很多内存，创建View对象（mInflater.inflate(R.layout.lv_item, null);从xml中生成View，这是属于IO操作）也是耗时操作，所以必将影响性能。<br>Android提供了一个叫做Recycler(反复循环器)的构件，就是当ListView的Item从上方滚出屏幕视角之外，对应Item的View会被缓存到Recycler中，相应的会从下方生成一个Item，而此时调用的getView中的convertView参数就是滚出屏幕的Item的View，所以说如果能重用这个convertView，就会大大改善性能。<br>如果一个屏幕最多显示7个Item，当Item1滑出屏幕，此时Item1 的View被添加进Recycler中，相应的在下部要产生一个Item8，这时调用getView方法，convertView参数就是Item1 的View。 其原理图如下：<br><img src="https://raw.githubusercontent.com/zhpanvip/images/master/project/article/0401.png" alt="这里写图片描述"><br>ListView的复用虽然大大提升了性能，但是却也带来很多问题。比如在加载图片时，由于下边的item复用了上边的item，造成下边item刚加载出来时显示的还是上边被复用的item的图片，等到这个新的item加载图片完毕时才会正常显示，这就是convert view复用造成listview图片加载错乱的问题。<br>与上边问题相似，在listview的item中存在CheckBox时也会由于复用convert view导致CheckBox的选中状态错乱，本片内容将解决由于复用导致CheckBox选中状态错乱的问题。<br>先看下存在问题的效果图<br><img src="https://raw.githubusercontent.com/zhpanvip/images/master/project/article/0402.gif" alt="这里写图片描述"></p><p>上图中只选中了北京市和天津市，当下滑ListView时发现下边的河南省和山东省也被选中了，再往下滑四川省和台湾省也被选中。其实可以发现一个规律，每一屏都会有两个条目被选中，其实这两个被选中的条目就是因为复用了第一屏的两个被选中的条目所导致的。<br>先看下ListView没有优化前的代码：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs routeros">public class MainActivity extends AppCompatActivity &#123;<br>    private ListView mListView;<br>    private List&lt;String&gt; mStringList;<br>    @Override<br>    protected void onCreate(Bundle savedInstanceState) &#123;<br>        super.onCreate(savedInstanceState);<br>        setContentView(R.layout.activity_main);<br>        <span class="hljs-attribute">mStringList</span>=new ArrayList&lt;&gt;();<br>        mStringList.<span class="hljs-builtin-name">add</span>(<span class="hljs-string">&quot;北京市&quot;</span>);mStringList.<span class="hljs-builtin-name">add</span>(<span class="hljs-string">&quot;天津市&quot;</span>);mStringList.<span class="hljs-builtin-name">add</span>(<span class="hljs-string">&quot;上海市&quot;</span>);mStringList.<span class="hljs-builtin-name">add</span>(<span class="hljs-string">&quot;重庆市&quot;</span>);<br>        mStringList.<span class="hljs-builtin-name">add</span>(<span class="hljs-string">&quot;河北省&quot;</span>);mStringList.<span class="hljs-builtin-name">add</span>(<span class="hljs-string">&quot;山西省&quot;</span>);mStringList.<span class="hljs-builtin-name">add</span>(<span class="hljs-string">&quot;辽宁省&quot;</span>);mStringList.<span class="hljs-builtin-name">add</span>(<span class="hljs-string">&quot;河南省&quot;</span>);<br>        mStringList.<span class="hljs-builtin-name">add</span>(<span class="hljs-string">&quot;山东省&quot;</span>);mStringList.<span class="hljs-builtin-name">add</span>(<span class="hljs-string">&quot;湖北省&quot;</span>);mStringList.<span class="hljs-builtin-name">add</span>(<span class="hljs-string">&quot;湖南省&quot;</span>);mStringList.<span class="hljs-builtin-name">add</span>(<span class="hljs-string">&quot;江西省&quot;</span>);<br>        mStringList.<span class="hljs-builtin-name">add</span>(<span class="hljs-string">&quot;福建省&quot;</span>);mStringList.<span class="hljs-builtin-name">add</span>(<span class="hljs-string">&quot;陕西省&quot;</span>);mStringList.<span class="hljs-builtin-name">add</span>(<span class="hljs-string">&quot;四川省&quot;</span>);mStringList.<span class="hljs-builtin-name">add</span>(<span class="hljs-string">&quot;台湾省&quot;</span>);<br>        mListView= (ListView) findViewById(R.id.lv_main);<br>        MyAdapter <span class="hljs-attribute">adapter</span>=new MyAdapter(this,mStringList);<br>        mListView.setAdapter(adapter);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>MainActivity中的代码为ListView适配数据和适配Adapter，不作过多解释。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Created by zhpan on 2016/9/24.</span><br><span class="hljs-comment"> */</span><br><br>public <span class="hljs-keyword">class</span> MyAdapter extends BaseAdapter &#123;<br><br>    List&lt;String&gt; mStringList;<br>    Context mContext;<br><br>    public <span class="hljs-constructor">MyAdapter(Context <span class="hljs-params">context</span>, List&lt;String&gt; <span class="hljs-params">stringList</span>)</span> &#123;<br>        mStringList = stringList;<br>        mContext=context;<br>    &#125;<br><br>    @Override<br>    public long get<span class="hljs-constructor">ItemId(<span class="hljs-params">int</span> <span class="hljs-params">position</span>)</span> &#123;<br>        return <span class="hljs-number">0</span>;<br>    &#125;<br><br>    @Override<br>    public View get<span class="hljs-constructor">View(<span class="hljs-params">final</span> <span class="hljs-params">int</span> <span class="hljs-params">position</span>, View <span class="hljs-params">convertView</span>, ViewGroup <span class="hljs-params">parent</span>)</span> &#123;<br>        MyViewHolder holder;<br>        <span class="hljs-keyword">if</span>(convertView==null)&#123;<br>            convertView=<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">View</span>.</span></span>inflate(mContext,<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">R</span>.</span></span>layout.item,null);<br>            holder=<span class="hljs-keyword">new</span> <span class="hljs-constructor">MyViewHolder()</span>;<br>            holder.mTextView= (TextView) convertView.find<span class="hljs-constructor">ViewById(R.<span class="hljs-params">id</span>.<span class="hljs-params">tv_item</span>)</span>;<br>            holder.mCheckBox= (CheckBox) convertView.find<span class="hljs-constructor">ViewById(R.<span class="hljs-params">id</span>.<span class="hljs-params">cb_item</span>)</span>;<br>            convertView.set<span class="hljs-constructor">Tag(<span class="hljs-params">holder</span>)</span>;<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            holder= (MyViewHolder) convertView.get<span class="hljs-constructor">Tag()</span>;<br>        &#125;<br><br>        holder.mTextView.set<span class="hljs-constructor">Text(<span class="hljs-params">mStringList</span>.<span class="hljs-params">get</span>(<span class="hljs-params">position</span>)</span>);<br><br>        return convertView;<br>    &#125;<br><br>    @Override<br>    public <span class="hljs-built_in">int</span> get<span class="hljs-constructor">Count()</span> &#123;<br>        return mStringList.size<span class="hljs-literal">()</span>;<br>    &#125;<br><br>    @Override<br>    public Object get<span class="hljs-constructor">Item(<span class="hljs-params">int</span> <span class="hljs-params">position</span>)</span> &#123;<br>        return null;<br>    &#125;<br><br>    public static <span class="hljs-keyword">class</span>  MyViewHolder &#123;<br>        TextView mTextView;<br>        CheckBox mCheckBox;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>在Adapter中只是复用了convertView,没有对CheckBox做任何处理，那么这样写的代码是存在上图中的CheckBox选中状态错乱问题的。为了解决这个问题我们需要对CheckBox的选中状态做下保存，可以在Adapter中声明一个Map集合用来保存被选中的CheckBox。修改后代码如下：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Created by zhpan on 2016/9/24.</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyAdapter</span> <span class="hljs-title">extends</span> <span class="hljs-title">BaseAdapter</span> &#123;</span><br><br>    List&lt;<span class="hljs-keyword">String</span>&gt; mStringList;<br>    Context mContext;<br>    <span class="hljs-keyword">private</span> Map&lt;Integer,Boolean&gt; <span class="hljs-built_in">map</span>=<span class="hljs-keyword">new</span> HashMap&lt;&gt;();<span class="hljs-comment">// 存放已被选中的CheckBox</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyAdapter</span><span class="hljs-params">(Context context, List&lt;<span class="hljs-keyword">String</span>&gt; stringList)</span> </span>&#123;<br>        mStringList = stringList;<br>        mContext=context;<br>    &#125;<br><br>    @Override<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getItemId</span><span class="hljs-params">(<span class="hljs-keyword">int</span> <span class="hljs-built_in">position</span>)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    @Override<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> View <span class="hljs-title">getView</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-built_in">position</span>, View convertView, ViewGroup parent)</span> </span>&#123;<br>        MyViewHolder holder;<br>        <span class="hljs-keyword">if</span>(convertView==null)&#123;<br>            convertView=View.inflate(mContext,R.layout.item,null);<br>            holder=<span class="hljs-keyword">new</span> MyViewHolder();<br>            holder.mTextView= (TextView) convertView.findViewById(R.id.tv_item);<br>            holder.mCheckBox= (CheckBox) convertView.findViewById(R.id.cb_item);<br>            convertView.setTag(holder);<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            holder= (MyViewHolder) convertView.getTag();<br>        &#125;<br><br>        holder.mTextView.setText(mStringList.<span class="hljs-built_in">get</span>(<span class="hljs-built_in">position</span>));<br>        holder.mCheckBox.setOnCheckedChangeListener(<span class="hljs-keyword">new</span> CompoundButton.OnCheckedChangeListener() &#123;<br>            @Override<br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> onCheckedChanged(CompoundButton buttonView, <span class="hljs-keyword">boolean</span> isChecked) &#123;<br>                <span class="hljs-keyword">if</span>(isChecked==<span class="hljs-literal">true</span>)&#123;<br>                    <span class="hljs-built_in">map</span>.<span class="hljs-built_in">put</span>(<span class="hljs-built_in">position</span>,<span class="hljs-literal">true</span>);<br>                &#125;<span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-built_in">map</span>.<span class="hljs-built_in">remove</span>(<span class="hljs-built_in">position</span>);<br>                &#125;<br>            &#125;<br>        &#125;);<br><br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">map</span>!=null&amp;&amp;<span class="hljs-built_in">map</span>.containsKey(<span class="hljs-built_in">position</span>))&#123;<br>            holder.mCheckBox.setChecked(<span class="hljs-literal">true</span>);<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            holder.mCheckBox.setChecked(<span class="hljs-literal">false</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> convertView;<br>    &#125;<br><br>    @Override<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getCount</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> mStringList.<span class="hljs-built_in">size</span>();<br>    &#125;<br><br>    @Override<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getItem</span><span class="hljs-params">(<span class="hljs-keyword">int</span> <span class="hljs-built_in">position</span>)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> null;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span>  <span class="hljs-title">MyViewHolder</span> &#123;</span><br>        TextView mTextView;<br>        CheckBox mCheckBox;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>针对这个问题我们子Adapter中加入了一个Map集合，其中Map的key用来存储条被选中的checkbox的position，value用来存储checkbox被选中。代码中还添加了checkbox的监听事件，在监听事件中判断点击的checkbox是否被选中，如果被选中了则将position添加到集合，并设置状态未true，否则就将该checkbox从集合中移除。然后通过if语句判断集合中是否存在该checkbox，如果存在则证明是被选中的,遂将该checkbox设置为选中状态setChecked(true)，否则证明checkbox没有选中则设置setChecked(false)。这样就解决了checkbox选中状态错乱的问题。<br>看下优化后的效果图<br><img src="https://raw.githubusercontent.com/zhpanvip/images/master/project/article/0403.gif" alt="这里写图片描述"></p><p>可以看到优化后CheckBox的选中状态不会再出现错乱问题了。</p><p><a href="http://download.csdn.net/detail/qq_20521573/9639225">源码下载</a></p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RecyclerView</tag>
      
      <tag>ListView</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>由浅入深理解Android中的回调机制</title>
    <link href="/2016/07/28/4.Callback%20in%20Android/"/>
    <url>/2016/07/28/4.Callback%20in%20Android/</url>
    
    <content type="html"><![CDATA[<p>什么是接口回调？来先看看接口回调的定义吧：可以把使用某一接口的类创建的对象的引用赋给该接口声明的接口变量，那么该接口变量就可以调用被类实现的接口的方法。什么意思？反正我是没看懂，哈哈（#黑线），这么官方的话还是不要看的好，不如看一个具体的例子。<br>话说有一天，奥巴马下达命令，让美国空军派轰炸机前去轰炸恐怖分子基地，并要求空军完成任务后通报轰炸详情。下达完命令后呢，奥巴马不会坐那干等空军电报吧，再说奥黑忙着呢，整天想着怎么阴俄罗斯和中国呢..于是下达完命令奥巴马就去干其他事情了。两个小时后空军发来电报：恐怖分子基地已摧毁。<br>嗯，就酱紫！上边的例子就是一个典型的接口回调！（奥巴马命令空军去空炸基地，空军轰炸完后向奥巴马报告即接口回调）接下来用java代码来实现上边的描述。<br>首先定义一个回调接口，该接口中有一个report()的回调方法，空军完成任务后会通过调用此方法发送电报。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Created by zhpan on 2016/7/27.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-symbol">ReportCallback</span> &#123;<span class="hljs-comment">//回调接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> report(String result); <span class="hljs-comment">//回调方法</span><br>&#125;<br></code></pre></td></tr></table></figure><p>定义一个奥巴马类，让他实现ReportCallback接口，并重写report()方法,注意，Obama类中持有空军Plane的引用,在此类中可通过调用plane.boom(this)命令空军去执行任务，boom()方法的参数为this，相当于new Obama()作为参数，即将自身传了进去。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Created by zhpan on 2016/7/27.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Obama</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ReportCallback</span> </span>&#123;<br><br><span class="hljs-keyword">private</span> Plane plane=<span class="hljs-keyword">new</span> Plane();<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Obama</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">super</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Obama</span><span class="hljs-params">(Plane plane)</span> </span>&#123;<br><span class="hljs-keyword">super</span>();<br><span class="hljs-keyword">this</span>.plane = plane;<br>&#125;<br><span class="hljs-comment">//命令轰炸机轰炸恐怖分子基地的方法</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">command</span><span class="hljs-params">()</span></span>&#123;<br>plane.boom(<span class="hljs-keyword">this</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">report</span><span class="hljs-params">(String result)</span> </span>&#123;<br>System.out.println(<span class="hljs-string">&quot;任务详情：&quot;</span>+result);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>下边是空军类，Obama类中调用此处的boom()方法（空军接到任务）。此类中持有了一个ReportCallback的引用cb,cb其实是由Obama向上转型而来，因为在Obama类中调用boom()方法时参数为this，用cb调用report()实际上是通过接口调用到了接口ReportCallback的子类Obama类中的report()方法。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Created by zhpan on 2016/7/27.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-symbol">Plane</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> boom(ReportCallback cb)&#123;<br><span class="hljs-comment">//空军执行了五次轰炸任务</span><br><span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)&#123;<br><span class="hljs-comment">//一个耗时操作</span><br><span class="hljs-keyword">try</span> &#123;<br>System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;执行轰炸任务&quot;</span>);<br>Thread.sleep(<span class="hljs-number">1000</span>);<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>e.printStackTrace();<br>&#125;<br>&#125;<br><span class="hljs-comment">//轰炸结束后通过report()方法发送了电报给奥黑</span><br>cb.report(<span class="hljs-string">&quot;基地已摧毁&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试类，Obama调用command方法。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> &#123;</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br><br>Obama obama=<span class="hljs-keyword">new</span> Obama();<br><span class="hljs-comment">//奥巴马下达命令</span><br>obama.command();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试结果如下：<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTYwNzI3MTUzMzU1ODM5" alt="这里写图片描述"><br>经过上边的例子，我们应该对接口回调有了一个初步的认识。那么在Android中都哪些地方用到了回调机制呢？其实，接口回调在Android中用的相当广泛，Android中的一些事件处理方法，比如：onKeyDown、onKeyLongPress、onTouchEvent等还有View的监听事件都是通过回调实现的。<br>下面我们以Button为例来分析Android中的回调机制。当用户点击Button时，会触发Button的onClick()方法，onClick()就是一个回调方法。结合View的源码来看：</p><p>在View中定义了一个OnClickListener 的接口，接口中有一个onClick的抽象方法，可类比上边例子中的ReportCallback 接口。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * Interface definition for a callback to be invoked when a view is clicked.</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">OnClickListener</span> </span>&#123;<br>       <span class="hljs-comment">/**</span><br><span class="hljs-comment">        * Called when a view has been clicked.</span><br><span class="hljs-comment">        *</span><br><span class="hljs-comment">        * <span class="hljs-doctag">@param</span> v The view that was clicked.</span><br><span class="hljs-comment">        */</span><br>       <span class="hljs-keyword">void</span> onClick(View v);<br>   &#125;<br></code></pre></td></tr></table></figure><p>同时View中还持有一个OnClickListener 接口的引用mOnClickListener，mOnClickListener对应了上边例子Plane 类中boom（ReportCallback cb）方法的参数cb,另外View中还定义了setOnClickListener()方法，该方法的参数是OnClickListener接口，方法体中将该参数赋值给了mOnClickListener。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs php">    <span class="hljs-comment">/**</span><br><span class="hljs-comment">      * Listener used to dispatch click events.</span><br><span class="hljs-comment">      * This field should be made private,</span><br><span class="hljs-comment">      *  so it is hidden from the SDK.</span><br><span class="hljs-comment">      * &#123;<span class="hljs-doctag">@hide</span>&#125;</span><br><span class="hljs-comment">      */</span><br>     <span class="hljs-keyword">public</span> OnClickListener mOnClickListener;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * Register a callback to be invoked when this view is</span><br><span class="hljs-comment">  * clicked. If this view is not</span><br><span class="hljs-comment">  * clickable, it becomes clickable.</span><br><span class="hljs-comment">  *</span><br><span class="hljs-comment">  * <span class="hljs-doctag">@param</span> l The callback that will run</span><br><span class="hljs-comment">  *</span><br><span class="hljs-comment">  * <span class="hljs-doctag">@see</span> #setClickable(boolean)</span><br><span class="hljs-comment">  */</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> setOnClickListener(@Nullable OnClickListener l) &#123;<br>     <span class="hljs-keyword">if</span> (!isClickable()) &#123;<br>         setClickable(<span class="hljs-literal">true</span>);<br>     &#125;<br>     getListenerInfo().mOnClickListener = l;<br> &#125;<br></code></pre></td></tr></table></figure><p>最后在performClick()方法中通过li.mOnClickListener.onClick(this);调用了onClick()方法，可类比Plane 类中cb调用report()方法。</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><br>/**<br> * Call this view&#x27;s OnClickListener, <span class="hljs-keyword">if</span> <span class="hljs-keyword">it</span> <span class="hljs-keyword">is</span> defined.<br> * Performs all normalactions associated <span class="hljs-keyword">with</span><br> * clicking: reporting accessibility event, playing<br> * a sound, etc.<br> *<br> * @<span class="hljs-literal">return</span> True there was an assigned OnClickListener<br> * <span class="hljs-keyword">that</span> was called, <span class="hljs-literal">false</span><br> *         otherwise <span class="hljs-keyword">is</span> returned.<br> */<br>public <span class="hljs-built_in">boolean</span> performClick() &#123;<br>    final <span class="hljs-built_in">boolean</span> <span class="hljs-literal">result</span>;<br>    final ListenerInfo li = mListenerInfo;<br>    <span class="hljs-keyword">if</span> (li != null &amp;&amp; li.mOnClickListener != null) &#123;<br>        playSoundEffect(SoundEffectConstants.CLICK);<br>        li.mOnClickListener.onClick(this);<br>        <span class="hljs-literal">result</span> = <span class="hljs-literal">true</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-literal">result</span> = <span class="hljs-literal">false</span>;<br>    &#125;<br>    sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED);<br><span class="hljs-built_in">    return</span> <span class="hljs-literal">result</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这是Android中回调机制的一个典型应用场景，通过上边对Android源码的分析相信大家对回调机制又有了更深一步的了解。在此基础上接下来我们不妨自己动手写一个回调。Come on!</p><p>我们以一个简易的购物车添加商品为例来实现一个自己的接口回调！先来看效果图吧<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTYwNzI4MTQwNzE1MTkx" alt="这里写图片描述"><br>上图中商品列表其实是一个ListView，由于只是演示接口回调的应用，所以只在ListView中填充了一条数据。而最下边的结算一栏是在ListView的外部，那么当商品数量改变时结算总价必然会跟随变化，也就是下边的结算会随着点击加号或者减号而变化。<br>做过item的子控件的点击事件的小伙伴应该清楚，item中子控件的点击事件是在Adapter中完成的，那么在ListView中点击子控件控件如何将得到的结果显示到ListView外部呢？即商品数量改变了，如何将总价格更新到ListView外部的结算出？其实就可以用接口回调来完成。接下来看实现思路。<br>1.首先我们可以定义一个接口OnNumChangeListener，接口里边包含两个抽象方法，分别负责增加和减少商品数量。代码如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">OnNumChangeListener</span> &#123;<br>    <span class="hljs-comment">//  增加商品数量的回调方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onAddNumListener</span>(<span class="hljs-params"><span class="hljs-keyword">int</span> price,ViewHolder holder</span>)</span>;<br>    <span class="hljs-comment">//减少商品数量的回调方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onSubNumListener</span>(<span class="hljs-params"><span class="hljs-keyword">int</span> price,ViewHolder holder</span>)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>2.在MyAdapter中添加setOnNumChangeListener方法，并在“+”、“-”按钮点击的时候分别调用OnNumChangeListener接口中的两个方法。代码如下：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Created by zhpan on 2016/7/28.</span><br><span class="hljs-comment"> * item中的数据并没有在getView()方法中添加，而是是在item布局文件中添加的。</span><br><span class="hljs-comment"> */</span><br>public <span class="hljs-keyword">class</span> MyAdapter extends BaseAdapter &#123;<br>    Context mContext;<br>    OnNumChangeListener mOnNumChangeListener ;<br><br>public void set<span class="hljs-constructor">OnNumChangeListener(OnNumChangeListener <span class="hljs-params">onNumChangeListener</span> )</span>&#123;<br>this.mOnNumChangeListener = onNumChangeListener<br>&#125;<br><br>    @Override<br>    public View get<span class="hljs-constructor">View(<span class="hljs-params">int</span> <span class="hljs-params">position</span>, View <span class="hljs-params">convertView</span>, ViewGroup <span class="hljs-params">parent</span>)</span> &#123;<br>        convertView=<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">View</span>.</span></span>inflate(mContext,<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">R</span>.</span></span>layout.item,null);<br>        final ViewHolder holder=<span class="hljs-keyword">new</span> <span class="hljs-constructor">ViewHolder()</span>;<br>        holder.add = (TextView) convertView.find<span class="hljs-constructor">ViewById(R.<span class="hljs-params">id</span>.<span class="hljs-params">tv_item_add</span>)</span>;<br>        holder.sub = (TextView) convertView.find<span class="hljs-constructor">ViewById(R.<span class="hljs-params">id</span>.<span class="hljs-params">tv_item_sub</span>)</span>;<br>        holder.num = (TextView) convertView.find<span class="hljs-constructor">ViewById(R.<span class="hljs-params">id</span>.<span class="hljs-params">tv_item_num</span>)</span>;<br>        <span class="hljs-comment">//  “+”的监听事件</span><br>        holder.add.set<span class="hljs-constructor">OnClickListener(<span class="hljs-params">new</span> View.OnClickListener()</span> &#123;<br>            @Override<br>            public void on<span class="hljs-constructor">Click(View <span class="hljs-params">view</span>)</span> &#123;<br>                <span class="hljs-comment">//  回调方法</span><br>                mOnNumChangeListener .on<span class="hljs-constructor">AddNumListener(10, <span class="hljs-params">holder</span>)</span>;<br>            &#125;<br>        &#125;);<br>        <span class="hljs-comment">//  “-”的监听事件</span><br>        holder.sub.set<span class="hljs-constructor">OnClickListener(<span class="hljs-params">new</span> View.OnClickListener()</span> &#123;<br>            @Override<br>            public void on<span class="hljs-constructor">Click(View <span class="hljs-params">view</span>)</span> &#123;<br>                <span class="hljs-comment">//  回调方法</span><br>                mOnNumChangeListener .on<span class="hljs-constructor">SubNumListener(10,<span class="hljs-params">holder</span>)</span>;<br>            &#125;<br>        &#125;);<br>        return convertView;<br>    &#125;<br><br><span class="hljs-operator">... </span><span class="hljs-comment">//  省略MyAdapter中无关代码</span><br><br>&#125;<br></code></pre></td></tr></table></figure><p>3.接下来在MainActivity中为Adapter设置OnNumChangeListener接口 并重写接口中的两个方法。代码如下：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">adapter.set<span class="hljs-constructor">OnNumChangeListener(<span class="hljs-params">new</span> MyAdapter.OnNumChangeListener()</span>&#123;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 在此实现增加商品数量，并更新总价格</span><br><span class="hljs-comment">     */</span><br>    @Override<br>    public void on<span class="hljs-constructor">AddNumListener(<span class="hljs-params">int</span> <span class="hljs-params">price</span>,ViewHolder <span class="hljs-params">holder</span>)</span> &#123;<br>        String numStr = holder.num.get<span class="hljs-constructor">Text()</span>.<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span>;<br>        <span class="hljs-built_in">int</span> num=<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Integer</span>.</span></span>parse<span class="hljs-constructor">Int(<span class="hljs-params">numStr</span>)</span>;<br>        num++;<br>        holder.num.set<span class="hljs-constructor">Text(<span class="hljs-params">num</span>+<span class="hljs-string">&quot;&quot;</span>)</span>;<br>        <span class="hljs-built_in">int</span> totalPrice=price*num;<br>        mTextView.set<span class="hljs-constructor">Text(<span class="hljs-string">&quot;结算：￥&quot;</span>+<span class="hljs-params">totalPrice</span>)</span>;<br><br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 在此实现减少商品数量，并更新总价格</span><br><span class="hljs-comment">     */</span><br>    @Override<br>    public void on<span class="hljs-constructor">SubNumListener(<span class="hljs-params">int</span> <span class="hljs-params">price</span>,ViewHolder <span class="hljs-params">holder</span>)</span> &#123;<br>        String numStr = holder.num.get<span class="hljs-constructor">Text()</span>.<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span>;<br>        <span class="hljs-built_in">int</span> num=<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Integer</span>.</span></span>parse<span class="hljs-constructor">Int(<span class="hljs-params">numStr</span>)</span>;<br>        <span class="hljs-keyword">if</span>(num&gt;<span class="hljs-number">1</span>)&#123;<br>            num--;<br>            holder.num.set<span class="hljs-constructor">Text(<span class="hljs-params">num</span>+<span class="hljs-string">&quot;&quot;</span>)</span>;<br>            <span class="hljs-built_in">int</span> totalPrice=price*num;<br>            mTextView.set<span class="hljs-constructor">Text(<span class="hljs-string">&quot;结算：￥&quot;</span>+<span class="hljs-params">totalPrice</span>)</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Toast</span>.</span></span>make<span class="hljs-constructor">Text(MainActivity.<span class="hljs-params">this</span>, <span class="hljs-string">&quot;不能再减少了&quot;</span>, Toast.LENGTH_SHORT)</span>.show<span class="hljs-literal">()</span>;<br>        &#125;<br>    &#125;<br><br>&#125;);<br></code></pre></td></tr></table></figure><p>这样一个简单的接口回调就完成了，相信经过这本篇文章的学习，大家一定能够掌握接口回调的使用，如果没有明白也没关系，可以参考下面源码。</p><p><a href="http://download.csdn.net/detail/qq_20521573/9588810">源码下载</a></p><h3 id="好库推荐"><a href="#好库推荐" class="headerlink" title="好库推荐"></a>好库推荐</h3><p>给大家推荐一下<a href="https://github.com/zhpanvip/BannerViewPager">BannerViewPager</a>。这是一个基于ViewPager实现的具有强大功能的无限轮播库。通过<a href="https://github.com/zhpanvip/BannerViewPager">BannerViewPager</a>可以实现腾讯视频、QQ音乐、酷狗音乐、支付宝、天猫、淘宝、优酷视频、喜马拉雅、网易云音乐、哔哩哔哩等APP的Banner样式以及指示器样式。</p><p>欢迎大家到github关注<a href="https://github.com/zhpanvip/BannerViewPager">BannerViewPager</a>！</p>]]></content>
    
    
    <categories>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>callback</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浅析Java设计模式（三）</title>
    <link href="/2016/07/26/3.Java%20design%20patterns(3)/"/>
    <url>/2016/07/26/3.Java%20design%20patterns(3)/</url>
    
    <content type="html"><![CDATA[<p>本篇文章继续来学习Java的设计模式，这篇文章来解析行为型模式种的几种比较常用的设计模式。</p><h2 id="一、观察者模式"><a href="#一、观察者模式" class="headerlink" title="一、观察者模式"></a>一、观察者模式</h2><p>观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态发生变化时，会通知所有的观察者对象，使它们能够自动更新自己。以微信推送腾讯新闻为例，用户在微信订阅了腾讯新闻后，用户会收到腾讯的新闻推送。如果用户取消了新闻订阅，那么就不会再收到推送。<br>观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态发生变化时，会通知所有的观察者对象，使它们能够自动更新自己。</p><p>以订阅微信公众号为例：</p><blockquote><p>用户在微信订阅了微信公众号后，会收到公众号的消息推送。如果用户取消了订阅，那么就不会再收到推送。</p></blockquote><h3 id="1-观察者Observer抽象层"><a href="#1-观察者Observer抽象层" class="headerlink" title="1.观察者Observer抽象层"></a>1.观察者Observer抽象层</h3><p>观察者订阅公众号后会监听公众号推送的消息，推送后观察者会收到更新。可以抽象出一个观察者接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 观察者抽象层</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Observer</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(String obj)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-观察者实现"><a href="#2-观察者实现" class="headerlink" title="2.观察者实现"></a>2.观察者实现</h3><p>用户实现观察者接口，收到消息后将消息打印：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 观察者实现</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserObserver</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Observer</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> String message;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">UserObserver</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(String message)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.message = message;<br>        readMessage();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">readMessage</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(name + <span class="hljs-string">&quot;收到一条消息：&quot;</span> + message);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-被观察者抽象层"><a href="#3-被观察者抽象层" class="headerlink" title="3.被观察者抽象层"></a>3.被观察者抽象层</h3><p>被观察者提供订阅、取消订阅、发布消息、以及发布消息后通知观察者的功能：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 被观察者抽象层</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Observable</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addObserver</span><span class="hljs-params">(Observer observer)</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">removeObserver</span><span class="hljs-params">(Observer observer)</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">notifyObservers</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">// 发布消息</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pushMessage</span><span class="hljs-params">(String message)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-被观察者实现"><a href="#4-被观察者实现" class="headerlink" title="4.被观察者实现"></a>4.被观察者实现</h3><p>定义一个公众号的被观察者，并实现Observable：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 被观察者</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WechatObservable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Observable</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> List&lt;Observer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    <span class="hljs-keyword">private</span> String message;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addObserver</span><span class="hljs-params">(Observer observer)</span> </span>&#123;<br>        list.add(observer);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removeObserver</span><span class="hljs-params">(Observer observer)</span> </span>&#123;<br>        list.remove(observer);<br>    &#125;<br><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notifyObservers</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (Observer observer : list) &#123;<br>            observer.update(message);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pushMessage</span><span class="hljs-params">(String message)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.message = message;<br>        <span class="hljs-comment">// 通知订阅的用户</span><br>        notifyObservers();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-测试代码"><a href="#5-测试代码" class="headerlink" title="5.测试代码"></a>5.测试代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ObserverTest</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        WechatObservable wechatObservable = <span class="hljs-keyword">new</span> WechatObservable();<br>        UserObserver ryan = <span class="hljs-keyword">new</span> UserObserver(<span class="hljs-string">&quot;Ryan&quot;</span>);<br>        UserObserver frank = <span class="hljs-keyword">new</span> UserObserver(<span class="hljs-string">&quot;Mike&quot;</span>);<br><br>        wechatObservable.addObserver(ryan);<br>        wechatObservable.addObserver(frank);<br><br>        wechatObservable.pushMessage(<span class="hljs-string">&quot;this is a news&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">Ryan收到一条消息：<span class="hljs-keyword">this</span> <span class="hljs-keyword">is</span> a news<br>Mike收到一条消息：<span class="hljs-keyword">this</span> <span class="hljs-keyword">is</span> a news<br></code></pre></td></tr></table></figure><h2 id="二、策略模式"><a href="#二、策略模式" class="headerlink" title="二、策略模式"></a>二、策略模式</h2><p>策略模式定义了一系列的算法，并将每一个算法封装起来，而且使他们可以相互替换，让算法独立于使用它的客户而独立变化。策略模式设计三个角色，环境(Context)角色、抽象策略(Strategy)角色以及具体策略(ConcreteStrategy)角色。<br>来看一个现实生活的例子，假设一个商场有三种会员（Strategy），分别为普通会员（StandardMemberStraegy）、白银会员（SilverMemberStrategy）以及黄金会员（GoldenMemberStrategy）。针对三种会员分别制定了不同的优方案。普通会员打九折、白银会员打八折、黄金会员打七折。来看如何用策略模式实现上述场景。</p><h3 id="1-创建抽象策略类"><a href="#1-创建抽象策略类" class="headerlink" title="1.创建抽象策略类"></a>1.创建抽象策略类</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> abstract <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Strategy</span> &#123;</span><br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">String</span> strategy;<br><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">String</span> <span class="hljs-title">getStrategy</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> strategy;<br>&#125;<br><br><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Strategy</span><span class="hljs-params">(<span class="hljs-keyword">String</span> strategy)</span> </span>&#123;<br>super();<br><span class="hljs-keyword">this</span>.strategy = strategy;<br>&#125;<br><br><span class="hljs-function">abstract <span class="hljs-keyword">double</span> <span class="hljs-title">getPrice</span><span class="hljs-params">(<span class="hljs-keyword">double</span> normalPrice)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-创建环境类（Context）并持有抽象策略类"><a href="#2-创建环境类（Context）并持有抽象策略类" class="headerlink" title="2.创建环境类（Context）并持有抽象策略类"></a>2.创建环境类（Context）并持有抽象策略类</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public <span class="hljs-keyword">class</span> Context &#123;<br><span class="hljs-keyword">private</span> Strategy mStrategy;<br><br>public void set<span class="hljs-constructor">Strategy(Strategy <span class="hljs-params">strategy</span>)</span> &#123;<br>mStrategy=strategy;<br>&#125;<br><br>public double execute<span class="hljs-constructor">Price(<span class="hljs-params">double</span> <span class="hljs-params">normalPrice</span>)</span> &#123;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(mStrategy.get<span class="hljs-constructor">Strategy()</span>+<span class="hljs-string">&quot;Member，折后价：&quot;</span>+mStrategy.get<span class="hljs-constructor">Price(<span class="hljs-params">normalPrice</span>)</span>);<br>return mStrategy.get<span class="hljs-constructor">Price(<span class="hljs-params">normalPrice</span>)</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-创建三种会员策略类"><a href="#3-创建三种会员策略类" class="headerlink" title="3.创建三种会员策略类"></a>3.创建三种会员策略类</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StandardMemberStraegy</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Strategy</span> </span>&#123;<br><br>public <span class="hljs-type">StandardMemberStraegy</span>(<span class="hljs-type">String</span> strategy) &#123;<br><span class="hljs-keyword">super</span>(strategy);<br>&#125;<br><br><span class="hljs-meta">@Override</span><br>public double getPrice(double normalPrice) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0.9</span>*normalPrice;<br>&#125;<br>&#125;<br><br>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SilverMemberStrategy</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Strategy</span></span>&#123;<br><br>public <span class="hljs-type">SilverMemberStrategy</span>(<span class="hljs-type">String</span> strategy) &#123;<br><span class="hljs-keyword">super</span>(strategy);<br>&#125;<br><br><span class="hljs-meta">@Override</span><br>public double getPrice(double normalPrice) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0.8</span>*normalPrice;<br>&#125;<br><br>&#125;<br><br>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GoldenMemberStrategy</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Strategy</span> </span>&#123;<br><br><br>public <span class="hljs-type">GoldenMemberStrategy</span>(<span class="hljs-type">String</span> strategy) &#123;<br><span class="hljs-keyword">super</span>(strategy);<br>&#125;<br><br><span class="hljs-meta">@Override</span><br>public double getPrice(double normalPrice) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0.7</span>*normalPrice;<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-创建策略模式测试类"><a href="#4-创建策略模式测试类" class="headerlink" title="4.创建策略模式测试类"></a>4.创建策略模式测试类</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public <span class="hljs-keyword">class</span> StrategyTest &#123;<br><br>public static void main(String<span class="hljs-literal">[]</span> args) &#123;<br>StandardMemberStraegy standar=<span class="hljs-keyword">new</span> <span class="hljs-constructor">StandardMemberStraegy(<span class="hljs-string">&quot;Standar&quot;</span>)</span>;<br>SilverMemberStrategy silver=<span class="hljs-keyword">new</span> <span class="hljs-constructor">SilverMemberStrategy(<span class="hljs-string">&quot;Silver&quot;</span>)</span>;<br>GoldenMemberStrategy golden=<span class="hljs-keyword">new</span> <span class="hljs-constructor">GoldenMemberStrategy(<span class="hljs-string">&quot;Golden&quot;</span>)</span>;<br>Context context=<span class="hljs-keyword">new</span> <span class="hljs-constructor">Context()</span>;<br><br>context.set<span class="hljs-constructor">Strategy(<span class="hljs-params">standar</span>)</span>;<br>context.execute<span class="hljs-constructor">Price(100)</span>;<br><br>context.set<span class="hljs-constructor">Strategy(<span class="hljs-params">silver</span>)</span>;<br>context.execute<span class="hljs-constructor">Price(100)</span>;<br><br>context.set<span class="hljs-constructor">Strategy(<span class="hljs-params">golden</span>)</span>;<br>context.execute<span class="hljs-constructor">Price(100)</span>;<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><blockquote><p>StandarMember，折后价：90.0<br>SilverMember，折后价：80.0<br>GoldenMember，折后价：70.0</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浅析Java设计模式（二）</title>
    <link href="/2016/07/25/2.Java%20design%20patterns(2)/"/>
    <url>/2016/07/25/2.Java%20design%20patterns(2)/</url>
    
    <content type="html"><![CDATA[<p>上篇文章我们学习了几种创建型模式 的设计模式，那么本篇文章就继续来学习一下结构型模式的几个常用设计模式。</p><h2 id="一、代理模式（Proxy-Pattern）"><a href="#一、代理模式（Proxy-Pattern）" class="headerlink" title="一、代理模式（Proxy Pattern）"></a>一、代理模式（Proxy Pattern）</h2><p>代理模式即为其它对象提供一种代理控制对这个对象的访问。在代理模式中，一个类代表另一个类的功能。这种类型的设计模式属于结构型模式。在代理模式中，我们创建具有现有对象的对象，以便向外界提供功能接口。代理模式的机构图如下：<br><img src="https://raw.githubusercontent.com/zhpanvip/images/master/project/article/0201.png" alt="这里写图片描述"><br>Subject类中定义一个抽象request()方法,RealSubject和Proxy共用接口，这样就在任何使用RealSubject的地方都可以使用Proxy。<br>1.Subject类代码如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Subject</span> &#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">request</span>(<span class="hljs-params"></span>)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>2.RealSubject集成Subject类</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RealSubject</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Subject</span></span>&#123;<br><br><span class="hljs-meta">@Override</span><br>public void request() &#123;<br><span class="hljs-type">System</span>.out.println(<span class="hljs-string">&quot;Real Request&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>3.Proxy实现Subject类</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Proxy</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Subject</span> </span>&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-type">RealSubject</span> mRealSubject;<br><br><span class="hljs-meta">@Override</span><br>public void request() &#123;<br><span class="hljs-keyword">if</span>(mRealSubject==<span class="hljs-literal">null</span>) &#123;<br>mRealSubject=<span class="hljs-keyword">new</span> <span class="hljs-type">RealSubject</span>();<br>&#125;<br>mRealSubject.request();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>4.代理测试类</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs routeros">public class ProxyTest &#123;<br><br>public static void main(String[] args) &#123;<br><span class="hljs-built_in">Proxy </span><span class="hljs-attribute">proxy</span>=new Proxy();<br>proxy.request();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><blockquote><p>Real Request</p></blockquote><h2 id="二、装饰模式（Decorator-Pattern）"><a href="#二、装饰模式（Decorator-Pattern）" class="headerlink" title="二、装饰模式（Decorator Pattern）"></a>二、装饰模式（Decorator Pattern）</h2><p>装饰模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装。</p><p>我们将创建一个 Shape 接口和实现了 Shape 接口的实体类。然后我们创建一个实现了 Shape 接口的抽象装饰类 ShapeDecorator，并把 Shape 对象作为它的实例变量。RedShapeDecorator 是实现了 ShapeDecorator 的实体类。DecoratorPatternDemo，我们的演示类使用 RedShapeDecorator 来装饰 Shape 对象。UML图如下：<br><img src="https://raw.githubusercontent.com/zhpanvip/images/master/project/article/0202.png" alt="这里写图片描述"><br>1.创建Shape接口</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">public<span class="hljs-built_in"> interface </span>Shape &#123;<br>void draw();<br>&#125;<br></code></pre></td></tr></table></figure><p>2.创建Circle类和Rectangle类并实现Shape接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Circle</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Shape</span> </span>&#123;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> </span>&#123;<br>System.out.println(<span class="hljs-string">&quot;Draw Circle&quot;</span>);<br>&#125;<br><br>&#125;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rectangle</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Shape</span> </span>&#123;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> </span>&#123;<br>System.out.println(<span class="hljs-string">&quot;Draw Rectangle&quot;</span>);<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>3.创建实现了 Shape 接口的抽象装饰类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShapeDecorator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Shape</span> </span>&#123;<br><span class="hljs-keyword">protected</span> Shape decoratedShape;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ShapeDecorator</span><span class="hljs-params">(Shape decoratedShape)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.decoratedShape=decoratedShape;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> </span>&#123;<br>decoratedShape.draw();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>4.创建RedShapeDecorator装饰类并继承ShapeDecorator</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedShapeDecorator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ShapeDecorator</span>  </span>&#123;<br><br>public <span class="hljs-type">RedShapeDecorator</span>(<span class="hljs-type">Shape</span> decoratedShape) &#123;<br><span class="hljs-keyword">super</span>(decoratedShape);<br>&#125;<br><br><span class="hljs-meta">@Override</span><br>public void draw() &#123;<br>decoratedShape.draw();<br>setRedBorder(decoratedShape);<br>&#125;<br><br><span class="hljs-keyword">private</span> void setRedBorder(<span class="hljs-type">Shape</span> decoratedShape) &#123;<br><span class="hljs-type">System</span>.out.println(<span class="hljs-string">&quot;Red Border Corlor&quot;</span>);<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>5.装饰模式测试类</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> DecoratorTest &#123;<br><span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) &#123;<br>Shape <span class="hljs-type">circle</span>=<span class="hljs-built_in">new</span> Circle();<br>Shape redCircle=<span class="hljs-built_in">new</span> RedShapeDecorator(<span class="hljs-built_in">new</span> Circle());<br><br>Shape redRectangle=<span class="hljs-built_in">new</span> RedShapeDecorator(<span class="hljs-built_in">new</span> Rectangle());<br><span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;Circle with normal border&quot;);<br><span class="hljs-type">circle</span>.draw();<br><br><span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;Circle whit red border&quot;);<br>redCircle.draw();<br><br><span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;Rectangle with red border&quot;);<br>redRectangle.draw();<br><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><blockquote><p>Circle with normal border<br>Draw Circle<br>Circle whit red border<br>Draw Circle<br>Red Border Corlor<br>Rectangle with red border<br>Draw Rectangle<br>Red Border Corlor</p></blockquote><h2 id="三、适配器模式"><a href="#三、适配器模式" class="headerlink" title="三、适配器模式"></a>三、适配器模式</h2><p>适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁。这种类型的设计模式属于结构型模式，它结合了两个独立接口的功能。通常来说，在软件开发中，系统的数据和行为都正确，但接口不符合时，我们应该考虑用适配器，目的是使控制范围之外的一个原有对象与某个接口匹配。</p><p>现在假定在我们的应用中使用了两种地图，分别是Google地图和Baidu地图。这两个地图接口对我们而言是隐藏不可修改的，但是由于我们应用的特殊需求，可能会使用两个地图获取位置。那么此时我们就可以用适配器模式来实现。<br>1.当前我们拥有百度地图和Google地图两个接口均可以获取地理位置。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaiduMap</span> &#123;</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">String</span> <span class="hljs-title">getBaiduLocation</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;this is baidu location&quot;</span>;<br>&#125;<br>&#125;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GoogleMap</span> &#123;</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">String</span> <span class="hljs-title">getGoogleLocation</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;this is Google location&quot;</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>2.创建一个Map接口</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">public<span class="hljs-built_in"> interface </span>Map &#123;<br>String getLocation(String mapType);<br>&#125;<br></code></pre></td></tr></table></figure><p>3.创建LocationAdapter实现Map接口</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LocationAdapter</span> <span class="hljs-keyword"><span class="hljs-keyword">implements</span> <span class="hljs-type">Map</span></span> </span>&#123;<br>@Override<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">String</span> getLocation(<span class="hljs-keyword">String</span> mapType) &#123;<br><span class="hljs-keyword">String</span> location=<span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-keyword">switch</span>(mapType) &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;Baidu&quot;</span>:<span class="hljs-type"></span><br><span class="hljs-type">location</span>=<span class="hljs-keyword">new</span> <span class="hljs-type">BaiduMap</span>().getBaiduLocation();<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;Google&quot;</span>:<span class="hljs-type"></span><br><span class="hljs-type">location</span>=<span class="hljs-keyword">new</span> <span class="hljs-type">GoogleMap</span>().getGoogleLocation();<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">return</span> location;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>3.测试适配器模式</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AdapterTest</span> &#123;</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>LocationAdapter adapter=<span class="hljs-keyword">new</span> LocationAdapter();<br>System.out.<span class="hljs-built_in">println</span>(adapter.getLocation(<span class="hljs-string">&quot;Baidu&quot;</span>));<br>System.out.<span class="hljs-built_in">println</span>(adapter.getLocation(<span class="hljs-string">&quot;Google&quot;</span>));<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><blockquote><p>this is baidu location<br>this is Google location</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浅析Java设计模式（一）</title>
    <link href="/2016/07/24/1.Java%20design%20patterns(1)/"/>
    <url>/2016/07/24/1.Java%20design%20patterns(1)/</url>
    
    <content type="html"><![CDATA[<p>设计模式可以分为三大类<br><strong>1.创建型模式</strong> 这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。该类设计模式有五种:</p><ul><li>简单工厂模式（Factory Pattern） </li><li>建造者模式（Builder Pattern）</li><li>单例模式（SingletonPattern）    </li><li>原型模式（Prototype Pattern）</li><li>抽象工厂模式（Abstract Factory Pattern） </li></ul><p><strong>2.结构型模式</strong> 这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。该类模式有五种：</p><ul><li>代理模式（Proxy Pattern）</li><li>装饰器模式（Decorator Pattern）  </li><li>适配器模式（Adapter Pattern）</li><li>组合模式（Composite Pattern）   </li><li>桥接模式（Bridge Pattern）  </li><li>外观模式（FacadePattern）   </li><li>过滤器模式（Filter、CriteriaPattern）  </li></ul><p><strong>3.行为型模式</strong>  这些设计模式特别关注对象之间的通信。</p><ul><li>观察者模式（Observer Pattern）</li><li>中介者模式（Mediator Pattern）</li><li>策略模式（Strategy Pattern）</li><li>责任链模式（Chain of Responsibility Pattern）</li><li>命令模式（Command Pattern）</li><li>解释器模式（Interpreter Pattern）</li><li>迭代器模式（Iterator Pattern）</li><li>备忘录模式（Memento Pattern）</li><li>状态模式（State Pattern）</li><li>空对象模式（Null Object Pattern）</li><li>模板模式（Template Pattern）</li><li>访问者模式（Visitor Pattern）<br>《浅析Java设计模式》将分为三篇分别对三类设计模式中比较常用且典型的几种模式做讲解。本篇文章是第一篇将从创建型模式中挑选简单工厂模式、单例模式以及建造者模式来解析。</li></ul><h2 id="一、简单工厂模式"><a href="#一、简单工厂模式" class="headerlink" title="一、简单工厂模式"></a>一、简单工厂模式</h2><p>简单工厂模式就是建立一个工厂类，对实现了同一接口的一些类进行实例的创建。简单工厂模式的实质是由一个工厂类根据传入的参数，动态决定应该创建哪一个产品类（这些产品类继承自一个父类或接口）的实例。<br>简单工厂模式UML<br>我们以画矩形、三角形以及圆为例，对于三种图形，可以抽象出来一个Shape，它们有共同的draw方法。并且让三种图形均实现Shape接口。简单工厂模式UML图如下所示：<br><img src="https://raw.githubusercontent.com/zhpanvip/images/master/project/article/0101.png" alt="这里写图片描述"><br>1.首先定义Shape接口，接口中有三种图形共有的draw方法：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">public<span class="hljs-built_in"> interface </span>Shape &#123;<br>void draw();<br>&#125;<br></code></pre></td></tr></table></figure><p>2.创建三种形状并实现Shape接口：<br>矩形类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rectangle</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Shape</span> </span>&#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> </span>&#123;<br>System.out.println(<span class="hljs-string">&quot;Draw a Rectangle&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>三角形：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Triangle</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Shape</span> </span>&#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> </span>&#123;<br>System.out.println(<span class="hljs-string">&quot;Draw a Triangle&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>圆形：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Circle</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Shape</span> </span>&#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> </span>&#123;<br>System.out.println(<span class="hljs-string">&quot;Draw a circle&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>3.创建工厂类，并根据参数信息画出对应的图形：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ShapFactory</span> &#123;<br> <span class="hljs-comment">//使用 getShape 方法获取形状类型的对象</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> Shape <span class="hljs-title">getShape</span>(<span class="hljs-params">String shapeType</span>)</span>&#123;<br>      <span class="hljs-keyword">if</span>(shapeType == <span class="hljs-literal">null</span>)&#123;<br>         <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>      &#125;<br>      <span class="hljs-keyword">if</span>(shapeType.<span class="hljs-keyword">equals</span>(<span class="hljs-string">&quot;Circle&quot;</span>))&#123;<br>         <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Circle();<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(shapeType.<span class="hljs-keyword">equals</span>(<span class="hljs-string">&quot;Rectangle&quot;</span>))&#123;<br>         <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Rectangle();<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(shapeType.<span class="hljs-keyword">equals</span>(<span class="hljs-string">&quot;Triangle&quot;</span>))&#123;<br>         <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Triangle();<br>      &#125;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>4.接下来，我们创建一个测试类：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">public class FactoryTest &#123;<br><br>public static void main(String[] args) &#123;<br><span class="hljs-keyword">ShapFactory </span><span class="hljs-keyword">shapFactory </span>= new <span class="hljs-keyword">ShapFactory();</span><br><span class="hljs-keyword"></span><br><span class="hljs-keyword"></span><span class="hljs-keyword">Shape </span><span class="hljs-keyword">shapeCircle </span>= <span class="hljs-keyword">shapFactory.getShape(&quot;Circle&quot;);</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">shapeCircle.draw();</span><br><span class="hljs-keyword"></span><br><span class="hljs-keyword"></span><span class="hljs-keyword">Shape </span><span class="hljs-keyword">shapeRectangle </span>= <span class="hljs-keyword">shapFactory.getShape(&quot;Rectangle&quot;);</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">shapeRectangle.draw();</span><br><span class="hljs-keyword"></span><br><span class="hljs-keyword"></span><span class="hljs-keyword">Shape </span><span class="hljs-keyword">shapeTriangle </span>= <span class="hljs-keyword">shapFactory.getShape(&quot;Triangle&quot;);</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">shapeTriangle.draw();</span><br><span class="hljs-keyword"></span><br><span class="hljs-keyword"></span><span class="hljs-keyword">Shape </span><span class="hljs-keyword">shapeSquare </span>= <span class="hljs-keyword">shapFactory.getShape(&quot;Square&quot;);</span><br><span class="hljs-keyword"></span>if (<span class="hljs-keyword">shapeSquare </span>== null) &#123;<br>System.out.println(<span class="hljs-string">&quot;shapeSquare is null!&quot;</span>);<br>&#125; else &#123;<br><span class="hljs-keyword">shapeSquare.draw();</span><br><span class="hljs-keyword"></span>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p> 输出结果：</p><blockquote><p>Draw a circle<br>Draw a Rectangle<br> Draw a Triangle<br>shapeSquare isnull!</p></blockquote><h2 id="二、单例模式"><a href="#二、单例模式" class="headerlink" title="二、单例模式"></a>二、单例模式</h2><p>单例模式（Singleton Pattern），保证一个类仅有一个实例，并提供一个访问它的全局访问方法。单例模式需要我们把显示定义的构造方法私有化，不允许外部对它实例化。单例模式的结构图如下所示。</p><p><img src="https://raw.githubusercontent.com/zhpanvip/images/master/project/article/0102.png" alt="这里写图片描述"><br><strong>1.一个简单的单例模式实现。</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs routeros">public class Singleton &#123;<br>private static Singleton instance;<br><br>private Singleton() &#123;<br>&#125;<br><br>public static Singleton getInstance() &#123;<br><span class="hljs-keyword">if</span>(<span class="hljs-attribute">instance</span>==null) &#123;<br><span class="hljs-built_in">instance </span>= new Singleton();<br>&#125;<br>return instance;<br>&#125;<br><br>public void openWindow() &#123;<br>System.out.println(<span class="hljs-string">&quot;Open a Window&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面就是一个最简单的单例模式，我们来写一个测试类：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingleTest</span> &#123;</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>Singleton single1=Singleton.getInstance();<br>Singleton single2=Singleton.getInstance();<br>System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;single1.equals(single2)---&quot;</span>+single1.equals(single2));<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><blockquote><p>single1.equals(single2)—true</p></blockquote><p>从输出结果可以看出两次调用getInstance得到的是同一个Singleton 实例。</p><p>上面仅仅是实现单例的一种方式，在调用时实例化对象我们称之为懒汉式，上面的代码有一个弊端，就是不支持多线程调用，在多线程调用的情况下可能会被实例化出多个实例，因此，严格来讲它并不是真正的单例模式！接下来我们继续来看几种单例模式的实现方法，并且来保证它的线程安全。<br><strong>2.线程安全的懒汉式单例模式</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs routeros">public class Singleton &#123;<br>private static Singleton instance;<br><br>private Singleton() &#123;&#125;<br><br>public static synchronized  Singleton getInstance() &#123;<br><span class="hljs-keyword">if</span>(<span class="hljs-attribute">instance</span>==null) &#123;<br><span class="hljs-built_in">instance </span>= new Singleton();<br>&#125;<br>return instance;<br>&#125;<br><br>public void openWindow() &#123;<br>System.out.println(<span class="hljs-string">&quot;Open a Window&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如上代码，我们仅仅在getInstance方法上加了一个synchronized 锁，从而保证了线程的安全。但是我们又不得不考虑一个问题，即每次调用getInstance的时候都会加锁，这种做法势必影响了程序的性能，所以还有待改良。<br><strong>3.双重锁定的单例模式</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> &#123;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span>(<span class="hljs-params"></span>)</span> &#123;<br>&#125;<br><br><span class="hljs-comment">//双重校验锁 线程安全  不用让线程每次都加锁，只有在未实例化时加锁，提高性能。</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton2 <span class="hljs-title">getInstance3</span>(<span class="hljs-params"></span>)</span> &#123;<br><span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<span class="hljs-comment">//先判断实例是否存在，不存在再加锁处理</span><br>synchronized (Singleton2.class) &#123;<br><span class="hljs-keyword">if</span>(instance==<span class="hljs-literal">null</span>) &#123;<br>instance=<span class="hljs-keyword">new</span> Singleton2();<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> instance;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">openWindow</span>(<span class="hljs-params"></span>)</span> &#123;<br>System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;Open a Window&quot;</span>);<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>上述代码中为什么两次判断instance是否为null？假如instance为null并且同时又两个线程调用getInstance()方法，它们将同时通过第一重instance==null的判断。然后由于锁机制，这两个线程只能有一个进入，另一个在外排队等候。等到第一个执行完后另一个线程才能进入。而此时如果没有第二重instance是否为空的判断，则第一个线程创建了实例，而第二个线程还是可以继续创建实例。这样没有达到单例的目的。<br><strong>4.饿汉式实现单例模式</strong><br>前三种我们讲解了懒汉式实现单例。那么还有一种在类加载时就创建对象的单例模式的实现方法我们称之为饿汉式。代码如下：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> &#123;</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance=<span class="hljs-keyword">new</span> Singleton();<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> instance;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">openWindow</span><span class="hljs-params">()</span> </span>&#123;<br>System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;Open a Window&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这种单例模式基于 classloader 机制避免了多线程的同步问题。但因为instance在类加载时就被实例化了，因此存在内存浪费的可能性。</p><h2 id="三、建造者模式"><a href="#三、建造者模式" class="headerlink" title="三、建造者模式"></a>三、建造者模式</h2><p>建造者模式是将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。<br>我们以画卡通人物为例，画一个卡通人物需要完成头、身体、手、腿的绘制。那么，我们就可以抽象出一个IDrawPerson的接口</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IDrawPerson</span> &#123;<br><br> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">drawHead</span>(<span class="hljs-params"></span>)</span>;<br><br> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">drawBody</span>(<span class="hljs-params"></span>)</span>;<br><br> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">drawHand</span>(<span class="hljs-params"></span>)</span>;<br><br> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">drawLeg</span>(<span class="hljs-params"></span>)</span>;<br><br> <span class="hljs-function">Person <span class="hljs-title">buildPerson</span>(<span class="hljs-params"></span>)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来，我想画一个比较瘦的卡通人物，那么定义PersonThinBuilder并实现IDrawPerson类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br><span class="hljs-keyword">private</span> String head;<br><br><span class="hljs-keyword">private</span> String body;<br><br><span class="hljs-keyword">private</span> String hand;<br><br><span class="hljs-keyword">private</span> String leg;<br><br>...  <span class="hljs-comment">//省去get、set方法</span><br>&#125;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PersonThinBuilder</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IDrawPerson</span> </span>&#123;<br><span class="hljs-keyword">private</span> Person mPerson;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PersonThinBuilder</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">super</span>();<br>mPerson=<span class="hljs-keyword">new</span> Person();<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">drawHead</span><span class="hljs-params">()</span> </span>&#123;<br>mPerson.setHead(<span class="hljs-string">&quot;draw head&quot;</span>);<br><br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">drawBody</span><span class="hljs-params">()</span> </span>&#123;<br>mPerson.setBody(<span class="hljs-string">&quot;draw thin body&quot;</span>);<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">drawHand</span><span class="hljs-params">()</span> </span>&#123;<br>mPerson.setHand(<span class="hljs-string">&quot;draa hand&quot;</span>);<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">drawLeg</span><span class="hljs-params">()</span> </span>&#123;<br>mPerson.setLeg(<span class="hljs-string">&quot;draw leg&quot;</span>);<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Person <span class="hljs-title">buildPerson</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> mPerson;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>同样，如果我想再画一个胖人或者高个子都用类似代码实现这个类就可以了。</p><p>接下来看建造者模式中很重要的一个类，指挥者类，用这个类来控制建造过程或者隔离用户与建造过程的关联。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public <span class="hljs-keyword">class</span> PersonDirector &#123;<br>public Person <span class="hljs-constructor">CreatePerson(IDrawPerson <span class="hljs-params">buildPerson</span>)</span> &#123;<br>buildPerson.draw<span class="hljs-constructor">Head()</span>;<br>buildPerson.draw<span class="hljs-constructor">Body()</span>;<br>buildPerson.draw<span class="hljs-constructor">Hand()</span>;<br>buildPerson.draw<span class="hljs-constructor">Leg()</span>;<br>return buildPerson.build<span class="hljs-constructor">Person()</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后来看创建一个建造者模式的测试类：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BuildTest</span> &#123;</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>PersonDirector personDirector=<span class="hljs-keyword">new</span> PersonDirector();<br>Person thinPerson=personDirector.CreatePerson(<span class="hljs-keyword">new</span> PersonThinBuilder());<br>System.out.<span class="hljs-built_in">println</span>(thinPerson.getBody());<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><blockquote><p>draw thin body</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
